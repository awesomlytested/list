{"repo":"plouc/nivo","url":"https://github.com/plouc/nivo","branch":"master","configs":[{"package":"@nivo/annotations","lang":"js","dir":"packages/annotations/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/arcs","lang":"ts","dir":"packages/arcs/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/axes","lang":"js","dir":"packages/axes/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/bar","lang":"js","dir":"packages/bar/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/bullet","lang":"js","dir":"packages/bullet/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/circle-packing","lang":"ts","dir":"packages/circle-packing/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/colors","lang":"js","dir":"packages/colors/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/core","lang":"js","dir":"packages/core/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/funnel","lang":"js","dir":"packages/funnel/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/heatmap","lang":"js","dir":"packages/heatmap/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/legends","lang":"js","dir":"packages/legends/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/line","lang":"js","dir":"packages/line/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/pie","lang":"js","dir":"packages/pie/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/radar","lang":"js","dir":"packages/radar/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/radial-bar","lang":"js","dir":"packages/radial-bar/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/recompose","lang":"ts","dir":"packages/recompose/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/scales","lang":"ts","dir":"packages/scales/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/scatterplot","lang":"js","dir":"packages/scatterplot/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/stream","lang":"js","dir":"packages/stream/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/sunburst","lang":"js","dir":"packages/sunburst/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/swarmplot","lang":"js","dir":"packages/swarmplot/tests","framework":"jest","pattern":"**/*.{js,ts}"},{"package":"@nivo/voronoi","lang":"ts","dir":"packages/voronoi/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@nivo/waffle","lang":"js","dir":"packages/waffle/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"computeArcBoundingBox() for position ,  with radius , starting at °, ending at °","suites":[],"updatePoint":{"line":45,"column":140},"line":45,"code":"    test(`computeArcBoundingBox() for position ${args[0]}, ${args[1]} with radius ${args[2]}, starting at ${args[3]}°, ending at ${args[4]}°`, () => {\n        const box = computeArcBoundingBox(...args)\n\n        for (const prop in expected) {\n            expect(box).toHaveProperty(prop, expected[prop])\n        }\n    })","file":"boundingBox.test.ts","skipped":false,"dir":"packages/arcs/tests"},{"name":"generates a scale from sequential colors ()","suites":["continuous scales from named schemes"],"updatePoint":{"line":10,"column":60,"index":400},"line":10,"code":"    it(`generates a scale from sequential colors (${scheme})`, () => {\n      const colorScale = getContinuousColorScale({\n        type: 'sequential',\n        scheme\n      }, unitInterval);\n      // d3 sequential schemes have 9 colors predefined\n      const schemeColors = colorSchemes[scheme][9];\n      // compare the computed colors and scheme colors at the extrema of the unit interval\n      expect(toHex(colorScale(0))).toBe(schemeColors[0]);\n      expect(toHex(colorScale(1))).toBe(schemeColors[8]);\n    });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"generates a scale from diverging colors ()","suites":["continuous scales from named schemes"],"updatePoint":{"line":23,"column":59,"index":963},"line":23,"code":"    it(`generates a scale from diverging colors (${scheme})`, () => {\n      const colorScale = getContinuousColorScale({\n        type: 'diverging',\n        scheme\n      }, unitInterval);\n      // d3 divergent scales have predefined 11 distinct colors\n      const schemeColors = colorSchemes[scheme][11];\n      // compare the computed colors and scheme colors at the extrema of the unit interval\n      expect(toHex(colorScale(0))).toBe(schemeColors[0]);\n      expect(toHex(colorScale(1))).toBe(schemeColors[10]);\n    });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"generates a sequential scale from custom colors","suites":["continuous scales from custom colors"],"updatePoint":{"line":37,"column":53,"index":1544},"line":37,"code":"  it(`generates a sequential scale from custom colors`, () => {\n    // custom colors in rgb are (68, 0, 0) and (170, 0, 0)\n    const customColors = ['#440000', '#aa0000'];\n    const colorScale = getContinuousColorScale({\n      type: 'sequential',\n      colors: customColors\n    }, unitInterval);\n    expect(toHex(colorScale(0))).toBe(customColors[0]);\n    expect(toHex(colorScale(1))).toBe(customColors[1]);\n    expect(toHex(colorScale(0.5))).toBe('#770000');\n  });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"accepts a sequential scale with custom interpolator","suites":["continuous scales from custom colors"],"updatePoint":{"line":48,"column":57,"index":2014},"line":48,"code":"  it(`accepts a sequential scale with custom interpolator`, () => {\n    const customColors = ['#440000', '#aa0000'];\n    // this interpolator is actually a threshold-like scale\n    const customInterpolator = t => {\n      if (t < 0.4) return customColors[0];\n      return customColors[1];\n    };\n    const colorScale = getContinuousColorScale({\n      type: 'sequential',\n      interpolator: customInterpolator\n    }, unitInterval);\n    expect(toHex(colorScale(0))).toBe(customColors[0]);\n    expect(toHex(colorScale(1))).toBe(customColors[1]);\n    expect(toHex(colorScale(0.39))).toBe(customColors[0]);\n    expect(toHex(colorScale(0.41))).toBe(customColors[1]);\n  });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"generates a divergent scale from custom colors","suites":["continuous scales from custom colors"],"updatePoint":{"line":64,"column":52,"index":2676},"line":64,"code":"  it(`generates a divergent scale from custom colors`, () => {\n    // custom colors in rgb are (68, 0, 0) and (170, 0, 0)\n    const customColors = ['#440000', '#ffffff', '#004400'];\n    const colorScale = getContinuousColorScale({\n      type: 'diverging',\n      colors: customColors\n    }, unitInterval);\n    expect(toHex(colorScale(0))).toBe(customColors[0]);\n    expect(toHex(colorScale(1))).toBe(customColors[2]);\n    expect(toHex(colorScale(0.5))).toBe(customColors[1]);\n  });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"accepts a divergent scale with custom interpolator","suites":["continuous scales from custom colors"],"updatePoint":{"line":75,"column":56,"index":3161},"line":75,"code":"  it(`accepts a divergent scale with custom interpolator`, () => {\n    const customColors = ['#440000', '#ffffff', '#004400'];\n    // this interpolator is actually a threshold-like scale\n    const customInterpolator = t => {\n      if (t < 0.2) return customColors[0];\n      if (t > 0.8) return customColors[2];\n      return customColors[1];\n    };\n    const colorScale = getContinuousColorScale({\n      type: 'diverging',\n      interpolator: customInterpolator\n    }, unitInterval);\n    expect(toHex(colorScale(0))).toBe(customColors[0]);\n    expect(toHex(colorScale(1))).toBe(customColors[2]);\n    expect(toHex(colorScale(0.25))).toBe(customColors[1]);\n    expect(toHex(colorScale(0.75))).toBe(customColors[1]);\n  });","file":"continuousColorScale.test.ts","skipped":false,"dir":"packages/colors/tests"},{"name":"should accept user defined function","suites":[],"updatePoint":{"line":11,"column":39,"index":351},"line":11,"code":"it(`should accept user defined function`, () => {\n  const userFunction = datum => datum.color;\n  const getColor = getInheritedColorGenerator(userFunction);\n  expect(getColor({\n    color: 'red'\n  })).toBe('red');\n});","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if an object is given but doesn't match theme or inheritance","suites":[],"updatePoint":{"line":18,"column":77,"index":605},"line":18,"code":"it(`should throw if an object is given but doesn't match theme or inheritance`, () => {\n  expect(() => {\n    getInheritedColorGenerator({});\n  }).toThrow(`Invalid color spec, you should either specify 'theme' or 'from' when using a config object`);\n});","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to use a theme property","suites":["from theme"],"updatePoint":{"line":24,"column":44,"index":856},"line":24,"code":"  it(`should be able to use a theme property`, () => {\n    const theme = {\n      thing: {\n        color: 'green'\n      }\n    };\n    const getColor = getInheritedColorGenerator({\n      theme: 'thing.color'\n    }, theme);\n    expect(getColor()).toBe('green');\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if no theme is provided","suites":["from theme"],"updatePoint":{"line":35,"column":42,"index":1118},"line":35,"code":"  it(`should throw if no theme is provided`, () => {\n    expect(() => {\n      getInheritedColorGenerator({\n        theme: 'color'\n      });\n    }).toThrow('Unable to use color from theme as no theme was provided');\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if theme property is undefined","suites":["from theme"],"updatePoint":{"line":42,"column":49,"index":1346},"line":42,"code":"  it(`should throw if theme property is undefined`, () => {\n    expect(() => {\n      getInheritedColorGenerator({\n        theme: 'color'\n      }, {});\n    }).toThrow(`Color from theme is undefined at path: 'color'`);\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to use color from datum","suites":["from datum"],"updatePoint":{"line":51,"column":44,"index":1599},"line":51,"code":"  it(`should be able to use color from datum`, () => {\n    const getColor = getInheritedColorGenerator({\n      from: 'data.color'\n    });\n    expect(getColor({\n      data: {\n        color: 'purple'\n      }\n    })).toBe('purple');\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to apply a brighter modifier on inherited color","suites":["from datum"],"updatePoint":{"line":61,"column":68,"index":1859},"line":61,"code":"  it(`should be able to apply a brighter modifier on inherited color`, () => {\n    const getColor = getInheritedColorGenerator({\n      from: 'color',\n      modifiers: [['brighter', 1]]\n    });\n    expect(getColor({\n      color: '#ff0099'\n    })).toBe(rgb('#ff0099').brighter(1).toString());\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to apply a darker modifier on inherited color","suites":["from datum"],"updatePoint":{"line":70,"column":66,"index":2154},"line":70,"code":"  it(`should be able to apply a darker modifier on inherited color`, () => {\n    const getColor = getInheritedColorGenerator({\n      from: 'color',\n      modifiers: [['darker', 1]]\n    });\n    expect(getColor({\n      color: '#ff0099'\n    })).toBe(rgb('#ff0099').darker(1).toString());\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to apply an opacity modifier on inherited color","suites":["from datum"],"updatePoint":{"line":79,"column":68,"index":2447},"line":79,"code":"  it(`should be able to apply an opacity modifier on inherited color`, () => {\n    const getColor = getInheritedColorGenerator({\n      from: 'color',\n      modifiers: [['opacity', 0.5]]\n    });\n    const expectedColor = rgb('#ff0099');\n    expectedColor.opacity = 0.5;\n    expect(getColor({\n      color: '#ff0099'\n    })).toBe(expectedColor.toString());\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to chain several modifiers on inherited color","suites":["from datum"],"updatePoint":{"line":90,"column":66,"index":2805},"line":90,"code":"  it(`should be able to chain several modifiers on inherited color`, () => {\n    const getColor = getInheritedColorGenerator({\n      from: 'color',\n      modifiers: [['darker', 2], ['opacity', 0.5]]\n    });\n    const expectedColor = rgb('#ff0099').darker(2);\n    expectedColor.opacity = 0.5;\n    expect(getColor({\n      color: '#ff0099'\n    })).toBe(expectedColor.toString());\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if modifier type is invalid","suites":["from datum"],"updatePoint":{"line":101,"column":46,"index":3168},"line":101,"code":"  it(`should throw if modifier type is invalid`, () => {\n    expect(() => {\n      getInheritedColorGenerator({\n        from: 'color',\n        modifiers: [['invalid']]\n      });\n    }).toThrow(`Invalid color modifier: 'invalid', must be one of: 'brighter', 'darker', 'opacity'`);\n  });","file":"inheritedColor.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should accept user defined function","suites":[],"updatePoint":{"line":10,"column":39,"index":405},"line":10,"code":"it(`should accept user defined function`, () => {\n  const userFunction = () => 'red';\n  const colorScale = getOrdinalColorScale(userFunction);\n  expect(colorScale).toBe(userFunction);\n  expect(colorScale()).toBe('red');\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a generator which use data color","suites":[],"updatePoint":{"line":16,"column":63,"index":653},"line":16,"code":"it(`should be able to generate a generator which use data color`, () => {\n  const colorScale = getOrdinalColorScale({\n    datum: 'color'\n  });\n  expect(colorScale({\n    color: 'green'\n  })).toBe('green');\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should accept user defined color array","suites":[],"updatePoint":{"line":24,"column":42,"index":841},"line":24,"code":"it(`should accept user defined color array`, () => {\n  const colors = ['purple', 'green', 'blue'];\n  const colorScale = getOrdinalColorScale(colors, 'id');\n  expect(colorScale.scale.range()).toEqual(colors);\n  expect(colorScale({\n    id: 'whatever'\n  })).toBe('purple');\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a scale from categorical colors ()","suites":[],"updatePoint":{"line":33,"column":76,"index":1196},"line":33,"code":"  it(`should be able to generate a scale from categorical colors (${scheme})`, () => {\n    const colorScale = getOrdinalColorScale({\n      scheme\n    }, 'id');\n    expect(colorScale.scale.range()).toEqual(colorSchemes[scheme]);\n    expect(colorScale({\n      id: 'whatever'\n    })).toBe(colorSchemes[scheme][0]);\n  });","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a scale from diverging colors ()","suites":[],"updatePoint":{"line":44,"column":74,"index":1560},"line":44,"code":"  it(`should be able to generate a scale from diverging colors (${scheme})`, () => {\n    const colorScale = getOrdinalColorScale({\n      scheme\n    }, 'id');\n    expect(colorScale.scale.range()).toEqual(colorSchemes[scheme][11]);\n    expect(colorScale({\n      id: 'whatever'\n    })).toBe(colorSchemes[scheme][11][0]);\n  });","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a scale from diverging colors with a specific size ()","suites":[],"updatePoint":{"line":55,"column":95,"index":1953},"line":55,"code":"  it(`should be able to generate a scale from diverging colors with a specific size (${scheme})`, () => {\n    const colorScale = getOrdinalColorScale({\n      scheme,\n      size: 5\n    });\n    expect(colorScale.scale.range()).toEqual(colorSchemes[scheme][5]);\n    expect(colorScale('whatever')).toBe(colorSchemes[scheme][5][0]);\n  });","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if trying to generate a scale from diverging colors with a size lower than 3","suites":[],"updatePoint":{"line":64,"column":93,"index":2289},"line":64,"code":"it(`should throw if trying to generate a scale from diverging colors with a size lower than 3`, () => {\n  expect(() => {\n    getOrdinalColorScale({\n      scheme: divergingColorSchemeIds[0],\n      size: 2\n    });\n  }).toThrow(`Invalid size '2' for diverging color scheme '${divergingColorSchemeIds[0]}', must be between 3~11`);\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if trying to generate a scale from diverging colors with a size greater than 11","suites":[],"updatePoint":{"line":72,"column":96,"index":2623},"line":72,"code":"it(`should throw if trying to generate a scale from diverging colors with a size greater than 11`, () => {\n  expect(() => {\n    getOrdinalColorScale({\n      scheme: divergingColorSchemeIds[0],\n      size: 13\n    });\n  }).toThrow(`Invalid size '13' for diverging color scheme '${divergingColorSchemeIds[0]}', must be between 3~11`);\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a scale from sequential colors ()","suites":[],"updatePoint":{"line":81,"column":75,"index":2983},"line":81,"code":"  it(`should be able to generate a scale from sequential colors (${scheme})`, () => {\n    const colorScale = getOrdinalColorScale({\n      scheme\n    });\n    expect(colorScale.scale.range()).toEqual(colorSchemes[scheme][9]);\n    expect(colorScale('whatever')).toBe(colorSchemes[scheme][9][0]);\n  });","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should be able to generate a scale from sequential colors with a specific size ()","suites":[],"updatePoint":{"line":90,"column":96,"index":3352},"line":90,"code":"  it(`should be able to generate a scale from sequential colors with a specific size (${scheme})`, () => {\n    const colorScale = getOrdinalColorScale({\n      scheme,\n      size: 5\n    });\n    expect(colorScale.scale.range()).toEqual(colorSchemes[scheme][5]);\n    expect(colorScale('whatever')).toBe(colorSchemes[scheme][5][0]);\n  });","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if trying to generate a scale from sequential colors with a size lower than 3","suites":[],"updatePoint":{"line":99,"column":94,"index":3689},"line":99,"code":"it(`should throw if trying to generate a scale from sequential colors with a size lower than 3`, () => {\n  expect(() => {\n    getOrdinalColorScale({\n      scheme: sequentialColorSchemeIds[0],\n      size: 2\n    });\n  }).toThrow(`Invalid size '2' for sequential color scheme '${sequentialColorSchemeIds[0]}', must be between 3~9`);\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if trying to generate a scale from sequential colors with a size greater than 9","suites":[],"updatePoint":{"line":107,"column":96,"index":4025},"line":107,"code":"it(`should throw if trying to generate a scale from sequential colors with a size greater than 9`, () => {\n  expect(() => {\n    getOrdinalColorScale({\n      scheme: sequentialColorSchemeIds[0],\n      size: 11\n    });\n  }).toThrow(`Invalid size '11' for sequential color scheme '${sequentialColorSchemeIds[0]}', must be between 3~9`);\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should throw if an object is given but doesn't match datum or scheme","suites":[],"updatePoint":{"line":115,"column":72,"index":4339},"line":115,"code":"it(`should throw if an object is given but doesn't match datum or scheme`, () => {\n  expect(() => {\n    getOrdinalColorScale({});\n  }).toThrow(`Invalid colors, when using an object, you should either pass a 'datum' or a 'scheme' property`);\n});","file":"ordinalColorScale.test.js","skipped":false,"dir":"packages/colors/tests"},{"name":"should add default margin","suites":[],"updatePoint":{"line":12,"column":29,"index":402},"line":12,"code":"it('should add default margin', () => {\n  const Sample = withDimensions()('div');\n  const div = shallow( /*#__PURE__*/React.createElement(Sample, {\n    width: 300,\n    height: 200\n  })).dive().find('div');\n  expect(div.prop('margin')).toEqual(defaultMargin);\n});","file":"hocs/withDimensions.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should compute inner and outer dimensions","suites":[],"updatePoint":{"line":20,"column":45,"index":681},"line":20,"code":"it('should compute inner and outer dimensions', () => {\n  const Sample = withDimensions()('div');\n  const div = shallow( /*#__PURE__*/React.createElement(Sample, {\n    width: 300,\n    height: 200,\n    margin: {\n      top: 50,\n      right: 20,\n      bottom: 50,\n      left: 20\n    }\n  })).dive().find('div');\n  expect(div.prop('outerWidth')).toBe(300);\n  expect(div.prop('outerHeight')).toBe(200);\n  expect(div.prop('width')).toBe(260);\n  expect(div.prop('height')).toBe(100);\n});","file":"hocs/withDimensions.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should accept an existing color scale","suites":["guessQuantizeColorScale()"],"updatePoint":{"line":11,"column":43,"index":392},"line":11,"code":"  it('should accept an existing color scale', () => {\n    const existingColorScale = () => {};\n    existingColorScale.domain = () => {};\n    const colorScale = guessQuantizeColorScale(existingColorScale);\n    expect(colorScale).toEqual(existingColorScale);\n  });","file":"lib/colors/quantize.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should not accept a function not providing a domain function","suites":["guessQuantizeColorScale()"],"updatePoint":{"line":17,"column":66,"index":678},"line":17,"code":"  it('should not accept a function not providing a domain function', () => {\n    expect(() => {\n      guessQuantizeColorScale(() => {});\n    }).toThrow(/Provided colors should be a valid quantize scale providing a 'domain\\(\\)' function/);\n  });","file":"lib/colors/quantize.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should accept d3 colors key","suites":["guessQuantizeColorScale()"],"updatePoint":{"line":22,"column":33,"index":890},"line":22,"code":"  it('should accept d3 colors key', () => {\n    const colorScale = guessQuantizeColorScale('BuGn');\n    expect(colorScale.range()).toEqual(['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b']);\n  });","file":"lib/colors/quantize.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should accept custom colors","suites":["guessQuantizeColorScale()"],"updatePoint":{"line":26,"column":33,"index":1137},"line":26,"code":"  it('should accept custom colors', () => {\n    const colors = ['#F00', '#0F0', '#00F'];\n    const colorScale = guessQuantizeColorScale(colors);\n    expect(colorScale.range()).toEqual(colors);\n  });","file":"lib/colors/quantize.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should throw if directive is invalid","suites":["guessQuantizeColorScale()"],"updatePoint":{"line":31,"column":42,"index":1345},"line":31,"code":"  it('should throw if directive is invalid', () => {\n    expect(() => {\n      guessQuantizeColorScale('invalid');\n    }).toThrow(/Unable to guess quantize color scale from 'invalid'/);\n  });","file":"lib/colors/quantize.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should support wildcard","suites":["isMatchingDef()"],"updatePoint":{"line":12,"column":29,"index":392},"line":12,"code":"  it('should support wildcard', () => {\n    const matcher = partial(isMatchingDef, '*');\n    expect(matcher()).toBe(true);\n    expect(matcher(null)).toBe(true);\n    expect(matcher({})).toBe(true);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should support predicate function","suites":["isMatchingDef()"],"updatePoint":{"line":18,"column":39,"index":605},"line":18,"code":"  it('should support predicate function', () => {\n    const matcher = partial(isMatchingDef, node => node.id === 'test');\n    expect(matcher({})).toBe(false);\n    expect(matcher({\n      id: 'other'\n    })).toBe(false);\n    expect(matcher({\n      id: 'test'\n    })).toBe(true);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should allow to check multiple fields at once","suites":["isMatchingDef()","using query object"],"updatePoint":{"line":29,"column":53,"index":943},"line":29,"code":"    it('should allow to check multiple fields at once', () => {\n      const matcher = partial(isMatchingDef, {\n        id: 'test',\n        isFake: true\n      });\n      expect(matcher({})).toBe(false);\n      expect(matcher({\n        id: 'other',\n        isFake: true\n      })).toBe(false);\n      expect(matcher({\n        id: 'test',\n        isFake: true\n      })).toBe(true);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should allow to use customize path to access node data","suites":["isMatchingDef()","using query object"],"updatePoint":{"line":44,"column":62,"index":1335},"line":44,"code":"    it('should allow to use customize path to access node data', () => {\n      const matcher = partial(isMatchingDef, {\n        id: 'test'\n      });\n      expect(matcher({}, 'custom')).toBe(false);\n      expect(matcher({\n        id: 'test'\n      }, 'custom')).toBe(false);\n      expect(matcher({\n        custom: {\n          id: 'other'\n        }\n      }, 'custom')).toBe(false);\n      expect(matcher({\n        custom: {\n          id: 'test'\n        }\n      }, 'custom')).toBe(true);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return false otherwise","suites":["isMatchingDef()","using query object"],"updatePoint":{"line":64,"column":35,"index":1805},"line":64,"code":"  it('should return false otherwise', () => {\n    expect(isMatchingDef()).toBe(false);\n    expect(isMatchingDef(2)).toBe(false);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return an empty array if def list is empty","suites":["bindDefs()"],"updatePoint":{"line":70,"column":55,"index":1995},"line":70,"code":"  it('should return an empty array if def list is empty', () => {\n    expect(bindDefs([], [{}], [{}])).toEqual([]);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return an empty array if node list is empty","suites":["bindDefs()"],"updatePoint":{"line":73,"column":56,"index":2118},"line":73,"code":"  it('should return an empty array if node list is empty', () => {\n    expect(bindDefs([{}], [], [{}])).toEqual([]);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return input defs if rule list is empty","suites":["bindDefs()"],"updatePoint":{"line":76,"column":52,"index":2237},"line":76,"code":"  it('should return input defs if rule list is empty', () => {\n    const defs = [{\n      type: 'whatever'\n    }];\n    expect(bindDefs(defs, [{}], [])).toEqual(defs);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should ignore subsequent rules if some already matched","suites":["bindDefs()"],"updatePoint":{"line":82,"column":60,"index":2417},"line":82,"code":"  it('should ignore subsequent rules if some already matched', () => {\n    const defs = [{\n      id: 'gradient',\n      type: 'linearGradient',\n      colors: []\n    }, {\n      id: 'pattern',\n      type: 'patternLines'\n    }];\n    const nodes = [{\n      id: 'test'\n    }];\n    expect(bindDefs(defs, nodes, [{\n      match: {\n        id: 'test'\n      },\n      id: 'gradient'\n    }, {\n      match: '*',\n      id: 'pattern'\n    }])).toEqual(defs);\n    expect(nodes).toEqual([{\n      id: 'test',\n      fill: 'url(#gradient)'\n    }]);\n  });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should apply def ID to all matching nodes and returns original defs if no inheritance involved","suites":["bindDefs()","using patterns"],"updatePoint":{"line":109,"column":102,"index":3029},"line":109,"code":"    it('should apply def ID to all matching nodes and returns original defs if no inheritance involved', () => {\n      const defs = [{\n        id: 'lines',\n        type: 'patternLines'\n      }];\n      const nodes = [{}, {}];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'lines'\n      }]);\n      expect(boundDefs).toEqual(defs);\n      expect(nodes).toEqual([{\n        fill: 'url(#lines)'\n      }, {\n        fill: 'url(#lines)'\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should allow targetKey to be customized","suites":["bindDefs()","using patterns"],"updatePoint":{"line":126,"column":47,"index":3455},"line":126,"code":"    it('should allow targetKey to be customized', () => {\n      const defs = [{\n        id: 'lines',\n        type: 'patternLines'\n      }];\n      const nodes = [{}, {}];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'lines'\n      }], {\n        targetKey: 'style.fill'\n      });\n      expect(boundDefs).toEqual(defs);\n      expect(nodes).toEqual([{\n        style: {\n          fill: 'url(#lines)'\n        }\n      }, {\n        style: {\n          fill: 'url(#lines)'\n        }\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should support inheritance","suites":["bindDefs()","using patterns"],"updatePoint":{"line":149,"column":34,"index":3969},"line":149,"code":"    it('should support inheritance', () => {\n      const defs = [{\n        id: 'lines.inheritBackground',\n        type: 'patternLines',\n        background: 'inherit'\n      }, {\n        id: 'lines.inheritColor',\n        type: 'patternLines',\n        color: 'inherit'\n      }];\n      const nodes = [{\n        id: 'inheritBackground',\n        color: '#000'\n      }, {\n        id: 'inheritColor',\n        color: '#F00'\n      }];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: {\n          id: 'inheritBackground'\n        },\n        id: 'lines.inheritBackground'\n      }, {\n        match: {\n          id: 'inheritColor'\n        },\n        id: 'lines.inheritColor'\n      }]);\n      expect(boundDefs).toEqual([...defs, {\n        id: 'lines.inheritBackground.bg.#000',\n        type: 'patternLines',\n        background: '#000'\n      }, {\n        id: 'lines.inheritColor.fg.#F00',\n        type: 'patternLines',\n        color: '#F00'\n      }]);\n      expect(nodes).toEqual([{\n        id: 'inheritBackground',\n        color: '#000',\n        fill: 'url(#lines.inheritBackground.bg.#000)'\n      }, {\n        id: 'inheritColor',\n        color: '#F00',\n        fill: 'url(#lines.inheritColor.fg.#F00)'\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should apply def ID to all matching nodes and returns original defs if no inheritance involved","suites":["bindDefs()","using gradients"],"updatePoint":{"line":198,"column":102,"index":5302},"line":198,"code":"    it('should apply def ID to all matching nodes and returns original defs if no inheritance involved', () => {\n      const defs = [{\n        id: 'gradient',\n        type: 'linearGradient',\n        colors: []\n      }];\n      const nodes = [{}, {}];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'gradient'\n      }]);\n      expect(boundDefs).toEqual(defs);\n      expect(nodes).toEqual([{\n        fill: 'url(#gradient)'\n      }, {\n        fill: 'url(#gradient)'\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should allow targetKey to be customized","suites":["bindDefs()","using gradients"],"updatePoint":{"line":216,"column":47,"index":5762},"line":216,"code":"    it('should allow targetKey to be customized', () => {\n      const defs = [{\n        id: 'gradient',\n        type: 'linearGradient',\n        colors: []\n      }];\n      const nodes = [{}, {}];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'gradient'\n      }], {\n        targetKey: 'style.fill'\n      });\n      expect(boundDefs).toEqual(defs);\n      expect(nodes).toEqual([{\n        style: {\n          fill: 'url(#gradient)'\n        }\n      }, {\n        style: {\n          fill: 'url(#gradient)'\n        }\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should allow gradientTransform to be used","suites":["bindDefs()","using gradients"],"updatePoint":{"line":240,"column":49,"index":6325},"line":240,"code":"    it('should allow gradientTransform to be used', () => {\n      const defs = [{\n        id: 'gradient',\n        type: 'linearGradient',\n        colors: [],\n        gradientTransform: 'rotate(90 0.5 0.5)'\n      }];\n      const nodes = [{}, {}];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'gradient'\n      }], {\n        targetKey: 'style.fill'\n      });\n      expect(boundDefs).toEqual(defs);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should support inheritance","suites":["bindDefs()","using gradients"],"updatePoint":{"line":256,"column":34,"index":6749},"line":256,"code":"    it('should support inheritance', () => {\n      const defs = [{\n        id: 'gradient',\n        type: 'linearGradient',\n        colors: [{\n          offset: 0,\n          color: 'inherit',\n          opacity: 0\n        }, {\n          offset: 100,\n          color: 'inherit'\n        }]\n      }];\n      const nodes = [{\n        color: '#000'\n      }, {\n        color: '#F00'\n      }];\n      const boundDefs = bindDefs(defs, nodes, [{\n        match: '*',\n        id: 'gradient'\n      }]);\n      expect(boundDefs).toEqual([...defs, {\n        id: 'gradient.0.#000.1.#000',\n        type: 'linearGradient',\n        colors: [{\n          offset: 0,\n          color: '#000',\n          opacity: 0\n        }, {\n          offset: 100,\n          color: '#000'\n        }]\n      }, {\n        id: 'gradient.0.#F00.1.#F00',\n        type: 'linearGradient',\n        colors: [{\n          offset: 0,\n          color: '#F00',\n          opacity: 0\n        }, {\n          offset: 100,\n          color: '#F00'\n        }]\n      }]);\n      expect(nodes).toEqual([{\n        color: '#000',\n        fill: 'url(#gradient.0.#000.1.#000)'\n      }, {\n        color: '#F00',\n        fill: 'url(#gradient.0.#F00.1.#F00)'\n      }]);\n    });","file":"lib/defs.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle simple value access","suites":["getLabelGenerator()"],"updatePoint":{"line":3,"column":39,"index":152},"line":3,"code":"  it(`should handle simple value access`, () => {\n    const getLabel = getLabelGenerator('value');\n    expect(getLabel({\n      value: 12\n    })).toBe(12);\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle nested property access","suites":["getLabelGenerator()"],"updatePoint":{"line":9,"column":42,"index":316},"line":9,"code":"  it(`should handle nested property access`, () => {\n    const getLabel = getLabelGenerator('node.value');\n    expect(getLabel({\n      node: {\n        value: 13\n      }\n    })).toBe(13);\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle simple access with d3 formatting","suites":["getLabelGenerator()"],"updatePoint":{"line":17,"column":52,"index":519},"line":17,"code":"  it(`should handle simple access with d3 formatting`, () => {\n    const getLabel = getLabelGenerator('value', '.1f');\n    expect(getLabel({\n      value: 14\n    })).toBe('14.0');\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle simple access with d3 formatting","suites":["getLabelGenerator()"],"updatePoint":{"line":23,"column":52,"index":704},"line":23,"code":"  it(`should handle simple access with d3 formatting`, () => {\n    const getLabel = getLabelGenerator('value', '.1f');\n    expect(getLabel({\n      value: 14\n    })).toBe('14.0');\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle custom access function","suites":["getLabelGenerator()"],"updatePoint":{"line":29,"column":42,"index":879},"line":29,"code":"  it(`should handle custom access function`, () => {\n    const getLabel = getLabelGenerator(d => d.value[0]);\n    expect(getLabel({\n      value: [15, 16]\n    })).toBe(15);\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle custom formatting function","suites":["getLabelGenerator()"],"updatePoint":{"line":35,"column":46,"index":1061},"line":35,"code":"  it(`should handle custom formatting function`, () => {\n    const getLabel = getLabelGenerator('value', v => v + 10);\n    expect(getLabel({\n      value: 17\n    })).toBe(27);\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should handle custom access & formatting functions","suites":["getLabelGenerator()"],"updatePoint":{"line":41,"column":56,"index":1252},"line":41,"code":"  it(`should handle custom access & formatting functions`, () => {\n    const getLabel = getLabelGenerator(d => d.value[1], v => v + 10);\n    expect(getLabel({\n      value: [18, 19]\n    })).toBe(29);\n  });","file":"lib/getLabelGenerator.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return true if x/y positions are in given rect","suites":["isCursorInRect()"],"updatePoint":{"line":11,"column":59,"index":395},"line":11,"code":"  it('should return true if x/y positions are in given rect', () => {\n    expect(isCursorInRect(10, 10, 20, 20, 20, 20)).toBe(true);\n  });","file":"lib/interactivity/detect.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should return false if x/y positions are not in given rect","suites":["isCursorInRect()"],"updatePoint":{"line":14,"column":64,"index":539},"line":14,"code":"  it('should return false if x/y positions are not in given rect', () => {\n    expect(isCursorInRect(10, 10, 20, 20, 40, 40)).toBe(false);\n  });","file":"lib/interactivity/detect.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"midAngle() should compute center of given angles","suites":[],"updatePoint":{"line":2,"column":54,"index":134},"line":2,"code":"test('midAngle() should compute center of given angles', () => {\n  expect(midAngle({\n    startAngle: 0,\n    endAngle: 90\n  })).toBe(45);\n});","file":"lib/polar/utils.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"absoluteAngleDegrees() should convert ° to °","suites":[],"updatePoint":{"line":29,"column":71,"index":606},"line":29,"code":"  test(`absoluteAngleDegrees() should convert ${input}° to ${expected}°`, () => {\n    expect(absoluteAngleDegrees(input)).toBe(expected);\n  });","file":"lib/polar/utils.test.js","skipped":false,"dir":"packages/core/tests"},{"name":"should render a basic line chart","suites":[],"updatePoint":{"line":6,"column":36,"index":224},"line":6,"code":"it('should render a basic line chart', () => {\n  const data = [{\n    id: 'A',\n    data: [{\n      x: 0,\n      y: 3\n    }, {\n      x: 1,\n      y: 7\n    }, {\n      x: 2,\n      y: 11\n    }, {\n      x: 3,\n      y: 9\n    }, {\n      x: 4,\n      y: 8\n    }]\n  }];\n  const component = renderer.create( /*#__PURE__*/React.createElement(Line, {\n    width: 500,\n    height: 300,\n    data: data,\n    animate: false\n  }));\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});","file":"Line.test.js","skipped":false,"dir":"packages/line/tests"},{"name":"should support multiple lines","suites":[],"updatePoint":{"line":35,"column":33,"index":701},"line":35,"code":"it('should support multiple lines', () => {\n  const data = [{\n    id: 'A',\n    data: [{\n      x: 0,\n      y: 3\n    }, {\n      x: 1,\n      y: 7\n    }, {\n      x: 2,\n      y: 11\n    }, {\n      x: 3,\n      y: 9\n    }, {\n      x: 4,\n      y: 8\n    }]\n  }, {\n    id: 'B',\n    data: [{\n      x: 0,\n      y: 1\n    }, {\n      x: 1,\n      y: 3\n    }, {\n      x: 2,\n      y: 5\n    }, {\n      x: 3,\n      y: 7\n    }, {\n      x: 4,\n      y: 11\n    }]\n  }];\n  const component = renderer.create( /*#__PURE__*/React.createElement(Line, {\n    width: 500,\n    height: 300,\n    data: data,\n    animate: false\n  }));\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});","file":"Line.test.js","skipped":false,"dir":"packages/line/tests"},{"name":"should create slice for each x value","suites":[],"updatePoint":{"line":82,"column":40,"index":1377},"line":82,"code":"it('should create slice for each x value', () => {\n  const data = [{\n    id: 'A',\n    data: [{\n      x: 0,\n      y: 3\n    }, {\n      x: 1,\n      y: 7\n    }, {\n      x: 2,\n      y: 11\n    }, {\n      x: 3,\n      y: 9\n    }, {\n      x: 4,\n      y: 8\n    }]\n  }];\n  const wrapper = mount( /*#__PURE__*/React.createElement(Line, {\n    width: 500,\n    height: 300,\n    data: data,\n    enableSlices: \"x\",\n    animate: false\n  }));\n  const slices = wrapper.find(SlicesItem);\n  expect(slices).toHaveLength(5);\n  expect(slices.at(0).prop('slice').id).toBe(0);\n  expect(slices.at(1).prop('slice').id).toBe(125);\n  expect(slices.at(2).prop('slice').id).toBe(250);\n  expect(slices.at(3).prop('slice').id).toBe(375);\n  expect(slices.at(4).prop('slice').id).toBe(500);\n});","file":"Line.test.js","skipped":false,"dir":"packages/line/tests"},{"name":"should have left and bottom axis by default","suites":[],"updatePoint":{"line":117,"column":47,"index":2142},"line":117,"code":"it('should have left and bottom axis by default', () => {\n  const data = [{\n    id: 'A',\n    data: [{\n      x: 0,\n      y: 3\n    }, {\n      x: 1,\n      y: 7\n    }, {\n      x: 2,\n      y: 11\n    }, {\n      x: 3,\n      y: 9\n    }, {\n      x: 4,\n      y: 8\n    }]\n  }];\n  const wrapper = mount( /*#__PURE__*/React.createElement(Line, {\n    width: 500,\n    height: 300,\n    data: data,\n    animate: false\n  }));\n  const axes = wrapper.find(Axis);\n  expect(axes).toHaveLength(2);\n  expect(axes.at(0).prop('axis')).toBe('x');\n  expect(axes.at(1).prop('axis')).toBe('y');\n});","file":"Line.test.js","skipped":false,"dir":"packages/line/tests"},{"name":"should support  curve interpolation","suites":["curve interpolation"],"updatePoint":{"line":170,"column":64,"index":3190},"line":170,"code":"    it(`should support ${curveInterpolation} curve interpolation`, () => {\n      const component = renderer.create( /*#__PURE__*/React.createElement(Line, {\n        width: 500,\n        height: 300,\n        data: data,\n        curve: curveInterpolation,\n        axisLeft: undefined,\n        axisBottom: undefined,\n        isInteractive: false,\n        enableStackTooltip: false,\n        animate: false,\n        enableDots: false,\n        enableGridX: false,\n        enableGridY: false\n      }));\n      const tree = component.toJSON();\n      expect(tree).toMatchSnapshot();\n    });","file":"Line.test.js","skipped":false,"dir":"packages/line/tests"},{"name":"compose composes from right to left","suites":[],"updatePoint":{"line":3,"column":41},"line":3,"code":"test('compose composes from right to left', () => {\n    const double = (x: number) => x * 2\n    const square = (x: number) => x * x\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose(square)(5)).toBe(25)\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose(square, double)(5)).toBe(100)\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose(double, square, double)(5)).toBe(200)\n})","file":"compose.test.ts","skipped":false,"dir":"packages/recompose/tests"},{"name":"compose can be seeded with multiple arguments","suites":[],"updatePoint":{"line":14,"column":51},"line":14,"code":"test('compose can be seeded with multiple arguments', () => {\n    const square = (x: number) => x * x\n    const add = (x: number, y: number) => x + y\n    expect(compose(square, add)(1, 2)).toBe(9)\n})","file":"compose.test.ts","skipped":false,"dir":"packages/recompose/tests"},{"name":"compose returns the identity function if given no arguments","suites":[],"updatePoint":{"line":20,"column":65},"line":20,"code":"test('compose returns the identity function if given no arguments', () => {\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose()(1, 2)).toBe(1)\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose()(3)).toBe(3)\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose()()).toBe(undefined)\n})","file":"compose.test.ts","skipped":false,"dir":"packages/recompose/tests"},{"name":"compose returns the first function if given only one","suites":[],"updatePoint":{"line":29,"column":58},"line":29,"code":"test('compose returns the first function if given only one', () => {\n    const fn = (x: number) => x * x\n    // @ts-expect-error not entirely sure why ts is complaining tbh\n    expect(compose(fn)(3)).toBe(fn(3))\n})","file":"compose.test.ts","skipped":false,"dir":"packages/recompose/tests"},{"name":"should compute values for point scale","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":46,"column":53},"line":46,"code":"            it('should compute values for point scale', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    { data: { [axis]: 'a' } },\n                                    { data: { [axis]: 'b' } },\n                                    { data: { [axis]: 'c' } },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    { data: { [axis]: 'c' } },\n                                    { data: { [axis]: 'd' } },\n                                    { data: { [axis]: 'e' } },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'point' }\n                    )\n                ).toEqual(pointScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should compute values for linear scale","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":73,"column":54},"line":73,"code":"            it('should compute values for linear scale', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    { data: { [axis]: 0 } },\n                                    { data: { [axis]: '1' } },\n                                    { data: { [axis]: '02' } },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    { data: { [axis]: 2 } },\n                                    { data: { [axis]: '3' } },\n                                    { data: { [axis]: '04' } },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'linear' }\n                    )\n                ).toEqual(linearScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should sort values for linear scale","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":100,"column":51},"line":100,"code":"            it('should sort values for linear scale', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    { data: { [axis]: '1' } },\n                                    { data: { [axis]: '02' } },\n                                    { data: { [axis]: 0 } },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    { data: { [axis]: '04' } },\n                                    { data: { [axis]: 2 } },\n                                    { data: { [axis]: '3' } },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'linear' }\n                    )\n                ).toEqual(linearScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should filter null values (holes) for linear scale","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":127,"column":66},"line":127,"code":"            it('should filter null values (holes) for linear scale', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    { data: { [axis]: '2' } },\n                                    { data: { [axis]: '04' } },\n                                    { data: { [axis]: null } },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    { data: { [axis]: '04' } },\n                                    { data: { [axis]: 2 } },\n                                    { data: { [axis]: '3' } },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'linear' }\n                    )\n                ).toEqual(linearScaleExpectation2)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should compute values for time scale with native dates","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":154,"column":70},"line":154,"code":"            it('should compute values for time scale with native dates', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 4, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 5, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 6, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'time', format: 'native' }\n                    )\n                ).toEqual(timeScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should sort values for time scale with native dates","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":205,"column":67},"line":205,"code":"            it('should sort values for time scale with native dates', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 6, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 4, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                    {\n                                        data: {\n                                            [axis]: new Date(Date.UTC(2018, 3, 5, 0, 0, 0, 0)),\n                                        },\n                                    },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'time', format: 'native' }\n                    )\n                ).toEqual(timeScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should compute values for time scale using scale format","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":256,"column":71},"line":256,"code":"            it('should compute values for time scale using scale format', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    {\n                                        data: { [axis]: '2018-4-1 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-2 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-3 0:0:0' },\n                                    },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    {\n                                        data: { [axis]: '2018-4-4 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-5 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-6 0:0:0' },\n                                    },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'time', format: '%Y-%m-%d %H:%M:%S' }\n                    )\n                ).toEqual(timeScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should sort values for time scale using scale format","suites":["generateSeriesAxis"," axis"],"updatePoint":{"line":295,"column":68},"line":295,"code":"            it('should sort values for time scale using scale format', () => {\n                expect(\n                    generateSeriesAxis(\n                        [\n                            {\n                                id: 'A',\n                                data: [\n                                    {\n                                        data: { [axis]: '2018-4-3 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-1 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-2 0:0:0' },\n                                    },\n                                ],\n                            },\n                            {\n                                id: 'B',\n                                data: [\n                                    {\n                                        data: { [axis]: '2018-4-6 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-4 0:0:0' },\n                                    },\n                                    {\n                                        data: { [axis]: '2018-4-5 0:0:0' },\n                                    },\n                                ],\n                            },\n                        ],\n                        axis,\n                        { type: 'time', format: '%Y-%m-%d %H:%M:%S' }\n                    )\n                ).toEqual(timeScaleExpectation)\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should stack values using  point scale","suites":["stackAxis"," axis"],"updatePoint":{"line":342,"column":66},"line":342,"code":"            it(`should stack values using ${otherAxis} point scale`, () => {\n                const xy = {\n                    [otherAxis]: {\n                        all: ['a', 'b', 'c'],\n                    },\n                    [axis]: {},\n                }\n                const series = [\n                    {\n                        id: 'A',\n                        data: [\n                            { data: { [otherAxis]: 'a', [axis]: 10 } },\n                            { data: { [otherAxis]: 'b', [axis]: 20 } },\n                            { data: { [otherAxis]: 'c', [axis]: 30 } },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 'a', [axis]: 1 } },\n                            { data: { [otherAxis]: 'b', [axis]: 2 } },\n                            { data: { [otherAxis]: 'c', [axis]: 3 } },\n                        ],\n                    },\n                ]\n                stackAxis(axis, xy, series)\n\n                expect(xy[axis]).toEqual({ minStacked: 10, maxStacked: 33 })\n                expect(series).toEqual([\n                    {\n                        id: 'A',\n                        data: [\n                            {\n                                data: {\n                                    [otherAxis]: 'a',\n                                    [axis]: 10,\n                                    [`${axis}Stacked`]: 10,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: 'b',\n                                    [axis]: 20,\n                                    [`${axis}Stacked`]: 20,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: 'c',\n                                    [axis]: 30,\n                                    [`${axis}Stacked`]: 30,\n                                },\n                            },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 'a', [axis]: 1, [`${axis}Stacked`]: 11 } },\n                            { data: { [otherAxis]: 'b', [axis]: 2, [`${axis}Stacked`]: 22 } },\n                            { data: { [otherAxis]: 'c', [axis]: 3, [`${axis}Stacked`]: 33 } },\n                        ],\n                    },\n                ])\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should stack values using  linear scale","suites":["stackAxis"," axis"],"updatePoint":{"line":408,"column":67},"line":408,"code":"            it(`should stack values using ${otherAxis} linear scale`, () => {\n                const xy = {\n                    [otherAxis]: {\n                        all: [1, 2, 3],\n                    },\n                    [axis]: {},\n                }\n                const series = [\n                    {\n                        id: 'A',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 10 } },\n                            { data: { [otherAxis]: 2, [axis]: 20 } },\n                            { data: { [otherAxis]: 3, [axis]: 30 } },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 1 } },\n                            { data: { [otherAxis]: 2, [axis]: 2 } },\n                            { data: { [otherAxis]: 3, [axis]: 3 } },\n                        ],\n                    },\n                ]\n                stackAxis(axis, xy, series)\n\n                expect(xy[axis]).toEqual({ minStacked: 10, maxStacked: 33 })\n                expect(series).toEqual([\n                    {\n                        id: 'A',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 10, [`${axis}Stacked`]: 10 } },\n                            { data: { [otherAxis]: 2, [axis]: 20, [`${axis}Stacked`]: 20 } },\n                            { data: { [otherAxis]: 3, [axis]: 30, [`${axis}Stacked`]: 30 } },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 1, [`${axis}Stacked`]: 11 } },\n                            { data: { [otherAxis]: 2, [axis]: 2, [`${axis}Stacked`]: 22 } },\n                            { data: { [otherAxis]: 3, [axis]: 3, [`${axis}Stacked`]: 33 } },\n                        ],\n                    },\n                ])\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should stack values using  time scale","suites":["stackAxis"," axis"],"updatePoint":{"line":456,"column":65},"line":456,"code":"            it(`should stack values using ${otherAxis} time scale`, () => {\n                const xy = {\n                    [otherAxis]: {\n                        all: [\n                            new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                            new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                            new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                        ],\n                    },\n                    [axis]: {},\n                }\n                const series = [\n                    {\n                        id: 'A',\n                        data: [\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                    [axis]: 10,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                    [axis]: 20,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                    [axis]: 30,\n                                },\n                            },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                    [axis]: 1,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                    [axis]: 2,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                    [axis]: 3,\n                                },\n                            },\n                        ],\n                    },\n                ]\n                stackAxis(axis, xy, series)\n\n                expect(xy[axis]).toEqual({ minStacked: 10, maxStacked: 33 })\n                expect(series).toEqual([\n                    {\n                        id: 'A',\n                        data: [\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                    [axis]: 10,\n                                    [`${axis}Stacked`]: 10,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                    [axis]: 20,\n                                    [`${axis}Stacked`]: 20,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                    [axis]: 30,\n                                    [`${axis}Stacked`]: 30,\n                                },\n                            },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 1, 0, 0, 0, 0)),\n                                    [axis]: 1,\n                                    [`${axis}Stacked`]: 11,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 2, 0, 0, 0, 0)),\n                                    [axis]: 2,\n                                    [`${axis}Stacked`]: 22,\n                                },\n                            },\n                            {\n                                data: {\n                                    [otherAxis]: new Date(Date.UTC(2018, 3, 3, 0, 0, 0, 0)),\n                                    [axis]: 3,\n                                    [`${axis}Stacked`]: 33,\n                                },\n                            },\n                        ],\n                    },\n                ])\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should handle null values","suites":["stackAxis"," axis"],"updatePoint":{"line":574,"column":41},"line":574,"code":"            it(`should handle null values`, () => {\n                const xy = {\n                    [otherAxis]: {\n                        all: [1, 2, 3],\n                    },\n                    [axis]: {},\n                }\n                const series = [\n                    {\n                        id: 'A',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 10 } },\n                            { data: { [otherAxis]: 2, [axis]: null } },\n                            { data: { [otherAxis]: 3, [axis]: 30 } },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 1 } },\n                            { data: { [otherAxis]: 2, [axis]: 2 } },\n                            { data: { [otherAxis]: 3, [axis]: null } },\n                        ],\n                    },\n                ]\n                stackAxis(axis, xy, series)\n\n                expect(xy).toEqual({\n                    [otherAxis]: { all: [1, 2, 3] },\n                    [axis]: { minStacked: 10, maxStacked: 30 },\n                })\n                expect(series).toEqual([\n                    {\n                        id: 'A',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 10, [`${axis}Stacked`]: 10 } },\n                            {\n                                data: {\n                                    [otherAxis]: 2,\n                                    [axis]: null,\n                                    [`${axis}Stacked`]: null,\n                                },\n                            },\n                            { data: { [otherAxis]: 3, [axis]: 30, [`${axis}Stacked`]: 30 } },\n                        ],\n                    },\n                    {\n                        id: 'B',\n                        data: [\n                            { data: { [otherAxis]: 1, [axis]: 1, [`${axis}Stacked`]: 11 } },\n                            { data: { [otherAxis]: 2, [axis]: 2, [`${axis}Stacked`]: null } },\n                            {\n                                data: {\n                                    [otherAxis]: 3,\n                                    [axis]: null,\n                                    [`${axis}Stacked`]: null,\n                                },\n                            },\n                        ],\n                    },\n                ])\n            })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"works with timescale an and empty series","suites":["computeXYScalesForSeries"],"updatePoint":{"line":641,"column":48},"line":641,"code":"    it('works with timescale an and empty series', () => {\n        const series = computeXYScalesForSeries(\n            [],\n            {\n                type: 'time',\n                format: '%Y-%m-%d',\n                useUTC: false,\n                precision: 'day',\n            },\n            {\n                type: 'linear',\n                stacked: false,\n            },\n            100,\n            100\n        )\n\n        expect(series).toMatchInlineSnapshot(`\n            Object {\n              \"series\": Array [],\n              \"x\": Object {\n                \"all\": Array [],\n                \"max\": undefined,\n                \"min\": undefined,\n              },\n              \"xScale\": [Function],\n              \"y\": Object {\n                \"all\": Array [],\n                \"max\": -Infinity,\n                \"min\": Infinity,\n              },\n              \"yScale\": [Function],\n            }\n        `)\n    })","file":"compute.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should be able to build a linear scale for x axis","suites":[],"updatePoint":{"line":3,"column":53},"line":3,"code":"it(`should be able to build a linear scale for x axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear' },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(50)\n    expect(scale(1)).toBe(100)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should be able to build a linear scale for y axis","suites":[],"updatePoint":{"line":16,"column":53},"line":16,"code":"it(`should be able to build a linear scale for y axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear' },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale(0)).toBe(100)\n    expect(scale(0.5)).toBe(50)\n    expect(scale(1)).toBe(0)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define min value for x axis","suites":[],"updatePoint":{"line":29,"column":47},"line":29,"code":"it(`should allow to define min value for x axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', min: 0.5 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale.domain()[0]).toBe(0.5)\n    expect(scale(0)).toBe(-100)\n    expect(scale(0.5)).toBe(0)\n    expect(scale(1)).toBe(100)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define min value for y axis","suites":[],"updatePoint":{"line":43,"column":47},"line":43,"code":"it(`should allow to define min value for y axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', min: 0.5 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale.domain()[0]).toBe(0.5)\n    expect(scale(0)).toBe(200)\n    expect(scale(0.5)).toBe(100)\n    expect(scale(1)).toBe(0)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define max value for x axis","suites":[],"updatePoint":{"line":57,"column":47},"line":57,"code":"it(`should allow to define max value for x axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', max: 2 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale.domain()[1]).toBe(2)\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(25)\n    expect(scale(1)).toBe(50)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define max value for y axis","suites":[],"updatePoint":{"line":71,"column":47},"line":71,"code":"it(`should allow to define max value for y axis`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', max: 2 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale.domain()[1]).toBe(2)\n    expect(scale(0)).toBe(100)\n    expect(scale(0.5)).toBe(75)\n    expect(scale(1)).toBe(50)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to reverse domain","suites":[],"updatePoint":{"line":85,"column":34},"line":85,"code":"it(`should allow to reverse domain`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', reverse: true },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(50)\n    expect(scale(1)).toBe(100)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to clamping","suites":[],"updatePoint":{"line":98,"column":28},"line":98,"code":"it(`should allow to clamping`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', clamp: true, min: 0.5 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale.domain()[0]).toBe(0.5)\n    expect(scale(0)).toBe(100)\n    expect(scale(0.5)).toBe(100)\n    expect(scale(1)).toBe(0)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow nice","suites":[],"updatePoint":{"line":112,"column":21},"line":112,"code":"it(`should allow nice`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', nice: true },\n        { all: [], min: 0.243, max: 0.933 },\n        100,\n        'x'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(50)\n    expect(scale(1)).toBe(100)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow numeric nice","suites":[],"updatePoint":{"line":125,"column":29},"line":125,"code":"it(`should allow numeric nice`, () => {\n    const scale = createLinearScale<number>(\n        { type: 'linear', nice: 2 },\n        { all: [], min: 0.243, max: 0.933 },\n        100,\n        'x'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(50)\n    expect(scale(1)).toBe(100)\n})","file":"linearScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should be able to build a symlog scale for x axis","suites":[],"updatePoint":{"line":3,"column":53},"line":3,"code":"it(`should be able to build a symlog scale for x axis`, () => {\n    const scale = createSymlogScale({ type: 'symlog' }, { all: [], min: 0, max: 1 }, 100, 'x')\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(58)\n    expect(scale(1)).toBe(100)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should be able to build a symlog scale for y axis","suites":[],"updatePoint":{"line":11,"column":53},"line":11,"code":"it(`should be able to build a symlog scale for y axis`, () => {\n    const scale = createSymlogScale({ type: 'symlog' }, { all: [], min: 0, max: 1 }, 100, 'y')\n\n    expect(scale(0)).toBe(100)\n    expect(scale(0.5)).toBe(42)\n    expect(scale(1)).toBe(0)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define min value for x axis","suites":[],"updatePoint":{"line":19,"column":47},"line":19,"code":"it(`should allow to define min value for x axis`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', min: 0.5 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale.domain()[0]).toBe(0.5)\n    expect(scale(0)).toBe(-141)\n    expect(scale(0.5)).toBe(0)\n    expect(scale(1)).toBe(100)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define min value for y axis","suites":[],"updatePoint":{"line":33,"column":47},"line":33,"code":"it(`should allow to define min value for y axis`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', min: 0.5 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale.domain()[0]).toBe(0.5)\n    expect(scale(0)).toBe(241)\n    expect(scale(0.5)).toBe(100)\n    expect(scale(1)).toBe(0)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define max value for x axis","suites":[],"updatePoint":{"line":47,"column":47},"line":47,"code":"it(`should allow to define max value for x axis`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', max: 2 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale.domain()[1]).toBe(2)\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(37)\n    expect(scale(1)).toBe(63)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to define max value for y axis","suites":[],"updatePoint":{"line":61,"column":47},"line":61,"code":"it(`should allow to define max value for y axis`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', max: 2 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale.domain()[1]).toBe(2)\n    expect(scale(0)).toBe(100)\n    expect(scale(0.5)).toBe(63)\n    expect(scale(1)).toBe(37)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to reverse domain","suites":[],"updatePoint":{"line":75,"column":34},"line":75,"code":"it(`should allow to reverse domain`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', reverse: true },\n        { all: [], min: 0, max: 1 },\n        100,\n        'y'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(58)\n    expect(scale(1)).toBe(100)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should allow to adjust the constant","suites":[],"updatePoint":{"line":88,"column":39},"line":88,"code":"it(`should allow to adjust the constant`, () => {\n    const scale = createSymlogScale(\n        { type: 'symlog', constant: 0.1 },\n        { all: [], min: 0, max: 1 },\n        100,\n        'x'\n    )\n\n    expect(scale(0)).toBe(0)\n    expect(scale(0.5)).toBe(75)\n    expect(scale(1)).toBe(100)\n})","file":"symlogScale.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should return default ticks","suites":["linear scale"],"updatePoint":{"line":8,"column":35},"line":8,"code":"    it('should return default ticks', () => {\n        expect(getScaleTicks(linearScale)).toEqual([\n            0, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500,\n        ])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support using a count","suites":["linear scale"],"updatePoint":{"line":14,"column":36},"line":14,"code":"    it('should support using a count', () => {\n        expect(getScaleTicks(linearScale, 6)).toEqual([0, 100, 200, 300, 400, 500])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support using specific values","suites":["linear scale"],"updatePoint":{"line":18,"column":44},"line":18,"code":"    it('should support using specific values', () => {\n        expect(getScaleTicks(linearScale, [0, 200, 400])).toEqual([0, 200, 400])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should return default ticks","suites":["time scale"],"updatePoint":{"line":29,"column":35},"line":29,"code":"    it('should return default ticks', () => {\n        expect(getScaleTicks(timeScale)).toEqual([\n            new Date(Date.UTC(2000, 0, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 1, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 2, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 3, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 4, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 5, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 6, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 7, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 8, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 9, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 10, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 11, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2001, 0, 1, 0, 0, 0, 0)),\n        ])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support using a count","suites":["time scale"],"updatePoint":{"line":47,"column":36},"line":47,"code":"    it('should support using a count', () => {\n        expect(getScaleTicks(timeScale, 4)).toEqual([\n            new Date(Date.UTC(2000, 0, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 3, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 6, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2000, 9, 1, 0, 0, 0, 0)),\n            new Date(Date.UTC(2001, 0, 1, 0, 0, 0, 0)),\n        ])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support non-UTC dates","suites":["time scale"],"updatePoint":{"line":57,"column":36},"line":57,"code":"    it('should support non-UTC dates', () => {\n        const noUtcTimeScale = scaleTime().domain([\n            new Date(2000, 0, 1, 0, 0, 0, 0),\n            new Date(2001, 0, 1, 0, 0, 0, 0),\n        ])\n\n        expect(getScaleTicks(noUtcTimeScale)).toEqual([\n            new Date(2000, 0, 1, 0, 0, 0, 0),\n            new Date(2000, 1, 1, 0, 0, 0, 0),\n            new Date(2000, 2, 1, 0, 0, 0, 0),\n            new Date(2000, 3, 1, 0, 0, 0, 0),\n            new Date(2000, 4, 1, 0, 0, 0, 0),\n            new Date(2000, 5, 1, 0, 0, 0, 0),\n            new Date(2000, 6, 1, 0, 0, 0, 0),\n            new Date(2000, 7, 1, 0, 0, 0, 0),\n            new Date(2000, 8, 1, 0, 0, 0, 0),\n            new Date(2000, 9, 1, 0, 0, 0, 0),\n            new Date(2000, 10, 1, 0, 0, 0, 0),\n            new Date(2000, 11, 1, 0, 0, 0, 0),\n            new Date(2001, 0, 1, 0, 0, 0, 0),\n        ])\n    })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support  interval","suites":["time scale"],"updatePoint":{"line":165,"column":56},"line":165,"code":"        it(`should support ${interval.interval} interval`, () => {\n            const intervalTimeScale = scaleUtc().domain(interval.domain)\n\n            // set utc flag on our scale\n            ;(intervalTimeScale as any).useUTC = true\n\n            expect(getScaleTicks(intervalTimeScale, `every ${interval.interval}`)).toEqual(\n                interval.expect\n            )\n        })","file":"ticks.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should support %s precision","suites":["createPrecisionMethod"],"line":6,"code":"    it.each([\n        ['millisecond', input],\n        ['second', new Date(2018, 9, 30, 15, 33, 47, 0)],\n        ['minute', new Date(2018, 9, 30, 15, 33, 0, 0)],\n        ['hour', new Date(2018, 9, 30, 15, 0, 0, 0)],\n        ['day', new Date(2018, 9, 30, 0, 0, 0, 0)],\n        ['month', new Date(2018, 9, 1, 0, 0, 0, 0)],\n        ['year', new Date(2018, 0, 1, 0, 0, 0, 0)],\n    ] as const)(`should support %s precision`, (precision, expected) => {\n        const date = new Date(input.getTime())\n        createPrecisionMethod(precision)(date)\n        expect(date.getTime()).toBe(expected.getTime())\n    })","file":"timeHelpers.test.ts","skipped":false,"dir":"packages/scales/tests"},{"name":"should be able to compute mesh for collinear points","suites":[],"updatePoint":{"line":3,"column":55},"line":3,"code":"it(`should be able to compute mesh for collinear points`, () => {\n    const points: [number, number][] = [\n        [0, 0],\n        [50, 50],\n        [100, 100],\n    ]\n\n    const { voronoi } = computeMesh({ points, width: 500, height: 500, debug: true })\n\n    const cells = Array.from(voronoi!.cellPolygons())\n    expect(cells).toHaveLength(3)\n})","file":"computeMesh.test.ts","skipped":false,"dir":"packages/voronoi/tests"},{"name":"should be able to compute mesh for a single point","suites":[],"updatePoint":{"line":16,"column":53},"line":16,"code":"it(`should be able to compute mesh for a single point`, () => {\n    const points: [number, number][] = [[50, 50]]\n\n    const { voronoi } = computeMesh({ points, width: 500, height: 500, debug: true })\n\n    const cells = Array.from(voronoi!.cellPolygons())\n    expect(cells).toHaveLength(1)\n})","file":"computeMesh.test.ts","skipped":false,"dir":"packages/voronoi/tests"},{"name":"should compute cell size according to given parameters","suites":["computeCellSize"],"updatePoint":{"line":3,"column":60,"index":160},"line":3,"code":"  it('should compute cell size according to given parameters', () => {\n    const cellSize = computeCellSize(100, 100, 10, 10, 0);\n    expect(cellSize).toBe(10);\n  });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support padding","suites":["computeCellSize"],"updatePoint":{"line":7,"column":28,"index":295},"line":7,"code":"  it('should support padding', () => {\n    const cellSize = computeCellSize(100, 100, 10, 10, 1);\n    expect(cellSize).toBe(9.1);\n  });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should create default empty grid","suites":["computeGrid"],"updatePoint":{"line":13,"column":38,"index":477},"line":13,"code":"  it('should create default empty grid', () => {\n    const {\n      cells,\n      cellSize,\n      origin\n    } = computeGrid(100, 100, 10, 10, 'bottom', 0);\n    expect(cells.length).toBe(100);\n    expect(cellSize).toBe(10);\n    expect(origin).toEqual({\n      x: 0,\n      y: 0\n    });\n    expect(cells).toMatchSnapshot();\n  });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support padding","suites":["computeGrid"],"updatePoint":{"line":27,"column":28,"index":792},"line":27,"code":"  it('should support padding', () => {\n    const {\n      cells,\n      cellSize\n    } = computeGrid(100, 100, 10, 10, 'bottom', 1);\n    expect(cellSize).toBe(9.1);\n    expect(cells).toMatchSnapshot();\n  });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should compute origin according to remaining space","suites":["computeGrid"],"updatePoint":{"line":35,"column":56,"index":1026},"line":35,"code":"  it('should compute origin according to remaining space', () => {\n    const {\n      cells,\n      origin\n    } = computeGrid(200, 100, 10, 10, 'bottom', 0);\n    expect(origin).toEqual({\n      x: 50,\n      y: 0\n    });\n    expect(cells).toMatchSnapshot();\n  });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support  fill mode","suites":["computeGrid"],"updatePoint":{"line":48,"column":44,"index":1369},"line":48,"code":"    it(`should support ${fillMode} fill mode`, () => {\n      const {\n        cells\n      } = computeGrid(100, 100, 10, 10, fillMode, 0);\n      expect(cells).toMatchSnapshot();\n    });","file":"compute.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should render a basic waffle chart in SVG","suites":[],"updatePoint":{"line":6,"column":45,"index":260},"line":6,"code":"it('should render a basic waffle chart in SVG', () => {\n  const component = renderer.create( /*#__PURE__*/React.createElement(Waffle, {\n    width: 400,\n    height: 400,\n    rows: 10,\n    columns: 10,\n    total: 100,\n    data: [{\n      id: 'one',\n      label: 'one',\n      value: 10\n    }]\n  }));\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});","file":"Waffle.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support  fill mode","suites":[],"updatePoint":{"line":24,"column":42,"index":714},"line":24,"code":"  it(`should support ${fillMode} fill mode`, () => {\n    const component = renderer.create( /*#__PURE__*/React.createElement(Waffle, {\n      width: 400,\n      height: 400,\n      rows: 10,\n      columns: 10,\n      total: 100,\n      data: [{\n        id: 'one',\n        label: 'one',\n        value: 10\n      }],\n      fillDirection: fillMode\n    }));\n    let tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });","file":"Waffle.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support legends","suites":[],"updatePoint":{"line":42,"column":26,"index":1125},"line":42,"code":"it('should support legends', () => {\n  const data = [{\n    id: 'one',\n    label: 'one',\n    value: 10\n  }, {\n    id: 'two',\n    label: 'two',\n    value: 20\n  }, {\n    id: 'tree',\n    label: 'tree',\n    value: 30\n  }];\n  const legends = [{\n    anchor: 'top-left',\n    direction: 'column',\n    itemWidth: 100,\n    itemHeight: 20\n  }];\n  const wrapper = mount( /*#__PURE__*/React.createElement(Waffle, {\n    width: 400,\n    height: 400,\n    rows: 10,\n    columns: 10,\n    total: 100,\n    colors: ['red', 'green', 'blue'],\n    data: data,\n    legends: legends\n  }));\n  expect(wrapper.find(LegendSvg)).toHaveLength(1);\n  const legendItems = wrapper.find(LegendSvgItem);\n  expect(legendItems).toHaveLength(3);\n  expect(legendItems.at(0).prop('data')).toEqual({\n    id: 'one',\n    label: 'one',\n    color: 'red'\n  });\n  expect(legendItems.at(1).prop('data')).toEqual({\n    id: 'two',\n    label: 'two',\n    color: 'green'\n  });\n  expect(legendItems.at(2).prop('data')).toEqual({\n    id: 'tree',\n    label: 'tree',\n    color: 'blue'\n  });\n});","file":"Waffle.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should allow to hide specific ids","suites":[],"updatePoint":{"line":91,"column":37,"index":2170},"line":91,"code":"it('should allow to hide specific ids', () => {\n  const data = [{\n    id: 'one',\n    label: 'one',\n    value: 10\n  }, {\n    id: 'two',\n    label: 'two',\n    value: 20\n  }];\n  const legends = [{\n    anchor: 'top-left',\n    direction: 'column',\n    itemWidth: 100,\n    itemHeight: 20\n  }];\n  const wrapper = mount( /*#__PURE__*/React.createElement(Waffle, {\n    width: 400,\n    height: 400,\n    rows: 10,\n    columns: 10,\n    total: 100,\n    colors: ['red', 'green'],\n    data: data,\n    hiddenIds: ['one'],\n    legends: legends\n  }));\n  const oneCells = wrapper.findWhere(n => n.type() === WaffleCell && n.prop('data') !== undefined && n.prop('data').id === 'one');\n  const twoCells = wrapper.findWhere(n => n.type() === WaffleCell && n.prop('data') !== undefined && n.prop('data').id === 'two');\n  expect(oneCells).toHaveLength(0);\n  expect(twoCells.length).toBeGreaterThan(0);\n  expect(wrapper.find(LegendSvgItem)).toHaveLength(2);\n});","file":"Waffle.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should render a basic waffle chart in HTML","suites":[],"updatePoint":{"line":3,"column":46,"index":131},"line":3,"code":"it('should render a basic waffle chart in HTML', () => {\n  const component = renderer.create( /*#__PURE__*/React.createElement(WaffleHtml, {\n    width: 400,\n    height: 400,\n    rows: 10,\n    columns: 10,\n    total: 100,\n    data: [{\n      id: 'one',\n      label: 'one',\n      value: 10\n    }]\n  }));\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});","file":"WaffleHtml.test.js","skipped":false,"dir":"packages/waffle/tests"},{"name":"should support  fill mode","suites":[],"updatePoint":{"line":21,"column":42,"index":589},"line":21,"code":"  it(`should support ${fillMode} fill mode`, () => {\n    const component = renderer.create( /*#__PURE__*/React.createElement(WaffleHtml, {\n      width: 400,\n      height: 400,\n      rows: 10,\n      columns: 10,\n      total: 100,\n      data: [{\n        id: 'one',\n        label: 'one',\n        value: 10\n      }],\n      fillDirection: fillMode\n    }));\n    let tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });","file":"WaffleHtml.test.js","skipped":false,"dir":"packages/waffle/tests"}]}