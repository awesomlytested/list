{
    "repo": "cyclejs/cyclejs",
    "url": "https://github.com/cyclejs/cyclejs",
    "branch": "master",
    "configs": [
        {
            "package": "@cycle/dom",
            "lang": "ts",
            "dir": "dom/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/history",
            "lang": "js",
            "dir": "history/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/html",
            "lang": "ts",
            "dir": "html/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/http",
            "lang": "ts",
            "dir": "http/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/isolate",
            "lang": "ts",
            "dir": "isolate/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/most-run",
            "lang": "ts",
            "dir": "most-run/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/run",
            "lang": "ts",
            "dir": "run/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/rxjs-run",
            "lang": "ts",
            "dir": "rxjs-run/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/state",
            "lang": "ts",
            "dir": "state/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@cycle/time",
            "lang": "ts",
            "dir": "time/test",
            "framework": "mocha",
            "pattern": "**/*.{js,ts}"
        }
    ],
    "tests": [
        {
            "name": "should accept a DOM element as input",
            "suites": [
                "makeDOMDriver"
            ],
            "updatePoint": {
                "line": 27,
                "column": 42
            },
            "line": 27,
            "code": "  it('should accept a DOM element as input', function() {\n    const element = createRenderTarget();\n    assert.doesNotThrow(function() {\n      makeDOMDriver(element);\n    });\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should accept a DocumentFragment as input",
            "suites": [
                "makeDOMDriver"
            ],
            "updatePoint": {
                "line": 34,
                "column": 47
            },
            "line": 34,
            "code": "  it('should accept a DocumentFragment as input', function() {\n    if (isIE10) {\n      return;\n    }\n    const docfrag = document.createDocumentFragment();\n    assert.doesNotThrow(function() {\n      makeDOMDriver(docfrag);\n    });\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should accept a string selector to an existing element as input",
            "suites": [
                "makeDOMDriver"
            ],
            "updatePoint": {
                "line": 44,
                "column": 69
            },
            "line": 44,
            "code": "  it('should accept a string selector to an existing element as input', function() {\n    const id = 'testShouldAcceptSelectorToExisting';\n    const element = createRenderTarget();\n    element.id = id;\n    assert.doesNotThrow(function() {\n      makeDOMDriver('#' + id);\n    });\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not accept a selector to an unknown element as input",
            "suites": [
                "makeDOMDriver"
            ],
            "updatePoint": {
                "line": 53,
                "column": 65
            },
            "line": 53,
            "code": "  it('should not accept a selector to an unknown element as input', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n    makeDOMDriver('#nonsenseIdToNothing')(xs.never());\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match({\n          message: 'Cannot render into unknown element `#nonsenseIdToNothing`',\n        })\n      );\n      sandbox.restore();\n      done();\n    }, 100);\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not accept a number as input",
            "suites": [
                "makeDOMDriver"
            ],
            "updatePoint": {
                "line": 70,
                "column": 41
            },
            "line": 70,
            "code": "  it('should not accept a number as input', function() {\n    assert.throws(function() {\n      makeDOMDriver(123 as any);\n    }, /Given container is not a DOM element neither a selector string/);\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should throw if input is not an Observable<VTree>",
            "suites": [
                "DOM Driver"
            ],
            "updatePoint": {
                "line": 78,
                "column": 55
            },
            "line": 78,
            "code": "  it('should throw if input is not an Observable<VTree>', function() {\n    const domDriver = makeDOMDriver(createRenderTarget());\n    assert.throws(function() {\n      domDriver({} as any);\n    }, /The DOM driver function expects as input a Stream of virtual/);\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have isolateSource() and isolateSink() in source",
            "suites": [
                "DOM Driver"
            ],
            "updatePoint": {
                "line": 85,
                "column": 61
            },
            "line": 85,
            "code": "  it('should have isolateSource() and isolateSink() in source', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div()),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    const dispose = run();\n    assert.strictEqual(typeof sources.DOM.isolateSource, 'function');\n    assert.strictEqual(typeof sources.DOM.isolateSink, 'function');\n    dispose();\n    done();\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should report errors thrown in hooks",
            "suites": [
                "DOM Driver"
            ],
            "updatePoint": {
                "line": 102,
                "column": 42
            },
            "line": 102,
            "code": "  it('should report errors thrown in hooks', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function main(sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.test', {\n            hook: {\n              insert: () => {\n                throw new Error('error in hook');\n              },\n            },\n          })\n        ),\n      };\n    }\n\n    cycleRun(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match({message: 'error in hook'})\n      );\n      sandbox.restore();\n      done();\n    }, 100);\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not work after has been disposed",
            "suites": [
                "DOM Driver"
            ],
            "updatePoint": {
                "line": 135,
                "column": 45
            },
            "line": 135,
            "code": "  it('should not work after has been disposed', function(done) {\n    const num$ = xs\n      .of(1, 2, 3)\n      .map(x => xs.of(x).compose(delay(50)))\n      .compose(flattenSequentially);\n\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: num$.map(num => h3('.target', String(num))),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    let hasDisposed = false;\n    let assertionOngoing = false;\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .addListener({\n        next: (root: Element) => {\n          const selectEl = root.querySelector('.target') as Element;\n          if (!selectEl && assertionOngoing && hasDisposed) {\n            // This synchronous delivery of the empty root element is allowed\n            return;\n          }\n          if (!selectEl && !assertionOngoing && hasDisposed) {\n            done(\n              'DOM Driver should not emit anything asynchronously after dispose()'\n            );\n          }\n          if (selectEl && hasDisposed) {\n            done('DOM Driver should not emit a target element after dispose()');\n          }\n          assertionOngoing = true;\n          assert.notStrictEqual(selectEl, null);\n          assert.notStrictEqual(typeof selectEl, 'undefined');\n          assert.strictEqual(selectEl.tagName, 'H3');\n          assert.notStrictEqual(selectEl.textContent, '3');\n          if (selectEl.textContent === '2') {\n            hasDisposed = true;\n            dispose();\n            setTimeout(() => {\n              done();\n            }, 100);\n          }\n          assertionOngoing = false;\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should clean up DOM on disposal",
            "suites": [
                "DOM Driver"
            ],
            "updatePoint": {
                "line": 190,
                "column": 37
            },
            "line": 190,
            "code": "  it('should clean up DOM on disposal', function(done) {\n    let hookTick = 0;\n    let hookInterval: any;\n    const hook = {\n      insert: () => {\n        hookInterval = setInterval(() => hookTick++, 10);\n      },\n      destroy: () => {\n        clearInterval(hookInterval);\n      },\n    };\n\n    function app() {\n      return {\n        DOM: xs.of(h3('.target', {hook}, 'dummy text')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget('disposal')),\n    });\n\n    const dispose = run();\n    setTimeout(() => {\n      dispose();\n      const hookTickOnDisposal = hookTick;\n\n      setTimeout(() => {\n        const renderTarget = document.getElementById('disposal') as Element;\n        assert.equal(renderTarget.innerHTML, '');\n        assert.ok(hookTick > 0);\n        assert.equal(hookTickOnDisposal, hookTick);\n        done();\n      }, 50);\n    }, 100);\n  });",
            "file": "browser/dom-driver.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return a stream of documents when querying \"document\"",
            "suites": [
                "DOMSource.elements()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 66
            },
            "line": 32,
            "code": "  it('should return a stream of documents when querying \"document\"', done => {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('.top-most', [p('Foo'), span('Bar')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    function isDocument(element: any): element is Document {\n      return 'body' in element && 'head' in element;\n    }\n\n    let dispose: any;\n    sources.DOM.select('document')\n      .element()\n      .take(1)\n      .addListener({\n        next: root => {\n          assert(root.body !== undefined); //Check type inference\n          assert(isDocument(root));\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/elements.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return a stream of bodies when querying \"body\"",
            "suites": [
                "DOMSource.elements()"
            ],
            "updatePoint": {
                "line": 64,
                "column": 59
            },
            "line": 64,
            "code": "  it('should return a stream of bodies when querying \"body\"', done => {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('.top-most', [p('Foo'), span('Bar')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    function isBody(element: any): element is HTMLBodyElement {\n      return 'aLink' in element && 'link' in element;\n    }\n\n    let dispose: any;\n    sources.DOM.select('body')\n      .element()\n      .take(1)\n      .addListener({\n        next: root => {\n          assert(root.aLink !== undefined); //Check type inference\n          assert(isBody(root));\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/elements.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return a stream of arrays of elements of size 1 when querying \":root\"",
            "suites": [
                "DOMSource.elements()"
            ],
            "updatePoint": {
                "line": 96,
                "column": 82
            },
            "line": 96,
            "code": "  it('should return a stream of arrays of elements of size 1 when querying \":root\"', done => {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('.top-most', [p('Foo'), span('Bar')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: root => {\n          assert(root.forEach !== undefined); //Check type inference\n          assert(Array.isArray(root));\n          assert(root.length === 1);\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/elements.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return a stream of arrays of elements of size 2 when querying \".some\"",
            "suites": [
                "DOMSource.elements()"
            ],
            "updatePoint": {
                "line": 126,
                "column": 82
            },
            "line": 126,
            "code": "  it('should return a stream of arrays of elements of size 2 when querying \".some\"', done => {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('.top-most', [div('.some'), div('.some')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select('.some')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elems: Array<Element>) => {\n          assert(Array.isArray(elems));\n          assert(elems.length === 2);\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/elements.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch a basic click interaction Observable",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 55
            },
            "line": 67,
            "code": "  it('should catch a basic click interaction Observable', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(h3('.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    let dispose: any;\n    sources.DOM.select('.myelementclass')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: function(root: Element) {\n          const myElement = root.querySelector(\n            '.myelementclass'\n          ) as HTMLElement;\n          assert.notStrictEqual(myElement, null);\n          assert.notStrictEqual(typeof myElement, 'undefined');\n          assert.strictEqual(myElement.tagName, 'H3');\n          assert.doesNotThrow(function() {\n            setTimeout(() => myElement.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should setup click detection with events() after run() occurs",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 109,
                "column": 67
            },
            "line": 109,
            "code": "  it('should setup click detection with events() after run() occurs', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(h3('.test2.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    const dispose = run();\n    sources.DOM.select('.myelementclass')\n      .events('click')\n      .addListener({\n        next(ev: Event) {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n          dispose();\n          done();\n        },\n      });\n\n    setTimeout(() => {\n      const myElement = document.querySelector(\n        '.test2.myelementclass'\n      ) as HTMLElement;\n      assert.notStrictEqual(myElement, null);\n      assert.notStrictEqual(typeof myElement, 'undefined');\n      assert.strictEqual(myElement.tagName, 'H3');\n      assert.doesNotThrow(function() {\n        setTimeout(() => myElement.click());\n      });\n    }, 200);\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should setup click detection on a ready DOM element (e.g. from server)",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 144,
                "column": 76
            },
            "line": 144,
            "code": "  it('should setup click detection on a ready DOM element (e.g. from server)', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.never(),\n      };\n    }\n\n    const containerElement = createRenderTarget();\n    const headerElement = document.createElement('H3');\n    headerElement.className = 'myelementclass';\n    headerElement.textContent = 'Foobar';\n    containerElement.appendChild(headerElement);\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(containerElement),\n    });\n    const dispose = run();\n    sources.DOM.select('.myelementclass')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n          dispose();\n          done();\n        },\n      });\n\n    setTimeout(() => {\n      const myElement = containerElement.querySelector(\n        '.myelementclass'\n      ) as HTMLElement;\n      assert.notStrictEqual(myElement, null);\n      assert.notStrictEqual(typeof myElement, 'undefined');\n      assert.strictEqual(myElement.tagName, 'H3');\n      assert.doesNotThrow(function() {\n        setTimeout(() => myElement.click());\n      });\n    }, 200);\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch events using id of root element in DOM.select",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 185,
                "column": 64
            },
            "line": 185,
            "code": "  it('should catch events using id of root element in DOM.select', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(h3('.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget('parent-001')),\n    });\n\n    let dispose: any;\n    sources.DOM.select('#parent-001')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const myElement = root.querySelector(\n            '.myelementclass'\n          ) as HTMLElement;\n          assert.notStrictEqual(myElement, null);\n          assert.notStrictEqual(typeof myElement, 'undefined');\n          assert.strictEqual(myElement.tagName, 'H3');\n          assert.doesNotThrow(function() {\n            setTimeout(() => myElement.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch events using id of top element in DOM.select",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 228,
                "column": 63
            },
            "line": 228,
            "code": "  it('should catch events using id of top element in DOM.select', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(h3('#myElementId', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget('parent-002')),\n    });\n\n    let dispose: any;\n    sources.DOM.select('#myElementId')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const myElement = root.querySelector('#myElementId') as HTMLElement;\n          assert.notStrictEqual(myElement, null);\n          assert.notStrictEqual(typeof myElement, 'undefined');\n          assert.strictEqual(myElement.tagName, 'H3');\n          assert.doesNotThrow(function() {\n            setTimeout(() => myElement.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch interaction events without prior select()",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 269,
                "column": 60
            },
            "line": 269,
            "code": "  it('should catch interaction events without prior select()', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [h3('.myelementclass', 'Foobar')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.events('click').addListener({\n      next: (ev: Event) => {\n        assert.strictEqual(ev.type, 'click');\n        assert.strictEqual((ev.target as HTMLElement).textContent, 'Foobar');\n        dispose();\n        done();\n      },\n    });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const myElement = root.querySelector(\n            '.myelementclass'\n          ) as HTMLElement;\n          assert.notStrictEqual(myElement, null);\n          assert.notStrictEqual(typeof myElement, 'undefined');\n          assert.strictEqual(myElement.tagName, 'H3');\n          assert.doesNotThrow(function() {\n            setTimeout(() => myElement.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch user events using DOM.select().select().events()",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 310,
                "column": 67
            },
            "line": 310,
            "code": "  it('should catch user events using DOM.select().select().events()', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          h3('.top-most', [\n            h2('.bar', 'Wrong'),\n            div('.foo', [h4('.bar', 'Correct')]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select('.foo')\n      .select('.bar')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Correct');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const wrongElement = root.querySelector('.bar') as HTMLElement;\n          const correctElement = root.querySelector('.foo .bar') as HTMLElement;\n          assert.notStrictEqual(wrongElement, null);\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof wrongElement, 'undefined');\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(wrongElement.tagName, 'H2');\n          assert.strictEqual(correctElement.tagName, 'H4');\n          assert.doesNotThrow(function() {\n            setTimeout(() => wrongElement.click());\n            setTimeout(() => correctElement.click(), 15);\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch events from many elements using DOM.select().events()",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 362,
                "column": 72
            },
            "line": 362,
            "code": "  it('should catch events from many elements using DOM.select().events()', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [\n            h4('.clickable.first', 'First'),\n            h4('.clickable.second', 'Second'),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select('.clickable')\n      .events('click')\n      .take(1)\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'First');\n        },\n      });\n\n    sources.DOM.select('.clickable')\n      .events('click')\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Second');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const firstElem = root.querySelector('.first') as HTMLElement;\n          const secondElem = root.querySelector('.second') as HTMLElement;\n          assert.notStrictEqual(firstElem, null);\n          assert.notStrictEqual(typeof firstElem, 'undefined');\n          assert.notStrictEqual(secondElem, null);\n          assert.notStrictEqual(typeof secondElem, 'undefined');\n          assert.doesNotThrow(function() {\n            setTimeout(() => firstElem.click());\n            setTimeout(() => secondElem.click(), 5);\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch interaction events from future elements",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 423,
                "column": 58
            },
            "line": 423,
            "code": "  it('should catch interaction events from future elements', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: concat(\n          xs.of(h2('.blesh', 'Blesh')),\n          xs.of(h3('.blish', 'Blish')).compose(delay(150)),\n          xs.of(h4('.blosh', 'Blosh')).compose(delay(150))\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget('parent-002')),\n    });\n\n    let dispose: any;\n    sources.DOM.select('.blosh')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          assert.strictEqual((ev.target as HTMLElement).textContent, 'Blosh');\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(3)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const myElement = root.querySelector('.blosh') as HTMLElement;\n          assert.notStrictEqual(myElement, null);\n          assert.notStrictEqual(typeof myElement, 'undefined');\n          assert.strictEqual(myElement.tagName, 'H4');\n          assert.strictEqual(myElement.textContent, 'Blosh');\n          assert.doesNotThrow(function() {\n            setTimeout(() => myElement.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch bubbling events in a DocumentFragment",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 469,
                "column": 56
            },
            "line": 469,
            "code": "  it('should catch bubbling events in a DocumentFragment', function(done) {\n    if (isIE10) {\n      done();\n      return;\n    }\n\n    const {bubbles: thisBrowserBubblesFragmentEvents} = fragmentSupport;\n\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div([div('.clickable', 'Hello')])),\n      };\n    }\n\n    if (!thisBrowserBubblesFragmentEvents) {\n      done();\n    } else {\n      const fragment = document.createDocumentFragment();\n      const renderTarget = fragment.appendChild(document.createElement('div'));\n\n      const {sinks, sources, run} = setup(app, {\n        DOM: makeDOMDriver(renderTarget as Element),\n      });\n\n      sources.DOM.select('.clickable')\n        .events('click', {useCapture: false})\n        .addListener({\n          next: (ev: Event) => {\n            const elem = ev.target as HTMLElement;\n            assert.strictEqual(ev.type, 'click');\n            assert.strictEqual(elem.tagName, 'DIV');\n            assert.strictEqual(elem.className, 'clickable');\n            assert.strictEqual(elem.textContent, 'Hello');\n            const top = elem.parentElement as Node;\n            const renderTarget2 = top.parentNode as Node;\n            const frag = renderTarget2.parentNode as Node;\n            assert.strictEqual(frag instanceof DocumentFragment, true);\n            done();\n          },\n        });\n\n      sources.DOM.select(':root')\n        .element()\n        .drop(1)\n        .take(1)\n        .addListener({\n          next: (root: Element) => {\n            const clickable = root.querySelector('.clickable') as HTMLElement;\n            setTimeout(() => clickable.click(), 80);\n          },\n        });\n      run();\n    }\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch non-bubbling events in a DocumentFragment with useCapture",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 524,
                "column": 76
            },
            "line": 524,
            "code": "  it('should catch non-bubbling events in a DocumentFragment with useCapture', function(done) {\n    if (isIE10) {\n      done();\n      return;\n    }\n\n    const {captures: thisBrowserCapturesFragmentEvents} = fragmentSupport;\n\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div([textarea('.blurable', 'Hello')])),\n      };\n    }\n\n    if (!thisBrowserCapturesFragmentEvents) {\n      done();\n    } else {\n      const fragment = document.createDocumentFragment();\n      const renderTarget = fragment.appendChild(document.createElement('textarea'));\n\n      const {sinks, sources, run} = setup(app, {\n        DOM: makeDOMDriver(renderTarget as Element),\n      });\n\n      sources.DOM.select('.blurable')\n        .events('mouseenter', {useCapture: true})\n        .addListener({\n          next: (ev: Event) => {\n            const elem = ev.target as HTMLElement;\n            assert.strictEqual(ev.type, 'mouseenter');\n            assert.strictEqual(elem.tagName, 'TEXTAREA');\n            assert.strictEqual(elem.className, 'blurable');\n            assert.strictEqual(elem.textContent, 'Hello');\n            const top = elem.parentElement as Node;\n            const renderTarget2 = top.parentNode as Node;\n            const frag = renderTarget2.parentNode as Node;\n            assert.strictEqual(frag instanceof DocumentFragment, true);\n            done();\n          },\n        });\n\n      sources.DOM.select(':root')\n        .element()\n        .drop(1)\n        .take(1)\n        .addListener({\n          next: (root: Element) => {\n            const blurable = root.querySelector('.blurable') as HTMLElement;\n\n            setTimeout(() => {\n              let event;\n              if(typeof(MouseEvent) === 'function') {\n                event = new MouseEvent('mouseenter', {\n                  'view': window,\n                  'bubbles': false,\n                  'cancelable': false\n                }); \n              } else {\n                event = document.createEvent('MouseEvent');\n                event.initMouseEvent('mouseenter', false, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n              }\n              \n              blurable.dispatchEvent(event);\n            }, 80);\n          },\n        });\n      run();\n    }\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have currentTarget or ownerTarget pointed to the selected parent",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 594,
                "column": 77
            },
            "line": 594,
            "code": "  it('should have currentTarget or ownerTarget pointed to the selected parent', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.top', [h2('.parent', [span('.child', 'Hello world')])])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select('.parent')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'SPAN');\n          assert.strictEqual(target.className, 'child');\n          assert.strictEqual(target.textContent, 'Hello world');\n          const currentTarget = ev.currentTarget as HTMLElement;\n          const ownerTarget = (ev as any).ownerTarget as HTMLElement;\n          const currentTargetIsParentH2 =\n            currentTarget.tagName === 'H2' &&\n            currentTarget.className === 'parent';\n          const ownerTargetIsParentH2 =\n            ownerTarget.tagName === 'H2' && ownerTarget.className === 'parent';\n          assert.strictEqual(\n            currentTargetIsParentH2 || ownerTargetIsParentH2,\n            true\n          );\n          dispose();\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const child = root.querySelector('.child') as HTMLElement;\n          assert.notStrictEqual(child, null);\n          assert.notStrictEqual(typeof child, 'undefined');\n          assert.strictEqual(child.tagName, 'SPAN');\n          assert.strictEqual(child.className, 'child');\n          assert.doesNotThrow(function() {\n            setTimeout(() => child.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch a non-bubbling Form `reset` event",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 652,
                "column": 52
            },
            "line": 652,
            "code": "  it('should catch a non-bubbling Form `reset` event', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [form('.form', [input('.field', {type: 'text'})])])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.form')\n      .events('reset', {}, false)\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'reset');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'FORM');\n          assert.strictEqual(target.className, 'form');\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _form = root.querySelector('.form') as HTMLFormElement;\n          setTimeout(() => _form.reset());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch a non-bubbling click event with useCapture",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 690,
                "column": 61
            },
            "line": 690,
            "code": "  it('should catch a non-bubbling click event with useCapture', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [div('.clickable', 'Hello')])),\n      };\n    }\n\n    function click(el: Element): void {\n      const ev = document.createEvent(`MouseEvent`);\n      ev.initMouseEvent(\n        `click`,\n        false, // bubble\n        true, // cancelable\n        window,\n        0,\n        0,\n        0,\n        0,\n        0, // coordinates\n        false,\n        false,\n        false,\n        false, // modifier keys\n        0, //left\n        null\n      );\n      el.dispatchEvent(ev);\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.clickable')\n      .events('click', {useCapture: true}, false)\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'DIV');\n          assert.strictEqual(target.className, 'clickable');\n          assert.strictEqual(target.textContent, 'Hello');\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const clickable = root.querySelector('.clickable') as HTMLElement;\n          setTimeout(() => click(clickable));\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should emit to multiple nonbubbling event streams",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 749,
                "column": 55
            },
            "line": 749,
            "code": "  it('should emit to multiple nonbubbling event streams', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [\n            input('.input', {type: 'text'}),\n          ])\n        ),\n      };\n    }\n\n    if (!document.hasFocus()) {\n      done();\n    } else {\n      const {sinks, sources, run} = setup(app, {\n        DOM: makeDOMDriver(createRenderTarget()),\n      });\n\n      Stream.merge(\n        sources.DOM.select('.input').events('focus'),\n        sources.DOM.select('.input').events('focus'),\n      )\n      .mapTo(1)\n      .fold((prev, current)=> prev + current, 0)\n      .addListener({\n          next: (count) => {\n            if (count === 2) {\n              done();\n            }\n          },\n        });\n\n      sources.DOM.select(':root')\n        .element()\n        .drop(1)\n        .take(1)\n        .addListener({\n          next: (root: Element) => {\n            const inputElement = root.querySelector('.input') as HTMLElement;\n            setTimeout(() => inputElement.focus(), 50);\n          },\n        });\n      run();\n    }\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch a blur event with useCapture",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 795,
                "column": 47
            },
            "line": 795,
            "code": "  it('should catch a blur event with useCapture', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [\n            input('.correct', {type: 'text'}, []),\n            input('.wrong', {type: 'text'}, []),\n            input('.dummy', {type: 'text'}),\n          ])\n        ),\n      };\n    }\n\n    if (!document.hasFocus()) {\n      done();\n    } else {\n      const {sinks, sources, run} = setup(app, {\n        DOM: makeDOMDriver(createRenderTarget()),\n      });\n\n      sources.DOM.select('.correct')\n        .events('blur', {useCapture: true})\n        .addListener({\n          next: (ev: Event) => {\n            assert.strictEqual(ev.type, 'blur');\n            assert.strictEqual((ev.target as HTMLElement).className, 'correct');\n            done();\n          },\n        });\n\n      sources.DOM.select(':root')\n        .element()\n        .drop(1)\n        .take(1)\n        .addListener({\n          next: (root: Element) => {\n            const correct = root.querySelector('.correct') as HTMLElement;\n            const wrong = root.querySelector('.wrong') as HTMLElement;\n            const dummy = root.querySelector('.dummy') as HTMLElement;\n            setTimeout(() => wrong.focus(), 50);\n            setTimeout(() => dummy.focus(), 100);\n            setTimeout(() => correct.focus(), 150);\n            setTimeout(() => dummy.focus(), 200);\n          },\n        });\n      run();\n    }\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should catch a blur event by default (no options)",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 844,
                "column": 55
            },
            "line": 844,
            "code": "  it('should catch a blur event by default (no options)', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [\n            input('.correct', {type: 'text'}, []),\n            input('.wrong', {type: 'text'}, []),\n            input('.dummy', {type: 'text'}),\n          ])\n        ),\n      };\n    }\n\n    if (!document.hasFocus()) {\n      done();\n    } else {\n      const {sinks, sources, run} = setup(app, {\n        DOM: makeDOMDriver(createRenderTarget()),\n      });\n\n      sources.DOM.select('.correct')\n        .events('blur')\n        .addListener({\n          next: (ev: Event) => {\n            assert.strictEqual(ev.type, 'blur');\n            assert.strictEqual((ev.target as HTMLElement).className, 'correct');\n            done();\n          },\n        });\n\n      sources.DOM.select(':root')\n        .element()\n        .drop(1)\n        .take(1)\n        .addListener({\n          next: (root: Element) => {\n            const correct = root.querySelector('.correct') as HTMLElement;\n            const wrong = root.querySelector('.wrong') as HTMLElement;\n            const dummy = root.querySelector('.dummy') as HTMLElement;\n            setTimeout(() => wrong.focus(), 50);\n            setTimeout(() => dummy.focus(), 100);\n            setTimeout(() => correct.focus(), 150);\n            setTimeout(() => dummy.focus(), 200);\n          },\n        });\n      run();\n    }\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not simulate bubbling for non-bubbling events",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 893,
                "column": 58
            },
            "line": 893,
            "code": "  it('should not simulate bubbling for non-bubbling events', done => {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(\n          div('.parent', [form('.form', [input('.field', {type: 'text'})])])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.parent')\n      .events('reset')\n      .addListener({\n        next: (ev: Event) => {\n          done(new Error('Reset event should not bubble to parent'));\n        },\n      });\n\n    sources.DOM.select('.form')\n      .events('reset')\n      .compose(delay(200))\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'reset');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'FORM');\n          assert.strictEqual(target.className, 'form');\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _form = root.querySelector('.form') as HTMLFormElement;\n          setTimeout(() => _form.reset());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have the DevTools flag in the source stream",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 940,
                "column": 56
            },
            "line": 940,
            "code": "  it('should have the DevTools flag in the source stream', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(h3('.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    const event$ = sources.DOM.select('.myelementclass').events('click');\n    assert.strictEqual((event$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow restarting of event streams from isolated components",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 955,
                "column": 71
            },
            "line": 955,
            "code": "  it('should allow restarting of event streams from isolated components', function(done) {\n    const outSubject = xs.create<any>();\n    const switchSubject = xs.create<any>();\n\n    function component(_sources: {DOM: DOMSource}) {\n      const itemMouseDown$ = _sources.DOM.select('.item').events(\n        'mousedown',\n        {},\n        false\n      );\n      const itemMouseUp$ = _sources.DOM.select('.item').events(\n        'mouseup',\n        {},\n        false\n      );\n\n      const itemMouseClick$ = itemMouseDown$\n        .map(down => itemMouseUp$.filter(up => down.target === up.target))\n        .flatten();\n\n      switchSubject\n        .map(() => itemMouseClick$)\n        .flatten()\n        .addListener({\n          next: (ev: any) => {\n            outSubject.shamefullySendNext(ev);\n          },\n        });\n\n      return {\n        DOM: xs.of(button('.item', ['stuff'])),\n      };\n    }\n\n    function app(_sources: {DOM: DOMSource}) {\n      return isolate(component)(_sources);\n    }\n\n    function mouseevent(el: Element, type: string) {\n      // This works on IE10\n      const ev = document.createEvent('MouseEvent');\n      ev.initMouseEvent(\n        type,\n        false, // bubble\n        true, // cancelable\n        window,\n        0,\n        0,\n        0,\n        0,\n        0, // coordinates\n        false,\n        false,\n        false,\n        false, // modifier keys\n        0, //left\n        null\n      );\n\n      // Would rather user this line below but does not work on IE10\n      //const ev = new MouseEvent(type)\n\n      el.dispatchEvent(ev);\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let count = 0;\n    outSubject.addListener({\n      next: (ev: any) => {\n        assert.strictEqual(ev.type, 'mouseup');\n        count++;\n        if (count === 2) {\n          done();\n        }\n      },\n    });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const clickable = root.querySelector('.item') as HTMLElement;\n          setTimeout(() => switchSubject.shamefullySendNext(null));\n          setTimeout(() => mouseevent(clickable, 'mousedown'), 100);\n          setTimeout(() => mouseevent(clickable, 'mouseup'), 200);\n          setTimeout(() => switchSubject.shamefullySendNext(null), 300);\n          setTimeout(() => mouseevent(clickable, 'mousedown'), 400);\n          setTimeout(() => mouseevent(clickable, 'mouseup'), 500);\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow preventing default event behavior",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1053,
                "column": 52
            },
            "line": 1053,
            "code": "  it('should allow preventing default event behavior', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {preventDefault: true})\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button');\n          assert.strictEqual(ev.defaultPrevented, true);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow preventing default event behavior with function",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1090,
                "column": 66
            },
            "line": 1090,
            "code": "  it('should allow preventing default event behavior with function', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {preventDefault: (ev: any) => ev.type === 'click'})\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button');\n          assert.strictEqual(ev.defaultPrevented, true);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow preventing default event behavior with object",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1127,
                "column": 64
            },
            "line": 1127,
            "code": "  it('should allow preventing default event behavior with object', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {preventDefault: {type: 'click'}})\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button');\n          assert.strictEqual(ev.defaultPrevented, true);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow preventing default event behavior with array in object",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1164,
                "column": 73
            },
            "line": 1164,
            "code": "  it('should allow preventing default event behavior with array in object', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button.to-prevent')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {\n        preventDefault: {target: {classList: ['button', 'to-prevent']}},\n      })\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button to-prevent');\n          assert.strictEqual(ev.defaultPrevented, true);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not prevent default on returning false from function predicate",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1203,
                "column": 75
            },
            "line": 1203,
            "code": "  it('should not prevent default on returning false from function predicate', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {preventDefault: (ev: any) => ev.type !== 'click'})\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button');\n          assert.strictEqual(ev.defaultPrevented, false);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not prevent default on returning false from object predicate",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1240,
                "column": 73
            },
            "line": 1240,
            "code": "  it('should not prevent default on returning false from object predicate', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {preventDefault: {type: 'notClick'}})\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button');\n          assert.strictEqual(ev.defaultPrevented, false);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not prevent default on returning false from array-in-object predicate",
            "suites": [
                "DOMSource.events()"
            ],
            "updatePoint": {
                "line": 1277,
                "column": 82
            },
            "line": 1277,
            "code": "  it('should not prevent default on returning false from array-in-object predicate', function(done) {\n    function app(_sources: {DOM: DOMSource}) {\n      return {\n        DOM: xs.of(div('.parent', [button('.button.to-prevent')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.button')\n      .events('click', {\n        preventDefault: {target: {classList: ['button', 'missing-class']}},\n      })\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(ev.type, 'click');\n          const target = ev.target as HTMLElement;\n          assert.strictEqual(target.tagName, 'BUTTON');\n          assert.strictEqual(target.className, 'button to-prevent');\n          assert.strictEqual(ev.defaultPrevented, false);\n          done();\n        },\n      });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const _button = root.querySelector('.button') as HTMLButtonElement;\n          setTimeout(() => _button.click());\n        },\n      });\n    run();\n  });",
            "file": "browser/events.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return source also with isolateSource and isolateSink",
            "suites": [
                "isolateSource"
            ],
            "updatePoint": {
                "line": 35,
                "column": 66
            },
            "line": 35,
            "code": "  it('should return source also with isolateSource and isolateSink', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(h('h3.top-most')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    const dispose = run();\n    const isolatedDOMSource = sources.DOM.isolateSource(\n      sources.DOM,\n      'top-most'\n    );\n    // Make assertions\n    assert.strictEqual(typeof isolatedDOMSource.isolateSource, 'function');\n    assert.strictEqual(typeof isolatedDOMSource.isolateSink, 'function');\n    dispose();\n    done();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should add an isolate field to the vtree sink",
            "suites": [
                "isolateSink"
            ],
            "updatePoint": {
                "line": 59,
                "column": 51
            },
            "line": 59,
            "code": "  it('should add an isolate field to the vtree sink', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const vtree$ = xs.of(h3('.top-most'));\n      return {\n        DOM: _sources.DOM.isolateSink(vtree$, 'foo'),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    // Make assertions\n    sinks.DOM.take(1).addListener({\n      next: (vtree: VNode) => {\n        assert.strictEqual(vtree.sel, 'h3.top-most');\n        assert.strictEqual(Array.isArray((vtree.data as any).isolate), true);\n        assert.deepStrictEqual((vtree.data as any).isolate, [\n          {type: 'total', scope: 'foo'},\n        ]);\n        setTimeout(() => {\n          dispose();\n          done();\n        });\n      },\n    });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not redundantly repeat the scope className",
            "suites": [
                "isolateSink"
            ],
            "updatePoint": {
                "line": 89,
                "column": 55
            },
            "line": 89,
            "code": "  it('should not redundantly repeat the scope className', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const vtree1$ = xs.of(span('.tab1', 'Hi'));\n      const vtree2$ = xs.of(span('.tab2', 'Hello'));\n      const first$ = _sources.DOM.isolateSink(vtree1$, '1');\n      const second$ = _sources.DOM.isolateSink(vtree2$, '2');\n      const switched$ = concat(\n        xs.of(1).compose(delay(50)),\n        xs.of(2).compose(delay(50)),\n        xs.of(1).compose(delay(50)),\n        xs.of(2).compose(delay(50)),\n        xs.of(1).compose(delay(50)),\n        xs.of(2).compose(delay(50))\n      )\n        .map(i => (i === 1 ? first$ : second$))\n        .flatten();\n      return {\n        DOM: switched$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    // Make assertions\n    sinks.DOM.drop(2)\n      .take(1)\n      .addListener({\n        next: (vtree: VNode) => {\n          assert.strictEqual(vtree.sel, 'span.tab1');\n          assert.strictEqual(Array.isArray((vtree.data as any).isolate), true);\n          assert.strictEqual((vtree.data as any).isolate.length, 1);\n          assert.deepStrictEqual((vtree.data as any).isolate, [\n            {type: 'total', scope: '1'},\n          ]);\n          dispose();\n          done();\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should prevent parent from DOM.selecting() inside the isolation",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 135,
                "column": 69
            },
            "line": 135,
            "code": "  it('should prevent parent from DOM.selecting() inside the isolation', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of(div('.foo', [h4('.bar', 'Wrong')])),\n        'ISOLATION'\n      );\n\n      const vdom$ = xs\n        .combine(xs.of(null), child$)\n        .map(([_, child]) => h3('.top-most', [child, h2('.bar', 'Correct')]));\n\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H2');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not occur with scope \":root\"",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 174,
                "column": 41
            },
            "line": 174,
            "code": "  it('should not occur with scope \":root\"', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of(div('.foo', [h4('.bar', 'Not wrong')])),\n        ':root'\n      );\n\n      const vdom$ = xs\n        .combine(xs.of(null), child$)\n        .map(([_, child]) => h3('.top-most', [child, h2('.bar', 'Correct')]));\n\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 2);\n\n          const notWrongElement = elements[0];\n          assert.notStrictEqual(notWrongElement, null);\n          assert.notStrictEqual(typeof notWrongElement, 'undefined');\n          assert.strictEqual(notWrongElement.tagName, 'H4');\n          assert.strictEqual(notWrongElement.textContent, 'Not wrong');\n\n          const correctElement = elements[1];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H2');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should apply only between siblings when given scope \".foo\"",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 220,
                "column": 64
            },
            "line": 220,
            "code": "  it('should apply only between siblings when given scope \".foo\"', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const foo$ = _sources.DOM.isolateSink(\n        xs.of(div('.container', [h4('.header', 'Correct')])),\n        '.foo'\n      );\n\n      const bar$ = _sources.DOM.isolateSink(\n        xs.of(div('.container', [h3('.header', 'Wrong')])),\n        '.bar'\n      );\n\n      const vdom$ = xs\n        .combine(foo$, bar$)\n        .map(([foo, bar]) =>\n          div('.top-most', [foo, bar, h2('.header', 'Correct')])\n        );\n\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    // Assert parent has total access to its children\n    sources.DOM.select('.header')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 3);\n          assert.strictEqual(elements[0].tagName, 'H4');\n          assert.strictEqual(elements[0].textContent, 'Correct');\n          assert.strictEqual(elements[1].tagName, 'H3');\n          assert.strictEqual(elements[1].textContent, 'Wrong');\n          assert.strictEqual(elements[2].tagName, 'H2');\n          assert.strictEqual(elements[2].textContent, 'Correct');\n\n          // Assert .foo child has no access to .bar child\n          sources.DOM.isolateSource(sources.DOM, '.foo')\n            .select('.header')\n            .elements()\n            .take(1)\n            .addListener({\n              next: (els: Array<Element>) => {\n                assert.strictEqual(Array.isArray(els), true);\n                assert.strictEqual(els.length, 1);\n                assert.strictEqual(els[0].tagName, 'H4');\n                assert.strictEqual(els[0].textContent, 'Correct');\n                done();\n              },\n            });\n        },\n      });\n\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should apply only between siblings when given scope \"#foo\"",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 283,
                "column": 64
            },
            "line": 283,
            "code": "  it('should apply only between siblings when given scope \"#foo\"', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const foo$ = _sources.DOM.isolateSink(\n        xs.of(div('.container', [h4('.header', 'Correct')])),\n        '#foo'\n      );\n\n      const bar$ = _sources.DOM.isolateSink(\n        xs.of(div('.container', [h3('.header', 'Wrong')])),\n        '#bar'\n      );\n\n      const vdom$ = xs\n        .combine(foo$, bar$)\n        .map(([foo, bar]) =>\n          div('.top-most', [foo, bar, h2('.header', 'Correct')])\n        );\n\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    // Assert parent has total access to its children\n    sources.DOM.select('.header')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 3);\n          assert.strictEqual(elements[0].tagName, 'H4');\n          assert.strictEqual(elements[0].textContent, 'Correct');\n          assert.strictEqual(elements[1].tagName, 'H3');\n          assert.strictEqual(elements[1].textContent, 'Wrong');\n          assert.strictEqual(elements[2].tagName, 'H2');\n          assert.strictEqual(elements[2].textContent, 'Correct');\n\n          // Assert .foo child has no access to .bar child\n          sources.DOM.isolateSource(sources.DOM, '#foo')\n            .select('.header')\n            .elements()\n            .take(1)\n            .addListener({\n              next: (els: Array<Element>) => {\n                assert.strictEqual(Array.isArray(els), true);\n                assert.strictEqual(els.length, 1);\n                assert.strictEqual(els[0].tagName, 'H4');\n                assert.strictEqual(els[0].textContent, 'Correct');\n                done();\n              },\n            });\n        },\n      });\n\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should work with thunks",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 346,
                "column": 29
            },
            "line": 346,
            "code": "  it('should work with thunks', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of<VNode>(thunk('div.foo', () => div('.foo', [h4('.bar', 'Wrong')]), [])),\n        'ISOLATION'\n      );\n\n      const vdom$ = xs\n        .combine(xs.of(null), child$)\n        .map(([_, child]) => h3('.top-most', [child, h2('.bar', 'Correct')]));\n\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select('.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H2');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow using elements() in an isolated main() fn",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 385,
                "column": 60
            },
            "line": 385,
            "code": "  it('should allow using elements() in an isolated main() fn', function(done) {\n    function main(_sources: {DOM: MainDOMSource}) {\n      const elem$ = _sources.DOM.select(':root').elements();\n      const vnode$ = elem$.map(elem =>\n        h('div.bar', 'left=' + (elem[0] as any).offsetLeft)\n      );\n      return {\n        DOM: vnode$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(isolate(main), {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const barElem = root.querySelector('.bar') as Element;\n          assert.notStrictEqual(barElem, null);\n          assert.notStrictEqual(typeof barElem, 'undefined');\n          assert.strictEqual(barElem.tagName, 'DIV');\n          assert.strictEqual(barElem.textContent, 'left=8');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow parent to DOM.select() in its own isolation island",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 417,
                "column": 69
            },
            "line": 417,
            "code": "  it('should allow parent to DOM.select() in its own isolation island', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const {isolateSource, isolateSink} = _sources.DOM;\n      const islandElement$ = isolateSource(_sources.DOM, 'island')\n        .select('.bar')\n        .elements();\n      const islandVDom$ = isolateSink(\n        xs.of(div([h3('.bar', 'Correct')])),\n        'island'\n      );\n      const child$ = isolateSink(\n        islandVDom$.map(islandVDom =>\n          div('.foo', [islandVDom, h4('.bar', 'Wrong')])\n        ),\n        'ISOLATION'\n      );\n      const vdom$ = child$.map(child => h3('.top-most', [child]));\n\n      return {\n        DOM: vdom$,\n        island: islandElement$,\n      };\n    }\n\n    const drivers = {\n      DOM: makeDOMDriver(createRenderTarget()),\n      island(sink: Stream<Array<Element>>) {},\n    };\n    const {sinks, sources, run} = setup(app, drivers);\n\n    sinks.island\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H3');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should isolate DOM.select between parent and (wrapper) child",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 465,
                "column": 66
            },
            "line": 465,
            "code": "  it('should isolate DOM.select between parent and (wrapper) child', function(done) {\n    function Frame(_sources: {DOM: MainDOMSource; content$: Stream<any>}) {\n      const click$ = _sources.DOM.select('.foo').events('click');\n      const vdom$ = _sources.content$.map(content =>\n        h4('.foo.frame', {style: {backgroundColor: 'lightblue'}}, [content])\n      );\n      return {\n        DOM: vdom$,\n        click$,\n      };\n    }\n\n    function Monalisa(_sources: {DOM: MainDOMSource}): any {\n      const {isolateSource, isolateSink} = _sources.DOM;\n\n      const islandDOMSource = isolateSource(_sources.DOM, '.island');\n      const monalisaClick$ = islandDOMSource.select('.foo').events('click');\n      const islandDOMSink$ = isolateSink(\n        xs.of(span('.foo.monalisa', 'Monalisa')),\n        '.island'\n      );\n\n      const click$ = _sources.DOM.select('.foo').events('click');\n\n      const frameDOMSource = isolateSource(_sources.DOM, 'myFrame');\n      const frame = Frame({DOM: frameDOMSource, content$: islandDOMSink$});\n      const outerVTree$ = isolateSink(frame.DOM, 'myFrame');\n\n      return {\n        DOM: outerVTree$,\n        frameClick: frame.click$,\n        monalisaClick: monalisaClick$,\n        click: click$,\n      };\n    }\n\n    const {sources, sinks, run} = setup(Monalisa, {\n      DOM: makeDOMDriver(createRenderTarget()),\n      frameClick: () => {},\n      monalisaClick: () => {},\n      click: () => {},\n    });\n    let dispose: any;\n\n    const frameClick$ = sinks.frameClick.map((ev: any) => ({\n      type: ev.type,\n      tagName: (ev.target as HTMLElement).tagName,\n    }));\n\n    const _monalisaClick$ = sinks.monalisaClick.map((ev: any) => ({\n      type: ev.type,\n      tagName: (ev.target as HTMLElement).tagName,\n    }));\n\n    const grandparentClick$ = sinks.click.map((ev: any) => ({\n      type: ev.type,\n      tagName: (ev.target as HTMLElement).tagName,\n    }));\n\n    // Stop the propagtion of the second click\n    sinks.monalisaClick\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (ev: Event) => ev.stopPropagation(),\n      });\n\n    let totalClickHandlersCalled = 0;\n    let frameClicked = false;\n    frameClick$.addListener({\n      next: (event: any) => {\n        assert.strictEqual(frameClicked, false);\n        assert.strictEqual(event.type, 'click');\n        assert.strictEqual(event.tagName, 'H4');\n        frameClicked = true;\n        totalClickHandlersCalled++;\n      },\n    });\n\n    // Monalisa should receive two clicks\n    let monalisaClicked = 0;\n    _monalisaClick$.addListener({\n      next: (event: any) => {\n        assert.strictEqual(monalisaClicked < 2, true);\n        assert.strictEqual(event.type, 'click');\n        assert.strictEqual(event.tagName, 'SPAN');\n        monalisaClicked++;\n        totalClickHandlersCalled++;\n      },\n    });\n\n    // The grandparent should receive sibling isolated events\n    // from the monalisa even though it is passed into the\n    // total isolated Frame\n    let grandparentClicked = false;\n    grandparentClick$.addListener({\n      next: (event: any) => {\n        assert.strictEqual(event.type, 'click');\n        assert.strictEqual(event.tagName, 'SPAN');\n        assert.strictEqual(grandparentClicked, false);\n        grandparentClicked = true;\n        totalClickHandlersCalled++;\n        assert.doesNotThrow(() => {\n          setTimeout(() => {\n            assert.strictEqual(totalClickHandlersCalled, 4);\n            dispose();\n            done();\n          }, 10);\n        });\n      },\n    });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const frameFoo = root.querySelector('.foo.frame') as HTMLElement;\n          const monalisaFoo = root.querySelector(\n            '.foo.monalisa'\n          ) as HTMLElement;\n          assert.notStrictEqual(frameFoo, null);\n          assert.notStrictEqual(monalisaFoo, null);\n          assert.notStrictEqual(typeof frameFoo, 'undefined');\n          assert.notStrictEqual(typeof monalisaFoo, 'undefined');\n          assert.strictEqual(frameFoo.tagName, 'H4');\n          assert.strictEqual(monalisaFoo.tagName, 'SPAN');\n          assert.doesNotThrow(() => {\n            setTimeout(() => frameFoo.click(), 0);\n            setTimeout(() => monalisaFoo.click());\n            setTimeout(() => monalisaFoo.click());\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow a child component to DOM.select() its own root",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 603,
                "column": 65
            },
            "line": 603,
            "code": "  it('should allow a child component to DOM.select() its own root', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of(span('.foo', [h4('.bar', 'Wrong')])),\n        'ISOLATION'\n      );\n\n      return {\n        DOM: child$.map(child => h3('.top-most', [child])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const {isolateSource} = sources.DOM;\n    let dispose: any;\n    isolateSource(sources.DOM, 'ISOLATION')\n      .select('.foo')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'SPAN');\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow DOM.selecting svg elements",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 643,
                "column": 45
            },
            "line": 643,
            "code": "  it('should allow DOM.selecting svg elements', function(done) {\n    function App(_sources: {DOM: MainDOMSource}) {\n      const triangleElement$ = _sources.DOM.select('.triangle').elements();\n\n      const svgTriangle = svg({attrs: {width: 150, height: 150}}, [\n        svg.polygon({\n          attrs: {\n            class: 'triangle',\n            points: '20 0 20 150 150 20',\n          },\n        }),\n      ]);\n\n      return {\n        DOM: xs.of(svgTriangle),\n        triangleElement: triangleElement$,\n      };\n    }\n\n    function IsolatedApp(_sources: {DOM: MainDOMSource}) {\n      const {isolateSource, isolateSink} = _sources.DOM;\n      const isolatedDOMSource = isolateSource(_sources.DOM, 'ISOLATION');\n      const app = App({DOM: isolatedDOMSource});\n      const isolateDOMSink = isolateSink(app.DOM, 'ISOLATION');\n      return {\n        DOM: isolateDOMSink,\n        triangleElement: app.triangleElement,\n      };\n    }\n\n    const drivers = {\n      DOM: makeDOMDriver(createRenderTarget()),\n      triangleElement: (sink: any) => {},\n    };\n    const {sinks, sources, run} = setup(IsolatedApp, drivers);\n\n    // Make assertions\n    sinks.triangleElement\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const triangleElement = elements[0];\n          assert.notStrictEqual(triangleElement, null);\n          assert.notStrictEqual(typeof triangleElement, 'undefined');\n          assert.strictEqual(triangleElement.tagName, 'polygon');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow DOM.select()ing its own root without classname or id",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 696,
                "column": 71
            },
            "line": 696,
            "code": "  it('should allow DOM.select()ing its own root without classname or id', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of(span([h4('.bar', 'Wrong')])),\n        'ISOLATION'\n      );\n\n      return {\n        DOM: child$.map(child => h3('.top-most', [child])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const {isolateSource} = sources.DOM;\n\n    isolateSource(sources.DOM, 'ISOLATION')\n      .select('span')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'SPAN');\n          done();\n        },\n      });\n\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow DOM.select()ing all elements with `*`",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 734,
                "column": 56
            },
            "line": 734,
            "code": "  it('should allow DOM.select()ing all elements with `*`', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        xs.of(span([div([h4('.foo', 'hello'), h4('.bar', 'world')])])),\n        'ISOLATION'\n      );\n\n      return {\n        DOM: child$.map(child => h3('.top-most', [child])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const {isolateSource} = sources.DOM;\n\n    isolateSource(sources.DOM, 'ISOLATION')\n      .select('*')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 4);\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should select() isolated element with tag + class",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 767,
                "column": 55
            },
            "line": 767,
            "code": "  it('should select() isolated element with tag + class', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(\n          h3('.top-most', [\n            h2('.bar', 'Wrong'),\n            div({isolate: [{type: 'total', scope: 'foo'}]}, [\n              h4('.bar', 'Correct'),\n            ]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    const isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');\n\n    isolatedDOMSource\n      .select('h4.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0];\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H4');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow isolatedDOMSource.events() to work without crashing",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 805,
                "column": 70
            },
            "line": 805,
            "code": "  it('should allow isolatedDOMSource.events() to work without crashing', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(\n          h3('.top-most', [\n            div({isolate: [{type: 'total', scope: 'foo'}]}, [\n              h4('.bar', 'Hello'),\n            ]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    let dispose: any;\n    const isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');\n\n    isolatedDOMSource.events('click').addListener({\n      next: (ev: Event) => {\n        dispose();\n        done();\n      },\n    });\n\n    isolatedDOMSource\n      .select('div')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0] as HTMLElement;\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'DIV');\n          assert.strictEqual(correctElement.textContent, 'Hello');\n          setTimeout(() => {\n            correctElement.click();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should process bubbling events from inner to outer component",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 852,
                "column": 66
            },
            "line": 852,
            "code": "  it('should process bubbling events from inner to outer component', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(\n          h3('.top-most', [\n            h2('.bar', 'Wrong'),\n            div({isolate: [{type: 'sibling', scope: '.foo'}]}, [\n              h4('.bar', 'Correct'),\n            ]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    let dispose: any;\n    const isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, '.foo');\n\n    let called = false;\n\n    sources.DOM.select('.top-most')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(called, true);\n          dispose();\n          done();\n        },\n      });\n\n    isolatedDOMSource\n      .select('h4.bar')\n      .events('click')\n      .addListener({\n        next: (ev: Event) => {\n          assert.strictEqual(called, false);\n          called = true;\n        },\n      });\n\n    isolatedDOMSource\n      .select('h4.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0] as HTMLElement;\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H4');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          setTimeout(() => {\n            correctElement.click();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should stop bubbling the event if the currentTarget was removed",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 915,
                "column": 69
            },
            "line": 915,
            "code": "  it('should stop bubbling the event if the currentTarget was removed', function(done) {\n    function main(_sources: {DOM: MainDOMSource}) {\n      const childExistence$ = _sources.DOM.isolateSource(_sources.DOM, 'foo')\n        .select('h4.bar')\n        .events('click')\n        .map(() => false)\n        .startWith(true);\n\n      return {\n        DOM: childExistence$.map(exists =>\n          div([\n            div('.top-most', {isolate: 'top'}, [\n              h2('.bar', 'Wrong'),\n              exists\n                ? div({isolate: [{type: 'total', scope: 'foo'}]}, [\n                    h4('.bar', 'Correct'),\n                  ])\n                : null,\n            ]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n    let dispose: any;\n    const topDOMSource = sources.DOM.isolateSource(sources.DOM, 'top');\n    const fooDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');\n\n    let parentEventHandlerCalled = false;\n\n    topDOMSource\n      .select('.bar')\n      .events('click')\n      .addListener({\n        next: (ev: any) => {\n          parentEventHandlerCalled = true;\n          done('this should not be called');\n        },\n      });\n\n    fooDOMSource\n      .select('.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const correctElement = elements[0] as HTMLElement;\n          assert.notStrictEqual(correctElement, null);\n          assert.notStrictEqual(typeof correctElement, 'undefined');\n          assert.strictEqual(correctElement.tagName, 'H4');\n          assert.strictEqual(correctElement.textContent, 'Correct');\n          setTimeout(() => {\n            correctElement.click();\n            setTimeout(() => {\n              assert.strictEqual(parentEventHandlerCalled, false);\n              dispose();\n              done();\n            }, 150);\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should handle a higher-order graph when events() are subscribed",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 984,
                "column": 69
            },
            "line": 984,
            "code": "  it('should handle a higher-order graph when events() are subscribed', done => {\n    let errorHappened = false;\n    let clickDetected = false;\n\n    function Child(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: _sources.DOM.select('.foo')\n          .events('click')\n          .debug(() => {\n            clickDetected = true;\n          })\n          .replaceError(() => {\n            errorHappened = true;\n            return xs.empty();\n          })\n          .mapTo(1)\n          .startWith(0)\n          .map(num => div('.container', [h3('.foo', 'Child foo')])),\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const first = isolate(Child, 'first')(_sources);\n      const second = isolate(Child, 'second')(_sources);\n      const oneChild = [first];\n      const twoChildren = [first, second];\n      const vnode$ = xs\n        .periodic(50)\n        .take(1)\n        .startWith(-1)\n        .map(i => (i === -1 ? oneChild : twoChildren))\n        .map(children =>\n          xs\n            .combine(...children.map(child => child.DOM))\n            .map(childVNodes => div('.parent', childVNodes))\n        )\n        .flatten();\n      return {\n        DOM: vnode$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .element()\n      .drop(2)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const parentEl = root.querySelector('.parent') as HTMLElement;\n          const foo = parentEl.querySelectorAll('.foo')[1] as HTMLElement;\n          assert.notStrictEqual(parentEl, null);\n          assert.notStrictEqual(typeof parentEl, 'undefined');\n          assert.notStrictEqual(foo, null);\n          assert.notStrictEqual(typeof foo, 'undefined');\n          assert.strictEqual(parentEl.tagName, 'DIV');\n          setTimeout(() => {\n            assert.strictEqual(errorHappened, false);\n            foo.click();\n            setTimeout(() => {\n              assert.strictEqual(clickDetected, true);\n              dispose();\n              done();\n            }, 50);\n          }, 100);\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should handle events when child is removed and re-added",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1058,
                "column": 61
            },
            "line": 1058,
            "code": "  it('should handle events when child is removed and re-added', done => {\n    let clicksCount = 0;\n\n    function Child(_sources: {DOM: MainDOMSource}) {\n      _sources.DOM.select('.foo')\n        .events('click')\n        .addListener({\n          next: () => {\n            clicksCount++;\n          },\n        });\n      return {\n        DOM: xs.of(div('.foo', ['This is foo'])),\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const child = isolate(Child)(_sources);\n      // make child.DOM be inserted, removed, and inserted again\n      const innerDOM$ = xs\n        .periodic(120)\n        .take(2)\n        .map(x => x + 1)\n        .startWith(0)\n        .map(x => (x === 1 ? xs.of(div()) : (child.DOM)))\n        .flatten();\n      return {\n        DOM: innerDOM$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(3)\n      .addListener({\n        next: (root: Element) => {\n          setTimeout(() => {\n            const foo = root.querySelector('.foo');\n            if (!foo) {\n              return;\n            }\n            (foo as any).click();\n          }, 0);\n        },\n      });\n    setTimeout(() => {\n      assert.strictEqual(clicksCount, 2);\n      dispose();\n      done();\n    }, 500);\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should handle events when parent is removed and re-added",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1117,
                "column": 62
            },
            "line": 1117,
            "code": "  it('should handle events when parent is removed and re-added', done => {\n    let clicksCount = 0;\n\n    function Child(_sources: {DOM: MainDOMSource}) {\n      _sources.DOM.select('.foo')\n        .events('click')\n        .addListener({\n          next: () => {\n            clicksCount++;\n          },\n        });\n      return {\n        DOM: xs.of(div('.foo', ['This is foo'])),\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const child = isolate(Child, 'child')(_sources);\n      // change parent key, causing it to be recreated\n      const x$ = xs\n        .periodic(120)\n        .map(x => x + 1)\n        .startWith(0)\n        .take(4);\n      const innerDOM$ = xs\n        .combine<number, VNode>(x$, child.DOM)\n        .map(([x, childVDOM]) =>\n          div(`.parent${x}`, {key: `key${x}`}, [childVDOM, `${x}`])\n        );\n      return {\n        DOM: innerDOM$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(4)\n      .addListener({\n        next: (root: Element) => {\n          setTimeout(() => {\n            const foo = root.querySelector('.foo');\n            if (!foo) {\n              return;\n            }\n            (foo as any).click();\n          }, 0);\n        },\n      });\n    setTimeout(() => {\n      assert.strictEqual(clicksCount, 4);\n      dispose();\n      done();\n    }, 800);\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should handle events when parent is removed and re-added, and has isolation scope",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1179,
                "column": 87
            },
            "line": 1179,
            "code": "  it('should handle events when parent is removed and re-added, and has isolation scope', done => {\n    let clicksCount = 0;\n\n    function Child(_sources: {DOM: MainDOMSource}) {\n      _sources.DOM.select('.foo')\n        .events('click')\n        .addListener({\n          next: () => {\n            clicksCount++;\n          },\n        });\n      return {\n        DOM: xs.of(div('.foo', ['This is foo'])),\n      };\n    }\n\n    function Parent(_sources: {DOM: MainDOMSource}) {\n      const child = isolate(Child, 'child')(_sources);\n      // change parent key, causing it to be recreated\n      const x$ = xs\n        .periodic(120)\n        .map(x => x + 1)\n        .startWith(0)\n        .take(4);\n      const innerDOM$ = xs\n        .combine<number, VNode>(x$, child.DOM)\n        .map(([x, childVDOM]) =>\n          div(`.parent${x}`, {key: `key${x}`}, [childVDOM, `${x}`])\n        );\n      return {\n        DOM: innerDOM$,\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const parent = isolate(Parent, 'parent')(_sources);\n      return {\n        DOM: parent.DOM,\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(4)\n      .addListener({\n        next: (root: Element) => {\n          setTimeout(() => {\n            const foo = root.querySelector('.foo');\n            if (!foo) {\n              return;\n            }\n            (foo as any).click();\n          }, 0);\n        },\n      });\n    setTimeout(() => {\n      assert.strictEqual(clicksCount, 4);\n      dispose();\n      done();\n    }, 800);\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow null or undefined isolated child DOM",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1573,
                "column": 55
            },
            "line": 1573,
            "code": "  it('should allow null or undefined isolated child DOM', function(done) {\n    function child(_sources: {DOM: MainDOMSource}) {\n      const visible$ = xs\n        .periodic(50)\n        .take(1)\n        .fold((acc, _) => !acc, true);\n      const vdom$ = visible$.map(visible => (visible ? h4('child') : null));\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const childSinks = isolate(child, 'child')(_sources);\n      const vdom$ = childSinks.DOM.map((childVDom: VNode) =>\n        div('.parent', [childVDom, h2('part of parent')])\n      );\n      return {\n        DOM: vdom$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const parentEl = root.querySelector('.parent') as Element;\n          assert.strictEqual(parentEl.childNodes.length, 2);\n          assert.strictEqual(parentEl.children[0].tagName, 'H4');\n          assert.strictEqual(parentEl.children[0].textContent, 'child');\n          assert.strictEqual(parentEl.children[1].tagName, 'H2');\n          assert.strictEqual(\n            parentEl.children[1].textContent,\n            'part of parent'\n          );\n        },\n      });\n    sources.DOM.element()\n      .drop(2)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const parentEl = root.querySelector('.parent') as Element;\n          assert.strictEqual(parentEl.childNodes.length, 1);\n          assert.strictEqual(parentEl.children[0].tagName, 'H2');\n          assert.strictEqual(\n            parentEl.children[0].textContent,\n            'part of parent'\n          );\n          dispose();\n          done();\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should allow recursive isolation using the same scope",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1635,
                "column": 59
            },
            "line": 1635,
            "code": "  it('should allow recursive isolation using the same scope', done => {\n    function Item(_sources: {DOM: MainDOMSource}, count: number) {\n      const childVdom$: Stream<VNode> =\n        count > 0\n          ? isolate(Item, '0')(_sources, count - 1).DOM\n          : xs.of<any>(null);\n\n      const highlight$ = _sources.DOM.select('button')\n        .events('click')\n        .mapTo(true)\n        .fold((x, _) => !x, false);\n\n      const vdom$ = xs\n        .combine(childVdom$, highlight$)\n        .map(([childVdom, highlight]) =>\n          div([\n            button('.btn', highlight ? 'HIGHLIGHTED' : 'click me'),\n            childVdom,\n          ])\n        );\n      return {DOM: vdom$};\n    }\n\n    function main(_sources: {DOM: MainDOMSource}) {\n      const vdom$ = Item(_sources, 3).DOM;\n      return {DOM: vdom$};\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const buttons = root.querySelectorAll('.btn');\n          assert.strictEqual(buttons.length, 4);\n          const firstButton = buttons[0];\n          const secondButton = buttons[1];\n          const thirdButton = buttons[2] as HTMLElement;\n          const forthButton = buttons[3];\n          setTimeout(() => {\n            thirdButton.click();\n          }, 100);\n          setTimeout(() => {\n            assert.notStrictEqual(firstButton.textContent, 'HIGHLIGHTED');\n            assert.notStrictEqual(secondButton.textContent, 'HIGHLIGHTED');\n            assert.strictEqual(thirdButton.textContent, 'HIGHLIGHTED');\n            assert.notStrictEqual(forthButton.textContent, 'HIGHLIGHTED');\n            dispose();\n            done();\n          }, 300);\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not lose event delegators when components are moved around",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1695,
                "column": 71
            },
            "line": 1695,
            "code": "  it('should not lose event delegators when components are moved around', function(done) {\n    function component(_sources: {DOM: MainDOMSource}) {\n      const click$ = _sources.DOM.select('.click-me')\n        .events('click')\n        .mapTo('clicked');\n\n      return {\n        DOM: xs.of(button('.click-me', 'click me')),\n        click$,\n      };\n    }\n\n    function app(_sources: {DOM: MainDOMSource}) {\n      const comp = isolate(component, 'child')(_sources);\n      const position$ = fromDiagram('1-2|');\n      return {\n        DOM: xs.combine(position$, comp.DOM).map(([position, childDom]) => {\n          const children =\n            position === '1'\n              ? [div([childDom]), div()]\n              : [div(), div([childDom])];\n\n          return div(children);\n        }),\n\n        click$: comp.click$,\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n      click$: () => {},\n    });\n\n    const expectedClicks = ['clicked', 'clicked'];\n    let dispose: any;\n    sinks.click$.take(2).addListener({\n      next: function(message: string) {\n        assert.strictEqual(message, expectedClicks.shift());\n      },\n      complete: function() {\n        assert.strictEqual(expectedClicks.length, 0);\n        done();\n        dispose();\n      },\n    });\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .addListener({\n        next: function(root: Element) {\n          const _button = root.querySelector('button.click-me') as HTMLElement;\n          _button.click();\n        },\n      });\n\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not break isolation if animated elements are removed",
            "suites": [
                "isolation"
            ],
            "updatePoint": {
                "line": 1755,
                "column": 65
            },
            "line": 1755,
            "code": "  it('should not break isolation if animated elements are removed', done => {\n    let eventProcessed = false;\n    function Child(_sources: {DOM: MainDOMSource}): any {\n      const remove$ = _sources.DOM.select('.click')\n        .events('click')\n        .mapTo(false);\n\n      _sources.DOM.select('.click')\n        .events('click')\n        .addListener({\n          next: (ev: any) => {\n            assert.strictEqual(ev.target.textContent, 'remove');\n            assert.strictEqual(eventProcessed, false);\n            eventProcessed = true;\n          },\n        });\n\n      const style = {\n        transition: 'transform 0.5s',\n        // remove handler broke isolation in earier versions\n        remove: {\n          transform: 'translateY(100%)',\n        },\n      };\n\n      return {\n        DOM: xs.of(button('.click', {style}, 'remove')),\n        remove: remove$,\n      };\n    }\n\n    function main(_sources: {DOM: MainDOMSource}): any {\n      const childSinks = isolate(Child)(_sources);\n\n      const showChild$ = _sources.DOM.select('.click')\n        .events('click')\n        .mapTo(true);\n\n      showChild$.addListener({\n        next: ev => assert(false),\n      });\n\n      const state$ = xs.merge(showChild$, childSinks.remove).startWith(true);\n\n      return {\n        DOM: xs\n          .combine(state$, childSinks.DOM)\n          .map(([show, child]) =>\n            div([button('.click', 'show'), show ? child : null])\n          ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(main, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: function(root: Element) {\n          const _button = root.querySelector(\n            'button.click:nth-child(2)'\n          ) as HTMLElement;\n          assert.strictEqual(_button.textContent, 'remove');\n          _button.click();\n          setTimeout(() => {\n            assert.strictEqual(eventProcessed, true);\n            assert.strictEqual(root.querySelectorAll('button').length, 1);\n            dispose();\n            done();\n          }, 600);\n        },\n      });\n\n    dispose = run();\n  });",
            "file": "browser/isolation.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have Observable `:root` in DOM source",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 50
            },
            "line": 33,
            "code": "  it('should have Observable `:root` in DOM source', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('.top-most', [p('Foo'), span('Bar')])),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select(':root')\n      .element()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (root: Element) => {\n          const classNameRegex = /top\\-most/;\n          assert.strictEqual(root.tagName, 'DIV');\n          const child = root.children[0];\n          const execResult = classNameRegex.exec(child.className);\n          assert.notStrictEqual(execResult, null);\n          assert.strictEqual((execResult as any)[0], 'top-most');\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return a DOMSource with elements(), events(), select()",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 66,
                "column": 67
            },
            "line": 66,
            "code": "  it('should return a DOMSource with elements(), events(), select()', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(h3('.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const dispose = run();\n    // Make assertions\n    const selection = sources.DOM.select('.myelementclass');\n    assert.strictEqual(typeof selection, 'object');\n    assert.strictEqual(typeof selection.select, 'function');\n    assert.strictEqual(typeof selection.select('h3'), 'object');\n    assert.strictEqual(typeof selection.elements, 'function');\n    assert.strictEqual(typeof selection.element(), 'object');\n    assert.strictEqual(typeof selection.element().subscribe, 'function');\n    assert.strictEqual(typeof selection.elements(), 'object');\n    assert.strictEqual(typeof selection.elements().subscribe, 'function');\n    assert.strictEqual(typeof selection.events, 'function');\n    assert.strictEqual(typeof selection.events('click'), 'object');\n    assert.strictEqual(typeof selection.events('click').subscribe, 'function');\n    dispose();\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have an observable of DOM elements",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 47
            },
            "line": 95,
            "code": "  it('should have an observable of DOM elements', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(h3('.myelementclass', 'Foobar')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    // Make assertions\n    sources.DOM.select('.myelementclass')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.notStrictEqual(elements, null);\n          assert.notStrictEqual(typeof elements, 'undefined');\n          // Is an Array\n          assert.strictEqual(Array.isArray(elements), true);\n          assert.strictEqual(elements.length, 1);\n          // Array with the H3 element\n          assert.strictEqual(elements[0].tagName, 'H3');\n          assert.strictEqual(elements[0].textContent, 'Foobar');\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should not select element outside the given scope",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 131,
                "column": 55
            },
            "line": 131,
            "code": "  it('should not select element outside the given scope', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(\n          h3('.top-most', [\n            h2('.bar', 'Wrong'),\n            div('.foo', [h4('.bar', 'Correct')]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    // Make assertions\n    sources.DOM.select('.foo')\n      .select('.bar')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const element = elements[0];\n          assert.notStrictEqual(element, null);\n          assert.notStrictEqual(typeof element, 'undefined');\n          assert.strictEqual(element.tagName, 'H4');\n          assert.strictEqual(element.textContent, 'Correct');\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should select svg element",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 171,
                "column": 31
            },
            "line": 171,
            "code": "  it('should select svg element', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(\n          svg({attrs: {width: 150, height: 150}}, [\n            svg.polygon({\n              attrs: {\n                class: 'triangle',\n                points: '20 0 20 150 150 20',\n              },\n            }),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    // Make assertions\n    const selection = sources.DOM.select('.triangle')\n      .elements()\n      .drop(1)\n      .take(1)\n      .addListener({\n        next: (elements: Array<Element>) => {\n          assert.strictEqual(elements.length, 1);\n          const triangleElement = elements[0];\n          assert.notStrictEqual(triangleElement, null);\n          assert.notStrictEqual(typeof triangleElement, 'undefined');\n          assert.strictEqual(triangleElement.tagName, 'polygon');\n          done();\n        },\n      });\n    run();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should support selecting the document element",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 209,
                "column": 51
            },
            "line": 209,
            "code": "  it('should support selecting the document element', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    function isDocument(element: any): element is Document {\n      return 'body' in element && 'head' in element;\n    }\n\n    let dispose: any;\n    sources.DOM.select('document')\n      .events('click')\n      .take(1)\n      .addListener({\n        next: (event: Event) => {\n          assert(isDocument(event.target));\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n    simulant.fire(document, 'click');\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should support selecting the body element",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 241,
                "column": 47
            },
            "line": 241,
            "code": "  it('should support selecting the body element', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    let dispose: any;\n    sources.DOM.select('body')\n      .events('click')\n      .take(1)\n      .addListener({\n        next: (event: Event) => {\n          assert.equal((event.target as HTMLElement).tagName, 'BODY');\n          setTimeout(() => {\n            dispose();\n            done();\n          });\n        },\n      });\n    dispose = run();\n    simulant.fire(document.body, 'click');\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in BodyDOMSource element() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 269,
                "column": 65
            },
            "line": 269,
            "code": "  it('should have DevTools flag in BodyDOMSource element() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const element$ = sources.DOM.select('body').element();\n    assert.strictEqual((element$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in BodyDOMSource elements() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 285,
                "column": 66
            },
            "line": 285,
            "code": "  it('should have DevTools flag in BodyDOMSource elements() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const element$ = sources.DOM.select('body').elements();\n    assert.strictEqual((element$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in BodyDOMSource events() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 301,
                "column": 64
            },
            "line": 301,
            "code": "  it('should have DevTools flag in BodyDOMSource events() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const event$ = sources.DOM.select('body').events('click');\n    assert.strictEqual((event$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in DocumentDOMSource element() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 317,
                "column": 69
            },
            "line": 317,
            "code": "  it('should have DevTools flag in DocumentDOMSource element() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const element$ = sources.DOM.select('document').element();\n    assert.strictEqual((element$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in DocumentDOMSource elements() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 333,
                "column": 70
            },
            "line": 333,
            "code": "  it('should have DevTools flag in DocumentDOMSource elements() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const element$ = sources.DOM.select('document').elements();\n    assert.strictEqual((element$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in DocumentDOMSource events() stream",
            "suites": [
                "DOMSource.select()"
            ],
            "updatePoint": {
                "line": 349,
                "column": 68
            },
            "line": 349,
            "code": "  it('should have DevTools flag in DocumentDOMSource events() stream', function(done) {\n    function app(_sources: {DOM: MainDOMSource}) {\n      return {\n        DOM: xs.of(div('hello world')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: makeDOMDriver(createRenderTarget()),\n    });\n\n    const event$ = sources.DOM.select('document').events('click');\n    assert.strictEqual((event$ as any)._isCycleSource, 'DOM');\n    done();\n  });",
            "file": "browser/select.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should be in accessible in the API",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 25,
                "column": 40
            },
            "line": 25,
            "code": "  it('should be in accessible in the API', function() {\n    assert.strictEqual(typeof mockDOMSource, 'function');\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should make an Observable for clicks on `.foo`",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 29,
                "column": 52
            },
            "line": 29,
            "code": "  it('should make an Observable for clicks on `.foo`', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n      },\n    });\n    userEvents\n      .select('.foo')\n      .events('click')\n      .subscribe({\n        next: (ev: any) => {\n          assert.strictEqual(ev, 135);\n          done();\n        },\n        error: done,\n        complete: () => {},\n      });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should make multiple user event Observables",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 48,
                "column": 49
            },
            "line": 48,
            "code": "  it('should make multiple user event Observables', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n      },\n      '.bar': {\n        scroll: of(2),\n      },\n    });\n    combineLatest(\n      userEvents.select('.foo').events('click'),\n      userEvents.select('.bar').events('scroll'),\n      (a: number, b: number) => a * b\n    ).subscribe({\n      next: ev => {\n        assert.strictEqual(ev, 270);\n        done();\n      },\n      error: done,\n      complete: () => {},\n    });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should make multiple user event Observables on the same selector",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 71,
                "column": 70
            },
            "line": 71,
            "code": "  it('should make multiple user event Observables on the same selector', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n        scroll: of(3),\n      },\n    });\n    combineLatest(\n      userEvents.select('.foo').events('click'),\n      userEvents.select('.foo').events('scroll'),\n      (a: number, b: number) => a * b\n    ).subscribe({\n      next: ev => {\n        assert.strictEqual(ev, 405);\n        done();\n      },\n      error: done,\n      complete: () => {},\n    });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return an empty Observable if query does not match",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 92,
                "column": 63
            },
            "line": 92,
            "code": "  it('should return an empty Observable if query does not match', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n      },\n    });\n    userEvents\n      .select('.impossible')\n      .events('scroll')\n      .subscribe({\n        next: done,\n        error: done,\n        complete: done,\n      });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return empty Observable for select().elements and none is defined",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 108,
                "column": 78
            },
            "line": 108,
            "code": "  it('should return empty Observable for select().elements and none is defined', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n      },\n    });\n    userEvents\n      .select('.foo')\n      .elements()\n      .subscribe({\n        next: done,\n        error: done,\n        complete: done,\n      });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return defined Observable for select().elements",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 124,
                "column": 60
            },
            "line": 124,
            "code": "  it('should return defined Observable for select().elements', function(done) {\n    const mockedDOMSource = mockDOMSource({\n      '.foo': {\n        elements: of(135),\n      },\n    });\n    mockedDOMSource\n      .select('.foo')\n      .elements()\n      .subscribe({\n        next: (e: any) => {\n          assert.strictEqual(e, 135);\n          done();\n        },\n        error: done,\n        complete: () => {},\n      });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in elements() source stream",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 143,
                "column": 59
            },
            "line": 143,
            "code": "  it('should have DevTools flag in elements() source stream', function(done) {\n    const mockedDOMSource = mockDOMSource({\n      '.foo': {\n        elements: of(135),\n      },\n    });\n    assert.strictEqual(\n      mockedDOMSource.select('.foo').elements()._isCycleSource,\n      'MockedDOM'\n    );\n    done();\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have DevTools flag in events() source stream",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 156,
                "column": 57
            },
            "line": 156,
            "code": "  it('should have DevTools flag in events() source stream', function(done) {\n    const userEvents = mockDOMSource({\n      '.foo': {\n        click: of(135),\n      },\n    });\n    assert.strictEqual(\n      userEvents.select('.foo').events('click')._isCycleSource,\n      'MockedDOM'\n    );\n    done();\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should return defined Observable when chaining .select()",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 169,
                "column": 62
            },
            "line": 169,
            "code": "  it('should return defined Observable when chaining .select()', function(done) {\n    const mockedDOMSource = mockDOMSource({\n      '.bar': {\n        '.foo': {\n          '.baz': {\n            elements: of(135),\n          },\n        },\n      },\n    });\n    mockedDOMSource\n      .select('.bar')\n      .select('.foo')\n      .select('.baz')\n      .elements()\n      .subscribe({\n        next: (e: any) => {\n          assert.strictEqual(e, 135);\n          done();\n        },\n        error: done,\n        complete: () => {},\n      });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "multiple .select()s should not throw when given empty mockedSelectors",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 194,
                "column": 75
            },
            "line": 194,
            "code": "  it('multiple .select()s should not throw when given empty mockedSelectors', () => {\n    assert.doesNotThrow(() => {\n      const DOM = mockDOMSource({});\n      DOM.select('.something')\n        .select('.other')\n        .events('click');\n    });\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "multiple .select()s should return some observable if not defined",
            "suites": [
                "mockDOMSource"
            ],
            "updatePoint": {
                "line": 203,
                "column": 70
            },
            "line": 203,
            "code": "  it('multiple .select()s should return some observable if not defined', () => {\n    const DOM = mockDOMSource({});\n    const domSource = DOM.select('.something').select('.other');\n    assert.strictEqual(\n      typeof domSource.events('click').pipe,\n      'function',\n      'domSource.events(click) should be an Observable instance'\n    );\n    assert.strictEqual(\n      typeof domSource.elements().pipe,\n      'function',\n      'domSource.elements() should be an Observable instance'\n    );\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have the same effect as DOM.select()",
            "suites": [
                "isolation on MockedDOMSource"
            ],
            "updatePoint": {
                "line": 220,
                "column": 49
            },
            "line": 220,
            "code": "  it('should have the same effect as DOM.select()', function(done) {\n    function app(_sources: {DOM: MockedDOMSource}) {\n      return {\n        DOM: of(\n          h3('.top-most', [\n            h2('.bar', 'Wrong'),\n            div('.child.___foo', [h4('.bar', 'Correct')]),\n          ])\n        ),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: () =>\n        mockDOMSource({\n          '.___foo': {\n            '.bar': {\n              elements: of<any>('skipped', 135),\n            },\n          },\n        }),\n    });\n\n    let dispose: any;\n    const isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');\n\n    // Make assertions\n    isolatedDOMSource\n      .select('.bar')\n      .elements()\n      .pipe(\n        skip(1),\n        take(1)\n      )\n      .subscribe((elements: number) => {\n        assert.strictEqual(elements, 135);\n        setTimeout(() => {\n          dispose();\n          done();\n        });\n      });\n    dispose = run();\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should have isolateSource and isolateSink",
            "suites": [
                "isolation on MockedDOMSource"
            ],
            "updatePoint": {
                "line": 264,
                "column": 47
            },
            "line": 264,
            "code": "  it('should have isolateSource and isolateSink', function(done) {\n    function app(_sources: {DOM: MockedDOMSource}) {\n      return {\n        DOM: of(h('h3.top-most.___foo')),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: (_: Stream<VNode>) => mockDOMSource({}),\n    });\n    const dispose = run();\n    const isolatedDOMSource = sources.DOM.isolateSource(sources.DOM, 'foo');\n    // Make assertions\n    assert.strictEqual(typeof isolatedDOMSource.isolateSource, 'function');\n    assert.strictEqual(typeof isolatedDOMSource.isolateSink, 'function');\n    dispose();\n    done();\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should prevent parent from DOM.selecting() inside the isolation",
            "suites": [
                "isolation on MockedDOMSource"
            ],
            "updatePoint": {
                "line": 283,
                "column": 69
            },
            "line": 283,
            "code": "  it('should prevent parent from DOM.selecting() inside the isolation', function(done) {\n    function app(_sources: {DOM: MockedDOMSource}) {\n      const child$ = _sources.DOM.isolateSink(\n        of(div('.foo', [h4('.bar', 'Wrong')])),\n        'ISOLATION'\n      );\n      return {\n        DOM: map((child: any) =>\n          h3('.top-most', [child, h2('.bar', 'Correct')])\n        )(child$),\n      };\n    }\n\n    const {sinks, sources, run} = setup(app, {\n      DOM: (_: Stream<VNode>) =>\n        mockDOMSource({\n          '.___ISOLATION': {\n            '.bar': {\n              elements: of('skipped', 'Wrong'),\n            },\n          },\n          '.bar': {\n            elements: of('skipped', 'Correct'),\n          },\n        }),\n    });\n\n    sources.DOM.select('.bar')\n      .elements()\n      .pipe(\n        skip(1),\n        take(1)\n      )\n      .subscribe(function(x: any) {\n        assert.strictEqual(x, 'Correct');\n        done();\n      });\n    run();\n  });",
            "file": "node/mock-dom-source.ts",
            "skipped": false,
            "dir": "dom/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "makeHistoryDriver"
            ],
            "updatePoint": {
                "line": 9,
                "column": 26
            },
            "line": 9,
            "code": "  it('should be a function', () => {\n    assert.strictEqual(typeof makeHistoryDriver, 'function');\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return a function",
            "suites": [
                "makeHistoryDriver"
            ],
            "updatePoint": {
                "line": 12,
                "column": 30
            },
            "line": 12,
            "code": "  it('should return a function', () => {\n    assert.strictEqual(typeof makeHistoryDriver(), 'function');\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return allow injecting History object directly",
            "suites": [
                "makeHistoryDriver"
            ],
            "updatePoint": {
                "line": 15,
                "column": 59
            },
            "line": 15,
            "code": "  it('should return allow injecting History object directly', () => {\n    const history = createMemoryHistory();\n    assert.strictEqual(typeof makeHistoryDriver(history), 'function');\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should start emitting the current location",
            "suites": [
                "makeHistoryDriver"
            ],
            "updatePoint": {
                "line": 19,
                "column": 48
            },
            "line": 19,
            "code": "  it('should start emitting the current location', function (done) {\n    const history$ = makeHistoryDriver()(xs.never());\n    const sub = history$.subscribe({\n      next: location => {\n        assert(location.pathname);\n        done();\n      },\n      error: err => {},\n      complete: () => {}\n    });\n    setTimeout(() => {\n      sub.unsubscribe();\n    });\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "makeHashHistoryDriver"
            ],
            "updatePoint": {
                "line": 35,
                "column": 26
            },
            "line": 35,
            "code": "  it('should be a function', () => {\n    assert.strictEqual(typeof makeHashHistoryDriver, 'function');\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return a function",
            "suites": [
                "makeHashHistoryDriver"
            ],
            "updatePoint": {
                "line": 38,
                "column": 30
            },
            "line": 38,
            "code": "  it('should return a function', () => {\n    assert.strictEqual(typeof makeHashHistoryDriver(), 'function');\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should start emitting the current location",
            "suites": [
                "makeHashHistoryDriver"
            ],
            "updatePoint": {
                "line": 41,
                "column": 48
            },
            "line": 41,
            "code": "  it('should start emitting the current location', function (done) {\n    const history$ = makeHashHistoryDriver()(xs.never());\n    const sub = history$.subscribe({\n      next: location => {\n        assert(location.pathname);\n        done();\n      },\n      error: err => {},\n      complete: () => {}\n    });\n    setTimeout(() => {\n      sub.unsubscribe();\n    });\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow listening to link clicks and change route",
            "suites": [
                "captureClicks"
            ],
            "updatePoint": {
                "line": 57,
                "column": 60
            },
            "line": 57,
            "code": "  it('should allow listening to link clicks and change route', function (done) {\n    setAdapt(x => x);\n    const historyDriver = makeHistoryDriver();\n    const sink = xs.never();\n    const history$ = captureClicks(historyDriver)(sink);\n    const sub = history$.compose(debounce(5)).drop(1).subscribe({\n      next: location => {\n        assert.strictEqual(location.pathname, '/test');\n        sub.unsubscribe();\n        sink.shamefullySendComplete();\n        done();\n      },\n      error: err => {},\n      complete: () => {}\n    });\n    const a = document.createElement('a');\n    a.href = '/test';\n    document.body.appendChild(a);\n    setTimeout(() => {\n      a.click();\n    }, 10);\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should remove click listener when disposed of",
            "suites": [
                "captureClicks"
            ],
            "updatePoint": {
                "line": 79,
                "column": 51
            },
            "line": 79,
            "code": "  it('should remove click listener when disposed of', function (done) {\n    function main(sources) {\n      return {\n        history: xs.never()\n      };\n    }\n\n    const {\n      sources: sources1,\n      run: run1\n    } = setup(main, {\n      history: captureClicks(makeHistoryDriver())\n    });\n    const sub1 = sources1.history.drop(1).subscribe({\n      next: () => done(new Error('should not trigger')),\n      error: err => {},\n      complete: () => {}\n    });\n    const dispose1 = run1();\n    dispose1();\n    const {\n      sources: sources2,\n      run: run2\n    } = setup(main, {\n      history: captureClicks(makeHistoryDriver())\n    });\n\n    let dispose2 = () => {};\n\n    const sub2 = sources2.history.drop(1).subscribe({\n      next: location => {\n        assert.strictEqual(location.pathname, '/dispose');\n        sub1.unsubscribe();\n        sub2.unsubscribe();\n        dispose2();\n        done();\n      },\n      error: done,\n      complete: () => {}\n    });\n    dispose2 = run2();\n    const a = document.createElement('a');\n    a.href = '/dispose';\n    document.body.appendChild(a);\n    setTimeout(() => {\n      a.click();\n    });\n  });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return a stream",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 20,
                "column": 28
            },
            "line": 20,
            "code": "  it('should return a stream', () => {\n    function main(_sources) {\n      assert.strictEqual(typeof _sources.history.remember, 'function');\n      return {\n        history: xs.never()\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    assert.strictEqual(typeof sources.history.remember, 'function');\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from pathname",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 36,
                "column": 44
            },
            "line": 36,
            "code": "  it('should create a location from pathname', function (done) {\n    function main(_sources) {\n      return {\n        history: xs.of('/test')\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    dispose = run();\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from PushHistoryInput",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 62,
                "column": 52
            },
            "line": 62,
            "code": "  it('should create a location from PushHistoryInput', function (done) {\n    function main(_sources) {\n      return {\n        history: xs.of < PushHistoryInput > {\n          type: 'push',\n          pathname: '/test'\n        }\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    dispose = run();\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow changing search with PushHistoryInput",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 91,
                "column": 56
            },
            "line": 91,
            "code": "  it('should allow changing search with PushHistoryInput', function (done) {\n    function main(_sources) {\n      return {\n        history: xs.of < PushHistoryInput > {\n          type: 'push',\n          search: '?a=b'\n        }\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.search, '?a=b');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    dispose = run();\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from ReplaceHistoryInput",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 120,
                "column": 55
            },
            "line": 120,
            "code": "  it('should create a location from ReplaceHistoryInput', function (done) {\n    function main(_sources) {\n      return {\n        history: xs.of < ReplaceHistoryInput > {\n          type: 'replace',\n          pathname: '/test'\n        }\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    dispose = run();\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow going back/forwards with `go`, `goBack`, `goForward`",
            "suites": [
                "historyDriver - xstream"
            ],
            "updatePoint": {
                "line": 149,
                "column": 71
            },
            "line": 149,
            "code": "  it('should allow going back/forwards with `go`, `goBack`, `goForward`', function (done) {\n    function main(_sources) {\n      return {\n        history: xs.periodic(100).take(6).map(i => ['/test', '/other', {\n          type: 'go',\n          amount: -1\n        }, {\n          type: 'go',\n          amount: +1\n        }, {\n          type: 'goBack'\n        }, {\n          type: 'goForward'\n        }][i])\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeHistoryDriver()\n    });\n    const expected = ['/test', '/other', '/test', '/other', '/test', '/other'];\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, expected.shift());\n\n        if (expected.length === 0) {\n          done();\n        }\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    dispose = run();\n  });",
            "file": "browser/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "makeServerHistoryDriver"
            ],
            "updatePoint": {
                "line": 6,
                "column": 26
            },
            "line": 6,
            "code": "  it('should be a function', () => {\n    assert.strictEqual(typeof makeServerHistoryDriver, 'function');\n  });",
            "file": "node/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return a function",
            "suites": [
                "makeServerHistoryDriver"
            ],
            "updatePoint": {
                "line": 9,
                "column": 30
            },
            "line": 9,
            "code": "  it('should return a function', () => {\n    assert.strictEqual(typeof makeServerHistoryDriver(), 'function');\n  });",
            "file": "node/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return allow injecting MemoryHistory object directly",
            "suites": [
                "makeServerHistoryDriver"
            ],
            "updatePoint": {
                "line": 12,
                "column": 65
            },
            "line": 12,
            "code": "  it('should return allow injecting MemoryHistory object directly', () => {\n    const history = createMemoryHistory();\n    assert.strictEqual(typeof makeHistoryDriver(history), 'function');\n  });",
            "file": "node/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should start emitting the current location",
            "suites": [
                "makeServerHistoryDriver"
            ],
            "updatePoint": {
                "line": 16,
                "column": 48
            },
            "line": 16,
            "code": "  it('should start emitting the current location', function (done) {\n    const history$ = makeServerHistoryDriver()(xs.never());\n    const sub = history$.subscribe({\n      next: location => {\n        assert(location.pathname);\n        done();\n      },\n      error: err => {},\n      complete: () => {}\n    });\n    setTimeout(() => {\n      sub.unsubscribe();\n    });\n  });",
            "file": "node/common.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should return a stream",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 10,
                "column": 28
            },
            "line": 10,
            "code": "  it('should return a stream', function () {\n    function main(_sources) {\n      assert.strictEqual(typeof _sources.history.remember, 'function');\n      return {\n        history: xs.never()\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    assert.strictEqual(typeof sources.history.remember, 'function');\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from pathname",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 26,
                "column": 44
            },
            "line": 26,
            "code": "  it('should create a location from pathname', done => {\n    function main(_sources) {\n      return {\n        history: xs.of('/test')\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from PushHistoryInput",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 52,
                "column": 52
            },
            "line": 52,
            "code": "  it('should create a location from PushHistoryInput', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < PushHistoryInput > {\n          type: 'push',\n          pathname: '/test'\n        }\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should create a location from ReplaceHistoryInput",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 81,
                "column": 55
            },
            "line": 81,
            "code": "  it('should create a location from ReplaceHistoryInput', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < ReplaceHistoryInput > {\n          type: 'replace',\n          pathname: '/test'\n        }\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, '/test');\n        done();\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow going back a route with type `go`",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 110,
                "column": 52
            },
            "line": 110,
            "code": "  it('should allow going back a route with type `go`', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < HistoryInput | string > ('/test', '/other', {\n          type: 'go',\n          amount: -1\n        })\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    const expected = ['/test', '/other', '/test'];\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, expected.shift());\n\n        if (expected.length === 0) {\n          done();\n        }\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow going back a route with type `goBack`",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 143,
                "column": 56
            },
            "line": 143,
            "code": "  it('should allow going back a route with type `goBack`', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < HistoryInput | string > ('/test', '/other', {\n          type: 'goBack'\n        })\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    const expected = ['/test', '/other', '/test'];\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, expected.shift());\n\n        if (expected.length === 0) {\n          done();\n        }\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow going forward a route with type `go`",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 175,
                "column": 55
            },
            "line": 175,
            "code": "  it('should allow going forward a route with type `go`', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < HistoryInput | string > ('/test', '/other', {\n          type: 'go',\n          amount: -1\n        }, {\n          type: 'go',\n          amount: 1\n        })\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    const expected = ['/test', '/other', '/test', '/other'];\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, expected.shift());\n\n        if (expected.length === 0) {\n          done();\n        }\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should allow going forward a route with type `goForward`",
            "suites": [
                "serverHistoryDriver - xstream"
            ],
            "updatePoint": {
                "line": 211,
                "column": 62
            },
            "line": 211,
            "code": "  it('should allow going forward a route with type `goForward`', done => {\n    function main(_sources) {\n      return {\n        history: xs.of < HistoryInput | string > ('/test', '/other', {\n          type: 'go',\n          amount: -1\n        }, {\n          type: 'goForward'\n        })\n      };\n    }\n\n    const {\n      sources,\n      run\n    } = setup(main, {\n      history: makeServerHistoryDriver()\n    });\n    const expected = ['/test', '/other', '/test', '/other'];\n    sources.history.drop(1).subscribe({\n      next(location) {\n        assert.strictEqual(location.pathname, expected.shift());\n\n        if (expected.length === 0) {\n          done();\n        }\n      },\n\n      error: done,\n      complete: () => {\n        done('complete should not be called');\n      }\n    });\n    run();\n  });",
            "file": "node/xstream.ts",
            "skipped": false,
            "dir": "history/test"
        },
        {
            "name": "should output HTML when given a simple vtree stream",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 9,
                "column": 57
            },
            "line": 9,
            "code": "  it('should output HTML when given a simple vtree stream', function(done) {\n    function app() {\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n\n    function effect(html: string): void {\n      assert.strictEqual(html, '<div class=\"test-element\">Foobar</div>');\n      done();\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should allow effect to see one or many HTML outputs",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 26,
                "column": 57
            },
            "line": 26,
            "code": "  it('should allow effect to see one or many HTML outputs', function(done) {\n    function app() {\n      return {\n        html: xs\n          .periodic(150)\n          .take(3)\n          .map(i => div('.test-element', ['Foobar' + i])),\n      };\n    }\n\n    const expected = [\n      '<div class=\"test-element\">Foobar0</div>',\n      '<div class=\"test-element\">Foobar1</div>',\n      '<div class=\"test-element\">Foobar2</div>',\n    ];\n\n    function effect(html: string): void {\n      assert.strictEqual(html, expected.shift());\n      if (expected.length === 0) {\n        done();\n      }\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should allow effect to see one (the last) HTML outputs",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 54,
                "column": 60
            },
            "line": 54,
            "code": "  it('should allow effect to see one (the last) HTML outputs', function(done) {\n    function app() {\n      return {\n        html: xs\n          .periodic(150)\n          .take(3)\n          .map(i => div('.test-element', ['Foobar' + i]))\n          .last(),\n      };\n    }\n\n    function effect(html: string): void {\n      assert.strictEqual(html, '<div class=\"test-element\">Foobar2</div>');\n      done();\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should output HTMLSource as an adapted stream",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 75,
                "column": 51
            },
            "line": 75,
            "code": "  it('should output HTMLSource as an adapted stream', function(done) {\n    type MySources = {\n      html: HTMLSource;\n    };\n    type MySinks = {\n      html: Stream<VNode>;\n    };\n\n    function app(_sources: MySources): MySinks {\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n    const {sources} = setup(app, {\n      html: makeHTMLDriver((html: string) => {}),\n    });\n    assert.strictEqual(\n      typeof (sources.html.elements() as any).imitate,\n      'function'\n    );\n    done();\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should have DevTools flag in HTMLSource elements() stream",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 98,
                "column": 63
            },
            "line": 98,
            "code": "  it('should have DevTools flag in HTMLSource elements() stream', function(done) {\n    function app(_sources: {html: HTMLSource}): any {\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n    const {sources} = setup(app, {\n      html: makeHTMLDriver((html: string) => {}),\n    });\n    assert.strictEqual((sources.html.elements() as any)._isCycleSource, 'html');\n    done();\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should have DevTools flag in HTMLSource elements() stream",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 111,
                "column": 63
            },
            "line": 111,
            "code": "  it('should have DevTools flag in HTMLSource elements() stream', function(done) {\n    function app(_sources: {html: HTMLSource}): any {\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n    const {sources} = setup(app, {\n      html: makeHTMLDriver((html: string) => {}),\n    });\n    assert.strictEqual(\n      (sources.html.events('click') as any)._isCycleSource,\n      'html'\n    );\n    done();\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should make bogus select().events() as sources",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 127,
                "column": 52
            },
            "line": 127,
            "code": "  it('should make bogus select().events() as sources', function(done) {\n    function app(sources: {html: HTMLSource}) {\n      assert.strictEqual(typeof sources.html.select, 'function');\n      assert.strictEqual(\n        typeof sources.html.select('whatever').elements().imitate,\n        'function'\n      );\n      assert.strictEqual(\n        typeof sources.html.select('whatever').events('click').imitate,\n        'function'\n      );\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n\n    function effect(html: string): void {\n      assert.strictEqual(html, '<div class=\"test-element\">Foobar</div>');\n      done();\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should output simple HTML Observable",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 153,
                "column": 42
            },
            "line": 153,
            "code": "  it('should output simple HTML Observable', function(done) {\n    function app() {\n      return {\n        html: xs.of(div('.test-element', ['Foobar'])),\n      };\n    }\n\n    function effect(html: string): void {\n      assert.strictEqual(html, '<div class=\"test-element\">Foobar</div>');\n      done();\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should support passing custom modules",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 170,
                "column": 43
            },
            "line": 170,
            "code": "  it('should support passing custom modules', function(done) {\n    function main() {\n      return {\n        html: xs.of(div(['Hello'])),\n      };\n    }\n\n    function effect(html: string): void {\n      try {\n        assert.strictEqual(html, '<div custom=\"stuff\">Hello</div>');\n      } catch (err) {\n        done(err);\n        return;\n      }\n      done();\n    }\n\n    const {sinks, sources, run: _run} = setup(main, {\n      html: makeHTMLDriver(effect, {\n        modules: [\n          (vnode: VNode, attributes: Map<string, any>) => {\n            attributes.set('custom', 'stuff');\n          },\n        ],\n      }),\n    });\n    _run();\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should render a complex and nested HTML",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 199,
                "column": 45
            },
            "line": 199,
            "code": "  it('should render a complex and nested HTML', function(done) {\n    function app() {\n      return {\n        html: xs.of(\n          h('.test-element', [\n            div([h2('.a', 'a'), h('h4.b', 'b'), h('h1.fooclass')]),\n            div([h3('.c', 'c'), h('div', [h('p.d', 'd'), h('h2.barclass')])]),\n          ])\n        ),\n      };\n    }\n\n    function effect(html: string): void {\n      assert.strictEqual(\n        html,\n        '<div class=\"test-element\">' +\n          '<div>' +\n          '<h2 class=\"a\">a</h2>' +\n          '<h4 class=\"b\">b</h4>' +\n          '<h1 class=\"fooclass\"></h1>' +\n          '</div>' +\n          '<div>' +\n          '<h3 class=\"c\">c</h3>' +\n          '<div>' +\n          '<p class=\"d\">d</p>' +\n          '<h2 class=\"barclass\"></h2>' +\n          '</div>' +\n          '</div>' +\n          '</div>'\n      );\n      done();\n    }\n\n    run(app, {\n      html: makeHTMLDriver(effect),\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should report errors thrown in snabbdom-to-html",
            "suites": [
                "HTML Driver"
            ],
            "updatePoint": {
                "line": 237,
                "column": 53
            },
            "line": 237,
            "code": "  it('should report errors thrown in snabbdom-to-html', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function app() {\n      return {\n        html: xs.of('invalid snabbdom' as any),\n      };\n    }\n\n    run(app, {\n      html: makeHTMLDriver(() => {}),\n    });\n\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sandbox.restore();\n      done();\n    }, 10);\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "html/test"
        },
        {
            "name": "should be a driver factory",
            "suites": [
                "makeHTTPDriver"
            ],
            "updatePoint": {
                "line": 18,
                "column": 34
            },
            "line": 18,
            "code": "    it('should be a driver factory', function() {\n      assert.strictEqual(typeof makeHTTPDriver, 'function');\n      const output = makeHTTPDriver();\n      assert.strictEqual(typeof output, 'function');\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should throw when request stream emits neither string nor object",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 28,
                "column": 72
            },
            "line": 28,
            "code": "    it('should throw when request stream emits neither string nor object', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of(123 as any),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      sources.HTTP.select()\n        .pipe(mergeAll())\n        .subscribe({\n          next: () => {\n            done('next should not be called');\n          },\n          error: (err: any) => {\n            assert.strictEqual(\n              err.message,\n              'Observable of requests given to ' +\n                'HTTP Driver must emit either URL strings or objects with ' +\n                'parameters.'\n            );\n            done();\n          },\n          complete: () => {\n            done('complete should not be called');\n          },\n        });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should throw when given options object without url string",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 59,
                "column": 65
            },
            "line": 59,
            "code": "    it('should throw when given options object without url string', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({method: 'post'} as any),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      sources.HTTP.select()\n        .pipe(mergeAll())\n        .subscribe({\n          next: () => {\n            done('next should not be called');\n          },\n          error: (err: any) => {\n            assert.strictEqual(\n              err.message,\n              'Please provide a `url` property in the request ' + 'options.'\n            );\n            done();\n          },\n          complete: () => {\n            done('complete should not be called');\n          },\n        });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return response metastream when given a simple URL string",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 88,
                "column": 72
            },
            "line": 88,
            "code": "    it('should return response metastream when given a simple URL string', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of(uri + '/hello'),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n      const response$$ = sources.HTTP.select();\n      assert.strictEqual(typeof response$$.pipe, 'function'); // is RxJS v5\n\n      response$$.subscribe({\n        next: response$ => {\n          assert.strictEqual(typeof response$.request, 'object');\n          assert.strictEqual(response$.request.url, uri + '/hello');\n          assert.strictEqual(typeof response$.pipe, 'function'); // is RxJS v5\n          response$.subscribe(function(response: any) {\n            assert.strictEqual(response.status, 200);\n            assert.strictEqual(response.text, 'Hello World');\n            done();\n          });\n        },\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return HTTPSource with isolateSource and isolateSink",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 114,
                "column": 67
            },
            "line": 114,
            "code": "    it('should return HTTPSource with isolateSource and isolateSink', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of(uri + '/hello'),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n      const httpSource = sources.HTTP;\n\n      run();\n      assert.strictEqual(typeof sources.HTTP.isolateSource, 'function');\n      assert.strictEqual(typeof sources.HTTP.isolateSink, 'function');\n      done();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return response metastream when given simple options obj",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 130,
                "column": 71
            },
            "line": 130,
            "code": "    it('should return response metastream when given simple options obj', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/pet',\n            method: 'POST',\n            send: {name: 'Woof', species: 'Dog'},\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const response$$ = sources.HTTP.select();\n      response$$.subscribe(function(response$) {\n        assert.strictEqual(response$.request.url, uri + '/pet');\n        assert.strictEqual(response$.request.method, 'POST');\n        assert.strictEqual((response$.request.send as any).name, 'Woof');\n        assert.strictEqual((response$.request.send as any).species, 'Dog');\n        response$.subscribe(function(response: any) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.text, 'added Woof the Dog');\n          done();\n        });\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return response metastream when send with type string [#674]",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 158,
                "column": 75
            },
            "line": 158,
            "code": "    it('should return response metastream when send with type string [#674]', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/pet',\n            method: 'POST',\n            send: 'name=Woof&species=Dog',\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const response$$ = sources.HTTP.select();\n      response$$.subscribe(function(response$) {\n        assert.strictEqual(response$.request.url, uri + '/pet');\n        assert.strictEqual(response$.request.method, 'POST');\n        assert.strictEqual(\n          response$.request.send as string,\n          'name=Woof&species=Dog'\n        );\n        response$.subscribe(function(response: any) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.text, 'added Woof the Dog');\n          done();\n        });\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should have DevTools flag in select() source stream",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 188,
                "column": 59
            },
            "line": 188,
            "code": "    it('should have DevTools flag in select() source stream', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/pet',\n            method: 'POST',\n            send: {name: 'Woof', species: 'Dog'},\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const response$$ = sources.HTTP.select();\n      assert.strictEqual((response$$ as any)._isCycleSource, 'HTTP');\n      done();\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should have DevTools flag in response$$ source stream",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 207,
                "column": 61
            },
            "line": 207,
            "code": "    it('should have DevTools flag in response$$ source stream', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/pet',\n            method: 'POST',\n            send: {name: 'Woof', species: 'Dog'},\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const response$$ = sources.HTTP.select();\n      assert.strictEqual((response$$ as any)._isCycleSource, 'HTTP');\n      done();\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return response metastream when given another options obj",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 226,
                "column": 72
            },
            "line": 226,
            "code": "    it('should return response metastream when given another options obj', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/querystring',\n            method: 'GET',\n            query: {foo: 102030, bar: 'Pub'},\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const response$$ = sources.HTTP.select();\n      response$$.subscribe(function(response$) {\n        assert.strictEqual(response$.request.url, uri + '/querystring');\n        assert.strictEqual(response$.request.method, 'GET');\n        assert.strictEqual((response$.request.query as any).foo, 102030);\n        assert.strictEqual((response$.request.query as any).bar, 'Pub');\n        response$.subscribe(function(response: any) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.body.foo, '102030');\n          assert.strictEqual(response.body.bar, 'Pub');\n          done();\n        });\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return response metastream when given yet another options obj",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 255,
                "column": 76
            },
            "line": 255,
            "code": "    it('should return response metastream when given yet another options obj', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/delete',\n            method: 'DELETE',\n            query: {foo: 102030, bar: 'Pub'},\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n      const response$$ = sources.HTTP.select();\n\n      response$$.subscribe(function(response$) {\n        assert.strictEqual(response$.request.url, uri + '/delete');\n        assert.strictEqual(response$.request.method, 'DELETE');\n        response$.subscribe(function(response: any) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.body.deleted, true);\n          done();\n        });\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not be possible to change the metastream's request",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 281,
                "column": 65
            },
            "line": 281,
            "code": "    it(\"should not be possible to change the metastream's request\", function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of({\n            url: uri + '/hello',\n            method: 'GET',\n          }),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      sources.HTTP.select()\n        .pipe(\n          map(response$ => {\n            response$.request = 1234 as any;\n            return response$;\n          })\n        )\n        .subscribe(\n          function next(response$) {\n            done('next should not be called');\n          },\n          err => {\n            assert.strictEqual(err instanceof TypeError, true);\n            done();\n          }\n        );\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should send 500 server errors to response$ onError",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 312,
                "column": 58
            },
            "line": 312,
            "code": "    it('should send 500 server errors to response$ onError', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: of(uri + '/error'),\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n      const response$$ = sources.HTTP.select();\n\n      response$$.subscribe(function(response$) {\n        assert.strictEqual(typeof response$.request, 'object');\n        assert.strictEqual(response$.request.url, uri + '/error');\n        response$.subscribe({\n          next: () => {\n            done('next should not be called');\n          },\n          error: (err: any) => {\n            assert.strictEqual(err.status, 500);\n            assert.strictEqual(err.message, 'Internal Server Error');\n            assert.strictEqual(err.response.text, 'boom');\n            done();\n          },\n          complete: () => {\n            done('complete should not be called');\n          },\n        });\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not be sensitive to ordering of sinks (issue #476)",
            "suites": [
                "HTTP Driver"
            ],
            "updatePoint": {
                "line": 343,
                "column": 65
            },
            "line": 343,
            "code": "    it('should not be sensitive to ordering of sinks (issue #476)', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        const request$ = of({\n          url: uri + '/hello',\n          method: 'GET',\n        });\n        const str$ = _sources.HTTP.select().pipe(\n          mergeAll(),\n          map((res: any) => res.text as string)\n        );\n\n        // Notice HTTP comes before Test here. This is crucial for this test.\n        return {\n          HTTP: request$,\n          Test: str$,\n        };\n      }\n      const testDriverExpected = ['Hello World'];\n\n      function testDriver(sink: Stream<string>) {\n        sink.subscribe({\n          next: x => {\n            assert.strictEqual(testDriverExpected.length, 1);\n            assert.strictEqual(x, testDriverExpected.shift());\n            assert.strictEqual(testDriverExpected.length, 0);\n            done();\n          },\n        });\n      }\n\n      const {sources, run} = setup(main, {\n        HTTP: makeHTTPDriver(),\n        Test: testDriver,\n      });\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should exist on the HTTPSource",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 382,
                "column": 38
            },
            "line": 382,
            "code": "    it('should exist on the HTTPSource', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: new Subject<RequestOptions>(),\n        };\n      }\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      assert.strictEqual(typeof sources.HTTP.isolateSource, 'function');\n      assert.strictEqual(typeof sources.HTTP.isolateSink, 'function');\n      done();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should exist on a scoped HTTPSource",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 395,
                "column": 43
            },
            "line": 395,
            "code": "    it('should exist on a scoped HTTPSource', function(done) {\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: new Subject<RequestOptions>(),\n        };\n      }\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, 'foo');\n\n      assert.strictEqual(typeof scopedHTTPSource.isolateSource, 'function');\n      assert.strictEqual(typeof scopedHTTPSource.isolateSink, 'function');\n      done();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should hide responses from outside the scope",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 410,
                "column": 52
            },
            "line": 410,
            "code": "    it('should hide responses from outside the scope', function(done) {\n      const proxyRequest$ = new Subject<RequestOptions>();\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: proxyRequest$,\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const ignoredRequest$ = of(uri + '/json');\n      const request$ = of(uri + '/hello').pipe(delay(10));\n      const scopedRequest$ = sources.HTTP.isolateSink(request$, 'foo');\n      const scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, 'foo');\n\n      scopedHTTPSource.select().subscribe(function(response$) {\n        assert.strictEqual(typeof response$.request, 'object');\n        assert.strictEqual(response$.request.url, uri + '/hello');\n        response$.subscribe(function(response: any) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.text, 'Hello World');\n          done();\n        });\n      });\n\n      merge(ignoredRequest$, scopedRequest$).subscribe(proxyRequest$ as any);\n\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should hide responses even if using the same scope multiple times",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 440,
                "column": 73
            },
            "line": 440,
            "code": "    it('should hide responses even if using the same scope multiple times', function(done) {\n      const proxyRequest$ = new Subject<RequestOptions>();\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: proxyRequest$,\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const ignoredRequest$ = of(uri + '/json');\n      const request$ = of(uri + '/hello').pipe(delay(10));\n      const fooInsideBarRequest$ = sources.HTTP.isolateSink(\n        sources.HTTP.isolateSink(request$, 'foo'),\n        'bar'\n      ).pipe(shareReplay());\n      const fooInsideBarHTTPSource = sources.HTTP.isolateSource(\n        sources.HTTP.isolateSource(sources.HTTP, 'bar'),\n        'foo'\n      );\n      const fooInsideFooHTTPSource = sources.HTTP.isolateSource(\n        sources.HTTP.isolateSource(sources.HTTP, 'foo'),\n        'foo'\n      );\n\n      fooInsideFooHTTPSource.select().subscribe(function(response$) {\n        assert(false);\n        done('should not be called');\n      });\n\n      fooInsideBarHTTPSource.select().subscribe(function(response$) {\n        assert.strictEqual(typeof response$.request, 'object');\n        assert.strictEqual(response$.request.url, uri + '/hello');\n        response$.subscribe(function(response) {\n          assert.strictEqual(response.status, 200);\n          assert.strictEqual(response.text, 'Hello World');\n          done();\n        });\n      });\n\n      merge(ignoredRequest$, fooInsideBarRequest$).subscribe(\n        proxyRequest$ as any\n      );\n\n      run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should emit responses when isolated many scopes deep",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 487,
                "column": 60
            },
            "line": 487,
            "code": "    it('should emit responses when isolated many scopes deep', function(done) {\n      let dispose: any;\n      function main(_sources: {HTTP: HTTPSource}) {\n        _sources.HTTP.select('hello').subscribe(function(response$) {\n          assert.strictEqual(typeof response$.request, 'object');\n          assert.strictEqual(response$.request.url, uri + '/hello');\n          response$.subscribe(function(response) {\n            assert.strictEqual(response.status, 200);\n            assert.strictEqual(response.text, 'Hello World');\n            dispose();\n            done();\n          });\n        });\n\n        return {\n          HTTP: of({\n            url: uri + '/hello',\n            category: 'hello',\n          }).pipe(delay(10)),\n        };\n      }\n\n      function wrapper1(_sources: {HTTP: HTTPSource}) {\n        return isolate(main, {HTTP: 'wrapper1'})(_sources);\n      }\n\n      function wrapper2(_sources: {HTTP: HTTPSource}) {\n        return isolate(wrapper1, {HTTP: 'wrapper2'})(_sources);\n      }\n\n      const {sources, run} = setup(wrapper2, {HTTP: makeHTTPDriver()});\n\n      dispose = run();\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should allow null scope to bypass isolation",
            "suites": [
                "isolateSource and isolateSink"
            ],
            "updatePoint": {
                "line": 522,
                "column": 51
            },
            "line": 522,
            "code": "    it('should allow null scope to bypass isolation', function(done) {\n      const proxyRequest$ = new Subject<any>();\n      function main(_sources: {HTTP: HTTPSource}) {\n        return {\n          HTTP: proxyRequest$,\n        };\n      }\n\n      const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n      const ignoredRequest$ = of(uri + '/json');\n      const request$ = of(uri + '/hello').pipe(delay(100));\n      const scopedRequest$ = sources.HTTP.isolateSink(proxyRequest$, null);\n      const scopedHTTPSource = sources.HTTP.isolateSource(sources.HTTP, null);\n\n      const expected = [uri + '/json', uri + '/hello'];\n\n      scopedHTTPSource.select().subscribe(function(response$: any) {\n        assert.strictEqual(typeof response$.request, 'object');\n        assert.strictEqual(response$.request.url, expected.shift());\n        if (expected.length === 0) {\n          done();\n        }\n      });\n\n      run();\n\n      merge(ignoredRequest$, request$).subscribe(proxyRequest$);\n    });",
            "file": "browser/common.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should be able to emit progress events on the response stream",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 24,
                "column": 67
            },
            "line": 24,
            "code": "  it('should be able to emit progress events on the response stream', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/querystring',\n          method: 'GET',\n          progress: true,\n          query: {foo: 102030, bar: 'Pub'},\n        }),\n      };\n    }\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n    const response$$ = sources.HTTP.select();\n\n    response$$.subscribe({\n      next: function(response$) {\n        assert.strictEqual(response$.request.url, uri + '/querystring');\n        assert.strictEqual(response$.request.method, 'GET');\n        assert.strictEqual((response$.request.query as any).foo, 102030);\n        assert.strictEqual((response$.request.query as any).bar, 'Pub');\n        let progressEventHappened = false;\n        response$.subscribe(function(response) {\n          if (response.type === 'progress') {\n            assert.strictEqual(typeof response.total, 'number');\n            progressEventHappened = true;\n          } else {\n            assert.strictEqual(progressEventHappened, true);\n            assert.strictEqual(response.status, 200);\n            assert.strictEqual(response.body.foo, '102030');\n            assert.strictEqual(response.body.bar, 'Pub');\n            done();\n          }\n        });\n      },\n    });\n\n    run();\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return binary response when responseType option is arraybuffer",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 63,
                "column": 75
            },
            "line": 63,
            "code": "  it('should return binary response when responseType option is arraybuffer', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/binary',\n          method: 'GET',\n          responseType: 'arraybuffer',\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n    const response$$ = sources.HTTP.select();\n    response$$.subscribe(function(response$) {\n      assert.strictEqual(response$.request.url, uri + '/binary');\n      assert.strictEqual(response$.request.method, 'GET');\n      assert.strictEqual(response$.request.responseType, 'arraybuffer');\n      response$.subscribe(function(response) {\n        assert.strictEqual(response.status, 200);\n        assert.deepStrictEqual(\n          new Uint8Array(response.body),\n          new Uint8Array([1, 2, 3])\n        );\n        done();\n      });\n    });\n    run();\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should return binary response when responseType option is blob",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 93,
                "column": 68
            },
            "line": 93,
            "code": "  it('should return binary response when responseType option is blob', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/binary',\n          method: 'GET',\n          responseType: 'blob',\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n    const response$$ = sources.HTTP.select();\n    response$$.subscribe(function(response$) {\n      assert.strictEqual(response$.request.url, uri + '/binary');\n      assert.strictEqual(response$.request.method, 'GET');\n      assert.strictEqual(response$.request.responseType, 'blob');\n      response$.subscribe(function(response) {\n        assert.strictEqual(response.status, 200);\n        const fr = new FileReader();\n        fr.onload = ev => {\n          assert.deepStrictEqual(\n            new Uint8Array(fr.result as ArrayBuffer),\n            new Uint8Array([1, 2, 3])\n          );\n          done();\n        };\n        fr.onerror = ev => {\n          done('should not be called');\n        };\n        fr.readAsArrayBuffer(response.body);\n      });\n    });\n    run();\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not have cross-driver race conditions, A (#592)",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 130,
                "column": 60
            },
            "line": 130,
            "code": "  it('should not have cross-driver race conditions, A (#592)', function(done) {\n    this.timeout(10000);\n\n    function child(_sources: any, num: any) {\n      const vdom$ = _sources.HTTP.select('cat').pipe(\n        mergeAll(),\n        map((res: any) => 'My name is ' + res.text)\n      );\n\n      const request$ =\n        num === 1\n          ? of({\n              category: 'cat',\n              url: uri + '/hello',\n            })\n          : never();\n\n      return {\n        HTTP: request$,\n        DOM: vdom$,\n      };\n    }\n\n    function mainHTTPThenDOM(_sources: any) {\n      const sinks$ = interval(1000).pipe(\n        take(6),\n        map(i => {\n          if (i % 2 === 1) {\n            return child(_sources, i);\n          } else {\n            return {\n              HTTP: empty(),\n              DOM: of(''),\n            };\n          }\n        }),\n        publishReplay(1),\n        refCount()\n      );\n\n      // order of sinks is important\n      return {\n        HTTP: sinks$.pipe(switchMap(sinks => sinks.HTTP)),\n        DOM: sinks$.pipe(switchMap(sinks => sinks.DOM)),\n      };\n    }\n\n    const expectedDOMSinks = [\n      /* HTTP then DOM: */ '',\n      'My name is Hello World',\n      '',\n      '',\n    ];\n\n    function domDriver(sink: any) {\n      sink.addListener({\n        next: (s: any) => {\n          assert.strictEqual(s, expectedDOMSinks.shift());\n        },\n        error: (err: any) => {},\n      });\n    }\n\n    // HTTP then DOM:\n    globalRun(mainHTTPThenDOM, {\n      HTTP: makeHTTPDriver(),\n      DOM: domDriver,\n    });\n    setTimeout(() => {\n      assert.strictEqual(expectedDOMSinks.length, 0);\n      done();\n    }, 8500);\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not have cross-driver race conditions, B (#592)",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 204,
                "column": 60
            },
            "line": 204,
            "code": "  it('should not have cross-driver race conditions, B (#592)', function(done) {\n    this.timeout(10000);\n\n    function child(_sources: any, num: any) {\n      const vdom$ = _sources.HTTP.select('cat').pipe(\n        mergeAll(),\n        map((res: any) => 'My name is ' + res.text)\n      );\n\n      const request$ =\n        num === 1\n          ? of({\n              category: 'cat',\n              url: uri + '/hello',\n            })\n          : never();\n\n      return {\n        HTTP: request$,\n        DOM: vdom$,\n      };\n    }\n\n    function mainDOMThenHTTP(_sources: any) {\n      const sinks$ = interval(1000).pipe(\n        take(6),\n        map(i => {\n          if (i % 2 === 1) {\n            return child(_sources, i);\n          } else {\n            return {\n              HTTP: empty(),\n              DOM: of(''),\n            };\n          }\n        }),\n        publishReplay(1),\n        refCount()\n      );\n\n      // order of sinks is important\n      return {\n        DOM: sinks$.pipe(switchMap(sinks => sinks.DOM)),\n        HTTP: sinks$.pipe(switchMap(sinks => sinks.HTTP)),\n      };\n    }\n\n    const expectedDOMSinks = [\n      /* DOM then HTTP: */ '',\n      'My name is Hello World',\n      '',\n      '',\n    ];\n\n    function domDriver(sink: any) {\n      sink.addListener({\n        next: (s: any) => {\n          assert.strictEqual(s, expectedDOMSinks.shift());\n        },\n        error: (err: any) => {},\n      });\n    }\n\n    // HTTP then DOM:\n    globalRun(mainDOMThenHTTP, {\n      HTTP: makeHTTPDriver(),\n      DOM: domDriver,\n    });\n    setTimeout(() => {\n      assert.strictEqual(expectedDOMSinks.length, 0);\n      done();\n    }, 8500);\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not remember past responses when selecting",
            "suites": [
                "HTTP Driver in the browser"
            ],
            "updatePoint": {
                "line": 278,
                "column": 55
            },
            "line": 278,
            "code": "  it('should not remember past responses when selecting', function(done) {\n    this.timeout(4000);\n\n    function main(_sources: any) {\n      const test$ = of(null).pipe(\n        delay(1000),\n        mergeMap(() =>\n          _sources.HTTP.select('cat').pipe(\n            mergeAll(),\n            map((res: any) => 'I should not show this, ' + res.text)\n          )\n        )\n      );\n\n      const request$ = of({\n        category: 'cat',\n        url: uri + '/hello',\n      });\n\n      return {\n        HTTP: request$,\n        Test: test$,\n      };\n    }\n\n    function testDriver(sink: any) {\n      sink.addListener({\n        next: (s: any) => {\n          console.log(s);\n          done('No data should come through the Test sink');\n        },\n        error: (err: any) => {\n          done(err);\n        },\n      });\n    }\n\n    globalRun(main, {\n      HTTP: makeHTTPDriver(),\n      Test: testDriver,\n    });\n\n    setTimeout(() => {\n      done();\n    }, 2000);\n  });",
            "file": "browser/index.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should auto-execute HTTP request when without listening to response stream",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 18,
                "column": 80
            },
            "line": 18,
            "code": "  it('should auto-execute HTTP request when without listening to response stream', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/pet',\n          method: 'POST',\n          send: {name: 'Woof', species: 'Dog'},\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n    globalSandbox.petPOSTResponse = null;\n    run();\n\n    setTimeout(function() {\n      assert.notStrictEqual(globalSandbox.petPOSTResponse, null);\n      assert.strictEqual(globalSandbox.petPOSTResponse, 'added Woof the Dog');\n      globalSandbox.petPOSTResponse = null;\n      done();\n    }, 250);\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should not auto-execute lazy request without listening to response stream",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 41,
                "column": 79
            },
            "line": 41,
            "code": "  it('should not auto-execute lazy request without listening to response stream', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/pet',\n          method: 'POST',\n          send: {name: 'Woof', species: 'Dog'},\n          lazy: true,\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n    globalSandbox.petPOSTResponse = null;\n    run();\n\n    setTimeout(function() {\n      assert.strictEqual(globalSandbox.petPOSTResponse, null);\n      done();\n    }, 250);\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should execute lazy HTTP request when listening to response stream",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 63,
                "column": 72
            },
            "line": 63,
            "code": "  it('should execute lazy HTTP request when listening to response stream', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/pet',\n          method: 'POST',\n          send: {name: 'Woof', species: 'Dog'},\n          lazy: true,\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n    globalSandbox.petPOSTResponse = null;\n\n    sources.HTTP.select()\n      .pipe(mergeAll())\n      .subscribe();\n\n    run();\n\n    setTimeout(function() {\n      assert.notStrictEqual(globalSandbox.petPOSTResponse, null);\n      assert.strictEqual(globalSandbox.petPOSTResponse, 'added Woof the Dog');\n      globalSandbox.petPOSTResponse = null;\n      done();\n    }, 250);\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should add request options object to each response",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 92,
                "column": 56
            },
            "line": 92,
            "code": "  it('should add request options object to each response', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/pet',\n          method: 'POST',\n          send: {name: 'Woof', species: 'Dog'},\n          _id: 'petRequest',\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n    sources.HTTP.select()\n      .pipe(mergeAll())\n      .subscribe(function(r: any) {\n        assert.ok(r.request);\n        assert.strictEqual(r.request._id, 'petRequest');\n        done();\n      });\n\n    run();\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should handle errors when sending request to non-existent server",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 117,
                "column": 70
            },
            "line": 117,
            "code": "  it('should handle errors when sending request to non-existent server', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: 'http://localhost:9999', // no server here\n          category: 'noServerCat',\n          _id: 'petRequest',\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n    sources.HTTP.select()\n      .pipe(mergeAll())\n      .subscribe({\n        next: function(r: any) {\n          done('next() should not be called');\n        },\n        error: function(err: any) {\n          assert.strictEqual(err.code, 'ECONNREFUSED');\n          assert.strictEqual(err.port, 9999);\n          done();\n        },\n      });\n\n    run();\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should call next() when ok is specified for an error status",
            "suites": [
                "HTTP Driver in Node.js"
            ],
            "updatePoint": {
                "line": 146,
                "column": 65
            },
            "line": 146,
            "code": "  it('should call next() when ok is specified for an error status', function(done) {\n    function main(_sources: {HTTP: HTTPSource}) {\n      return {\n        HTTP: of({\n          url: uri + '/not-found-url',\n          method: 'GET',\n          ok: (res: any) => res.status === 404,\n        }),\n      };\n    }\n\n    const {sources, run} = setup(main, {HTTP: makeHTTPDriver()});\n\n    sources.HTTP.select()\n      .pipe(mergeAll())\n      .subscribe({\n        next: function(r: any) {\n          assert.ok(r.request);\n          assert.strictEqual(r.status, 404);\n          done();\n        },\n        error: function(err: any) {\n          done('error() should not be called');\n        },\n      });\n\n    run();\n  });",
            "file": "node.ts",
            "skipped": false,
            "dir": "http/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 16,
                "column": 26
            },
            "line": 16,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof isolate, 'function');\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 20,
                "column": 54
            },
            "line": 20,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      isolate('not a function' as any);\n    }, /First argument given to isolate\\(\\) must be a 'dataflowComponent' function/i);\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should throw if second argument is null",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 26,
                "column": 45
            },
            "line": 26,
            "code": "  it('should throw if second argument is null', function() {\n    function MyDataflowComponent() {}\n    assert.throws(() => {\n      isolate(MyDataflowComponent, null);\n    }, /Second argument given to isolate\\(\\) must not be null/i);\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should convert the 2nd argument to string if it is not a string",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 33,
                "column": 69
            },
            "line": 33,
            "code": "  it('should convert the 2nd argument to string if it is not a string', function() {\n    function MyDataflowComponent() {}\n    assert.doesNotThrow(() => {\n      isolate(MyDataflowComponent, 12);\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should return a function",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 40,
                "column": 30
            },
            "line": 40,
            "code": "  it('should return a function', function() {\n    function MyDataflowComponent() {}\n    const scopedMyDataflowComponent = isolate(MyDataflowComponent, `myScope`);\n    assert.strictEqual(typeof scopedMyDataflowComponent, `function`);\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should make a new scope if second argument is undefined",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 46,
                "column": 61
            },
            "line": 46,
            "code": "  it('should make a new scope if second argument is undefined', function() {\n    function MyDataflowComponent() {}\n    const scopedMyDataflowComponent = isolate(MyDataflowComponent);\n    assert.strictEqual(typeof scopedMyDataflowComponent, `function`);\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should accept a scopes-per-channel object as the second argument",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 52,
                "column": 70
            },
            "line": 52,
            "code": "  it('should accept a scopes-per-channel object as the second argument', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {\n      first: 'scope1',\n      second: 'scope2',\n    });\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, 'scope1');\n    assert.strictEqual(actual2, 'scope1');\n    assert.strictEqual(actual3, 'scope2');\n    assert.strictEqual(actual4, 'scope2');\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should not isolate a channel given null scope",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 117,
                "column": 51
            },
            "line": 117,
            "code": "  it('should not isolate a channel given null scope', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {\n      first: null,\n      second: 'scope2',\n    });\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, '');\n    assert.strictEqual(actual2, '');\n    assert.strictEqual(actual3, 'scope2');\n    assert.strictEqual(actual4, 'scope2');\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should generate a scope if a channel is undefined in scopes-per-channel",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 182,
                "column": 77
            },
            "line": 182,
            "code": "  it('should generate a scope if a channel is undefined in scopes-per-channel', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {first: 'scope1'});\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, 'scope1');\n    assert.strictEqual(actual2, 'scope1');\n    assert.strictEqual(actual3, 'cycle1');\n    assert.strictEqual(actual4, 'cycle1');\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should accept a wildcard * in the scopes-per-channel object",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 244,
                "column": 65
            },
            "line": 244,
            "code": "  it('should accept a wildcard * in the scopes-per-channel object', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {\n      first: 'scope1',\n      '*': 'default',\n    });\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, 'scope1');\n    assert.strictEqual(actual2, 'scope1');\n    assert.strictEqual(actual3, 'default');\n    assert.strictEqual(actual4, 'default');\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should not isolate a non-specified channel if wildcard * is null",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 309,
                "column": 70
            },
            "line": 309,
            "code": "  it('should not isolate a non-specified channel if wildcard * is null', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {\n      first: 'scope1',\n      '*': null,\n    });\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, 'scope1');\n    assert.strictEqual(actual2, 'scope1');\n    assert.strictEqual(actual3, '');\n    assert.strictEqual(actual4, '');\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should not convert to string values in scopes-per-channel object",
            "suites": [
                "isolate"
            ],
            "updatePoint": {
                "line": 374,
                "column": 70
            },
            "line": 374,
            "code": "  it('should not convert to string values in scopes-per-channel object', function(done) {\n    function Component(_sources: any) {\n      return {\n        first: _sources.first.getSink(),\n        second: _sources.second.getSink(),\n      };\n    }\n\n    const scopedComponent = isolate(Component, {first: 123, second: 456});\n    let actual1 = '';\n    let actual2 = '';\n    let actual3 = '';\n    let actual4 = '';\n\n    const sources = {\n      first: {\n        getSink() {\n          return of(10);\n        },\n        isolateSource(source: any, scope: string) {\n          actual1 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual2 = scope;\n          return sink;\n        },\n      },\n\n      second: {\n        getSink() {\n          return of(20);\n        },\n        isolateSource(source: any, scope: string) {\n          actual3 = scope;\n          return source;\n        },\n        isolateSink(sink: any, scope: string) {\n          actual4 = scope;\n          return sink;\n        },\n      },\n    };\n    const sinks = scopedComponent(sources);\n\n    assert.strictEqual(actual1, 123);\n    assert.strictEqual(actual2, 123);\n    assert.strictEqual(actual3, 456);\n    assert.strictEqual(actual4, 456);\n    let hasFirst = false;\n    sinks.first.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, false);\n      assert.strictEqual(x, 10);\n      hasFirst = true;\n    });\n    sinks.second.subscribe((x: any) => {\n      assert.strictEqual(hasFirst, true);\n      assert.strictEqual(x, 20);\n      done();\n    });\n  });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should return a valid dataflow component",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 437,
                "column": 48
            },
            "line": 437,
            "code": "    it('should return a valid dataflow component', function(done) {\n      function driver() {\n        return {};\n      }\n\n      function MyDataflowComponent(\n        sources: {other: unknown},\n        foo: string,\n        bar: string\n      ) {\n        return {\n          other: of([foo, bar]),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent);\n      const scopedSinks = scopedMyDataflowComponent(\n        {other: driver()},\n        `foo`,\n        `bar`\n      );\n\n      assert.strictEqual(typeof scopedSinks, `object`);\n      scopedSinks.other.subscribe(strings => {\n        assert.strictEqual(strings.join(), `foo,bar`);\n        done();\n      });\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should return correct types when all inputs are typed",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 465,
                "column": 61
            },
            "line": 465,
            "code": "    it('should return correct types when all inputs are typed', function(done) {\n      class MyTestSource {\n        constructor() {}\n\n        public isolateSource(so: MyTestSource, scope: string) {\n          return new MyTestSource();\n        }\n\n        public isolateSink(\n          sink: Observable<Array<string>>,\n          scope: string\n        ): Observable<Array<string>> {\n          return sink;\n        }\n      }\n\n      function MyDataflowComponent(\n        sources: {other: MyTestSource},\n        foo: string,\n        bar: string\n      ) {\n        return {\n          other: of([foo, bar]),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent);\n      const scopedSinks = scopedMyDataflowComponent(\n        {other: new MyTestSource()},\n        `foo`,\n        `bar`\n      ) as {other: Observable<Array<string>>};\n\n      assert.strictEqual(typeof scopedSinks, `object`);\n      scopedSinks.other.subscribe(strings => {\n        assert.strictEqual(strings.join(), `foo,bar`);\n        done();\n      });\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should return correct types when all inputs are typed",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 504,
                "column": 61
            },
            "line": 504,
            "code": "    it('should return correct types when all inputs are typed', function(done) {\n      class MyTestSource {\n        constructor() {}\n\n        public isolateSource(so: MyTestSource, scope: string) {\n          return new MyTestSource();\n        }\n\n        public isolateSink(\n          sink: Observable<Array<string>>,\n          scope: string\n        ): Observable<Array<number>> {\n          return of([123, 456]);\n        }\n      }\n\n      function MyDataflowComponent(\n        sources: {other: MyTestSource},\n        foo: string,\n        bar: string\n      ) {\n        return {\n          other: of([foo, bar]),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent);\n      const scopedSinks = scopedMyDataflowComponent(\n        {other: new MyTestSource()},\n        `foo`,\n        `bar`\n      ) as {other: Observable<Array<number>>};\n\n      assert.strictEqual(typeof scopedSinks, `object`);\n      scopedSinks.other.subscribe(nums => {\n        assert.strictEqual(nums.join(), `123,456`);\n        done();\n      });\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should return correct types when all inputs are typed",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 543,
                "column": 61
            },
            "line": 543,
            "code": "    it('should return correct types when all inputs are typed', function(done) {\n      function MyDataflowComponent(\n        sources: {other: Observable<string>},\n        foo: string,\n        bar: string\n      ) {\n        return {\n          other: of([foo, bar]),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent);\n      const scopedSinks = scopedMyDataflowComponent(\n        {other: of<string>('foo')},\n        `foo`,\n        `bar`\n      );\n\n      assert.strictEqual(typeof scopedSinks, `object`);\n      scopedSinks.other.subscribe((x: Array<string>) => {\n        assert.strictEqual(x.join(), `foo,bar`);\n        done();\n      });\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should call `isolateSource` of drivers",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 567,
                "column": 46
            },
            "line": 567,
            "code": "    it('should call `isolateSource` of drivers', function() {\n      function driver() {\n        function isolateSource(source: any, scope: string) {\n          return source.someFunc(scope);\n        }\n        function someFunc(this: any, v: string) {\n          const scope = this.scope;\n          return {\n            scope: scope.concat(v),\n            someFunc,\n            isolateSource,\n          };\n        }\n        return {\n          scope: [],\n          someFunc,\n          isolateSource,\n        };\n      }\n\n      function MyDataflowComponent(sources: {other: any}) {\n        return {\n          other: sources.other.someFunc('a'),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent, `myScope`);\n      const scopedSinks = scopedMyDataflowComponent({other: driver()});\n      assert.strictEqual(scopedSinks.other.scope.length, 2);\n      assert.strictEqual(scopedSinks.other.scope[0], `myScope`);\n      assert.strictEqual(scopedSinks.other.scope[1], `a`);\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should not call `isolateSink` for a sink-only driver",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 599,
                "column": 60
            },
            "line": 599,
            "code": "    it('should not call `isolateSink` for a sink-only driver', function() {\n      function driver(sink: any) {}\n\n      function MyDataflowComponent(sources: {other: any}) {\n        return {\n          other: of('a'),\n        };\n      }\n      let scopedMyDataflowComponent;\n      assert.doesNotThrow(function() {\n        scopedMyDataflowComponent = isolate(MyDataflowComponent, `myScope`);\n      });\n      const scopedSinks = (scopedMyDataflowComponent as any)({\n        other: driver(null),\n      });\n      scopedSinks.other.subscribe((x: any) => assert.strictEqual(x, 'a'));\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should call `isolateSink` of drivers",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 617,
                "column": 44
            },
            "line": 617,
            "code": "    it('should call `isolateSink` of drivers', function(done) {\n      function driver() {\n        function isolateSink(sink: any, scope: string) {\n          return sink.map((v: string) => `${v} ${scope}`);\n        }\n        return {\n          isolateSink,\n        };\n      }\n\n      function MyDataflowComponent(sources: {other: unknown}) {\n        return {\n          other: of('a'),\n        };\n      }\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent, `myScope`);\n      const scopedSinks = scopedMyDataflowComponent({other: driver()});\n      const i = 0;\n      scopedSinks.other.subscribe(x => {\n        assert.strictEqual(x, 'a myScope');\n        done();\n      });\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should handle undefined cases gracefully",
            "suites": [
                "isolate",
                "scopedDataflowComponent"
            ],
            "updatePoint": {
                "line": 641,
                "column": 48
            },
            "line": 641,
            "code": "    it('should handle undefined cases gracefully', function() {\n      const MyDataflowComponent = () => ({});\n      const scopedMyDataflowComponent = isolate(MyDataflowComponent, 'myScope');\n      assert.doesNotThrow(() =>\n        scopedMyDataflowComponent({noSource: void 0 as any})\n      );\n    });",
            "file": "index.ts",
            "skipped": false,
            "dir": "isolate/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 9,
                "column": 26
            },
            "line": 9,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof run, 'function');\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 13,
                "column": 54
            },
            "line": 13,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (run as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 19,
                "column": 54
            },
            "line": 19,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (run as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 25,
                "column": 56
            },
            "line": 25,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      run(() => ({}), {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should return a dispose function",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 31,
                "column": 38
            },
            "line": 31,
            "code": "  it('should return a dispose function', function() {\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n    function app(sources: any) {\n      return {\n        other: sources.other.take(1).startWith('a'),\n      };\n    }\n    function driver() {\n      return most.of('b').tap(spy);\n    }\n    const dispose = run(app, {other: driver});\n    assert.strictEqual(typeof dispose, 'function');\n    setTimeout(() => {\n      sinon.assert.calledOnce(spy);\n    });\n    dispose();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should report errors from main() in the console",
            "suites": [
                "run()"
            ],
            "updatePoint": {
                "line": 50,
                "column": 53
            },
            "line": 50,
            "code": "  it('should report errors from main() in the console', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function main(sources: any): any {\n      return {\n        other: sources.other.map(() => {\n          throw new Error('malfunction');\n        }),\n      };\n    }\n    function driver(xsSink: any) {\n      most\n        .from(xsSink)\n        .drain()\n        .catch(() => {});\n      return most.of('b');\n    }\n\n    let caught = false;\n    try {\n      run(main, {other: driver});\n    } catch (err) {\n      assert.strictEqual(err.message, 'malfunction');\n      caught = true;\n    }\n\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match((err: any) => err.message === 'malfunction')\n      );\n\n      // Should be false because the error was already reported in the console.\n      // Otherwise we would have double reporting of the error.\n      assert.strictEqual(caught, false);\n\n      done();\n    }, 100);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 10,
                "column": 26
            },
            "line": 10,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof setup, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 14,
                "column": 54
            },
            "line": 14,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (setup as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 20,
                "column": 54
            },
            "line": 20,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (setup as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 26,
                "column": 56
            },
            "line": 26,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      setup(() => ({}), {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should allow to not use all sources in main",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 32,
                "column": 49
            },
            "line": 32,
            "code": "  it('should allow to not use all sources in main', function() {\n    function app(so: {first: Stream<string>}) {\n      return {\n        first: xs.of('test'),\n        second: xs.of('string'),\n      };\n    }\n    function app2() {\n      return {second: xs.of('test')};\n    }\n    function driver(sink: xsStream<string>) {\n      return xs.of('answer');\n    }\n    const {sinks, sources} = setup(app, {first: driver, second: driver});\n    const {sinks: sinks2, sources: sources2} = setup(app2, {\n      first: driver,\n      second: driver,\n    });\n\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.second.addListener, 'function');\n    assert.strictEqual(typeof sinks2, 'object');\n    assert.strictEqual(typeof sinks2.second.addListener, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should return sinks object and sources object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 57,
                "column": 51
            },
            "line": 57,
            "code": "  it('should return sinks object and sources object', function() {\n    type MySources = {\n      other: Stream<string>;\n    };\n\n    type MySinks = {\n      other: Stream<string>;\n    };\n\n    function app(_sources: MySources): MySinks {\n      return {\n        other: _sources.other.take(1).startWith('a'),\n      };\n    }\n    function driver() {\n      return most.of('b');\n    }\n    const {sinks, sources} = setup(app, {other: driver});\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.other.observe, 'function');\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.observe, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should return a run() which in turn returns a dispose()",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 83,
                "column": 61
            },
            "line": 83,
            "code": "  it('should return a run() which in turn returns a dispose()', function(done) {\n    type TestSources = {\n      other: Stream<number>;\n    };\n\n    type TestSinks = {\n      other: Stream<string>;\n    };\n\n    function app(_sources: TestSources): TestSinks {\n      return {\n        other: most.concat(\n          _sources.other\n            .take(6)\n            .map(String)\n            .startWith('a'),\n          most.never()\n        ),\n      };\n    }\n    function driver(xsSink: xsStream<string>) {\n      return most\n        .from(xsSink)\n        .map(x => x.charCodeAt(0))\n        .delay(1);\n    }\n    const {sources, run} = setup(app, {other: driver});\n    let dispose: any;\n    sources.other\n      .observe(x => {\n        assert.strictEqual(x, 97);\n        dispose();\n        done();\n      })\n      .catch(done);\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should not type check drivers that use xstream",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 121,
                "column": 52
            },
            "line": 121,
            "code": "  it('should not type check drivers that use xstream', function() {\n    type MySources = {\n      other: Stream<string>;\n    };\n\n    type MySinks = {\n      other: Stream<string>;\n    };\n\n    function app(_sources: MySources): MySinks {\n      return {\n        other: _sources.other.take(1).startWith('a'),\n      };\n    }\n    function xsdriver(sink: xs<string>): xs<string> {\n      return xs.of('b');\n    }\n\n    const {sinks, sources} = setup(app, {other: xsdriver});\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.other.subscribe, 'function');\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.subscribe, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should not work after has been disposed",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 148,
                "column": 45
            },
            "line": 148,
            "code": "  it('should not work after has been disposed', function(done) {\n    const number$ = most\n      .periodic(50, 1)\n      .scan((x, y) => x + y, 0)\n      .map(i => i + 1);\n    function app(_sources: any) {\n      return {other: number$};\n    }\n    const {sources, run} = setup(app, {\n      other: (num$: xsStream<number>) => most.from(num$).map(num => 'x' + num),\n    });\n    let dispose: any;\n    sources.other\n      .observe((x: any) => {\n        assert.notStrictEqual(x, 'x3');\n        if (x === 'x2') {\n          dispose();\n          setTimeout(() => {\n            done();\n          }, 100);\n        }\n      })\n      .catch(done);\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "most-run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 8,
                "column": 26
            },
            "line": 8,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof run, 'function');\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 12,
                "column": 54
            },
            "line": 12,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (run as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 18,
                "column": 54
            },
            "line": 18,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (run as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 24,
                "column": 56
            },
            "line": 24,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      (run as any)(() => {}, {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should return a dispose function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 30,
                "column": 38
            },
            "line": 30,
            "code": "  it('should return a dispose function', function() {\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n\n    type NiceSources = {\n      other: Stream<string>;\n    };\n    type NiceSinks = {\n      other: Stream<string>;\n    };\n\n    function app(sources: NiceSources): NiceSinks {\n      return {\n        other: sources.other.take(1).startWith('a'),\n      };\n    }\n\n    function driver() {\n      return xs.of('b').debug(spy);\n    }\n\n    const dispose = run(app, {other: driver});\n    assert.strictEqual(typeof dispose, 'function');\n    sinon.assert.calledOnce(spy);\n    dispose();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should support driver that asynchronously subscribes to sink",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 57,
                "column": 66
            },
            "line": 57,
            "code": "  it('should support driver that asynchronously subscribes to sink', function(done) {\n    function app(sources: any): any {\n      return {\n        foo: xs.of(10),\n      };\n    }\n\n    const expected = [10];\n    function driver(sink: Stream<number>): Stream<any> {\n      const buffer: Array<number> = [];\n      sink.addListener({\n        next: x => {\n          buffer.push(x);\n        },\n      });\n      setTimeout(() => {\n        while (buffer.length > 0) {\n          const x = buffer.shift();\n          assert.strictEqual(x, expected.shift());\n        }\n        sink.subscribe({\n          next(x) {\n            assert.strictEqual(x, expected.shift());\n          },\n          error() {},\n          complete() {},\n        });\n      });\n      return xs.never();\n    }\n\n    run(app, {foo: driver});\n\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 100);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should forbid cross-driver synchronous races (#592)",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 96,
                "column": 57
            },
            "line": 96,
            "code": "  it('should forbid cross-driver synchronous races (#592)', function(done) {\n    this.timeout(4000);\n\n    function child(sources: any, num: number) {\n      const vdom$ = sources.HTTP\n        // .select('cat')\n        // .flatten()\n        .map((res: any) => res.body.name)\n        .map((name: string) => 'My name is ' + name);\n\n      const request$ =\n        num === 1\n          ? xs.of({\n              category: 'cat',\n              url: 'http://jsonplaceholder.typicode.com/users/1',\n            })\n          : xs.never();\n\n      return {\n        HTTP: request$,\n        DOM: vdom$,\n      };\n    }\n\n    function mainHTTPThenDOM(sources: any) {\n      const sinks$ = xs\n        .periodic(100)\n        .take(6)\n        .map(i => {\n          if (i % 2 === 1) {\n            return child(sources, i);\n          } else {\n            return {\n              HTTP: xs.empty(),\n              DOM: xs.of(''),\n            };\n          }\n        });\n\n      // order of sinks is important to reproduce the bug\n      return {\n        HTTP: sinks$.map(sinks => sinks.HTTP).flatten(),\n        DOM: sinks$.map(sinks => sinks.DOM as Stream<string>).flatten(),\n      };\n    }\n\n    function mainDOMThenHTTP(sources: any) {\n      const sinks$ = xs\n        .periodic(100)\n        .take(6)\n        .map(i => {\n          if (i % 2 === 1) {\n            return child(sources, i);\n          } else {\n            return {\n              HTTP: xs.empty(),\n              DOM: xs.of(''),\n            };\n          }\n        });\n\n      // order of sinks is important to reproduce the bug\n      return {\n        DOM: sinks$.map(sinks => sinks.DOM as Stream<string>).flatten(),\n        HTTP: sinks$.map(sinks => sinks.HTTP).flatten(),\n      };\n    }\n\n    let requestsSent = 0;\n    const expectedDOMSinks = [\n      /* HTTP then DOM: */ '',\n      'My name is Louis',\n      '',\n      '',\n      /* DOM then HTTP: */ '',\n      'My name is Louis',\n      '',\n      '',\n    ];\n\n    function domDriver(sink: Stream<string>) {\n      sink.addListener({\n        next: s => {\n          assert.strictEqual(s, expectedDOMSinks.shift());\n        },\n        error: (err: any) => {},\n      });\n    }\n\n    function httpDriver(sink: Stream<any>) {\n      const source = sink.map(req => ({body: {name: 'Louis'}}));\n      source.addListener({\n        next: x => {},\n        error: (err: any) => {},\n      });\n      return source.debug(x => {\n        requestsSent += 1;\n      });\n    }\n\n    // HTTP then DOM:\n    const dispose = run(mainHTTPThenDOM, {\n      HTTP: httpDriver,\n      DOM: domDriver,\n    });\n    setTimeout(() => {\n      assert.strictEqual(expectedDOMSinks.length, 4);\n      assert.strictEqual(requestsSent, 1);\n      dispose();\n\n      // DOM then HTTP:\n      run(mainDOMThenHTTP, {\n        HTTP: httpDriver,\n        DOM: domDriver,\n      });\n      setTimeout(() => {\n        assert.strictEqual(expectedDOMSinks.length, 0);\n        assert.strictEqual(requestsSent, 2);\n        done();\n      }, 1000);\n    }, 1000);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should report errors from main() in the console",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 219,
                "column": 53
            },
            "line": 219,
            "code": "  it('should report errors from main() in the console', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function main(sources: any): any {\n      return {\n        other: sources.other\n          .take(1)\n          .startWith('a')\n          .map(() => {\n            throw new Error('malfunction');\n          }),\n      };\n    }\n    function driver(sink: Stream<any>) {\n      sink.addListener({\n        next: () => {},\n        error: (err: any) => {},\n      });\n      return xs.of('b');\n    }\n\n    let caught = false;\n    try {\n      run(main, {other: driver});\n    } catch (e) {\n      caught = true;\n    }\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match((err: any) => err.message === 'malfunction')\n      );\n\n      // Should be false because the error was already reported in the console.\n      // Otherwise we would have double reporting of the error.\n      assert.strictEqual(caught, false);\n\n      sandbox.restore();\n      done();\n    }, 80);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should call DevTool internal function to pass sinks",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 263,
                "column": 57
            },
            "line": 263,
            "code": "  it('should call DevTool internal function to pass sinks', function() {\n    let window: any;\n    if (typeof global === 'object') {\n      (global as any).window = {};\n      window = (global as any).window;\n    }\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n    window.CyclejsDevTool_startGraphSerializer = spy;\n\n    function app(ext: any): any {\n      return {\n        other: ext.other.take(1).startWith('a'),\n      };\n    }\n    function driver() {\n      return xs.of('b');\n    }\n    run(app, {other: driver});\n\n    sinon.assert.calledOnce(spy);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should adapt() a simple source (stream)",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 286,
                "column": 45
            },
            "line": 286,
            "code": "  it('should adapt() a simple source (stream)', function(done) {\n    let appCalled = false;\n    function app(sources: any): any {\n      assert.strictEqual(typeof sources.other, 'string');\n      assert.strictEqual(sources.other, 'this is adapted');\n      appCalled = true;\n\n      return {\n        other: xs.of(1, 2, 3),\n      };\n    }\n\n    function driver(sink: Stream<string>) {\n      return xs.of(10, 20, 30);\n    }\n\n    setAdapt(stream => 'this is adapted');\n    run(app, {other: driver});\n    setAdapt(x => x);\n\n    assert.strictEqual(appCalled, true);\n    done();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should support sink-only drivers",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 310,
                "column": 38
            },
            "line": 310,
            "code": "  it('should support sink-only drivers', function(done) {\n    function app(sources: any): any {\n      return {\n        other: xs.of(1, 2, 3),\n      };\n    }\n\n    let driverCalled = false;\n    function driver(sink: Stream<string>) {\n      assert.strictEqual(typeof sink, 'object');\n      assert.strictEqual(typeof sink.fold, 'function');\n      driverCalled = true;\n    }\n\n    run(app, {other: driver});\n\n    assert.strictEqual(driverCalled, true);\n    done();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should not adapt() sinks",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 330,
                "column": 30
            },
            "line": 330,
            "code": "  it('should not adapt() sinks', function(done) {\n    function app(sources: any): any {\n      return {\n        other: xs.of(1, 2, 3),\n      };\n    }\n\n    let driverCalled = false;\n    function driver(sink: Stream<string>) {\n      assert.strictEqual(typeof sink, 'object');\n      assert.strictEqual(typeof sink.fold, 'function');\n      driverCalled = true;\n      return xs.of(10, 20, 30);\n    }\n\n    setAdapt(stream => 'this not a stream');\n    run(app, {other: driver});\n    setAdapt(x => x);\n\n    assert.strictEqual(driverCalled, true);\n    done();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 10,
                "column": 26
            },
            "line": 10,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof setup, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 14,
                "column": 54
            },
            "line": 14,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (setup as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 20,
                "column": 54
            },
            "line": 20,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (setup as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 26,
                "column": 56
            },
            "line": 26,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      (setup as any)(() => {}, {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should allow to have a driver that takes a union as input",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 32,
                "column": 63
            },
            "line": 32,
            "code": "  it('should allow to have a driver that takes a union as input', function() {\n    function app(so: {drv: Stream<string>}) {\n      return {\n        drv: xs.of('foo'),\n      };\n    }\n\n    const {sinks, sources} = setup(app, {\n      drv: (s: Stream<string | number>) => xs.of('foo'),\n    });\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should allow to not use all sources in main",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 44,
                "column": 49
            },
            "line": 44,
            "code": "  it('should allow to not use all sources in main', function() {\n    function app(so: {first: Stream<string>}) {\n      return {\n        first: xs.of('test'),\n        second: xs.of('string'),\n      };\n    }\n    function app2() {\n      return {second: xs.of('test')};\n    }\n    function driver(sink: Stream<string>) {\n      return xs.of('answer');\n    }\n    const {sinks, sources} = setup(app, {first: driver, second: driver});\n    const {sinks: sinks2, sources: sources2} = setup(app2, {\n      first: driver,\n      second: driver,\n    });\n\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.second.addListener, 'function');\n    assert.strictEqual(typeof sinks2, 'object');\n    assert.strictEqual(typeof sinks2.second.addListener, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should return sinks object and sources object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 69,
                "column": 51
            },
            "line": 69,
            "code": "  it('should return sinks object and sources object', function() {\n    function app(ext: {other: Stream<string>}) {\n      return {\n        other: ext.other.take(1).startWith('a'),\n      };\n    }\n    function driver() {\n      return xs.of('b');\n    }\n    const {sinks, sources} = setup(app, {other: driver});\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.other.addListener, 'function');\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.addListener, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should type-check keyof sources and sinks in main and drivers",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 87,
                "column": 67
            },
            "line": 87,
            "code": "  it('should type-check keyof sources and sinks in main and drivers', function() {\n    type Sources = {\n      str: Stream<string>;\n      obj: Stream<object>;\n    };\n\n    function app(sources: Sources) {\n      return {\n        str: sources.str.take(1).startWith('a'), // good\n        // str: sources.obj.mapTo('good'), // good\n        // strTYPO: sources.str.take(1).startWith('a'), // bad\n        // str: xs.of(123), // bad\n        num: xs.of(100), // good\n        // numTYPO: xs.of(100), // bad\n        // num: xs.of('BAD TYPE'), // bad\n      };\n    }\n\n    const stringDriver: Driver<Stream<string>, Stream<string>> = (\n      sink: Stream<string>\n    ) => xs.of('b');\n\n    const numberWriteOnlyDriver: Driver<Stream<number>, void> = (\n      sink: Stream<number>\n    ) => {};\n\n    const objectReadOnlyDriver: Driver<void, Stream<object>> = () => xs.of({});\n\n    setup(app, {\n      str: stringDriver,\n      num: numberWriteOnlyDriver,\n      obj: objectReadOnlyDriver,\n    });\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should type-check keyof sources and sinks, supporting interfaces",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 122,
                "column": 70
            },
            "line": 122,
            "code": "  it('should type-check keyof sources and sinks, supporting interfaces', function() {\n    interface Sources {\n      str: Stream<string>;\n      obj: Stream<object>;\n    }\n\n    interface Sinks {\n      str: Stream<string>;\n      num: Stream<number>;\n    }\n\n    function app(sources: Sources): Sinks {\n      return {\n        str: sources.str.take(1).startWith('a'), // good\n        // str: sources.obj.mapTo('good'), // good\n        // strTYPO: sources.str.take(1).startWith('a'), // bad\n        // str: xs.of(123), // bad\n        num: xs.of(100), // good\n        // numTYPO: xs.of(100), // bad\n        // num: xs.of('BAD TYPE'), // bad\n      };\n    }\n\n    const stringDriver: Driver<Stream<string>, Stream<string>> = (\n      sink: Stream<string>\n    ) => xs.of('b');\n\n    const numberWriteOnlyDriver: Driver<Stream<number>, void> = (\n      sink: Stream<number>\n    ) => {};\n\n    const objectReadOnlyDriver: Driver<void, Stream<object>> = () => xs.of({});\n\n    setup(app, {\n      str: stringDriver,\n      num: numberWriteOnlyDriver,\n      obj: objectReadOnlyDriver,\n    });\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should type-check and allow more drivers than sinks",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 162,
                "column": 57
            },
            "line": 162,
            "code": "  it('should type-check and allow more drivers than sinks', function() {\n    type Sources = {\n      str: Stream<string>;\n      num: Stream<number>;\n      obj: Stream<object>;\n    };\n\n    function app(sources: Sources) {\n      return {};\n    }\n\n    function stringDriver(sink: Stream<string>) {\n      return xs.of('b');\n    }\n\n    const numberDriver = (sink: Stream<number>) => xs.of(100);\n\n    const objectReadOnlyDriver = () => xs.of({});\n\n    setup(app, {\n      str: stringDriver,\n      num: numberDriver,\n      obj: objectReadOnlyDriver,\n    });\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should return a run() which in turn returns a dispose()",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 188,
                "column": 61
            },
            "line": 188,
            "code": "  it('should return a run() which in turn returns a dispose()', function(done) {\n    type TestSources = {\n      other: Stream<number>;\n    };\n\n    function app(_sources: TestSources) {\n      return {\n        other: concat(\n          _sources.other\n            .take(6)\n            .map(String)\n            .startWith('a'),\n          xs.never()\n        ),\n      };\n    }\n\n    function driver(sink: Stream<string>) {\n      return sink.map(x => x.charCodeAt(0)).compose(delay(1));\n    }\n\n    const {sources, run} = setup(app, {other: driver});\n\n    let dispose: any;\n    sources.other.addListener({\n      next: x => {\n        assert.strictEqual(x, 97);\n        dispose(); // will trigger this listener's complete\n      },\n      error: done,\n      complete: done,\n    });\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should not work after has been disposed",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 223,
                "column": 45
            },
            "line": 223,
            "code": "  it('should not work after has been disposed', function(done) {\n    type MySources = {\n      other: Stream<string>;\n    };\n\n    function app(_sources: MySources) {\n      return {other: xs.periodic(100).map(i => i + 1)};\n    }\n    function driver(num$: Stream<number>): Stream<string> {\n      return num$.map(num => 'x' + num);\n    }\n\n    const {sources, run} = setup(app, {\n      other: driver,\n    });\n\n    let dispose: any;\n    sources.other.addListener({\n      next: x => {\n        assert.notStrictEqual(x, 'x3');\n        if (x === 'x2') {\n          dispose(); // will trigger this listener's complete\n        }\n      },\n      error: done,\n      complete: done,\n    });\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 9,
                "column": 26
            },
            "line": 9,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof setupReusable, 'function');\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if argument is not object",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 13,
                "column": 44
            },
            "line": 13,
            "code": "  it('should throw if argument is not object', function() {\n    assert.throws(() => {\n      (setupReusable as any)('not a function');\n    }, /Argument given to setupReusable must be an object with driver/i);\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should throw if argument is an empty object",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 19,
                "column": 49
            },
            "line": 19,
            "code": "  it('should throw if argument is an empty object', function() {\n    assert.throws(() => {\n      (setupReusable as any)({});\n    }, /Argument given to setupReusable must be an object with at least one/i);\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should return engine with sources and run",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 25,
                "column": 47
            },
            "line": 25,
            "code": "  it('should return engine with sources and run', function() {\n    function app(ext: any): any {\n      return {\n        other: ext.other.take(1).startWith('a'),\n      };\n    }\n    function driver() {\n      return xs.of('b');\n    }\n    const {sources, run} = setupReusable({other: driver});\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.addListener, 'function');\n    assert.strictEqual(typeof run, 'function');\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should return an engine, which we can run and dispose",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 42,
                "column": 59
            },
            "line": 42,
            "code": "  it('should return an engine, which we can run and dispose', function() {\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n\n    type NiceSources = {\n      other: Stream<string>;\n    };\n    type NiceSinks = {\n      other: Stream<string>;\n    };\n\n    function app(sources: NiceSources): NiceSinks {\n      return {\n        other: sources.other.take(1).startWith('a'),\n      };\n    }\n\n    function driver(sink: Stream<string>) {\n      return xs.of('b').debug(spy);\n    }\n\n    const engine = setupReusable({other: driver});\n    const sinks = app(engine.sources);\n    const dispose = engine.run(sinks);\n    assert.strictEqual(typeof dispose, 'function');\n    sinon.assert.calledOnce(spy);\n    dispose();\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should allow reusing drivers for many apps",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 71,
                "column": 48
            },
            "line": 71,
            "code": "  it('should allow reusing drivers for many apps', function(done) {\n    const sandbox = sinon.createSandbox();\n    const spy1 = sandbox.spy();\n    const spy2 = sandbox.spy();\n\n    type NiceSources = {\n      other: Stream<string>;\n    };\n    type NiceSinks = {\n      other: Stream<string>;\n    };\n\n    function app1(sources: NiceSources): NiceSinks {\n      return {\n        other: sources.other.mapTo('a').debug(spy1),\n      };\n    }\n\n    function app2(sources: NiceSources): NiceSinks {\n      return {\n        other: sources.other.mapTo('x').debug(spy2),\n      };\n    }\n\n    let sinkCompleted = 0;\n    function driver(sink: Stream<string>) {\n      sink.addListener({\n        complete: () => {\n          sinkCompleted++;\n          done(\n            new Error('complete should not be called before engine is before')\n          );\n        },\n      });\n      return xs.of('b');\n    }\n\n    const engine = setupReusable({other: driver});\n\n    const dispose1 = engine.run(app1(engine.sources));\n    sinon.assert.calledOnce(spy1);\n    sinon.assert.calledWithExactly(spy1, 'a');\n    sandbox.restore();\n    dispose1();\n\n    const dispose2 = engine.run(app2(engine.sources));\n    sinon.assert.calledOnce(spy2);\n    sinon.assert.calledWithExactly(spy2, 'x');\n    dispose2();\n    assert.strictEqual(sinkCompleted, 0);\n    done();\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should allow disposing the engine, stopping reusability",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 124,
                "column": 61
            },
            "line": 124,
            "code": "  it('should allow disposing the engine, stopping reusability', function(done) {\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n\n    type NiceSources = {\n      other: Stream<string>;\n    };\n    type NiceSinks = {\n      other: Stream<string>;\n    };\n\n    function app(sources: NiceSources): NiceSinks {\n      return {\n        other: sources.other.mapTo('a').debug(spy),\n      };\n    }\n\n    let sinkCompleted = 0;\n    function driver(sink: Stream<string>) {\n      sink.addListener({\n        complete: () => {\n          sinkCompleted++;\n        },\n      });\n      return xs.of('b');\n    }\n\n    const engine = setupReusable({other: driver});\n\n    engine.run(app(engine.sources));\n    sinon.assert.calledOnce(spy);\n    sinon.assert.calledWithExactly(spy, 'a');\n    sandbox.restore();\n    engine.dispose();\n    assert.strictEqual(sinkCompleted, 1);\n    done();\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should report errors from main() in the console",
            "suites": [
                "setupReusable"
            ],
            "updatePoint": {
                "line": 162,
                "column": 53
            },
            "line": 162,
            "code": "  it('should report errors from main() in the console', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function main(sources: any): any {\n      return {\n        other: sources.other\n          .take(1)\n          .startWith('a')\n          .map(() => {\n            throw new Error('malfunction');\n          }),\n      };\n    }\n    function driver(sink: Stream<any>) {\n      sink.addListener({\n        next: () => {},\n        error: (err: any) => {},\n      });\n      return xs.of('b');\n    }\n\n    let caught = false;\n    const engine = setupReusable({other: driver});\n    try {\n      const sinks = main(engine.sources);\n      engine.run(sinks);\n    } catch (e) {\n      caught = true;\n    }\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match((err: any) => err.message === 'malfunction')\n      );\n\n      // Should be false because the error was already reported in the console.\n      // Otherwise we would have double reporting of the error.\n      assert.strictEqual(caught, false);\n\n      sandbox.restore();\n      done();\n    }, 80);\n  });",
            "file": "setupReusable.ts",
            "skipped": false,
            "dir": "run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 10,
                "column": 26
            },
            "line": 10,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof run, 'function');\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 14,
                "column": 54
            },
            "line": 14,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (run as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 20,
                "column": 54
            },
            "line": 20,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (run as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 26,
                "column": 56
            },
            "line": 26,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      (run as any)(() => {}, {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should return a dispose function",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 32,
                "column": 38
            },
            "line": 32,
            "code": "  it('should return a dispose function', function() {\n    const sandbox = sinon.createSandbox();\n    const spy = sandbox.spy();\n    function app(sources: any): any {\n      return {\n        other: sources.other.pipe(\n          take(1),\n          startWith('a')\n        ),\n      };\n    }\n    function driver() {\n      return of('b').pipe(tap(spy));\n    }\n    const dispose = run(app, {other: driver});\n    assert.strictEqual(typeof dispose, 'function');\n    sinon.assert.calledOnce(spy);\n    dispose();\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should report main() errors in the console",
            "suites": [
                "run"
            ],
            "updatePoint": {
                "line": 52,
                "column": 48
            },
            "line": 52,
            "code": "  it('should report main() errors in the console', function(done) {\n    const sandbox = sinon.createSandbox();\n    sandbox.stub(console, 'error');\n\n    function main(sources: any): any {\n      const sink = sources.other.pipe(\n        take(1),\n        startWith('a'),\n        delay(10),\n        map(() => {\n          throw new Error('malfunction');\n        })\n      );\n\n      return {\n        other: sink,\n      };\n    }\n\n    function driver(xsSink: any) {\n      from(xsSink).subscribe({\n        next: () => {},\n        error: err => {},\n      });\n      return of('b');\n    }\n\n    let caught = false;\n    try {\n      run(main, {other: driver});\n    } catch (e) {\n      assert.strictEqual(e.message, 'malfunction');\n      caught = true;\n    }\n    setTimeout(() => {\n      sinon.assert.calledOnce(console.error as any);\n      sinon.assert.calledWithExactly(\n        console.error as any,\n        sinon.match((err: any) => err.message === 'malfunction')\n      );\n\n      // Should be false because the error was already reported in the console.\n      // Otherwise we would have double reporting of the error.\n      assert.strictEqual(caught, false);\n\n      sandbox.restore();\n      done();\n    }, 80);\n  });",
            "file": "run.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should be a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 11,
                "column": 26
            },
            "line": 11,
            "code": "  it('should be a function', function() {\n    assert.strictEqual(typeof setup, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if first argument is not a function",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 15,
                "column": 54
            },
            "line": 15,
            "code": "  it('should throw if first argument is not a function', function() {\n    assert.throws(() => {\n      (setup as any)('not a function');\n    }, /First argument given to Cycle must be the 'main' function/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if second argument is not an object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 21,
                "column": 54
            },
            "line": 21,
            "code": "  it('should throw if second argument is not an object', function() {\n    assert.throws(() => {\n      (setup as any)(() => {}, 'not an object');\n    }, /Second argument given to Cycle must be an object with driver functions/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should throw if second argument is an empty object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 27,
                "column": 56
            },
            "line": 27,
            "code": "  it('should throw if second argument is an empty object', function() {\n    assert.throws(() => {\n      (setup as any)(() => {}, {});\n    }, /Second argument given to Cycle must be an object with at least one/i);\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should allow to not use all sources in main",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 33,
                "column": 49
            },
            "line": 33,
            "code": "  it('should allow to not use all sources in main', function() {\n    function app(so: {first: Observable<string>}) {\n      return {\n        first: of('test'),\n        second: of('string'),\n      };\n    }\n    function app2() {\n      return {second: of('test')};\n    }\n    function driver(sink: Stream<string>) {\n      return xs.of('answer');\n    }\n    const {sinks, sources} = setup(app, {first: driver, second: driver});\n    const {sinks: sinks2, sources: sources2} = setup(app2, {\n      first: driver,\n      second: driver,\n    });\n\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.second.pipe, 'function');\n    assert.strictEqual(typeof sinks2, 'object');\n    assert.strictEqual(typeof sinks2.second.pipe, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should return sinks object and sources object",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 58,
                "column": 51
            },
            "line": 58,
            "code": "  it('should return sinks object and sources object', function() {\n    type MySources = {\n      other: Observable<string>;\n    };\n\n    type MySinks = {\n      other: Observable<string>;\n    };\n\n    function app(_sources: MySources): MySinks {\n      return {\n        other: _sources.other.pipe(\n          take(1),\n          startWith('a')\n        ),\n      };\n    }\n    function driver() {\n      return xs.of('b');\n    }\n\n    const {sinks, sources} = setup(app, {other: driver});\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.other.subscribe, 'function');\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.subscribe, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should not type check drivers that use xstream",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 88,
                "column": 52
            },
            "line": 88,
            "code": "  it('should not type check drivers that use xstream', function() {\n    type MySources = {\n      other: Observable<string>;\n    };\n\n    type MySinks = {\n      other: Observable<string>;\n    };\n\n    function app(_sources: MySources): MySinks {\n      return {\n        other: _sources.other.pipe(\n          take(1),\n          startWith('a')\n        ),\n      };\n    }\n    function xsdriver(): Stream<string> {\n      return xs.of('b');\n    }\n\n    const {sinks, sources} = setup(app, {other: xsdriver});\n    assert.strictEqual(typeof sinks, 'object');\n    assert.strictEqual(typeof sinks.other.subscribe, 'function');\n    assert.strictEqual(typeof sources, 'object');\n    assert.notStrictEqual(typeof sources.other, 'undefined');\n    assert.notStrictEqual(sources.other, null);\n    assert.strictEqual(typeof sources.other.subscribe, 'function');\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should return a run() which in turn returns a dispose()",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 118,
                "column": 61
            },
            "line": 118,
            "code": "  it('should return a run() which in turn returns a dispose()', function(done) {\n    type TestSources = {\n      other: Observable<number>;\n    };\n\n    type TestSinks = {\n      other: Observable<string>;\n    };\n\n    function app(_sources: TestSources): TestSinks {\n      return {\n        other: _sources.other.pipe(\n          take(6),\n          map(String),\n          startWith('a')\n        ),\n      };\n    }\n    function driver(xsSink: Stream<string>): Stream<number> {\n      return xsSink.map(x => x.charCodeAt(0)).compose(xsDelay(1));\n    }\n    const {sources, run} = setup(app, {other: driver});\n    let dispose: any;\n    sources.other.subscribe(x => {\n      assert.strictEqual(x, 97);\n      dispose();\n      done();\n    });\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should not work after has been disposed",
            "suites": [
                "setup"
            ],
            "updatePoint": {
                "line": 149,
                "column": 45
            },
            "line": 149,
            "code": "  it('should not work after has been disposed', function(done) {\n    const number$ = range(1, 3).pipe(concatMap(x => of(x).pipe(delay(150))));\n\n    function app(_sources: {other: Observable<string>}) {\n      return {other: number$};\n    }\n\n    const {sources, run} = setup(app, {\n      other: (num$: Stream<number>) => num$.map(num => 'x' + num),\n    });\n\n    let dispose: any;\n    sources.other.subscribe(function(x: any) {\n      assert.notStrictEqual(x, 'x3');\n      if (x === 'x2') {\n        dispose();\n        setTimeout(() => {\n          done();\n        }, 100);\n      }\n    });\n    dispose = run();\n  });",
            "file": "setup.ts",
            "skipped": false,
            "dir": "rxjs-run/test"
        },
        {
            "name": "should return an isolatable List component",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 10,
                "column": 48
            },
            "line": 10,
            "code": "  it('should return an isolatable List component', done => {\n    type ItemState = {\n      key: string;\n      val: number | null;\n    };\n    const expected = [\n      [{key: 'a', val: 3}],\n      [{key: 'a', val: 3}, {key: 'b', val: null}],\n      [{key: 'a', val: 3}, {key: 'b', val: 10}],\n      [{key: 'a', val: 3}, {key: 'b', val: 10}, {key: 'c', val: 27}],\n      [{key: 'a', val: 3}, {key: 'b', val: 10}],\n    ];\n\n    function Child(sources: {state: StateSource<ItemState>}) {\n      const defaultReducer$ = xs.of((prev: any) => {\n        if (typeof prev.val === 'number') {\n          return prev;\n        } else {\n          return {key: prev.key, val: 10};\n        }\n      });\n\n      const deleteReducer$ = xs\n        .of((prev: any) => (prev.key === 'c' ? void 0 : prev))\n        .compose(delay(50));\n\n      return {\n        state: xs.merge(defaultReducer$, deleteReducer$) as Stream<\n          Reducer<any>\n        >,\n      };\n    }\n\n    const List = makeCollection<ItemState>({\n      item: Child,\n      itemKey: s => s.key,\n      itemScope: key => key,\n      collectSinks: instances => ({\n        state: instances.pickMerge('state'),\n      }),\n    });\n\n    type MainState = {\n      list: Array<ItemState>;\n    };\n\n    function Main(sources: {state: StateSource<MainState>}) {\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.list, expected.shift());\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {\n          done('complete should not be called');\n        },\n      });\n\n      const childSinks = isolate(List, 'list')(sources);\n      const childReducer$ = childSinks.state;\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [{key: 'a', val: 3}]};\n      });\n\n      const addReducer$ = xs.merge(\n        xs\n          .of(function addB(prev: MainState): MainState {\n            return {list: prev.list.concat({key: 'b', val: null})};\n          })\n          .compose(delay(100)),\n        xs\n          .of(function addC(prev: MainState): MainState {\n            return {list: prev.list.concat({key: 'c', val: 27})};\n          })\n          .compose(delay(200))\n      );\n\n      const parentReducer$ = xs.merge(initReducer$, addReducer$);\n      const reducer$ = xs.merge(parentReducer$, childReducer$);\n\n      return {\n        state: reducer$ as Stream<Reducer<any>>,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 300);\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with a custom itemKey",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 105,
                "column": 39
            },
            "line": 105,
            "code": "  it('should work with a custom itemKey', done => {\n    const expected = [\n      [{id: 'a', val: 3}],\n      [{id: 'a', val: 3}, {id: 'b', val: null}],\n      [{id: 'a', val: 3}, {id: 'b', val: 10}],\n      [{id: 'a', val: 3}, {id: 'b', val: 10}, {id: 'c', val: 27}],\n      [{id: 'a', val: 3}, {id: 'b', val: 10}],\n    ];\n\n    type ItemState = {\n      id: string;\n      val: number | undefined;\n    };\n\n    function Child(sources: {state: StateSource<ItemState>}) {\n      const defaultReducer$ = xs.of((prev: ItemState) => {\n        if (typeof prev.val === 'number') {\n          return prev;\n        } else {\n          return {id: prev.id, val: 10};\n        }\n      });\n\n      const deleteReducer$ = xs\n        .of((prev: ItemState) => (prev.id === 'c' ? void 0 : prev))\n        .compose(delay(50));\n\n      return {\n        state: xs.merge(defaultReducer$, deleteReducer$),\n      };\n    }\n\n    const List = makeCollection<ItemState>({\n      item: Child,\n      itemKey: s => s.id,\n      collectSinks: instances => ({\n        state: instances.pickMerge('state'),\n      }),\n    });\n\n    function Main(sources: {state: StateSource<any>}) {\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.list, expected.shift());\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {\n          done('complete should not be called');\n        },\n      });\n\n      const childSinks = isolate(List, 'list')(sources);\n      const childReducer$ = childSinks.state;\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [{id: 'a', val: 3}]};\n      });\n\n      const addReducer$ = xs.merge(\n        xs\n          .of(function addB(prev: any) {\n            return {list: prev.list.concat({id: 'b', val: null})};\n          })\n          .compose(delay(100)),\n        xs\n          .of(function addC(prev: any) {\n            return {list: prev.list.concat({id: 'c', val: 27})};\n          })\n          .compose(delay(200))\n      );\n\n      const parentReducer$ = xs.merge(initReducer$, addReducer$);\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 300);\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should support itemFactory instead of static item",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 196,
                "column": 55
            },
            "line": 196,
            "code": "  it('should support itemFactory instead of static item', done => {\n    type ItemState = {\n      type: string;\n      name: string | null;\n    };\n\n    const expected: Array<Array<ItemState>> = [\n      [{type: 'a', name: null}],\n      [{type: 'a', name: 'Apple'}],\n      [{type: 'a', name: 'Apple'}, {type: 'b', name: null}],\n      [{type: 'a', name: 'Apple'}, {type: 'b', name: 'Banana'}],\n    ];\n\n    function ChildApple(sources: {state: StateSource<ItemState>}) {\n      return {\n        state: xs.of((prev: ItemState) => {\n          if (typeof prev.name === 'string') {\n            return prev;\n          } else {\n            return {type: prev.type, name: 'Apple'};\n          }\n        }),\n      };\n    }\n\n    function ChildBanana(sources: {state: StateSource<ItemState>}) {\n      return {\n        state: xs.of((prev: ItemState) => {\n          if (typeof prev.name === 'string') {\n            return prev;\n          } else {\n            return {type: prev.type, name: 'Banana'};\n          }\n        }),\n      };\n    }\n\n    const List = makeCollection<ItemState>({\n      itemFactory: s => (s.type === 'a' ? ChildApple : ChildBanana),\n      itemKey: s => s.type,\n      collectSinks: instances => ({\n        state: instances.pickMerge('state'),\n      }),\n    });\n\n    function Main(sources: {state: StateSource<{list: Array<ItemState>}>}) {\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.list, expected.shift());\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {\n          done('complete should not be called');\n        },\n      });\n\n      const childSinks = isolate(List, 'list')(sources);\n      const childReducer$ = childSinks.state;\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [{type: 'a', name: null}]};\n      });\n\n      const addReducer$ = xs\n        .of(function addB(prev: any) {\n          return {list: prev.list.concat({type: 'b', name: null})};\n        })\n        .compose(delay(100));\n\n      const parentReducer$ = xs.merge(initReducer$, addReducer$);\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 300);\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should correctly accumulate over time even without itemKey",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 285,
                "column": 64
            },
            "line": 285,
            "code": "  it('should correctly accumulate over time even without itemKey', done => {\n    const expected = [\n      [{val: 3}],\n      [{val: 4}],\n      [{val: 5}],\n      [{val: 6}],\n      [{val: 6}, {val: null}],\n      [{val: 6}, {val: 10}],\n      [{val: 6}, {val: 11}],\n      [{val: 6}, {val: 12}],\n      [{val: 6}, {val: 13}],\n    ];\n\n    function Child(sources: {state: StateSource<any>}) {\n      const defaultReducer$ = xs.of((prev: any) => {\n        if (typeof prev.val === 'number') {\n          return prev;\n        } else {\n          return {val: 10};\n        }\n      });\n\n      const incrementReducer$ = xs\n        .of(\n          (prev: any) => ({val: prev.val + 1}),\n          (prev: any) => ({val: prev.val + 1}),\n          (prev: any) => ({val: prev.val + 1})\n        )\n        .compose(delay(50));\n\n      return {\n        state: xs.merge(defaultReducer$, incrementReducer$),\n      };\n    }\n\n    const List = makeCollection({\n      item: Child,\n      collectSinks: instances => ({\n        state: instances.pickMerge('state'),\n      }),\n    });\n\n    function Main(sources: {state: StateSource<any>}) {\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.list, expected.shift());\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {\n          done('complete should not be called');\n        },\n      });\n\n      const childSinks = isolate(List, 'list')(sources);\n      const childReducer$ = childSinks.state;\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [{val: 3}]};\n      });\n\n      const addReducer$ = xs\n        .of(function addSecond(prev: any) {\n          return {list: prev.list.concat({val: null})};\n        })\n        .compose(delay(100));\n\n      const parentReducer$ = xs.merge(initReducer$, addReducer$);\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 200);\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work also on an object, not just on arrays",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 371,
                "column": 55
            },
            "line": 371,
            "code": "  it('should work also on an object, not just on arrays', done => {\n    const expected = [{key: 'a', val: null}, {key: 'a', val: 10}];\n    function Child(sources: {state: StateSource<any>}) {\n      const defaultReducer$ = xs.of((prev: any) => {\n        if (typeof prev.val === 'number') {\n          return prev;\n        } else {\n          return {key: prev.key, val: 10};\n        }\n      });\n\n      return {\n        state: defaultReducer$,\n      };\n    }\n\n    const Wrapper = makeCollection({\n      item: Child,\n      collectSinks: instances => ({\n        state: instances.pickMerge('state'),\n      }),\n    });\n\n    function Main(sources: {state: StateSource<any>}) {\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.wrap, expected.shift());\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {\n          done('complete should not be called');\n        },\n      });\n\n      const wrapperSinks = isolate(Wrapper, 'wrap')(sources);\n      const wrapperReducer$ = wrapperSinks.state;\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {wrap: {key: 'a', val: null}};\n      });\n\n      const reducer$ = xs.merge(initReducer$, wrapperReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    setTimeout(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    }, 60);\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should not throw if pickMerge() is called with name that item does not use",
            "suites": [
                "makeCollection"
            ],
            "updatePoint": {
                "line": 431,
                "column": 80
            },
            "line": 431,
            "code": "  it('should not throw if pickMerge() is called with name that item does not use', done => {\n    function Child(sources: {state: StateSource<any>}) {\n      return {\n        state: xs.of({}),\n      };\n    }\n\n    const List = makeCollection<{key: string}>({\n      item: Child,\n      itemKey: s => s.key,\n      itemScope: key => key,\n      collectSinks: instances => ({\n        HTTP: instances.pickMerge('HTTP'),\n      }),\n    });\n\n    function Main(sources: {state: StateSource<any>}) {\n      const childSinks = isolate(List, 'list')(sources);\n\n      const initReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [{key: 'a', val: 3}]};\n      });\n\n      childSinks.HTTP.subscribe({});\n\n      return {\n        state: initReducer$,\n      };\n    }\n\n    const wrapped = withState(Main);\n    wrapped({});\n    done();\n  });",
            "file": "makeCollection.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "returns a wrapped main function",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 17,
                "column": 37
            },
            "line": 17,
            "code": "  it('returns a wrapped main function', () => {\n    function main() {\n      return {state: xs.never()};\n    }\n\n    const wrapped = withState(main);\n    assert.strictEqual(typeof wrapped, 'function');\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "inner function receives StateSource under sources.state",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 26,
                "column": 61
            },
            "line": 26,
            "code": "  it('inner function receives StateSource under sources.state', () => {\n    function main(sources: {state: StateSource<any>}) {\n      assert.strictEqual(!!sources.state, true);\n      assert.strictEqual(typeof sources.state, 'object');\n      assert.strictEqual(typeof sources.state.stream, 'object');\n      assert.strictEqual(typeof sources.state.select, 'function');\n      assert.strictEqual(typeof sources.state.isolateSource, 'function');\n      assert.strictEqual(typeof sources.state.isolateSink, 'function');\n      return {state: xs.never()};\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "inner function receives StateSource under sources.whatever",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 41,
                "column": 64
            },
            "line": 41,
            "code": "  it('inner function receives StateSource under sources.whatever', () => {\n    function main(sources: {whatever: StateSource<any>}) {\n      assert.strictEqual(!!sources.whatever, true);\n      assert.strictEqual(typeof sources.whatever, 'object');\n      assert.strictEqual(typeof sources.whatever.stream, 'object');\n      assert.strictEqual(typeof sources.whatever.select, 'function');\n      assert.strictEqual(typeof sources.whatever.isolateSource, 'function');\n      assert.strictEqual(typeof sources.whatever.isolateSink, 'function');\n      return {whatever: xs.never()};\n    }\n\n    const wrapped = withState(main, 'whatever');\n    wrapped({});\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "inner function takes StateSource, sends reducers to sink",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 56,
                "column": 62
            },
            "line": 56,
            "code": "  it('inner function takes StateSource, sends reducers to sink', done => {\n    type State = {foo: string};\n\n    const expected = ['bar'];\n    function main(sources: {state: StateSource<State>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.foo, expected.shift());\n        },\n        error(e) {},\n        complete() {},\n      });\n\n      return {\n        state: xs.of(function reducer1(prevState: State): State {\n          return {foo: 'bar'};\n        }),\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "StateSource.stream never emits if no sink reducer was emitted",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 86,
                "column": 67
            },
            "line": 86,
            "code": "  it('StateSource.stream never emits if no sink reducer was emitted', done => {\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      sources.state.stream.addListener({\n        next(x) {\n          done('StateSource should not emit in this case');\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {\n          done('StateSource should not complete');\n        },\n      });\n\n      return {\n        state: xs.never(),\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(done);\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should compile with type annotations",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 112,
                "column": 42
            },
            "line": 112,
            "code": "  it('should compile with type annotations', () => {\n    interface State {\n      foo: string;\n    }\n\n    interface Parent {\n      bar: number;\n      child: {foo: number};\n    }\n\n    interface Sources {\n      state: StateSource<State>;\n    }\n    interface Sinks {\n      state?: Stream<Reducer<State>>;\n    }\n\n    interface ParentSources {\n      state: StateSource<Parent>;\n    }\n    interface ParentSinks {\n      state?: Stream<Reducer<Parent>>;\n    }\n\n    function Child(sources: Sources): Sinks {\n      return {\n        state: xs.of<Reducer<State>>(() => ({foo: 'Hello'})),\n      };\n    }\n\n    function Parent(sources: ParentSources): ParentSinks {\n      const childSinks = isolate(Child, {state: 'child'})(sources);\n      return {\n        state: childSinks.state as Stream<Reducer<Parent>>,\n      };\n    }\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "reducers receive previous state",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 150,
                "column": 37
            },
            "line": 150,
            "code": "  it('reducers receive previous state', done => {\n    const expected = [7, 10, 15, 25];\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const reducer$ = xs.of(\n        () => ({count: 7}),\n        (prevState: any) => ({count: prevState.count + 3}),\n        (prevState: any) => ({count: prevState.count + 5}),\n        (prevState: any) => ({count: prevState.count + 10})\n      );\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(expected.length, 0);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "top level default reducer sees undefined prev state",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 186,
                "column": 57
            },
            "line": 186,
            "code": "  it('top level default reducer sees undefined prev state', done => {\n    type State = {foo: string};\n    let calledSource = false;\n    let calledSink = false;\n    function main(sources: {state: StateSource<State>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.foo, 'bar');\n          calledSource = true;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      return {\n        state: xs.of(function defaultReducer(prevState?: State): State {\n          assert.strictEqual(typeof prevState, 'undefined');\n          calledSink = true;\n          if (typeof prevState === 'undefined') {\n            return {foo: 'bar'};\n          } else {\n            return prevState;\n          }\n        }),\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledSource, true);\n      assert.strictEqual(calledSink, true);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "child component default reducer can get state from parent",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 226,
                "column": 63
            },
            "line": 226,
            "code": "  it('child component default reducer can get state from parent', done => {\n    let calledSource = false;\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [7];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          calledSource = true;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function defaultReducer(prevState: any): any {\n        if (typeof prevState === 'undefined') {\n          return {count: 0};\n        } else {\n          return prevState;\n        }\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      const childSinks = isolate(child, 'child')(sources);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {child: {count: 7}};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$);\n\n      return {\n        state: reducer$ as any,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledSource, true);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "child component default reducer can set default state",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 276,
                "column": 59
            },
            "line": 276,
            "code": "  it('child component default reducer can set default state', done => {\n    let calledSource = false;\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [0];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          calledSource = true;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function defaultReducer(prevState: any): any {\n        if (typeof prevState === 'undefined') {\n          return {count: 0};\n        } else {\n          return prevState;\n        }\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      const childSinks = isolate(child, 'child')(sources);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledSource, true);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "child component can be isolated with a lens object as scope",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 328,
                "column": 65
            },
            "line": 328,
            "code": "  it('child component can be isolated with a lens object as scope', done => {\n    let calledChild = 0;\n    let calledMain = 0;\n    type ChildState = {\n      celsius: number;\n    };\n    function child(sources: {state: StateSource<ChildState>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [27, 37];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.celsius, expected.shift());\n          calledChild += 1;\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function increment(\n        prevState: ChildState\n      ): ChildState {\n        return {celsius: prevState.celsius + 10};\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    type MainState = {\n      deeply: {\n        nested: {\n          prop: {\n            kelvin: number;\n          };\n        };\n      };\n    };\n    function main(sources: {state: StateSource<MainState>}) {\n      const celsiusLens: Lens<MainState, ChildState> = {\n        get: state => ({\n          celsius: state ? state.deeply.nested.prop.kelvin - 273 : 0,\n        }),\n        set: (state, childState) => ({\n          deeply: {\n            nested: {prop: {kelvin: childState ? childState.celsius + 273 : 0}},\n          },\n        }),\n      };\n\n      const childSinks = isolate(child, {state: celsiusLens})(sources);\n      const childReducer$ = childSinks.state;\n\n      const expected = [300, 310];\n      sources.state.stream.addListener({\n        next(s) {\n          assert.strictEqual(s.deeply.nested.prop.kelvin, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e.message);\n        },\n        complete() {},\n      });\n\n      const parentReducer$ = xs.of(function initReducer(\n        prevState: MainState\n      ): MainState {\n        return {\n          deeply: {\n            nested: {\n              prop: {\n                kelvin: 300,\n              },\n            },\n          },\n        };\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<MainState>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledChild, 2);\n      assert.strictEqual(calledMain, 2);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "child component also gets undefined if parent has not initialized state",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 425,
                "column": 77
            },
            "line": 425,
            "code": "  it('child component also gets undefined if parent has not initialized state', done => {\n    let called = false;\n    function child(sources: {state: StateSource<any>}) {\n      const expected = [0];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          called = true;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function defaultReducer(prevState: any): any {\n        if (typeof prevState === 'undefined') {\n          return {count: 0};\n        } else {\n          return prevState;\n        }\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      const childSinks = isolate(child, 'child')(sources);\n      const childReducer$ = childSinks.state as Stream<Reducer<any>>;\n\n      const reducer$ = childReducer$;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(called, true);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with a manually isolated child component",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 470,
                "column": 58
            },
            "line": 470,
            "code": "  it('should work with a manually isolated child component', done => {\n    let calledChild = 0;\n    let calledMain = 0;\n\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [7, 9];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          calledChild += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function(prevState: any): any {\n        return {count: prevState.count + 2};\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      const expected = [7, 9];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.child.count, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const childSinks = child({state: isolateSource(sources.state, 'child')});\n      assert(childSinks.state);\n      const childReducer$ = isolateSink(childSinks.state, 'child');\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {child: {count: 7}};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$);\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledChild, 2);\n      assert.strictEqual(calledMain, 2);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with an isolated child component",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 532,
                "column": 50
            },
            "line": 532,
            "code": "  it('should work with an isolated child component', done => {\n    let calledChild = 0;\n    let calledMain = 0;\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [7, 9];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          calledChild += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(function(prevState: any): any {\n        return {count: prevState.count + 2};\n      });\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [7, 9];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.child.count, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const childSinks = isolate(child, 'child')(sources);\n      assert(childSinks.state);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {child: {count: 7}};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledChild, 2);\n      assert.strictEqual(calledMain, 2);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with an isolated child component and falsy values",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 597,
                "column": 67
            },
            "line": 597,
            "code": "  it('should work with an isolated child component and falsy values', done => {\n    let calledChild = 0;\n    let calledMain = 0;\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [1, 0, -1];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x, expected.shift());\n          calledChild += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(\n        (prevCount: any) => prevCount - 1,\n        (prevCount: any) => prevCount - 1\n      ) as Stream<Reducer<any>>;\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [1, 0, -1];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.strictEqual(x.count, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const childSinks = isolate(child, 'count')(sources);\n      assert(childSinks.state);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {count: 1};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledChild, 3);\n      assert.strictEqual(calledMain, 3);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with an isolated child component on an array subtree",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 663,
                "column": 70
            },
            "line": 663,
            "code": "  it('should work with an isolated child component on an array subtree', done => {\n    let calledChild = 0;\n    let calledMain = 0;\n    function child(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [[3], [3, 5]];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x, expected.shift());\n          calledChild += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of((prevArr: Array<any>) => prevArr.concat(5));\n      return {\n        state: reducer$ as Stream<Reducer<any>>,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [[3], [3, 5]];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x.list, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const childSinks = isolate(child, 'list')(sources);\n      assert(childSinks.state);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return {list: [3]};\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledChild, 2);\n      assert.strictEqual(calledMain, 2);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "should work with an isolated child component on an array entry",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 726,
                "column": 68
            },
            "line": 726,
            "code": "  it('should work with an isolated child component on an array entry', done => {\n    let calledSecond = 0;\n    let calledMain = 0;\n    function secondEntry(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [5, 15, 6];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x, expected.shift());\n          calledSecond += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n      const reducer$ = xs.of(\n        (prevNum: number): number | undefined => prevNum + 10,\n        (prevNum: number): number | undefined => void 0\n      ) as Stream<Reducer<any>>;\n      return {\n        state: reducer$,\n      };\n    }\n\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [[3, 5, 6], [3, 15, 6], [3, 6]];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x, expected.shift());\n          calledMain += 1;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {},\n      });\n\n      const childSinks = isolate(secondEntry, 1)(sources);\n      assert(childSinks.state);\n      const childReducer$ = childSinks.state;\n\n      const parentReducer$ = xs.of(function initReducer(prevState: any): any {\n        return [3, 5, 6];\n      });\n      const reducer$ = xs.merge(parentReducer$, childReducer$) as Stream<\n        Reducer<any>\n      >;\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(calledSecond, 3);\n      assert.strictEqual(calledMain, 3);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "not complete reducer stream neither source state$",
            "suites": [
                "withState"
            ],
            "updatePoint": {
                "line": 792,
                "column": 55
            },
            "line": 792,
            "code": "  it('not complete reducer stream neither source state$', done => {\n    let called = false;\n    function main(sources: {state: StateSource<any>}) {\n      assert(sources.state);\n      assert(sources.state.stream);\n      const expected = [[3, 5, 6]];\n      sources.state.stream.addListener({\n        next(x) {\n          assert.deepEqual(x, expected.shift());\n          called = true;\n        },\n        error(e) {\n          done(e);\n        },\n        complete() {\n          done('should not complete');\n        },\n      });\n\n      const reducer$ = xs.of(function initReducer(prevState: any): any {\n        return [3, 5, 6];\n      });\n\n      return {\n        state: reducer$,\n      };\n    }\n\n    const wrapped = withState(main);\n    wrapped({});\n    setImmediate(() => {\n      assert.strictEqual(called, true);\n      done();\n    });\n  });",
            "file": "withState.ts",
            "skipped": false,
            "dir": "state/test"
        },
        {
            "name": "calls done.fail upon failure if present",
            "suites": [
                "jasmine support"
            ],
            "updatePoint": {
                "line": 5,
                "column": 45
            },
            "line": 5,
            "code": "  it('calls done.fail upon failure if present', mochaDone => {\n    const done = function() {\n      throw new Error('expected test to fail');\n    };\n\n    (done as any).fail = (err: any) => {\n      mochaDone();\n    };\n\n    const Time = mockTimeSource();\n\n    Time.assertEqual(Time.diagram('-1-'), Time.diagram('-2-'));\n\n    Time.run(done);\n  });",
            "file": "jasmine-support.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "works with @cycle/time",
            "suites": [
                "most"
            ],
            "updatePoint": {
                "line": 9,
                "column": 28
            },
            "line": 9,
            "code": "  it('works with @cycle/time', done => {\n    const Time = mockTimeSource();\n\n    const actual$ = most.of('a').thru(Time.delay(60));\n    const expected$ = Time.diagram(`---(a|)`);\n\n    Time.assertEqual(actual$, expected$);\n    Time.run(done);\n  });",
            "file": "most.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "works with @cycle/time",
            "suites": [
                "rxjs"
            ],
            "updatePoint": {
                "line": 9,
                "column": 28
            },
            "line": 9,
            "code": "  it('works with @cycle/time', done => {\n    const Time = mockTimeSource();\n\n    const actual$ = of('a').pipe(Time.delay(60));\n    const expected$ = Time.diagram(`---(a|)`);\n\n    Time.assertEqual(actual$, expected$);\n    Time.run(done);\n  });",
            "file": "rxjs.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "propagates events passed through operators",
            "suites": [
                "time driver"
            ],
            "updatePoint": {
                "line": 9,
                "column": 48
            },
            "line": 9,
            "code": "  it('propagates events passed through operators', done => {\n    const Time = timeDriver(xs.empty());\n\n    const expected = [1, 2, 3];\n\n    xs.of(1, 2, 3)\n      .compose(Time.delay(1))\n      .addListener({\n        next(n: number) {\n          assert.equal(n, expected.shift());\n        },\n\n        complete() {\n          assert.equal(expected.length, 0);\n\n          done();\n\n          Time.dispose();\n        },\n\n        error: done,\n      });\n  });",
            "file": "time-driver.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "propagates errors",
            "suites": [
                "time driver"
            ],
            "updatePoint": {
                "line": 33,
                "column": 23
            },
            "line": 33,
            "code": "  it('propagates errors', done => {\n    const Time = timeDriver(xs.empty());\n\n    xs.throw(new Error())\n      .compose(Time.debounce(1))\n      .addListener({\n        error(err: Error) {\n          done();\n          Time.dispose();\n        },\n      });\n  });",
            "file": "time-driver.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "can be used to test Cycle apps",
            "suites": [
                "@cycle/time"
            ],
            "updatePoint": {
                "line": 104,
                "column": 36
            },
            "line": 104,
            "code": "  it('can be used to test Cycle apps', done => {\n    function Counter({DOM}: any) {\n      const add$: Stream<number> = DOM.select('.add')\n        .events('click')\n        .mapTo(+1);\n\n      const subtract$: Stream<number> = DOM.select('.subtract')\n        .events('click')\n        .mapTo(-1);\n\n      const change$ = xs.merge(add$, subtract$);\n\n      const add = (a: number, b: number) => a + b;\n\n      const count$ = change$.fold(add, 0);\n\n      return {\n        count$,\n      };\n    }\n\n    const Time = mockTimeSource();\n\n    const addClick = '---x-x-x------x-|';\n    const subtractClick = '-----------x----|';\n\n    const expectedCount = '0--1-2-3---2--3-|';\n\n    const _DOM = mockDOMSource({\n      '.add': {\n        click: Time.diagram(addClick),\n      },\n      '.subtract': {\n        click: Time.diagram(subtractClick),\n      },\n    });\n\n    const counter = Counter({DOM: _DOM});\n\n    Time.assertEqual(counter.count$, Time.diagram(expectedCount));\n\n    Time.run(done);\n  });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "supports custom operators",
            "suites": [
                "@cycle/time"
            ],
            "updatePoint": {
                "line": 148,
                "column": 31
            },
            "line": 148,
            "code": "  it('supports custom operators', done => {\n    const Time = mockTimeSource({interval: 10});\n\n    const input$ = Time.diagram('--1--2--3-------');\n    const expected$ = Time.diagram('---1---2---3----');\n\n    function delayBy(\n      timeSource: TimeSource,\n      delaySelector: (t: any) => number\n    ): Operator {\n      return function delayByOperator<T>(stream: Stream<T>): Stream<T> {\n        return xs.create<T>({\n          start(listener) {\n            const {schedule, currentTime} = timeSource.createOperator<T>();\n\n            stream.addListener({\n              next(t: T) {\n                const delay = delaySelector(t);\n\n                schedule.next(listener, currentTime() + delay, t);\n              },\n\n              error(err: Error) {\n                schedule.error(listener, currentTime(), err);\n              },\n\n              complete() {\n                schedule.complete(listener, currentTime());\n              },\n            });\n          },\n\n          stop() {},\n        });\n      };\n    }\n\n    const actual$ = input$.compose(delayBy(Time, (i: number) => i * 10));\n\n    Time.assertEqual(actual$, expected$);\n\n    Time.run(done);\n  });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "creates streams from ascii diagrams",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".diagram"
            ],
            "updatePoint": {
                "line": 198,
                "column": 49
            },
            "line": 198,
            "code": "          it('creates streams from ascii diagrams', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.diagram(`---1---2---3---|`);\n\n            const expectedValues = [1, 2, 3];\n\n            take(stream, expectedValues.length).subscribe({\n              next(ev: number) {\n                assert.equal(ev, expectedValues.shift());\n              },\n\n              complete: () => done(), // tslint:disable-line\n              error: done,\n            });\n\n            Time.run();\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "schedules errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".diagram"
            ],
            "updatePoint": {
                "line": 217,
                "column": 30
            },
            "line": 217,
            "code": "          it('schedules errors', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.diagram(`---1---2---#`);\n\n            const expectedValues = [1, 2];\n\n            stream.subscribe({\n              next(ev) {\n                assert.equal(ev, expectedValues.shift());\n              },\n\n              complete: () => {},\n              error: error => {\n                assert.equal(expectedValues.length, 0);\n                done();\n              },\n            });\n\n            Time.run();\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "optionally takes an object of values",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".diagram"
            ],
            "updatePoint": {
                "line": 239,
                "column": 50
            },
            "line": 239,
            "code": "          it('optionally takes an object of values', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.diagram(`---A---B---C---|`, {\n              A: {foo: 1},\n              B: {foo: 2},\n              C: {foo: 3},\n            });\n\n            const expectedValues = [{foo: 1}, {foo: 2}, {foo: 3}];\n\n            take(stream, expectedValues.length).subscribe({\n              next(ev: number) {\n                assert.deepEqual(ev, expectedValues.shift());\n              },\n\n              complete: () => done(), // tslint:disable-line\n              error: done,\n            });\n\n            Time.run();\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "handles multiple events in a single frame",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".diagram"
            ],
            "updatePoint": {
                "line": 262,
                "column": 55
            },
            "line": 262,
            "code": "          it('handles multiple events in a single frame', done => {\n            const Time = mockTimeSource();\n\n            const a = Time.diagram('---a---');\n            const b = Time.diagram('---b---');\n            const expected = Time.diagram('---(ab)---');\n\n            Time.assertEqual((library.lib as any).merge(a, b), expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "starts new diagrams at the current scheduler time",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".diagram"
            ],
            "updatePoint": {
                "line": 274,
                "column": 63
            },
            "line": 274,
            "code": "          it('starts new diagrams at the current scheduler time', done => {\n            const Time = mockTimeSource();\n\n            const a = flatMap(Time.diagram('---a---'), () =>\n              Time.diagram('---b---')\n            );\n            const expected = Time.diagram('------b---');\n\n            Time.assertEqual(a, expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "allows testing via marble diagrams",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 289,
                "column": 48
            },
            "line": 289,
            "code": "          it('allows testing via marble diagrams', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram(`---1---2---3---|`);\n\n            const value = map(input, (i: number) => i * 2);\n\n            const expected = Time.diagram(`---2---4---6---|`);\n\n            Time.assertEqual(value, expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "fails when actual differs from expected",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 303,
                "column": 53
            },
            "line": 303,
            "code": "          it('fails when actual differs from expected', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram(`---1---2---3---|`);\n\n            const expected = Time.diagram(`---2---4---5---|`);\n\n            const value = map(input, (i: number) => i * 2);\n\n            const complete = (err: any) => {\n              if (err) {\n                const lines = err.message\n                  .split(/\\s+/)\n                  .filter((a: string) => a.length > 0);\n\n                assert(\n                  [\n                    'Expected',\n                    '---2---4---5---|',\n                    'Got',\n                    '---2---4---6---|',\n                  ].every(expectedLine => lines.indexOf(expectedLine) !== -1),\n                  err.message\n                );\n\n                done();\n              } else {\n                throw new Error('expected test to fail');\n              }\n            };\n\n            Time.assertEqual(value, expected);\n\n            Time.run(complete);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "stringifies objects",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 339,
                "column": 33
            },
            "line": 339,
            "code": "          it('stringifies objects', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram(`---1---2---3---|`);\n\n            const expected = Time.diagram(`---a-------b---|`, {\n              a: {a: 1},\n              b: {a: 2},\n            });\n\n            const complete = (err: any) => {\n              if (err) {\n                const lines = err.message\n                  .split(/\\s+/)\n                  .filter((a: string) => a.length > 0);\n\n                assert(\n                  [\n                    'Expected',\n                    '---{\"a\":1}-------{\"a\":2}---|',\n                    'Got',\n                    '---1---2---3---|',\n                  ].every(expectedLine => lines.indexOf(expectedLine) !== -1)\n                );\n\n                done();\n              } else {\n                throw new Error('expected test to fail');\n              }\n            };\n\n            Time.assertEqual(input, expected);\n\n            Time.run(complete);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "prints primitive values",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 375,
                "column": 37
            },
            "line": 375,
            "code": "          it('prints primitive values', done => {\n            // most's 'merge' operator seems to be broken with Time.diagram() :\n            // it throws \"cannot read property 'dispose' of undefined (on MergeSink.prototype.end)\"\n            if (library.name === 'most') {\n              done();\n              return;\n            }\n            const Time = mockTimeSource();\n\n            const input = (library.lib as any).merge(\n              library.adapt(xs.of(undefined)),\n              library.adapt(xs.of(null)),\n              Time.diagram('1-2-3x')\n            );\n\n            const expected = Time.diagram(`---(ab)-(cd)---|`, {\n              a: 'string',\n              b: 42,\n              c: null,\n              d: undefined,\n            });\n\n            const complete = (err: any) => {\n              if (err) {\n                const lines = err.message\n                  .split(/\\s+/)\n                  .filter((a: string) => a.length > 0);\n\n                assert(\n                  [\n                    'Expected',\n                    '---(string42)-(nullundefined)---|',\n                    'Got',\n                    '(undefinednull1)-2-3x',\n                  ].every(expectedLine => lines.indexOf(expectedLine) !== -1)\n                );\n\n                done();\n              } else {\n                throw new Error('expected test to fail');\n              }\n            };\n\n            Time.assertEqual(input, expected);\n\n            Time.run(complete);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "handles errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 423,
                "column": 28
            },
            "line": 423,
            "code": "          it('handles errors', done => {\n            const Time = mockTimeSource();\n\n            const stream = xs.throw(new Error('Test!'));\n            const expected = '#';\n\n            Time.assertEqual(stream, Time.diagram(expected));\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "compares objects using deep equality by default",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual"
            ],
            "updatePoint": {
                "line": 434,
                "column": 61
            },
            "line": 434,
            "code": "          it('compares objects using deep equality by default', done => {\n            const Time = mockTimeSource();\n\n            const actual = Time.diagram(`---A---B---C---|`, {\n              A: {foo: 1},\n              B: {foo: 2},\n              C: {foo: 3},\n            });\n\n            const expected = Time.diagram(`---X---Y---Z---|`, {\n              X: {foo: 1},\n              Y: {foo: 2},\n              Z: {foo: 3},\n            });\n\n            Time.assertEqual(actual, expected);\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "passes",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 454,
                "column": 22
            },
            "line": 454,
            "code": "            it('passes', done => {\n              const Time = mockTimeSource();\n\n              const actual$ = Time.diagram(`---A---B---C---|`, {\n                A: {foo: 1, bar: 2},\n                B: {foo: 2, bar: 4},\n                C: {foo: 3, bar: 6},\n              });\n\n              const expected$ = Time.diagram(`---X---Y---Z---|`, {\n                X: {foo: 1, bar: 3},\n                Y: {foo: 2, bar: 4},\n                Z: {foo: 3, bar: 6},\n              });\n\n              function comparator(actual: any, expected: any) {\n                return actual.foo === expected.foo;\n              }\n\n              Time.assertEqual(actual$, expected$, comparator);\n              Time.run(done);\n            });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "fails",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 477,
                "column": 21
            },
            "line": 477,
            "code": "            it('fails', done => {\n              const Time = mockTimeSource();\n\n              const actual$ = Time.diagram(`---A---B---C---|`, {\n                A: {foo: 1, bar: 2},\n                B: {foo: 2, bar: 4},\n                C: {foo: 3, bar: 6},\n              });\n\n              const expected$ = Time.diagram(`---X---Y---Z---|`, {\n                X: {foo: 5, bar: 3},\n                Y: {foo: 2, bar: 4},\n                Z: {foo: 3, bar: 6},\n              });\n\n              function comparator(actual: any, expected: any) {\n                return actual.foo === expected.foo;\n              }\n\n              Time.assertEqual(actual$, expected$, comparator);\n\n              Time.run(err => {\n                if (!err) {\n                  done(new Error('expected test to fail'));\n                } else {\n                  done();\n                }\n              });\n            });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "logs errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 507,
                "column": 27
            },
            "line": 507,
            "code": "            it('logs errors', done => {\n              const Time = mockTimeSource();\n\n              const actual$ = Time.diagram(`---A---B---C---|`, {\n                A: {foo: 1, bar: 2},\n                B: {foo: 2, bar: 4},\n                C: {foo: 3, bar: 6},\n              });\n\n              const expected$ = Time.diagram(`---X---Y---Z---|`, {\n                X: {foo: 5, bar: 3},\n                Y: {foo: 2, bar: 4},\n                Z: {foo: 3, bar: 6},\n              });\n\n              function comparator(actual: any, expected: any) {\n                if (actual.foo !== expected.foo) {\n                  throw new Error('Something went wrong');\n                }\n              }\n\n              Time.assertEqual(actual$, expected$, comparator);\n\n              Time.run((err: any) => {\n                if (!err) {\n                  done(new Error('expected test to fail'));\n                }\n\n                assert(\n                  err.message.indexOf('Something went wrong') !== -1,\n                  [\n                    'Expected failure message to include error, did not:',\n                    err.message,\n                    'to include:',\n                    'Something went wrong',\n                  ].join('\\n\\n')\n                );\n\n                done();\n              });\n            });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "logs unexpected errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 550,
                "column": 36
            },
            "line": 550,
            "code": "          it('logs unexpected errors', done => {\n            const Time = mockTimeSource();\n\n            const input$ = Time.diagram(`---A---B---C---|`);\n\n            const expectedError = 'Something went unexpectedly wrong!';\n\n            function transformation(character: string) {\n              if (character === 'A') {\n                return 'X';\n              }\n\n              if (character === 'B') {\n                throw new Error(expectedError);\n              }\n            }\n\n            const actual$ = map(input$, transformation);\n\n            const expected$ = Time.diagram(`---X---Y---Z---|`);\n\n            Time.assertEqual(actual$, expected$);\n            Time.run((err: any) => {\n              if (!err) {\n                done(new Error('expected test to fail'));\n              }\n\n              assert(\n                err.message.indexOf(expectedError) !== -1,\n                [\n                  'Expected failure message to include error, did not:',\n                  err.message,\n                  'to include:',\n                  expectedError,\n                ].join('\\n\\n')\n              );\n\n              done();\n            });\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "handles infinite streams",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 591,
                "column": 38
            },
            "line": 591,
            "code": "          it('handles infinite streams', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram('---1---2---3---');\n            const actual = map(input, (i: number) => i * 2);\n            const expected = Time.diagram('---2---4---6---');\n\n            Time.assertEqual(actual, expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "handles infinite streams that have failures",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 603,
                "column": 57
            },
            "line": 603,
            "code": "          it('handles infinite streams that have failures', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram('---1---2---3---');\n            const actual = map(input, (i: number) => i * 2);\n            const expected = Time.diagram('---2---7---6---');\n\n            Time.assertEqual(actual, expected);\n\n            Time.run(err => {\n              if (!err) {\n                return done(new Error('expected test to fail'));\n              }\n\n              done();\n            });\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "displays simultaneous events correctly",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".assertEqual",
                "custom equality functions"
            ],
            "updatePoint": {
                "line": 621,
                "column": 52
            },
            "line": 621,
            "code": "          it('displays simultaneous events correctly', done => {\n            const Time = mockTimeSource();\n\n            const input = `---(11)---(22)---(33)---|`;\n            const expected = `---(11)---(22)---(34)---|`;\n\n            const complete = (err: any) => {\n              if (err) {\n                const lines = err.message\n                  .split(/\\s+/)\n                  .filter((a: string) => a.length > 0);\n\n                assert(\n                  ['Expected', expected, 'Got', input].every(\n                    expectedLine => lines.indexOf(expectedLine) !== -1\n                  )\n                );\n\n                done();\n              } else {\n                throw new Error('expected test to fail');\n              }\n            };\n\n            Time.assertEqual(Time.diagram(input), Time.diagram(expected));\n\n            Time.run(complete);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "creates a stream that emits every period ms",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".periodic"
            ],
            "updatePoint": {
                "line": 652,
                "column": 57
            },
            "line": 652,
            "code": "          it('creates a stream that emits every period ms', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.periodic(80);\n\n            const expected = Time.diagram(`----0---1---2---3---4---`);\n\n            Time.assertEqual(stream, expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "delays events by the given period",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".delay"
            ],
            "updatePoint": {
                "line": 666,
                "column": 47
            },
            "line": 666,
            "code": "          it('delays events by the given period', done => {\n            const Time = mockTimeSource();\n\n            const input = Time.diagram(`---1---2---3---|`) as any;\n\n            const expected = Time.diagram(`------1---2---3---|`);\n\n            const value = compose(\n              input,\n              Time.delay(60)\n            );\n\n            Time.assertEqual(value, expected);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "propagates errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".delay"
            ],
            "updatePoint": {
                "line": 683,
                "column": 31
            },
            "line": 683,
            "code": "          it('propagates errors', done => {\n            const Time = mockTimeSource();\n\n            const stream = compose(\n              xs.throw(new Error('Test!')),\n              Time.delay(60)\n            );\n            const expected = '---#';\n\n            Time.assertEqual(stream, Time.diagram(expected));\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "unsubscribes",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".delay"
            ],
            "updatePoint": {
                "line": 697,
                "column": 26
            },
            "line": 697,
            "code": "          it('unsubscribes', done => {\n            const Time = timeDriver(xs.empty());\n            testUnsubscription(Time, Time.delay(0), done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "delays events until the period has passed",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".debounce"
            ],
            "updatePoint": {
                "line": 704,
                "column": 55
            },
            "line": 704,
            "code": "          it('delays events until the period has passed', done => {\n            const Time = mockTimeSource();\n\n            const input = `--1----2-3----|`;\n            const expected = `-----1------3-|`;\n\n            const stream = compose(\n              Time.diagram(input),\n              Time.debounce(60)\n            );\n            const expectedStream = Time.diagram(expected);\n\n            Time.assertEqual(stream, expectedStream);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "propagates errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".debounce"
            ],
            "updatePoint": {
                "line": 721,
                "column": 31
            },
            "line": 721,
            "code": "          it('propagates errors', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.diagram('---1-2---3-#');\n            const expected = Time.diagram('--------2--#');\n\n            Time.assertEqual(\n              compose(\n                stream,\n                Time.debounce(60)\n              ),\n              expected\n            );\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "unsubscribes",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".debounce"
            ],
            "updatePoint": {
                "line": 738,
                "column": 26
            },
            "line": 738,
            "code": "          it('unsubscribes', done => {\n            const Time = timeDriver(xs.empty());\n            testUnsubscription(Time, Time.debounce(0), done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "only allows one event per period",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttle"
            ],
            "updatePoint": {
                "line": 745,
                "column": 46
            },
            "line": 745,
            "code": "          it('only allows one event per period', done => {\n            const Time = mockTimeSource();\n\n            const input = `--1-2-----3--4-5---6-|`;\n            const expected = `--1-------3----5---6-|`;\n            const stream = compose(\n              Time.diagram(input),\n              Time.throttle(60)\n            );\n            const expectedStream = Time.diagram(expected);\n\n            Time.assertEqual(stream, expectedStream);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "propagates errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttle"
            ],
            "updatePoint": {
                "line": 761,
                "column": 31
            },
            "line": 761,
            "code": "          it('propagates errors', done => {\n            const Time = mockTimeSource();\n\n            const stream = Time.diagram('---1-2---3-#');\n            const expected = Time.diagram('---1-----3-#');\n\n            Time.assertEqual(\n              compose(\n                stream,\n                Time.throttle(60)\n              ),\n              expected\n            );\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "fires an event before completing",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttle",
                "with a synchronous stream"
            ],
            "updatePoint": {
                "line": 779,
                "column": 48
            },
            "line": 779,
            "code": "            it('fires an event before completing', done => {\n              const Time = mockTimeSource();\n\n              const stream = library.adapt(xs.from([1, 2, 3]));\n              const expected = Time.diagram('(1|)');\n\n              Time.assertEqual(\n                compose(\n                  stream,\n                  Time.throttle(60)\n                ),\n                expected\n              );\n\n              Time.run(done);\n            });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "unsubscribes",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttle",
                "with a synchronous stream"
            ],
            "updatePoint": {
                "line": 797,
                "column": 26
            },
            "line": 797,
            "code": "          it('unsubscribes', done => {\n            const Time = timeDriver(xs.empty());\n            testUnsubscription(Time, Time.throttle(0), done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "provides a stream of frames for animations",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".animationFrames"
            ],
            "updatePoint": {
                "line": 804,
                "column": 56
            },
            "line": 804,
            "code": "          it('provides a stream of frames for animations', done => {\n            const Time = mockTimeSource({interval: 8});\n\n            const frames = [0, 1, 2].map(i => ({\n              time: i * 16,\n              delta: 16,\n              normalizedDelta: 1,\n            }));\n\n            const actual$ = Time.animationFrames();\n            const expected$ = Time.diagram(`--0-1-2`, frames);\n\n            Time.assertEqual(actual$, expected$);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "throttles a stream using animationFrames",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttleAnimation"
            ],
            "updatePoint": {
                "line": 823,
                "column": 54
            },
            "line": 823,
            "code": "          it('throttles a stream using animationFrames', done => {\n            const Time = mockTimeSource({interval: 8});\n\n            const noisy$ = Time.diagram(`-123456----`);\n            const actual$ = compose(\n              noisy$,\n              Time.throttleAnimation\n            );\n            const expected$ = Time.diagram(`--2-4-6----`);\n\n            Time.assertEqual(actual$, expected$);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "unsubscribes",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".throttleAnimation"
            ],
            "updatePoint": {
                "line": 838,
                "column": 26
            },
            "line": 838,
            "code": "          it('unsubscribes', done => {\n            const Time = timeDriver(xs.empty());\n            testUnsubscription(Time, Time.throttleAnimation, done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "records a stream into an array of entries",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".record"
            ],
            "updatePoint": {
                "line": 845,
                "column": 55
            },
            "line": 845,
            "code": "          it('records a stream into an array of entries', done => {\n            const Time = mockTimeSource();\n\n            const expectedNextEntry = {type: 'next', time: 60, value: 'a'};\n            const expectedCompletionEntry = {type: 'complete', time: 140};\n\n            const input$ = Time.diagram(`---a---|`);\n\n            const actual$ = compose(\n              input$,\n              Time.record\n            );\n            const expected$ = Time.diagram(`x--y---(z|)`, {\n              x: [],\n              y: [expectedNextEntry],\n              z: [expectedNextEntry, expectedCompletionEntry],\n            });\n\n            Time.assertEqual(actual$, expected$);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "records errors",
            "suites": [
                "@cycle/time",
                "mockTimeSource",
                ".record"
            ],
            "updatePoint": {
                "line": 868,
                "column": 28
            },
            "line": 868,
            "code": "          it('records errors', done => {\n            const Time = mockTimeSource();\n\n            const expectedErrorEntry = {\n              type: 'error',\n              time: 60,\n              error: new Error(`scheduled error`),\n            };\n\n            const input$ = Time.diagram(`---#`);\n\n            const actual$ = compose(\n              input$,\n              Time.record\n            );\n            const expected$ = Time.diagram(`x--(y|)`, {\n              x: [],\n              y: [expectedErrorEntry],\n            });\n\n            Time.assertEqual(actual$, expected$);\n\n            Time.run(done);\n          });",
            "file": "time.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "emits the given values immediately",
            "suites": [
                "xstream",
                "of"
            ],
            "updatePoint": {
                "line": 11,
                "column": 42
            },
            "line": 11,
            "code": "    it('emits the given values immediately', done => {\n      const Time = mockTimeSource();\n\n      Time.assertEqual(xs.of('A'), Time.diagram('(A|)'));\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "applies a function to each item in the stream",
            "suites": [
                "xstream",
                "map"
            ],
            "updatePoint": {
                "line": 21,
                "column": 53
            },
            "line": 21,
            "code": "    it('applies a function to each item in the stream', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--1--2--3--|');\n\n      const actual = input.map(i => i * 2);\n\n      const expected = Time.diagram('--2--4--6--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "replaces each occurence with the given value",
            "suites": [
                "xstream",
                "mapTo"
            ],
            "updatePoint": {
                "line": 37,
                "column": 52
            },
            "line": 37,
            "code": "    it('replaces each occurence with the given value', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--1--2--3--|');\n\n      const actual = input.mapTo(7);\n\n      const expected = Time.diagram('--7--7--7--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "merges two streams",
            "suites": [
                "xstream",
                "merge"
            ],
            "updatePoint": {
                "line": 53,
                "column": 26
            },
            "line": 53,
            "code": "    it('merges two streams', done => {\n      const Time = mockTimeSource();\n\n      const A = Time.diagram('-----1-----1--|');\n      const B = Time.diagram('--2-----2-----|');\n\n      const actual = xs.merge(A, B);\n\n      const expected = Time.diagram('--2--1--2--1--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "combines two streams",
            "suites": [
                "xstream",
                "combine"
            ],
            "updatePoint": {
                "line": 70,
                "column": 28
            },
            "line": 70,
            "code": "    it('combines two streams', done => {\n      const Time = mockTimeSource();\n\n      const A = Time.diagram('0-1-----3-----|');\n      const B = Time.diagram('0---2------5--|');\n\n      const actual = xs.combine(A, B).map(([a, b]) => a + b);\n\n      const expected = Time.diagram('0-1-3---5--8--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "only allows events that pass the given conditional",
            "suites": [
                "xstream",
                "filter"
            ],
            "updatePoint": {
                "line": 87,
                "column": 58
            },
            "line": 87,
            "code": "    it('only allows events that pass the given conditional', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--1--2--3--4--5--6--|');\n\n      const actual = input.filter(i => i % 2 === 0);\n\n      const expected = Time.diagram('-----2-----4-----6--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "takes the first n items",
            "suites": [
                "xstream",
                "take"
            ],
            "updatePoint": {
                "line": 103,
                "column": 31
            },
            "line": 103,
            "code": "    it('takes the first n items', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--1--2--3--4--5--6--|');\n\n      const actual = input.take(3);\n\n      const expected = Time.diagram('--1--2--(3|)');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "drops the first n items",
            "suites": [
                "xstream",
                "drop"
            ],
            "updatePoint": {
                "line": 119,
                "column": 31
            },
            "line": 119,
            "code": "    it('drops the first n items', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--1--2--3--4--5--6--|');\n\n      const actual = input.drop(3);\n\n      const expected = Time.diagram('-----------4--5--6--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "returns the last item after the stream completes",
            "suites": [
                "xstream",
                "last"
            ],
            "updatePoint": {
                "line": 135,
                "column": 56
            },
            "line": 135,
            "code": "    it('returns the last item after the stream completes', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('--a--b--c--|');\n\n      const actual = input.last();\n\n      const expected = Time.diagram('-----------(c|)');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "prepends a starting value",
            "suites": [
                "xstream",
                "startWith"
            ],
            "updatePoint": {
                "line": 151,
                "column": 33
            },
            "line": 151,
            "code": "    it('prepends a starting value', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('---1--2--3--|');\n\n      const actual = input.startWith(0);\n\n      const expected = Time.diagram('0--1--2--3--|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "ends the stream when the given stream emits",
            "suites": [
                "xstream",
                "endWhen"
            ],
            "updatePoint": {
                "line": 167,
                "column": 51
            },
            "line": 167,
            "code": "    it('ends the stream when the given stream emits', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('---1--2--3--4--5--6-|');\n      const endWhen = Time.diagram('-----------x--------|');\n\n      const actual = input.endWhen(endWhen);\n\n      const expected = Time.diagram('---1--2--3-|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "accumulates a value from a seed",
            "suites": [
                "xstream",
                "fold"
            ],
            "updatePoint": {
                "line": 184,
                "column": 39
            },
            "line": 184,
            "code": "    it('accumulates a value from a seed', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('---1--1--1--1--1--1-|');\n\n      const actual = input.fold((acc, val) => acc + val, 0);\n\n      const expected = Time.diagram('0--1--2--3--4--5--6-|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "replaces the stream with another stream following an error",
            "suites": [
                "xstream",
                "replaceError"
            ],
            "updatePoint": {
                "line": 200,
                "column": 66
            },
            "line": 200,
            "code": "    it('replaces the stream with another stream following an error', done => {\n      const Time = mockTimeSource();\n\n      const input = Time.diagram('---1--2--3--#');\n      const replace = Time.diagram('---------------7-|');\n\n      const actual = input.replaceError(() => replace);\n\n      const expected = Time.diagram('---1--2--3-----7-|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "turns a stream of streams into a flat stream",
            "suites": [
                "xstream",
                "flatten"
            ],
            "updatePoint": {
                "line": 217,
                "column": 52
            },
            "line": 217,
            "code": "    it('turns a stream of streams into a flat stream', done => {\n      const Time = mockTimeSource();\n\n      const A = Time.diagram('--1--1--1--1--1--|');\n      const B = Time.diagram('---2--2---2--2--2|');\n\n      const input = Time.diagram('-A-------B-------|', {A, B});\n\n      const actual = input.flatten();\n\n      const expected = Time.diagram('--1--1--1-2--2--2|');\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        },
        {
            "name": "creates a circular dependency",
            "suites": [
                "xstream",
                "imitate"
            ],
            "updatePoint": {
                "line": 236,
                "column": 37
            },
            "line": 236,
            "code": "    it('creates a circular dependency', done => {\n      const Time = mockTimeSource();\n\n      const proxy = xs.create();\n\n      const input = Time.diagram('--a--b--c|');\n\n      const actual = proxy;\n\n      const expected = Time.diagram('--a--b--c|');\n\n      proxy.imitate(input);\n\n      Time.assertEqual(actual, expected);\n\n      Time.run(done);\n    });",
            "file": "xstream.ts",
            "skipped": false,
            "dir": "time/test"
        }
    ],
    "badge": "cyclejs__cyclejs.svg"
}