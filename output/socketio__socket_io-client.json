{"repo":"socketio/socket.io-client","url":"https://github.com/socketio/socket.io-client","branch":"master","configs":[{"package":"socket.io-client","lang":"ts","dir":"test","framework":"mocha","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should connect to localhost","suites":["connection"],"updatePoint":{"line":11,"column":33},"line":11,"code":"  it(\"should connect to localhost\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.emit(\"hi\");\n    socket.on(\"hi\", (data) => {\n      socket.disconnect();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not connect when autoConnect option set to false","suites":["connection"],"updatePoint":{"line":20,"column":61},"line":20,"code":"  it(\"should not connect when autoConnect option set to false\", () => {\n    const socket = io({ forceNew: true, autoConnect: false });\n    expect(socket.io.engine).to.not.be.ok();\n    socket.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with same path","suites":["connection"],"updatePoint":{"line":26,"column":49},"line":26,"code":"  it(\"should start two connections with same path\", () => {\n    const s1 = io(\"/\");\n    const s2 = io(\"/\");\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with same path and different querystrings","suites":["connection"],"updatePoint":{"line":35,"column":76},"line":35,"code":"  it(\"should start two connections with same path and different querystrings\", () => {\n    const s1 = io(\"/?woot\");\n    const s2 = io(\"/\");\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start two connections with different paths","suites":["connection"],"updatePoint":{"line":44,"column":55},"line":44,"code":"  it(\"should start two connections with different paths\", () => {\n    const s1 = io(\"/\", { path: \"/foo\" });\n    const s2 = io(\"/\", { path: \"/bar\" });\n\n    expect(s1.io).to.not.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should start a single connection with different namespaces","suites":["connection"],"updatePoint":{"line":53,"column":64},"line":53,"code":"  it(\"should start a single connection with different namespaces\", () => {\n    const opts = {};\n    const s1 = io(\"/foo\", opts);\n    const s2 = io(\"/bar\", opts);\n\n    expect(s1.io).to.be(s2.io);\n    s1.disconnect();\n    s2.disconnect();\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should work with acks","suites":["connection"],"updatePoint":{"line":63,"column":27},"line":63,"code":"  it(\"should work with acks\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.emit(\"ack\");\n    socket.on(\"ack\", (fn) => {\n      fn(5, { test: true });\n    });\n    socket.on(\"got it\", () => {\n      socket.disconnect();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should receive date with ack","suites":["connection"],"updatePoint":{"line":75,"column":34},"line":75,"code":"  it(\"should receive date with ack\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.emit(\"getAckDate\", { test: true }, (data) => {\n      expect(data).to.be.a(\"string\");\n      socket.disconnect();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should work with false","suites":["connection"],"updatePoint":{"line":84,"column":28},"line":84,"code":"  it(\"should work with false\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.emit(\"false\");\n    socket.on(\"false\", (f) => {\n      expect(f).to.be(false);\n      socket.disconnect();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should receive utf8 multibyte characters","suites":["connection"],"updatePoint":{"line":94,"column":46},"line":94,"code":"  it(\"should receive utf8 multibyte characters\", (done) => {\n    const correct = [\n      \"てすと\",\n      \"Я Б Г Д Ж Й\",\n      \"Ä ä Ü ü ß\",\n      \"utf8 — string\",\n      \"utf8 — string\",\n    ];\n\n    const socket = io({ forceNew: true });\n    let i = 0;\n    socket.on(\"takeUtf8\", (data) => {\n      expect(data).to.be(correct[i]);\n      i++;\n      if (i === correct.length) {\n        socket.disconnect();\n        done();\n      }\n    });\n    socket.emit(\"getUtf8\");\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should connect to a namespace after connection established","suites":["connection"],"updatePoint":{"line":116,"column":64},"line":116,"code":"  it(\"should connect to a namespace after connection established\", (done) => {\n    const manager = new Manager();\n    const socket = manager.socket(\"/\");\n    socket.on(\"connect\", () => {\n      const foo = manager.socket(\"/foo\");\n      foo.on(\"connect\", () => {\n        foo.close();\n        socket.close();\n        manager._close();\n        done();\n      });\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should open a new namespace after connection gets closed","suites":["connection"],"updatePoint":{"line":130,"column":62},"line":130,"code":"  it(\"should open a new namespace after connection gets closed\", (done) => {\n    const manager = new Manager();\n    const socket = manager.socket(\"/\");\n    socket\n      .on(\"connect\", () => {\n        socket.disconnect();\n      })\n      .on(\"disconnect\", () => {\n        const foo = manager.socket(\"/foo\");\n        foo.on(\"connect\", () => {\n          foo.disconnect();\n          manager._close();\n          done();\n        });\n      });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect by default","suites":["connection"],"updatePoint":{"line":147,"column":33},"line":147,"code":"  it(\"should reconnect by default\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.io.on(\"reconnect\", () => {\n      socket.disconnect();\n      done();\n    });\n\n    setTimeout(() => {\n      socket.io.engine.close();\n    }, 500);\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect manually","suites":["connection"],"updatePoint":{"line":159,"column":31},"line":159,"code":"  it(\"should reconnect manually\", (done) => {\n    const socket = io({ forceNew: true });\n    socket\n      .once(\"connect\", () => {\n        socket.disconnect();\n      })\n      .once(\"disconnect\", () => {\n        socket.once(\"connect\", () => {\n          socket.disconnect();\n          done();\n        });\n        socket.connect();\n      });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect automatically after reconnecting manually","suites":["connection"],"updatePoint":{"line":174,"column":64},"line":174,"code":"  it(\"should reconnect automatically after reconnecting manually\", (done) => {\n    const socket = io({ forceNew: true });\n    socket\n      .once(\"connect\", () => {\n        socket.disconnect();\n      })\n      .once(\"disconnect\", () => {\n        socket.io.on(\"reconnect\", () => {\n          socket.disconnect();\n          done();\n        });\n        socket.connect();\n        setTimeout(() => {\n          socket.io.engine.close();\n        }, 500);\n      });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should attempt reconnects after a failed reconnect","suites":["connection"],"updatePoint":{"line":192,"column":56},"line":192,"code":"  it(\"should attempt reconnects after a failed reconnect\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      timeout: 0,\n      reconnectionAttempts: 2,\n      reconnectionDelay: 10,\n    });\n    const socket = manager.socket(\"/timeout\");\n    manager.once(\"reconnect_failed\", () => {\n      let reconnects = 0;\n      const reconnectCb = () => {\n        reconnects++;\n      };\n\n      manager.on(\"reconnect_attempt\", reconnectCb);\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.close();\n        manager._close();\n        done();\n      });\n      socket.connect();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"reconnect delay should increase every time","suites":["connection"],"updatePoint":{"line":217,"column":48},"line":217,"code":"  it(\"reconnect delay should increase every time\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      timeout: 0,\n      reconnectionAttempts: 3,\n      reconnectionDelay: 100,\n      randomizationFactor: 0.2,\n    });\n    const socket = manager.socket(\"/timeout\");\n    let reconnects = 0;\n    let increasingDelay = true;\n    let startTime;\n    let prevDelay = 0;\n\n    manager.on(\"error\", () => {\n      startTime = new Date().getTime();\n    });\n    manager.on(\"reconnect_attempt\", () => {\n      reconnects++;\n      const currentTime = new Date().getTime();\n      const delay = currentTime - startTime;\n      if (delay <= prevDelay) {\n        increasingDelay = false;\n      }\n      prevDelay = delay;\n    });\n\n    manager.on(\"reconnect_failed\", () => {\n      expect(reconnects).to.be(3);\n      expect(increasingDelay).to.be.ok();\n      socket.close();\n      manager._close();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not reconnect when force closed","suites":["connection"],"updatePoint":{"line":253,"column":44},"line":253,"code":"  it(\"should not reconnect when force closed\", (done) => {\n    const socket = io(\"/invalid\", {\n      forceNew: true,\n      timeout: 0,\n      reconnectionDelay: 10,\n    });\n    socket.io.once(\"error\", () => {\n      socket.io.on(\"reconnect_attempt\", () => {\n        expect().fail();\n      });\n      socket.disconnect();\n      // set a timeout to let reconnection possibly fire\n      setTimeout(() => {\n        done();\n      }, 500);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting when force closed","suites":["connection"],"updatePoint":{"line":271,"column":48},"line":271,"code":"  it(\"should stop reconnecting when force closed\", (done) => {\n    const socket = io(\"/invalid\", {\n      forceNew: true,\n      timeout: 0,\n      reconnectionDelay: 10,\n    });\n    socket.io.once(\"reconnect_attempt\", () => {\n      socket.io.on(\"reconnect_attempt\", () => {\n        expect().fail();\n      });\n      socket.disconnect();\n      // set a timeout to let reconnection possibly fire\n      setTimeout(() => {\n        done();\n      }, 500);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should reconnect after stopping reconnection","suites":["connection"],"updatePoint":{"line":289,"column":50},"line":289,"code":"  it(\"should reconnect after stopping reconnection\", (done) => {\n    const socket = io(\"/invalid\", {\n      forceNew: true,\n      timeout: 0,\n      reconnectionDelay: 10,\n    });\n    socket.io.once(\"reconnect_attempt\", () => {\n      socket.io.on(\"reconnect_attempt\", () => {\n        socket.disconnect();\n        done();\n      });\n      socket.disconnect();\n      socket.connect();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop reconnecting on a socket and keep to reconnect on another","suites":["connection"],"updatePoint":{"line":305,"column":75},"line":305,"code":"  it(\"should stop reconnecting on a socket and keep to reconnect on another\", (done) => {\n    const manager = new Manager();\n    const socket1 = manager.socket(\"/\");\n    const socket2 = manager.socket(\"/asd\");\n\n    manager.on(\"reconnect_attempt\", () => {\n      socket1.on(\"connect\", () => {\n        expect().fail();\n      });\n      socket2.on(\"connect\", () => {\n        setTimeout(() => {\n          socket2.disconnect();\n          manager._close();\n          done();\n        }, 500);\n      });\n      socket1.disconnect();\n    });\n\n    setTimeout(() => {\n      manager.engine.close();\n    }, 1000);\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should try to reconnect twice and fail when requested two attempts with immediate timeout and reconnect enabled","suites":["connection"],"updatePoint":{"line":329,"column":117},"line":329,"code":"  it(\"should try to reconnect twice and fail when requested two attempts with immediate timeout and reconnect enabled\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      timeout: 0,\n      reconnectionAttempts: 2,\n      reconnectionDelay: 10,\n    });\n    let socket;\n\n    let reconnects = 0;\n    const reconnectCb = () => {\n      reconnects++;\n    };\n\n    manager.on(\"reconnect_attempt\", reconnectCb);\n    manager.on(\"reconnect_failed\", () => {\n      expect(reconnects).to.be(2);\n      socket.close();\n      manager._close();\n      done();\n    });\n\n    socket = manager.socket(\"/timeout\");\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should fire reconnect_* events on manager","suites":["connection"],"updatePoint":{"line":354,"column":47},"line":354,"code":"  it(\"should fire reconnect_* events on manager\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      timeout: 0,\n      reconnectionAttempts: 2,\n      reconnectionDelay: 10,\n    });\n    const socket = manager.socket(\"/timeout_socket\");\n\n    let reconnects = 0;\n    const reconnectCb = (attempts) => {\n      reconnects++;\n      expect(attempts).to.be(reconnects);\n    };\n\n    manager.on(\"reconnect_attempt\", reconnectCb);\n    manager.on(\"reconnect_failed\", () => {\n      expect(reconnects).to.be(2);\n      socket.close();\n      manager._close();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should fire reconnecting (on manager) with attempts number when reconnecting twice","suites":["connection"],"updatePoint":{"line":378,"column":88},"line":378,"code":"  it(\"should fire reconnecting (on manager) with attempts number when reconnecting twice\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      timeout: 0,\n      reconnectionAttempts: 2,\n      reconnectionDelay: 10,\n    });\n    const socket = manager.socket(\"/timeout_socket\");\n\n    let reconnects = 0;\n    const reconnectCb = (attempts) => {\n      reconnects++;\n      expect(attempts).to.be(reconnects);\n    };\n\n    manager.on(\"reconnect_attempt\", reconnectCb);\n    manager.on(\"reconnect_failed\", () => {\n      expect(reconnects).to.be(2);\n      socket.close();\n      manager._close();\n      done();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect and should form a connection when connecting to correct port with default timeout","suites":["connection"],"updatePoint":{"line":402,"column":115},"line":402,"code":"  it(\"should not try to reconnect and should form a connection when connecting to correct port with default timeout\", (done) => {\n    const manager = new Manager({\n      reconnection: true,\n      reconnectionDelay: 10,\n    });\n    const cb = () => {\n      socket.close();\n      expect().fail();\n    };\n    manager.on(\"reconnect_attempt\", cb);\n\n    var socket = manager.socket(\"/valid\");\n    socket.on(\"connect\", () => {\n      // set a timeout to let reconnection possibly fire\n      setTimeout(() => {\n        socket.close();\n        manager._close();\n        done();\n      }, 1000);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should connect while disconnecting another socket","suites":["connection"],"updatePoint":{"line":424,"column":55},"line":424,"code":"  it(\"should connect while disconnecting another socket\", (done) => {\n    const manager = new Manager();\n    const socket1 = manager.socket(\"/foo\");\n    socket1.on(\"connect\", () => {\n      const socket2 = manager.socket(\"/asd\");\n      socket2.on(\"connect\", done);\n      socket1.disconnect();\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit a connect_error event when reaching a Socket.IO server in v2.x","suites":["connection"],"updatePoint":{"line":434,"column":80},"line":434,"code":"  it(\"should emit a connect_error event when reaching a Socket.IO server in v2.x\", (done) => {\n    const socket = io({\n      autoConnect: false,\n    });\n\n    socket.on(\"connect_error\", () => {\n      done();\n    });\n\n    // @ts-ignore\n    socket.onpacket({\n      nsp: \"/\",\n      type: 0,\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not close the connection when disconnecting a single socket","suites":["connection"],"updatePoint":{"line":450,"column":72},"line":450,"code":"  it(\"should not close the connection when disconnecting a single socket\", (done) => {\n    const manager = new Manager({\n      autoConnect: false,\n    });\n    const socket1 = manager.socket(\"/foo\");\n    const socket2 = manager.socket(\"/asd\");\n\n    socket1.connect();\n    socket1.on(\"connect\", () => {\n      socket2.connect();\n    });\n\n    socket2.on(\"connect\", () => {\n      socket2.on(\"disconnect\", () => {\n        done(new Error(\"should not happen for now\"));\n      });\n      socket1.disconnect();\n      setTimeout(() => {\n        socket2.off(\"disconnect\");\n        manager.on(\"close\", () => {\n          done();\n        });\n        socket2.disconnect();\n      }, 200);\n    });\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should try to reconnect twice and fail when requested two attempts with incorrect address and reconnect enabled","suites":["connection"],"updatePoint":{"line":480,"column":119},"line":480,"code":"    it(\"should try to reconnect twice and fail when requested two attempts with incorrect address and reconnect enabled\", (done) => {\n      const manager = new Manager(\"http://localhost:3940\", {\n        reconnection: true,\n        reconnectionAttempts: 2,\n        reconnectionDelay: 10,\n      });\n      const socket = manager.socket(\"/asd\");\n      let reconnects = 0;\n      const cb = () => {\n        reconnects++;\n      };\n\n      manager.on(\"reconnect_attempt\", cb);\n\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.disconnect();\n        manager._close();\n        done();\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect with incorrect port when reconnection disabled","suites":["connection"],"updatePoint":{"line":502,"column":82},"line":502,"code":"    it(\"should not try to reconnect with incorrect port when reconnection disabled\", (done) => {\n      const manager = new Manager(\"http://localhost:9823\", {\n        reconnection: false,\n      });\n      const cb = () => {\n        socket.close();\n        expect().fail();\n      };\n      manager.on(\"reconnect_attempt\", cb);\n\n      manager.on(\"error\", () => {\n        // set a timeout to let reconnection possibly fire\n        setTimeout(() => {\n          socket.disconnect();\n          manager._close();\n          done();\n        }, 1000);\n      });\n\n      var socket = manager.socket(\"/invalid\");\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should still try to reconnect twice after opening another socket asynchronously","suites":["connection"],"updatePoint":{"line":524,"column":87},"line":524,"code":"    it(\"should still try to reconnect twice after opening another socket asynchronously\", (done) => {\n      const manager = new Manager(\"http://localhost:9823\", {\n        reconnection: true,\n        reconnectionAttempts: 2,\n      });\n      let delay = Math.floor(\n        manager.reconnectionDelay() * manager.randomizationFactor() * 0.5\n      );\n      delay = Math.max(delay, 10);\n\n      let reconnects = 0;\n      const cb = () => {\n        reconnects++;\n      };\n\n      manager.on(\"reconnect_attempt\", cb);\n\n      manager.on(\"reconnect_failed\", () => {\n        expect(reconnects).to.be(2);\n        socket.disconnect();\n        manager._close();\n        done();\n      });\n\n      var socket = manager.socket(\"/room1\");\n\n      setTimeout(() => {\n        manager.socket(\"/room2\");\n      }, delay);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should use overridden setTimeout by default","suites":["connection","reconnect timeout"],"updatePoint":{"line":581,"column":51},"line":581,"code":"    it(\"should use overridden setTimeout by default\", async () => {\n      const clock = FakeTimers.install();\n      const manager = new Manager(options);\n      setupManagerCallbacks(manager);\n\n      // Wait real clock time for the socket to connect before disconnecting it.\n      await clock.tickAsync(options.timeout);\n      await wait(options.timeout);\n      manager.engine.close();\n\n      // Let the clock approach the reconnect delay.\n      await clock.tickAsync(options.reconnectionDelayMax - 1);\n      expect(reconnected).to.be(false);\n\n      await clock.tickAsync(1); // reconnect.\n      expect(reconnected).to.be(true);\n\n      clock.uninstall();\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should use native setTimeout with useNativeSetTimers","suites":["connection","reconnect timeout"],"updatePoint":{"line":601,"column":60},"line":601,"code":"    it(\"should use native setTimeout with useNativeSetTimers\", async () => {\n      options.useNativeTimers = true;\n      const clock = FakeTimers.install();\n      const manager = new Manager(options);\n      setupManagerCallbacks(manager);\n\n      // Wait real clock time for the socket to connect before disconnecting it.\n      await clock.tickAsync(options.timeout);\n      await wait(options.timeout);\n      manager.engine.close();\n\n      // Since the client will not use the overridden timeout function,\n      // advancing the fake clock should not reconnect.\n      await clock.tickAsync(options.reconnectionDelayMax);\n      expect(reconnected).to.be(false);\n      clock.uninstall();\n\n      // Wait reconnectionDelayMax to trigger reconnect.\n      await wait(options.reconnectionDelayMax);\n      expect(reconnected).to.be(true);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit date as string","suites":["connection","reconnect timeout"],"updatePoint":{"line":624,"column":32},"line":624,"code":"  it(\"should emit date as string\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"takeDate\", (data) => {\n      socket.close();\n      expect(data).to.be.a(\"string\");\n      done();\n    });\n    socket.emit(\"getDate\");\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should emit date in object","suites":["connection","reconnect timeout"],"updatePoint":{"line":634,"column":32},"line":634,"code":"  it(\"should emit date in object\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"takeDateObj\", (data) => {\n      socket.close();\n      expect(data).to.be.an(\"object\");\n      expect(data.date).to.be.a(\"string\");\n      done();\n    });\n    socket.emit(\"getDateObj\");\n  });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should get base64 data as a last resort","suites":["connection","reconnect timeout"],"updatePoint":{"line":646,"column":47},"line":646,"code":"    it(\"should get base64 data as a last resort\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"takebin\", (a) => {\n        socket.disconnect();\n        expect(a.base64).to.be(true);\n        expect(a.data).to.eql(\"YXNkZmFzZGY=\");\n        done();\n      });\n      socket.emit(\"getbin\");\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should get binary data (as an ArrayBuffer)","suites":["connection","reconnect timeout"],"updatePoint":{"line":661,"column":50},"line":661,"code":"    it(\"should get binary data (as an ArrayBuffer)\", (done) => {\n      const socket = io({ forceNew: true });\n      if (env.node) {\n        socket.io.engine.binaryType = \"arraybuffer\";\n      }\n      socket.emit(\"doge\");\n      socket.on(\"doge\", (buffer) => {\n        expect(buffer instanceof ArrayBuffer).to.be(true);\n        socket.disconnect();\n        done();\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as an ArrayBuffer)","suites":["connection","reconnect timeout"],"updatePoint":{"line":674,"column":51},"line":674,"code":"    it(\"should send binary data (as an ArrayBuffer)\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"buffack\", () => {\n        socket.disconnect();\n        done();\n      });\n      const buf = base64.decode(\"asdfasdf\");\n      socket.emit(\"buffa\", buf);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as an ArrayBuffer) mixed with json","suites":["connection","reconnect timeout"],"updatePoint":{"line":684,"column":67},"line":684,"code":"    it(\"should send binary data (as an ArrayBuffer) mixed with json\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"jsonbuff-ack\", () => {\n        socket.disconnect();\n        done();\n      });\n      const buf = base64.decode(\"howdy\");\n      socket.emit(\"jsonbuff\", {\n        hello: \"lol\",\n        message: buf,\n        goodbye: \"gotcha\",\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send events with ArrayBuffers in the correct order","suites":["connection","reconnect timeout"],"updatePoint":{"line":698,"column":65},"line":698,"code":"    it(\"should send events with ArrayBuffers in the correct order\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"abuff2-ack\", () => {\n        socket.disconnect();\n        done();\n      });\n      const buf = base64.decode(\"abuff1\");\n      socket.emit(\"abuff1\", buf);\n      socket.emit(\"abuff2\", \"please arrive second\");\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as a Blob)","suites":["connection","reconnect timeout"],"updatePoint":{"line":711,"column":43},"line":711,"code":"    it(\"should send binary data (as a Blob)\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"back\", () => {\n        socket.disconnect();\n        done();\n      });\n      const blob = textBlobBuilder(\"hello world\");\n      socket.emit(\"blob\", blob);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send binary data (as a Blob) mixed with json","suites":["connection","reconnect timeout"],"updatePoint":{"line":721,"column":59},"line":721,"code":"    it(\"should send binary data (as a Blob) mixed with json\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"jsonblob-ack\", () => {\n        socket.disconnect();\n        done();\n      });\n      const blob = textBlobBuilder(\"EEEEEEEEE\");\n      socket.emit(\"jsonblob\", {\n        hello: \"lol\",\n        message: blob,\n        goodbye: \"gotcha\",\n      });\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should send events with Blobs in the correct order","suites":["connection","reconnect timeout"],"updatePoint":{"line":735,"column":58},"line":735,"code":"    it(\"should send events with Blobs in the correct order\", (done) => {\n      const socket = io({ forceNew: true });\n      socket.on(\"blob3-ack\", () => {\n        socket.disconnect();\n        done();\n      });\n      const blob = textBlobBuilder(\"BLOBBLOB\");\n      socket.emit(\"blob1\", blob);\n      socket.emit(\"blob2\", \"second\");\n      socket.emit(\"blob3\", blob);\n    });","file":"connection.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered","suites":["autoRef option"],"updatePoint":{"line":8,"column":45},"line":8,"code":"  it(\"should stop once the timer is triggered\", (done) => {\n    exec(fixture(\"unref.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (even when trying to reconnect)","suites":["autoRef option"],"updatePoint":{"line":12,"column":77},"line":12,"code":"  it(\"should stop once the timer is triggered (even when trying to reconnect)\", (done) => {\n    exec(fixture(\"unref-during-reconnection.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (polling)","suites":["autoRef option"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it(\"should stop once the timer is triggered (polling)\", (done) => {\n    exec(fixture(\"unref-polling-only.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should stop once the timer is triggered (websocket)","suites":["autoRef option"],"updatePoint":{"line":20,"column":57},"line":20,"code":"  it(\"should stop once the timer is triggered (websocket)\", (done) => {\n    exec(fixture(\"unref-websocket-only.ts\"), done);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should not stop with autoUnref set to false","suites":["autoRef option"],"updatePoint":{"line":24,"column":49},"line":24,"code":"  it(\"should not stop with autoUnref set to false\", (done) => {\n    const process = exec(fixture(\"no-unref.ts\"), () => {\n      done(new Error(\"should not happen\"));\n    });\n    setTimeout(() => {\n      process.kill();\n      done();\n    }, 1000);\n  });","file":"node.ts","skipped":false,"dir":"test"},{"name":"should have an accessible socket id equal to the server-side socket id (default namespace)","suites":["socket"],"updatePoint":{"line":12,"column":96},"line":12,"code":"  it(\"should have an accessible socket id equal to the server-side socket id (default namespace)\", (done) => {\n    const socket = io({ forceNew: true });\n\n    socket.emit(\"getId\", (id) => {\n      expect(socket.id).to.be.ok();\n      expect(socket.id).to.be.eql(id);\n      expect(socket.id).to.not.eql(socket.io.engine.id);\n      socket.disconnect();\n      done();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should have an accessible socket id equal to the server-side socket id (custom namespace)","suites":["socket"],"updatePoint":{"line":24,"column":95},"line":24,"code":"  it(\"should have an accessible socket id equal to the server-side socket id (custom namespace)\", (done) => {\n    const socket = io(\"/foo\", { forceNew: true });\n    socket.emit(\"getId\", (id) => {\n      expect(socket.id).to.be.ok();\n      expect(socket.id).to.be.eql(id);\n      expect(socket.id).to.not.eql(socket.io.engine.id);\n      socket.disconnect();\n      done();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"clears socket.id upon disconnection","suites":["socket"],"updatePoint":{"line":35,"column":41},"line":35,"code":"  it(\"clears socket.id upon disconnection\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"connect\", () => {\n      socket.on(\"disconnect\", () => {\n        expect(socket.id).to.not.be.ok();\n        done();\n      });\n\n      socket.disconnect();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"doesn't fire an error event if we force disconnect in opening state","suites":["socket"],"updatePoint":{"line":47,"column":73},"line":47,"code":"  it(\"doesn't fire an error event if we force disconnect in opening state\", (done) => {\n    const socket = io({ forceNew: true, timeout: 100 });\n    socket.disconnect();\n    socket.io.on(\"error\", () => {\n      throw new Error(\"Unexpected\");\n    });\n    setTimeout(() => {\n      done();\n    }, 300);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"fire a connect_error event when the connection cannot be established","suites":["socket"],"updatePoint":{"line":58,"column":74},"line":58,"code":"  it(\"fire a connect_error event when the connection cannot be established\", (done) => {\n    const socket = io(\"http://localhost:9823\", {\n      forceNew: true,\n      timeout: 100,\n    });\n    socket.on(\"connect_error\", () => {\n      socket.close();\n      done();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"doesn't fire a connect_error event when the connection is already established","suites":["socket"],"updatePoint":{"line":69,"column":83},"line":69,"code":"  it(\"doesn't fire a connect_error event when the connection is already established\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"connect\", () => {\n      socket.io.engine.close();\n    });\n    socket.on(\"connect_error\", () => {\n      done(new Error(\"should not happen\"));\n    });\n    setTimeout(() => {\n      socket.close();\n      done();\n    }, 300);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should change socket.id upon reconnection","suites":["socket"],"updatePoint":{"line":83,"column":47},"line":83,"code":"  it(\"should change socket.id upon reconnection\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"connect\", () => {\n      const id = socket.id;\n\n      socket.io.on(\"reconnect_attempt\", () => {\n        expect(socket.id).to.not.be.ok();\n      });\n\n      socket.io.on(\"reconnect\", () => {\n        expect(socket.id).to.not.eql(id);\n        socket.disconnect();\n        done();\n      });\n\n      socket.io.engine.close();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should enable compression by default","suites":["socket"],"updatePoint":{"line":102,"column":42},"line":102,"code":"  it(\"should enable compression by default\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"connect\", () => {\n      socket.io.engine.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(true);\n        socket.disconnect();\n        done();\n      });\n      socket.emit(\"hi\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should disable compression","suites":["socket"],"updatePoint":{"line":114,"column":32},"line":114,"code":"  it(\"should disable compression\", (done) => {\n    const socket = io({ forceNew: true });\n    socket.on(\"connect\", () => {\n      socket.io.engine.once(\"packetCreate\", (packet) => {\n        expect(packet.options.compress).to.be(false);\n        socket.disconnect();\n        done();\n      });\n      socket.compress(false).emit(\"hi\");\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object (default namespace)","suites":["socket","query option"],"updatePoint":{"line":127,"column":51},"line":127,"code":"    it(\"should accept an object (default namespace)\", (done) => {\n      const socket = io(\"/\", { forceNew: true, query: { e: \"f\" } });\n\n      socket.emit(\"getHandshake\", (handshake) => {\n        expect(handshake.query.e).to.be(\"f\");\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept a query string (default namespace)","suites":["socket","query option"],"updatePoint":{"line":137,"column":56},"line":137,"code":"    it(\"should accept a query string (default namespace)\", (done) => {\n      const socket = io(\"/?c=d\", { forceNew: true });\n\n      socket.emit(\"getHandshake\", (handshake) => {\n        expect(handshake.query.c).to.be(\"d\");\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object","suites":["socket","query option"],"updatePoint":{"line":147,"column":31},"line":147,"code":"    it(\"should accept an object\", (done) => {\n      const socket = io(\"/abc\", { forceNew: true, query: { a: \"b\" } });\n\n      socket.on(\"handshake\", (handshake) => {\n        expect(handshake.query.a).to.be(\"b\");\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept a query string","suites":["socket","query option"],"updatePoint":{"line":157,"column":36},"line":157,"code":"    it(\"should accept a query string\", (done) => {\n      const socket = io(\"/abc?b=c&d=e\", { forceNew: true });\n\n      socket.on(\"handshake\", (handshake) => {\n        expect(handshake.query.b).to.be(\"c\");\n        expect(handshake.query.d).to.be(\"e\");\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should properly encode the parameters","suites":["socket","query option"],"updatePoint":{"line":168,"column":45},"line":168,"code":"    it(\"should properly encode the parameters\", (done) => {\n      const socket = io(\"/abc\", { forceNew: true, query: { \"&a\": \"&=?a\" } });\n\n      socket.on(\"handshake\", (handshake) => {\n        expect(handshake.query[\"&a\"]).to.be(\"&=?a\");\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an object","suites":["socket","auth option"],"updatePoint":{"line":180,"column":31},"line":180,"code":"    it(\"should accept an object\", (done) => {\n      const socket = io(\"/abc\", { forceNew: true, auth: { a: \"b\", c: \"d\" } });\n\n      socket.on(\"handshake\", (handshake) => {\n        expect(handshake.auth.a).to.be(\"b\");\n        expect(handshake.auth.c).to.be(\"d\");\n        expect(handshake.query.a).to.be(undefined);\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should accept an function","suites":["socket","auth option"],"updatePoint":{"line":192,"column":33},"line":192,"code":"    it(\"should accept an function\", (done) => {\n      const socket = io(\"/abc\", {\n        forceNew: true,\n        auth: (cb) => cb({ e: \"f\" }),\n      });\n\n      socket.on(\"handshake\", (handshake) => {\n        expect(handshake.auth.e).to.be(\"f\");\n        expect(handshake.query.e).to.be(undefined);\n        socket.disconnect();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should fire an error event on middleware failure from custom namespace","suites":["socket","auth option"],"updatePoint":{"line":207,"column":76},"line":207,"code":"  it(\"should fire an error event on middleware failure from custom namespace\", (done) => {\n    const socket = io(\"/no\", { forceNew: true });\n    socket.on(\"connect_error\", (err) => {\n      expect(err).to.be.an(Error);\n      expect(err.message).to.eql(\"Auth failed (custom namespace)\");\n      socket.disconnect();\n      done();\n    });\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not try to reconnect after a middleware failure","suites":["socket","auth option"],"updatePoint":{"line":217,"column":60},"line":217,"code":"  it(\"should not try to reconnect after a middleware failure\", (done) => {\n    const socket = io(\"/no\", { forceNew: true, reconnectionDelay: 10 });\n\n    let count = 0;\n\n    socket.on(\"connect_error\", () => {\n      count++;\n      // force reconnection\n      socket.io.engine.close();\n    });\n\n    setTimeout(() => {\n      expect(count).to.eql(1);\n      done();\n    }, 100);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should properly disconnect then reconnect","suites":["socket","auth option"],"updatePoint":{"line":234,"column":47},"line":234,"code":"  it(\"should properly disconnect then reconnect\", (done) => {\n    const socket = io(\"/\", { forceNew: true, transports: [\"websocket\"] });\n\n    let count = 0;\n\n    socket.once(\"connect\", () => {\n      socket.disconnect().connect();\n    });\n\n    socket.on(\"disconnect\", () => {\n      count++;\n    });\n\n    setTimeout(() => {\n      expect(count).to.eql(1);\n      success(done, socket);\n    }, 200);\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should throw on reserved event","suites":["socket","auth option"],"updatePoint":{"line":253,"column":36},"line":253,"code":"  it(\"should throw on reserved event\", () => {\n    const socket = io(\"/no\", { forceNew: true });\n\n    expect(() => socket.emit(\"disconnecting\", \"goodbye\")).to.throwException(\n      /\"disconnecting\" is a reserved event name/\n    );\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should emit events in order","suites":["socket","auth option"],"updatePoint":{"line":261,"column":33},"line":261,"code":"  it(\"should emit events in order\", (done) => {\n    const socket = io(\"/\", { autoConnect: false });\n    let i = 0;\n\n    socket.on(\"connect\", () => {\n      socket.emit(\"echo\", \"second\", () => {\n        expect(++i).to.eql(2);\n\n        socket.disconnect();\n        done();\n      });\n    });\n\n    socket.emit(\"echo\", \"first\", () => {\n      expect(++i).to.eql(1);\n    });\n\n    socket.connect();\n  });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should discard a volatile packet when the socket is not connected","suites":["socket","volatile packets"],"updatePoint":{"line":282,"column":73},"line":282,"code":"    it(\"should discard a volatile packet when the socket is not connected\", (done) => {\n      const socket = io({ forceNew: true, autoConnect: false });\n\n      socket.volatile.emit(\"getId\", () => {\n        done(new Error(\"should not happen\"));\n      });\n\n      socket.emit(\"getId\", () => {\n        socket.disconnect();\n        done();\n      });\n\n      socket.connect();\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should discard a volatile packet when the pipe is not ready","suites":["socket","volatile packets"],"updatePoint":{"line":297,"column":67},"line":297,"code":"    it(\"should discard a volatile packet when the pipe is not ready\", (done) => {\n      const socket = io({ forceNew: true });\n\n      socket.on(\"connect\", () => {\n        socket.emit(\"getId\", () => {\n          socket.disconnect();\n          done();\n        });\n\n        socket.volatile.emit(\"getId\", () => {\n          done(new Error(\"should not happen\"));\n        });\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should send a volatile packet when the socket is connected and the pipe is ready","suites":["socket","volatile packets"],"updatePoint":{"line":312,"column":88},"line":312,"code":"    it(\"should send a volatile packet when the socket is connected and the pipe is ready\", (done) => {\n      const socket = io({ forceNew: true });\n\n      const interval = setInterval(() => {\n        socket.volatile.emit(\"getId\", () => {\n          clearInterval(interval);\n          socket.disconnect();\n          done();\n        });\n      }, 200);\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should call listener","suites":["socket","onAny"],"updatePoint":{"line":326,"column":28},"line":326,"code":"    it(\"should call listener\", (done) => {\n      const socket = io(\"/abc\");\n\n      socket.onAny((event, arg1) => {\n        expect(event).to.be(\"handshake\");\n        expect(arg1).to.be.an(Object);\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should prepend listener","suites":["socket","onAny"],"updatePoint":{"line":336,"column":31},"line":336,"code":"    it(\"should prepend listener\", (done) => {\n      const socket = io(\"/abc\");\n\n      let count = 0;\n\n      socket.onAny((event, arg1) => {\n        expect(count).to.be(2);\n        done();\n      });\n\n      socket.prependAny(() => {\n        expect(count++).to.be(1);\n      });\n\n      socket.prependAny(() => {\n        expect(count++).to.be(0);\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should remove listener","suites":["socket","onAny"],"updatePoint":{"line":355,"column":30},"line":355,"code":"    it(\"should remove listener\", (done) => {\n      const socket = io(\"/abc\");\n\n      let count = 0;\n\n      const fail = () => done(new Error(\"fail\"));\n\n      socket.onAny(fail);\n      socket.offAny(fail);\n      expect(socket.listenersAny.length).to.be(0);\n\n      socket.onAny(() => {\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout after the given delay when socket is not connected","suites":["socket","timeout"],"updatePoint":{"line":373,"column":73},"line":373,"code":"    it(\"should timeout after the given delay when socket is not connected\", (done) => {\n      const socket = io(\"/\", {\n        autoConnect: false,\n      });\n\n      socket.timeout(50).emit(\"event\", (err) => {\n        expect(err).to.be.an(Error);\n        expect(socket.sendBuffer).to.be.empty();\n        done();\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout when the server does not acknowledge the event","suites":["socket","timeout"],"updatePoint":{"line":385,"column":69},"line":385,"code":"    it(\"should timeout when the server does not acknowledge the event\", (done) => {\n      const socket = io(\"/\");\n\n      socket.timeout(50).emit(\"unknown\", (err) => {\n        expect(err).to.be.an(Error);\n        success(done, socket);\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should timeout when the server does not acknowledge the event in time","suites":["socket","timeout"],"updatePoint":{"line":394,"column":77},"line":394,"code":"    it(\"should timeout when the server does not acknowledge the event in time\", (done) => {\n      const socket = io(\"/\");\n\n      let count = 0;\n\n      socket.timeout(0).emit(\"echo\", 42, (err) => {\n        expect(err).to.be.an(Error);\n        count++;\n      });\n\n      setTimeout(() => {\n        expect(count).to.eql(1);\n        success(done, socket);\n      }, 200);\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"should not timeout when the server does acknowledge the event","suites":["socket","timeout"],"updatePoint":{"line":410,"column":69},"line":410,"code":"    it(\"should not timeout when the server does acknowledge the event\", (done) => {\n      const socket = io(\"/\");\n\n      socket.timeout(50).emit(\"echo\", 42, (err, value) => {\n        expect(err).to.be(null);\n        expect(value).to.be(42);\n        success(done, socket);\n      });\n    });","file":"socket.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters of reserved events","suites":["typed events","no event map","on"],"updatePoint":{"line":10,"column":73},"line":10,"code":"      it(\"infers correct types for listener parameters of reserved events\", () => {\n        const socket = io();\n        expectType<Socket<DefaultEventsMap, DefaultEventsMap>>(socket);\n\n        expectError(socket.on(\"connect\", (arg) => {}));\n\n        socket.on(\"connect_error\", (err) => {\n          expectType<Error>(err);\n        });\n\n        socket.on(\"disconnect\", (reason) => {\n          expectType<Socket.DisconnectReason>(reason);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events","suites":["typed events","no event map","on"],"updatePoint":{"line":25,"column":62},"line":25,"code":"      it(\"infers 'any' for listener parameters of other events\", () => {\n        const socket = io();\n\n        socket.on(\"random\", (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers 'any' for listener parameters of other events using enums","suites":["typed events","no event map","on"],"updatePoint":{"line":35,"column":74},"line":35,"code":"      it(\"infers 'any' for listener parameters of other events using enums\", () => {\n        const socket = io();\n\n        enum Events {\n          TEST = \"test\",\n        }\n\n        socket.on(\"test\", (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n\n        socket.on(Events.TEST, (a, b, c) => {\n          expectType<any>(a);\n          expectType<any>(b);\n          expectType<any>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts any parameters","suites":["typed events","no event map","emit"],"updatePoint":{"line":57,"column":32},"line":57,"code":"      it(\"accepts any parameters\", () => {\n        const socket = io();\n\n        socket.emit(\"random\", 1, \"2\", [3]);\n        socket.emit(\"no parameters\");\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["typed events","single event map","on"],"updatePoint":{"line":72,"column":54},"line":72,"code":"      it(\"infers correct types for listener parameters\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectType<Socket<BidirectionalEvents, BidirectionalEvents>>(socket);\n\n        socket.on(\"random\", (a, b, c) => {\n          expectType<number>(a);\n          expectType<string>(b);\n          expectType<number[]>(c);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["typed events","single event map","on"],"updatePoint":{"line":84,"column":50},"line":84,"code":"      it(\"does not accept arguments of wrong types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectType<Socket<BidirectionalEvents, BidirectionalEvents>>(socket);\n\n        expectError(socket.on(\"random\"));\n        expectError(socket.on(\"random\", (a, b, c, d) => {}));\n        expectError(socket.on(2, 3));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["typed events","single event map","emit"],"updatePoint":{"line":96,"column":48},"line":96,"code":"      it(\"accepts arguments of the correct types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        socket.emit(\"random\", 1, \"2\", [3]);\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of the wrong types","suites":["typed events","single event map","emit"],"updatePoint":{"line":102,"column":54},"line":102,"code":"      it(\"does not accept arguments of the wrong types\", () => {\n        const socket: Socket<BidirectionalEvents> = io();\n\n        expectError(socket.emit(\"random\"));\n        expectError(socket.emit(\"random\", (a, b, c) => {}));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"infers correct types for listener parameters","suites":["typed events","listen and emit event maps","on"],"updatePoint":{"line":121,"column":54},"line":121,"code":"      it(\"infers correct types for listener parameters\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectType<Socket<ServerToClientEvents, ClientToServerEvents>>(socket);\n\n        socket.on(\"helloFromServer\", (message) => {\n          expectType<string>(message);\n        });\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept emit events","suites":["typed events","listen and emit event maps","on"],"updatePoint":{"line":131,"column":37},"line":131,"code":"      it(\"does not accept emit events\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectType<Socket<ServerToClientEvents, ClientToServerEvents>>(socket);\n\n        expectError(socket.on(\"helloFromClient\", (message) => {}));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"accepts arguments of the correct types","suites":["typed events","listen and emit event maps","emit"],"updatePoint":{"line":141,"column":48},"line":141,"code":"      it(\"accepts arguments of the correct types\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        socket.emit(\"helloFromClient\", \"hi\");\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"does not accept arguments of wrong types","suites":["typed events","listen and emit event maps","emit"],"updatePoint":{"line":147,"column":50},"line":147,"code":"      it(\"does not accept arguments of wrong types\", () => {\n        const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();\n\n        expectError(socket.emit(\"helloFromClient\"));\n        expectError(socket.emit(\"helloFromClient\", 10));\n        expectError(socket.emit(\"helloFromClient\", \"hi\", 10));\n        expectError(socket.emit(\"helloFromServer\", \"hi\", 10));\n        expectError(socket.emit(\"wrong name\", 10));\n        expectError(socket.emit(\"wrong name\"));\n      });","file":"typed-events.test-d.ts","skipped":false,"dir":"test"},{"name":"works with undefined","suites":["url"],"updatePoint":{"line":7,"column":26},"line":7,"code":"  it(\"works with undefined\", () => {\n    loc.hostname = \"woot.com\";\n    loc.protocol = \"https:\";\n    loc.port = 4005;\n    loc.host = loc.hostname + \":\" + loc.port;\n    const parsed = url(undefined, undefined, loc);\n    expect(parsed.host).to.be(\"woot.com\");\n    expect(parsed.protocol).to.be(\"https\");\n    expect(parsed.port).to.be(\"4005\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with relative paths","suites":["url"],"updatePoint":{"line":18,"column":31},"line":18,"code":"  it(\"works with relative paths\", () => {\n    loc.hostname = \"woot.com\";\n    loc.protocol = \"https:\";\n    loc.port = 3000;\n    loc.host = loc.hostname + \":\" + loc.port;\n    const parsed = url(\"/test\", undefined, loc);\n    expect(parsed.host).to.be(\"woot.com\");\n    expect(parsed.protocol).to.be(\"https\");\n    expect(parsed.port).to.be(\"3000\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with no protocol","suites":["url"],"updatePoint":{"line":29,"column":28},"line":29,"code":"  it(\"works with no protocol\", () => {\n    loc.protocol = \"http:\";\n    const parsed = url(\"localhost:3000\", undefined, loc);\n    expect(parsed.host).to.be(\"localhost\");\n    expect(parsed.port).to.be(\"3000\");\n    expect(parsed.protocol).to.be(\"http\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with no schema","suites":["url"],"updatePoint":{"line":37,"column":26},"line":37,"code":"  it(\"works with no schema\", () => {\n    loc.protocol = \"http:\";\n    const parsed = url(\"//localhost:3000\", undefined, loc);\n    expect(parsed.host).to.be(\"localhost\");\n    expect(parsed.port).to.be(\"3000\");\n    expect(parsed.protocol).to.be(\"http\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"forces ports for unique url ids","suites":["url"],"updatePoint":{"line":45,"column":37},"line":45,"code":"  it(\"forces ports for unique url ids\", () => {\n    const id1 = url(\"http://google.com:80/\");\n    const id2 = url(\"http://google.com/\");\n    const id3 = url(\"https://google.com/\");\n    const id4 = url(\"http://google.com/\", \"/test\");\n    expect(id1.id).to.be(id2.id);\n    expect(id1.id).to.not.be(id3.id);\n    expect(id2.id).to.not.be(id3.id);\n    expect(id2.id).to.not.be(id4.id);\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"identifies the namespace","suites":["url"],"updatePoint":{"line":56,"column":30},"line":56,"code":"  it(\"identifies the namespace\", () => {\n    loc.protocol = \"http:\";\n    loc.hostname = \"woot.com\";\n\n    expect(url(\"/woot\", undefined, loc).path).to.be(\"/woot\");\n    expect(url(\"http://google.com\").path).to.be(\"/\");\n    expect(url(\"http://google.com/\").path).to.be(\"/\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with ipv6","suites":["url"],"updatePoint":{"line":65,"column":21},"line":65,"code":"  it(\"works with ipv6\", () => {\n    const parsed = url(\"http://[::1]\");\n    expect(parsed.protocol).to.be(\"http\");\n    expect(parsed.host).to.be(\"::1\");\n    expect(parsed.port).to.be(\"80\");\n    expect(parsed.id).to.be(\"http://[::1]:80\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with ipv6 location","suites":["url"],"updatePoint":{"line":73,"column":30},"line":73,"code":"  it(\"works with ipv6 location\", () => {\n    loc.protocol = \"http:\";\n    loc.hostname = \"[::1]\";\n    loc.port = \"\";\n    loc.host = loc.hostname + \":\" + loc.port;\n\n    const parsed = url(undefined, undefined, loc);\n    expect(parsed.protocol).to.be(\"http\");\n    expect(parsed.host).to.be(\"::1\");\n    expect(parsed.port).to.be(\"80\");\n    expect(parsed.id).to.be(\"http://[::1]:80\");\n  });","file":"url.ts","skipped":false,"dir":"test"},{"name":"works with a custom path","suites":["url"],"updatePoint":{"line":86,"column":30},"line":86,"code":"  it(\"works with a custom path\", function () {\n    const parsed = url(\"https://woot.com/some-namespace\", \"/some-path\");\n    expect(parsed.id).to.be(\"https://woot.com:443/some-path\");\n    expect(parsed.path).to.be(\"/some-namespace\");\n  });","file":"url.ts","skipped":false,"dir":"test"}]}