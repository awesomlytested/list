{
    "repo": "aws/aws-cdk",
    "url": "https://github.com/aws/aws-cdk",
    "branch": "master",
    "configs": [
        {
            "package": "@aws-cdk-containers/ecs-service-extensions",
            "lang": "ts",
            "dir": "packages/@aws-cdk-containers/ecs-service-extensions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/alexa-ask",
            "lang": "ts",
            "dir": "packages/@aws-cdk/alexa-ask/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/app-delivery",
            "lang": "ts",
            "dir": "packages/@aws-cdk/app-delivery/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/assert-internal",
            "lang": "ts",
            "dir": "packages/@aws-cdk/assert-internal/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/assertions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/assertions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/assets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/assets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-accessanalyzer",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-accessanalyzer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-acmpca",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-acmpca/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-amazonmq",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-amazonmq/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-amplify",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-amplify/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-amplifyuibuilder",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-amplifyuibuilder/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-apigateway",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-apigateway/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-apigatewayv2-authorizers",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-apigatewayv2-integrations",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-apigatewayv2",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appconfig",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appconfig/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appflow",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appflow/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appintegrations",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appintegrations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-applicationautoscaling",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-applicationautoscaling/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-applicationinsights",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-applicationinsights/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appmesh",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appmesh/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-apprunner",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-apprunner/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appstream",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appstream/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-appsync",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-appsync/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-aps",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-aps/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-athena",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-athena/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-auditmanager",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-auditmanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-autoscaling-common",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-autoscaling-common/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-autoscaling-hooktargets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-autoscaling-hooktargets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-autoscaling",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-autoscaling/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-autoscalingplans",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-autoscalingplans/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-backup",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-backup/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-batch",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-batch/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-budgets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-budgets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cassandra",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cassandra/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ce",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ce/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/dns_validated_certificate_handler",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-certificatemanager/lambda-packages/dns_validated_certificate_handler/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-certificatemanager",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-certificatemanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-chatbot",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-chatbot/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloud9",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloud9/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudformation",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudformation/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudfront-origins",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudfront-origins/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudfront",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudfront/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudtrail",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudtrail/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudwatch-actions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudwatch-actions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cloudwatch",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cloudwatch/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codeartifact",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codeartifact/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codebuild",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codebuild/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codecommit",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codecommit/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codedeploy",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-codedeploy/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codeguruprofiler",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codeguruprofiler/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codegurureviewer",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codegurureviewer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codepipeline-actions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codepipeline-actions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codepipeline",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codepipeline/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codestar",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codestar/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codestarconnections",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codestarconnections/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-codestarnotifications",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-codestarnotifications/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cognito",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cognito/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-config",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-config/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-connect",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-connect/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-cur",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-cur/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-customerprofiles",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-customerprofiles/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-databrew",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-databrew/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-datapipeline",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-datapipeline/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-datasync",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-datasync/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-dax",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-dax/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-detective",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-detective/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-devopsguru",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-devopsguru/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-directoryservice",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-directoryservice/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-dlm",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-dlm/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-dms",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-dms/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-docdb",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-docdb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-global-lambda-coordinator",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-dynamodb-global/lambda-packages/aws-global-table-coordinator/test",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@aws-cdk/aws-dynamodb-global",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-dynamodb-global/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-dynamodb",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-dynamodb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ec2",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ec2/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ecr-assets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ecr-assets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ecr",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ecr/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ecs-patterns",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-ecs-patterns/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ecs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ecs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-efs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-efs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-eks-legacy",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-eks-legacy/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-eks",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-eks/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticache",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticache/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticbeanstalk",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticbeanstalk/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticloadbalancing",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticloadbalancing/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticloadbalancingv2-actions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticloadbalancingv2-actions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticloadbalancingv2-targets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticloadbalancingv2-targets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticloadbalancingv2",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticloadbalancingv2/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-elasticsearch",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-elasticsearch/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-emr",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-emr/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-emrcontainers",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-emrcontainers/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-events-targets",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-events-targets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-events",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-events/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-eventschemas",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-eventschemas/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-evidently",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-evidently/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-finspace",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-finspace/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-fis",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-fis/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-fms",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-fms/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-frauddetector",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-frauddetector/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-fsx",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-fsx/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-gamelift",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-gamelift/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-globalaccelerator-endpoints",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-globalaccelerator-endpoints/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-globalaccelerator",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-globalaccelerator/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-glue",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-glue/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-greengrass",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-greengrass/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-greengrassv2",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-greengrassv2/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-groundstation",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-groundstation/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-guardduty",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-guardduty/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-healthlake",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-healthlake/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iam",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iam/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-imagebuilder",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-imagebuilder/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-inspector",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-inspector/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iot-actions",
            "lang": "js",
            "dir": "packages/@aws-cdk/aws-iot-actions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iot",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iot/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iot1click",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iot1click/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotanalytics",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotanalytics/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotcoredeviceadvisor",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotcoredeviceadvisor/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotevents",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotevents/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotfleethub",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotfleethub/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotsitewise",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotsitewise/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotthingsgraph",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotthingsgraph/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-iotwireless",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-iotwireless/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ivs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ivs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kendra",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kendra/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kinesis",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kinesis/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kinesisanalytics-flink",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kinesisanalytics",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kinesisanalytics/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kinesisfirehose-destinations",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kinesisfirehose",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-kms",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-kms/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lakeformation",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lakeformation/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda-destinations",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda-destinations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda-event-sources",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda-event-sources/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda-go",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda-go/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda-nodejs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda-nodejs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda-python",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda-python/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lambda",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lambda/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lex",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lex/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-licensemanager",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-licensemanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lightsail",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lightsail/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-location",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-location/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-logs-destinations",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-logs-destinations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-logs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-logs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lookoutequipment",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lookoutequipment/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lookoutmetrics",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lookoutmetrics/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-lookoutvision",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-lookoutvision/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-macie",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-macie/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-managedblockchain",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-managedblockchain/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-mediaconnect",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-mediaconnect/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-mediaconvert",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-mediaconvert/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-medialive",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-medialive/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-mediapackage",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-mediapackage/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-mediastore",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-mediastore/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-memorydb",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-memorydb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-msk",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-msk/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-mwaa",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-mwaa/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-neptune",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-neptune/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-networkfirewall",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-networkfirewall/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-networkmanager",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-networkmanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-nimblestudio",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-nimblestudio/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-opensearchservice",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-opensearchservice/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-opsworks",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-opsworks/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-opsworkscm",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-opsworkscm/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-panorama",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-panorama/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-pinpoint",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-pinpoint/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-pinpointemail",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-pinpointemail/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-qldb",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-qldb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-quicksight",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-quicksight/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ram",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ram/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-rds",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-rds/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-redshift",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-redshift/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-refactorspaces",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-refactorspaces/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-rekognition",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-rekognition/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-resiliencehub",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-resiliencehub/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-resourcegroups",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-resourcegroups/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-robomaker",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-robomaker/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53-patterns",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53-patterns/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53-targets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53-targets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53recoverycontrol",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53recoverycontrol/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53recoveryreadiness",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53recoveryreadiness/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-route53resolver",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-route53resolver/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-rum",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-rum/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3-assets",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3-assets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3-deployment",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3-deployment/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3-notifications",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3-notifications/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3objectlambda",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3objectlambda/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-s3outposts",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-s3outposts/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sagemaker",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sagemaker/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sam",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sam/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sdb",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sdb/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-secretsmanager",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-secretsmanager/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-securityhub",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-securityhub/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-servicecatalog",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-servicecatalog/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-servicecatalogappregistry",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-servicediscovery",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-servicediscovery/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ses-actions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ses-actions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ses",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ses/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-signer",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-signer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sns-subscriptions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sns-subscriptions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sns",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sns/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sqs",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sqs/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ssm",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ssm/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ssmcontacts",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ssmcontacts/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-ssmincidents",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-ssmincidents/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-sso",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-sso/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-stepfunctions-tasks",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-stepfunctions-tasks/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-stepfunctions",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-stepfunctions/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-synthetics",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-synthetics/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-timestream",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-timestream/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-transfer",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-transfer/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-waf",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-waf/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-wafregional",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-wafregional/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-wafv2",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-wafv2/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-wisdom",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-wisdom/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-workspaces",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-workspaces/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/aws-xray",
            "lang": "ts",
            "dir": "packages/@aws-cdk/aws-xray/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cdk-assets-schema",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cdk-assets-schema/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cfnspec",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cfnspec/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cloud-assembly-schema",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cloud-assembly-schema/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cloudformation-diff",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cloudformation-diff/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cloudformation-include",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cloudformation-include/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/core",
            "lang": "ts",
            "dir": "packages/@aws-cdk/core/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/custom-resources",
            "lang": "js",
            "dir": "packages/@aws-cdk/custom-resources/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cx-api",
            "lang": "ts",
            "dir": "packages/@aws-cdk/cx-api/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/example-construct-library",
            "lang": "ts",
            "dir": "packages/@aws-cdk/example-construct-library/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/lambda-layer-awscli",
            "lang": "ts",
            "dir": "packages/@aws-cdk/lambda-layer-awscli/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/lambda-layer-kubectl",
            "lang": "ts",
            "dir": "packages/@aws-cdk/lambda-layer-kubectl/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/lambda-layer-node-proxy-agent",
            "lang": "ts",
            "dir": "packages/@aws-cdk/lambda-layer-node-proxy-agent/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/pipelines",
            "lang": "ts",
            "dir": "packages/@aws-cdk/pipelines/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/region-info",
            "lang": "ts",
            "dir": "packages/@aws-cdk/region-info/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/yaml-cfn",
            "lang": "ts",
            "dir": "packages/@aws-cdk/yaml-cfn/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@monocdk-experiment/rewrite-imports",
            "lang": "ts",
            "dir": "packages/@monocdk-experiment/rewrite-imports/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "aws-cdk-migration",
            "lang": "ts",
            "dir": "packages/aws-cdk-migration/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "aws-cdk",
            "lang": "ts",
            "dir": "packages/aws-cdk/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "cdk-assets",
            "lang": "ts",
            "dir": "packages/cdk-assets/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "cdk-dasm",
            "lang": "ts",
            "dir": "packages/cdk-dasm/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "decdk",
            "lang": "ts",
            "dir": "packages/decdk/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cdk-release",
            "lang": "ts",
            "dir": "tools/@aws-cdk/cdk-release/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/cfn2ts",
            "lang": "js",
            "dir": "tools/@aws-cdk/cfn2ts/test",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@aws-cdk/eslint-plugin",
            "lang": "js",
            "dir": "tools/@aws-cdk/eslint-plugin/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/generate-examples",
            "lang": "ts",
            "dir": "tools/@aws-cdk/generate-examples/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/individual-pkg-gen",
            "lang": "ts",
            "dir": "tools/@aws-cdk/individual-pkg-gen/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/pkglint",
            "lang": "ts",
            "dir": "tools/@aws-cdk/pkglint/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/prlint",
            "lang": "ts",
            "dir": "tools/@aws-cdk/prlint/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@aws-cdk/yarn-cling",
            "lang": "ts",
            "dir": "tools/@aws-cdk/yarn-cling/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "create an app connected to a GitHub repository",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 52
            },
            "line": 12,
            "code": "test('create an app connected to a GitHub repository', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    buildSpec: codebuild.BuildSpec.fromObjectToYaml({\n      version: '1.0',\n      frontend: {\n        phases: {\n          build: {\n            commands: [\n              'npm run build',\n            ],\n          },\n        },\n      },\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    Name: 'App',\n    BuildSpec: 'version: \\\"1.0\\\"\\nfrontend:\\n  phases:\\n    build:\\n      commands:\\n        - npm run build\\n',\n    IAMServiceRole: {\n      'Fn::GetAtt': [\n        'AppRole1AF9B530',\n        'Arn',\n      ],\n    },\n    OauthToken: 'secret',\n    Repository: 'https://github.com/aws/aws-cdk',\n    BasicAuthConfig: {\n      EnableBasicAuth: false,\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [\n        {\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: {\n            Service: 'amplify.amazonaws.com',\n          },\n        },\n      ],\n      Version: '2012-10-17',\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "create an app connected to a GitLab repository",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 52
            },
            "line": 67,
            "code": "test('create an app connected to a GitLab repository', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitLabSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    buildSpec: codebuild.BuildSpec.fromObject({\n      version: '1.0',\n      frontend: {\n        phases: {\n          build: {\n            commands: [\n              'npm run build',\n            ],\n          },\n        },\n      },\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    Name: 'App',\n    BuildSpec: '{\\n  \\\"version\\\": \\\"1.0\\\",\\n  \\\"frontend\\\": {\\n    \\\"phases\\\": {\\n      \\\"build\\\": {\\n        \\\"commands\\\": [\\n          \\\"npm run build\\\"\\n        ]\\n      }\\n    }\\n  }\\n}',\n    IAMServiceRole: {\n      'Fn::GetAtt': [\n        'AppRole1AF9B530',\n        'Arn',\n      ],\n    },\n    OauthToken: 'secret',\n    Repository: 'https://gitlab.com/aws/aws-cdk',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [\n        {\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: {\n            Service: 'amplify.amazonaws.com',\n          },\n        },\n      ],\n      Version: '2012-10-17',\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "create an app connected to a CodeCommit repository",
            "suites": [],
            "updatePoint": {
                "line": 119,
                "column": 56
            },
            "line": 119,
            "code": "test('create an app connected to a CodeCommit repository', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.CodeCommitSourceCodeProvider({\n      repository: codecommit.Repository.fromRepositoryName(stack, 'Repo', 'my-repo'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    IAMServiceRole: {\n      'Fn::GetAtt': [\n        'AppRole1AF9B530',\n        'Arn',\n      ],\n    },\n    Repository: {\n      'Fn::Join': [\n        '',\n        [\n          'https://git-codecommit.',\n          {\n            Ref: 'AWS::Region',\n          },\n          '.',\n          {\n            Ref: 'AWS::URLSuffix',\n          },\n          '/v1/repos/my-repo',\n        ],\n      ],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [\n        {\n          Action: 'codecommit:GitPull',\n          Effect: 'Allow',\n          Resource: {\n            'Fn::Join': [\n              '',\n              [\n                'arn:',\n                {\n                  Ref: 'AWS::Partition',\n                },\n                ':codecommit:',\n                {\n                  Ref: 'AWS::Region',\n                },\n                ':',\n                {\n                  Ref: 'AWS::AccountId',\n                },\n                ':my-repo',\n              ],\n            ],\n          },\n        },\n      ],\n      Version: '2012-10-17',\n    },\n    Roles: [\n      {\n        Ref: 'AppRole1AF9B530',\n      },\n    ],\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with basic auth from credentials",
            "suites": [],
            "updatePoint": {
                "line": 191,
                "column": 38
            },
            "line": 191,
            "code": "test('with basic auth from credentials', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    basicAuth: amplify.BasicAuth.fromCredentials('username', SecretValue.unsafePlainText('password')),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    BasicAuthConfig: {\n      EnableBasicAuth: true,\n      Password: 'password',\n      Username: 'username',\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with basic auth from generated password",
            "suites": [],
            "updatePoint": {
                "line": 212,
                "column": 45
            },
            "line": 212,
            "code": "test('with basic auth from generated password', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    basicAuth: amplify.BasicAuth.fromGeneratedPassword('username'),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    BasicAuthConfig: {\n      EnableBasicAuth: true,\n      Password: {\n        'Fn::Join': [\n          '',\n          [\n            '{{resolve:secretsmanager:',\n            {\n              Ref: 'AppAppBasicAuthE743F015',\n            },\n            ':SecretString:password::}}',\n          ],\n        ],\n      },\n      Username: 'username',\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n    GenerateSecretString: {\n      GenerateStringKey: 'password',\n      SecretStringTemplate: '{\\\"username\\\":\\\"username\\\"}',\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with env vars",
            "suites": [],
            "updatePoint": {
                "line": 251,
                "column": 19
            },
            "line": 251,
            "code": "test('with env vars', () => {\n  // WHEN\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    environmentVariables: {\n      key1: 'value1',\n    },\n  });\n  app.addEnvironment('key2', 'value2');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    EnvironmentVariables: [\n      {\n        Name: 'key1',\n        Value: 'value1',\n      },\n      {\n        Name: 'key2',\n        Value: 'value2',\n      },\n    ],\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with custom rules",
            "suites": [],
            "updatePoint": {
                "line": 280,
                "column": 23
            },
            "line": 280,
            "code": "test('with custom rules', () => {\n  // WHEN\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    customRules: [\n      {\n        source: '/source1',\n        target: '/target1',\n        status: amplify.RedirectStatus.PERMANENT_REDIRECT,\n      },\n    ],\n  });\n  app.addCustomRule({\n    source: '/source2',\n    target: '/target2',\n    status: amplify.RedirectStatus.TEMPORARY_REDIRECT,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    CustomRules: [\n      {\n        Source: '/source1',\n        Status: '301',\n        Target: '/target1',\n      },\n      {\n        Source: '/source2',\n        Status: '302',\n        Target: '/target2',\n      },\n    ],\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with SPA redirect",
            "suites": [],
            "updatePoint": {
                "line": 319,
                "column": 23
            },
            "line": 319,
            "code": "test('with SPA redirect', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    customRules: [amplify.CustomRule.SINGLE_PAGE_APPLICATION_REDIRECT],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    CustomRules: [\n      {\n        Source: '</^[^.]+$/>',\n        Status: '200',\n        Target: '/index.html',\n      },\n    ],\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with auto branch creation",
            "suites": [],
            "updatePoint": {
                "line": 342,
                "column": 31
            },
            "line": 342,
            "code": "test('with auto branch creation', () => {\n  // WHEN\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    autoBranchCreation: {\n      environmentVariables: {\n        key1: 'value1',\n      },\n    },\n  });\n  app.addAutoBranchEnvironment('key2', 'value2');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    AutoBranchCreationConfig: {\n      BasicAuthConfig: {\n        EnableBasicAuth: false,\n      },\n      EnableAutoBranchCreation: true,\n      EnableAutoBuild: true,\n      EnablePullRequestPreview: true,\n      EnvironmentVariables: [\n        {\n          Name: 'key1',\n          Value: 'value1',\n        },\n        {\n          Name: 'key2',\n          Value: 'value2',\n        },\n      ],\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with auto branch deletion",
            "suites": [],
            "updatePoint": {
                "line": 381,
                "column": 31
            },
            "line": 381,
            "code": "test('with auto branch deletion', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    autoBranchDeletion: true,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    EnableBranchAutoDeletion: true,\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with custom headers",
            "suites": [],
            "updatePoint": {
                "line": 398,
                "column": 25
            },
            "line": 398,
            "code": "test('with custom headers', () => {\n  // WHEN\n  new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    customResponseHeaders: [\n      {\n        pattern: '*.json',\n        headers: {\n          'custom-header-name-1': 'custom-header-value-1',\n          'custom-header-name-2': 'custom-header-value-2',\n        },\n      },\n      {\n        pattern: '/path/*',\n        headers: {\n          'custom-header-name-1': 'custom-header-value-2',\n        },\n      },\n      {\n        pattern: '/with-tokens/*',\n        headers: {\n          'x-custom': `${'hello'.repeat(10)}${Stack.of(stack).urlSuffix} `,\n        },\n      },\n    ],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::App', {\n    CustomHeaders: {\n      'Fn::Join': [\n        '',\n        [\n          'customHeaders:\\n  - pattern: \"*.json\"\\n    headers:\\n      - key: \"custom-header-name-1\"\\n        value: \"custom-header-value-1\"\\n      - key: \"custom-header-name-2\"\\n        value: \"custom-header-value-2\"\\n  - pattern: \"/path/*\"\\n    headers:\\n      - key: \"custom-header-name-1\"\\n        value: \"custom-header-value-2\"\\n  - pattern: \"/with-tokens/*\"\\n    headers:\\n      - key: \"x-custom\"\\n        value: \"hellohellohellohellohellohellohellohellohellohello',\n          {\n            Ref: 'AWS::URLSuffix',\n          },\n          ' \"\\n',\n        ],\n      ],\n    },\n  });\n});",
            "file": "app.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent CREATE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 59,
                "column": 28
            },
            "line": 59,
            "code": "  it('onEvent CREATE success', async () => {\n    // GIVEN\n    listJobsResponse.mockImplementation(() => {\n      return {\n        jobSummaries: [],\n      };\n    });\n    getSignedUrlResponse.mockImplementation(() => {\n      return 'signedUrlValue';\n    });\n    startDeploymentResponse.mockImplementation(() => {\n      return {\n        jobSummary: { jobId: 'jobIdValue' },\n      };\n    });\n\n    // WHEN\n    const response = await onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      AmplifyJobId: 'jobIdValue',\n    });\n\n    expect(listJobsRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      maxResults: 1,\n    });\n    expect(listJobsResponse).toBeCalled();\n    expect(getSignedUrlResponse).toHaveBeenCalledWith('getObject', {\n      Bucket: 's3BucketNameValue',\n      Key: 's3ObjectKeyValue',\n    });\n    expect(startDeploymentRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      sourceUrl: 'signedUrlValue',\n    });\n    expect(startDeploymentResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent CREATE pending job",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 116,
                "column": 32
            },
            "line": 116,
            "code": "  it('onEvent CREATE pending job', async () => {\n    // GIVEN\n    listJobsResponse.mockImplementation(() => {\n      return {\n        jobSummaries: [{ status: 'PENDING' }],\n      };\n    });\n\n    // WHEN\n    await expect(() => onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n    })).rejects.toMatch('Amplify job already running. Aborting deployment.');\n\n    expect(listJobsRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      maxResults: 1,\n    });\n    expect(listJobsResponse).toBeCalled();\n    expect(getSignedUrlResponse).not.toHaveBeenCalled();\n    expect(startDeploymentRequest).not.toHaveBeenCalled();\n    expect(startDeploymentResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete CREATE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 153,
                "column": 31
            },
            "line": 153,
            "code": "  it('isComplete CREATE success', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'SUCCEED' } },\n      };\n    });\n\n    // WHEN\n    const response = await isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      Data: {\n        JobId: 'amplifyJobIdValue',\n        Status: 'SUCCEED',\n      },\n      IsComplete: true,\n    });\n\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete CREATE pending",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 197,
                "column": 31
            },
            "line": 197,
            "code": "  it('isComplete CREATE pending', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'PENDING' } },\n      };\n    });\n\n    // WHEN\n    const response = await isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      IsComplete: false,\n    });\n\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete CREATE failed",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 237,
                "column": 30
            },
            "line": 237,
            "code": "  it('isComplete CREATE failed', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'FAILED' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n    })).rejects.toThrow('Amplify job failed with status: FAILED');\n    // THEN\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete CREATE cancelled",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 272,
                "column": 33
            },
            "line": 272,
            "code": "  it('isComplete CREATE cancelled', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'CANCELLED' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n    })).rejects.toThrow('Amplify job failed with status: CANCELLED');\n\n    // THEN\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete CREATE no JobId",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 308,
                "column": 32
            },
            "line": 308,
            "code": "  it('isComplete CREATE no JobId', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'PENDING' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Create',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n    })).rejects.toThrow('Unable to determine Amplify job status without job id');\n\n    // THEN\n    expect(getJobRequest).not.toHaveBeenCalled();\n    expect(getJobResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent UPDATE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 339,
                "column": 28
            },
            "line": 339,
            "code": "  it('onEvent UPDATE success', async () => {\n    // GIVEN\n    listJobsResponse.mockImplementation(() => {\n      return {\n        jobSummaries: [],\n      };\n    });\n    getSignedUrlResponse.mockImplementation(() => {\n      return 'signedUrlValue';\n    });\n    startDeploymentResponse.mockImplementation(() => {\n      return {\n        jobSummary: { jobId: 'jobIdValue' },\n      };\n    });\n\n    // WHEN\n    const response = await onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: { ServiceToken: 'serviceTokenValue' },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      AmplifyJobId: 'jobIdValue',\n    });\n\n    expect(listJobsRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      maxResults: 1,\n    });\n    expect(listJobsResponse).toBeCalled();\n    expect(getSignedUrlResponse).toHaveBeenCalledWith('getObject', {\n      Bucket: 's3BucketNameValue',\n      Key: 's3ObjectKeyValue',\n    });\n    expect(startDeploymentRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      sourceUrl: 'signedUrlValue',\n    });\n    expect(startDeploymentResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent UPDATE pending job",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 398,
                "column": 32
            },
            "line": 398,
            "code": "  it('onEvent UPDATE pending job', async () => {\n    // GIVEN\n    listJobsResponse.mockImplementation(() => {\n      return {\n        jobSummaries: [{ status: 'PENDING' }],\n      };\n    });\n\n    // WHEN\n    await expect(() => onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: { ServiceToken: 'serviceTokenValue' },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toMatch('Amplify job already running. Aborting deployment.');\n\n    // THEN\n    expect(listJobsRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      maxResults: 1,\n    });\n    expect(listJobsResponse).toBeCalled();\n    expect(getSignedUrlResponse).not.toHaveBeenCalled();\n    expect(startDeploymentRequest).not.toHaveBeenCalled();\n    expect(startDeploymentResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete UPDATE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 438,
                "column": 31
            },
            "line": 438,
            "code": "  it('isComplete UPDATE success', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'SUCCEED' } },\n      };\n    });\n\n    // WHEN\n    const response = await isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      Data: {\n        JobId: 'amplifyJobIdValue',\n        Status: 'SUCCEED',\n      },\n      IsComplete: true,\n    });\n\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete UPDATE pending",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 484,
                "column": 31
            },
            "line": 484,
            "code": "  it('isComplete UPDATE pending', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'PENDING' } },\n      };\n    });\n\n    // WHEN\n    const response = await isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      IsComplete: false,\n    });\n\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete UPDATE failed",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 526,
                "column": 30
            },
            "line": 526,
            "code": "  it('isComplete UPDATE failed', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'FAILED' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toThrow('Amplify job failed with status: FAILED');\n    // THEN\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete UPDATE cancelled",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 563,
                "column": 33
            },
            "line": 563,
            "code": "  it('isComplete UPDATE cancelled', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'CANCELLED' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      AmplifyJobId: 'amplifyJobIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toThrow('Amplify job failed with status: CANCELLED');\n\n    // THEN\n    expect(getJobRequest).toHaveBeenCalledWith({\n      appId: 'appIdValue',\n      branchName: 'branchNameValue',\n      jobId: 'amplifyJobIdValue',\n    });\n    expect(getJobResponse).toBeCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete UPDATE no JobId",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 601,
                "column": 32
            },
            "line": 601,
            "code": "  it('isComplete UPDATE no JobId', async () => {\n    // GIVEN\n    getJobResponse.mockImplementation(() => {\n      return {\n        job: { summary: { status: 'PENDING' } },\n      };\n    });\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toThrow('Unable to determine Amplify job status without job id');\n\n    // THEN\n    expect(getJobRequest).not.toHaveBeenCalled();\n    expect(getJobResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent DELETE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 634,
                "column": 28
            },
            "line": 634,
            "code": "  it('onEvent DELETE success', async () => {\n    // GIVEN\n\n    // WHEN\n    await expect(() => onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Delete',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).resolves;\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete DELETE success",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 657,
                "column": 31
            },
            "line": 657,
            "code": "  it('isComplete DELETE success', async () => {\n    // GIVEN\n\n    // WHEN\n    const response = await isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Delete',\n      ResourceType: 'Custom::AmplifyAssetDeployment',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    });\n\n    // THEN\n    expect(response).toEqual({\n      IsComplete: true,\n    });\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "onEvent unsupported resource type",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 685,
                "column": 39
            },
            "line": 685,
            "code": "  it('onEvent unsupported resource type', async () => {\n    // GIVEN\n\n    // WHEN\n    await expect(() => onEvent({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::BadResourceType',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toThrow('Unsupported resource type \"Custom::BadResourceType\"');\n\n\n    // THEN\n    expect(getJobRequest).not.toHaveBeenCalled();\n    expect(getJobResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "isComplete unsupported resource type",
            "suites": [
                "handler"
            ],
            "updatePoint": {
                "line": 714,
                "column": 42
            },
            "line": 714,
            "code": "  it('isComplete unsupported resource type', async () => {\n    // GIVEN\n\n    // WHEN\n    await expect(() => isComplete({\n      ServiceToken: 'serviceTokenValue',\n      RequestType: 'Update',\n      ResourceType: 'Custom::BadResourceType',\n      ResourceProperties: {\n        ServiceToken: 'serviceTokenValue',\n        AppId: 'appIdValue',\n        BranchName: 'branchNameValue',\n        S3BucketName: 's3BucketNameValue',\n        S3ObjectKey: 's3ObjectKeyValue',\n      },\n      OldResourceProperties: {},\n      ResponseURL: 'responseUrlValue',\n      StackId: 'stackIdValue',\n      RequestId: 'requestIdValue',\n      LogicalResourceId: 'logicalResourceIdValue',\n      PhysicalResourceId: 'physicalResourceIdValue',\n    })).rejects.toThrow('Unsupported resource type \"Custom::BadResourceType\"');\n\n    // THEN\n    expect(getJobRequest).not.toHaveBeenCalled();\n    expect(getJobResponse).not.toHaveBeenCalled();\n  });",
            "file": "asset-deployment-handler/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "create a branch",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 21
            },
            "line": 20,
            "code": "test('create a branch', () => {\n  // WHEN\n  app.addBranch('dev');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Branch', {\n    AppId: {\n      'Fn::GetAtt': [\n        'AppF1B96344',\n        'AppId',\n      ],\n    },\n    BranchName: 'dev',\n    EnableAutoBuild: true,\n    EnablePullRequestPreview: true,\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with basic auth from credentials",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 38
            },
            "line": 38,
            "code": "test('with basic auth from credentials', () => {\n  // WHEN\n  app.addBranch('dev', {\n    basicAuth: amplify.BasicAuth.fromCredentials('username', SecretValue.unsafePlainText('password')),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Branch', {\n    BasicAuthConfig: {\n      EnableBasicAuth: true,\n      Password: 'password',\n      Username: 'username',\n    },\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with basic auth from generated password",
            "suites": [],
            "updatePoint": {
                "line": 54,
                "column": 45
            },
            "line": 54,
            "code": "test('with basic auth from generated password', () => {\n  // WHEN\n  app.addBranch('dev', {\n    basicAuth: amplify.BasicAuth.fromGeneratedPassword('username'),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Branch', {\n    BasicAuthConfig: {\n      EnableBasicAuth: true,\n      Password: {\n        'Fn::Join': [\n          '',\n          [\n            '{{resolve:secretsmanager:',\n            {\n              Ref: 'AppdevdevBasicAuthB25D2314',\n            },\n            ':SecretString:password::}}',\n          ],\n        ],\n      },\n      Username: 'username',\n    },\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with env vars",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 19
            },
            "line": 81,
            "code": "test('with env vars', () => {\n  // WHEN\n  const branch = app.addBranch('dev', {\n    environmentVariables: {\n      key1: 'value1',\n    },\n  });\n  branch.addEnvironment('key2', 'value2');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Branch', {\n    EnvironmentVariables: [\n      {\n        Name: 'key1',\n        Value: 'value1',\n      },\n      {\n        Name: 'key2',\n        Value: 'value2',\n      },\n    ],\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with asset deployment",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 27
            },
            "line": 105,
            "code": "test('with asset deployment', () => {\n  // WHEN\n  const asset = new Asset(app, 'SampleAsset', {\n    path: path.join(__dirname, './test-asset'),\n  });\n  app.addBranch('dev', { asset });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('Custom::AmplifyAssetDeployment', {\n    ServiceToken: {\n      'Fn::GetAtt': [\n        'comamazonawscdkcustomresourcesamplifyassetdeploymentproviderNestedStackcomamazonawscdkcustomresourcesamplifyassetdeploymentproviderNestedStackResource89BDFEB2',\n        'Outputs.comamazonawscdkcustomresourcesamplifyassetdeploymentprovideramplifyassetdeploymenthandlerproviderframeworkonEventA449D9A9Arn',\n      ],\n    },\n    AppId: {\n      'Fn::GetAtt': [\n        'AppF1B96344',\n        'AppId',\n      ],\n    },\n    BranchName: 'dev',\n    S3ObjectKey: '8c89eadc6be22019c81ed6b9c7d9929ae10de55679fd8e0e9fd4c00f8edc1cda.zip',\n    S3BucketName: {\n      'Fn::Sub': 'cdk-hnb659fds-assets-${AWS::AccountId}-${AWS::Region}',\n    },\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "with performance mode",
            "suites": [],
            "updatePoint": {
                "line": 134,
                "column": 27
            },
            "line": 134,
            "code": "test('with performance mode', () => {\n  // WHEN\n  app.addBranch('dev', {\n    performanceMode: true,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Branch', {\n    EnablePerformanceMode: true,\n  });\n});",
            "file": "branch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "create a domain",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 21
            },
            "line": 6,
            "code": "test('create a domain', () => {\n  // GIVEN\n  const stack = new Stack();\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n  });\n  const prodBranch = app.addBranch('main');\n  const devBranch = app.addBranch('dev');\n\n  // WHEN\n  const domain = app.addDomain('amazon.com', {\n    subDomains: [\n      {\n        branch: prodBranch,\n        prefix: 'prod',\n      },\n    ],\n  });\n  domain.mapSubDomain(devBranch);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Domain', {\n    AppId: {\n      'Fn::GetAtt': [\n        'AppF1B96344',\n        'AppId',\n      ],\n    },\n    DomainName: 'amazon.com',\n    SubDomainSettings: [\n      {\n        BranchName: {\n          'Fn::GetAtt': [\n            'AppmainF505BAED',\n            'BranchName',\n          ],\n        },\n        Prefix: 'prod',\n      },\n      {\n        BranchName: {\n          'Fn::GetAtt': [\n            'AppdevB328DAFC',\n            'BranchName',\n          ],\n        },\n        Prefix: {\n          'Fn::GetAtt': [\n            'AppdevB328DAFC',\n            'BranchName',\n          ],\n        },\n      },\n    ],\n  });\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "map a branch to the domain root",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 37
            },
            "line": 67,
            "code": "test('map a branch to the domain root', () => {\n  // GIVEN\n  const stack = new Stack();\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n  });\n  const prodBranch = app.addBranch('main');\n\n  // WHEN\n  const domain = app.addDomain('amazon.com');\n  domain.mapRoot(prodBranch);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Domain', {\n    AppId: {\n      'Fn::GetAtt': [\n        'AppF1B96344',\n        'AppId',\n      ],\n    },\n    DomainName: 'amazon.com',\n    SubDomainSettings: [\n      {\n        BranchName: {\n          'Fn::GetAtt': [\n            'AppmainF505BAED',\n            'BranchName',\n          ],\n        },\n        Prefix: '',\n      },\n    ],\n  });\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "throws at synthesis without subdomains",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 44
            },
            "line": 106,
            "code": "test('throws at synthesis without subdomains', () => {\n  // GIVEN\n  const app = new App();\n  const stack = new Stack(app, 'test-stack');\n  const amplifyApp = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n  });\n\n  // WHEN\n  amplifyApp.addDomain('amazon.com');\n\n  // THEN\n  expect(() => app.synth()).toThrow(/The domain doesn't contain any subdomains/);\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "auto subdomain all branches",
            "suites": [],
            "updatePoint": {
                "line": 125,
                "column": 33
            },
            "line": 125,
            "code": "test('auto subdomain all branches', () => {\n  // GIVEN\n  const stack = new Stack();\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n  });\n  const prodBranch = app.addBranch('main');\n\n  // WHEN\n  const domain = app.addDomain('amazon.com', {\n    enableAutoSubdomain: true,\n  });\n  domain.mapRoot(prodBranch);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Domain', {\n    EnableAutoSubDomain: true,\n    AutoSubDomainCreationPatterns: [\n      '*',\n      'pr*',\n    ],\n    AutoSubDomainIAMRole: {\n      'Fn::GetAtt': [\n        'AppRole1AF9B530',\n        'Arn',\n      ],\n    },\n  });\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "auto subdomain some branches",
            "suites": [],
            "updatePoint": {
                "line": 159,
                "column": 34
            },
            "line": 159,
            "code": "test('auto subdomain some branches', () => {\n  // GIVEN\n  const stack = new Stack();\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n  });\n  const prodBranch = app.addBranch('main');\n\n  // WHEN\n  const domain = app.addDomain('amazon.com', {\n    enableAutoSubdomain: true,\n    autoSubdomainCreationPatterns: ['features/**'],\n  });\n  domain.mapRoot(prodBranch);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Domain', {\n    EnableAutoSubDomain: true,\n    AutoSubDomainCreationPatterns: ['features/**'],\n    AutoSubDomainIAMRole: {\n      'Fn::GetAtt': [\n        'AppRole1AF9B530',\n        'Arn',\n      ],\n    },\n  });\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "auto subdomain with IAM role",
            "suites": [],
            "updatePoint": {
                "line": 191,
                "column": 34
            },
            "line": 191,
            "code": "test('auto subdomain with IAM role', () => {\n  // GIVEN\n  const stack = new Stack();\n  const app = new amplify.App(stack, 'App', {\n    sourceCodeProvider: new amplify.GitHubSourceCodeProvider({\n      owner: 'aws',\n      repository: 'aws-cdk',\n      oauthToken: SecretValue.unsafePlainText('secret'),\n    }),\n    role: iam.Role.fromRoleArn(\n      stack,\n      'AmplifyRole',\n      `arn:aws:iam::${Stack.of(stack).account}:role/AmplifyRole`,\n      { mutable: false },\n    ),\n  });\n  const prodBranch = app.addBranch('main');\n\n  // WHEN\n  const domain = app.addDomain('amazon.com', {\n    enableAutoSubdomain: true,\n    autoSubdomainCreationPatterns: ['features/**'],\n  });\n  domain.mapRoot(prodBranch);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Amplify::Domain', {\n    EnableAutoSubDomain: true,\n    AutoSubDomainCreationPatterns: ['features/**'],\n    AutoSubDomainIAMRole: {\n      'Fn::Join': [\n        '',\n        [\n          'arn:aws:iam::',\n          {\n            Ref: 'AWS::AccountId',\n          },\n          ':role/AmplifyRole',\n        ],\n      ],\n    },\n  });\n});",
            "file": "domain.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-amplify/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpJwtAuthorizer"
            ],
            "updatePoint": {
                "line": 7,
                "column": 15,
                "index": 303
            },
            "line": 7,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const authorizer = new HttpJwtAuthorizer('BooksAuthorizer', 'https://test.us.auth0.com', {\n      jwtAudience: ['3131231']\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerType: 'JWT',\n      IdentitySource: ['$request.header.Authorization'],\n      JwtConfiguration: {\n        Audience: ['3131231'],\n        Issuer: 'https://test.us.auth0.com'\n      },\n      Name: 'BooksAuthorizer'\n    });\n  });",
            "file": "http/jwt.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "same authorizer is used when bound to multiple routes",
            "suites": [
                "HttpJwtAuthorizer"
            ],
            "updatePoint": {
                "line": 33,
                "column": 61,
                "index": 1068
            },
            "line": 33,
            "code": "  test('same authorizer is used when bound to multiple routes', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const authorizer = new HttpJwtAuthorizer('BooksAuthorizer', 'https://test.us.auth0.com', {\n      jwtAudience: ['3131231']\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/pets',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Authorizer', 1);\n  });",
            "file": "http/jwt.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 416
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', handler);\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      Name: 'BooksAuthorizer',\n      AuthorizerType: 'REQUEST',\n      AuthorizerResultTtlInSeconds: 300,\n      AuthorizerPayloadFormatVersion: '1.0',\n      IdentitySource: ['$request.header.Authorization']\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      AuthorizationType: 'CUSTOM'\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "should use format 2.0 and simple responses when simple response type is requested",
            "suites": [
                "HttpLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 38,
                "column": 89,
                "index": 1460
            },
            "line": 38,
            "code": "  test('should use format 2.0 and simple responses when simple response type is requested', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', handler, {\n      responseTypes: [HttpLambdaResponseType.SIMPLE]\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerPayloadFormatVersion: '2.0',\n      EnableSimpleResponses: true\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "should use format 1.0 when only IAM response type is requested",
            "suites": [
                "HttpLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 64,
                "column": 70,
                "index": 2296
            },
            "line": 64,
            "code": "  test('should use format 1.0 when only IAM response type is requested', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', handler, {\n      responseTypes: [HttpLambdaResponseType.IAM]\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerPayloadFormatVersion: '1.0',\n      EnableSimpleResponses: Match.absent()\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "should use format 2.0 and simple responses when both response types are requested",
            "suites": [
                "HttpLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 90,
                "column": 89,
                "index": 3158
            },
            "line": 90,
            "code": "  test('should use format 2.0 and simple responses when both response types are requested', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', handler, {\n      responseTypes: [HttpLambdaResponseType.IAM, HttpLambdaResponseType.SIMPLE]\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerPayloadFormatVersion: '2.0',\n      EnableSimpleResponses: true\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "can override cache ttl",
            "suites": [
                "HttpLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 116,
                "column": 30,
                "index": 3982
            },
            "line": 116,
            "code": "  test('can override cache ttl', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const handler = new Function(stack, 'auth-functon', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const authorizer = new HttpLambdaAuthorizer('BooksAuthorizer', handler, {\n      resultsCacheTtl: Duration.minutes(10)\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerResultTtlInSeconds: 600\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpUserPoolAuthorizer"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 365
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const userPool = new UserPool(stack, 'UserPool');\n    const authorizer = new HttpUserPoolAuthorizer('BooksAuthorizer', userPool);\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerType: 'JWT',\n      IdentitySource: ['$request.header.Authorization'],\n      JwtConfiguration: {\n        Audience: [{\n          Ref: 'UserPoolUserPoolAuthorizerClient680A88B6'\n        }],\n        Issuer: {\n          'Fn::Join': ['', ['https://cognito-idp.', {\n            Ref: 'AWS::Region'\n          }, '.amazonaws.com/', stack.resolve(userPool.userPoolId)]]\n        }\n      },\n      Name: 'BooksAuthorizer'\n    });\n  });",
            "file": "http/user-pool.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "same authorizer is used when bound to multiple routes",
            "suites": [
                "HttpUserPoolAuthorizer"
            ],
            "updatePoint": {
                "line": 39,
                "column": 61,
                "index": 1328
            },
            "line": 39,
            "code": "  test('same authorizer is used when bound to multiple routes', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const userPool = new UserPool(stack, 'UserPool');\n    const authorizer = new HttpUserPoolAuthorizer('UserPoolAuthorizer', userPool);\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/pets',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Authorizer', 1);\n  });",
            "file": "http/user-pool.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "multiple userPoolClients are attached",
            "suites": [
                "HttpUserPoolAuthorizer"
            ],
            "updatePoint": {
                "line": 61,
                "column": 45,
                "index": 1956
            },
            "line": 61,
            "code": "  test('multiple userPoolClients are attached', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const userPool = new UserPool(stack, 'UserPool');\n    const userPoolClient1 = userPool.addClient('UserPoolClient1');\n    const userPoolClient2 = userPool.addClient('UserPoolClient2');\n    const authorizer = new HttpUserPoolAuthorizer('BooksAuthorizer', userPool, {\n      userPoolClients: [userPoolClient1, userPoolClient2]\n    });\n\n    // WHEN\n    api.addRoutes({\n      integration: new DummyRouteIntegration(),\n      path: '/books',\n      authorizer\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      AuthorizerType: 'JWT',\n      IdentitySource: ['$request.header.Authorization'],\n      JwtConfiguration: {\n        Audience: [stack.resolve(userPoolClient1.userPoolClientId), stack.resolve(userPoolClient2.userPoolClientId)],\n        Issuer: {\n          'Fn::Join': ['', ['https://cognito-idp.', {\n            Ref: 'AWS::Region'\n          }, '.amazonaws.com/', stack.resolve(userPool.userPoolId)]]\n        }\n      }\n    });\n  });",
            "file": "http/user-pool.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 423
            },
            "line": 8,
            "code": "  test('default', () => {\n    const stack = new Stack();\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const integration = new WebSocketLambdaIntegration('Integration', handler);\n    const authorizer = new WebSocketIamAuthorizer();\n    new WebSocketApi(stack, 'WebSocketApi', {\n      connectRouteOptions: {\n        integration,\n        authorizer\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      RouteKey: '$connect',\n      AuthorizationType: 'AWS_IAM'\n    });\n  });",
            "file": "websocket/iam.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketLambdaAuthorizer"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 426
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const handler = new Function(stack, 'auth-function', {\n      runtime: Runtime.NODEJS_14_X,\n      code: Code.fromInline('exports.handler = () => {return true}'),\n      handler: 'index.handler'\n    });\n    const integration = new WebSocketLambdaIntegration('Integration', handler);\n    const authorizer = new WebSocketLambdaAuthorizer('default-authorizer', handler);\n\n    // WHEN\n    new WebSocketApi(stack, 'WebSocketApi', {\n      connectRouteOptions: {\n        integration,\n        authorizer\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      Name: 'default-authorizer',\n      AuthorizerType: 'REQUEST',\n      IdentitySource: ['route.request.header.Authorization']\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      AuthorizationType: 'CUSTOM'\n    });\n  });",
            "file": "websocket/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-authorizers/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 437
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.ApplicationLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      ConnectionId: {\n        Ref: 'HttpApiVpcLink159804837'\n      },\n      ConnectionType: 'VPC_LINK',\n      IntegrationMethod: 'ANY',\n      IntegrationUri: {\n        Ref: 'lblistener657ADDEC'\n      },\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "able to add a custom vpcLink",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 44,
                "column": 36,
                "index": 1425
            },
            "line": 44,
            "code": "  test('able to add a custom vpcLink', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const lb = new elbv2.ApplicationLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener, {\n        vpcLink\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      ConnectionId: {\n        Ref: 'VpcLink42ED6FF0'\n      },\n      ConnectionType: 'VPC_LINK',\n      IntegrationMethod: 'ANY',\n      IntegrationUri: {\n        Ref: 'lblistener657ADDEC'\n      },\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "method option is correctly recognized",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 85,
                "column": 45,
                "index": 2511
            },
            "line": 85,
            "code": "  test('method option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.ApplicationLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener, {\n        method: HttpMethod.PATCH\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationMethod: 'PATCH'\n    });\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "fails when imported ALB is used without specifying load balancer",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 114,
                "column": 72,
                "index": 3338
            },
            "line": 114,
            "code": "  test('fails when imported ALB is used without specifying load balancer', () => {\n    const stack = new Stack();\n    const securityGroup = ec2.SecurityGroup.fromSecurityGroupId(stack, 'MySecurityGroup', 'sg-903004f8');\n    const listener = elbv2.ApplicationListener.fromApplicationListenerAttributes(stack, 'Listener', {\n      listenerArn: 'arn:aws:elasticloadbalancing:us-east-1:012345655:listener/app/myloadbalancer/lb-12345/listener-12345',\n      securityGroup\n    });\n    const api = new HttpApi(stack, 'HttpApi');\n    expect(() => new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener),\n      routeKey: HttpRouteKey.with('/pets')\n    })).toThrow(/vpcLink property must be specified/);\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "tlsConfig option is correctly recognized",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 128,
                "column": 48,
                "index": 4091
            },
            "line": 128,
            "code": "  test('tlsConfig option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.ApplicationLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener, {\n        secureServerName: 'name-to-verify'\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      TlsConfig: {\n        ServerNameToVerify: 'name-to-verify'\n      }\n    });\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "parameterMapping option is correctly recognized",
            "suites": [
                "HttpAlbIntegration"
            ],
            "updatePoint": {
                "line": 159,
                "column": 55,
                "index": 4950
            },
            "line": 159,
            "code": "  test('parameterMapping option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.ApplicationLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpAlbIntegration('Integration', listener, {\n        parameterMapping: new ParameterMapping().appendHeader('header2', MappingValue.requestHeader('header1')).removeHeader('header1')\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      RequestParameters: {\n        'append:header.header2': '$request.header.header1',\n        'remove:header.header1': ''\n      }\n    });\n  });",
            "file": "http/alb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpProxyIntegration"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15,
                "index": 381
            },
            "line": 6,
            "code": "  test('default', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyRoute', {\n      httpApi: api,\n      integration: new HttpUrlIntegration('Integration', 'some-target-url'),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      IntegrationUri: 'some-target-url',\n      PayloadFormatVersion: '1.0',\n      IntegrationMethod: 'ANY'\n    });\n  });",
            "file": "http/http-proxy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "method option is correctly recognized",
            "suites": [
                "HttpProxyIntegration"
            ],
            "updatePoint": {
                "line": 21,
                "column": 45,
                "index": 954
            },
            "line": 21,
            "code": "  test('method option is correctly recognized', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyRoute', {\n      httpApi: api,\n      integration: new HttpUrlIntegration('Integration', 'some-target-url', {\n        method: HttpMethod.PATCH\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationMethod: 'PATCH'\n    });\n  });",
            "file": "http/http-proxy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "custom payload format version is allowed",
            "suites": [
                "HttpProxyIntegration"
            ],
            "updatePoint": {
                "line": 35,
                "column": 48,
                "index": 1463
            },
            "line": 35,
            "code": "  test('custom payload format version is allowed', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpIntegration(stack, 'HttpInteg', {\n      payloadFormatVersion: PayloadFormatVersion.custom('99.99'),\n      httpApi: api,\n      integrationType: HttpIntegrationType.HTTP_PROXY,\n      integrationUri: 'some-target-url'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      IntegrationUri: 'some-target-url',\n      PayloadFormatVersion: '99.99'\n    });\n  });",
            "file": "http/http-proxy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "HttpIntegration without payloadFormatVersion is allowed",
            "suites": [
                "HttpProxyIntegration"
            ],
            "updatePoint": {
                "line": 50,
                "column": 63,
                "index": 2066
            },
            "line": 50,
            "code": "  test('HttpIntegration without payloadFormatVersion is allowed', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpIntegration(stack, 'HttpInteg', {\n      httpApi: api,\n      integrationType: HttpIntegrationType.HTTP_PROXY,\n      integrationUri: 'some-target-url'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      IntegrationUri: 'some-target-url'\n    });\n  });",
            "file": "http/http-proxy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "parameterMapping is correctly recognized",
            "suites": [
                "HttpProxyIntegration"
            ],
            "updatePoint": {
                "line": 63,
                "column": 48,
                "index": 2551
            },
            "line": 63,
            "code": "  test('parameterMapping is correctly recognized', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpIntegration(stack, 'HttpInteg', {\n      httpApi: api,\n      integrationType: HttpIntegrationType.HTTP_PROXY,\n      integrationUri: 'some-target-url',\n      parameterMapping: new ParameterMapping().appendHeader('header2', MappingValue.requestHeader('header1')).removeHeader('header1')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      IntegrationUri: 'some-target-url',\n      RequestParameters: {\n        'append:header.header2': '$request.header.header1',\n        'remove:header.header1': ''\n      }\n    });\n  });",
            "file": "http/http-proxy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "LambdaProxyIntegration"
            ],
            "updatePoint": {
                "line": 7,
                "column": 15,
                "index": 414
            },
            "line": 7,
            "code": "  test('default', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    const fooFn = fooFunction(stack, 'Fn');\n    new HttpRoute(stack, 'LambdaProxyRoute', {\n      httpApi: api,\n      integration: new HttpLambdaIntegration('Integration', fooFn),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'AWS_PROXY',\n      IntegrationUri: stack.resolve(fooFn.functionArn),\n      PayloadFormatVersion: '2.0'\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "payloadFormatVersion selection",
            "suites": [
                "LambdaProxyIntegration"
            ],
            "updatePoint": {
                "line": 22,
                "column": 38,
                "index": 999
            },
            "line": 22,
            "code": "  test('payloadFormatVersion selection', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'LambdaProxyRoute', {\n      httpApi: api,\n      integration: new HttpLambdaIntegration('Integration', fooFunction(stack, 'Fn'), {\n        payloadFormatVersion: PayloadFormatVersion.VERSION_1_0\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "parameterMapping selection",
            "suites": [
                "LambdaProxyIntegration"
            ],
            "updatePoint": {
                "line": 36,
                "column": 34,
                "index": 1537
            },
            "line": 36,
            "code": "  test('parameterMapping selection', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'LambdaProxyRoute', {\n      httpApi: api,\n      integration: new HttpLambdaIntegration('Integration', fooFunction(stack, 'Fn'), {\n        parameterMapping: new ParameterMapping().appendHeader('header2', MappingValue.requestHeader('header1')).removeHeader('header1')\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      RequestParameters: {\n        'append:header.header2': '$request.header.header1',\n        'remove:header.header1': ''\n      }\n    });\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "no dependency cycles",
            "suites": [
                "LambdaProxyIntegration"
            ],
            "updatePoint": {
                "line": 53,
                "column": 28,
                "index": 2239
            },
            "line": 53,
            "code": "  test('no dependency cycles', () => {\n    const app = new App();\n    const lambdaStack = new Stack(app, 'lambdaStack');\n    const fooFn = fooFunction(lambdaStack, 'Fn');\n    const apigwStack = new Stack(app, 'apigwStack');\n    new HttpApi(apigwStack, 'httpApi', {\n      defaultIntegration: new HttpLambdaIntegration('Integration', fooFn)\n    });\n    expect(() => app.synth()).not.toThrow();\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "multiple routes for the same lambda integration",
            "suites": [
                "LambdaProxyIntegration"
            ],
            "updatePoint": {
                "line": 63,
                "column": 55,
                "index": 2664
            },
            "line": 63,
            "code": "  test('multiple routes for the same lambda integration', () => {\n    const app = new App();\n    const lambdaStack = new Stack(app, 'lambdaStack');\n    const fooFn = fooFunction(lambdaStack, 'Fn');\n    const stack = new Stack(app, 'apigwStack');\n    const api = new HttpApi(stack, 'httpApi');\n    const integration = new HttpLambdaIntegration('Integration', fooFn);\n    api.addRoutes({\n      path: '/foo',\n      integration\n    });\n    api.addRoutes({\n      path: '/bar',\n      integration\n    });\n\n    // Make sure we have two permissions -- one for each method -- but a single integration\n    Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Permission', {\n      SourceArn: {\n        'Fn::Join': ['', Match.arrayWith([':execute-api:', '/*/*/foo'])]\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Permission', {\n      SourceArn: {\n        'Fn::Join': ['', Match.arrayWith([':execute-api:', '/*/*/bar'])]\n      }\n    });\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Integration', 1);\n  });",
            "file": "http/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 437
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.NetworkLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      ConnectionId: {\n        Ref: 'HttpApiVpcLink159804837'\n      },\n      ConnectionType: 'VPC_LINK',\n      IntegrationMethod: 'ANY',\n      IntegrationUri: {\n        Ref: 'lblistener657ADDEC'\n      },\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "able to add a custom vpcLink",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 44,
                "column": 36,
                "index": 1421
            },
            "line": 44,
            "code": "  test('able to add a custom vpcLink', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const lb = new elbv2.NetworkLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener, {\n        vpcLink\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      ConnectionId: {\n        Ref: 'VpcLink42ED6FF0'\n      },\n      ConnectionType: 'VPC_LINK',\n      IntegrationMethod: 'ANY',\n      IntegrationUri: {\n        Ref: 'lblistener657ADDEC'\n      },\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "method option is correctly recognized",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 85,
                "column": 45,
                "index": 2503
            },
            "line": 85,
            "code": "  test('method option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.NetworkLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener, {\n        method: HttpMethod.PATCH\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationMethod: 'PATCH'\n    });\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "fails when imported NLB is used without specifying vpcLink",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 114,
                "column": 66,
                "index": 3320
            },
            "line": 114,
            "code": "  test('fails when imported NLB is used without specifying vpcLink', () => {\n    const stack = new Stack();\n    const listener = elbv2.NetworkListener.fromNetworkListenerArn(stack, 'Listener', 'arn:aws:elasticloadbalancing:us-east-1:012345655:listener/net/myloadbalancer/lb-12345/listener-12345');\n    const api = new HttpApi(stack, 'HttpApi');\n    expect(() => new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener),\n      routeKey: HttpRouteKey.with('/pets')\n    })).toThrow(/vpcLink property must be specified/);\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "tlsConfig option is correctly recognized",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 124,
                "column": 48,
                "index": 3904
            },
            "line": 124,
            "code": "  test('tlsConfig option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.NetworkLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener, {\n        secureServerName: 'name-to-verify'\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      TlsConfig: {\n        ServerNameToVerify: 'name-to-verify'\n      }\n    });\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "paramaterMapping option is correctly recognized",
            "suites": [
                "HttpNlbIntegration"
            ],
            "updatePoint": {
                "line": 155,
                "column": 55,
                "index": 4759
            },
            "line": 155,
            "code": "  test('paramaterMapping option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const lb = new elbv2.NetworkLoadBalancer(stack, 'lb', {\n      vpc\n    });\n    const listener = lb.addListener('listener', {\n      port: 80\n    });\n    listener.addTargets('target', {\n      port: 80\n    });\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpNlbIntegration('Integration', listener, {\n        parameterMapping: new ParameterMapping().appendHeader('header2', MappingValue.requestHeader('header1')).removeHeader('header1')\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      RequestParameters: {\n        'append:header.header2': '$request.header.header1',\n        'remove:header.header1': ''\n      }\n    });\n  });",
            "file": "http/nlb.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpServiceDiscoveryIntegration"
            ],
            "updatePoint": {
                "line": 8,
                "column": 15,
                "index": 468
            },
            "line": 8,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const namespace = new servicediscovery.PrivateDnsNamespace(stack, 'Namespace', {\n      name: 'foobar.com',\n      vpc\n    });\n    const service = namespace.createService('Service');\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpServiceDiscoveryIntegration('Integration', service, {\n        vpcLink\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'HTTP_PROXY',\n      ConnectionId: {\n        Ref: 'VpcLink42ED6FF0'\n      },\n      ConnectionType: 'VPC_LINK',\n      IntegrationMethod: 'ANY',\n      IntegrationUri: {\n        'Fn::GetAtt': ['NamespaceServiceCABDF534', 'Arn']\n      },\n      PayloadFormatVersion: '1.0'\n    });\n  });",
            "file": "http/service-discovery.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "method option is correctly recognized",
            "suites": [
                "HttpServiceDiscoveryIntegration"
            ],
            "updatePoint": {
                "line": 45,
                "column": 45,
                "index": 1561
            },
            "line": 45,
            "code": "  test('method option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const namespace = new servicediscovery.PrivateDnsNamespace(stack, 'Namespace', {\n      name: 'foobar.com',\n      vpc\n    });\n    const service = namespace.createService('Service');\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpServiceDiscoveryIntegration('Integration', service, {\n        vpcLink,\n        method: HttpMethod.PATCH\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationMethod: 'PATCH'\n    });\n  });",
            "file": "http/service-discovery.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "fails if vpcLink is not specified",
            "suites": [
                "HttpServiceDiscoveryIntegration"
            ],
            "updatePoint": {
                "line": 74,
                "column": 41,
                "index": 2427
            },
            "line": 74,
            "code": "  test('fails if vpcLink is not specified', () => {\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const namespace = new servicediscovery.PrivateDnsNamespace(stack, 'Namespace', {\n      name: 'foobar.com',\n      vpc\n    });\n    const service = namespace.createService('Service');\n    const api = new HttpApi(stack, 'HttpApi');\n    expect(() => new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpServiceDiscoveryIntegration('Integration', service, {\n        method: HttpMethod.PATCH\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    })).toThrow(/vpcLink property is mandatory/);\n  });",
            "file": "http/service-discovery.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "tlsConfig option is correctly recognized",
            "suites": [
                "HttpServiceDiscoveryIntegration"
            ],
            "updatePoint": {
                "line": 91,
                "column": 48,
                "index": 3100
            },
            "line": 91,
            "code": "  test('tlsConfig option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const namespace = new servicediscovery.PrivateDnsNamespace(stack, 'Namespace', {\n      name: 'foobar.com',\n      vpc\n    });\n    const service = namespace.createService('Service');\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpServiceDiscoveryIntegration('Integration', service, {\n        vpcLink,\n        secureServerName: 'name-to-verify'\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      TlsConfig: {\n        ServerNameToVerify: 'name-to-verify'\n      }\n    });\n  });",
            "file": "http/service-discovery.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "parameterMapping option is correctly recognized",
            "suites": [
                "HttpServiceDiscoveryIntegration"
            ],
            "updatePoint": {
                "line": 122,
                "column": 55,
                "index": 4029
            },
            "line": 122,
            "code": "  test('parameterMapping option is correctly recognized', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    const namespace = new servicediscovery.PrivateDnsNamespace(stack, 'Namespace', {\n      name: 'foobar.com',\n      vpc\n    });\n    const service = namespace.createService('Service');\n\n    // WHEN\n    const api = new HttpApi(stack, 'HttpApi');\n    new HttpRoute(stack, 'HttpProxyPrivateRoute', {\n      httpApi: api,\n      integration: new HttpServiceDiscoveryIntegration('Integration', service, {\n        vpcLink,\n        parameterMapping: new ParameterMapping().appendHeader('header2', MappingValue.requestHeader('header1')).removeHeader('header1')\n      }),\n      routeKey: HttpRouteKey.with('/pets')\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      RequestParameters: {\n        'append:header.header2': '$request.header.header1',\n        'remove:header.header1': ''\n      }\n    });\n  });",
            "file": "http/service-discovery.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "LambdaWebSocketIntegration"
            ],
            "updatePoint": {
                "line": 7,
                "column": 15,
                "index": 337
            },
            "line": 7,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const fooFn = fooFunction(stack, 'Fn');\n\n    // WHEN\n    new WebSocketApi(stack, 'Api', {\n      connectRouteOptions: {\n        integration: new WebSocketLambdaIntegration('Integration', fooFn)\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'AWS_PROXY',\n      IntegrationUri: {\n        'Fn::Join': ['', ['arn:', {\n          Ref: 'AWS::Partition'\n        }, ':apigateway:', {\n          Ref: 'AWS::Region'\n        }, ':lambda:path/2015-03-31/functions/', {\n          'Fn::GetAtt': ['Fn9270CBC0', 'Arn']\n        }, '/invocations']]\n      }\n    });\n  });",
            "file": "websocket/lambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default",
            "suites": [
                "MockWebSocketIntegration"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15,
                "index": 267
            },
            "line": 6,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new WebSocketApi(stack, 'Api', {\n      defaultRouteOptions: {\n        integration: new WebSocketMockIntegration('DefaultIntegration')\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      IntegrationType: 'MOCK',\n      IntegrationUri: ''\n    });\n  });",
            "file": "websocket/mock.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2-integrations/test"
        },
        {
            "name": "default stage",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 8,
                "column": 21,
                "index": 382
            },
            "line": 8,
            "code": "  test('default stage', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api');\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    new ApiMapping(stack, 'Mapping', {\n      api,\n      domainName: dn\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::ApiMapping', {\n      ApiId: {\n        Ref: 'ApiF70053CD'\n      },\n      Stage: '$default'\n    });\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "beta stage mapping",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 26,
                "column": 26,
                "index": 901
            },
            "line": 26,
            "code": "  test('beta stage mapping', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api', {\n      createDefaultStage: false\n    });\n    const beta = api.addStage('beta', {\n      stageName: 'beta'\n    });\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    new ApiMapping(stack, 'Mapping', {\n      api,\n      domainName: dn,\n      stage: beta,\n      apiMappingKey: 'beta'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::ApiMapping', {\n      ApiId: {\n        Ref: 'ApiF70053CD'\n      },\n      Stage: 'beta',\n      ApiMappingKey: 'beta'\n    });\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "apiMappingKey validation - empty string not allowed",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 52,
                "column": 59,
                "index": 1639
            },
            "line": 52,
            "code": "  test('apiMappingKey validation - empty string not allowed', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api');\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    expect(() => {\n      new ApiMapping(stack, 'Mapping', {\n        api,\n        domainName: dn,\n        apiMappingKey: ''\n      });\n    }).toThrow(/empty string for api mapping key not allowed/);\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "import mapping",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 67,
                "column": 22,
                "index": 2102
            },
            "line": 67,
            "code": "  test('import mapping', () => {\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api');\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    const mapping = new ApiMapping(stack, 'Mapping', {\n      api,\n      domainName: dn\n    });\n    const imported = ApiMapping.fromApiMappingAttributes(stack, 'ImportedMapping', {\n      apiMappingId: mapping.apiMappingId\n    });\n    expect(imported.apiMappingId).toEqual(mapping.apiMappingId);\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "stage validation - throws if defaultStage not available for HttpApi",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 83,
                "column": 75,
                "index": 2715
            },
            "line": 83,
            "code": "  test('stage validation - throws if defaultStage not available for HttpApi', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api', {\n      createDefaultStage: false\n    });\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n\n    // WHEN\n    expect(() => {\n      new ApiMapping(stack, 'Mapping', {\n        api,\n        domainName: dn\n      });\n    }).toThrow(/stage property must be specified/);\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "stage validation - throws if stage not provided for WebSocketApi",
            "suites": [
                "ApiMapping"
            ],
            "updatePoint": {
                "line": 102,
                "column": 72,
                "index": 3256
            },
            "line": 102,
            "code": "  test('stage validation - throws if stage not provided for WebSocketApi', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api');\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n\n    // WHEN\n    expect(() => {\n      new ApiMapping(stack, 'Mapping', {\n        api,\n        domainName: dn\n      });\n    }).toThrow(/stage property must be specified/);\n  });",
            "file": "common/api-mapping.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpAuthorizer"
            ],
            "updatePoint": {
                "line": 5,
                "column": 15,
                "index": 212
            },
            "line": 5,
            "code": "  test('default', () => {\n    const stack = new Stack();\n    const httpApi = new HttpApi(stack, 'HttpApi');\n    new HttpAuthorizer(stack, 'HttpAuthorizer', {\n      httpApi,\n      identitySource: ['identitysource.1', 'identitysource.2'],\n      type: HttpAuthorizerType.JWT,\n      jwtAudience: ['audience.1', 'audience.2'],\n      jwtIssuer: 'issuer'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      ApiId: stack.resolve(httpApi.apiId),\n      Name: 'HttpAuthorizer',\n      AuthorizerType: 'JWT',\n      IdentitySource: ['identitysource.1', 'identitysource.2']\n    });\n  });",
            "file": "http/authorizer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "authorizer name",
            "suites": [
                "HttpAuthorizer"
            ],
            "updatePoint": {
                "line": 22,
                "column": 23,
                "index": 842
            },
            "line": 22,
            "code": "  test('authorizer name', () => {\n    const stack = new Stack();\n    const httpApi = new HttpApi(stack, 'HttpApi');\n    new HttpAuthorizer(stack, 'HttpAuthorizer', {\n      httpApi,\n      authorizerName: 'my-authorizer',\n      identitySource: ['identitysource.1', 'identitysource.2'],\n      type: HttpAuthorizerType.JWT,\n      jwtAudience: ['audience.1', 'audience.2'],\n      jwtIssuer: 'issuer'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n      Name: 'my-authorizer'\n    });\n  });",
            "file": "http/authorizer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "audience and issuer",
            "suites": [
                "HttpAuthorizer",
                "jwt configuration"
            ],
            "updatePoint": {
                "line": 38,
                "column": 29,
                "index": 1420
            },
            "line": 38,
            "code": "    test('audience and issuer', () => {\n      const stack = new Stack();\n      const httpApi = new HttpApi(stack, 'HttpApi');\n      new HttpAuthorizer(stack, 'HttpAuthorizer', {\n        httpApi,\n        identitySource: ['identitysource.1', 'identitysource.2'],\n        type: HttpAuthorizerType.JWT,\n        jwtAudience: ['audience.1', 'audience.2'],\n        jwtIssuer: 'issuer'\n      });\n      Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n        JwtConfiguration: {\n          Audience: ['audience.1', 'audience.2'],\n          Issuer: 'issuer'\n        }\n      });\n    });",
            "file": "http/authorizer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "HttpAuthorizer",
                "lambda"
            ],
            "updatePoint": {
                "line": 57,
                "column": 15,
                "index": 2051
            },
            "line": 57,
            "code": "    it('default', () => {\n      const stack = new Stack();\n      const httpApi = new HttpApi(stack, 'HttpApi');\n      new HttpAuthorizer(stack, 'HttpAuthorizer', {\n        httpApi,\n        identitySource: ['identitysource.1', 'identitysource.2'],\n        type: HttpAuthorizerType.LAMBDA,\n        authorizerUri: 'arn:cool-lambda-arn'\n      });\n      Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n        AuthorizerType: 'REQUEST',\n        AuthorizerPayloadFormatVersion: '2.0',\n        AuthorizerUri: 'arn:cool-lambda-arn'\n      });\n    });",
            "file": "http/authorizer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "create domain name correctly",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 11,
                "column": 36,
                "index": 598
            },
            "line": 11,
            "code": "  test('create domain name correctly', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }]\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "throws when domainName is empty string",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 30,
                "column": 46,
                "index": 1152
            },
            "line": 30,
            "code": "  test('throws when domainName is empty string', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    const t = () => {\n      new DomainName(stack, 'DomainName', {\n        domainName: '',\n        certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n      });\n    };\n\n    // THEN\n    expect(t).toThrow(/empty string for domainName not allowed/);\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "import domain name correctly",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 45,
                "column": 36,
                "index": 1524
            },
            "line": 45,
            "code": "  test('import domain name correctly', () => {\n    // GIVEN\n    const stack = new Stack();\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n\n    // WHEN\n    const imported = DomainName.fromDomainNameAttributes(stack, 'dn', {\n      name: dn.name,\n      regionalDomainName: dn.regionalDomainName,\n      regionalHostedZoneId: dn.regionalHostedZoneId\n    });\n\n    // THEN;\n    expect(imported.name).toEqual(dn.name);\n    expect(imported.regionalDomainName).toEqual(dn.regionalDomainName);\n    expect(imported.regionalHostedZoneId).toEqual(dn.regionalHostedZoneId);\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "addStage with domainNameMapping",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 65,
                "column": 39,
                "index": 2198
            },
            "line": 65,
            "code": "  test('addStage with domainNameMapping', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new HttpApi(stack, 'Api', {\n      createDefaultStage: true\n    });\n\n    // WHEN\n    const dn = new DomainName(stack, 'DN', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    api.addStage('beta', {\n      stageName: 'beta',\n      autoDeploy: true,\n      domainMapping: {\n        domainName: dn,\n        mappingKey: 'beta'\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }]\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::ApiMapping', {\n      ApiId: {\n        Ref: 'ApiF70053CD'\n      },\n      DomainName: {\n        Ref: 'DNFDC76583'\n      },\n      Stage: 'beta',\n      ApiMappingKey: 'beta'\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "api with defaultDomainMapping",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 103,
                "column": 37,
                "index": 3232
            },
            "line": 103,
            "code": "  test('api with defaultDomainMapping', () => {\n    // GIVEN\n    const stack = new Stack();\n    const dn = new DomainName(stack, 'DN', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n\n    // WHEN\n    new HttpApi(stack, 'Api', {\n      createDefaultStage: true,\n      defaultDomainMapping: {\n        domainName: dn\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }]\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::ApiMapping', {\n      ApiId: {\n        Ref: 'ApiF70053CD'\n      },\n      DomainName: {\n        Ref: 'DNFDC76583'\n      },\n      Stage: '$default'\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "throws when defaultDomainMapping enabled with createDefaultStage disabled",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 137,
                "column": 81,
                "index": 4182
            },
            "line": 137,
            "code": "  test('throws when defaultDomainMapping enabled with createDefaultStage disabled', () => {\n    // GIVEN\n    const stack = new Stack();\n    const dn = new DomainName(stack, 'DN', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn)\n    });\n    const t = () => {\n      new HttpApi(stack, 'Api', {\n        createDefaultStage: false,\n        defaultDomainMapping: {\n          domainName: dn\n        }\n      });\n    };\n\n    // WHEN/THEN\n    expect(t).toThrow('defaultDomainMapping not supported with createDefaultStage disabled');\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "accepts a mutual TLS configuration",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 156,
                "column": 42,
                "index": 4717
            },
            "line": 156,
            "code": "  test('accepts a mutual TLS configuration', () => {\n    // GIVEN\n    const stack = new Stack();\n    const bucket = Bucket.fromBucketName(stack, 'testBucket', 'example-bucket');\n\n    // WHEN\n    new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn),\n      mtls: {\n        bucket,\n        key: 'someca.pem'\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }],\n      MutualTlsAuthentication: {\n        TruststoreUri: 's3://example-bucket/someca.pem'\n      }\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "mTLS should allow versions to be set on the s3 bucket",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 183,
                "column": 61,
                "index": 5530
            },
            "line": 183,
            "code": "  test('mTLS should allow versions to be set on the s3 bucket', () => {\n    // GIVEN\n    const stack = new Stack();\n    const bucket = Bucket.fromBucketName(stack, 'testBucket', 'example-bucket');\n\n    // WHEN\n    new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn),\n      mtls: {\n        bucket,\n        key: 'someca.pem',\n        version: 'version'\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }],\n      MutualTlsAuthentication: {\n        TruststoreUri: 's3://example-bucket/someca.pem',\n        TruststoreVersion: 'version'\n      }\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "domain with mutual tls configuration and ownership cert",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 212,
                "column": 63,
                "index": 6411
            },
            "line": 212,
            "code": "  test('domain with mutual tls configuration and ownership cert', () => {\n    // GIVEN\n    const stack = new Stack();\n    const bucket = Bucket.fromBucketName(stack, 'testBucket', 'example-bucket');\n\n    // WHEN\n    new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert2', certArn2),\n      ownershipCertificate: Certificate.fromCertificateArn(stack, 'ownershipCert', ownershipCertArn),\n      endpointType: EndpointType.REGIONAL,\n      securityPolicy: SecurityPolicy.TLS_1_2,\n      mtls: {\n        bucket,\n        key: 'someca.pem',\n        version: 'version'\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate2',\n        EndpointType: 'REGIONAL',\n        SecurityPolicy: 'TLS_1_2',\n        OwnershipVerificationCertificateArn: 'arn:aws:acm:us-east-1:111111111111:ownershipcertificate'\n      }],\n      MutualTlsAuthentication: {\n        TruststoreUri: 's3://example-bucket/someca.pem',\n        TruststoreVersion: 'version'\n      }\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "throws when ownerhsip cert is used for non-mtls domain",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 246,
                "column": 62,
                "index": 7624
            },
            "line": 246,
            "code": "  test('throws when ownerhsip cert is used for non-mtls domain', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    const t = () => {\n      new DomainName(stack, 'DomainName', {\n        domainName,\n        certificate: Certificate.fromCertificateArn(stack, 'cert2', certArn2),\n        ownershipCertificate: Certificate.fromCertificateArn(stack, 'ownershipCert', ownershipCertArn)\n      });\n    };\n\n    // THEN\n    expect(t).toThrow(/ownership certificate can only be used with mtls domains/);\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "add new configuration to a domain name for migration",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 262,
                "column": 60,
                "index": 8139
            },
            "line": 262,
            "code": "  test('add new configuration to a domain name for migration', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    const dn = new DomainName(stack, 'DomainName', {\n      domainName,\n      certificate: Certificate.fromCertificateArn(stack, 'cert', certArn),\n      endpointType: EndpointType.REGIONAL\n    });\n    dn.addEndpoint({\n      certificate: Certificate.fromCertificateArn(stack, 'cert2', certArn2),\n      endpointType: EndpointType.EDGE\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::DomainName', {\n      DomainName: 'example.com',\n      DomainNameConfigurations: [{\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate',\n        EndpointType: 'REGIONAL'\n      }, {\n        CertificateArn: 'arn:aws:acm:us-east-1:111111111111:certificate2',\n        EndpointType: 'EDGE'\n      }]\n    });\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "throws when endpoint types for two domain name configurations are the same",
            "suites": [
                "DomainName"
            ],
            "updatePoint": {
                "line": 289,
                "column": 82,
                "index": 9042
            },
            "line": 289,
            "code": "  test('throws when endpoint types for two domain name configurations are the same', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    const t = () => {\n      const dn = new DomainName(stack, 'DomainName', {\n        domainName,\n        certificate: Certificate.fromCertificateArn(stack, 'cert', certArn),\n        endpointType: EndpointType.REGIONAL\n      });\n      dn.addEndpoint({\n        certificate: Certificate.fromCertificateArn(stack, 'cert2', certArn2)\n      });\n    };\n\n    // THEN\n    expect(t).toThrow(/an endpoint with type REGIONAL already exists/);\n  });",
            "file": "http/domain-name.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default setup",
            "suites": [
                "VpcLink"
            ],
            "updatePoint": {
                "line": 6,
                "column": 21,
                "index": 219
            },
            "line": 6,
            "code": "  test('default setup', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new VpcLink(stack, 'VpcLink', {\n      vpcLinkName: 'MyLink',\n      vpc\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::VpcLink', {\n      Name: 'MyLink',\n      SubnetIds: [{\n        Ref: 'VPCPrivateSubnet1Subnet8BCA10E0'\n      }, {\n        Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A'\n      }],\n      SecurityGroupIds: []\n    });\n  });",
            "file": "http/vpc-link.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "subnets and security security groups in props",
            "suites": [
                "VpcLink"
            ],
            "updatePoint": {
                "line": 28,
                "column": 53,
                "index": 761
            },
            "line": 28,
            "code": "  test('subnets and security security groups in props', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const subnet1 = new ec2.Subnet(stack, 'subnet1', {\n      vpcId: vpc.vpcId,\n      availabilityZone: vpc.availabilityZones[0],\n      cidrBlock: vpc.vpcCidrBlock\n    });\n    const subnet2 = new ec2.Subnet(stack, 'subnet2', {\n      vpcId: vpc.vpcId,\n      availabilityZone: vpc.availabilityZones[1],\n      cidrBlock: vpc.vpcCidrBlock\n    });\n    const sg1 = new ec2.SecurityGroup(stack, 'SG1', {\n      vpc\n    });\n    const sg2 = new ec2.SecurityGroup(stack, 'SG2', {\n      vpc\n    });\n    const sg3 = new ec2.SecurityGroup(stack, 'SG3', {\n      vpc\n    });\n\n    // WHEN\n    new VpcLink(stack, 'VpcLink', {\n      vpc,\n      subnets: {\n        subnets: [subnet1, subnet2]\n      },\n      securityGroups: [sg1, sg2, sg3]\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::VpcLink', {\n      Name: 'VpcLink',\n      SubnetIds: [{\n        Ref: 'subnet1Subnet16A4B3BD'\n      }, {\n        Ref: 'subnet2SubnetF9569CD3'\n      }],\n      SecurityGroupIds: [{\n        'Fn::GetAtt': ['SG1BA065B6E', 'GroupId']\n      }, {\n        'Fn::GetAtt': ['SG20CE3219C', 'GroupId']\n      }, {\n        'Fn::GetAtt': ['SG351782A25', 'GroupId']\n      }]\n    });\n  });",
            "file": "http/vpc-link.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "subnets can be added using addSubnets",
            "suites": [
                "VpcLink"
            ],
            "updatePoint": {
                "line": 78,
                "column": 45,
                "index": 2084
            },
            "line": 78,
            "code": "  test('subnets can be added using addSubnets', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const subnet = new ec2.Subnet(stack, 'subnet', {\n      vpcId: vpc.vpcId,\n      availabilityZone: vpc.availabilityZones[0],\n      cidrBlock: vpc.vpcCidrBlock\n    });\n\n    // WHEN\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    vpcLink.addSubnets(subnet);\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::VpcLink', {\n      Name: 'VpcLink',\n      SubnetIds: [{\n        Ref: 'VPCPrivateSubnet1Subnet8BCA10E0'\n      }, {\n        Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A'\n      }, {\n        Ref: 'subnetSubnet39D20FD5'\n      }]\n    });\n  });",
            "file": "http/vpc-link.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "security groups can be added using addSecurityGroups",
            "suites": [
                "VpcLink"
            ],
            "updatePoint": {
                "line": 106,
                "column": 60,
                "index": 2841
            },
            "line": 106,
            "code": "  test('security groups can be added using addSecurityGroups', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const sg1 = new ec2.SecurityGroup(stack, 'SG1', {\n      vpc\n    });\n    const sg2 = new ec2.SecurityGroup(stack, 'SG2', {\n      vpc\n    });\n    const sg3 = new ec2.SecurityGroup(stack, 'SG3', {\n      vpc\n    });\n\n    // WHEN\n    const vpcLink = new VpcLink(stack, 'VpcLink', {\n      vpc\n    });\n    vpcLink.addSecurityGroups(sg1, sg2, sg3);\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::VpcLink', {\n      Name: 'VpcLink',\n      SubnetIds: [{\n        Ref: 'VPCPrivateSubnet1Subnet8BCA10E0'\n      }, {\n        Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A'\n      }],\n      SecurityGroupIds: [{\n        'Fn::GetAtt': ['SG1BA065B6E', 'GroupId']\n      }, {\n        'Fn::GetAtt': ['SG20CE3219C', 'GroupId']\n      }, {\n        'Fn::GetAtt': ['SG351782A25', 'GroupId']\n      }]\n    });\n  });",
            "file": "http/vpc-link.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "importing an existing vpc link",
            "suites": [
                "VpcLink"
            ],
            "updatePoint": {
                "line": 143,
                "column": 38,
                "index": 3796
            },
            "line": 143,
            "code": "  test('importing an existing vpc link', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    VpcLink.fromVpcLinkAttributes(stack, 'ImportedVpcLink', {\n      vpcLinkId: 'vpclink-id',\n      vpc: ec2.Vpc.fromVpcAttributes(stack, 'ImportedVpc', {\n        vpcId: 'vpc-12345',\n        availabilityZones: ['us-east-1']\n      })\n    });\n\n    // THEN\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::VpcLink', 0);\n  });",
            "file": "http/vpc-link.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15,
                "index": 390
            },
            "line": 6,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new WebSocketApi(stack, 'api');\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Api', {\n      Name: 'api',\n      ProtocolType: 'WEBSOCKET'\n    });\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Stage', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Route', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Integration', 0);\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "apiKeySelectionExpression: given a value",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 22,
                "column": 48,
                "index": 940
            },
            "line": 22,
            "code": "  test('apiKeySelectionExpression: given a value', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new WebSocketApi(stack, 'api', {\n      apiKeySelectionExpression: WebSocketApiKeySelectionExpression.AUTHORIZER_USAGE_IDENTIFIER_KEY\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Api', {\n      ApiKeySelectionExpression: '$context.authorizer.usageIdentifierKey',\n      Name: 'api',\n      ProtocolType: 'WEBSOCKET'\n    });\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Stage', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Route', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::ApiGatewayV2::Integration', 0);\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "addRoute: adds a route with passed key",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 41,
                "column": 46,
                "index": 1672
            },
            "line": 41,
            "code": "  test('addRoute: adds a route with passed key', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api');\n\n    // WHEN\n    api.addRoute('myroute', {\n      integration: new DummyIntegration()\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(api.apiId),\n      RouteKey: 'myroute'\n    });\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "addRoute: adds a route with passed key and allows it to return a response",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 57,
                "column": 81,
                "index": 2123
            },
            "line": 57,
            "code": "  test('addRoute: adds a route with passed key and allows it to return a response', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api');\n\n    // WHEN\n    const route = api.addRoute('myroute', {\n      integration: new DummyIntegration(),\n      returnResponse: true\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(api.apiId),\n      RouteKey: 'myroute',\n      RouteResponseSelectionExpression: '$default'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::RouteResponse', {\n      ApiId: stack.resolve(api.apiId),\n      RouteId: stack.resolve(route.routeId),\n      RouteResponseKey: '$default'\n    });\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "connectRouteOptions: adds a $connect route",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 80,
                "column": 50,
                "index": 2854
            },
            "line": 80,
            "code": "  test('connectRouteOptions: adds a $connect route', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api', {\n      connectRouteOptions: {\n        integration: new DummyIntegration()\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(api.apiId),\n      RouteKey: '$connect'\n    });\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "disconnectRouteOptions: adds a $disconnect route",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 95,
                "column": 56,
                "index": 3278
            },
            "line": 95,
            "code": "  test('disconnectRouteOptions: adds a $disconnect route', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api', {\n      disconnectRouteOptions: {\n        integration: new DummyIntegration()\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(api.apiId),\n      RouteKey: '$disconnect'\n    });\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "defaultRouteOptions: adds a $default route",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 110,
                "column": 50,
                "index": 3702
            },
            "line": 110,
            "code": "  test('defaultRouteOptions: adds a $default route', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'api', {\n      defaultRouteOptions: {\n        integration: new DummyIntegration()\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(api.apiId),\n      RouteKey: '$default'\n    });\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "import",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 125,
                "column": 14,
                "index": 4084
            },
            "line": 125,
            "code": "  test('import', () => {\n    // GIVEN\n    const stack = new Stack();\n    const imported = WebSocketApi.fromWebSocketApiAttributes(stack, 'imported', {\n      webSocketId: 'ws-1234',\n      apiEndpoint: 'api-endpoint'\n    });\n\n    // THEN\n    expect(imported.apiId).toEqual('ws-1234');\n    expect(imported.apiEndpoint).toEqual('api-endpoint');\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "apiEndpoint for imported",
            "suites": [
                "WebSocketApi"
            ],
            "updatePoint": {
                "line": 137,
                "column": 32,
                "index": 4449
            },
            "line": 137,
            "code": "  test('apiEndpoint for imported', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = WebSocketApi.fromWebSocketApiAttributes(stack, 'imported', {\n      webSocketId: 'api-1234'\n    });\n\n    // THEN\n    expect(() => api.apiEndpoint).toThrow(/apiEndpoint is not configured/);\n  });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "adds an IAM policy to the principal",
            "suites": [
                "WebSocketApi",
                "grantManageConnections"
            ],
            "updatePoint": {
                "line": 148,
                "column": 45,
                "index": 4804
            },
            "line": 148,
            "code": "    test('adds an IAM policy to the principal', () => {\n      // GIVEN\n      const stack = new Stack();\n      const api = new WebSocketApi(stack, 'api');\n      const principal = new User(stack, 'user');\n\n      // WHEN\n      api.grantManageConnections(principal);\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: Match.arrayWith([{\n            Action: 'execute-api:ManageConnections',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': ['', ['arn:', {\n                Ref: 'AWS::Partition'\n              }, ':execute-api:', {\n                Ref: 'AWS::Region'\n              }, ':', {\n                Ref: 'AWS::AccountId'\n              }, ':', {\n                Ref: 'apiC8550315'\n              }, '/*/*/@connections/*']]\n            }\n          }])\n        }\n      });\n    });",
            "file": "websocket/api.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketAuthorizer",
                "lambda"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15,
                "index": 261
            },
            "line": 6,
            "code": "    it('default', () => {\n      const stack = new Stack();\n      const webSocketApi = new WebSocketApi(stack, 'WebSocketApi');\n      new WebSocketAuthorizer(stack, 'WebSocketAuthorizer', {\n        webSocketApi,\n        identitySource: ['identitysource.1', 'identitysource.2'],\n        type: WebSocketAuthorizerType.LAMBDA,\n        authorizerUri: 'arn:cool-lambda-arn'\n      });\n      Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Authorizer', {\n        AuthorizerType: 'REQUEST',\n        AuthorizerUri: 'arn:cool-lambda-arn'\n      });\n    });",
            "file": "websocket/authorizer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketRoute"
            ],
            "updatePoint": {
                "line": 5,
                "column": 15,
                "index": 321
            },
            "line": 5,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const webSocketApi = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    new WebSocketRoute(stack, 'Route', {\n      webSocketApi,\n      integration: new DummyIntegration(),\n      routeKey: 'message'\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      RouteKey: 'message',\n      Target: {\n        'Fn::Join': ['', ['integrations/', {\n          Ref: 'RouteDummyIntegrationE40E82B4'\n        }]]\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      IntegrationType: 'AWS_PROXY',\n      IntegrationUri: 'some-uri'\n    });\n  });",
            "file": "websocket/route.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "Api Key is required for route when apiKeyIsRequired is true",
            "suites": [
                "WebSocketRoute"
            ],
            "updatePoint": {
                "line": 33,
                "column": 67,
                "index": 1176
            },
            "line": 33,
            "code": "  test('Api Key is required for route when apiKeyIsRequired is true', () => {\n    // GIVEN\n    const stack = new Stack();\n    const webSocketApi = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    new WebSocketRoute(stack, 'Route', {\n      webSocketApi,\n      integration: new DummyIntegration(),\n      routeKey: 'message',\n      apiKeyRequired: true\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      ApiKeyRequired: true,\n      RouteKey: 'message',\n      Target: {\n        'Fn::Join': ['', ['integrations/', {\n          Ref: 'RouteDummyIntegrationE40E82B4'\n        }]]\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      IntegrationType: 'AWS_PROXY',\n      IntegrationUri: 'some-uri'\n    });\n  });",
            "file": "websocket/route.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "integration cannot be used across WebSocketApis",
            "suites": [
                "WebSocketRoute"
            ],
            "updatePoint": {
                "line": 63,
                "column": 55,
                "index": 2075
            },
            "line": 63,
            "code": "  test('integration cannot be used across WebSocketApis', () => {\n    // GIVEN\n    const integration = new DummyIntegration();\n\n    // WHEN\n    const stack = new Stack();\n    const webSocketApi1 = new WebSocketApi(stack, 'WebSocketApi1');\n    const webSocketApi2 = new WebSocketApi(stack, 'WebSocketApi2');\n    new WebSocketRoute(stack, 'WebSocketRoute1', {\n      webSocketApi: webSocketApi1,\n      integration,\n      routeKey: 'route'\n    });\n    expect(() => new WebSocketRoute(stack, 'WebSocketRoute2', {\n      webSocketApi: webSocketApi2,\n      integration,\n      routeKey: 'route'\n    })).toThrow(/cannot be associated with multiple APIs/);\n  });",
            "file": "websocket/route.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "associating integrations in different APIs creates separate AWS::ApiGatewayV2::Integration",
            "suites": [
                "WebSocketRoute"
            ],
            "updatePoint": {
                "line": 82,
                "column": 98,
                "index": 2770
            },
            "line": 82,
            "code": "  test('associating integrations in different APIs creates separate AWS::ApiGatewayV2::Integration', () => {\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'WebSocketApi');\n    new WebSocketRoute(stack, 'WebSocketRoute1', {\n      webSocketApi: api,\n      integration: new DummyIntegration(),\n      routeKey: '/books'\n    });\n    new WebSocketRoute(stack, 'WebSocketRoute2', {\n      webSocketApi: api,\n      integration: new DummyIntegration(),\n      routeKey: '/magazines'\n    });\n    Template.fromStack(stack).hasResource('AWS::ApiGatewayV2::Integration', 2);\n  });",
            "file": "websocket/route.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default RouteResponseSelectionExpression is set if route will return a response to the client",
            "suites": [
                "WebSocketRoute"
            ],
            "updatePoint": {
                "line": 97,
                "column": 101,
                "index": 3364
            },
            "line": 97,
            "code": "  test('default RouteResponseSelectionExpression is set if route will return a response to the client', () => {\n    // GIVEN\n    const stack = new Stack();\n    const webSocketApi = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    const route = new WebSocketRoute(stack, 'Route', {\n      webSocketApi,\n      integration: new DummyIntegration(),\n      routeKey: 'message',\n      returnResponse: true\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Route', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      RouteKey: 'message',\n      RouteResponseSelectionExpression: '$default',\n      Target: {\n        'Fn::Join': ['', ['integrations/', {\n          Ref: 'RouteDummyIntegrationE40E82B4'\n        }]]\n      }\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::RouteResponse', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      RouteId: stack.resolve(route.routeId),\n      RouteResponseKey: '$default'\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Integration', {\n      ApiId: stack.resolve(webSocketApi.apiId),\n      IntegrationType: 'AWS_PROXY',\n      IntegrationUri: 'some-uri'\n    });\n  });",
            "file": "websocket/route.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "default",
            "suites": [
                "WebSocketStage"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15,
                "index": 248
            },
            "line": 6,
            "code": "  test('default', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    const defaultStage = new WebSocketStage(stack, 'Stage', {\n      webSocketApi: api,\n      stageName: 'dev'\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Stage', {\n      ApiId: stack.resolve(api.apiId),\n      StageName: 'dev'\n    });\n    expect(defaultStage.url.endsWith('/dev')).toBe(true);\n  });",
            "file": "websocket/stage.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "import",
            "suites": [
                "WebSocketStage"
            ],
            "updatePoint": {
                "line": 24,
                "column": 14,
                "index": 725
            },
            "line": 24,
            "code": "  test('import', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    const stage = new WebSocketStage(stack, 'Stage', {\n      webSocketApi: api,\n      stageName: 'dev'\n    });\n    const imported = WebSocketStage.fromWebSocketStageAttributes(stack, 'Import', {\n      stageName: stage.stageName,\n      api\n    });\n\n    // THEN\n    expect(imported.stageName).toEqual(stage.stageName);\n    expect(() => imported.url).toThrow();\n    expect(() => imported.callbackUrl).toThrow();\n  });",
            "file": "websocket/stage.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "callback URL",
            "suites": [
                "WebSocketStage"
            ],
            "updatePoint": {
                "line": 44,
                "column": 20,
                "index": 1276
            },
            "line": 44,
            "code": "  test('callback URL', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    const defaultStage = new WebSocketStage(stack, 'Stage', {\n      webSocketApi: api,\n      stageName: 'dev'\n    });\n\n    // THEN\n    expect(defaultStage.callbackUrl.endsWith('/dev')).toBe(true);\n    expect(defaultStage.callbackUrl.startsWith('https://')).toBe(true);\n  });",
            "file": "websocket/stage.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "adds an IAM policy to the principal",
            "suites": [
                "WebSocketStage",
                "grantManageConnections"
            ],
            "updatePoint": {
                "line": 60,
                "column": 45,
                "index": 1757
            },
            "line": 60,
            "code": "    test('adds an IAM policy to the principal', () => {\n      // GIVEN\n      const stack = new Stack();\n      const api = new WebSocketApi(stack, 'Api');\n      const defaultStage = new WebSocketStage(stack, 'Stage', {\n        webSocketApi: api,\n        stageName: 'dev'\n      });\n      const principal = new User(stack, 'User');\n\n      // WHEN\n      defaultStage.grantManagementApiAccess(principal);\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: Match.arrayWith([{\n            Action: 'execute-api:ManageConnections',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': ['', ['arn:', {\n                Ref: 'AWS::Partition'\n              }, ':execute-api:', {\n                Ref: 'AWS::Region'\n              }, ':', {\n                Ref: 'AWS::AccountId'\n              }, ':', {\n                Ref: 'ApiF70053CD'\n              }, `/${defaultStage.stageName}/*/@connections/*`]]\n            }\n          }])\n        }\n      });\n    });",
            "file": "websocket/stage.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "correctly sets throttle settings",
            "suites": [
                "WebSocketStage",
                "grantManageConnections"
            ],
            "updatePoint": {
                "line": 95,
                "column": 40,
                "index": 2814
            },
            "line": 95,
            "code": "  test('correctly sets throttle settings', () => {\n    // GIVEN\n    const stack = new Stack();\n    const api = new WebSocketApi(stack, 'Api');\n\n    // WHEN\n    new WebSocketStage(stack, 'DefaultStage', {\n      webSocketApi: api,\n      stageName: 'dev',\n      throttle: {\n        burstLimit: 1000,\n        rateLimit: 1000\n      }\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::ApiGatewayV2::Stage', {\n      ApiId: stack.resolve(api.apiId),\n      StageName: 'dev',\n      DefaultRouteSettings: {\n        ThrottlingBurstLimit: 1000,\n        ThrottlingRateLimit: 1000\n      }\n    });\n  });",
            "file": "websocket/stage.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apigatewayv2/test"
        },
        {
            "name": "create a service with ECR Public(image repository type: ECR_PUBLIC)",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 73
            },
            "line": 13,
            "code": "test('create a service with ECR Public(image repository type: ECR_PUBLIC)', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: { port: 8000 },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '8000',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment variables and start commands are allowed for imageConfiguration with defined port",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 106
            },
            "line": 46,
            "code": "test('custom environment variables and start commands are allowed for imageConfiguration with defined port', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        port: 8000,\n        environmentVariables: {\n          TEST_ENVIRONMENT_VARIABLE: 'test environment variable value',\n        },\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  service.addEnvironmentVariable('SECOND_ENVIRONEMENT_VARIABLE', 'second test value');\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '8000',\n          RuntimeEnvironmentVariables: [\n            {\n              Name: 'TEST_ENVIRONMENT_VARIABLE',\n              Value: 'test environment variable value',\n            },\n            {\n              Name: 'SECOND_ENVIRONEMENT_VARIABLE',\n              Value: 'second test value',\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment secrets and start commands are allowed for imageConfiguration with defined port",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 104
            },
            "line": 98,
            "code": "test('custom environment secrets and start commands are allowed for imageConfiguration with defined port', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const secret = new secretsmanager.Secret(stack, 'Secret');\n  const parameter = ssm.StringParameter.fromSecureStringParameterAttributes(stack, 'Parameter', {\n    parameterName: '/name',\n    version: 1,\n  });\n\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        port: 8000,\n        environmentSecrets: {\n          SECRET: apprunner.Secret.fromSecretsManager(secret),\n          PARAMETER: apprunner.Secret.fromSsmParameter(parameter),\n          SECRET_ID: apprunner.Secret.fromSecretsManagerVersion(secret, { versionId: 'version-id' }),\n          SECRET_STAGE: apprunner.Secret.fromSecretsManagerVersion(secret, { versionStage: 'version-stage' }),\n        },\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  service.addSecret('LATER_SECRET', apprunner.Secret.fromSecretsManager(secret, 'field'));\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '8000',\n          RuntimeEnvironmentSecrets: [\n            {\n              Name: 'SECRET',\n              Value: {\n                Ref: 'SecretA720EF05',\n              },\n            },\n            {\n              Name: 'PARAMETER',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    'arn:',\n                    {\n                      Ref: 'AWS::Partition',\n                    },\n                    ':ssm:',\n                    {\n                      Ref: 'AWS::Region',\n                    },\n                    ':',\n                    {\n                      Ref: 'AWS::AccountId',\n                    },\n                    ':parameter/name',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'SECRET_ID',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    ':::version-id',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'SECRET_STAGE',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    '::version-stage:',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'LATER_SECRET',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    ':field::',\n                  ],\n                ],\n              },\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment variables and start commands are allowed for imageConfiguration with port undefined",
            "suites": [],
            "updatePoint": {
                "line": 222,
                "column": 108
            },
            "line": 222,
            "code": "test('custom environment variables and start commands are allowed for imageConfiguration with port undefined', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        environmentVariables: {\n          TEST_ENVIRONMENT_VARIABLE: 'test environment variable value',\n        },\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  service.addEnvironmentVariable('SECOND_ENVIRONEMENT_VARIABLE', 'second test value');\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          RuntimeEnvironmentVariables: [\n            {\n              Name: 'TEST_ENVIRONMENT_VARIABLE',\n              Value: 'test environment variable value',\n            },\n            {\n              Name: 'SECOND_ENVIRONEMENT_VARIABLE',\n              Value: 'second test value',\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment secrets and start commands are allowed for imageConfiguration with port undefined",
            "suites": [],
            "updatePoint": {
                "line": 272,
                "column": 106
            },
            "line": 272,
            "code": "test('custom environment secrets and start commands are allowed for imageConfiguration with port undefined', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const secret = new secretsmanager.Secret(stack, 'Secret');\n  const parameter = ssm.StringParameter.fromSecureStringParameterAttributes(stack, 'Parameter', {\n    parameterName: '/name',\n    version: 1,\n  });\n\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        environmentSecrets: {\n          SECRET: apprunner.Secret.fromSecretsManager(secret),\n          PARAMETER: apprunner.Secret.fromSsmParameter(parameter),\n          SECRET_ID: apprunner.Secret.fromSecretsManagerVersion(secret, { versionId: 'version-id' }),\n          SECRET_STAGE: apprunner.Secret.fromSecretsManagerVersion(secret, { versionStage: 'version-stage' }),\n        },\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  service.addSecret('LATER_SECRET', apprunner.Secret.fromSecretsManager(secret, 'field'));\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          RuntimeEnvironmentSecrets: [\n            {\n              Name: 'SECRET',\n              Value: {\n                Ref: 'SecretA720EF05',\n              },\n            },\n            {\n              Name: 'PARAMETER',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    'arn:',\n                    {\n                      Ref: 'AWS::Partition',\n                    },\n                    ':ssm:',\n                    {\n                      Ref: 'AWS::Region',\n                    },\n                    ':',\n                    {\n                      Ref: 'AWS::AccountId',\n                    },\n                    ':parameter/name',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'SECRET_ID',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    ':::version-id',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'SECRET_STAGE',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    '::version-stage:',\n                  ],\n                ],\n              },\n            },\n            {\n              Name: 'LATER_SECRET',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    ':field::',\n                  ],\n                ],\n              },\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment variables can be added with .addEnvironmentVariable() without first defining them in props",
            "suites": [],
            "updatePoint": {
                "line": 394,
                "column": 115
            },
            "line": 394,
            "code": "test('custom environment variables can be added with .addEnvironmentVariable() without first defining them in props', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  // WHEN\n  service.addEnvironmentVariable('TEST_ENVIRONMENT_VARIABLE', 'test environment variable value');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          RuntimeEnvironmentVariables: [\n            {\n              Name: 'TEST_ENVIRONMENT_VARIABLE',\n              Value: 'test environment variable value',\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom environment secrets can be added with .addSecret() without first defining them in props",
            "suites": [],
            "updatePoint": {
                "line": 436,
                "column": 100
            },
            "line": 436,
            "code": "test('custom environment secrets can be added with .addSecret() without first defining them in props', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  const secret = new secretsmanager.Secret(stack, 'Secret');\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageConfiguration: {\n        startCommand: '/root/start-command.sh',\n      },\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  // WHEN\n  service.addSecret('LATER_SECRET', apprunner.Secret.fromSecretsManager(secret, 'field'));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageConfiguration: {\n          RuntimeEnvironmentSecrets: [\n            {\n              Name: 'LATER_SECRET',\n              Value: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      Ref: 'SecretA720EF05',\n                    },\n                    ':field::',\n                  ],\n                ],\n              },\n            },\n          ],\n          StartCommand: '/root/start-command.sh',\n        },\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n    InstanceConfiguration: {\n      InstanceRoleArn: {\n        'Fn::GetAtt': [\n          'DemoServiceInstanceRoleFCED1725',\n          'Arn',\n        ],\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a service from existing ECR repository(image repository type: ECR)",
            "suites": [],
            "updatePoint": {
                "line": 497,
                "column": 79
            },
            "line": 497,
            "code": "test('create a service from existing ECR repository(image repository type: ECR)', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'Service', {\n    source: apprunner.Source.fromEcr({\n      imageConfiguration: { port: 80 },\n      repository: ecr.Repository.fromRepositoryName(stack, 'NginxRepository', 'nginx'),\n    }),\n  });\n\n  // THEN\n  // we should have an IAM role\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [\n        {\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: {\n            Service: 'build.apprunner.amazonaws.com',\n          },\n        },\n      ],\n      Version: '2012-10-17',\n    },\n  });\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        AccessRoleArn: {\n          'Fn::GetAtt': [\n            'ServiceAccessRole4763579D',\n            'Arn',\n          ],\n        },\n      },\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '80',\n        },\n        ImageIdentifier: {\n          'Fn::Join': [\n            '',\n            [\n              {\n                Ref: 'AWS::AccountId',\n              },\n              '.dkr.ecr.',\n              {\n                Ref: 'AWS::Region',\n              },\n              '.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n              '/nginx:latest',\n            ],\n          ],\n        },\n        ImageRepositoryType: 'ECR',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a service with local assets(image repository type: ECR)",
            "suites": [],
            "updatePoint": {
                "line": 570,
                "column": 68
            },
            "line": 570,
            "code": "test('create a service with local assets(image repository type: ECR)', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const dockerAsset = new ecr_assets.DockerImageAsset(stack, 'Assets', {\n    directory: path.join(__dirname, './docker.assets'),\n  });\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromAsset({\n      imageConfiguration: { port: 8000 },\n      asset: dockerAsset,\n    }),\n  });\n\n  // THEN\n  // we should have an IAM role\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [\n        {\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: {\n            Service: 'build.apprunner.amazonaws.com',\n          },\n        },\n      ],\n      Version: '2012-10-17',\n    },\n  });\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        AccessRoleArn: {\n          'Fn::GetAtt': [\n            'DemoServiceAccessRoleE7F08742',\n            'Arn',\n          ],\n        },\n      },\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '8000',\n        },\n        ImageIdentifier: {\n          'Fn::Sub': '${AWS::AccountId}.dkr.ecr.${AWS::Region}.${AWS::URLSuffix}/cdk-hnb659fds-container-assets-${AWS::AccountId}-${AWS::Region}:77284835684772d19c95f4f5a37e7618d5f9efc40db9321d44ac039db457b967',\n        },\n        ImageRepositoryType: 'ECR',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a service with github repository",
            "suites": [],
            "updatePoint": {
                "line": 631,
                "column": 45
            },
            "line": 631,
            "code": "test('create a service with github repository', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromGitHub({\n      repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n      branch: 'main',\n      configurationSource: apprunner.ConfigurationSourceType.REPOSITORY,\n      connection: apprunner.GitHubConnection.fromConnectionArn('MOCK'),\n    }),\n  });\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        ConnectionArn: 'MOCK',\n      },\n      CodeRepository: {\n        CodeConfiguration: {\n          ConfigurationSource: 'REPOSITORY',\n        },\n        RepositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n        SourceCodeVersion: {\n          Type: 'BRANCH',\n          Value: 'main',\n        },\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a service with github repository - undefined branch name is allowed",
            "suites": [],
            "updatePoint": {
                "line": 671,
                "column": 80
            },
            "line": 671,
            "code": "test('create a service with github repository - undefined branch name is allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromGitHub({\n      repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n      configurationSource: apprunner.ConfigurationSourceType.API,\n      codeConfigurationValues: {\n        runtime: apprunner.Runtime.PYTHON_3,\n        port: '8000',\n      },\n      connection: apprunner.GitHubConnection.fromConnectionArn('MOCK'),\n    }),\n  });\n\n  // THEN\n  // we should have the service with the branch value as 'main'\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        ConnectionArn: 'MOCK',\n      },\n      CodeRepository: {\n        CodeConfiguration: {\n          CodeConfigurationValues: {\n            Port: '8000',\n            Runtime: 'PYTHON_3',\n          },\n          ConfigurationSource: 'API',\n        },\n        RepositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n        SourceCodeVersion: {\n          Type: 'BRANCH',\n          Value: 'main',\n        },\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a service with github repository - buildCommand, environment and startCommand are allowed",
            "suites": [],
            "updatePoint": {
                "line": 718,
                "column": 102
            },
            "line": 718,
            "code": "test('create a service with github repository - buildCommand, environment and startCommand are allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const service = new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromGitHub({\n      repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n      configurationSource: apprunner.ConfigurationSourceType.API,\n      codeConfigurationValues: {\n        runtime: apprunner.Runtime.PYTHON_3,\n        port: '8000',\n        buildCommand: '/root/build.sh',\n        environmentVariables: {\n          TEST_ENVIRONMENT_VARIABLE: 'test environment variable value',\n        },\n        startCommand: '/root/start.sh',\n      },\n      connection: apprunner.GitHubConnection.fromConnectionArn('MOCK'),\n    }),\n  });\n\n  service.addEnvironmentVariable('SECOND_ENVIRONEMENT_VARIABLE', 'second test value');\n\n  // THEN\n  // we should have the service with the branch value as 'main'\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        ConnectionArn: 'MOCK',\n      },\n      CodeRepository: {\n        CodeConfiguration: {\n          CodeConfigurationValues: {\n            Port: '8000',\n            Runtime: 'PYTHON_3',\n            BuildCommand: '/root/build.sh',\n            RuntimeEnvironmentVariables: [\n              {\n                Name: 'TEST_ENVIRONMENT_VARIABLE',\n                Value: 'test environment variable value',\n              },\n              {\n                Name: 'SECOND_ENVIRONEMENT_VARIABLE',\n                Value: 'second test value',\n              },\n            ],\n            StartCommand: '/root/start.sh',\n          },\n          ConfigurationSource: 'API',\n        },\n        RepositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n        SourceCodeVersion: {\n          Type: 'BRANCH',\n          Value: 'main',\n        },\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "import from service name",
            "suites": [],
            "updatePoint": {
                "line": 785,
                "column": 30
            },
            "line": 785,
            "code": "test('import from service name', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const svc = apprunner.Service.fromServiceName(stack, 'ImportService', 'ExistingService');\n  // THEN\n  expect(svc).toHaveProperty('serviceName');\n  expect(svc).toHaveProperty('serviceArn');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "import from service attributes",
            "suites": [],
            "updatePoint": {
                "line": 796,
                "column": 36
            },
            "line": 796,
            "code": "test('import from service attributes', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const svc = apprunner.Service.fromServiceAttributes(stack, 'ImportService', {\n    serviceName: 'mock',\n    serviceArn: 'mock',\n    serviceStatus: 'mock',\n    serviceUrl: 'mock',\n  });\n  // THEN\n  expect(svc).toHaveProperty('serviceName');\n  expect(svc).toHaveProperty('serviceArn');\n  expect(svc).toHaveProperty('serviceStatus');\n  expect(svc).toHaveProperty('serviceUrl');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "undefined imageConfiguration port is allowed",
            "suites": [],
            "updatePoint": {
                "line": 815,
                "column": 50
            },
            "line": 815,
            "code": "test('undefined imageConfiguration port is allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'Service', {\n    source: apprunner.Source.fromEcrPublic({\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n\n  // THEN\n  // we should have the service\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {},\n      ImageRepository: {\n        ImageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n        ImageRepositoryType: 'ECR_PUBLIC',\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom IAM access role and instance role are allowed",
            "suites": [],
            "updatePoint": {
                "line": 844,
                "column": 58
            },
            "line": 844,
            "code": "test('custom IAM access role and instance role are allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const dockerAsset = new ecr_assets.DockerImageAsset(stack, 'Assets', {\n    directory: path.join(__dirname, './docker.assets'),\n  });\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromAsset({\n      asset: dockerAsset,\n      imageConfiguration: { port: 8000 },\n    }),\n    accessRole: new iam.Role(stack, 'AccessRole', {\n      assumedBy: new iam.ServicePrincipal('build.apprunner.amazonaws.com'),\n      managedPolicies: [\n        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSAppRunnerServicePolicyForECRAccess'),\n      ],\n    }),\n    instanceRole: new iam.Role(stack, 'InstanceRole', {\n      assumedBy: new iam.ServicePrincipal('tasks.apprunner.amazonaws.com'),\n    }),\n  });\n  // THEN\n  // we should have the service with the branch value as 'main'\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AuthenticationConfiguration: {\n        AccessRoleArn: {\n          'Fn::GetAtt': [\n            'AccessRoleEC309AE6',\n            'Arn',\n          ],\n        },\n      },\n      ImageRepository: {\n        ImageConfiguration: {\n          Port: '8000',\n        },\n        ImageIdentifier: {\n          'Fn::Sub': '${AWS::AccountId}.dkr.ecr.${AWS::Region}.${AWS::URLSuffix}/cdk-hnb659fds-container-assets-${AWS::AccountId}-${AWS::Region}:77284835684772d19c95f4f5a37e7618d5f9efc40db9321d44ac039db457b967',\n        },\n        ImageRepositoryType: 'ECR',\n      },\n    },\n    InstanceConfiguration: {\n      InstanceRoleArn: {\n        'Fn::GetAtt': [\n          'InstanceRole3CCE2F1D',\n          'Arn',\n        ],\n      },\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "cpu and memory properties are allowed",
            "suites": [],
            "updatePoint": {
                "line": 905,
                "column": 43
            },
            "line": 905,
            "code": "test('cpu and memory properties are allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n    cpu: apprunner.Cpu.ONE_VCPU,\n    memory: apprunner.Memory.THREE_GB,\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    InstanceConfiguration: {\n      Cpu: '1 vCPU',\n      Memory: '3 GB',\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "custom cpu and memory units are allowed",
            "suites": [],
            "updatePoint": {
                "line": 931,
                "column": 45
            },
            "line": 931,
            "code": "test('custom cpu and memory units are allowed', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n    cpu: apprunner.Cpu.of('Some vCPU'),\n    memory: apprunner.Memory.of('Some GB'),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    InstanceConfiguration: {\n      Cpu: 'Some vCPU',\n      Memory: 'Some GB',\n    },\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'DEFAULT',\n      },\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "environment variable with a prefix of AWSAPPRUNNER should throw an error",
            "suites": [],
            "updatePoint": {
                "line": 957,
                "column": 78
            },
            "line": 957,
            "code": "test('environment variable with a prefix of AWSAPPRUNNER should throw an error', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  // we should have the service\n  expect(() => {\n    new apprunner.Service(stack, 'DemoService', {\n      source: apprunner.Source.fromEcrPublic({\n        imageConfiguration: {\n          environmentVariables: {\n            AWSAPPRUNNER_FOO: 'bar',\n          },\n        },\n        imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n      }),\n    });\n  }).toThrow('Environment variable key AWSAPPRUNNER_FOO with a prefix of AWSAPPRUNNER is not allowed');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "environment variable with a prefix of AWSAPPRUNNER added later should throw an error",
            "suites": [],
            "updatePoint": {
                "line": 977,
                "column": 90
            },
            "line": 977,
            "code": "test('environment variable with a prefix of AWSAPPRUNNER added later should throw an error', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  // we should have the service\n  expect(() => {\n    const service = new apprunner.Service(stack, 'DemoService', {\n      source: apprunner.Source.fromEcrPublic({\n        imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n      }),\n    });\n    service.addEnvironmentVariable('AWSAPPRUNNER_FOO', 'BAR');\n  }).toThrow('Environment variable key AWSAPPRUNNER_FOO with a prefix of AWSAPPRUNNER is not allowed');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "environment secrets with a prefix of AWSAPPRUNNER should throw an error",
            "suites": [],
            "updatePoint": {
                "line": 993,
                "column": 77
            },
            "line": 993,
            "code": "test('environment secrets with a prefix of AWSAPPRUNNER should throw an error', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  const secret = new secretsmanager.Secret(stack, 'Secret');\n\n  // WHEN\n  // we should have the service\n  expect(() => {\n    new apprunner.Service(stack, 'DemoService', {\n      source: apprunner.Source.fromEcrPublic({\n        imageConfiguration: {\n          environmentSecrets: {\n            AWSAPPRUNNER_FOO: apprunner.Secret.fromSecretsManager(secret),\n          },\n        },\n        imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n      }),\n    });\n  }).toThrow('Environment secret key AWSAPPRUNNER_FOO with a prefix of AWSAPPRUNNER is not allowed');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "environment secrets with a prefix of AWSAPPRUNNER added later should throw an error",
            "suites": [],
            "updatePoint": {
                "line": 1015,
                "column": 89
            },
            "line": 1015,
            "code": "test('environment secrets with a prefix of AWSAPPRUNNER added later should throw an error', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  const secret = new secretsmanager.Secret(stack, 'Secret');\n\n  // WHEN\n  // we should have the service\n  expect(() => {\n    const service = new apprunner.Service(stack, 'DemoService', {\n      source: apprunner.Source.fromEcrPublic({\n        imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n      }),\n    });\n    service.addSecret('AWSAPPRUNNER_FOO', apprunner.Secret.fromSecretsManager(secret));\n  }).toThrow('Environment secret key AWSAPPRUNNER_FOO with a prefix of AWSAPPRUNNER is not allowed');\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "specifying a vpcConnector should assign the service to it and set the egressType to VPC",
            "suites": [],
            "updatePoint": {
                "line": 1033,
                "column": 93
            },
            "line": 1033,
            "code": "test('specifying a vpcConnector should assign the service to it and set the egressType to VPC', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n\n  const vpc = new ec2.Vpc(stack, 'Vpc', {\n    ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),\n  });\n\n  const securityGroup = new ec2.SecurityGroup(stack, 'SecurityGroup', { vpc });\n\n  const vpcConnector = new apprunner.VpcConnector(stack, 'VpcConnector', {\n    securityGroups: [securityGroup],\n    vpc,\n    vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n    vpcConnectorName: 'MyVpcConnector',\n  });\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n    vpcConnector,\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    NetworkConfiguration: {\n      EgressConfiguration: {\n        EgressType: 'VPC',\n        VpcConnectorArn: {\n          'Fn::GetAtt': [\n            'VpcConnectorE3A78531',\n            'VpcConnectorArn',\n          ],\n        },\n      },\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::VpcConnector', {\n    Subnets: [\n      {\n        Ref: 'VpcPublicSubnet1Subnet5C2D37C4',\n      },\n      {\n        Ref: 'VpcPublicSubnet2Subnet691E08A3',\n      },\n    ],\n    SecurityGroups: [\n      {\n        'Fn::GetAtt': [\n          'SecurityGroupDD263621',\n          'GroupId',\n        ],\n      },\n    ],\n    VpcConnectorName: 'MyVpcConnector',\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "autoDeploymentsEnabled flag is set true",
            "suites": [],
            "updatePoint": {
                "line": 1093,
                "column": 45
            },
            "line": 1093,
            "code": "test('autoDeploymentsEnabled flag is set true', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  const dockerAsset = new ecr_assets.DockerImageAsset(stack, 'Assets', {\n    directory: path.join(__dirname, './docker.assets'),\n  });\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromAsset({\n      imageConfiguration: { port: 8000 },\n      asset: dockerAsset,\n    }),\n    autoDeploymentsEnabled: true,\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AutoDeploymentsEnabled: true,\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "autoDeploymentsEnabled flag is set false",
            "suites": [],
            "updatePoint": {
                "line": 1116,
                "column": 46
            },
            "line": 1116,
            "code": "test('autoDeploymentsEnabled flag is set false', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromGitHub({\n      repositoryUrl: 'https://github.com/aws-containers/hello-app-runner',\n      branch: 'main',\n      configurationSource: apprunner.ConfigurationSourceType.REPOSITORY,\n      connection: apprunner.GitHubConnection.fromConnectionArn('MOCK'),\n    }),\n    autoDeploymentsEnabled: false,\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AutoDeploymentsEnabled: false,\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "autoDeploymentsEnabled flag is NOT set",
            "suites": [],
            "updatePoint": {
                "line": 1138,
                "column": 44
            },
            "line": 1138,
            "code": "test('autoDeploymentsEnabled flag is NOT set', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n  // WHEN\n  new apprunner.Service(stack, 'DemoService', {\n    source: apprunner.Source.fromEcrPublic({\n      imageIdentifier: 'public.ecr.aws/aws-containers/hello-app-runner:latest',\n    }),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::Service', {\n    SourceConfiguration: {\n      AutoDeploymentsEnabled: Match.absent(),\n    },\n  });\n});",
            "file": "service.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a vpcConnector with all properties",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "test('create a vpcConnector with all properties', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n\n  const vpc = new ec2.Vpc(stack, 'Vpc', {\n    ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),\n  });\n\n  const securityGroup = new ec2.SecurityGroup(stack, 'SecurityGroup', { vpc });\n  // WHEN\n  new VpcConnector(stack, 'VpcConnector', {\n    securityGroups: [securityGroup],\n    vpc,\n    vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n    vpcConnectorName: 'MyVpcConnector',\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::VpcConnector', {\n    Subnets: [\n      {\n        Ref: 'VpcPublicSubnet1Subnet5C2D37C4',\n      },\n      {\n        Ref: 'VpcPublicSubnet2Subnet691E08A3',\n      },\n    ],\n    SecurityGroups: [\n      {\n        'Fn::GetAtt': [\n          'SecurityGroupDD263621',\n          'GroupId',\n        ],\n      },\n    ],\n    VpcConnectorName: 'MyVpcConnector',\n  });\n});",
            "file": "vpc-connector.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a vpcConnector without a name",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 42
            },
            "line": 45,
            "code": "test('create a vpcConnector without a name', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n\n  const vpc = new ec2.Vpc(stack, 'Vpc', {\n    ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),\n  });\n\n  const securityGroup = new ec2.SecurityGroup(stack, 'SecurityGroup', { vpc });\n  // WHEN\n  new VpcConnector(stack, 'VpcConnector', {\n    securityGroups: [securityGroup],\n    vpc,\n    vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::VpcConnector', {\n    Subnets: [\n      {\n        Ref: 'VpcPublicSubnet1Subnet5C2D37C4',\n      },\n      {\n        Ref: 'VpcPublicSubnet2Subnet691E08A3',\n      },\n    ],\n    SecurityGroups: [\n      {\n        'Fn::GetAtt': [\n          'SecurityGroupDD263621',\n          'GroupId',\n        ],\n      },\n    ],\n  });\n});",
            "file": "vpc-connector.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a vpcConnector without a security group should create one",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 70
            },
            "line": 82,
            "code": "test('create a vpcConnector without a security group should create one', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n\n  const vpc = new ec2.Vpc(stack, 'Vpc', {\n    ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),\n  });\n\n  // WHEN\n  new VpcConnector(stack, 'VpcConnector', {\n    vpc,\n    vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::VpcConnector', {\n    Subnets: [\n      {\n        Ref: 'VpcPublicSubnet1Subnet5C2D37C4',\n      },\n      {\n        Ref: 'VpcPublicSubnet2Subnet691E08A3',\n      },\n    ],\n    SecurityGroups: [\n      {\n        'Fn::GetAtt': [\n          'VpcConnectorSecurityGroup33FAF25D',\n          'GroupId',\n        ],\n      },\n    ],\n  });\n});",
            "file": "vpc-connector.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "create a vpcConnector with an empty security group array should create one",
            "suites": [],
            "updatePoint": {
                "line": 117,
                "column": 80
            },
            "line": 117,
            "code": "test('create a vpcConnector with an empty security group array should create one', () => {\n  // GIVEN\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'demo-stack');\n\n  const vpc = new ec2.Vpc(stack, 'Vpc', {\n    ipAddresses: ec2.IpAddresses.cidr('10.0.0.0/16'),\n  });\n\n  // WHEN\n  new VpcConnector(stack, 'VpcConnector', {\n    vpc,\n    vpcSubnets: vpc.selectSubnets({ subnetType: ec2.SubnetType.PUBLIC }),\n    securityGroups: [],\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::AppRunner::VpcConnector', {\n    Subnets: [\n      {\n        Ref: 'VpcPublicSubnet1Subnet5C2D37C4',\n      },\n      {\n        Ref: 'VpcPublicSubnet2Subnet691E08A3',\n      },\n    ],\n    SecurityGroups: [\n      {\n        'Fn::GetAtt': [\n          'VpcConnectorSecurityGroup33FAF25D',\n          'GroupId',\n        ],\n      },\n    ],\n  });\n});",
            "file": "vpc-connector.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-apprunner/test"
        },
        {
            "name": "use aws batch job as an event rule target",
            "suites": [
                "Batch job event target"
            ],
            "updatePoint": {
                "line": 34,
                "column": 49
            },
            "line": 34,
            "code": "  test('use aws batch job as an event rule target', () => {\n    // GIVEN\n    const rule = new events.Rule(stack, 'Rule', {\n      schedule: events.Schedule.expression('rate(1 min)'),\n    });\n\n    // WHEN\n    rule.addTarget(new targets.BatchJob(jobQueue.jobQueueArn, jobQueue, jobDefinition.jobDefinitionArn, jobDefinition));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n      ScheduleExpression: 'rate(1 min)',\n      State: 'ENABLED',\n      Targets: [\n        {\n          Arn: {\n            'Fn::GetAtt': [\n              'MyQueue4F9177CF',\n              'JobQueueArn',\n            ],\n          },\n          Id: 'Target0',\n          RoleArn: {\n            'Fn::GetAtt': [\n              'MyJobEventsRoleCF43C336',\n              'Arn',\n            ],\n          },\n          BatchParameters: {\n            JobDefinition: {\n              Ref: 'MyJob8719E923',\n            },\n            JobName: 'Rule',\n          },\n        },\n      ],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: 'batch:SubmitJob',\n            Effect: 'Allow',\n            Resource: [\n              { Ref: 'MyJob8719E923' },\n              {\n                'Fn::GetAtt': [\n                  'MyQueue4F9177CF',\n                  'JobQueueArn',\n                ],\n              },\n            ],\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      Roles: [\n        { Ref: 'MyJobEventsRoleCF43C336' },\n      ],\n    });\n  });",
            "file": "aws-events-targets/batch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "use a Dead Letter Queue for the rule target",
            "suites": [
                "Batch job event target"
            ],
            "updatePoint": {
                "line": 97,
                "column": 51
            },
            "line": 97,
            "code": "  test('use a Dead Letter Queue for the rule target', () => {\n    // GIVEN\n    const rule = new events.Rule(stack, 'Rule', {\n      schedule: events.Schedule.expression('rate(1 hour)'),\n    });\n\n    const queue = new sqs.Queue(stack, 'Queue');\n\n    // WHEN\n    const eventInput = {\n      buildspecOverride: 'buildspecs/hourly.yml',\n    };\n\n    rule.addTarget(new targets.BatchJob(\n      jobQueue.jobQueueArn,\n      jobQueue,\n      jobDefinition.jobDefinitionArn,\n      jobDefinition, {\n        deadLetterQueue: queue,\n        event: events.RuleTargetInput.fromObject(eventInput),\n      },\n    ));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n      Targets: [\n        {\n          Arn: {\n            'Fn::GetAtt': [\n              'MyQueue4F9177CF',\n              'JobQueueArn',\n            ],\n          },\n          Id: 'Target0',\n          DeadLetterConfig: {\n            Arn: {\n              'Fn::GetAtt': [\n                'Queue4A7E3555',\n                'Arn',\n              ],\n            },\n          },\n          Input: JSON.stringify(eventInput),\n          RoleArn: {\n            'Fn::GetAtt': ['MyJobEventsRoleCF43C336', 'Arn'],\n          },\n          BatchParameters: {\n            JobDefinition: {\n              Ref: 'MyJob8719E923',\n            },\n            JobName: 'Rule',\n          },\n        },\n      ],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::SQS::QueuePolicy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: 'sqs:SendMessage',\n            Condition: {\n              ArnEquals: {\n                'aws:SourceArn': {\n                  'Fn::GetAtt': [\n                    'Rule4C995B7F',\n                    'Arn',\n                  ],\n                },\n              },\n            },\n            Effect: 'Allow',\n            Principal: {\n              Service: 'events.amazonaws.com',\n            },\n            Resource: {\n              'Fn::GetAtt': [\n                'Queue4A7E3555',\n                'Arn',\n              ],\n            },\n            Sid: 'AllowEventRuleRule',\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      Queues: [\n        {\n          Ref: 'Queue4A7E3555',\n        },\n      ],\n    });\n  });",
            "file": "aws-events-targets/batch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "specifying retry policy",
            "suites": [
                "Batch job event target"
            ],
            "updatePoint": {
                "line": 191,
                "column": 31
            },
            "line": 191,
            "code": "  test('specifying retry policy', () => {\n    // GIVEN\n    const rule = new events.Rule(stack, 'Rule', {\n      schedule: events.Schedule.expression('rate(1 hour)'),\n    });\n\n    const queue = new sqs.Queue(stack, 'Queue');\n\n    // WHEN\n    const eventInput = {\n      buildspecOverride: 'buildspecs/hourly.yml',\n    };\n\n    rule.addTarget(new targets.BatchJob(\n      jobQueue.jobQueueArn,\n      jobQueue,\n      jobDefinition.jobDefinitionArn,\n      jobDefinition, {\n        deadLetterQueue: queue,\n        event: events.RuleTargetInput.fromObject(eventInput),\n        retryAttempts: 2,\n        maxEventAge: Duration.hours(2),\n      },\n    ));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n      ScheduleExpression: 'rate(1 hour)',\n      State: 'ENABLED',\n      Targets: [\n        {\n          Arn: {\n            'Fn::GetAtt': [\n              'MyQueue4F9177CF',\n              'JobQueueArn',\n            ],\n          },\n          BatchParameters: {\n            JobDefinition: {\n              Ref: 'MyJob8719E923',\n            },\n            JobName: 'Rule',\n          },\n          DeadLetterConfig: {\n            Arn: {\n              'Fn::GetAtt': [\n                'Queue4A7E3555',\n                'Arn',\n              ],\n            },\n          },\n          Id: 'Target0',\n          Input: JSON.stringify(eventInput),\n          RetryPolicy: {\n            MaximumEventAgeInSeconds: 7200,\n            MaximumRetryAttempts: 2,\n          },\n          RoleArn: {\n            'Fn::GetAtt': [\n              'MyJobEventsRoleCF43C336',\n              'Arn',\n            ],\n          },\n        },\n      ],\n    });\n  });",
            "file": "aws-events-targets/batch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "specifying retry policy with 0 retryAttempts",
            "suites": [
                "Batch job event target"
            ],
            "updatePoint": {
                "line": 259,
                "column": 52
            },
            "line": 259,
            "code": "  test('specifying retry policy with 0 retryAttempts', () => {\n    // GIVEN\n    const rule = new events.Rule(stack, 'Rule', {\n      schedule: events.Schedule.expression('rate(1 hour)'),\n    });\n\n    // WHEN\n    const eventInput = {\n      buildspecOverride: 'buildspecs/hourly.yml',\n    };\n\n    rule.addTarget(new targets.BatchJob(\n      jobQueue.jobQueueArn,\n      jobQueue,\n      jobDefinition.jobDefinitionArn,\n      jobDefinition, {\n        event: events.RuleTargetInput.fromObject(eventInput),\n        retryAttempts: 0,\n      },\n    ));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n      ScheduleExpression: 'rate(1 hour)',\n      State: 'ENABLED',\n      Targets: [\n        {\n          Arn: {\n            'Fn::GetAtt': [\n              'MyQueue4F9177CF',\n              'JobQueueArn',\n            ],\n          },\n          BatchParameters: {\n            JobDefinition: {\n              Ref: 'MyJob8719E923',\n            },\n            JobName: 'Rule',\n          },\n          Id: 'Target0',\n          Input: JSON.stringify(eventInput),\n          RetryPolicy: {\n            MaximumRetryAttempts: 0,\n          },\n          RoleArn: {\n            'Fn::GetAtt': [\n              'MyJobEventsRoleCF43C336',\n              'Arn',\n            ],\n          },\n        },\n      ],\n    });\n  });",
            "file": "aws-events-targets/batch.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task with only the required parameters",
            "suites": [],
            "updatePoint": {
                "line": 41,
                "column": 46
            },
            "line": 41,
            "code": "  test('Task with only the required parameters', () => {\n  // WHEN\n    const task = new sfn.Task(stack, 'Task', {\n      task: new tasks.RunBatchJob({\n        jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n        jobName: 'JobName',\n        jobQueueArn: batchJobQueue.jobQueueArn,\n      }),\n    });\n\n    // THEN\n    expect(stack.resolve(task.toStateJson())).toEqual({\n      Type: 'Task',\n      Resource: {\n        'Fn::Join': [\n          '',\n          [\n            'arn:',\n            {\n              Ref: 'AWS::Partition',\n            },\n            ':states:::batch:submitJob.sync',\n          ],\n        ],\n      },\n      End: true,\n      Parameters: {\n        JobDefinition: { Ref: 'JobDefinition24FFE3ED' },\n        JobName: 'JobName',\n        JobQueue: {\n          'Fn::GetAtt': [\n            'JobQueueC5644E0D',\n            'JobQueueArn',\n          ],\n        },\n      },\n    });\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task with all the parameters",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 36
            },
            "line": 80,
            "code": "  test('Task with all the parameters', () => {\n  // WHEN\n    const task = new sfn.Task(stack, 'Task', {\n      task: new tasks.RunBatchJob({\n        jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n        jobName: 'JobName',\n        jobQueueArn: batchJobQueue.jobQueueArn,\n        arraySize: 15,\n        containerOverrides: {\n          command: ['sudo', 'rm'],\n          environment: { key: 'value' },\n          instanceType: new ec2.InstanceType('MULTI'),\n          memory: 1024,\n          gpuCount: 1,\n          vcpus: 10,\n        },\n        dependsOn: [{ jobId: '1234', type: 'some_type' }],\n        payload: {\n          foo: sfn.JsonPath.stringAt('$.bar'),\n        },\n        attempts: 3,\n        timeout: cdk.Duration.seconds(60),\n        integrationPattern: sfn.ServiceIntegrationPattern.FIRE_AND_FORGET,\n      }),\n    });\n\n    // THEN\n    expect(stack.resolve(task.toStateJson())).toEqual({\n      Type: 'Task',\n      Resource: {\n        'Fn::Join': [\n          '',\n          [\n            'arn:',\n            {\n              Ref: 'AWS::Partition',\n            },\n            ':states:::batch:submitJob',\n          ],\n        ],\n      },\n      End: true,\n      Parameters: {\n        JobDefinition: { Ref: 'JobDefinition24FFE3ED' },\n        JobName: 'JobName',\n        JobQueue: {\n          'Fn::GetAtt': [\n            'JobQueueC5644E0D',\n            'JobQueueArn',\n          ],\n        },\n        ArrayProperties: { Size: 15 },\n        ContainerOverrides: {\n          Command: ['sudo', 'rm'],\n          Environment: [{ Name: 'key', Value: 'value' }],\n          InstanceType: 'MULTI',\n          Memory: 1024,\n          ResourceRequirements: [{ Type: 'GPU', Value: '1' }],\n          Vcpus: 10,\n        },\n        DependsOn: [{ JobId: '1234', Type: 'some_type' }],\n        Parameters: { 'foo.$': '$.bar' },\n        RetryStrategy: { Attempts: 3 },\n        Timeout: { AttemptDurationSeconds: 60 },\n      },\n    });\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "supports tokens",
            "suites": [],
            "updatePoint": {
                "line": 148,
                "column": 23
            },
            "line": 148,
            "code": "  test('supports tokens', () => {\n  // WHEN\n    const task = new sfn.Task(stack, 'Task', {\n      task: new tasks.RunBatchJob({\n        jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n        jobQueueArn: batchJobQueue.jobQueueArn,\n        jobName: sfn.JsonPath.stringAt('$.jobName'),\n        arraySize: sfn.JsonPath.numberAt('$.arraySize'),\n        timeout: cdk.Duration.seconds(sfn.JsonPath.numberAt('$.timeout')),\n        attempts: sfn.JsonPath.numberAt('$.attempts'),\n      }),\n    });\n\n    // THEN\n    expect(stack.resolve(task.toStateJson())).toEqual({\n      Type: 'Task',\n      Resource: {\n        'Fn::Join': [\n          '',\n          [\n            'arn:',\n            {\n              Ref: 'AWS::Partition',\n            },\n            ':states:::batch:submitJob.sync',\n          ],\n        ],\n      },\n      End: true,\n      Parameters: {\n        'JobDefinition': { Ref: 'JobDefinition24FFE3ED' },\n        'JobName.$': '$.jobName',\n        'JobQueue': {\n          'Fn::GetAtt': [\n            'JobQueueC5644E0D',\n            'JobQueueArn',\n          ],\n        },\n        'ArrayProperties': {\n          'Size.$': '$.arraySize',\n        },\n        'RetryStrategy': {\n          'Attempts.$': '$.attempts',\n        },\n        'Timeout': {\n          'AttemptDurationSeconds.$': '$.timeout',\n        },\n      },\n    });\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if WAIT_FOR_TASK_TOKEN is supplied as service integration pattern",
            "suites": [],
            "updatePoint": {
                "line": 199,
                "column": 85
            },
            "line": 199,
            "code": "  test('Task throws if WAIT_FOR_TASK_TOKEN is supplied as service integration pattern', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          integrationPattern: sfn.ServiceIntegrationPattern.WAIT_FOR_TASK_TOKEN,\n        }),\n      });\n    }).toThrow(\n      /Invalid Service Integration Pattern: WAIT_FOR_TASK_TOKEN is not supported to call RunBatchJob./i,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if environment in containerOverrides contain env with name starting with AWS_BATCH",
            "suites": [],
            "updatePoint": {
                "line": 214,
                "column": 102
            },
            "line": 214,
            "code": "  test('Task throws if environment in containerOverrides contain env with name starting with AWS_BATCH', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          containerOverrides: {\n            environment: { AWS_BATCH_MY_NAME: 'MY_VALUE' },\n          },\n        }),\n      });\n    }).toThrow(\n      /Invalid environment variable name: AWS_BATCH_MY_NAME. Environment variable names starting with 'AWS_BATCH' are reserved./i,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if arraySize is out of limits 2-10000",
            "suites": [],
            "updatePoint": {
                "line": 231,
                "column": 57
            },
            "line": 231,
            "code": "  test('Task throws if arraySize is out of limits 2-10000', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          arraySize: 1,\n        }),\n      });\n    }).toThrow(\n      /arraySize must be between 2 and 10,000/,\n    );\n\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          arraySize: 10001,\n        }),\n      });\n    }).toThrow(\n      /arraySize must be between 2 and 10,000/,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if dependencies exceeds 20",
            "suites": [],
            "updatePoint": {
                "line": 259,
                "column": 46
            },
            "line": 259,
            "code": "  test('Task throws if dependencies exceeds 20', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          dependsOn: [...Array(21).keys()].map(i => ({\n            jobId: `${i}`,\n            type: `some_type-${i}`,\n          })),\n        }),\n      });\n    }).toThrow(\n      /dependencies must be 20 or less/,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if attempts is out of limits 1-10",
            "suites": [],
            "updatePoint": {
                "line": 277,
                "column": 53
            },
            "line": 277,
            "code": "  test('Task throws if attempts is out of limits 1-10', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          attempts: 0,\n        }),\n      });\n    }).toThrow(\n      /attempts must be between 1 and 10/,\n    );\n\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          attempts: 11,\n        }),\n      });\n    }).toThrow(\n      /attempts must be between 1 and 10/,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if timeout is less than 60 sec",
            "suites": [],
            "updatePoint": {
                "line": 305,
                "column": 50
            },
            "line": 305,
            "code": "  test('Task throws if timeout is less than 60 sec', () => {\n    expect(() => {\n      new sfn.Task(stack, 'Task', {\n        task: new tasks.RunBatchJob({\n          jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n          jobName: 'JobName',\n          jobQueueArn: batchJobQueue.jobQueueArn,\n          timeout: cdk.Duration.seconds(59),\n        }),\n      });\n    }).toThrow(\n      /timeout must be greater than 60 seconds/,\n    );\n  });",
            "file": "aws-stepfunctions-tasks/run-batch-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task with only the required parameters",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 44
            },
            "line": 39,
            "code": "test('Task with only the required parameters', () => {\n  // WHEN\n  const task = new BatchSubmitJob(stack, 'Task', {\n    jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n    jobName: 'JobName',\n    jobQueueArn: batchJobQueue.jobQueueArn,\n  });\n\n  // THEN\n  expect(stack.resolve(task.toStateJson())).toEqual({\n    Type: 'Task',\n    Resource: {\n      'Fn::Join': [\n        '',\n        [\n          'arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':states:::batch:submitJob.sync',\n        ],\n      ],\n    },\n    End: true,\n    Parameters: {\n      JobDefinition: { Ref: 'JobDefinition24FFE3ED' },\n      JobName: 'JobName',\n      JobQueue: {\n        'Fn::GetAtt': [\n          'JobQueueC5644E0D',\n          'JobQueueArn',\n        ],\n      },\n    },\n  });\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task with all the parameters",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 34
            },
            "line": 76,
            "code": "test('Task with all the parameters', () => {\n  // WHEN\n  const task = new BatchSubmitJob(stack, 'Task', {\n    jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n    jobName: 'JobName',\n    jobQueueArn: batchJobQueue.jobQueueArn,\n    arraySize: 15,\n    containerOverrides: {\n      command: ['sudo', 'rm'],\n      environment: { key: 'value' },\n      instanceType: new ec2.InstanceType('MULTI'),\n      memory: cdk.Size.mebibytes(1024),\n      gpuCount: 1,\n      vcpus: 10,\n    },\n    dependsOn: [{ jobId: '1234', type: 'some_type' }],\n    payload: sfn.TaskInput.fromObject({\n      foo: sfn.JsonPath.stringAt('$.bar'),\n    }),\n    attempts: 3,\n    taskTimeout: sfn.Timeout.duration(cdk.Duration.seconds(60)),\n    integrationPattern: sfn.IntegrationPattern.REQUEST_RESPONSE,\n  });\n\n  // THEN\n  expect(stack.resolve(task.toStateJson())).toEqual({\n    Type: 'Task',\n    Resource: {\n      'Fn::Join': [\n        '',\n        [\n          'arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':states:::batch:submitJob',\n        ],\n      ],\n    },\n    End: true,\n    Parameters: {\n      JobDefinition: { Ref: 'JobDefinition24FFE3ED' },\n      JobName: 'JobName',\n      JobQueue: {\n        'Fn::GetAtt': [\n          'JobQueueC5644E0D',\n          'JobQueueArn',\n        ],\n      },\n      ArrayProperties: { Size: 15 },\n      ContainerOverrides: {\n        Command: ['sudo', 'rm'],\n        Environment: [{ Name: 'key', Value: 'value' }],\n        InstanceType: 'MULTI',\n        ResourceRequirements: [{ Type: 'GPU', Value: '1' }, { Type: 'MEMORY', Value: '1024' }, { Type: 'VCPU', Value: '10' }],\n      },\n      DependsOn: [{ JobId: '1234', Type: 'some_type' }],\n      Parameters: { 'foo.$': '$.bar' },\n      RetryStrategy: { Attempts: 3 },\n      Timeout: { AttemptDurationSeconds: 60 },\n    },\n  });\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "supports tokens",
            "suites": [],
            "updatePoint": {
                "line": 140,
                "column": 21
            },
            "line": 140,
            "code": "test('supports tokens', () => {\n  // WHEN\n  const task = new BatchSubmitJob(stack, 'Task', {\n    jobName: sfn.JsonPath.stringAt('$.jobName'),\n    jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n    jobQueueArn: batchJobQueue.jobQueueArn,\n    arraySize: sfn.JsonPath.numberAt('$.arraySize'),\n    taskTimeout: sfn.Timeout.at('$.timeout'),\n    attempts: sfn.JsonPath.numberAt('$.attempts'),\n  });\n\n  // THEN\n  expect(stack.resolve(task.toStateJson())).toEqual({\n    Type: 'Task',\n    Resource: {\n      'Fn::Join': [\n        '',\n        [\n          'arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':states:::batch:submitJob.sync',\n        ],\n      ],\n    },\n    End: true,\n    Parameters: {\n      'JobDefinition': { Ref: 'JobDefinition24FFE3ED' },\n      'JobName.$': '$.jobName',\n      'JobQueue': {\n        'Fn::GetAtt': [\n          'JobQueueC5644E0D',\n          'JobQueueArn',\n        ],\n      },\n      'ArrayProperties': {\n        'Size.$': '$.arraySize',\n      },\n      'RetryStrategy': {\n        'Attempts.$': '$.attempts',\n      },\n      'Timeout': {\n        'AttemptDurationSeconds.$': '$.timeout',\n      },\n    },\n  });\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "container overrides are tokens",
            "suites": [],
            "updatePoint": {
                "line": 189,
                "column": 36
            },
            "line": 189,
            "code": "test('container overrides are tokens', () => {\n  // WHEN\n  const task = new BatchSubmitJob(stack, 'Task', {\n    jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n    jobName: 'JobName',\n    jobQueueArn: batchJobQueue.jobQueueArn,\n    containerOverrides: {\n      memory: cdk.Size.mebibytes(sfn.JsonPath.numberAt('$.asdf')),\n    },\n  });\n\n  // THEN\n  expect(stack.resolve(task.toStateJson())).toEqual({\n    Type: 'Task',\n    Resource: { 'Fn::Join': ['', ['arn:', { Ref: 'AWS::Partition' }, ':states:::batch:submitJob.sync']] },\n    End: true,\n    Parameters: {\n      JobDefinition: { Ref: 'JobDefinition24FFE3ED' },\n      JobName: 'JobName',\n      JobQueue: {\n        'Fn::GetAtt': [\n          'JobQueueC5644E0D',\n          'JobQueueArn',\n        ],\n      },\n      ContainerOverrides: {\n        ResourceRequirements: [{ 'Type': 'MEMORY', 'Value.$': '$.asdf' }],\n      },\n    },\n  });\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "supports passing task input into payload",
            "suites": [],
            "updatePoint": {
                "line": 221,
                "column": 46
            },
            "line": 221,
            "code": "test('supports passing task input into payload', () => {\n  // WHEN\n  const task = new BatchSubmitJob(stack, 'Task', {\n    jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n    jobQueueArn: batchJobQueue.jobQueueArn,\n    jobName: sfn.JsonPath.stringAt('$.jobName'),\n    payload: sfn.TaskInput.fromJsonPathAt('$.foo'),\n  });\n\n  // THEN\n  expect(stack.resolve(task.toStateJson())).toEqual({\n    Type: 'Task',\n    Resource: {\n      'Fn::Join': [\n        '',\n        [\n          'arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':states:::batch:submitJob.sync',\n        ],\n      ],\n    },\n    End: true,\n    Parameters: {\n      'JobDefinition': { Ref: 'JobDefinition24FFE3ED' },\n      'JobName.$': '$.jobName',\n      'JobQueue': {\n        'Fn::GetAtt': [\n          'JobQueueC5644E0D',\n          'JobQueueArn',\n        ],\n      },\n      'Parameters.$': '$.foo',\n    },\n  });\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if WAIT_FOR_TASK_TOKEN is supplied as service integration pattern",
            "suites": [],
            "updatePoint": {
                "line": 260,
                "column": 83
            },
            "line": 260,
            "code": "test('Task throws if WAIT_FOR_TASK_TOKEN is supplied as service integration pattern', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      integrationPattern: sfn.IntegrationPattern.WAIT_FOR_TASK_TOKEN,\n    });\n  }).toThrow(\n    /Unsupported service integration pattern. Supported Patterns: REQUEST_RESPONSE,RUN_JOB. Received: WAIT_FOR_TASK_TOKEN/,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if environment in containerOverrides contain env with name starting with AWS_BATCH",
            "suites": [],
            "updatePoint": {
                "line": 273,
                "column": 100
            },
            "line": 273,
            "code": "test('Task throws if environment in containerOverrides contain env with name starting with AWS_BATCH', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      containerOverrides: {\n        environment: { AWS_BATCH_MY_NAME: 'MY_VALUE' },\n      },\n    });\n  }).toThrow(\n    /Invalid environment variable name: AWS_BATCH_MY_NAME. Environment variable names starting with 'AWS_BATCH' are reserved./,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if arraySize is out of limits 2-10000",
            "suites": [],
            "updatePoint": {
                "line": 288,
                "column": 55
            },
            "line": 288,
            "code": "test('Task throws if arraySize is out of limits 2-10000', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      arraySize: 1,\n    });\n  }).toThrow(\n    /arraySize must be between 2 and 10,000/,\n  );\n\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task2', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      arraySize: 10001,\n    });\n  }).toThrow(\n    /arraySize must be between 2 and 10,000/,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if dependencies exceeds 20",
            "suites": [],
            "updatePoint": {
                "line": 312,
                "column": 44
            },
            "line": 312,
            "code": "test('Task throws if dependencies exceeds 20', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      dependsOn: [...Array(21).keys()].map(i => ({\n        jobId: `${i}`,\n        type: `some_type-${i}`,\n      })),\n    });\n  }).toThrow(\n    /dependencies must be 20 or less/,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if attempts is out of limits 1-10",
            "suites": [],
            "updatePoint": {
                "line": 328,
                "column": 51
            },
            "line": 328,
            "code": "test('Task throws if attempts is out of limits 1-10', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      attempts: 0,\n    });\n  }).toThrow(\n    /attempts must be between 1 and 10/,\n  );\n\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task2', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      attempts: 11,\n    });\n  }).toThrow(\n    /attempts must be between 1 and 10/,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "Task throws if attempt duration is less than 60 sec",
            "suites": [],
            "updatePoint": {
                "line": 352,
                "column": 57
            },
            "line": 352,
            "code": "test('Task throws if attempt duration is less than 60 sec', () => {\n  expect(() => {\n    new BatchSubmitJob(stack, 'Task', {\n      jobDefinitionArn: batchJobDefinition.jobDefinitionArn,\n      jobName: 'JobName',\n      jobQueueArn: batchJobQueue.jobQueueArn,\n      taskTimeout: sfn.Timeout.duration(cdk.Duration.seconds(59)),\n    });\n  }).toThrow(\n    /attempt duration must be greater than 60 seconds./,\n  );\n});",
            "file": "aws-stepfunctions-tasks/submit-job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "%p",
            "suites": [],
            "line": 43,
            "code": "describe.each([EcsEc2ContainerDefinition, EcsFargateContainerDefinition])('%p', (ContainerDefinition) => {\n  // GIVEN\n  beforeEach(() => {\n    stack = new Stack();\n    pascalCaseExpectedProps = capitalizePropertyNames(stack, defaultExpectedProps);\n  });\n\n  test('ecs container defaults', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n    });\n  });\n\n  test('respects command', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        command: ['echo', 'foo'],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Command: ['echo', 'foo'],\n      },\n    });\n  });\n\n  test('respects environment', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        environment: {\n          foo: 'bar',\n        },\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Environment: [{\n          Name: 'foo',\n          Value: 'bar',\n        }],\n      },\n    });\n  });\n\n  test('respects executionRole', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        executionRole: new Role(stack, 'execRole', {\n          assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:user/user-name'),\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ExecutionRoleArn: {\n          'Fn::GetAtt': ['execRole623CB63A', 'Arn'],\n        },\n      },\n    });\n  });\n\n  test('respects jobRole', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        jobRole: new Role(stack, 'jobRole', {\n          assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:user/user-name'),\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        JobRoleArn: {\n          'Fn::GetAtt': ['jobRoleA2173686', 'Arn'],\n        },\n      },\n    });\n  });\n\n  test('respects linuxParameters', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        linuxParameters: new LinuxParameters(stack, 'linuxParameters', {\n          initProcessEnabled: true,\n          maxSwap: Size.kibibytes(4096),\n          sharedMemorySize: Size.mebibytes(256),\n          swappiness: 30,\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        LinuxParameters: {\n          InitProcessEnabled: true,\n          MaxSwap: 4,\n          SharedMemorySize: 256,\n          Swappiness: 30,\n        },\n      },\n    });\n  });\n\n  test('respects logging and creates an execution role for EC2 and Fargate containers', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        logging: ecs.LogDriver.awsLogs({\n          datetimeFormat: 'format',\n          logRetention: logs.RetentionDays.ONE_MONTH,\n          multilinePattern: 'pattern',\n          streamPrefix: 'hello',\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ExecutionRoleArn: {\n          'Fn::GetAtt': ['EcsContainerExecutionRole3B199293', 'Arn'],\n        },\n        ...pascalCaseExpectedProps.ContainerProperties,\n        LogConfiguration: {\n          Options: {\n            'awslogs-datetime-format': 'format',\n            'awslogs-group': { Ref: 'EcsContainerLogGroup6C5D5962' },\n            'awslogs-multiline-pattern': 'pattern',\n            'awslogs-region': { Ref: 'AWS::Region' },\n            'awslogs-stream-prefix': 'hello',\n          },\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'ecs-tasks.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });\n\n  test('respects readonlyRootFilesystem', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        readonlyRootFilesystem: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ReadonlyRootFilesystem: true,\n      },\n    });\n  });\n\n  test('respects secrets', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        secrets: [\n          new Secret(stack, 'testSecret'),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Secrets: [\n          {\n            Name: {\n              'Fn::Join': [\n                '-',\n                [\n                  {\n                    'Fn::Select': [\n                      0,\n                      {\n                        'Fn::Split': [\n                          '-',\n                          {\n                            'Fn::Select': [\n                              6,\n                              {\n                                'Fn::Split': [\n                                  ':',\n                                  {\n                                    Ref: 'testSecretB96AD12C',\n                                  },\n                                ],\n                              },\n                            ],\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                  {\n                    'Fn::Select': [\n                      1,\n                      {\n                        'Fn::Split': [\n                          '-',\n                          {\n                            'Fn::Select': [\n                              6,\n                              {\n                                'Fn::Split': [\n                                  ':',\n                                  {\n                                    Ref: 'testSecretB96AD12C',\n                                  },\n                                ],\n                              },\n                            ],\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                ],\n              ],\n            },\n            ValueFrom: { Ref: 'testSecretB96AD12C' },\n          },\n        ],\n      },\n    });\n  });\n\n  test('respects user', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        user: 'foo',\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        User: 'foo',\n      },\n    });\n  });\n\n  test('respects efs volumes', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        volumes: [\n          EcsVolume.efs({\n            containerPath: '/first/path',\n            fileSystem: new efs.FileSystem(stack, 'efs', {\n              vpc: new Vpc(stack, 'vpc'),\n            }),\n            name: 'firstEfsVolume',\n            accessPointId: 'EfsVolumeAccessPointId',\n            readonly: true,\n            rootDirectory: 'efsRootDir',\n            enableTransitEncryption: true,\n            transitEncryptionPort: 20181,\n            useJobRole: true,\n          }),\n          EcsVolume.efs({\n            containerPath: '/second/path',\n            fileSystem: new efs.FileSystem(stack, 'efs2', {\n              vpc: new Vpc(stack, 'vpc2'),\n            }),\n            name: 'secondEfsVolume',\n          }),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [\n          {\n            EfsVolumeConfiguration: {\n              FileSystemId: {\n                Ref: 'efs6C17982A',\n              },\n              RootDirectory: 'efsRootDir',\n              TransitEncryptionPort: 20181,\n              AuthorizationConfig: {\n                AccessPointId: 'EfsVolumeAccessPointId',\n                Iam: 'ENABLED',\n              },\n            },\n            Name: 'firstEfsVolume',\n          },\n          {\n            EfsVolumeConfiguration: {\n              FileSystemId: {\n                Ref: 'efs2CB3916C1',\n              },\n            },\n            Name: 'secondEfsVolume',\n          },\n        ],\n        MountPoints: [\n          {\n            ContainerPath: '/first/path',\n            ReadOnly: true,\n            SourceVolume: 'firstEfsVolume',\n          },\n          {\n            ContainerPath: '/second/path',\n            SourceVolume: 'secondEfsVolume',\n          },\n        ],\n      },\n    });\n  });\n\n  test('respects host volumes', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        volumes: [\n          EcsVolume.host({\n            containerPath: '/container/path',\n            name: 'EcsHostPathVolume',\n            hostPath: '/host/path',\n          }),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [\n          {\n            Name: 'EcsHostPathVolume',\n            Host: {\n              SourcePath: '/host/path',\n            },\n          },\n        ],\n        MountPoints: [\n          {\n            ContainerPath: '/container/path',\n            SourceVolume: 'EcsHostPathVolume',\n          },\n        ],\n      },\n    });\n  });\n\n  test('respects addVolume() with an EfsVolume', () => {\n    // GIVEN\n    const jobDefn = new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EcsVolume.efs({\n      containerPath: '/container/path',\n      fileSystem: new efs.FileSystem(stack, 'efs', {\n        vpc: new Vpc(stack, 'vpc'),\n      }),\n      name: 'AddedEfsVolume',\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [{\n          Name: 'AddedEfsVolume',\n          EfsVolumeConfiguration: {\n            FileSystemId: {\n              Ref: 'efs6C17982A',\n            },\n          },\n        }],\n        MountPoints: [{\n          ContainerPath: '/container/path',\n          SourceVolume: 'AddedEfsVolume',\n        }],\n      },\n    });\n  });\n\n  test('respects addVolume() with a host volume', () => {\n    // GIVEN\n    const jobDefn = new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EcsVolume.host({\n      containerPath: '/container/path/new',\n      name: 'hostName',\n      hostPath: '/host/path',\n      readonly: false,\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [{\n          Name: 'hostName',\n          Host: {\n            SourcePath: '/host/path',\n          },\n        }],\n        MountPoints: [{\n          ContainerPath: '/container/path/new',\n          SourceVolume: 'hostName',\n        }],\n      },\n    });\n  });\n});",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "ecs container defaults",
            "suites": [],
            "updatePoint": {
                "line": 50,
                "column": 30
            },
            "line": 50,
            "code": "  test('ecs container defaults', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects command",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 24
            },
            "line": 64,
            "code": "  test('respects command', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        command: ['echo', 'foo'],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Command: ['echo', 'foo'],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects environment",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 28
            },
            "line": 83,
            "code": "  test('respects environment', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        environment: {\n          foo: 'bar',\n        },\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Environment: [{\n          Name: 'foo',\n          Value: 'bar',\n        }],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects executionRole",
            "suites": [],
            "updatePoint": {
                "line": 108,
                "column": 30
            },
            "line": 108,
            "code": "  test('respects executionRole', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        executionRole: new Role(stack, 'execRole', {\n          assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:user/user-name'),\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ExecutionRoleArn: {\n          'Fn::GetAtt': ['execRole623CB63A', 'Arn'],\n        },\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects jobRole",
            "suites": [],
            "updatePoint": {
                "line": 132,
                "column": 24
            },
            "line": 132,
            "code": "  test('respects jobRole', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        jobRole: new Role(stack, 'jobRole', {\n          assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:user/user-name'),\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        JobRoleArn: {\n          'Fn::GetAtt': ['jobRoleA2173686', 'Arn'],\n        },\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects linuxParameters",
            "suites": [],
            "updatePoint": {
                "line": 156,
                "column": 32
            },
            "line": 156,
            "code": "  test('respects linuxParameters', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        privileged: true,\n        linuxParameters: new LinuxParameters(stack, 'linuxParameters', {\n          initProcessEnabled: true,\n          maxSwap: Size.kibibytes(4096),\n          sharedMemorySize: Size.mebibytes(256),\n          swappiness: 30,\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        LinuxParameters: {\n          InitProcessEnabled: true,\n          MaxSwap: 4,\n          SharedMemorySize: 256,\n          Swappiness: 30,\n        },\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects logging and creates an execution role for EC2 and Fargate containers",
            "suites": [],
            "updatePoint": {
                "line": 186,
                "column": 85
            },
            "line": 186,
            "code": "  test('respects logging and creates an execution role for EC2 and Fargate containers', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        logging: ecs.LogDriver.awsLogs({\n          datetimeFormat: 'format',\n          logRetention: logs.RetentionDays.ONE_MONTH,\n          multilinePattern: 'pattern',\n          streamPrefix: 'hello',\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ExecutionRoleArn: {\n          'Fn::GetAtt': ['EcsContainerExecutionRole3B199293', 'Arn'],\n        },\n        ...pascalCaseExpectedProps.ContainerProperties,\n        LogConfiguration: {\n          Options: {\n            'awslogs-datetime-format': 'format',\n            'awslogs-group': { Ref: 'EcsContainerLogGroup6C5D5962' },\n            'awslogs-multiline-pattern': 'pattern',\n            'awslogs-region': { Ref: 'AWS::Region' },\n            'awslogs-stream-prefix': 'hello',\n          },\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'ecs-tasks.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects readonlyRootFilesystem",
            "suites": [],
            "updatePoint": {
                "line": 232,
                "column": 39
            },
            "line": 232,
            "code": "  test('respects readonlyRootFilesystem', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        readonlyRootFilesystem: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ReadonlyRootFilesystem: true,\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects secrets",
            "suites": [],
            "updatePoint": {
                "line": 251,
                "column": 24
            },
            "line": 251,
            "code": "  test('respects secrets', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        secrets: [\n          new Secret(stack, 'testSecret'),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Secrets: [\n          {\n            Name: {\n              'Fn::Join': [\n                '-',\n                [\n                  {\n                    'Fn::Select': [\n                      0,\n                      {\n                        'Fn::Split': [\n                          '-',\n                          {\n                            'Fn::Select': [\n                              6,\n                              {\n                                'Fn::Split': [\n                                  ':',\n                                  {\n                                    Ref: 'testSecretB96AD12C',\n                                  },\n                                ],\n                              },\n                            ],\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                  {\n                    'Fn::Select': [\n                      1,\n                      {\n                        'Fn::Split': [\n                          '-',\n                          {\n                            'Fn::Select': [\n                              6,\n                              {\n                                'Fn::Split': [\n                                  ':',\n                                  {\n                                    Ref: 'testSecretB96AD12C',\n                                  },\n                                ],\n                              },\n                            ],\n                          },\n                        ],\n                      },\n                    ],\n                  },\n                ],\n              ],\n            },\n            ValueFrom: { Ref: 'testSecretB96AD12C' },\n          },\n        ],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects user",
            "suites": [],
            "updatePoint": {
                "line": 329,
                "column": 21
            },
            "line": 329,
            "code": "  test('respects user', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        user: 'foo',\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        User: 'foo',\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects efs volumes",
            "suites": [],
            "updatePoint": {
                "line": 348,
                "column": 28
            },
            "line": 348,
            "code": "  test('respects efs volumes', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        volumes: [\n          EcsVolume.efs({\n            containerPath: '/first/path',\n            fileSystem: new efs.FileSystem(stack, 'efs', {\n              vpc: new Vpc(stack, 'vpc'),\n            }),\n            name: 'firstEfsVolume',\n            accessPointId: 'EfsVolumeAccessPointId',\n            readonly: true,\n            rootDirectory: 'efsRootDir',\n            enableTransitEncryption: true,\n            transitEncryptionPort: 20181,\n            useJobRole: true,\n          }),\n          EcsVolume.efs({\n            containerPath: '/second/path',\n            fileSystem: new efs.FileSystem(stack, 'efs2', {\n              vpc: new Vpc(stack, 'vpc2'),\n            }),\n            name: 'secondEfsVolume',\n          }),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [\n          {\n            EfsVolumeConfiguration: {\n              FileSystemId: {\n                Ref: 'efs6C17982A',\n              },\n              RootDirectory: 'efsRootDir',\n              TransitEncryptionPort: 20181,\n              AuthorizationConfig: {\n                AccessPointId: 'EfsVolumeAccessPointId',\n                Iam: 'ENABLED',\n              },\n            },\n            Name: 'firstEfsVolume',\n          },\n          {\n            EfsVolumeConfiguration: {\n              FileSystemId: {\n                Ref: 'efs2CB3916C1',\n              },\n            },\n            Name: 'secondEfsVolume',\n          },\n        ],\n        MountPoints: [\n          {\n            ContainerPath: '/first/path',\n            ReadOnly: true,\n            SourceVolume: 'firstEfsVolume',\n          },\n          {\n            ContainerPath: '/second/path',\n            SourceVolume: 'secondEfsVolume',\n          },\n        ],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects host volumes",
            "suites": [],
            "updatePoint": {
                "line": 422,
                "column": 29
            },
            "line": 422,
            "code": "  test('respects host volumes', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n        volumes: [\n          EcsVolume.host({\n            containerPath: '/container/path',\n            name: 'EcsHostPathVolume',\n            hostPath: '/host/path',\n          }),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [\n          {\n            Name: 'EcsHostPathVolume',\n            Host: {\n              SourcePath: '/host/path',\n            },\n          },\n        ],\n        MountPoints: [\n          {\n            ContainerPath: '/container/path',\n            SourceVolume: 'EcsHostPathVolume',\n          },\n        ],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects addVolume() with an EfsVolume",
            "suites": [],
            "updatePoint": {
                "line": 460,
                "column": 46
            },
            "line": 460,
            "code": "  test('respects addVolume() with an EfsVolume', () => {\n    // GIVEN\n    const jobDefn = new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EcsVolume.efs({\n      containerPath: '/container/path',\n      fileSystem: new efs.FileSystem(stack, 'efs', {\n        vpc: new Vpc(stack, 'vpc'),\n      }),\n      name: 'AddedEfsVolume',\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [{\n          Name: 'AddedEfsVolume',\n          EfsVolumeConfiguration: {\n            FileSystemId: {\n              Ref: 'efs6C17982A',\n            },\n          },\n        }],\n        MountPoints: [{\n          ContainerPath: '/container/path',\n          SourceVolume: 'AddedEfsVolume',\n        }],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects addVolume() with a host volume",
            "suites": [],
            "updatePoint": {
                "line": 498,
                "column": 47
            },
            "line": 498,
            "code": "  test('respects addVolume() with a host volume', () => {\n    // GIVEN\n    const jobDefn = new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new ContainerDefinition(stack, 'EcsContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EcsVolume.host({\n      containerPath: '/container/path/new',\n      name: 'hostName',\n      hostPath: '/host/path',\n      readonly: false,\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Volumes: [{\n          Name: 'hostName',\n          Host: {\n            SourcePath: '/host/path',\n          },\n        }],\n        MountPoints: [{\n          ContainerPath: '/container/path/new',\n          SourceVolume: 'hostName',\n        }],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects addUlimit()",
            "suites": [
                "EC2 containers"
            ],
            "updatePoint": {
                "line": 541,
                "column": 28
            },
            "line": 541,
            "code": "  test('respects addUlimit()', () => {\n    // GIVEN\n    const jobDefn = new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsEc2ContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    (jobDefn.container as IEcsEc2ContainerDefinition).addUlimit({\n      hardLimit: 10,\n      name: UlimitName.SIGPENDING,\n      softLimit: 1,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Ulimits: [{\n          HardLimit: 10,\n          SoftLimit: 1,\n          Name: 'sigpending',\n        }],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects ulimits",
            "suites": [
                "EC2 containers"
            ],
            "updatePoint": {
                "line": 570,
                "column": 24
            },
            "line": 570,
            "code": "  test('respects ulimits', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsEc2ContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        ulimits: [\n          {\n            hardLimit: 100,\n            name: UlimitName.CORE,\n            softLimit: 10,\n          },\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Ulimits: [\n          {\n            HardLimit: 100,\n            Name: 'core',\n            SoftLimit: 10,\n          },\n        ],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects privileged",
            "suites": [
                "EC2 containers"
            ],
            "updatePoint": {
                "line": 601,
                "column": 27
            },
            "line": 601,
            "code": "  test('respects privileged', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsEc2ContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        privileged: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Privileged: true,\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects gpu",
            "suites": [
                "EC2 containers"
            ],
            "updatePoint": {
                "line": 620,
                "column": 20
            },
            "line": 620,
            "code": "  test('respects gpu', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsEc2ContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        privileged: true,\n        gpu: 12,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ResourceRequirements: [\n          {\n            Type: 'MEMORY',\n            Value: '2048',\n          },\n          {\n            Type: 'VCPU',\n            Value: '256',\n          },\n          {\n            Type: 'GPU',\n            Value: '12',\n          },\n        ],\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can use an assset as a container",
            "suites": [
                "EC2 containers"
            ],
            "updatePoint": {
                "line": 653,
                "column": 40
            },
            "line": 653,
            "code": "  test('can use an assset as a container', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsEc2ContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        image: ecs.ContainerImage.fromAsset(\n          path.join(__dirname, 'batchjob-image'),\n        ),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        Image: {\n          'Fn::Sub': '${AWS::AccountId}.dkr.ecr.${AWS::Region}.${AWS::URLSuffix}/cdk-hnb659fds-container-assets-${AWS::AccountId}-${AWS::Region}:8b518243ecbfcfd08b4734069e7e74ff97b7889dfde0a60d16e7bdc96e6c593b',\n        },\n        ExecutionRoleArn: { 'Fn::GetAtt': ['EcsEc2ContainerExecutionRole90E18680', 'Arn'] },\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "create executionRole by default",
            "suites": [
                "Fargate containers"
            ],
            "updatePoint": {
                "line": 685,
                "column": 39
            },
            "line": 685,
            "code": "  test('create executionRole by default', () => {\n    // WHEN\n    new EcsJobDefinition(stack, 'ECSJobDefn', {\n      container: new EcsFargateContainerDefinition(stack, 'EcsFargateContainer', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      ContainerProperties: {\n        ...pascalCaseExpectedProps.ContainerProperties,\n        ExecutionRoleArn: {\n          'Fn::GetAtt': ['EcsFargateContainerExecutionRole3286EAFE', 'Arn'],\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'ecs-tasks.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "ecs-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition respects propagateTags",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 45
            },
            "line": 7,
            "code": "test('EcsJobDefinition respects propagateTags', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EcsJobDefinition(stack, 'JobDefn', {\n    propagateTags: true,\n    container: new EcsEc2ContainerDefinition(stack, 'EcsContainer', {\n      cpu: 256,\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      memory: Size.mebibytes(2048),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    PropagateTags: true,\n  });\n});",
            "file": "ecs-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition uses Compatibility.EC2 for EC2 containers",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 64
            },
            "line": 27,
            "code": "test('EcsJobDefinition uses Compatibility.EC2 for EC2 containers', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EcsJobDefinition(stack, 'ECSJobDefn', {\n    container: new EcsEc2ContainerDefinition(stack, 'EcsContainer', {\n      cpu: 256,\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      memory: Size.mebibytes(2048),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    PlatformCapabilities: [Compatibility.EC2],\n  });\n});",
            "file": "ecs-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition uses Compatibility.FARGATE for Fargate containers",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 72
            },
            "line": 46,
            "code": "test('EcsJobDefinition uses Compatibility.FARGATE for Fargate containers', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EcsJobDefinition(stack, 'ECSJobDefn', {\n    container: new EcsFargateContainerDefinition(stack, 'EcsContainer', {\n      cpu: 256,\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      memory: Size.mebibytes(2048),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    PlatformCapabilities: [Compatibility.FARGATE],\n  });\n});",
            "file": "ecs-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be imported from ARN",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 30
            },
            "line": 65,
            "code": "test('can be imported from ARN', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const importedJob = EcsJobDefinition.fromJobDefinitionArn(stack, 'importedJobDefinition',\n    'arn:aws:batch:us-east-1:123456789012:job-definition/job-def-name:1');\n\n  // THEN\n  expect(importedJob.jobDefinitionArn).toEqual('arn:aws:batch:us-east-1:123456789012:job-definition/job-def-name:1');\n});",
            "file": "ecs-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "eks container defaults",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 35,
                "column": 30
            },
            "line": 35,
            "code": "  test('eks container defaults', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects args",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 49,
                "column": 21
            },
            "line": 49,
            "code": "  test('respects args', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        args: ['arg1', 'arg2'],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Args: ['arg1', 'arg2'],\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects command",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 73,
                "column": 24
            },
            "line": 73,
            "code": "  test('respects command', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        command: ['echo', 'bar'],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Command: ['echo', 'bar'],\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects cpuLimit",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 97,
                "column": 25
            },
            "line": 97,
            "code": "  test('respects cpuLimit', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        cpuLimit: 256,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Limits: {\n                cpu: 256,\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects cpuReservation",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 125,
                "column": 31
            },
            "line": 125,
            "code": "  test('respects cpuReservation', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        cpuReservation: 256,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Requests: {\n                cpu: 256,\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects memoryLimitMiB",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 153,
                "column": 31
            },
            "line": 153,
            "code": "  test('respects memoryLimitMiB', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        memoryLimit: Size.mebibytes(2048),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Limits: {\n                memory: '2048Mi',\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects memoryReservation",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 181,
                "column": 34
            },
            "line": 181,
            "code": "  test('respects memoryReservation', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        memoryReservation: Size.mebibytes(2048),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Requests: {\n                memory: '2048Mi',\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects gpuLimit",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 209,
                "column": 25
            },
            "line": 209,
            "code": "  test('respects gpuLimit', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        gpuLimit: 20,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Limits: {\n                'nvidia.com/gpu': 20,\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects gpuReservation",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 237,
                "column": 31
            },
            "line": 237,
            "code": "  test('respects gpuReservation', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        gpuReservation: 20,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Requests: {\n                'nvidia.com/gpu': 20,\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects resource requests and limits",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 265,
                "column": 45
            },
            "line": 265,
            "code": "  test('respects resource requests and limits', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        cpuLimit: 256,\n        cpuReservation: 128,\n        memoryLimit: Size.mebibytes(2048),\n        memoryReservation: Size.mebibytes(2048),\n        gpuLimit: 20,\n        gpuReservation: 10,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Resources: {\n              Limits: {\n                'cpu': 256,\n                'memory': '2048Mi',\n                'nvidia.com/gpu': 20,\n              },\n              Requests: {\n                'cpu': 128,\n                'memory': '2048Mi',\n                'nvidia.com/gpu': 10,\n              },\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects env",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 305,
                "column": 20
            },
            "line": 305,
            "code": "  test('respects env', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        env: {\n          var: 'val',\n          boo: 'bah',\n        },\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Env: [\n              {\n                Name: 'var',\n                Value: 'val',\n              },\n              {\n                Name: 'boo',\n                Value: 'bah',\n              },\n            ],\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects imagePullPolicy",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 341,
                "column": 32
            },
            "line": 341,
            "code": "  test('respects imagePullPolicy', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        imagePullPolicy: ImagePullPolicy.NEVER,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            ImagePullPolicy: 'Never',\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects name",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 365,
                "column": 21
            },
            "line": 365,
            "code": "  test('respects name', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        name: 'myContainerName',\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            Name: 'myContainerName',\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects privileged",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 389,
                "column": 27
            },
            "line": 389,
            "code": "  test('respects privileged', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        privileged: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            SecurityContext: {\n              Privileged: true,\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects readonlyFileSystem",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 415,
                "column": 35
            },
            "line": 415,
            "code": "  test('respects readonlyFileSystem', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        readonlyRootFilesystem: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            SecurityContext: {\n              ReadOnlyRootFilesystem: true,\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects runAsGroup",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 441,
                "column": 27
            },
            "line": 441,
            "code": "  test('respects runAsGroup', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        runAsGroup: 1,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            SecurityContext: {\n              RunAsGroup: 1,\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects runAsRoot",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 467,
                "column": 26
            },
            "line": 467,
            "code": "  test('respects runAsRoot', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        runAsRoot: true,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            SecurityContext: {\n              RunAsNonRoot: false,\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects runAsUser",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 493,
                "column": 26
            },
            "line": 493,
            "code": "  test('respects runAsUser', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        runAsUser: 90,\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            SecurityContext: {\n              RunAsUser: 90,\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects emptyDir volumes",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 519,
                "column": 33
            },
            "line": 519,
            "code": "  test('respects emptyDir volumes', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        volumes: [\n          EksVolume.emptyDir({\n            name: 'emptyDirName',\n            medium: EmptyDirMediumType.DISK,\n            mountPath: '/mount/path',\n            readonly: false,\n            sizeLimit: Size.mebibytes(2048),\n          }),\n        ],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            VolumeMounts: [{\n              MountPath: '/mount/path',\n              Name: 'emptyDirName',\n              ReadOnly: false,\n            }],\n          }],\n          Volumes: [{\n            Name: 'emptyDirName',\n            EmptyDir: {\n              Medium: '',\n              SizeLimit: '2048Mi',\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects hostPath volumes",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 562,
                "column": 33
            },
            "line": 562,
            "code": "  test('respects hostPath volumes', () => {\n    // WHEN\n    new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n        volumes: [EksVolume.hostPath({\n          name: 'hostPathName',\n          hostPath: 'hostPathPath',\n          mountPath: '/mount/path',\n          readonly: true,\n        })],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            VolumeMounts: [{\n              MountPath: '/mount/path',\n              Name: 'hostPathName',\n              ReadOnly: true,\n            }],\n          }],\n          Volumes: [{\n            Name: 'hostPathName',\n            HostPath: {\n              Path: 'hostPathPath',\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects addVolume() with emptyDir volume",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 601,
                "column": 49
            },
            "line": 601,
            "code": "  test('respects addVolume() with emptyDir volume', () => {\n    // GIVEN\n    const jobDefn = new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EksVolume.emptyDir({\n      name: 'emptyDirName',\n      medium: EmptyDirMediumType.DISK,\n      mountPath: '/mount/path',\n      readonly: false,\n      sizeLimit: Size.mebibytes(2048),\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            VolumeMounts: [{\n              MountPath: '/mount/path',\n              Name: 'emptyDirName',\n              ReadOnly: false,\n            }],\n          }],\n          Volumes: [{\n            Name: 'emptyDirName',\n            EmptyDir: {\n              Medium: '',\n              SizeLimit: '2048Mi',\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects addVolume() with hostPath volume",
            "suites": [
                "eks container"
            ],
            "updatePoint": {
                "line": 644,
                "column": 49
            },
            "line": 644,
            "code": "  test('respects addVolume() with hostPath volume', () => {\n    // GIVEN\n    const jobDefn = new EksJobDefinition(stack, 'ECSJobDefn', {\n      container: new EksContainerDefinition(stack, 'EcsEc2Container', {\n        ...defaultContainerProps,\n      }),\n    });\n\n    // WHEN\n    jobDefn.container.addVolume(EksVolume.hostPath({\n      name: 'hostPathName',\n      hostPath: 'hostPathPath',\n      mountPath: '/mount/path',\n      readonly: true,\n    }));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...pascalCaseExpectedProps,\n      EksProperties: {\n        PodProperties: {\n          ...pascalCaseExpectedProps.EksProperties.PodProperties,\n          Containers: [{\n            ...pascalCaseExpectedProps.EksProperties.PodProperties.Containers[0],\n            VolumeMounts: [{\n              MountPath: '/mount/path',\n              Name: 'hostPathName',\n              ReadOnly: true,\n            }],\n          }],\n          Volumes: [{\n            Name: 'hostPathName',\n            HostPath: {\n              Path: 'hostPathPath',\n            },\n          }],\n        },\n      },\n    });\n  });",
            "file": "eks-container-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition respects dnsPolicy",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 41
            },
            "line": 7,
            "code": "test('EcsJobDefinition respects dnsPolicy', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EksJobDefinition(stack, 'EKSJobDefn', {\n    container: new EksContainerDefinition(stack, 'EksContainer', {\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    }),\n    dnsPolicy: DnsPolicy.CLUSTER_FIRST,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    EksProperties: {\n      PodProperties: {\n        DnsPolicy: DnsPolicy.CLUSTER_FIRST,\n      },\n    },\n  });\n});",
            "file": "eks-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition respects useHostNetwork",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 46
            },
            "line": 29,
            "code": "test('EcsJobDefinition respects useHostNetwork', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EksJobDefinition(stack, 'EKSJobDefn', {\n    container: new EksContainerDefinition(stack, 'EksContainer', {\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    }),\n    useHostNetwork: true,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    EksProperties: {\n      PodProperties: {\n        HostNetwork: true,\n      },\n    },\n  });\n});",
            "file": "eks-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition respects serviceAccount",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 46
            },
            "line": 51,
            "code": "test('EcsJobDefinition respects serviceAccount', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new EksJobDefinition(stack, 'EKSJobDefn', {\n    container: new EksContainerDefinition(stack, 'EksContainer', {\n      image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n    }),\n    serviceAccount: 'my-service-account',\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    EksProperties: {\n      PodProperties: {\n        ServiceAccountName: 'my-service-account',\n      },\n    },\n  });\n});",
            "file": "eks-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be imported from ARN",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 30
            },
            "line": 73,
            "code": "test('can be imported from ARN', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const importedJob = EksJobDefinition.fromEksJobDefinitionArn(stack, 'importedJobDefinition',\n    'arn:aws:batch:us-east-1:123456789012:job-definition/job-def-name:1');\n\n  // THEN\n  expect(importedJob.jobDefinitionArn).toEqual('arn:aws:batch:us-east-1:123456789012:job-definition/job-def-name:1');\n});",
            "file": "eks-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "%p type JobDefinition",
            "suites": [],
            "line": 33,
            "code": "describe.each([batch.EcsJobDefinition, batch.EksJobDefinition, batch.MultiNodeJobDefinition])('%p type JobDefinition', (JobDefinition) => {\n  // GIVEN\n  beforeEach(() => {\n    stack = new Stack();\n\n    pascalCaseExpectedEcsProps = capitalizePropertyNames(stack, defaultExpectedEcsProps);\n    pascalCaseExpectedEksProps = capitalizePropertyNames(stack, defaultExpectedEksProps);\n    pascalCaseExpectedMultiNodeProps = capitalizePropertyNames(stack, defaultExpectedMultiNodeProps);\n\n    defaultEcsProps = {\n      container: new batch.EcsEc2ContainerDefinition(stack, 'EcsContainer', {\n        cpu: 256,\n        memory: Size.mebibytes(2048),\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      }),\n    };\n    defaultEksProps = {\n      container: new batch.EksContainerDefinition(stack, 'EksContainer', {\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      }),\n    };\n    defaultMultiNodeProps = {\n      containers: [{\n        container: new batch.EcsEc2ContainerDefinition(stack, 'MultinodeEcsContainer', {\n          cpu: 256,\n          memory: Size.mebibytes(2048),\n          image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n        }),\n        startNode: 0,\n        endNode: 10,\n      }],\n      mainNode: 0,\n      instanceType: InstanceType.of(InstanceClass.R4, InstanceSize.LARGE),\n    };\n    switch (JobDefinition) {\n      case batch.EcsJobDefinition:\n        expectedProps = pascalCaseExpectedEcsProps;\n        defaultProps = defaultEcsProps;\n        break;\n      case batch.EksJobDefinition:\n        expectedProps = pascalCaseExpectedEksProps;\n        defaultProps = defaultEksProps;\n        break;\n      case batch.MultiNodeJobDefinition:\n        expectedProps = pascalCaseExpectedMultiNodeProps;\n        defaultProps = defaultMultiNodeProps;\n        break;\n    }\n  });\n\n  test('JobDefinition respects name', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      jobDefinitionName: 'myEcsJob',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      JobDefinitionName: 'myEcsJob',\n    });\n  });\n\n  test('JobDefinition respects parameters', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      parameters: {\n        foo: 'bar',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      Parameters: {\n        foo: 'bar',\n      },\n    });\n  });\n\n  test('JobDefinition respects retryAttempts', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      retryAttempts: 8,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        Attempts: 8,\n      },\n    });\n  });\n\n  test('JobDefinition respects retryStrategies', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      retryStrategies: [\n        batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.CANNOT_PULL_CONTAINER),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.NON_ZERO_EXIT_CODE),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.SPOT_INSTANCE_RECLAIMED),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.custom({\n          onExitCode: '40*',\n          onReason: 'reason*',\n          onStatusReason: 'statusReason',\n        })),\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        EvaluateOnExit: [\n          {\n            Action: 'EXIT',\n            OnReason: 'CannotPullContainerError:*',\n          },\n          {\n            Action: 'RETRY',\n            OnExitCode: '*',\n          },\n          {\n            Action: 'RETRY',\n            OnStatusReason: 'Host EC2*',\n          },\n          {\n            Action: 'RETRY',\n            OnExitCode: '40*',\n            OnReason: 'reason*',\n            OnStatusReason: 'statusReason',\n          },\n        ],\n      },\n    });\n  });\n\n  test('JobDefinition respects schedulingPriority', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      schedulingPriority: 10,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      SchedulingPriority: 10,\n    });\n  });\n\n  test('JobDefinition respects schedulingPriority', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      timeout: Duration.minutes(10),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      Timeout: {\n        AttemptDurationSeconds: 600,\n      },\n    });\n  });\n\n  test('JobDefinition respects addRetryStrategy()', () => {\n    // WHEN\n    const jobDefn = new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n    });\n\n    jobDefn.addRetryStrategy(batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.SPOT_INSTANCE_RECLAIMED));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        EvaluateOnExit: [\n          {\n            Action: 'RETRY',\n            OnStatusReason: 'Host EC2*',\n          },\n        ],\n      },\n    });\n  });\n\n  /*\n  test('can be imported from name', () => {\n    // WHEN\n    const importedJob = JobDefinition.fromJobDefinitionName(stack, 'job-def-clone', 'job-def-name');\n\n    // THEN\n    expect(importedJob.jobDefinitionName).toEqual('job-def-name');\n    expect(importedJob.jobDefinitionArn)\n      .toEqual(`arn:${Aws.PARTITION}:batch:${Aws.REGION}:${Aws.ACCOUNT_ID}:job-definition/job-def-name`);\n  });\n  */\n});",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects name",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 35
            },
            "line": 83,
            "code": "  test('JobDefinition respects name', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      jobDefinitionName: 'myEcsJob',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      JobDefinitionName: 'myEcsJob',\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects parameters",
            "suites": [],
            "updatePoint": {
                "line": 97,
                "column": 41
            },
            "line": 97,
            "code": "  test('JobDefinition respects parameters', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      parameters: {\n        foo: 'bar',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      Parameters: {\n        foo: 'bar',\n      },\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects retryAttempts",
            "suites": [],
            "updatePoint": {
                "line": 115,
                "column": 44
            },
            "line": 115,
            "code": "  test('JobDefinition respects retryAttempts', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      retryAttempts: 8,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        Attempts: 8,\n      },\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects retryStrategies",
            "suites": [],
            "updatePoint": {
                "line": 131,
                "column": 46
            },
            "line": 131,
            "code": "  test('JobDefinition respects retryStrategies', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      retryStrategies: [\n        batch.RetryStrategy.of(batch.Action.EXIT, batch.Reason.CANNOT_PULL_CONTAINER),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.NON_ZERO_EXIT_CODE),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.SPOT_INSTANCE_RECLAIMED),\n        batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.custom({\n          onExitCode: '40*',\n          onReason: 'reason*',\n          onStatusReason: 'statusReason',\n        })),\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        EvaluateOnExit: [\n          {\n            Action: 'EXIT',\n            OnReason: 'CannotPullContainerError:*',\n          },\n          {\n            Action: 'RETRY',\n            OnExitCode: '*',\n          },\n          {\n            Action: 'RETRY',\n            OnStatusReason: 'Host EC2*',\n          },\n          {\n            Action: 'RETRY',\n            OnExitCode: '40*',\n            OnReason: 'reason*',\n            OnStatusReason: 'statusReason',\n          },\n        ],\n      },\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects schedulingPriority",
            "suites": [],
            "updatePoint": {
                "line": 175,
                "column": 49
            },
            "line": 175,
            "code": "  test('JobDefinition respects schedulingPriority', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      schedulingPriority: 10,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      SchedulingPriority: 10,\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects schedulingPriority",
            "suites": [],
            "updatePoint": {
                "line": 189,
                "column": 49
            },
            "line": 189,
            "code": "  test('JobDefinition respects schedulingPriority', () => {\n    // WHEN\n    new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n      timeout: Duration.minutes(10),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      Timeout: {\n        AttemptDurationSeconds: 600,\n      },\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobDefinition respects addRetryStrategy()",
            "suites": [],
            "updatePoint": {
                "line": 205,
                "column": 49
            },
            "line": 205,
            "code": "  test('JobDefinition respects addRetryStrategy()', () => {\n    // WHEN\n    const jobDefn = new JobDefinition(stack, 'JobDefn', {\n      ...defaultProps,\n    });\n\n    jobDefn.addRetryStrategy(batch.RetryStrategy.of(batch.Action.RETRY, batch.Reason.SPOT_INSTANCE_RECLAIMED));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n      ...expectedProps,\n      RetryStrategy: {\n        EvaluateOnExit: [\n          {\n            Action: 'RETRY',\n            OnStatusReason: 'Host EC2*',\n          },\n        ],\n      },\n    });\n  });",
            "file": "job-definition-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue respects computeEnvironments",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 43
            },
            "line": 7,
            "code": "test('JobQueue respects computeEnvironments', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  new JobQueue(stack, 'joBBQ', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'CE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobQueue', {\n    ComputeEnvironmentOrder: [{\n      ComputeEnvironment: { 'Fn::GetAtt': ['CE1BFE03A1', 'ComputeEnvironmentArn'] },\n      Order: 1,\n    }],\n    Priority: 10,\n    State: 'ENABLED',\n  });\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue respects enabled",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 31
            },
            "line": 34,
            "code": "test('JobQueue respects enabled', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  new JobQueue(stack, 'joBBQ', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'CE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n    enabled: false,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobQueue', {\n    ComputeEnvironmentOrder: [{\n      ComputeEnvironment: { 'Fn::GetAtt': ['CE1BFE03A1', 'ComputeEnvironmentArn'] },\n      Order: 1,\n    }],\n    Priority: 10,\n    State: 'DISABLED',\n  });\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue respects name",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 28
            },
            "line": 62,
            "code": "test('JobQueue respects name', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  new JobQueue(stack, 'joBBQ', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'CE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n    jobQueueName: 'JoBBQ',\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobQueue', {\n    ComputeEnvironmentOrder: [{\n      ComputeEnvironment: { 'Fn::GetAtt': ['CE1BFE03A1', 'ComputeEnvironmentArn'] },\n      Order: 1,\n    }],\n    Priority: 10,\n    JobQueueName: 'JoBBQ',\n  });\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue respects schedulingPolicy",
            "suites": [],
            "updatePoint": {
                "line": 90,
                "column": 40
            },
            "line": 90,
            "code": "test('JobQueue respects schedulingPolicy', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  new JobQueue(stack, 'JobQueue', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'CE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n    schedulingPolicy: new FairshareSchedulingPolicy(stack, 'FairsharePolicy'),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobQueue', {\n    ComputeEnvironmentOrder: [{\n      ComputeEnvironment: { 'Fn::GetAtt': ['CE1BFE03A1', 'ComputeEnvironmentArn'] },\n      Order: 1,\n    }],\n    Priority: 10,\n    SchedulingPolicyArn: {\n      'Fn::GetAtt': ['FairsharePolicy51969009', 'Arn'],\n    },\n  });\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue respects addComputeEnvironment",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 45
            },
            "line": 120,
            "code": "test('JobQueue respects addComputeEnvironment', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  const queue = new JobQueue(stack, 'JobQueue', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'FirstCE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n    schedulingPolicy: new FairshareSchedulingPolicy(stack, 'FairsharePolicy'),\n  });\n\n  queue.addComputeEnvironment(\n    new ManagedEc2EcsComputeEnvironment(stack, 'SecondCE', {\n      vpc,\n    }),\n    2,\n  );\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobQueue', {\n    ComputeEnvironmentOrder: [\n      {\n        ComputeEnvironment: { 'Fn::GetAtt': ['FirstCEAD3794AD', 'ComputeEnvironmentArn'] },\n        Order: 1,\n      },\n      {\n        ComputeEnvironment: { 'Fn::GetAtt': ['SecondCEEBA93938', 'ComputeEnvironmentArn'] },\n        Order: 2,\n      },\n    ],\n    Priority: 10,\n    SchedulingPolicyArn: {\n      'Fn::GetAtt': ['FairsharePolicy51969009', 'Arn'],\n    },\n  });\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be imported from ARN",
            "suites": [],
            "updatePoint": {
                "line": 163,
                "column": 30
            },
            "line": 163,
            "code": "test('can be imported from ARN', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const queue = JobQueue.fromJobQueueArn(stack, 'importedJobQueue',\n    'arn:aws:batch:us-east-1:123456789012:job-queue/importedJobQueue');\n\n  // THEN\n  expect(queue.jobQueueArn).toEqual('arn:aws:batch:us-east-1:123456789012:job-queue/importedJobQueue');\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "JobQueue throws when the same order is assigned to multiple ComputeEnvironments",
            "suites": [],
            "updatePoint": {
                "line": 175,
                "column": 85
            },
            "line": 175,
            "code": "test('JobQueue throws when the same order is assigned to multiple ComputeEnvironments', () => {\n  // GIVEN\n  const stack = new Stack();\n  const vpc = new ec2.Vpc(stack, 'vpc');\n\n  // WHEN\n  const joBBQ = new JobQueue(stack, 'joBBQ', {\n    computeEnvironments: [{\n      computeEnvironment: new ManagedEc2EcsComputeEnvironment(stack, 'FirstCE', {\n        vpc,\n      }),\n      order: 1,\n    }],\n    priority: 10,\n  });\n\n  joBBQ.addComputeEnvironment(\n    new ManagedEc2EcsComputeEnvironment(stack, 'SecondCE', {\n      vpc,\n    }),\n    1,\n  );\n\n  expect(() => {\n    Template.fromStack(stack);\n  }).toThrow(/assigns the same order to different ComputeEnvironments/);\n});",
            "file": "job-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "%p type ComputeEnvironment",
            "suites": [],
            "line": 68,
            "code": "describe.each([ManagedEc2EcsComputeEnvironment, ManagedEc2EksComputeEnvironment])('%p type ComputeEnvironment', (ComputeEnvironment) => {\n  beforeEach(() => {\n    stack = new Stack();\n    vpc = new ec2.Vpc(stack, 'vpc');\n\n    pascalCaseExpectedEcsProps = capitalizePropertyNames(stack, defaultExpectedEcsProps);\n    pascalCaseExpectedEksProps = capitalizePropertyNames(stack, defaultExpectedEksProps);\n    defaultComputeResources = pascalCaseExpectedEcsProps.ComputeResources;\n\n    defaultEcsProps = {\n      vpc,\n    };\n    defaultEksProps = {\n      vpc,\n      kubernetesNamespace: 'cdk-test-namespace',\n      eksCluster: new eks.Cluster(stack, 'eksTestCluster', {\n        version: eks.KubernetesVersion.V1_24,\n      }),\n    };\n    expectedProps = ComputeEnvironment === ManagedEc2EcsComputeEnvironment\n      ? pascalCaseExpectedEcsProps\n      : pascalCaseExpectedEksProps;\n    defaultProps = ComputeEnvironment === ManagedEc2EcsComputeEnvironment\n      ? defaultEcsProps as ManagedEc2EcsComputeEnvironmentProps\n      : defaultEksProps as ManagedEc2EksComputeEnvironmentProps;\n  });\n\n  test('default props', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::InstanceProfile', {\n      Roles: [{ Ref: 'MyCEInstanceProfileRole895D248D' }],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'ec2.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });\n\n  test('can specify maxvCpus', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      maxvCpus: 512,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        MaxvCpus: 512,\n      },\n    });\n  });\n\n  test('can specify minvCpus', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      minvCpus: 8,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        MinvCpus: 8,\n      },\n    });\n  });\n\n  test('can be disabled', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      enabled: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      State: 'DISABLED',\n    });\n  });\n\n  test('spot => AllocationStrategy.SPOT_CAPACITY_OPTIMIZED', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      spot: true,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Type: 'SPOT',\n        AllocationStrategy: 'SPOT_CAPACITY_OPTIMIZED',\n      },\n    });\n  });\n\n  test('images are correctly rendered as EC2ConfigurationObjects', () => {\n    const expectedImageType = ComputeEnvironment === ManagedEc2EcsComputeEnvironment\n      ? batch.EcsMachineImageType.ECS_AL2\n      : batch.EksMachineImageType.EKS_AL2;\n\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      images: [\n        {\n          image: ec2.MachineImage.latestAmazonLinux(),\n        },\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Ec2Configuration: [\n          {\n            ImageIdOverride: { Ref: 'SsmParameterValueawsserviceamiamazonlinuxlatestamznamihvmx8664gp2C96584B6F00A464EAD1953AFF4B05118Parameter' },\n            ImageType: expectedImageType,\n          },\n        ],\n      },\n    });\n  });\n\n  test('instance classes are correctly rendered', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceClasses: [ec2.InstanceClass.R4],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4',\n          'optimal',\n        ],\n      },\n    });\n  });\n\n  test('instance types are correctly rendered', () => {\n    // WHEN\n    const ce = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.R4, ec2.InstanceSize.LARGE)],\n    });\n\n    ce.addInstanceClass(ec2.InstanceClass.M4);\n    ce.addInstanceType(ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4.large',\n          'c4.large',\n          'm4',\n          'optimal',\n        ],\n      },\n    });\n  });\n\n  test('respects useOptimalInstanceClasses: false', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n      instanceClasses: [ec2.InstanceClass.R4],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4',\n        ],\n      },\n    });\n  });\n\n  test('does not throw with useOptimalInstanceClasses: false and a call to addInstanceClass()', () => {\n    // WHEN\n    const myCE = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n    });\n\n    myCE.addInstanceClass(ec2.InstanceClass.C4);\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'c4',\n        ],\n      },\n    });\n  });\n\n  test('does not throw with useOptimalInstanceClasses: false and a call to addInstanceType()', () => {\n    // WHEN\n    const myCE = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n    });\n\n    myCE.addInstanceType(ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.XLARGE112));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'c4.112xlarge',\n        ],\n      },\n    });\n  });\n\n  test('creates and uses instanceProfile, even when instanceRole is specified', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceRole: new Role(stack, 'myRole', {\n        assumedBy: new ServicePrincipal('foo.amazonaws.com', {\n          region: 'bermuda-triangle-1337',\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        // instanceRole is unchanged from default\n      },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::InstanceProfile', {\n      Roles: [{ Ref: 'myRoleE60D68E8' }],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'foo.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });\n\n  test('respects launch template', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      launchTemplate: new ec2.LaunchTemplate(stack, 'launchTemplate'),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        LaunchTemplate: {\n          LaunchTemplateId: { Ref: 'launchTemplateDEE5742D' },\n        },\n      },\n    });\n  });\n\n  test('respects name', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      computeEnvironmentName: 'NamedCE',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeEnvironmentName: 'NamedCE',\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n    });\n  });\n\n  test('respects placement group', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      placementGroup: new ec2.PlacementGroup(stack, 'myPlacementGroup'),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        PlacementGroup: {\n          'Fn::GetAtt': ['myPlacementGroup2E94D14E', 'GroupName'],\n        },\n      },\n    });\n  });\n\n  test('respects replaceComputeEnvironment', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      replaceComputeEnvironment: true,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      ReplaceComputeEnvironment: true,\n    });\n  });\n\n  test('respects security groups', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      securityGroups: [new ec2.SecurityGroup(stack, 'TestSG', {\n        vpc,\n        allowAllOutbound: false,\n      })],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        SecurityGroupIds: [{\n          'Fn::GetAtt': ['TestSG581D3391', 'GroupId'],\n        }],\n      },\n    });\n  });\n\n  test('respects service role', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      serviceRole: new Role(stack, 'TestSLR', {\n        assumedBy: new ServicePrincipal('cdk.amazonaws.com'),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ServiceRole: {\n        'Fn::GetAtt': ['TestSLR05974C22', 'Arn'],\n      },\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n    });\n  });\n\n  test('respects vpcSubnets', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpcSubnets: {\n        subnets: [new ec2.Subnet(stack, 'testSubnet', {\n          availabilityZone: 'az-3',\n          cidrBlock: '10.0.0.0/32',\n          vpcId: new ec2.Vpc(stack, 'subnetVpc').vpcId,\n        })],\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Subnets: [\n          { Ref: 'testSubnet42F0FA0C' },\n        ],\n      },\n    });\n  });\n\n  test('respects updateTimeout', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      updateTimeout: Duration.minutes(1),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      UpdatePolicy: {\n        JobExecutionTimeoutMinutes: 1,\n      },\n    });\n  });\n\n  test('respects terminateOnUpdate', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      terminateOnUpdate: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      UpdatePolicy: {\n        TerminateJobsOnUpdate: false,\n      },\n    });\n  });\n\n  test('respects updateToLatestImageVersion', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      updateToLatestImageVersion: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        UpdateToLatestImageVersion: false,\n      },\n    });\n  });\n\n  test('can be imported from arn', () => {\n    // WHEN\n    const ce = ManagedEc2EcsComputeEnvironment.fromManagedEc2EcsComputeEnvironmentArn(stack, 'import', 'arn:aws:batch:us-east-1:123456789012:compute-environment/ce-name');\n\n    // THEN\n    expect(ce.computeEnvironmentArn).toEqual('arn:aws:batch:us-east-1:123456789012:compute-environment/ce-name');\n  });\n\n  test('throws when no instance types are provided', () => {\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      useOptimalInstanceClasses: false,\n      vpc,\n    });\n\n    expect(() => {\n      Template.fromStack(stack);\n    }).toThrow(/Specifies 'useOptimalInstanceClasses: false' without specifying any instance types or classes/);\n  });\n\n  test('throws error when AllocationStrategy.SPOT_CAPACITY_OPTIMIZED is used without specfiying spot', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        allocationStrategy: AllocationStrategy.SPOT_CAPACITY_OPTIMIZED,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'AllocationStrategy.SPOT_CAPACITY_OPTIMIZED' without using spot instances/);\n  });\n\n  test('throws error when spotBidPercentage is specified without spot', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 80,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' without specifying 'spot'/);\n  });\n\n  test('throws error when spotBidPercentage is specified and spot is false', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 80,\n        spot: false,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' without specifying 'spot'/);\n  });\n\n  test('throws error when spotBidPercentage > 100', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 120,\n        spot: true,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' > 100/);\n  });\n\n  test('throws error when spotBidPercentage < 0', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: -120,\n        spot: true,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' < 0/);\n  });\n\n  test('throws error when minvCpus > maxvCpus', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        maxvCpus: 512,\n        minvCpus: 1024,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' has 'minvCpus' = 1024 > 'maxvCpus' = 512; 'minvCpus' cannot be greater than 'maxvCpus'/);\n  });\n\n  test('throws error when minvCpus < 0', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        minvCpus: -256,\n      });\n    }).toThrowError(/Managed ComputeEnvironment 'MyCE' has 'minvCpus' = -256 < 0; 'minvCpus' cannot be less than zero/);\n  });\n});",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "default props",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 21
            },
            "line": 95,
            "code": "  test('default props', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::InstanceProfile', {\n      Roles: [{ Ref: 'MyCEInstanceProfileRole895D248D' }],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'ec2.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can specify maxvCpus",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 28
            },
            "line": 121,
            "code": "  test('can specify maxvCpus', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      maxvCpus: 512,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        MaxvCpus: 512,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can specify minvCpus",
            "suites": [],
            "updatePoint": {
                "line": 139,
                "column": 28
            },
            "line": 139,
            "code": "  test('can specify minvCpus', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      minvCpus: 8,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        MinvCpus: 8,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be disabled",
            "suites": [],
            "updatePoint": {
                "line": 157,
                "column": 23
            },
            "line": 157,
            "code": "  test('can be disabled', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      enabled: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      State: 'DISABLED',\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "spot => AllocationStrategy.SPOT_CAPACITY_OPTIMIZED",
            "suites": [],
            "updatePoint": {
                "line": 172,
                "column": 58
            },
            "line": 172,
            "code": "  test('spot => AllocationStrategy.SPOT_CAPACITY_OPTIMIZED', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      spot: true,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Type: 'SPOT',\n        AllocationStrategy: 'SPOT_CAPACITY_OPTIMIZED',\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "images are correctly rendered as EC2ConfigurationObjects",
            "suites": [],
            "updatePoint": {
                "line": 191,
                "column": 64
            },
            "line": 191,
            "code": "  test('images are correctly rendered as EC2ConfigurationObjects', () => {\n    const expectedImageType = ComputeEnvironment === ManagedEc2EcsComputeEnvironment\n      ? batch.EcsMachineImageType.ECS_AL2\n      : batch.EksMachineImageType.EKS_AL2;\n\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      images: [\n        {\n          image: ec2.MachineImage.latestAmazonLinux(),\n        },\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Ec2Configuration: [\n          {\n            ImageIdOverride: { Ref: 'SsmParameterValueawsserviceamiamazonlinuxlatestamznamihvmx8664gp2C96584B6F00A464EAD1953AFF4B05118Parameter' },\n            ImageType: expectedImageType,\n          },\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "instance classes are correctly rendered",
            "suites": [],
            "updatePoint": {
                "line": 222,
                "column": 47
            },
            "line": 222,
            "code": "  test('instance classes are correctly rendered', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceClasses: [ec2.InstanceClass.R4],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4',\n          'optimal',\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "instance types are correctly rendered",
            "suites": [],
            "updatePoint": {
                "line": 243,
                "column": 45
            },
            "line": 243,
            "code": "  test('instance types are correctly rendered', () => {\n    // WHEN\n    const ce = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceTypes: [ec2.InstanceType.of(ec2.InstanceClass.R4, ec2.InstanceSize.LARGE)],\n    });\n\n    ce.addInstanceClass(ec2.InstanceClass.M4);\n    ce.addInstanceType(ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4.large',\n          'c4.large',\n          'm4',\n          'optimal',\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects useOptimalInstanceClasses: false",
            "suites": [],
            "updatePoint": {
                "line": 269,
                "column": 49
            },
            "line": 269,
            "code": "  test('respects useOptimalInstanceClasses: false', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n      instanceClasses: [ec2.InstanceClass.R4],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'r4',\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "does not throw with useOptimalInstanceClasses: false and a call to addInstanceClass()",
            "suites": [],
            "updatePoint": {
                "line": 290,
                "column": 93
            },
            "line": 290,
            "code": "  test('does not throw with useOptimalInstanceClasses: false and a call to addInstanceClass()', () => {\n    // WHEN\n    const myCE = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n    });\n\n    myCE.addInstanceClass(ec2.InstanceClass.C4);\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'c4',\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "does not throw with useOptimalInstanceClasses: false and a call to addInstanceType()",
            "suites": [],
            "updatePoint": {
                "line": 312,
                "column": 92
            },
            "line": 312,
            "code": "  test('does not throw with useOptimalInstanceClasses: false and a call to addInstanceType()', () => {\n    // WHEN\n    const myCE = new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      useOptimalInstanceClasses: false,\n    });\n\n    myCE.addInstanceType(ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.XLARGE112));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        InstanceTypes: [\n          'c4.112xlarge',\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "creates and uses instanceProfile, even when instanceRole is specified",
            "suites": [],
            "updatePoint": {
                "line": 334,
                "column": 77
            },
            "line": 334,
            "code": "  test('creates and uses instanceProfile, even when instanceRole is specified', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      instanceRole: new Role(stack, 'myRole', {\n        assumedBy: new ServicePrincipal('foo.amazonaws.com', {\n          region: 'bermuda-triangle-1337',\n        }),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        // instanceRole is unchanged from default\n      },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::InstanceProfile', {\n      Roles: [{ Ref: 'myRoleE60D68E8' }],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: { Service: 'foo.amazonaws.com' },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects launch template",
            "suites": [],
            "updatePoint": {
                "line": 369,
                "column": 32
            },
            "line": 369,
            "code": "  test('respects launch template', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      launchTemplate: new ec2.LaunchTemplate(stack, 'launchTemplate'),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        LaunchTemplate: {\n          LaunchTemplateId: { Ref: 'launchTemplateDEE5742D' },\n        },\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects name",
            "suites": [],
            "updatePoint": {
                "line": 389,
                "column": 21
            },
            "line": 389,
            "code": "  test('respects name', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      computeEnvironmentName: 'NamedCE',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeEnvironmentName: 'NamedCE',\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects placement group",
            "suites": [],
            "updatePoint": {
                "line": 407,
                "column": 32
            },
            "line": 407,
            "code": "  test('respects placement group', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      placementGroup: new ec2.PlacementGroup(stack, 'myPlacementGroup'),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        PlacementGroup: {\n          'Fn::GetAtt': ['myPlacementGroup2E94D14E', 'GroupName'],\n        },\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects replaceComputeEnvironment",
            "suites": [],
            "updatePoint": {
                "line": 427,
                "column": 42
            },
            "line": 427,
            "code": "  test('respects replaceComputeEnvironment', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      replaceComputeEnvironment: true,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      ReplaceComputeEnvironment: true,\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects security groups",
            "suites": [],
            "updatePoint": {
                "line": 445,
                "column": 32
            },
            "line": 445,
            "code": "  test('respects security groups', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      securityGroups: [new ec2.SecurityGroup(stack, 'TestSG', {\n        vpc,\n        allowAllOutbound: false,\n      })],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        SecurityGroupIds: [{\n          'Fn::GetAtt': ['TestSG581D3391', 'GroupId'],\n        }],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects service role",
            "suites": [],
            "updatePoint": {
                "line": 467,
                "column": 29
            },
            "line": 467,
            "code": "  test('respects service role', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      serviceRole: new Role(stack, 'TestSLR', {\n        assumedBy: new ServicePrincipal('cdk.amazonaws.com'),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ServiceRole: {\n        'Fn::GetAtt': ['TestSLR05974C22', 'Arn'],\n      },\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects vpcSubnets",
            "suites": [],
            "updatePoint": {
                "line": 488,
                "column": 27
            },
            "line": 488,
            "code": "  test('respects vpcSubnets', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpcSubnets: {\n        subnets: [new ec2.Subnet(stack, 'testSubnet', {\n          availabilityZone: 'az-3',\n          cidrBlock: '10.0.0.0/32',\n          vpcId: new ec2.Vpc(stack, 'subnetVpc').vpcId,\n        })],\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Subnets: [\n          { Ref: 'testSubnet42F0FA0C' },\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects updateTimeout",
            "suites": [],
            "updatePoint": {
                "line": 513,
                "column": 30
            },
            "line": 513,
            "code": "  test('respects updateTimeout', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      updateTimeout: Duration.minutes(1),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      UpdatePolicy: {\n        JobExecutionTimeoutMinutes: 1,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects terminateOnUpdate",
            "suites": [],
            "updatePoint": {
                "line": 532,
                "column": 34
            },
            "line": 532,
            "code": "  test('respects terminateOnUpdate', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      terminateOnUpdate: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n      UpdatePolicy: {\n        TerminateJobsOnUpdate: false,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects updateToLatestImageVersion",
            "suites": [],
            "updatePoint": {
                "line": 551,
                "column": 43
            },
            "line": 551,
            "code": "  test('respects updateToLatestImageVersion', () => {\n    // WHEN\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      updateToLatestImageVersion: false,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...expectedProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        UpdateToLatestImageVersion: false,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be imported from arn",
            "suites": [],
            "updatePoint": {
                "line": 568,
                "column": 32
            },
            "line": 568,
            "code": "  test('can be imported from arn', () => {\n    // WHEN\n    const ce = ManagedEc2EcsComputeEnvironment.fromManagedEc2EcsComputeEnvironmentArn(stack, 'import', 'arn:aws:batch:us-east-1:123456789012:compute-environment/ce-name');\n\n    // THEN\n    expect(ce.computeEnvironmentArn).toEqual('arn:aws:batch:us-east-1:123456789012:compute-environment/ce-name');\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws when no instance types are provided",
            "suites": [],
            "updatePoint": {
                "line": 576,
                "column": 50
            },
            "line": 576,
            "code": "  test('throws when no instance types are provided', () => {\n    new ComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      useOptimalInstanceClasses: false,\n      vpc,\n    });\n\n    expect(() => {\n      Template.fromStack(stack);\n    }).toThrow(/Specifies 'useOptimalInstanceClasses: false' without specifying any instance types or classes/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when AllocationStrategy.SPOT_CAPACITY_OPTIMIZED is used without specfiying spot",
            "suites": [],
            "updatePoint": {
                "line": 588,
                "column": 100
            },
            "line": 588,
            "code": "  test('throws error when AllocationStrategy.SPOT_CAPACITY_OPTIMIZED is used without specfiying spot', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        allocationStrategy: AllocationStrategy.SPOT_CAPACITY_OPTIMIZED,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'AllocationStrategy.SPOT_CAPACITY_OPTIMIZED' without using spot instances/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when spotBidPercentage is specified without spot",
            "suites": [],
            "updatePoint": {
                "line": 599,
                "column": 69
            },
            "line": 599,
            "code": "  test('throws error when spotBidPercentage is specified without spot', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 80,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' without specifying 'spot'/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when spotBidPercentage is specified and spot is false",
            "suites": [],
            "updatePoint": {
                "line": 610,
                "column": 74
            },
            "line": 610,
            "code": "  test('throws error when spotBidPercentage is specified and spot is false', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 80,\n        spot: false,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' without specifying 'spot'/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when spotBidPercentage > 100",
            "suites": [],
            "updatePoint": {
                "line": 622,
                "column": 49
            },
            "line": 622,
            "code": "  test('throws error when spotBidPercentage > 100', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: 120,\n        spot: true,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' > 100/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when spotBidPercentage < 0",
            "suites": [],
            "updatePoint": {
                "line": 634,
                "column": 47
            },
            "line": 634,
            "code": "  test('throws error when spotBidPercentage < 0', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        spotBidPercentage: -120,\n        spot: true,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotBidPercentage' < 0/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when minvCpus > maxvCpus",
            "suites": [],
            "updatePoint": {
                "line": 646,
                "column": 45
            },
            "line": 646,
            "code": "  test('throws error when minvCpus > maxvCpus', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        maxvCpus: 512,\n        minvCpus: 1024,\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' has 'minvCpus' = 1024 > 'maxvCpus' = 512; 'minvCpus' cannot be greater than 'maxvCpus'/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when minvCpus < 0",
            "suites": [],
            "updatePoint": {
                "line": 658,
                "column": 38
            },
            "line": 658,
            "code": "  test('throws error when minvCpus < 0', () => {\n    // THEN\n    expect(() => {\n      new ComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        vpc,\n        minvCpus: -256,\n      });\n    }).toThrowError(/Managed ComputeEnvironment 'MyCE' has 'minvCpus' = -256 < 0; 'minvCpus' cannot be less than zero/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects spotFleetRole",
            "suites": [
                "ManagedEc2EcsComputeEnvironment"
            ],
            "updatePoint": {
                "line": 691,
                "column": 30
            },
            "line": 691,
            "code": "  test('respects spotFleetRole', () => {\n    // WHEN\n    new ManagedEc2EcsComputeEnvironment(stack, 'MyCE', {\n      ...defaultEcsProps,\n      spot: true,\n      spotFleetRole: new Role(stack, 'SpotFleetRole', {\n        assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:magicuser/foobar'),\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEcsProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        AllocationStrategy: AllocationStrategy.SPOT_CAPACITY_OPTIMIZED,\n        Type: 'SPOT',\n        SpotIamFleetRole: {\n          'Fn::GetAtt': ['SpotFleetRole6D4F7558', 'Arn'],\n        },\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "image types are correctly rendered as EC2ConfigurationObjects",
            "suites": [
                "ManagedEc2EcsComputeEnvironment"
            ],
            "updatePoint": {
                "line": 715,
                "column": 69
            },
            "line": 715,
            "code": "  test('image types are correctly rendered as EC2ConfigurationObjects', () => {\n    // WHEN\n    new ManagedEc2EcsComputeEnvironment(stack, 'MyCE', {\n      ...defaultEcsProps,\n      vpc,\n      images: [\n        {\n          imageType: batch.EcsMachineImageType.ECS_AL2_NVIDIA,\n        },\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEcsProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Ec2Configuration: [\n          {\n            ImageType: 'ECS_AL2_NVIDIA',\n          },\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can use non-default allocation strategy",
            "suites": [
                "ManagedEc2EcsComputeEnvironment"
            ],
            "updatePoint": {
                "line": 741,
                "column": 47
            },
            "line": 741,
            "code": "  test('can use non-default allocation strategy', () => {\n    // WHEN\n    new ManagedEc2EcsComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      allocationStrategy: AllocationStrategy.BEST_FIT,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEcsProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        AllocationStrategy: 'BEST_FIT',\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "spot and AllocationStrategy.BEST_FIT => a default spot fleet role is created",
            "suites": [
                "ManagedEc2EcsComputeEnvironment"
            ],
            "updatePoint": {
                "line": 759,
                "column": 84
            },
            "line": 759,
            "code": "  test('spot and AllocationStrategy.BEST_FIT => a default spot fleet role is created', () => {\n    // WHEN\n    new ManagedEc2EcsComputeEnvironment(stack, 'MyCE', {\n      ...defaultProps,\n      vpc,\n      spot: true,\n      allocationStrategy: AllocationStrategy.BEST_FIT,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEcsProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Type: 'SPOT',\n        AllocationStrategy: 'BEST_FIT',\n        SpotIamFleetRole: { 'Fn::GetAtt': ['MyCESpotFleetRole70BE30A0', 'Arn'] },\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws when spotFleetRole is specified without spot",
            "suites": [
                "ManagedEc2EcsComputeEnvironment"
            ],
            "updatePoint": {
                "line": 780,
                "column": 59
            },
            "line": 780,
            "code": "  test('throws when spotFleetRole is specified without spot', () => {\n    // WHEN\n    expect(() => {\n      new ManagedEc2EcsComputeEnvironment(stack, 'MyCE', {\n        ...defaultEcsProps,\n        spotFleetRole: new Role(stack, 'SpotFleetRole', {\n          assumedBy: new ArnPrincipal('arn:aws:iam:123456789012:magicuser/foobar'),\n        }),\n      });\n    }).toThrow(/Managed ComputeEnvironment 'MyCE' specifies 'spotFleetRole' without specifying 'spot'/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "default props",
            "suites": [
                "ManagedEc2EksComputeEnvironment"
            ],
            "updatePoint": {
                "line": 814,
                "column": 21
            },
            "line": 814,
            "code": "  test('default props', () => {\n    // WHEN\n    new ManagedEc2EksComputeEnvironment(stack, 'MyCE', {\n      ...defaultEksProps,\n      vpc,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEksProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "throws error when AllocationStrategy.BEST_FIT is used",
            "suites": [
                "ManagedEc2EksComputeEnvironment"
            ],
            "updatePoint": {
                "line": 830,
                "column": 61
            },
            "line": 830,
            "code": "  test('throws error when AllocationStrategy.BEST_FIT is used', () => {\n    // THEN\n    expect(() => {\n      new ManagedEc2EksComputeEnvironment(stack, 'MyCE', {\n        ...defaultProps,\n        allocationStrategy: AllocationStrategy.BEST_FIT,\n      });\n    }).toThrow(/ManagedEc2EksComputeEnvironment 'MyCE' uses invalid allocation strategy 'AllocationStrategy.BEST_FIT'/);\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "image types are correctly rendered as EC2ConfigurationObjects",
            "suites": [
                "ManagedEc2EksComputeEnvironment"
            ],
            "updatePoint": {
                "line": 840,
                "column": 69
            },
            "line": 840,
            "code": "  test('image types are correctly rendered as EC2ConfigurationObjects', () => {\n    // WHEN\n    new ManagedEc2EksComputeEnvironment(stack, 'MyCE', {\n      ...defaultEksProps,\n      vpc,\n      images: [\n        {\n          imageType: batch.EksMachineImageType.EKS_AL2_NVIDIA,\n        },\n      ],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n      ...pascalCaseExpectedEksProps,\n      ComputeResources: {\n        ...defaultComputeResources,\n        Ec2Configuration: [\n          {\n            ImageType: 'EKS_AL2_NVIDIA',\n          },\n        ],\n      },\n    });\n  });",
            "file": "managed-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "MultiNodeJobDefinition respects mainNode",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 46
            },
            "line": 8,
            "code": "test('MultiNodeJobDefinition respects mainNode', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new MultiNodeJobDefinition(stack, 'ECSJobDefn', {\n    containers: [{\n      container: new EcsEc2ContainerDefinition(stack, 'MultinodeContainer', {\n        cpu: 256,\n        memory: Size.mebibytes(2048),\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      }),\n      startNode: 0,\n      endNode: 9,\n    }],\n    mainNode: 5,\n    instanceType: InstanceType.of(InstanceClass.R4, InstanceSize.LARGE),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    NodeProperties: {\n      MainNode: 5,\n      NodeRangeProperties: [{\n        Container: {\n          InstanceType: 'r4.large',\n        },\n        TargetNodes: '0:9',\n      }],\n      NumNodes: 10,\n    },\n    PlatformCapabilities: [Compatibility.EC2],\n  });\n});",
            "file": "multinode-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "EcsJobDefinition respects propagateTags",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 45
            },
            "line": 43,
            "code": "test('EcsJobDefinition respects propagateTags', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new MultiNodeJobDefinition(stack, 'ECSJobDefn', {\n    propagateTags: true,\n    containers: [{\n      container: new EcsEc2ContainerDefinition(stack, 'MultinodeContainer', {\n        cpu: 256,\n        memory: Size.mebibytes(2048),\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      }),\n      startNode: 0,\n      endNode: 9,\n    }],\n    mainNode: 0,\n    instanceType: InstanceType.of(InstanceClass.R4, InstanceSize.LARGE),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    PropagateTags: true,\n  });\n});",
            "file": "multinode-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "MultiNodeJobDefinition one container",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 42
            },
            "line": 69,
            "code": "test('MultiNodeJobDefinition one container', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new MultiNodeJobDefinition(stack, 'ECSJobDefn', {\n    containers: [{\n      container: new EcsEc2ContainerDefinition(stack, 'MultinodeContainer', {\n        cpu: 256,\n        memory: Size.mebibytes(2048),\n        image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n      }),\n      startNode: 0,\n      endNode: 9,\n    }],\n    mainNode: 0,\n    instanceType: InstanceType.of(InstanceClass.R4, InstanceSize.LARGE),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    NodeProperties: {\n      MainNode: 0,\n      NodeRangeProperties: [{\n        Container: {\n          InstanceType: 'r4.large',\n        },\n        TargetNodes: '0:9',\n      }],\n      NumNodes: 10,\n    },\n    PlatformCapabilities: [Compatibility.EC2],\n  });\n});",
            "file": "multinode-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "MultiNodeJobDefinition two containers",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 43
            },
            "line": 104,
            "code": "test('MultiNodeJobDefinition two containers', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new MultiNodeJobDefinition(stack, 'ECSJobDefn', {\n    containers: [\n      {\n        container: new EcsEc2ContainerDefinition(stack, 'MultinodeContainer1', {\n          cpu: 256,\n          memory: Size.mebibytes(2048),\n          image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n        }),\n        startNode: 0,\n        endNode: 9,\n      },\n      {\n        container: new EcsEc2ContainerDefinition(stack, 'MultinodeContainer2', {\n          cpu: 512,\n          memory: Size.mebibytes(4096),\n          image: ecs.ContainerImage.fromRegistry('amazon/amazon-ecs-sample'),\n        }),\n        startNode: 10,\n        endNode: 14,\n      },\n    ],\n    instanceType: InstanceType.of(InstanceClass.R4, InstanceSize.LARGE),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::JobDefinition', {\n    NodeProperties: {\n      MainNode: 0,\n      NodeRangeProperties: [\n        {\n          Container: {\n            InstanceType: 'r4.large',\n          },\n          TargetNodes: '0:9',\n        },\n        {\n          Container: {\n            InstanceType: 'r4.large',\n          },\n          TargetNodes: '10:14',\n        },\n\n      ],\n      NumNodes: 15,\n    },\n    PlatformCapabilities: [Compatibility.EC2],\n  });\n});",
            "file": "multinode-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "multinode job requires at least one container",
            "suites": [],
            "updatePoint": {
                "line": 158,
                "column": 51
            },
            "line": 158,
            "code": "test('multinode job requires at least one container', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new MultiNodeJobDefinition(stack, 'ECSJobDefn', {\n    instanceType: InstanceType.of(InstanceClass.C4, InstanceSize.LARGE),\n  });\n\n  // THEN\n  expect(() => Template.fromStack(stack)).toThrow(/multinode job has no containers!/);\n});",
            "file": "multinode-job-definition.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "empty fairshare policy",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 28
            },
            "line": 6,
            "code": "test('empty fairshare policy', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new FairshareSchedulingPolicy(stack, 'schedulingPolicy');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    FairsharePolicy: {\n      ShareDistribution: [],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "fairshare policy respects computeReservation",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 50
            },
            "line": 21,
            "code": "test('fairshare policy respects computeReservation', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new FairshareSchedulingPolicy(stack, 'schedulingPolicy', {\n    computeReservation: 75,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    FairsharePolicy: {\n      ComputeReservation: 75,\n      ShareDistribution: [],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "fairshare policy respects name",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 36
            },
            "line": 39,
            "code": "test('fairshare policy respects name', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new FairshareSchedulingPolicy(stack, 'schedulingPolicy', {\n    schedulingPolicyName: 'FairsharePolicyName',\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    Name: 'FairsharePolicyName',\n    FairsharePolicy: {\n      ShareDistribution: [],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "fairshare policy respects shareDecay",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 42
            },
            "line": 57,
            "code": "test('fairshare policy respects shareDecay', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new FairshareSchedulingPolicy(stack, 'schedulingPolicy', {\n    shareDecay: Duration.hours(1),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    FairsharePolicy: {\n      ShareDecaySeconds: 3600,\n      ShareDistribution: [],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "fairshare policy respects shares",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 38
            },
            "line": 75,
            "code": "test('fairshare policy respects shares', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new FairshareSchedulingPolicy(stack, 'schedulingPolicy', {\n    shares: [\n      {\n        shareIdentifier: 'myShareId',\n        weightFactor: 0.5,\n      },\n      {\n        shareIdentifier: 'myShareId2',\n        weightFactor: 1,\n      },\n    ],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    FairsharePolicy: {\n      ShareDistribution: [\n        {\n          ShareIdentifier: 'myShareId',\n          WeightFactor: 0.5,\n        },\n        {\n          ShareIdentifier: 'myShareId2',\n          WeightFactor: 1,\n        },\n      ],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "addShare() works",
            "suites": [],
            "updatePoint": {
                "line": 110,
                "column": 22
            },
            "line": 110,
            "code": "test('addShare() works', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const policy = new FairshareSchedulingPolicy(stack, 'schedulingPolicy', {\n    shares: [{\n      shareIdentifier: 'myShareId',\n      weightFactor: 0.5,\n    }],\n  });\n  policy.addShare({\n    shareIdentifier: 'addedShareId',\n    weightFactor: 0.5,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::SchedulingPolicy', {\n    FairsharePolicy: {\n      ShareDistribution: [\n        {\n          ShareIdentifier: 'myShareId',\n          WeightFactor: 0.5,\n        },\n        {\n          ShareIdentifier: 'addedShareId',\n          WeightFactor: 0.5,\n        },\n      ],\n    },\n  });\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "can be imported from ARN",
            "suites": [],
            "updatePoint": {
                "line": 143,
                "column": 30
            },
            "line": 143,
            "code": "test('can be imported from ARN', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const policy = FairshareSchedulingPolicy.fromFairshareSchedulingPolicyArn(stack, 'policyImport',\n    'arn:aws:batch:us-east-1:123456789012:scheduling-policy/policyImport');\n\n  // THEN\n  expect(policy.schedulingPolicyArn).toEqual('arn:aws:batch:us-east-1:123456789012:scheduling-policy/policyImport');\n});",
            "file": "scheduling-policy.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "default props",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 19
            },
            "line": 26,
            "code": "test('default props', () => {\n  // GIVEN\n  stack = new Stack();\n\n  // WHEN\n  new UnmanagedComputeEnvironment(stack, 'MyCE');\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n    ...pascalCaseExpectedProps,\n  });\n});",
            "file": "unmanaged-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects enabled: false",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 29
            },
            "line": 39,
            "code": "test('respects enabled: false', () => {\n  // GIVEN\n  stack = new Stack();\n\n  // WHEN\n  new UnmanagedComputeEnvironment(stack, 'MyCE', {\n    enabled: false,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n    ...pascalCaseExpectedProps,\n    State: 'DISABLED',\n  });\n});",
            "file": "unmanaged-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects name",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 19
            },
            "line": 55,
            "code": "test('respects name', () => {\n  // GIVEN\n  stack = new Stack();\n\n  // WHEN\n  new UnmanagedComputeEnvironment(stack, 'MyCE', {\n    computeEnvironmentName: 'magic',\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n    ...pascalCaseExpectedProps,\n    ComputeEnvironmentName: 'magic',\n  });\n});",
            "file": "unmanaged-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects serviceRole",
            "suites": [],
            "updatePoint": {
                "line": 71,
                "column": 26
            },
            "line": 71,
            "code": "test('respects serviceRole', () => {\n  // GIVEN\n  stack = new Stack();\n\n  // WHEN\n  new UnmanagedComputeEnvironment(stack, 'MyCE', {\n    serviceRole: new Role(stack, 'myMagicRole', {\n      assumedBy: new ServicePrincipal('batch.amazonaws.com'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n    ...pascalCaseExpectedProps,\n    ServiceRole: {\n      'Fn::GetAtt': ['myMagicRole2BBD827A', 'Arn'],\n    },\n  });\n});",
            "file": "unmanaged-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "respects unmanagedvCpus",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 29
            },
            "line": 91,
            "code": "test('respects unmanagedvCpus', () => {\n  // GIVEN\n  stack = new Stack();\n\n  // WHEN\n  new UnmanagedComputeEnvironment(stack, 'MyCE', {\n    unmanagedvCpus: 256,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Batch::ComputeEnvironment', {\n    ...pascalCaseExpectedProps,\n    UnmanagedvCpus: 256,\n  });\n});",
            "file": "unmanaged-compute-environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-batch/test"
        },
        {
            "name": "create resource correctly with only vpc and imageId provided",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 66
            },
            "line": 17,
            "code": "test('create resource correctly with only vpc and imageId provided', () => {\n  // WHEN\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  });\n  // THEN\n  Template.fromStack(stack).resourceCountIs('AWS::Cloud9::EnvironmentEC2', 1);\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "create resource correctly with vpc, imageId, and subnetSelection",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 70
            },
            "line": 27,
            "code": "test('create resource correctly with vpc, imageId, and subnetSelection', () => {\n  // WHEN\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    subnetSelection: {\n      subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,\n    },\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  });\n  // THEN\n  Template.fromStack(stack).resourceCountIs('AWS::Cloud9::EnvironmentEC2', 1);\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "import correctly from existing environment",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 48
            },
            "line": 40,
            "code": "test('import correctly from existing environment', () => {\n  // WHEN\n  const c9env = cloud9.Ec2Environment.fromEc2EnvironmentName(stack, 'ImportedEnv', 'existingEnvName');\n  // THEN\n  expect(c9env).toHaveProperty('ec2EnvironmentName');\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "create correctly with instanceType specified",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 50
            },
            "line": 47,
            "code": "test('create correctly with instanceType specified', () => {\n  // WHEN\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  });\n  // THEN\n  Template.fromStack(stack).resourceCountIs('AWS::Cloud9::EnvironmentEC2', 1);\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "throw error when subnetSelection not specified and the provided VPC has no public subnets",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 95
            },
            "line": 58,
            "code": "test('throw error when subnetSelection not specified and the provided VPC has no public subnets', () => {\n  // WHEN\n  const privateOnlyVpc = new ec2.Vpc(stack, 'PrivateOnlyVpc', {\n    maxAzs: 2,\n    subnetConfiguration: [\n      {\n        subnetType: ec2.SubnetType.PRIVATE_ISOLATED,\n        name: 'IsolatedSubnet',\n        cidrMask: 24,\n      },\n    ],\n  });\n  // THEN\n  expect(() => {\n    new cloud9.Ec2Environment(stack, 'C9Env', {\n      vpc: privateOnlyVpc,\n      instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n      imageId: cloud9.ImageId.AMAZON_LINUX_2,\n    });\n  }).toThrow(/no subnetSelection specified and no public subnet found in the vpc, please specify subnetSelection/);\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "can use CodeCommit repositories",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 37
            },
            "line": 80,
            "code": "test('can use CodeCommit repositories', () => {\n  // WHEN\n  const repo = codecommit.Repository.fromRepositoryName(stack, 'Repo', 'foo');\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    clonedRepositories: [\n      cloud9.CloneRepository.fromCodeCommit(repo, '/src'),\n    ],\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Cloud9::EnvironmentEC2', {\n    InstanceType: 't2.micro',\n    Repositories: [\n      {\n        PathComponent: '/src',\n        RepositoryUrl: {\n          'Fn::Join': [\n            '',\n            [\n              'https://git-codecommit.',\n              {\n                Ref: 'AWS::Region',\n              },\n              '.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n              '/v1/repos/foo',\n            ],\n          ],\n        },\n      },\n    ],\n  });\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "environment owner can be an IAM user",
            "suites": [],
            "updatePoint": {
                "line": 117,
                "column": 42
            },
            "line": 117,
            "code": "test('environment owner can be an IAM user', () => {\n  // WHEN\n  const user = new iam.User(stack, 'User', {\n    userName: 'testUser',\n  });\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n    owner: Owner.user(user),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Cloud9::EnvironmentEC2', {\n    OwnerArn: {\n      'Fn::GetAtt': ['User00B015A1', 'Arn'],\n    },\n  });\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "environment owner can be account root",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 43
            },
            "line": 135,
            "code": "test('environment owner can be account root', () => {\n  // WHEN\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n    owner: Owner.accountRoot('12345678'),\n  });\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Cloud9::EnvironmentEC2', {\n    OwnerArn: 'arn:aws:iam::12345678:root',\n  });\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "has connection type property (%s)",
            "suites": [],
            "line": 148,
            "code": "test.each([\n  [ConnectionType.CONNECT_SSH, 'CONNECT_SSH'],\n  [ConnectionType.CONNECT_SSM, 'CONNECT_SSM'],\n  [undefined, 'CONNECT_SSH'],\n])('has connection type property (%s)', (connectionType, expected) => {\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    connectionType,\n    imageId: cloud9.ImageId.AMAZON_LINUX_2,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Cloud9::EnvironmentEC2', {\n    InstanceType: Match.anyValue(),\n    ConnectionType: expected,\n    SubnetId: Match.anyValue(),\n  });\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "has image ID property (%s)",
            "suites": [],
            "line": 166,
            "code": "test.each([\n  [ImageId.AMAZON_LINUX_2, 'amazonlinux-2-x86_64'],\n  [ImageId.UBUNTU_18_04, 'ubuntu-18.04-x86_64'],\n])('has image ID property (%s)', (imageId, expected) => {\n  new cloud9.Ec2Environment(stack, 'C9Env', {\n    vpc,\n    imageId: imageId,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Cloud9::EnvironmentEC2', {\n    InstanceType: Match.anyValue(),\n    ImageId: expected,\n    SubnetId: Match.anyValue(),\n  });\n});",
            "file": "cloud9.environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-cloud9/test"
        },
        {
            "name": "create",
            "suites": [
                "GitHub Repository"
            ],
            "updatePoint": {
                "line": 14,
                "column": 14
            },
            "line": 14,
            "code": "  test('create', () => {\n    new GitHubRepository(stack, 'GitHubRepo', {\n      owner: 'foo',\n      repositoryName: 'bar',\n      accessToken: cdk.SecretValue.secretsManager('my-github-token', {\n        jsonField: 'token',\n      }),\n      contentsBucket: Bucket.fromBucketName(stack, 'Bucket', 'bucket-name'),\n      contentsKey: 'import.zip',\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::CodeStar::GitHubRepository', {\n      RepositoryAccessToken: '{{resolve:secretsmanager:my-github-token:SecretString:token::}}',\n      RepositoryName: 'bar',\n      RepositoryOwner: 'foo',\n      Code: {\n        S3: {\n          Bucket: 'bucket-name',\n          Key: 'import.zip',\n        },\n      },\n    });\n  });",
            "file": "codestar.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-codestar/test"
        },
        {
            "name": "enable issues and private",
            "suites": [
                "GitHub Repository"
            ],
            "updatePoint": {
                "line": 38,
                "column": 33
            },
            "line": 38,
            "code": "  test('enable issues and private', () => {\n    new GitHubRepository(stack, 'GitHubRepo', {\n      owner: 'foo',\n      repositoryName: 'bar',\n      accessToken: cdk.SecretValue.secretsManager('my-github-token', {\n        jsonField: 'token',\n      }),\n      contentsBucket: Bucket.fromBucketName(stack, 'Bucket', 'bucket-name'),\n      contentsKey: 'import.zip',\n      enableIssues: true,\n      visibility: RepositoryVisibility.PRIVATE,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::CodeStar::GitHubRepository', {\n      EnableIssues: true,\n      IsPrivate: true,\n    });\n  });",
            "file": "codestar.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-codestar/test"
        },
        {
            "name": "default fleet alias",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 28,
                "column": 29
            },
            "line": 28,
            "code": "    test('default fleet alias', () => {\n      new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-alias',\n        fleet: fleet,\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Alias', {\n        Properties:\n            {\n              Name: 'test-alias',\n              RoutingStrategy: {\n                FleetId: { Ref: 'MyBuildFleet0F4EADEC' },\n                Type: 'SIMPLE',\n              },\n            },\n      });\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default terminate alias",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 46,
                "column": 33
            },
            "line": 46,
            "code": "    test('default terminate alias', () => {\n      new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-alias',\n        terminalMessage: 'terminate message',\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Alias', {\n        Properties:\n              {\n                Name: 'test-alias',\n                RoutingStrategy: {\n                  Message: 'terminate message',\n                  Type: 'TERMINAL',\n                },\n              },\n      });\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect alias name",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 64,
                "column": 38
            },
            "line": 64,
            "code": "    test('with an incorrect alias name', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectName += 'A';\n      }\n\n      expect(() => new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: incorrectName,\n        fleet: fleet,\n      })).toThrow(/Alias name can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect description",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 76,
                "column": 39
            },
            "line": 76,
            "code": "    test('with an incorrect description', () => {\n      let incorrectDescription = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectDescription += 'A';\n      }\n\n      expect(() => new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-name',\n        description: incorrectDescription,\n        fleet: fleet,\n      })).toThrow(/Alias description can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with none of fleet and terminalMessage properties",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 89,
                "column": 59
            },
            "line": 89,
            "code": "    test('with none of fleet and terminalMessage properties', () => {\n      expect(() => new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-name',\n        terminalMessage: 'a terminal message',\n        fleet: fleet,\n      })).toThrow(/Either a terminal message or a fleet must be binded to this Alias./);\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with both fleet and terminalMessage properties",
            "suites": [
                "alias",
                "new"
            ],
            "updatePoint": {
                "line": 97,
                "column": 56
            },
            "line": 97,
            "code": "    test('with both fleet and terminalMessage properties', () => {\n      expect(() => new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-name',\n        terminalMessage: 'a terminal message',\n        fleet: fleet,\n      })).toThrow(/Either a terminal message or a fleet must be binded to this Alias, not both./);\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "Alias.fromAliasArn",
            "suites": [
                "alias",
                "test import methods"
            ],
            "updatePoint": {
                "line": 107,
                "column": 28
            },
            "line": 107,
            "code": "    test('Alias.fromAliasArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.Alias.fromAliasArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:alias/sample-alias-id');\n\n      // THEN\n      expect(imported.aliasArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:alias/sample-alias-id');\n      expect(imported.aliasId).toEqual('sample-alias-id');\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "Alias.fromAliasId",
            "suites": [
                "alias",
                "test import methods"
            ],
            "updatePoint": {
                "line": 119,
                "column": 27
            },
            "line": 119,
            "code": "    test('Alias.fromAliasId', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.Alias.fromAliasId(stack, 'Imported', 'sample-alias-id');\n\n      // THEN\n      expect(stack.resolve(imported.aliasArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':alias/sample-alias-id',\n        ]],\n      });\n      expect(stack.resolve(imported.aliasId)).toStrictEqual('sample-alias-id');\n    });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "alias",
                "Alias.fromAliasAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 155,
                "column": 36
            },
            "line": 155,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.Alias.fromAliasAttributes(stack, 'ImportedAlias', { aliasArn });\n\n        expect(importedFleet.aliasId).toEqual(aliasId);\n        expect(importedFleet.aliasArn).toEqual(aliasArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('alias-region');\n      });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "alias",
                "Alias.fromAliasAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 164,
                "column": 30
            },
            "line": 164,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.Alias.fromAliasAttributes(stack, 'ImportedAlias', { }))\n          .toThrow(/Either aliasId or aliasArn must be provided in AliasAttributes/);\n      });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "alias",
                "Alias.fromAliasAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 169,
                "column": 28
            },
            "line": 169,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.Alias.fromAliasAttributes(stack, 'ImportedAlias', { aliasArn: 'arn:aws:gamelift:alias-region:123456789012:alias' }))\n          .toThrow(/No alias identifier found in ARN: 'arn:aws:gamelift:alias-region:123456789012:alias'/);\n      });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the alias's region is taken from the ARN",
            "suites": [
                "alias",
                "Alias.fromAliasAttributes()",
                "for an alias in a different account and region"
            ],
            "updatePoint": {
                "line": 182,
                "column": 52
            },
            "line": 182,
            "code": "      test(\"the alias's region is taken from the ARN\", () => {\n        expect(alias.env.region).toBe('alias-region');\n      });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the alias's account is taken from the ARN",
            "suites": [
                "alias",
                "Alias.fromAliasAttributes()",
                "for an alias in a different account and region"
            ],
            "updatePoint": {
                "line": 186,
                "column": 53
            },
            "line": 186,
            "code": "      test(\"the alias's account is taken from the ARN\", () => {\n        expect(alias.env.account).toBe('123456789012');\n      });",
            "file": "alias.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default build fleet",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 18,
                "column": 29
            },
            "line": 18,
            "code": "    test('default build fleet', () => {\n      new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n        AssumeRolePolicyDocument:\n          {\n            Statement:\n              [{\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: { Service: 'gamelift.amazonaws.com' },\n              }],\n            Version: '2012-10-17',\n          },\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n          {\n            BuildId: { Ref: 'Build45A36621' },\n            NewGameSessionProtectionPolicy: 'NoProtection',\n            FleetType: 'ON_DEMAND',\n            EC2InstanceType: 'c4.large',\n            CertificateConfiguration: {\n              CertificateType: 'DISABLED',\n            },\n            MaxSize: 1,\n            MinSize: 0,\n            RuntimeConfiguration: {\n              ServerProcesses: [\n                {\n                  ConcurrentExecutions: 1,\n                  LaunchPath: 'test-launch-path',\n                },\n              ],\n            },\n          },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect fleet name",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 67,
                "column": 38
            },
            "line": 67,
            "code": "    test('with an incorrect fleet name', () => {\n      let incorrectFleetName = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectFleetName += 'A';\n      }\n\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: incorrectFleetName,\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      })).toThrow(/Fleet name can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect description",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 85,
                "column": 39
            },
            "line": 85,
            "code": "    test('with an incorrect description', () => {\n      let incorrectDescription = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectDescription += 'A';\n      }\n\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        description: incorrectDescription,\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      })).toThrow(/Fleet description can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect minSize value",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 104,
                "column": 41
            },
            "line": 104,
            "code": "    test('with an incorrect minSize value', () => {\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n        minSize: -1,\n      })).toThrow(/The minimum number of instances allowed in the Fleet cannot be lower than 0, given -1/);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect maxSize value",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 118,
                "column": 41
            },
            "line": 118,
            "code": "    test('with an incorrect maxSize value', () => {\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n        maxSize: -1,\n      })).toThrow(/The maximum number of instances allowed in the Fleet cannot be lower than 0, given -1/);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with too much locations from constructor",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 132,
                "column": 50
            },
            "line": 132,
            "code": "    test('with too much locations from constructor', () => {\n      let incorrectLocations: gamelift.Location[] = [];\n      for (let i = 0; i < 101; i++) {\n        incorrectLocations.push({\n          region: 'eu-west-1',\n        });\n      }\n\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        locations: incorrectLocations,\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      })).toThrow(/No more than 100 locations are allowed per fleet, given 101/);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with too much locations",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 153,
                "column": 33
            },
            "line": 153,
            "code": "    test('with too much locations', () => {\n      let locations: gamelift.Location[] = [];\n      for (let i = 0; i < 100; i++) {\n        locations.push({\n          region: 'eu-west-1',\n        });\n      }\n\n      const fleet = new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        locations: locations,\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      });\n\n      expect(() => fleet.addLocation('eu-west-1')).toThrow(/No more than 100 locations are allowed per fleet/);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with too much ingress rules",
            "suites": [
                "build fleet",
                "new"
            ],
            "updatePoint": {
                "line": 176,
                "column": 37
            },
            "line": 176,
            "code": "    test('with too much ingress rules', () => {\n      let incorrectIngressRules: gamelift.IngressRule[] = [];\n      for (let i = 0; i < 51; i++) {\n        incorrectIngressRules.push({\n          source: gamelift.Peer.anyIpv4(),\n          port: gamelift.Port.tcpRange(100, 200),\n        });\n      }\n\n      expect(() => new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        ingressRules: incorrectIngressRules,\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n      })).toThrow(/No more than 50 ingress rules are allowed per fleet, given 51/);\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add single tcp port ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 217,
                "column": 42
            },
            "line": 217,
            "code": "    test('add single tcp port ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.tcp(144));\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n              EC2InboundPermissions: [\n                {\n                  IpRange: '0.0.0.0/0',\n                  FromPort: 144,\n                  ToPort: 144,\n                  Protocol: 'TCP',\n                },\n              ],\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add tcp port range ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 237,
                "column": 41
            },
            "line": 237,
            "code": "    test('add tcp port range ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.tcpRange(100, 200));\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n\n              EC2InboundPermissions: [\n                {\n                  IpRange: '0.0.0.0/0',\n                  FromPort: 100,\n                  ToPort: 200,\n                  Protocol: 'TCP',\n                },\n              ],\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add single udp port ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 258,
                "column": 42
            },
            "line": 258,
            "code": "    test('add single udp port ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.udp(144));\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n\n              EC2InboundPermissions: [\n                {\n                  IpRange: '0.0.0.0/0',\n                  FromPort: 144,\n                  ToPort: 144,\n                  Protocol: 'UDP',\n                },\n              ],\n\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add udp port range ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 280,
                "column": 41
            },
            "line": 280,
            "code": "    test('add udp port range ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.udpRange(100, 200));\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n\n              EC2InboundPermissions: [\n                {\n                  IpRange: '0.0.0.0/0',\n                  FromPort: 100,\n                  ToPort: 200,\n                  Protocol: 'UDP',\n                },\n              ],\n\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add all tcp ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 302,
                "column": 34
            },
            "line": 302,
            "code": "    test('add all tcp ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.ipv4('1.2.3.4/5'), gamelift.Port.allTcp());\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n\n              EC2InboundPermissions: [\n                {\n                  IpRange: '1.2.3.4/5',\n                  FromPort: 1026,\n                  ToPort: 60000,\n                  Protocol: 'TCP',\n                },\n              ],\n\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add all udp ingress rule",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 324,
                "column": 34
            },
            "line": 324,
            "code": "    test('add all udp ingress rule', () => {\n      // WHEN\n      fleet.addIngressRule(gamelift.Peer.ipv4('1.2.3.4/5'), gamelift.Port.allUdp());\n\n      // THEN\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n\n              EC2InboundPermissions: [\n                {\n                  IpRange: '1.2.3.4/5',\n                  FromPort: 1026,\n                  ToPort: 60000,\n                  Protocol: 'UDP',\n                },\n              ],\n\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add invalid IPv4 CIDR address",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 346,
                "column": 39
            },
            "line": 346,
            "code": "    test('add invalid IPv4 CIDR address', () => {\n      // WHEN\n      expect(() => fleet.addIngressRule(gamelift.Peer.ipv4('1.2.3/23'), gamelift.Port.tcp(144)))\n        .toThrowError('Invalid IPv4 CIDR: \\\"1.2.3/23\\\"');\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add IPv4 CIDR address without mask",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 352,
                "column": 44
            },
            "line": 352,
            "code": "    test('add IPv4 CIDR address without mask', () => {\n      // WHEN\n      expect(() => fleet.addIngressRule(gamelift.Peer.ipv4('1.2.3.4'), gamelift.Port.tcp(144)))\n        .toThrowError('CIDR mask is missing in IPv4: \\\"1.2.3.4\\\". Did you mean \\\"1.2.3.4/32\\\"?');\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add too much ingress rules",
            "suites": [
                "build fleet",
                "test ingress rules"
            ],
            "updatePoint": {
                "line": 358,
                "column": 36
            },
            "line": 358,
            "code": "    test('add too much ingress rules', () => {\n      for (let i = 0; i < 50; i++) {\n        fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.tcpRange(100, 200));\n      }\n      expect(() => fleet.addIngressRule(gamelift.Peer.anyIpv4(), gamelift.Port.tcp(144)))\n        .toThrowError('No more than 50 ingress rules are allowed per fleet');\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add new location",
            "suites": [
                "build fleet",
                "add locations"
            ],
            "updatePoint": {
                "line": 386,
                "column": 26
            },
            "line": 386,
            "code": "    test('add new location', () => {\n      // Add a new location\n      fleet.addLocation('eu-west-1');\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n              {\n                Locations: [{\n                  Location: 'eu-west-1',\n                }],\n              },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add new location with capacity",
            "suites": [
                "build fleet",
                "add locations"
            ],
            "updatePoint": {
                "line": 400,
                "column": 40
            },
            "line": 400,
            "code": "    test('add new location with capacity', () => {\n      // Add a new location\n      fleet.addLocation('eu-west-1', 3, 1, 4);\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n                {\n                  Locations: [{\n                    Location: 'eu-west-1',\n                    LocationCapacity: {\n                      DesiredEC2Instances: 3,\n                      MinSize: 1,\n                      MaxSize: 4,\n                    },\n                  }],\n                },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "BuildFleet.fromBuildFleetArn",
            "suites": [
                "build fleet",
                "test import methods"
            ],
            "updatePoint": {
                "line": 421,
                "column": 38
            },
            "line": 421,
            "code": "    test('BuildFleet.fromBuildFleetArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.BuildFleet.fromBuildFleetArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:fleet/sample-fleet-id');\n\n      // THEN\n      expect(imported.fleetArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:fleet/sample-fleet-id');\n      expect(imported.fleetId).toEqual('sample-fleet-id');\n      expect(imported.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: imported }));\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "BuildFleet.fromFleetId",
            "suites": [
                "build fleet",
                "test import methods"
            ],
            "updatePoint": {
                "line": 434,
                "column": 32
            },
            "line": 434,
            "code": "    test('BuildFleet.fromFleetId', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.BuildFleet.fromBuildFleetId(stack, 'Imported', 'sample-fleet-id');\n\n      // THEN\n      expect(stack.resolve(imported.fleetArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':fleet/sample-fleet-id',\n        ]],\n      });\n      expect(stack.resolve(imported.fleetId)).toStrictEqual('sample-fleet-id');\n      expect(imported.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: imported }));\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "grant provides access to fleet",
            "suites": [
                "build fleet",
                "test import methods"
            ],
            "updatePoint": {
                "line": 458,
                "column": 38
            },
            "line": 458,
            "code": "  test('grant provides access to fleet', () => {\n    const stack = new cdk.Stack();\n\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n    });\n\n    const fleet = new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n      fleetName: 'test-fleet',\n      content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n      instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n      runtimeConfiguration: {\n        serverProcesses: [{\n          launchPath: 'test-launch-path',\n        }],\n      },\n      role: role,\n    });\n\n    fleet.grant(role, 'gamelift:ListFleets');\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Action: 'gamelift:ListFleets',\n            Resource: stack.resolve(fleet.fleetArn),\n          }),\n        ],\n      },\n      Roles: [stack.resolve(role.roleName)],\n    });\n  });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 510,
                "column": 16
            },
            "line": 510,
            "code": "    test('metric', () => {\n      const metric = fleet.metric('ActiveInstances');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'ActiveInstances',\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricActiveInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 524,
                "column": 31
            },
            "line": 524,
            "code": "    test('metricActiveInstances', () => {\n      const metric = fleet.metricActiveInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'ActiveInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPercentIdleInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 539,
                "column": 36
            },
            "line": 539,
            "code": "    test('metricPercentIdleInstances', () => {\n      const metric = fleet.metricPercentIdleInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PercentIdleInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricDesiredInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 554,
                "column": 32
            },
            "line": 554,
            "code": "    test('metricDesiredInstances', () => {\n      const metric = fleet.metricDesiredInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'DesiredInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricIdleInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 569,
                "column": 29
            },
            "line": 569,
            "code": "    test('metricIdleInstances', () => {\n      const metric = fleet.metricIdleInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'IdleInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricInstanceInterruptions",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 584,
                "column": 37
            },
            "line": 584,
            "code": "    test('metricInstanceInterruptions', () => {\n      const metric = fleet.metricInstanceInterruptions();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'InstanceInterruptions',\n        statistic: cloudwatch.Statistic.SUM,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMaxInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 599,
                "column": 28
            },
            "line": 599,
            "code": "    test('metricMaxInstances', () => {\n      const metric = fleet.metricMaxInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MaxInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMinInstances",
            "suites": [
                "build fleet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 614,
                "column": 28
            },
            "line": 614,
            "code": "    test('metricMinInstances', () => {\n      const metric = fleet.metricMinInstances();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MinInstances',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          FleetId: fleet.fleetId,\n        },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add vpc peering",
            "suites": [
                "build fleet",
                "test vpc peering"
            ],
            "updatePoint": {
                "line": 637,
                "column": 25
            },
            "line": 637,
            "code": "    test('add vpc peering', () => {\n      const stack = new cdk.Stack();\n\n      const vpc = new ec2.Vpc(stack, 'Vpc');\n\n      new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n        peerVpc: vpc,\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::Fleet', {\n        Properties:\n            {\n              PeerVpcAwsAccountId: { Ref: 'AWS::AccountId' },\n              PeerVpcId: { Ref: 'Vpc8378EB38' },\n            },\n      });\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "check warning message",
            "suites": [
                "build fleet",
                "test vpc peering"
            ],
            "updatePoint": {
                "line": 663,
                "column": 31
            },
            "line": 663,
            "code": "    test('check warning message', () => {\n      const stack = new cdk.Stack();\n\n      const vpc = new ec2.Vpc(stack, 'Vpc');\n\n      new gamelift.BuildFleet(stack, 'MyBuildFleet', {\n        fleetName: 'test-fleet',\n        content: gamelift.Build.fromAsset(stack, 'Build', path.join(__dirname, 'my-game-build')),\n        instanceType: ec2.InstanceType.of(ec2.InstanceClass.C4, ec2.InstanceSize.LARGE),\n        runtimeConfiguration: {\n          serverProcesses: [{\n            launchPath: 'test-launch-path',\n          }],\n        },\n        peerVpc: vpc,\n      });\n      Annotations.fromStack(stack).hasWarning('/Default/MyBuildFleet', Match.stringLikeRegexp(warningMessage));\n    });",
            "file": "build-fleet.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a new build from asset",
            "suites": [
                "build",
                "new",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 48
            },
            "line": 51,
            "code": "      test('should create a new build from asset', () => {\n        build = gamelift.Build.fromAsset(stack, 'ImportedBuild', localAsset);\n\n        expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          StorageLocation: {\n            Bucket: {\n              Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3Bucket3626B74C',\n            },\n          },\n        });\n\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a new build from bucket",
            "suites": [
                "build",
                "new",
                ".fromBucket()"
            ],
            "updatePoint": {
                "line": 67,
                "column": 49
            },
            "line": 67,
            "code": "      test('should create a new build from bucket', () => {\n        build = gamelift.Build.fromBucket(stack, 'ImportedBuild', contentBucket, 'content');\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          StorageLocation: {\n            Bucket: 'bucketname',\n            Key: 'content',\n          },\n        });\n\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a role and use it with the build",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 85,
                "column": 58
            },
            "line": 85,
            "code": "      test('should create a role and use it with the build', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n          AssumeRolePolicyDocument: {\n            Statement: [\n              {\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: {\n                  Service: 'gamelift.amazonaws.com',\n                },\n              },\n            ],\n            Version: '2012-10-17',\n          },\n        });\n\n        // Role policy should grant reading from the assets bucket\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n          PolicyDocument: {\n            Statement: [\n              contentBucketAccessStatement,\n            ],\n          },\n          Roles: [\n            {\n              Ref: 'BuildServiceRole1F57E904',\n            },\n          ],\n        });\n\n        // check the build using the role\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          StorageLocation: {\n            Bucket: 'bucketname',\n            Key: 'content',\n            RoleArn: {\n              'Fn::GetAtt': [\n                'BuildServiceRole1F57E904',\n                'Arn',\n              ],\n            },\n          },\n        });\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should return correct buildId from CloudFormation",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 130,
                "column": 61
            },
            "line": 130,
            "code": "      test('should return correct buildId from CloudFormation', () => {\n        expect(stack.resolve(build.buildId)).toEqual({ Ref: 'Build45A36621' });\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with a custom role should use it and set it in CloudFormation",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 134,
                "column": 73
            },
            "line": 134,
            "code": "      test('with a custom role should use it and set it in CloudFormation', () => {\n        const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n        build = new gamelift.Build(stack, 'BuildWithRole', {\n          ...defaultProps,\n          role,\n        });\n\n        expect(build.grantPrincipal).toEqual(role);\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          StorageLocation: {\n            RoleArn: role.roleArn,\n          },\n        });\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with a custom buildName should set it in CloudFormation",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 149,
                "column": 67
            },
            "line": 149,
            "code": "      test('with a custom buildName should set it in CloudFormation', () => {\n        build = new gamelift.Build(stack, 'BuildWithName', {\n          ...defaultProps,\n          buildName: buildName,\n        });\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          Name: buildName,\n        });\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all optional attributes should set it in CloudFormation",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 160,
                "column": 72
            },
            "line": 160,
            "code": "      test('with all optional attributes should set it in CloudFormation', () => {\n        build = new gamelift.Build(stack, 'BuildWithName', {\n          ...defaultProps,\n          buildName: buildName,\n          operatingSystem: gamelift.OperatingSystem.AMAZON_LINUX_2,\n          buildVersion: '1.0',\n        });\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n          Name: buildName,\n          OperatingSystem: gamelift.OperatingSystem.AMAZON_LINUX_2,\n          Version: '1.0',\n        });\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect buildName (>1024)",
            "suites": [
                "build",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 175,
                "column": 47
            },
            "line": 175,
            "code": "      test('with an incorrect buildName (>1024)', () => {\n        let incorrectBuildName = '';\n        for (let i = 0; i < 1025; i++) {\n          incorrectBuildName += 'A';\n        }\n\n        expect(() => new gamelift.Build(stack, 'BuildWithWrongName', {\n          content,\n          buildName: incorrectBuildName,\n        })).toThrow(/Build name can not be longer than 1024 characters but has 1025 characters./);\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "Build.fromBuildArn",
            "suites": [
                "build",
                "test import methods"
            ],
            "updatePoint": {
                "line": 190,
                "column": 28
            },
            "line": 190,
            "code": "    test('Build.fromBuildArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.Build.fromBuildArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:build/sample-build-id');\n\n      // THEN\n      expect(imported.buildArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:build/sample-build-id');\n      expect(imported.buildId).toEqual('sample-build-id');\n    });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "Build.fromBuildId",
            "suites": [
                "build",
                "test import methods"
            ],
            "updatePoint": {
                "line": 202,
                "column": 27
            },
            "line": 202,
            "code": "    test('Build.fromBuildId', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.Build.fromBuildId(stack, 'Imported', 'sample-build-id');\n\n      // THEN\n      expect(stack.resolve(imported.buildArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':build/sample-build-id',\n        ]],\n      });\n      expect(stack.resolve(imported.buildId)).toStrictEqual('sample-build-id');\n    });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "build",
                "Build.fromBuildAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 238,
                "column": 36
            },
            "line": 238,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.Build.fromBuildAttributes(stack, 'ImportedBuild', { buildArn });\n\n        expect(importedFleet.buildId).toEqual(buildId);\n        expect(importedFleet.buildArn).toEqual(buildArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('build-region');\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "build",
                "Build.fromBuildAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 247,
                "column": 30
            },
            "line": 247,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.Build.fromBuildAttributes(stack, 'ImportedBuild', { }))\n          .toThrow(/Either buildId or buildArn must be provided in BuildAttributes/);\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "build",
                "Build.fromBuildAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 252,
                "column": 28
            },
            "line": 252,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.Build.fromBuildAttributes(stack, 'ImportedBuild', { buildArn: 'arn:aws:gamelift:build-region:123456789012:build' }))\n          .toThrow(/No build identifier found in ARN: 'arn:aws:gamelift:build-region:123456789012:build'/);\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the build's region is taken from the ARN",
            "suites": [
                "build",
                "Build.fromBuildAttributes()",
                "for an build in a different account and region"
            ],
            "updatePoint": {
                "line": 265,
                "column": 52
            },
            "line": 265,
            "code": "      test(\"the build's region is taken from the ARN\", () => {\n        expect(build.env.region).toBe('build-region');\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the build's account is taken from the ARN",
            "suites": [
                "build",
                "Build.fromBuildAttributes()",
                "for an build in a different account and region"
            ],
            "updatePoint": {
                "line": 269,
                "column": 53
            },
            "line": 269,
            "code": "      test(\"the build's account is taken from the ARN\", () => {\n        expect(build.env.account).toBe('123456789012');\n      });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with valid bucket name and key and bound by build sets the right path and grants the build permissions to read from it",
            "suites": [
                "Content",
                ".fromBucket()"
            ],
            "updatePoint": {
                "line": 21,
                "column": 128
            },
            "line": 21,
            "code": "    test('with valid bucket name and key and bound by build sets the right path and grants the build permissions to read from it', () => {\n      bucket = s3.Bucket.fromBucketName(stack, 'Bucket', 'bucketname');\n      content = gamelift.Content.fromBucket(bucket, key);\n      new gamelift.Build(stack, 'Build1', {\n        content: content,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n        StorageLocation: {\n          Bucket: 'bucketname',\n          Key: 'content',\n        },\n      });\n\n      // Role policy should grant reading from the assets bucket\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: [\n                's3:GetObject',\n                's3:GetObjectVersion',\n              ],\n              Effect: 'Allow',\n              Resource: {\n                'Fn::Join': [\n                  '',\n                  [\n                    'arn:',\n                    {\n                      Ref: 'AWS::Partition',\n                    },\n                    ':s3:::bucketname/content',\n                  ],\n                ],\n              },\n            },\n          ],\n        },\n        Roles: [\n          {\n            Ref: 'Build1ServiceRole24FABCB7',\n          },\n        ],\n      });\n    });",
            "file": "content.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with valid and existing file path and bound to script location and permissions stack metadata",
            "suites": [
                "Content",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 76,
                "column": 103
            },
            "line": 76,
            "code": "    test('with valid and existing file path and bound to script location and permissions stack metadata', () => {\n      new gamelift.Build(stack, 'Build1', {\n        content: content,\n      });\n\n      expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n      Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n        StorageLocation: {\n          Bucket: {\n            Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3Bucket3626B74C',\n          },\n          Key: {\n            'Fn::Join': [\n              '',\n              [\n                {\n                  'Fn::Select': [\n                    0,\n                    {\n                      'Fn::Split': [\n                        '||',\n                        {\n                          Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                        },\n                      ],\n                    },\n                  ],\n                },\n                {\n                  'Fn::Select': [\n                    1,\n                    {\n                      'Fn::Split': [\n                        '||',\n                        {\n                          Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            ],\n          },\n          RoleArn: {\n            'Fn::GetAtt': [\n              'Build1ServiceRole24FABCB7',\n              'Arn',\n            ],\n          },\n        },\n      });\n      // Role policy should grant reading from the assets bucket\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: [\n                's3:GetObject',\n                's3:GetObjectVersion',\n              ],\n              Effect: 'Allow',\n              Resource: {\n                'Fn::Join': [\n                  '',\n                  [\n                    'arn:',\n                    {\n                      Ref: 'AWS::Partition',\n                    },\n                    ':s3:::',\n                    {\n                      Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3Bucket3626B74C',\n                    },\n                    '/',\n                    {\n                      'Fn::Select': [\n                        0,\n                        {\n                          'Fn::Split': [\n                            '||',\n                            {\n                              Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                            },\n                          ],\n                        },\n                      ],\n                    },\n                    {\n                      'Fn::Select': [\n                        1,\n                        {\n                          'Fn::Split': [\n                            '||',\n                            {\n                              Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                            },\n                          ],\n                        },\n                      ],\n                    },\n                  ],\n                ],\n              },\n            },\n          ],\n        },\n        Roles: [\n          {\n            Ref: 'Build1ServiceRole24FABCB7',\n          },\n        ],\n      });\n    });",
            "file": "content.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an unsupported file path throws",
            "suites": [
                "Content",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 191,
                "column": 46
            },
            "line": 191,
            "code": "    test('with an unsupported file path throws', () => {\n      // GIVEN\n      const fileAsset = gamelift.Content.fromAsset(path.join(__dirname, 'my-game-build', 'TestApplicationServer'));\n\n      // THEN\n      expect(() => new gamelift.Build(stack, 'Build1', { content: fileAsset }))\n        .toThrow(/Asset must be a \\.zip file or a directory/);\n    });",
            "file": "content.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "used in more than 1 build in the same stack should be reused",
            "suites": [
                "Content",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 200,
                "column": 70
            },
            "line": 200,
            "code": "    test('used in more than 1 build in the same stack should be reused', () => {\n      new gamelift.Build(stack, 'Build1', {\n        content: content,\n      });\n      new gamelift.Build(stack, 'Build2', {\n        content: content,\n      });\n      const StorageLocation = {\n        Bucket: {\n          Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3Bucket3626B74C',\n        },\n        Key: {\n          'Fn::Join': [\n            '',\n            [\n              {\n                'Fn::Select': [\n                  0,\n                  {\n                    'Fn::Split': [\n                      '||',\n                      {\n                        Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                      },\n                    ],\n                  },\n                ],\n              },\n              {\n                'Fn::Select': [\n                  1,\n                  {\n                    'Fn::Split': [\n                      '||',\n                      {\n                        Ref: 'AssetParametersb95e4173bc399a8f686a4951aa26e01de1ed1e9d981ee1a7f18a15512dbdcb37S3VersionKey75334BA8',\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          ],\n        },\n        RoleArn: {\n          'Fn::GetAtt': [\n            'Build1ServiceRole24FABCB7',\n            'Arn',\n          ],\n        },\n      };\n\n      expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n      Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n        StorageLocation,\n      });\n      Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Build', {\n        StorageLocation,\n      });\n    });",
            "file": "content.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "throws if trying to rebind in another stack",
            "suites": [
                "Content",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 261,
                "column": 53
            },
            "line": 261,
            "code": "    test('throws if trying to rebind in another stack', () => {\n      new gamelift.Build(stack, 'Build1', {\n        content,\n      });\n      const differentStack = new cdk.Stack();\n\n      expect(() => new gamelift.Build(differentStack, 'Build2', {\n        content,\n      })).toThrow(/Asset is already associated with another stack/);\n    });",
            "file": "content.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 19,
                "column": 36
            },
            "line": 19,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.FleetBase.fromFleetAttributes(stack, 'ImportedScript', { fleetArn });\n\n        expect(importedFleet.fleetId).toEqual(fleetId);\n        expect(importedFleet.fleetArn).toEqual(fleetArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('fleet-region');\n        expect(importedFleet.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: importedFleet }));\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all attrs",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 29,
                "column": 26
            },
            "line": 29,
            "code": "      test('with all attrs', () => {\n        const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n        const importedFleet = gamelift.FleetBase.fromFleetAttributes(stack, 'ImportedScript', { fleetArn, role });\n\n        expect(importedFleet.fleetId).toEqual(fleetId);\n        expect(importedFleet.grantPrincipal).toEqual(role);\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 37,
                "column": 30
            },
            "line": 37,
            "code": "      test('with missing attrs', () => {\n        const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n        expect(() => gamelift.FleetBase.fromFleetAttributes(stack, 'ImportedScript', { role }))\n          .toThrow(/Either fleetId or fleetArn must be provided in FleetAttributes/);\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 43,
                "column": 28
            },
            "line": 43,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.FleetBase.fromFleetAttributes(stack, 'ImportedScript', { fleetArn: 'arn:aws:gamelift:fleet-region:123456789012:fleet' }))\n          .toThrow(/No fleet identifier found in ARN: 'arn:aws:gamelift:fleet-region:123456789012:fleet'/);\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the fleet's region is taken from the ARN",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                "for a fleet in a different account and region"
            ],
            "updatePoint": {
                "line": 56,
                "column": 52
            },
            "line": 56,
            "code": "      test(\"the fleet's region is taken from the ARN\", () => {\n        expect(fleet.env.region).toBe('fleet-region');\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the fleet's account is taken from the ARN",
            "suites": [
                "Fleet base",
                "FleetBase.fromFleetAttributes()",
                "for a fleet in a different account and region"
            ],
            "updatePoint": {
                "line": 60,
                "column": 53
            },
            "line": 60,
            "code": "      test(\"the fleet's account is taken from the ARN\", () => {\n        expect(fleet.env.account).toBe('123456789012');\n      });",
            "file": "fleet-base.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default gameservergroup",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 20,
                "column": 33
            },
            "line": 20,
            "code": "    test('default gameservergroup', () => {\n\n      new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: 'test-gameservergroup-name',\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n        AssumeRolePolicyDocument:\n          {\n            Statement:\n              [{\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: {\n                  Service: 'gamelift.amazonaws.com',\n                },\n              },\n              {\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: {\n                  Service: 'autoscaling.amazonaws.com',\n                },\n              }],\n            Version: '2012-10-17',\n          },\n        ManagedPolicyArns: [{\n          'Fn::Join': [\n            '',\n            [\n              'arn:',\n              {\n                Ref: 'AWS::Partition',\n              },\n              ':iam::aws:policy/GameLiftGameServerGroupPolicy',\n            ],\n          ],\n        }],\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameServerGroup', {\n        Properties:\n          {\n            GameServerGroupName: 'test-gameservergroup-name',\n            GameServerProtectionPolicy: 'NO_PROTECTION',\n            InstanceDefinitions: [{ InstanceType: 'c5.large' }],\n            LaunchTemplate: {\n              LaunchTemplateId: { Ref: 'LaunchTemplte29591DF8' },\n              Version: {\n                'Fn::GetAtt': [\n                  'LaunchTemplte29591DF8',\n                  'LatestVersionNumber',\n                ],\n              },\n            },\n            RoleArn: {\n              'Fn::GetAtt': [\n                'MyGameServerGroupServiceRoleD6701F0B',\n                'Arn',\n              ],\n            },\n            VpcSubnets: [\n              { Ref: 'vpcPublicSubnet1Subnet2E65531E' },\n              { Ref: 'vpcPublicSubnet2Subnet009B674F' },\n            ],\n          },\n      });\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with autoScalingPolicy",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 94,
                "column": 32
            },
            "line": 94,
            "code": "    test('with autoScalingPolicy', () => {\n      new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: 'test-gameservergroup-name',\n        autoScalingPolicy: {\n          targetTrackingConfiguration: 10,\n          estimatedInstanceWarmup: cdk.Duration.minutes(5),\n        },\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameServerGroup', {\n        Properties:\n          {\n            GameServerGroupName: 'test-gameservergroup-name',\n            GameServerProtectionPolicy: 'NO_PROTECTION',\n            InstanceDefinitions: [{ InstanceType: 'c5.large' }],\n            LaunchTemplate: {\n              LaunchTemplateId: { Ref: 'LaunchTemplte29591DF8' },\n              Version: {\n                'Fn::GetAtt': [\n                  'LaunchTemplte29591DF8',\n                  'LatestVersionNumber',\n                ],\n              },\n            },\n            RoleArn: {\n              'Fn::GetAtt': [\n                'MyGameServerGroupServiceRoleD6701F0B',\n                'Arn',\n              ],\n            },\n            VpcSubnets: [\n              { Ref: 'vpcPublicSubnet1Subnet2E65531E' },\n              { Ref: 'vpcPublicSubnet2Subnet009B674F' },\n            ],\n            AutoScalingPolicy: {\n              EstimatedInstanceWarmup: 300,\n              TargetTrackingConfiguration: {\n                TargetValue: 10,\n              },\n            },\n          },\n      });\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect game server group name length",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 143,
                "column": 57
            },
            "line": 143,
            "code": "    test('with an incorrect game server group name length', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 129; i++) {\n        incorrectName += 'A';\n      }\n      expect(() => new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: incorrectName,\n      })).toThrow(/GameServerGroup name can not be longer than 128 characters but has 129 characters./);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect game server group name format",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 158,
                "column": 57
            },
            "line": 158,
            "code": "    test('with an incorrect game server group name format', () => {\n      let incorrectName = 'test with space';\n      expect(() => new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: incorrectName,\n      })).toThrow(/Game server group name test with space can contain only letters, numbers, hyphens, back slash or dot with no spaces./);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect instance definitions list from constructor",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 170,
                "column": 70
            },
            "line": 170,
            "code": "    test('with an incorrect instance definitions list from constructor', () => {\n      let incorrectInstanceDefinitions: gamelift.InstanceDefinition[] = [];\n      for (let i = 0; i < 21; i++) {\n        incorrectInstanceDefinitions.push({\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        });\n      }\n      expect(() => new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: incorrectInstanceDefinitions,\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: 'test-name',\n      })).toThrow(/No more than 20 instance definitions are allowed per game server group, given 21/);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with incorrect minSize",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 185,
                "column": 32
            },
            "line": 185,
            "code": "    test('with incorrect minSize', () => {\n      expect(() => new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: 'test-name',\n        minSize: -1,\n      })).toThrow(/The minimum number of instances allowed in the Amazon EC2 Auto Scaling group cannot be lower than 0, given -1/);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with incorrect maxSize",
            "suites": [
                "gameservergroup",
                "new"
            ],
            "updatePoint": {
                "line": 197,
                "column": 32
            },
            "line": 197,
            "code": "    test('with incorrect maxSize', () => {\n      expect(() => new gamelift.GameServerGroup(stack, 'MyGameServerGroup', {\n        instanceDefinitions: [{\n          instanceType: ec2.InstanceType.of(ec2.InstanceClass.C5, ec2.InstanceSize.LARGE),\n        }],\n        vpc: vpc,\n        launchTemplate: launchTemplate,\n        gameServerGroupName: 'test-name',\n        maxSize: -1,\n      })).toThrow(/The maximum number of instances allowed in the Amazon EC2 Auto Scaling group cannot be lower than 1, given -1/);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 223,
                "column": 34
            },
            "line": 223,
            "code": "    test('with required attrs only', () => {\n      const importedFleet = gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { gameServerGroupArn, autoScalingGroupArn });\n\n      expect(importedFleet.autoScalingGroupArn).toEqual(autoScalingGroupArn);\n      expect(importedFleet.gameServerGroupArn).toEqual(gameServerGroupArn);\n      expect(importedFleet.gameServerGroupName).toEqual(gameServerGroupName);\n      expect(importedFleet.env.account).toEqual('123456789012');\n      expect(importedFleet.env.region).toEqual('test-region');\n      expect(importedFleet.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: importedFleet }));\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all attrs",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 234,
                "column": 24
            },
            "line": 234,
            "code": "    test('with all attrs', () => {\n      const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n      const importedFleet = gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { gameServerGroupArn, autoScalingGroupArn, role });\n\n      expect(importedFleet.autoScalingGroupArn).toEqual(autoScalingGroupArn);\n      expect(importedFleet.gameServerGroupArn).toEqual(gameServerGroupArn);\n      expect(importedFleet.gameServerGroupName).toEqual(gameServerGroupName);\n      expect(importedFleet.grantPrincipal).toEqual(role);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 244,
                "column": 28
            },
            "line": 244,
            "code": "    test('with missing attrs', () => {\n      const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n      expect(() => gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { role, autoScalingGroupArn }))\n        .toThrow(/Either gameServerGroupName or gameServerGroupArn must be provided in GameServerGroupAttributes/);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 250,
                "column": 26
            },
            "line": 250,
            "code": "    test('with invalid ARN', () => {\n      expect(() => gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { autoScalingGroupArn, gameServerGroupArn: 'arn:aws:gamelift:test-region:123456789012:gameservergroup' }))\n        .toThrow(/No game server group name found in ARN: 'arn:aws:gamelift:test-region:123456789012:gameservergroup'/);\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the gameServerGroup's region is taken from the ARN",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 255,
                "column": 60
            },
            "line": 255,
            "code": "    test(\"the gameServerGroup's region is taken from the ARN\", () => {\n      const importedFleet = gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { gameServerGroupArn, autoScalingGroupArn });\n      expect(importedFleet.env.region).toBe('test-region');\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the gameServerGroup's account is taken from the ARN",
            "suites": [
                "gameservergroup",
                "test import methods"
            ],
            "updatePoint": {
                "line": 260,
                "column": 61
            },
            "line": 260,
            "code": "    test(\"the gameServerGroup's account is taken from the ARN\", () => {\n      const importedFleet = gamelift.GameServerGroup.fromGameServerGroupAttributes(stack, 'ImportedScript', { gameServerGroupArn, autoScalingGroupArn });\n      expect(importedFleet.env.account).toBe('123456789012');\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "gameservergroup",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 286,
                "column": 16
            },
            "line": 286,
            "code": "    test('metric', () => {\n      const metric = gameServerGroup.metric('AvailableGameServers');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'AvailableGameServers',\n        dimensions: {\n          GameServerGroupArn: gameServerGroup.gameServerGroupArn,\n        },\n      });\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "grant",
            "suites": [
                "gameservergroup",
                "granting access"
            ],
            "updatePoint": {
                "line": 326,
                "column": 15
            },
            "line": 326,
            "code": "    test('grant', () => {\n      gameServerGroup.grant(role, 'gamelift:DescribeGameServerGroup');\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: [\n            Match.objectLike({\n              Action: 'gamelift:DescribeGameServerGroup',\n              Resource: stack.resolve(gameServerGroup.gameServerGroupArn),\n            }),\n          ],\n        },\n        Roles: [stack.resolve(role.roleName)],\n      });\n    });",
            "file": "game-server-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default fleet gameSessionQueue",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 30,
                "column": 40
            },
            "line": 30,
            "code": "    test('default fleet gameSessionQueue', () => {\n      new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-gameSessionQueue',\n        destinations: [fleet],\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameSessionQueue', {\n        Properties:\n            {\n              Name: 'test-gameSessionQueue',\n              Destinations: [\n                {\n                  DestinationArn: {\n                    'Fn::Join': [\n                      '',\n                      [\n                        'arn:',\n                        {\n                          Ref: 'AWS::Partition',\n                        },\n                        ':gamelift:',\n                        {\n                          Ref: 'AWS::Region',\n                        },\n                        ':',\n                        {\n                          Ref: 'AWS::AccountId',\n                        },\n                        ':fleet/',\n                        {\n                          Ref: 'MyBuildFleet0F4EADEC',\n                        },\n                      ],\n                    ],\n                  },\n                },\n              ],\n            },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default alias gameSessionQueue",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 71,
                "column": 40
            },
            "line": 71,
            "code": "    test('default alias gameSessionQueue', () => {\n      const alias = new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-alias',\n        fleet: fleet,\n      });\n\n      new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-gameSessionQueue',\n        destinations: [alias],\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameSessionQueue', {\n        Properties:\n              {\n                Name: 'test-gameSessionQueue',\n                Destinations: [\n                  {\n                    DestinationArn: {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'arn:',\n                          {\n                            Ref: 'AWS::Partition',\n                          },\n                          ':gamelift:',\n                          {\n                            Ref: 'AWS::Region',\n                          },\n                          ':',\n                          {\n                            Ref: 'AWS::AccountId',\n                          },\n                          ':alias/',\n                          {\n                            Ref: 'MyAlias9A08CB8C',\n                          },\n                        ],\n                      ],\n                    },\n                  },\n                ],\n              },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add new destination",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 117,
                "column": 29
            },
            "line": 117,
            "code": "    test('add new destination', () => {\n      const alias = new gamelift.Alias(stack, 'MyAlias', {\n        aliasName: 'test-alias',\n        fleet: fleet,\n      });\n\n      const queue = new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-gameSessionQueue',\n        destinations: [fleet],\n      });\n\n      queue.addDestination(alias);\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameSessionQueue', {\n        Properties:\n              {\n                Name: 'test-gameSessionQueue',\n                Destinations: [\n                  {\n                    DestinationArn: {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'arn:',\n                          {\n                            Ref: 'AWS::Partition',\n                          },\n                          ':gamelift:',\n                          {\n                            Ref: 'AWS::Region',\n                          },\n                          ':',\n                          {\n                            Ref: 'AWS::AccountId',\n                          },\n                          ':fleet/',\n                          {\n                            Ref: 'MyBuildFleet0F4EADEC',\n                          },\n                        ],\n                      ],\n                    },\n                  },\n                  {\n                    DestinationArn: {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'arn:',\n                          {\n                            Ref: 'AWS::Partition',\n                          },\n                          ':gamelift:',\n                          {\n                            Ref: 'AWS::Region',\n                          },\n                          ':',\n                          {\n                            Ref: 'AWS::AccountId',\n                          },\n                          ':alias/',\n                          {\n                            Ref: 'MyAlias9A08CB8C',\n                          },\n                        ],\n                      ],\n                    },\n                  },\n                ],\n              },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all properties",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 190,
                "column": 29
            },
            "line": 190,
            "code": "    test('with all properties', () => {\n      const topic = new sns.Topic(stack, 'MyTopic', {});\n\n      new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-gameSessionQueue',\n        destinations: [fleet],\n        customEventData: 'test-event-data',\n        allowedLocations: ['eu-west-1', 'eu-west-2'],\n        notificationTarget: topic,\n        playerLatencyPolicies: [{\n          maximumIndividualPlayerLatency: cdk.Duration.millis(100),\n          policyDuration: cdk.Duration.seconds(300),\n        }],\n        priorityConfiguration: {\n          locationOrder: [\n            'eu-west-1',\n            'eu-west-2',\n          ],\n          priorityOrder: [\n            gamelift.PriorityType.LATENCY,\n            gamelift.PriorityType.COST,\n            gamelift.PriorityType.DESTINATION,\n            gamelift.PriorityType.LOCATION,\n          ],\n        },\n        timeout: cdk.Duration.seconds(300),\n\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::GameSessionQueue', {\n        Properties:\n            {\n              Name: 'test-gameSessionQueue',\n              CustomEventData: 'test-event-data',\n              FilterConfiguration: {\n                AllowedLocations: [\n                  'eu-west-1',\n                  'eu-west-2',\n                ],\n              },\n              NotificationTarget: { Ref: 'MyTopic86869434' },\n              PlayerLatencyPolicies: [{\n                MaximumIndividualPlayerLatencyMilliseconds: 100,\n                PolicyDurationSeconds: 300,\n              }],\n              PriorityConfiguration: {\n                LocationOrder: [\n                  'eu-west-1',\n                  'eu-west-2',\n                ],\n                PriorityOrder: [\n                  'LATENCY',\n                  'COST',\n                  'DESTINATION',\n                  'LOCATION',\n                ],\n              },\n              TimeoutInSeconds: 300,\n              Destinations: [\n                {\n                  DestinationArn: {\n                    'Fn::Join': [\n                      '',\n                      [\n                        'arn:',\n                        {\n                          Ref: 'AWS::Partition',\n                        },\n                        ':gamelift:',\n                        {\n                          Ref: 'AWS::Region',\n                        },\n                        ':',\n                        {\n                          Ref: 'AWS::AccountId',\n                        },\n                        ':fleet/',\n                        {\n                          Ref: 'MyBuildFleet0F4EADEC',\n                        },\n                      ],\n                    ],\n                  },\n                },\n              ],\n            },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an invlaid priority configuration location order",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 279,
                "column": 63
            },
            "line": 279,
            "code": "    test('with an invlaid priority configuration location order', () => {\n      let incorrectLocationOrder: string[] = [];\n      for (let i = 0; i < 101; i++) {\n        incorrectLocationOrder.push('test-location');\n      }\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-name',\n        destinations: [fleet],\n        priorityConfiguration: {\n          locationOrder: incorrectLocationOrder,\n          priorityOrder: [\n            gamelift.PriorityType.COST,\n          ],\n        },\n      })).toThrow(/No more than 100 locations are allowed per priority configuration, given 101/);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an invlaid priority configuration priority order",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 297,
                "column": 63
            },
            "line": 297,
            "code": "    test('with an invlaid priority configuration priority order', () => {\n      let incorrectPriorityOrder: gamelift.PriorityType[] = [];\n      for (let i = 0; i < 5; i++) {\n        incorrectPriorityOrder.push(gamelift.PriorityType.COST);\n      }\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-name',\n        destinations: [fleet],\n        priorityConfiguration: {\n          locationOrder: ['eu-west-1', 'eu-west-2'],\n          priorityOrder: incorrectPriorityOrder,\n        },\n      })).toThrow(/No more than 4 priorities are allowed per priority configuration, given 5/);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 313,
                "column": 32
            },
            "line": 313,
            "code": "    test('with an incorrect name', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 129; i++) {\n        incorrectName += 'A';\n      }\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: incorrectName,\n        destinations: [fleet],\n      })).toThrow(/GameSessionQueue name can not be longer than 128 characters but has 129 characters./);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name format",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 325,
                "column": 39
            },
            "line": 325,
            "code": "    test('with an incorrect name format', () => {\n      let incorrectName = 'test with space';\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: incorrectName,\n        destinations: [fleet],\n      })).toThrow(/GameSessionQueue name test with space can contain only letters, numbers, hyphens with no spaces./);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect custom event data",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 334,
                "column": 45
            },
            "line": 334,
            "code": "    test('with an incorrect custom event data', () => {\n      let incorrectCustomEventData = '';\n      for (let i = 0; i < 257; i++) {\n        incorrectCustomEventData += 'A';\n      }\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-name',\n        destinations: [fleet],\n        customEventData: incorrectCustomEventData,\n      })).toThrow(/GameSessionQueue custom event data can not be longer than 256 characters but has 257 characters./);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect number of locations",
            "suites": [
                "gameSessionQueue",
                "new"
            ],
            "updatePoint": {
                "line": 347,
                "column": 47
            },
            "line": 347,
            "code": "    test('with an incorrect number of locations', () => {\n      let incorrectLocations: string[] = [];\n      for (let i = 0; i < 101; i++) {\n        incorrectLocations.push('test');\n      }\n\n      expect(() => new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue', {\n        gameSessionQueueName: 'test-name',\n        destinations: [fleet],\n        allowedLocations: incorrectLocations,\n      })).toThrow(/No more than 100 allowed locations are allowed per game session queue, given 101/);\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 384,
                "column": 16
            },
            "line": 384,
            "code": "    test('metric', () => {\n      const metric = gameSessionQueue.metric('AverageWaitTime');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'AverageWaitTime',\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricAverageWaitTime",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 398,
                "column": 31
            },
            "line": 398,
            "code": "    test('metricAverageWaitTime', () => {\n      const metric = gameSessionQueue.metricAverageWaitTime();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'AverageWaitTime',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlacementsCanceled",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 413,
                "column": 34
            },
            "line": 413,
            "code": "    test('metricPlacementsCanceled', () => {\n      const metric = gameSessionQueue.metricPlacementsCanceled();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlacementsCanceled',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlacementsFailed",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 428,
                "column": 32
            },
            "line": 428,
            "code": "    test('metricPlacementsFailed', () => {\n      const metric = gameSessionQueue.metricPlacementsFailed();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlacementsFailed',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlacementsStarted",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 443,
                "column": 33
            },
            "line": 443,
            "code": "    test('metricPlacementsStarted', () => {\n      const metric = gameSessionQueue.metricPlacementsStarted();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlacementsStarted',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlacementsSucceeded",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 458,
                "column": 35
            },
            "line": 458,
            "code": "    test('metricPlacementsSucceeded', () => {\n      const metric = gameSessionQueue.metricPlacementsSucceeded();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlacementsSucceeded',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlacementsTimedOut",
            "suites": [
                "gameSessionQueue",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 473,
                "column": 34
            },
            "line": 473,
            "code": "    test('metricPlacementsTimedOut', () => {\n      const metric = gameSessionQueue.metricPlacementsTimedOut();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlacementsTimedOut',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          GameSessionQueueName: gameSessionQueue.gameSessionQueueName,\n        },\n      });\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "GameSessionQueue.fromGameSessionQueueArn",
            "suites": [
                "gameSessionQueue",
                "test import methods"
            ],
            "updatePoint": {
                "line": 492,
                "column": 50
            },
            "line": 492,
            "code": "    test('GameSessionQueue.fromGameSessionQueueArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.GameSessionQueue.fromGameSessionQueueArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:gamesessionqueue/sample-gameSessionQueue-name');\n\n      // THEN\n      expect(imported.gameSessionQueueArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:gamesessionqueue/sample-gameSessionQueue-name');\n      expect(imported.gameSessionQueueName).toEqual('sample-gameSessionQueue-name');\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "GameSessionQueue.fromGameSessionQueueId",
            "suites": [
                "gameSessionQueue",
                "test import methods"
            ],
            "updatePoint": {
                "line": 504,
                "column": 49
            },
            "line": 504,
            "code": "    test('GameSessionQueue.fromGameSessionQueueId', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.GameSessionQueue.fromGameSessionQueueName(stack, 'Imported', 'sample-gameSessionQueue-name');\n\n      // THEN\n      expect(stack.resolve(imported.gameSessionQueueArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':gamesessionqueue/sample-gameSessionQueue-name',\n        ]],\n      });\n      expect(stack.resolve(imported.gameSessionQueueName)).toStrictEqual('sample-gameSessionQueue-name');\n    });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "gameSessionQueue",
                "GameSessionQueue.fromGameSessionQueueAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 540,
                "column": 36
            },
            "line": 540,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.GameSessionQueue.fromGameSessionQueueAttributes(stack, 'ImportedGameSessionQueue', { gameSessionQueueArn });\n\n        expect(importedFleet.gameSessionQueueName).toEqual(gameSessionQueueName);\n        expect(importedFleet.gameSessionQueueArn).toEqual(gameSessionQueueArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('gameSessionQueue-region');\n      });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "gameSessionQueue",
                "GameSessionQueue.fromGameSessionQueueAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 549,
                "column": 30
            },
            "line": 549,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.GameSessionQueue.fromGameSessionQueueAttributes(stack, 'ImportedGameSessionQueue', { }))\n          .toThrow(/Either gameSessionQueueName or gameSessionQueueArn must be provided in GameSessionQueueAttributes/);\n      });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "gameSessionQueue",
                "GameSessionQueue.fromGameSessionQueueAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 554,
                "column": 28
            },
            "line": 554,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.GameSessionQueue.fromGameSessionQueueAttributes(stack, 'ImportedGameSessionQueue', { gameSessionQueueArn: 'arn:aws:gamelift:gameSessionQueue-region:123456789012:gamesessionqueue' }))\n          .toThrow(/No gameSessionQueue name found in ARN: 'arn:aws:gamelift:gameSessionQueue-region:123456789012:gamesessionqueue'/);\n      });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the gameSessionQueue's region is taken from the ARN",
            "suites": [
                "gameSessionQueue",
                "GameSessionQueue.fromGameSessionQueueAttributes()",
                "for an gameSessionQueue in a different account and region"
            ],
            "updatePoint": {
                "line": 567,
                "column": 63
            },
            "line": 567,
            "code": "      test(\"the gameSessionQueue's region is taken from the ARN\", () => {\n        expect(gameSessionQueue.env.region).toBe('gameSessionQueue-region');\n      });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the gameSessionQueue's account is taken from the ARN",
            "suites": [
                "gameSessionQueue",
                "GameSessionQueue.fromGameSessionQueueAttributes()",
                "for an gameSessionQueue in a different account and region"
            ],
            "updatePoint": {
                "line": 571,
                "column": 64
            },
            "line": 571,
            "code": "      test(\"the gameSessionQueue's account is taken from the ARN\", () => {\n        expect(gameSessionQueue.env.account).toBe('123456789012');\n      });",
            "file": "game-session-queue.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "new RuleSetBody from Inline content",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromInline"
            ],
            "updatePoint": {
                "line": 14,
                "column": 45
            },
            "line": 14,
            "code": "    test('new RuleSetBody from Inline content', () => {\n      const ruleSet = gamelift.RuleSetContent.fromInline('{}');\n      const content = ruleSet.bind(stack);\n      expect(content.ruleSetBody).toEqual('{}');\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "fails if invlaid JSON format",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromInline"
            ],
            "updatePoint": {
                "line": 20,
                "column": 38
            },
            "line": 20,
            "code": "    test('fails if invlaid JSON format', () => {\n      expect(() => gamelift.RuleSetContent.fromInline('{ name }'))\n        .toThrow(/RuleSet body has an invalid Json format/);\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "fails if content too large",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromInline"
            ],
            "updatePoint": {
                "line": 25,
                "column": 36
            },
            "line": 25,
            "code": "    test('fails if content too large', () => {\n      let incorrectContent = '';\n      for (let i = 0; i < 65536; i++) {\n        incorrectContent += 'A';\n      }\n\n      expect(() => gamelift.RuleSetContent.fromInline(JSON.stringify({ name: incorrectContent })))\n        .toThrow(/RuleSet body cannot exceed 65535 characters, actual 65547/);\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "new RuleSetBody from Json file",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromJsonFile"
            ],
            "updatePoint": {
                "line": 37,
                "column": 40
            },
            "line": 37,
            "code": "    test('new RuleSetBody from Json file', () => {\n      const ruleSet = gamelift.RuleSetContent.fromJsonFile(path.join(__dirname, 'my-ruleset/ruleset.json'));\n      const content = ruleSet.bind(stack);\n      const result = JSON.parse(fs.readFileSync(path.join(__dirname, 'my-ruleset/ruleset.json')).toString());\n      expect(content.ruleSetBody).toEqual(JSON.stringify(result));\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "fails if file not exist",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromJsonFile"
            ],
            "updatePoint": {
                "line": 44,
                "column": 33
            },
            "line": 44,
            "code": "    test('fails if file not exist', () => {\n      const content = path.join(__dirname, 'my-ruleset/file-not-exist.json');\n      expect(() => gamelift.RuleSetContent.fromJsonFile(content))\n        .toThrow(`RuleSet path does not exist, please verify it, actual ${content}`);\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "fails if file is a directory",
            "suites": [
                "MatchmakingRuleSetBody",
                "gamelift.MatchmakingRuleSetBody.fromJsonFile"
            ],
            "updatePoint": {
                "line": 50,
                "column": 38
            },
            "line": 50,
            "code": "    test('fails if file is a directory', () => {\n      const contentPath = path.join(__dirname, 'my-ruleset');\n      expect(() => gamelift.RuleSetContent.fromJsonFile(contentPath))\n        .toThrow(`RuleSet path is not link to a single file, please verify your path, actual ${contentPath}`);\n    });",
            "file": "matchmaking-ruleset-body.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default new ruleSet",
            "suites": [
                "MatchmakingRuleSet",
                "new"
            ],
            "updatePoint": {
                "line": 16,
                "column": 29
            },
            "line": 16,
            "code": "    test('default new ruleSet', () => {\n      new gamelift.MatchmakingRuleSet(stack, 'MyMatchmakingRuleSet', {\n        matchmakingRuleSetName: 'test-ruleSet',\n        content: gamelift.RuleSetContent.fromInline(ruleSetBody),\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingRuleSet', {\n        Properties:\n            {\n              Name: 'test-ruleSet',\n              RuleSetBody: ruleSetBody,\n            },\n      });\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name - too long",
            "suites": [
                "MatchmakingRuleSet",
                "new"
            ],
            "updatePoint": {
                "line": 31,
                "column": 43
            },
            "line": 31,
            "code": "    test('with an incorrect name - too long', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 129; i++) {\n        incorrectName += 'A';\n      }\n\n      expect(() => new gamelift.MatchmakingRuleSet(stack, 'MyMatchmakingRuleSet', {\n        matchmakingRuleSetName: incorrectName,\n        content: gamelift.RuleSetContent.fromInline(ruleSetBody),\n      })).toThrow(/RuleSet name can not be longer than 128 characters but has 129 characters./);\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name - bad format",
            "suites": [
                "MatchmakingRuleSet",
                "new"
            ],
            "updatePoint": {
                "line": 43,
                "column": 45
            },
            "line": 43,
            "code": "    test('with an incorrect name - bad format', () => {\n      let incorrectName = 'test with space';\n\n      expect(() => new gamelift.MatchmakingRuleSet(stack, 'MyMatchmakingRuleSet', {\n        matchmakingRuleSetName: incorrectName,\n        content: gamelift.RuleSetContent.fromInline(ruleSetBody),\n      })).toThrow(/RuleSet name test with space can contain only letters, numbers, hyphens, back slash or dot with no spaces./);\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "MatchmakingRuleSet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 66,
                "column": 16
            },
            "line": 66,
            "code": "    test('metric', () => {\n      const metric = ruleSet.metric('RuleEvaluationsPassed');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'RuleEvaluationsPassed',\n        dimensions: {\n          MatchmakingRuleSetName: ruleSet.matchmakingRuleSetName,\n        },\n      });\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "RuleEvaluationsPassed",
            "suites": [
                "MatchmakingRuleSet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 80,
                "column": 31
            },
            "line": 80,
            "code": "    test('RuleEvaluationsPassed', () => {\n      const metric = ruleSet.metricRuleEvaluationsPassed();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'RuleEvaluationsPassed',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingRuleSetName: ruleSet.matchmakingRuleSetName,\n        },\n      });\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "RuleEvaluationsFailed",
            "suites": [
                "MatchmakingRuleSet",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 95,
                "column": 31
            },
            "line": 95,
            "code": "    test('RuleEvaluationsFailed', () => {\n      const metric = ruleSet.metricRuleEvaluationsFailed();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'RuleEvaluationsFailed',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingRuleSetName: ruleSet.matchmakingRuleSetName,\n        },\n      });\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "MatchmakingRuleSet.fromMatchmakingRuleSetArn",
            "suites": [
                "MatchmakingRuleSet",
                "test import methods"
            ],
            "updatePoint": {
                "line": 112,
                "column": 54
            },
            "line": 112,
            "code": "    test('MatchmakingRuleSet.fromMatchmakingRuleSetArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.MatchmakingRuleSet.fromMatchmakingRuleSetArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:matchmakingruleset/sample-ruleSet-name');\n\n      // THEN\n      expect(imported.matchmakingRuleSetArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:matchmakingruleset/sample-ruleSet-name');\n      expect(imported.matchmakingRuleSetName).toEqual('sample-ruleSet-name');\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "MatchmakingRuleSet.fromMatchmakingRuleSetName",
            "suites": [
                "MatchmakingRuleSet",
                "test import methods"
            ],
            "updatePoint": {
                "line": 124,
                "column": 55
            },
            "line": 124,
            "code": "    test('MatchmakingRuleSet.fromMatchmakingRuleSetName', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.MatchmakingRuleSet.fromMatchmakingRuleSetName(stack, 'Imported', 'sample-ruleSet-name');\n\n      // THEN\n      expect(stack.resolve(imported.matchmakingRuleSetArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':matchmakingruleset/sample-ruleSet-name',\n        ]],\n      });\n      expect(stack.resolve(imported.matchmakingRuleSetName)).toStrictEqual('sample-ruleSet-name');\n    });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "MatchmakingRuleSet",
                "MatchmakingRuleSet.fromMatchmakingRuleSetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 160,
                "column": 36
            },
            "line": 160,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.MatchmakingRuleSet.fromMatchmakingRuleSetAttributes(stack, 'ImportedMatchmakingRuleSet', { matchmakingRuleSetArn });\n\n        expect(importedFleet.matchmakingRuleSetName).toEqual(matchmakingRuleSetName);\n        expect(importedFleet.matchmakingRuleSetArn).toEqual(matchmakingRuleSetArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('ruleSet-region');\n      });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "MatchmakingRuleSet",
                "MatchmakingRuleSet.fromMatchmakingRuleSetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 169,
                "column": 30
            },
            "line": 169,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.MatchmakingRuleSet.fromMatchmakingRuleSetAttributes(stack, 'ImportedMatchmakingRuleSet', { }))\n          .toThrow(/Either matchmakingRuleSetName or matchmakingRuleSetArn must be provided in MatchmakingRuleSetAttributes/);\n      });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "MatchmakingRuleSet",
                "MatchmakingRuleSet.fromMatchmakingRuleSetAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 174,
                "column": 28
            },
            "line": 174,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.MatchmakingRuleSet.fromMatchmakingRuleSetAttributes(stack, 'ImportedMatchmakingRuleSet', { matchmakingRuleSetArn: 'arn:aws:gamelift:ruleSet-region:123456789012:matchmakingruleset' }))\n          .toThrow(/No matchmaking ruleSet identifier found in ARN: 'arn:aws:gamelift:ruleSet-region:123456789012:matchmakingruleset'/);\n      });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the ruleSet's region is taken from the ARN",
            "suites": [
                "MatchmakingRuleSet",
                "MatchmakingRuleSet.fromMatchmakingRuleSetAttributes()",
                "for an ruleSet in a different account and region"
            ],
            "updatePoint": {
                "line": 187,
                "column": 54
            },
            "line": 187,
            "code": "      test(\"the ruleSet's region is taken from the ARN\", () => {\n        expect(ruleSet.env.region).toBe('ruleSet-region');\n      });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the ruleSet's account is taken from the ARN",
            "suites": [
                "MatchmakingRuleSet",
                "MatchmakingRuleSet.fromMatchmakingRuleSetAttributes()",
                "for an ruleSet in a different account and region"
            ],
            "updatePoint": {
                "line": 191,
                "column": 55
            },
            "line": 191,
            "code": "      test(\"the ruleSet's account is taken from the ARN\", () => {\n        expect(ruleSet.env.account).toBe('123456789012');\n      });",
            "file": "matchmaking-ruleset.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default QueuedMatchmakingConfiguration",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 27,
                "column": 48
            },
            "line": 27,
            "code": "    test('default QueuedMatchmakingConfiguration', () => {\n      new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingConfiguration', {\n        Properties: {\n          Name: 'test-config-name',\n          NotificationTarget: { Ref: 'MyQueuedMatchmakingConfigurationTopicBAC3E679' },\n          FlexMatchMode: 'WITH_QUEUE',\n          BackfillMode: 'AUTOMATIC',\n          AcceptanceRequired: false,\n          RequestTimeoutSeconds: 300,\n          RuleSetName: { Ref: 'MyMatchmakingRuleSet41F295C4' },\n          GameSessionQueueArns: [\n            {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':gamelift:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':gamesessionqueue/',\n                  {\n                    Ref: 'MyGameSessionQueue1A15CE31',\n                  },\n                ],\n              ],\n            },\n          ],\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "add game session queue",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 72,
                "column": 32
            },
            "line": 72,
            "code": "    test('add game session queue', () => {\n      const gameSessionQueue2 = new gamelift.GameSessionQueue(stack, 'MyGameSessionQueue2', {\n        gameSessionQueueName: 'test-queue-name-2',\n        destinations: [],\n      });\n\n      const matchmakingConfiguration = new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n      });\n\n      matchmakingConfiguration.addGameSessionQueue(gameSessionQueue2);\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingConfiguration', {\n        Properties: {\n          Name: 'test-config-name',\n          NotificationTarget: { Ref: 'MyQueuedMatchmakingConfigurationTopicBAC3E679' },\n          FlexMatchMode: 'WITH_QUEUE',\n          BackfillMode: 'AUTOMATIC',\n          AcceptanceRequired: false,\n          RequestTimeoutSeconds: 300,\n          RuleSetName: { Ref: 'MyMatchmakingRuleSet41F295C4' },\n          GameSessionQueueArns: [\n            {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':gamelift:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':gamesessionqueue/',\n                  {\n                    Ref: 'MyGameSessionQueue1A15CE31',\n                  },\n                ],\n              ],\n            },\n            {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':gamelift:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':gamesessionqueue/',\n                  {\n                    Ref: 'MyGameSessionQueue2EED85BF6',\n                  },\n                ],\n              ],\n            },\n          ],\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all properties",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 147,
                "column": 29
            },
            "line": 147,
            "code": "    test('with all properties', () => {\n      new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-queuedMatchmakingConfiguration',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        customEventData: 'event-data',\n        gameProperties: [{\n          key: 'test-key',\n          value: 'test-value',\n        }],\n        gameSessionData: 'test-session-data',\n        manualBackfillMode: true,\n        additionalPlayerCount: 3,\n        description: 'test description',\n        requestTimeout: cdk.Duration.seconds(30),\n        requireAcceptance: true,\n        acceptanceTimeout: cdk.Duration.seconds(30),\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingConfiguration', {\n        Properties: {\n          Name: 'test-queuedMatchmakingConfiguration',\n          NotificationTarget: { Ref: 'MyQueuedMatchmakingConfigurationTopicBAC3E679' },\n          FlexMatchMode: 'WITH_QUEUE',\n          BackfillMode: 'MANUAL',\n          AcceptanceRequired: true,\n          RequestTimeoutSeconds: 30,\n          RuleSetName: { Ref: 'MyMatchmakingRuleSet41F295C4' },\n          AcceptanceTimeoutSeconds: 30,\n          AdditionalPlayerCount: 3,\n          GameSessionData: 'test-session-data',\n          Description: 'test description',\n          GameProperties: [\n            {\n              Key: 'test-key',\n              Value: 'test-value',\n            },\n          ],\n          GameSessionQueueArns: [\n            {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':gamelift:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':gamesessionqueue/',\n                  {\n                    Ref: 'MyGameSessionQueue1A15CE31',\n                  },\n                ],\n              ],\n            },\n          ],\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 214,
                "column": 32
            },
            "line": 214,
            "code": "    test('with an incorrect name', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 129; i++) {\n        incorrectName += 'A';\n      }\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: incorrectName,\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n      })).toThrow(/Matchmaking configuration name can not be longer than 128 characters but has 129 characters./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name format",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 227,
                "column": 39
            },
            "line": 227,
            "code": "    test('with an incorrect name format', () => {\n      let incorrectName = 'test with space';\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: incorrectName,\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n      })).toThrow(/Matchmaking configuration name test with space can contain only letters, numbers, hyphens, back slash or dot with no spaces./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect description",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 237,
                "column": 39
            },
            "line": 237,
            "code": "    test('with an incorrect description', () => {\n      let incorrectDescription = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectDescription += 'A';\n      }\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        description: incorrectDescription,\n      })).toThrow(/Matchmaking configuration description can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect number of game properties",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 251,
                "column": 53
            },
            "line": 251,
            "code": "    test('with an incorrect number of game properties', () => {\n      let incorrectField: gamelift.GameProperty[] = [];\n      for (let i = 0; i < 17; i++) {\n        incorrectField.push({\n          key: 'test',\n          value: 'test',\n        });\n      }\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        gameProperties: incorrectField,\n      })).toThrow(/The maximum number of game properties allowed in the matchmaking configuration cannot be higher than 16, given 17/);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect game session data length",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 268,
                "column": 52
            },
            "line": 268,
            "code": "    test('with an incorrect game session data length', () => {\n      let incorrectField: string = '';\n      for (let i = 0; i < 4097; i++) {\n        incorrectField += 'A';\n      }\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        gameSessionData: incorrectField,\n      })).toThrow(/Matchmaking configuration game session data can not be longer than 4096 characters but has 4097 characters./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect custom event data length",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 282,
                "column": 52
            },
            "line": 282,
            "code": "    test('with an incorrect custom event data length', () => {\n      let incorrectField: string = '';\n      for (let i = 0; i < 257; i++) {\n        incorrectField += 'A';\n      }\n\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        customEventData: incorrectField,\n      })).toThrow(/Matchmaking configuration custom event data can not be longer than 256 characters but has 257 characters./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect acceptance timeout",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 296,
                "column": 46
            },
            "line": 296,
            "code": "    test('with an incorrect acceptance timeout', () => {\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        acceptanceTimeout: Duration.seconds(700),\n      })).toThrow(/Matchmaking configuration acceptance timeout can not exceed 600 seconds, actual 700 seconds./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect request timeout",
            "suites": [
                "queuedMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 305,
                "column": 43
            },
            "line": 305,
            "code": "    test('with an incorrect request timeout', () => {\n      expect(() => new gamelift.QueuedMatchmakingConfiguration(stack, 'MyQueuedMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        gameSessionQueues: [gameSessionQueue],\n        ruleSet: ruleSet,\n        requestTimeout: Duration.seconds(43300),\n      })).toThrow(/Matchmaking configuration request timeout can not exceed 43200 seconds, actual 43300 seconds./);\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 339,
                "column": 16
            },
            "line": 339,
            "code": "    test('metric', () => {\n      const metric = queuedMatchmakingConfiguration.metric('CurrentTickets');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'CurrentTickets',\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlayersStarted",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 353,
                "column": 30
            },
            "line": 353,
            "code": "    test('metricPlayersStarted', () => {\n      const metric = queuedMatchmakingConfiguration.metricPlayersStarted();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlayersStarted',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesRejected",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 368,
                "column": 31
            },
            "line": 368,
            "code": "    test('metricMatchesRejected', () => {\n      const metric = queuedMatchmakingConfiguration.metricMatchesRejected();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesRejected',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesPlaced",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 383,
                "column": 29
            },
            "line": 383,
            "code": "    test('metricMatchesPlaced', () => {\n      const metric = queuedMatchmakingConfiguration.metricMatchesPlaced();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesPlaced',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesCreated",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 398,
                "column": 30
            },
            "line": 398,
            "code": "    test('metricMatchesCreated', () => {\n      const metric = queuedMatchmakingConfiguration.metricMatchesCreated();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesCreated',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesAccepted",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 413,
                "column": 31
            },
            "line": 413,
            "code": "    test('metricMatchesAccepted', () => {\n      const metric = queuedMatchmakingConfiguration.metricMatchesAccepted();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesAccepted',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricCurrentTickets",
            "suites": [
                "queuedMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 428,
                "column": 30
            },
            "line": 428,
            "code": "    test('metricCurrentTickets', () => {\n      const metric = queuedMatchmakingConfiguration.metricCurrentTickets();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'CurrentTickets',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: queuedMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationArn",
            "suites": [
                "queuedMatchmakingConfiguration",
                "test import methods"
            ],
            "updatePoint": {
                "line": 447,
                "column": 78
            },
            "line": 447,
            "code": "    test('QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:matchmakingconfiguration/sample-queuedMatchmakingConfiguration-name');\n\n      // THEN\n      expect(imported.matchmakingConfigurationArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:matchmakingconfiguration/sample-queuedMatchmakingConfiguration-name');\n      expect(imported.matchmakingConfigurationName).toEqual('sample-queuedMatchmakingConfiguration-name');\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationName",
            "suites": [
                "queuedMatchmakingConfiguration",
                "test import methods"
            ],
            "updatePoint": {
                "line": 459,
                "column": 79
            },
            "line": 459,
            "code": "    test('QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationName', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationName(stack, 'Imported', 'sample-matchmakingConfiguration-name');\n\n      // THEN\n      expect(stack.resolve(imported.matchmakingConfigurationArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':matchmakingconfiguration/sample-matchmakingConfiguration-name',\n        ]],\n      });\n      expect(stack.resolve(imported.matchmakingConfigurationName)).toStrictEqual('sample-matchmakingConfiguration-name');\n    });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "queuedMatchmakingConfiguration",
                "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 495,
                "column": 36
            },
            "line": 495,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.QueuedMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedQueuedMatchmakingConfiguration', { matchmakingConfigurationArn });\n\n        expect(importedFleet.matchmakingConfigurationName).toEqual(matchmakingConfigurationName);\n        expect(importedFleet.matchmakingConfigurationArn).toEqual(matchmakingConfigurationArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('matchmakingConfiguration-region');\n      });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "queuedMatchmakingConfiguration",
                "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 504,
                "column": 30
            },
            "line": 504,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.QueuedMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedQueuedMatchmakingConfiguration', { }))\n          .toThrow(/Either matchmakingConfigurationName or matchmakingConfigurationArn must be provided in MatchmakingConfigurationAttributes/);\n      });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "queuedMatchmakingConfiguration",
                "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 509,
                "column": 28
            },
            "line": 509,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.QueuedMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedQueuedMatchmakingConfiguration', { matchmakingConfigurationArn: 'arn:aws:gamelift:matchmakingConfiguration-region:123456789012:matchmakingconfiguration' }))\n          .toThrow(/No matchmaking configuration name found in ARN: 'arn:aws:gamelift:matchmakingConfiguration-region:123456789012:matchmakingconfiguration'/);\n      });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the queuedMatchmakingConfiguration's region is taken from the ARN",
            "suites": [
                "queuedMatchmakingConfiguration",
                "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationAttributes()",
                "for an queuedMatchmakingConfiguration in a different account and region"
            ],
            "updatePoint": {
                "line": 522,
                "column": 77
            },
            "line": 522,
            "code": "      test(\"the queuedMatchmakingConfiguration's region is taken from the ARN\", () => {\n        expect(queuedMatchmakingConfiguration.env.region).toBe('matchmakingConfiguration-region');\n      });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the queuedMatchmakingConfiguration's account is taken from the ARN",
            "suites": [
                "queuedMatchmakingConfiguration",
                "QueuedMatchmakingConfiguration.fromQueuedMatchmakingConfigurationAttributes()",
                "for an queuedMatchmakingConfiguration in a different account and region"
            ],
            "updatePoint": {
                "line": 526,
                "column": 78
            },
            "line": 526,
            "code": "      test(\"the queuedMatchmakingConfiguration's account is taken from the ARN\", () => {\n        expect(queuedMatchmakingConfiguration.env.account).toBe('123456789012');\n      });",
            "file": "queued-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required fields",
            "suites": [
                "script",
                ".fromScriptArn()"
            ],
            "updatePoint": {
                "line": 23,
                "column": 30
            },
            "line": 23,
            "code": "    test('with required fields', () => {\n      const script = gamelift.Script.fromScriptArn(stack, 'ImportedScript', scriptArn);\n\n      expect(script.scriptArn).toEqual(scriptArn);\n      expect(script.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: script }));\n    });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "script",
                ".fromScriptAttributes()"
            ],
            "updatePoint": {
                "line": 32,
                "column": 34
            },
            "line": 32,
            "code": "    test('with required attrs only', () => {\n      const script = gamelift.Script.fromScriptAttributes(stack, 'ImportedScript', { scriptArn });\n\n      expect(script.scriptId).toEqual(scriptId);\n      expect(script.scriptArn).toEqual(scriptArn);\n      expect(script.env.account).toEqual('123456789012');\n      expect(script.env.region).toEqual('script-region');\n      expect(script.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: script }));\n    });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all attrs",
            "suites": [
                "script",
                ".fromScriptAttributes()"
            ],
            "updatePoint": {
                "line": 42,
                "column": 24
            },
            "line": 42,
            "code": "    test('with all attrs', () => {\n      const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n      const script = gamelift.Script.fromScriptAttributes(stack, 'ImportedScript', { scriptArn, role });\n\n      expect(scriptId).toEqual(scriptId);\n      expect(script.grantPrincipal).toEqual(role);\n    });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a new script from asset",
            "suites": [
                "script",
                "new",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 87,
                "column": 49
            },
            "line": 87,
            "code": "      test('should create a new script from asset', () => {\n        script = gamelift.Script.fromAsset(stack, 'ImportedScript', localAsset);\n\n        expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          StorageLocation: {\n            Bucket: {\n              Ref: 'AssetParameters6019bfc8ab05a24b0ae9b5d8f4585cbfc7d1c30a23286d0b25ce7066a368a5d7S3Bucket72AA8348',\n            },\n          },\n        });\n\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a new script from bucket",
            "suites": [
                "script",
                "new",
                ".fromBucket()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 50
            },
            "line": 103,
            "code": "      test('should create a new script from bucket', () => {\n        script = gamelift.Script.fromBucket(stack, 'ImportedScript', contentBucket, 'content');\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          StorageLocation: {\n            Bucket: 'bucketname',\n            Key: 'content',\n          },\n        });\n\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should create a role and use it with the script",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 121,
                "column": 59
            },
            "line": 121,
            "code": "      test('should create a role and use it with the script', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n          AssumeRolePolicyDocument: {\n            Statement: [\n              {\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: {\n                  Service: 'gamelift.amazonaws.com',\n                },\n              },\n            ],\n            Version: '2012-10-17',\n          },\n        });\n\n        // Role policy should grant reading from the assets bucket\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n          PolicyDocument: {\n            Statement: [\n              contentBucketAccessStatement,\n            ],\n          },\n          Roles: [\n            {\n              Ref: 'ScriptServiceRole23DD8079',\n            },\n          ],\n        });\n\n        // check the script using the role\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          StorageLocation: {\n            Bucket: 'bucketname',\n            Key: 'content',\n            RoleArn: {\n              'Fn::GetAtt': [\n                'ScriptServiceRole23DD8079',\n                'Arn',\n              ],\n            },\n          },\n        });\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "should return correct script attributes from CloudFormation",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 166,
                "column": 71
            },
            "line": 166,
            "code": "      test('should return correct script attributes from CloudFormation', () => {\n        expect(stack.resolve(script.scriptId)).toEqual({ Ref: 'Script09016516' });\n        expect(stack.resolve(script.scriptArn)).toEqual({\n          'Fn::GetAtt': [\n            'Script09016516',\n            'Arn',\n          ],\n        });\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with a custom role should use it and set it in CloudFormation",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 176,
                "column": 73
            },
            "line": 176,
            "code": "      test('with a custom role should use it and set it in CloudFormation', () => {\n        const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n        script = new gamelift.Script(stack, 'ScriptWithRole', {\n          ...defaultProps,\n          role,\n        });\n\n        expect(script.grantPrincipal).toEqual(role);\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          StorageLocation: {\n            RoleArn: role.roleArn,\n          },\n        });\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with a custom scriptName should set it in CloudFormation",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 191,
                "column": 68
            },
            "line": 191,
            "code": "      test('with a custom scriptName should set it in CloudFormation', () => {\n        script = new gamelift.Script(stack, 'ScriptWithName', {\n          ...defaultProps,\n          scriptName: scriptName,\n        });\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          Name: scriptName,\n        });\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all optional attributes should set it in CloudFormation",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 202,
                "column": 72
            },
            "line": 202,
            "code": "      test('with all optional attributes should set it in CloudFormation', () => {\n        script = new gamelift.Script(stack, 'ScriptWithName', {\n          ...defaultProps,\n          scriptName: scriptName,\n          scriptVersion: '1.0',\n        });\n\n        Template.fromStack(stack).hasResourceProperties('AWS::GameLift::Script', {\n          Name: scriptName,\n          Version: '1.0',\n        });\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect scriptName (>1024)",
            "suites": [
                "script",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 215,
                "column": 48
            },
            "line": 215,
            "code": "      test('with an incorrect scriptName (>1024)', () => {\n        let incorrectScriptName = '';\n        for (let i = 0; i < 1025; i++) {\n          incorrectScriptName += 'A';\n        }\n\n        expect(() => new gamelift.Script(stack, 'ScriptWithWrongName', {\n          content,\n          scriptName: incorrectScriptName,\n        })).toThrow(/Script name can not be longer than 1024 characters but has 1025 characters./);\n      });",
            "file": "script.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "default StandaloneMatchmakingConfiguration",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 22,
                "column": 52
            },
            "line": 22,
            "code": "    test('default StandaloneMatchmakingConfiguration', () => {\n      new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        ruleSet: ruleSet,\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingConfiguration', {\n        Properties:\n            {\n              Name: 'test-config-name',\n              NotificationTarget: { Ref: 'MyStandaloneMatchmakingConfigurationTopicDEF24815' },\n              FlexMatchMode: 'STANDALONE',\n              AcceptanceRequired: false,\n              RequestTimeoutSeconds: 300,\n              RuleSetName: { Ref: 'MyMatchmakingRuleSet41F295C4' },\n            },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with all properties",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 41,
                "column": 29
            },
            "line": 41,
            "code": "    test('with all properties', () => {\n      new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-standaloneMatchmakingConfiguration',\n        ruleSet: ruleSet,\n      });\n\n      Template.fromStack(stack).hasResource('AWS::GameLift::MatchmakingConfiguration', {\n        Properties:\n            {\n              Name: 'test-standaloneMatchmakingConfiguration',\n              NotificationTarget: { Ref: 'MyStandaloneMatchmakingConfigurationTopicDEF24815' },\n              FlexMatchMode: 'STANDALONE',\n              AcceptanceRequired: false,\n              RequestTimeoutSeconds: 300,\n              RuleSetName: { Ref: 'MyMatchmakingRuleSet41F295C4' },\n            },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 60,
                "column": 32
            },
            "line": 60,
            "code": "    test('with an incorrect name', () => {\n      let incorrectName = '';\n      for (let i = 0; i < 129; i++) {\n        incorrectName += 'A';\n      }\n\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: incorrectName,\n        ruleSet: ruleSet,\n      })).toThrow(/Matchmaking configuration name can not be longer than 128 characters but has 129 characters./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect name format",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 72,
                "column": 39
            },
            "line": 72,
            "code": "    test('with an incorrect name format', () => {\n      let incorrectName = 'test with space';\n\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: incorrectName,\n        ruleSet: ruleSet,\n      })).toThrow(/Matchmaking configuration name test with space can contain only letters, numbers, hyphens, back slash or dot with no spaces./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect description",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 81,
                "column": 39
            },
            "line": 81,
            "code": "    test('with an incorrect description', () => {\n      let incorrectDescription = '';\n      for (let i = 0; i < 1025; i++) {\n        incorrectDescription += 'A';\n      }\n\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        ruleSet: ruleSet,\n        description: incorrectDescription,\n      })).toThrow(/Matchmaking configuration description can not be longer than 1024 characters but has 1025 characters./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect custom event data length",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 94,
                "column": 52
            },
            "line": 94,
            "code": "    test('with an incorrect custom event data length', () => {\n      let incorrectField: string = '';\n      for (let i = 0; i < 257; i++) {\n        incorrectField += 'A';\n      }\n\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        ruleSet: ruleSet,\n        customEventData: incorrectField,\n      })).toThrow(/Matchmaking configuration custom event data can not be longer than 256 characters but has 257 characters./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect acceptance timeout",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 107,
                "column": 46
            },
            "line": 107,
            "code": "    test('with an incorrect acceptance timeout', () => {\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        ruleSet: ruleSet,\n        acceptanceTimeout: Duration.seconds(700),\n      })).toThrow(/Matchmaking configuration acceptance timeout can not exceed 600 seconds, actual 700 seconds./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with an incorrect request timeout",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "new"
            ],
            "updatePoint": {
                "line": 115,
                "column": 43
            },
            "line": 115,
            "code": "    test('with an incorrect request timeout', () => {\n      expect(() => new gamelift.StandaloneMatchmakingConfiguration(stack, 'MyStandaloneMatchmakingConfiguration', {\n        matchmakingConfigurationName: 'test-config-name',\n        ruleSet: ruleSet,\n        requestTimeout: Duration.seconds(43300),\n      })).toThrow(/Matchmaking configuration request timeout can not exceed 43200 seconds, actual 43300 seconds./);\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metric",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 142,
                "column": 16
            },
            "line": 142,
            "code": "    test('metric', () => {\n      const metric = standaloneMatchmakingConfiguration.metric('CurrentTickets');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'CurrentTickets',\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricPlayersStarted",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 156,
                "column": 30
            },
            "line": 156,
            "code": "    test('metricPlayersStarted', () => {\n      const metric = standaloneMatchmakingConfiguration.metricPlayersStarted();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'PlayersStarted',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesRejected",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 171,
                "column": 31
            },
            "line": 171,
            "code": "    test('metricMatchesRejected', () => {\n      const metric = standaloneMatchmakingConfiguration.metricMatchesRejected();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesRejected',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesPlaced",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 186,
                "column": 29
            },
            "line": 186,
            "code": "    test('metricMatchesPlaced', () => {\n      const metric = standaloneMatchmakingConfiguration.metricMatchesPlaced();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesPlaced',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesCreated",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 201,
                "column": 30
            },
            "line": 201,
            "code": "    test('metricMatchesCreated', () => {\n      const metric = standaloneMatchmakingConfiguration.metricMatchesCreated();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesCreated',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricMatchesAccepted",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 216,
                "column": 31
            },
            "line": 216,
            "code": "    test('metricMatchesAccepted', () => {\n      const metric = standaloneMatchmakingConfiguration.metricMatchesAccepted();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'MatchesAccepted',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "metricCurrentTickets",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 231,
                "column": 30
            },
            "line": 231,
            "code": "    test('metricCurrentTickets', () => {\n      const metric = standaloneMatchmakingConfiguration.metricCurrentTickets();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/GameLift',\n        metricName: 'CurrentTickets',\n        statistic: cloudwatch.Stats.AVERAGE,\n        dimensions: {\n          MatchmakingConfigurationName: standaloneMatchmakingConfiguration.matchmakingConfigurationName,\n        },\n      });\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationArn",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "test import methods"
            ],
            "updatePoint": {
                "line": 250,
                "column": 86
            },
            "line": 250,
            "code": "    test('StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationArn', () => {\n      // GIVEN\n      const stack2 = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationArn(stack2, 'Imported', 'arn:aws:gamelift:us-east-1:123456789012:matchmakingconfiguration/sample-standaloneMatchmakingConfiguration-name');\n\n      // THEN\n      expect(imported.matchmakingConfigurationArn).toEqual('arn:aws:gamelift:us-east-1:123456789012:matchmakingconfiguration/sample-standaloneMatchmakingConfiguration-name');\n      expect(imported.matchmakingConfigurationName).toEqual('sample-standaloneMatchmakingConfiguration-name');\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationName",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "test import methods"
            ],
            "updatePoint": {
                "line": 262,
                "column": 87
            },
            "line": 262,
            "code": "    test('StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationName', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const imported = gamelift.StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationName(stack, 'Imported', 'sample-matchmakingConfiguration-name');\n\n      // THEN\n      expect(stack.resolve(imported.matchmakingConfigurationArn)).toStrictEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { Ref: 'AWS::Partition' },\n          ':gamelift:',\n          { Ref: 'AWS::Region' },\n          ':',\n          { Ref: 'AWS::AccountId' },\n          ':matchmakingconfiguration/sample-matchmakingConfiguration-name',\n        ]],\n      });\n      expect(stack.resolve(imported.matchmakingConfigurationName)).toStrictEqual('sample-matchmakingConfiguration-name');\n    });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 298,
                "column": 36
            },
            "line": 298,
            "code": "      test('with required attrs only', () => {\n        const importedFleet = gamelift.StandaloneMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedStandaloneMatchmakingConfiguration', { matchmakingConfigurationArn });\n\n        expect(importedFleet.matchmakingConfigurationName).toEqual(matchmakingConfigurationName);\n        expect(importedFleet.matchmakingConfigurationArn).toEqual(matchmakingConfigurationArn);\n        expect(importedFleet.env.account).toEqual('123456789012');\n        expect(importedFleet.env.region).toEqual('matchmakingConfiguration-region');\n      });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with missing attrs",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 307,
                "column": 30
            },
            "line": 307,
            "code": "      test('with missing attrs', () => {\n        expect(() => gamelift.StandaloneMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedStandaloneMatchmakingConfiguration', { }))\n          .toThrow(/Either matchmakingConfigurationName or matchmakingConfigurationArn must be provided in MatchmakingConfigurationAttributes/);\n      });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with invalid ARN",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationAttributes()",
                ""
            ],
            "updatePoint": {
                "line": 312,
                "column": 28
            },
            "line": 312,
            "code": "      test('with invalid ARN', () => {\n        expect(() => gamelift.StandaloneMatchmakingConfiguration.fromMatchmakingConfigurationAttributes(stack, 'ImportedStandaloneMatchmakingConfiguration', { matchmakingConfigurationArn: 'arn:aws:gamelift:matchmakingConfiguration-region:123456789012:matchmakingconfiguration' }))\n          .toThrow(/No matchmaking configuration name found in ARN: 'arn:aws:gamelift:matchmakingConfiguration-region:123456789012:matchmakingconfiguration'/);\n      });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the standaloneMatchmakingConfiguration's region is taken from the ARN",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationAttributes()",
                "for an standaloneMatchmakingConfiguration in a different account and region"
            ],
            "updatePoint": {
                "line": 325,
                "column": 81
            },
            "line": 325,
            "code": "      test(\"the standaloneMatchmakingConfiguration's region is taken from the ARN\", () => {\n        expect(standaloneMatchmakingConfiguration.env.region).toBe('matchmakingConfiguration-region');\n      });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "the standaloneMatchmakingConfiguration's account is taken from the ARN",
            "suites": [
                "standaloneMatchmakingConfiguration",
                "StandaloneMatchmakingConfiguration.fromStandaloneMatchmakingConfigurationAttributes()",
                "for an standaloneMatchmakingConfiguration in a different account and region"
            ],
            "updatePoint": {
                "line": 329,
                "column": 82
            },
            "line": 329,
            "code": "      test(\"the standaloneMatchmakingConfiguration's account is taken from the ARN\", () => {\n        expect(standaloneMatchmakingConfiguration.env.account).toBe('123456789012');\n      });",
            "file": "standalone-matchmaking-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-gamelift/test"
        },
        {
            "name": "with valid bucket name and key and bound by job sets the right path and grants the job permissions to read from it",
            "suites": [
                "Code",
                ".fromBucket()"
            ],
            "updatePoint": {
                "line": 21,
                "column": 124
            },
            "line": 21,
            "code": "    test('with valid bucket name and key and bound by job sets the right path and grants the job permissions to read from it', () => {\n      bucket = s3.Bucket.fromBucketName(stack, 'Bucket', 'bucketname');\n      script = glue.Code.fromBucket(bucket, key);\n      new glue.Job(stack, 'Job1', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script,\n        }),\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        Command: {\n          ScriptLocation: 's3://bucketname/script',\n        },\n      });\n\n      // Role policy should grant reading from the assets bucket\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: [\n                's3:GetObject*',\n                's3:GetBucket*',\n                's3:List*',\n              ],\n              Effect: 'Allow',\n              Resource: [\n                {\n                  'Fn::Join': [\n                    '',\n                    [\n                      'arn:',\n                      {\n                        Ref: 'AWS::Partition',\n                      },\n                      ':s3:::bucketname',\n                    ],\n                  ],\n                },\n                {\n                  'Fn::Join': [\n                    '',\n                    [\n                      'arn:',\n                      {\n                        Ref: 'AWS::Partition',\n                      },\n                      ':s3:::bucketname/script',\n                    ],\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n        Roles: [\n          {\n            Ref: 'Job1ServiceRole7AF34CCA',\n          },\n        ],\n      });\n    });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with valid and existing file path and bound to job sets job's script location and permissions stack metadata",
            "suites": [
                "Code",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 95,
                "column": 118
            },
            "line": 95,
            "code": "    test(\"with valid and existing file path and bound to job sets job's script location and permissions stack metadata\", () => {\n      new glue.Job(stack, 'Job1', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script,\n        }),\n      });\n\n      expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        Command: {\n          ScriptLocation: {\n            'Fn::Join': [\n              '',\n              [\n                's3://',\n                {\n                  Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3Bucket4E517469',\n                },\n                '/',\n                {\n                  'Fn::Select': [\n                    0,\n                    {\n                      'Fn::Split': [\n                        '||',\n                        {\n                          Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3VersionKeyF7753763',\n                        },\n                      ],\n                    },\n                  ],\n                },\n                {\n                  'Fn::Select': [\n                    1,\n                    {\n                      'Fn::Split': [\n                        '||',\n                        {\n                          Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3VersionKeyF7753763',\n                        },\n                      ],\n                    },\n                  ],\n                },\n              ],\n            ],\n          },\n        },\n      });\n      // Role policy should grant reading from the assets bucket\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: [\n                's3:GetObject*',\n                's3:GetBucket*',\n                's3:List*',\n              ],\n              Effect: 'Allow',\n              Resource: [\n                {\n                  'Fn::Join': [\n                    '',\n                    [\n                      'arn:',\n                      {\n                        Ref: 'AWS::Partition',\n                      },\n                      ':s3:::',\n                      {\n                        Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3Bucket4E517469',\n                      },\n                    ],\n                  ],\n                },\n                {\n                  'Fn::Join': [\n                    '',\n                    [\n                      'arn:',\n                      {\n                        Ref: 'AWS::Partition',\n                      },\n                      ':s3:::',\n                      {\n                        Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3Bucket4E517469',\n                      },\n                      '/*',\n                    ],\n                  ],\n                },\n              ],\n            },\n          ],\n        },\n        Roles: [\n          {\n            Ref: 'Job1ServiceRole7AF34CCA',\n          },\n        ],\n      });\n    });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with an unsupported directory path throws",
            "suites": [
                "Code",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 202,
                "column": 51
            },
            "line": 202,
            "code": "    test('with an unsupported directory path throws', () => {\n      expect(() => glue.Code.fromAsset(directoryPath))\n        .toThrow(/Only files are supported/);\n    });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "used in more than 1 job in the same stack should be reused",
            "suites": [
                "Code",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 207,
                "column": 68
            },
            "line": 207,
            "code": "    test('used in more than 1 job in the same stack should be reused', () => {\n      new glue.Job(stack, 'Job1', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script,\n        }),\n      });\n      new glue.Job(stack, 'Job2', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script,\n        }),\n      });\n      const ScriptLocation = {\n        'Fn::Join': [\n          '',\n          [\n            's3://',\n            {\n              Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3Bucket4E517469',\n            },\n            '/',\n            {\n              'Fn::Select': [\n                0,\n                {\n                  'Fn::Split': [\n                    '||',\n                    {\n                      Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3VersionKeyF7753763',\n                    },\n                  ],\n                },\n              ],\n            },\n            {\n              'Fn::Select': [\n                1,\n                {\n                  'Fn::Split': [\n                    '||',\n                    {\n                      Ref: 'AssetParameters432033e3218068a915d2532fa9be7858a12b228a2ae6e5c10faccd9097b1e855S3VersionKeyF7753763',\n                    },\n                  ],\n                },\n              ],\n            },\n          ],\n        ],\n      };\n\n      expect(stack.node.metadata.find(m => m.type === 'aws:cdk:asset')).toBeDefined();\n      // Job1 and Job2 use reuse the asset\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        Command: {\n          ScriptLocation,\n        },\n        Role: {\n          'Fn::GetAtt': [\n            'Job1ServiceRole7AF34CCA',\n            'Arn',\n          ],\n        },\n      });\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        Command: {\n          ScriptLocation,\n        },\n        Role: {\n          'Fn::GetAtt': [\n            'Job2ServiceRole5D2B98FE',\n            'Arn',\n          ],\n        },\n      });\n    });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "throws if trying to rebind in another stack",
            "suites": [
                "Code",
                ".fromAsset()"
            ],
            "updatePoint": {
                "line": 287,
                "column": 53
            },
            "line": 287,
            "code": "    test('throws if trying to rebind in another stack', () => {\n      new glue.Job(stack, 'Job1', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script,\n        }),\n      });\n      const differentStack = new cdk.Stack();\n\n      expect(() => new glue.Job(differentStack, 'Job2', {\n        executable: glue.JobExecutable.pythonShell({\n          glueVersion: glue.GlueVersion.V1_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          script: script,\n        }),\n      })).toThrow(/associated with another stack/);\n    });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a connection with connection properties",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 45
            },
            "line": 6,
            "code": "test('a connection with connection properties', () => {\n  const stack = new cdk.Stack();\n  new glue.Connection(stack, 'Connection', {\n    type: glue.ConnectionType.JDBC,\n    properties: {\n      JDBC_CONNECTION_URL: 'jdbc:server://server:443/connection',\n      USERNAME: 'username',\n      PASSWORD: 'password',\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionProperties: {\n        JDBC_CONNECTION_URL: 'jdbc:server://server:443/connection',\n        USERNAME: 'username',\n        PASSWORD: 'password',\n      },\n      ConnectionType: 'JDBC',\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a connection with a subnet and security group",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 51
            },
            "line": 32,
            "code": "test('a connection with a subnet and security group', () => {\n  const stack = new cdk.Stack();\n  const subnet = ec2.Subnet.fromSubnetAttributes(stack, 'subnet', {\n    subnetId: 'subnetId',\n    availabilityZone: 'azId',\n  });\n  const securityGroup = ec2.SecurityGroup.fromSecurityGroupId(stack, 'securityGroup', 'sgId');\n  new glue.Connection(stack, 'Connection', {\n    type: glue.ConnectionType.NETWORK,\n    securityGroups: [securityGroup],\n    subnet,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionType: 'NETWORK',\n      PhysicalConnectionRequirements: {\n        AvailabilityZone: 'azId',\n        SubnetId: 'subnetId',\n        SecurityGroupIdList: ['sgId'],\n      },\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a connection with a name and description",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 46
            },
            "line": 60,
            "code": "test('a connection with a name and description', () => {\n  const stack = new cdk.Stack();\n  new glue.Connection(stack, 'Connection', {\n    connectionName: 'name',\n    description: 'description',\n    type: glue.ConnectionType.NETWORK,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionType: 'NETWORK',\n      Name: 'name',\n      Description: 'description',\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a connection with a custom type",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 37
            },
            "line": 80,
            "code": "test('a connection with a custom type', () => {\n  const stack = new cdk.Stack();\n  new glue.Connection(stack, 'Connection', {\n    connectionName: 'name',\n    description: 'description',\n    type: new glue.ConnectionType('CUSTOM_TYPE'),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionType: 'CUSTOM_TYPE',\n      Name: 'name',\n      Description: 'description',\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a connection with match criteria",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 38
            },
            "line": 100,
            "code": "test('a connection with match criteria', () => {\n  const stack = new cdk.Stack();\n  new glue.Connection(stack, 'Connection', {\n    type: glue.ConnectionType.NETWORK,\n    matchCriteria: ['c1', 'c2'],\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionType: 'NETWORK',\n      MatchCriteria: ['c1', 'c2'],\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "addProperty",
            "suites": [],
            "updatePoint": {
                "line": 118,
                "column": 17
            },
            "line": 118,
            "code": "test('addProperty', () => {\n  const stack = new cdk.Stack();\n  const connection = new glue.Connection(stack, 'Connection', {\n    type: glue.ConnectionType.NETWORK,\n  });\n  connection.addProperty('SomeKey', 'SomeValue');\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Connection', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    ConnectionInput: {\n      ConnectionType: 'NETWORK',\n      ConnectionProperties: {\n        SomeKey: 'SomeValue',\n      },\n    },\n  });\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fromConnectionName",
            "suites": [],
            "updatePoint": {
                "line": 138,
                "column": 24
            },
            "line": 138,
            "code": "test('fromConnectionName', () => {\n  const connectionName = 'name';\n  const stack = new cdk.Stack();\n  const connection = glue.Connection.fromConnectionName(stack, 'ImportedConnection', connectionName);\n\n  expect(connection.connectionName).toEqual(connectionName);\n  expect(connection.connectionArn).toEqual(stack.formatArn({\n    service: 'glue',\n    resource: 'connection',\n    resourceName: connectionName,\n  }));\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fromConnectionArn",
            "suites": [],
            "updatePoint": {
                "line": 151,
                "column": 23
            },
            "line": 151,
            "code": "test('fromConnectionArn', () => {\n  const connectionArn = 'arn:aws:glue:region:account-id:connection/name';\n  const stack = new cdk.Stack();\n  const connection = glue.Connection.fromConnectionArn(stack, 'ImportedConnection', connectionArn);\n\n  expect(connection.connectionName).toEqual('name');\n  expect(connection.connectionArn).toEqual(connectionArn);\n});",
            "file": "connection.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "default database does not create a bucket",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 47
            },
            "line": 16,
            "code": "test('default database does not create a bucket', () => {\n  new glue.Database(stack, 'Database');\n\n  Template.fromStack(stack).templateMatches({\n    Resources: {\n      DatabaseB269D8BB: {\n        Type: 'AWS::Glue::Database',\n        Properties: {\n          CatalogId: {\n            Ref: 'AWS::AccountId',\n          },\n          DatabaseInput: {\n            Name: 'database',\n          },\n        },\n      },\n    },\n  });\n\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "explicit locationURI",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 26
            },
            "line": 37,
            "code": "test('explicit locationURI', () => {\n  new glue.Database(stack, 'Database', {\n    locationUri: 's3://my-uri/',\n  });\n\n  Template.fromStack(stack).templateMatches({\n    Resources: {\n      DatabaseB269D8BB: {\n        Type: 'AWS::Glue::Database',\n        Properties: {\n          CatalogId: {\n            Ref: 'AWS::AccountId',\n          },\n          DatabaseInput: {\n            LocationUri: 's3://my-uri/',\n            Name: 'database',\n          },\n        },\n      },\n    },\n  });\n\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fromDatabase",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 18
            },
            "line": 61,
            "code": "test('fromDatabase', () => {\n  // WHEN\n  const database = glue.Database.fromDatabaseArn(stack, 'import', 'arn:aws:glue:us-east-1:123456789012:database/db1');\n\n  // THEN\n  expect(database.databaseArn).toEqual('arn:aws:glue:us-east-1:123456789012:database/db1');\n  expect(database.databaseName).toEqual('db1');\n  expect(stack.resolve(database.catalogArn)).toEqual({\n    'Fn::Join': ['',\n      ['arn:', { Ref: 'AWS::Partition' }, ':glue:', { Ref: 'AWS::Region' }, ':', { Ref: 'AWS::AccountId' }, ':catalog']],\n  });\n  expect(stack.resolve(database.catalogId)).toEqual({ Ref: 'AWS::AccountId' });\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "locationUri length must be >= 1",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 37
            },
            "line": 75,
            "code": "test('locationUri length must be >= 1', () => {\n  expect(() =>\n    new glue.Database(stack, 'Database', {\n      locationUri: '',\n    }),\n  ).toThrow();\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "locationUri length must be <= 1024",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 40
            },
            "line": 83,
            "code": "test('locationUri length must be <= 1024', () => {\n  expect(() =>\n    new glue.Database(stack, 'Database', {\n      locationUri: 'a'.repeat(1025),\n    }),\n  ).toThrow();\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can specify a physical name",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 33
            },
            "line": 91,
            "code": "test('can specify a physical name', () => {\n  new glue.Database(stack, 'Database', {\n    databaseName: 'my_database',\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Database', {\n    DatabaseInput: {\n      Name: 'my_database',\n    },\n  });\n});",
            "file": "database.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".V0_9 should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 6,
                "column": 43
            },
            "line": 6,
            "code": "  test('.V0_9 should set the name correctly', () => expect(glue.GlueVersion.V0_9.name).toEqual('0.9'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".V1_0 should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 8,
                "column": 43
            },
            "line": 8,
            "code": "  test('.V1_0 should set the name correctly', () => expect(glue.GlueVersion.V1_0.name).toEqual('1.0'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".V2_0 should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 10,
                "column": 43
            },
            "line": 10,
            "code": "  test('.V2_0 should set the name correctly', () => expect(glue.GlueVersion.V2_0.name).toEqual('2.0'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".V3_0 should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 12,
                "column": 43
            },
            "line": 12,
            "code": "  test('.V3_0 should set the name correctly', () => expect(glue.GlueVersion.V3_0.name).toEqual('3.0'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".V4_0 should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 14,
                "column": 43
            },
            "line": 14,
            "code": "  test('.V4_0 should set the name correctly', () => expect(glue.GlueVersion.V4_0.name).toEqual('4.0'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "of(customVersion) should set the name correctly",
            "suites": [
                "GlueVersion"
            ],
            "updatePoint": {
                "line": 16,
                "column": 55
            },
            "line": 16,
            "code": "  test('of(customVersion) should set the name correctly', () => expect(glue.GlueVersion.of('CustomVersion').name).toEqual('CustomVersion'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".TWO should set the name correctly",
            "suites": [
                "PythonVersion"
            ],
            "updatePoint": {
                "line": 20,
                "column": 42
            },
            "line": 20,
            "code": "  test('.TWO should set the name correctly', () => expect(glue.PythonVersion.TWO).toEqual('2'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".THREE should set the name correctly",
            "suites": [
                "PythonVersion"
            ],
            "updatePoint": {
                "line": 22,
                "column": 44
            },
            "line": 22,
            "code": "  test('.THREE should set the name correctly', () => expect(glue.PythonVersion.THREE).toEqual('3'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".THREE_NINE should set the name correctly",
            "suites": [
                "PythonVersion"
            ],
            "updatePoint": {
                "line": 24,
                "column": 49
            },
            "line": 24,
            "code": "  test('.THREE_NINE should set the name correctly', () => expect(glue.PythonVersion.THREE_NINE).toEqual('3.9'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".ETL should set the name correctly",
            "suites": [
                "JobType"
            ],
            "updatePoint": {
                "line": 28,
                "column": 42
            },
            "line": 28,
            "code": "  test('.ETL should set the name correctly', () => expect(glue.JobType.ETL.name).toEqual('glueetl'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".STREAMING should set the name correctly",
            "suites": [
                "JobType"
            ],
            "updatePoint": {
                "line": 30,
                "column": 48
            },
            "line": 30,
            "code": "  test('.STREAMING should set the name correctly', () => expect(glue.JobType.STREAMING.name).toEqual('gluestreaming'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".PYTHON_SHELL should set the name correctly",
            "suites": [
                "JobType"
            ],
            "updatePoint": {
                "line": 32,
                "column": 51
            },
            "line": 32,
            "code": "  test('.PYTHON_SHELL should set the name correctly', () => expect(glue.JobType.PYTHON_SHELL.name).toEqual('pythonshell'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".RAY should set the name correctly",
            "suites": [
                "JobType"
            ],
            "updatePoint": {
                "line": 34,
                "column": 42
            },
            "line": 34,
            "code": "  test('.RAY should set the name correctly', () => expect(glue.JobType.RAY.name).toEqual('glueray'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "of(customName) should set the name correctly",
            "suites": [
                "JobType"
            ],
            "updatePoint": {
                "line": 36,
                "column": 52
            },
            "line": 36,
            "code": "  test('of(customName) should set the name correctly', () => expect(glue.JobType.of('CustomName').name).toEqual('CustomName'));",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with valid config should succeed",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 51,
                "column": 42
            },
            "line": 51,
            "code": "    test('with valid config should succeed', () => {\n      expect(glue.JobExecutable.of({\n        glueVersion: glue.GlueVersion.V1_0,\n        type: glue.JobType.PYTHON_SHELL,\n        language: glue.JobLanguage.PYTHON,\n        pythonVersion: glue.PythonVersion.THREE,\n        script,\n      })).toBeDefined();\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with JobType.PYTHON_SHELL and a language other than JobLanguage.PYTHON should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 61,
                "column": 93
            },
            "line": 61,
            "code": "    test('with JobType.PYTHON_SHELL and a language other than JobLanguage.PYTHON should throw', () => {\n      expect(() => glue.JobExecutable.of({\n        glueVersion: glue.GlueVersion.V3_0,\n        type: glue.JobType.PYTHON_SHELL,\n        language: glue.JobLanguage.SCALA,\n        script,\n      })).toThrow(/Python shell requires the language to be set to Python/);\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with JobType.RAY and a language other than JobLanguage.PYTHON should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 70,
                "column": 84
            },
            "line": 70,
            "code": "    test('with JobType.RAY and a language other than JobLanguage.PYTHON should throw', () => {\n      expect(() => glue.JobExecutable.of({\n        glueVersion: glue.GlueVersion.V4_0,\n        type: glue.JobType.RAY,\n        language: glue.JobLanguage.SCALA,\n        script,\n      })).toThrow(/Ray requires the language to be set to Python/);\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with a non JobLanguage.PYTHON and extraPythonFiles set should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 79,
                "column": 77
            },
            "line": 79,
            "code": "    test('with a non JobLanguage.PYTHON and extraPythonFiles set should throw', () => {\n      expect(() => glue.JobExecutable.of({\n        glueVersion: glue.GlueVersion.V3_0,\n        type: glue.JobType.ETL,\n        language: glue.JobLanguage.SCALA,\n        className: 'com.Test',\n        extraPythonFiles: [script],\n        script,\n      })).toThrow(/extraPythonFiles is not supported for languages other than JobLanguage.PYTHON/);\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with JobType.PYTHON_SHELL and GlueVersion  should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 91,
                "column": 81
            },
            "line": 91,
            "code": "      test(`with JobType.PYTHON_SHELL and GlueVersion ${glueVersion} should throw`, () => {\n        expect(() => glue.JobExecutable.of({\n          type: glue.JobType.PYTHON_SHELL,\n          language: glue.JobLanguage.PYTHON,\n          pythonVersion: glue.PythonVersion.TWO,\n          script,\n          glueVersion,\n        })).toThrow(`Specified GlueVersion ${glueVersion.name} does not support Python Shell`);\n      });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with extraJarsFirst set and GlueVersion  should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 103,
                "column": 84
            },
            "line": 103,
            "code": "      test(`with extraJarsFirst set and GlueVersion ${glueVersion.name} should throw`, () => {\n        expect(() => glue.JobExecutable.of({\n          type: glue.JobType.ETL,\n          language: glue.JobLanguage.PYTHON,\n          pythonVersion: glue.PythonVersion.TWO,\n          extraJarsFirst: true,\n          script,\n          glueVersion,\n        })).toThrow(`Specified GlueVersion ${glueVersion.name} does not support extraJarsFirst`);\n      });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with PythonVersion.TWO and GlueVersion  should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 116,
                "column": 78
            },
            "line": 116,
            "code": "      test(`with PythonVersion.TWO and GlueVersion ${glueVersion} should throw`, () => {\n        expect(() => glue.JobExecutable.of({\n          type: glue.JobType.ETL,\n          language: glue.JobLanguage.PYTHON,\n          pythonVersion: glue.PythonVersion.TWO,\n          script,\n          glueVersion,\n        })).toThrow(`Specified GlueVersion ${glueVersion.name} does not support PythonVersion 2`);\n      });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with PythonVersion set to PythonVersion.THREE_NINE and JobType etl should throw",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 127,
                "column": 89
            },
            "line": 127,
            "code": "    test('with PythonVersion set to PythonVersion.THREE_NINE and JobType etl should throw', () => {\n      expect(() => glue.JobExecutable.of({\n        type: glue.JobType.ETL,\n        language: glue.JobLanguage.PYTHON,\n        pythonVersion: glue.PythonVersion.THREE_NINE,\n        script,\n        glueVersion: glue.GlueVersion.V1_0,\n      })).toThrow('Specified PythonVersion PythonVersion.THREE_NINE is only supported for JobType Python Shell');\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with PythonVersion PythonVersion.THREE_NINE and JobType pythonshell should succeed",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 137,
                "column": 92
            },
            "line": 137,
            "code": "    test('with PythonVersion PythonVersion.THREE_NINE and JobType pythonshell should succeed', () => {\n      expect(glue.JobExecutable.of({\n        type: glue.JobType.PYTHON_SHELL,\n        glueVersion: glue.GlueVersion.V1_0,\n        language: glue.JobLanguage.PYTHON,\n        pythonVersion: glue.PythonVersion.THREE_NINE,\n        script,\n      })).toBeDefined();\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with PythonVersion PythonVersion.THREE_NINE and JobType ray should succeed",
            "suites": [
                "JobExecutable",
                ".of()"
            ],
            "updatePoint": {
                "line": 147,
                "column": 84
            },
            "line": 147,
            "code": "    test('with PythonVersion PythonVersion.THREE_NINE and JobType ray should succeed', () => {\n      expect(glue.JobExecutable.of({\n        type: glue.JobType.RAY,\n        glueVersion: glue.GlueVersion.V4_0,\n        language: glue.JobLanguage.PYTHON,\n        pythonVersion: glue.PythonVersion.THREE_NINE,\n        script,\n      })).toBeDefined();\n    });",
            "file": "job-executable.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".STANDARD should set the name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 11,
                "column": 47
            },
            "line": 11,
            "code": "  test('.STANDARD should set the name correctly', () => expect(glue.WorkerType.STANDARD.name).toEqual('Standard'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".G_1X should set the name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 13,
                "column": 43
            },
            "line": 13,
            "code": "  test('.G_1X should set the name correctly', () => expect(glue.WorkerType.G_1X.name).toEqual('G.1X'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".G_2X should set the name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 15,
                "column": 43
            },
            "line": 15,
            "code": "  test('.G_2X should set the name correctly', () => expect(glue.WorkerType.G_2X.name).toEqual('G.2X'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".G_025X should set the name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 17,
                "column": 45
            },
            "line": 17,
            "code": "  test('.G_025X should set the name correctly', () => expect(glue.WorkerType.G_025X.name).toEqual('G.025X'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".Z_2X should set the name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 19,
                "column": 43
            },
            "line": 19,
            "code": "  test('.Z_2X should set the name correctly', () => expect(glue.WorkerType.Z_2X.name).toEqual('Z.2X'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "of(customType) should set name correctly",
            "suites": [
                "WorkerType"
            ],
            "updatePoint": {
                "line": 21,
                "column": 48
            },
            "line": 21,
            "code": "  test('of(customType) should set name correctly', () => expect(glue.WorkerType.of('CustomType').name).toEqual('CustomType'));",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with required attrs only",
            "suites": [
                "Job",
                ".fromJobAttributes()"
            ],
            "updatePoint": {
                "line": 33,
                "column": 34
            },
            "line": 33,
            "code": "    test('with required attrs only', () => {\n      const job = glue.Job.fromJobAttributes(stack, 'ImportedJob', { jobName });\n\n      expect(job.jobName).toEqual(jobName);\n      expect(job.jobArn).toEqual(stack.formatArn({\n        service: 'glue',\n        resource: 'job',\n        resourceName: jobName,\n      }));\n      expect(job.grantPrincipal).toEqual(new iam.UnknownPrincipal({ resource: job }));\n    });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with all attrs",
            "suites": [
                "Job",
                ".fromJobAttributes()"
            ],
            "updatePoint": {
                "line": 45,
                "column": 24
            },
            "line": 45,
            "code": "    test('with all attrs', () => {\n      const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n      const job = glue.Job.fromJobAttributes(stack, 'ImportedJob', { jobName, role });\n\n      expect(job.jobName).toEqual(jobName);\n      expect(job.jobArn).toEqual(stack.formatArn({\n        service: 'glue',\n        resource: 'job',\n        resourceName: jobName,\n      }));\n      expect(job.grantPrincipal).toEqual(role);\n    });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should create a role and use it with the job",
            "suites": [
                "Job",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 125,
                "column": 56
            },
            "line": 125,
            "code": "      test('should create a role and use it with the job', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n          AssumeRolePolicyDocument: {\n            Statement: [\n              {\n                Action: 'sts:AssumeRole',\n                Effect: 'Allow',\n                Principal: {\n                  Service: 'glue.amazonaws.com',\n                },\n              },\n            ],\n            Version: '2012-10-17',\n          },\n          ManagedPolicyArns: [\n            {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':iam::aws:policy/service-role/AWSGlueServiceRole',\n                ],\n              ],\n            },\n          ],\n        });\n\n        // Role policy should grant reading from the assets bucket\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n          PolicyDocument: {\n            Statement: [\n              codeBucketAccessStatement,\n            ],\n          },\n          Roles: [\n            {\n              Ref: 'JobServiceRole4F432993',\n            },\n          ],\n        });\n\n        // check the job using the role\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          Command: {\n            Name: 'glueetl',\n            ScriptLocation: 's3://bucketname/script',\n          },\n          Role: {\n            'Fn::GetAtt': [\n              'JobServiceRole4F432993',\n              'Arn',\n            ],\n          },\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should return correct jobName and jobArn from CloudFormation",
            "suites": [
                "Job",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 184,
                "column": 72
            },
            "line": 184,
            "code": "      test('should return correct jobName and jobArn from CloudFormation', () => {\n        expect(stack.resolve(job.jobName)).toEqual({ Ref: 'JobB9D00F9F' });\n        expect(stack.resolve(job.jobArn)).toEqual({\n          'Fn::Join': ['', ['arn:', { Ref: 'AWS::Partition' }, ':glue:', { Ref: 'AWS::Region' }, ':', { Ref: 'AWS::AccountId' }, ':job/', { Ref: 'JobB9D00F9F' }]],\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with a custom role should use it and set it in CloudFormation",
            "suites": [
                "Job",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 191,
                "column": 73
            },
            "line": 191,
            "code": "      test('with a custom role should use it and set it in CloudFormation', () => {\n        const role = iam.Role.fromRoleArn(stack, 'Role', 'arn:aws:iam::123456789012:role/TestRole');\n        job = new glue.Job(stack, 'JobWithRole', {\n          ...defaultProps,\n          role,\n        });\n\n        expect(job.grantPrincipal).toEqual(role);\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          Role: role.roleArn,\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with a custom jobName should set it in CloudFormation",
            "suites": [
                "Job",
                "new",
                "with necessary props only"
            ],
            "updatePoint": {
                "line": 204,
                "column": 65
            },
            "line": 204,
            "code": "      test('with a custom jobName should set it in CloudFormation', () => {\n        job = new glue.Job(stack, 'JobWithName', {\n          ...defaultProps,\n          jobName,\n        });\n\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          Name: jobName,\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should set minimal default arguments",
            "suites": [
                "Job",
                "new",
                "enabling continuous logging with defaults"
            ],
            "updatePoint": {
                "line": 224,
                "column": 48
            },
            "line": 224,
            "code": "      test('should set minimal default arguments', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          DefaultArguments: {\n            '--enable-continuous-cloudwatch-log': 'true',\n            '--enable-continuous-log-filter': 'true',\n          },\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should set all arguments",
            "suites": [
                "Job",
                "new",
                "enabling continuous logging with all props set"
            ],
            "updatePoint": {
                "line": 251,
                "column": 36
            },
            "line": 251,
            "code": "      test('should set all arguments', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          DefaultArguments: {\n            '--enable-continuous-cloudwatch-log': 'true',\n            '--enable-continuous-log-filter': 'false',\n            '--continuous-log-logGroup': 'LogGroupName',\n            '--continuous-log-logStreamPrefix': 'LogStreamPrefix',\n            '--continuous-log-conversionPattern': '%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n',\n          },\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should grant cloudwatch log write permissions",
            "suites": [
                "Job",
                "new",
                "enabling continuous logging with all props set"
            ],
            "updatePoint": {
                "line": 263,
                "column": 57
            },
            "line": 263,
            "code": "      test('should grant cloudwatch log write permissions', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n          PolicyDocument: {\n            Statement: [\n              {\n                Action: [\n                  'logs:CreateLogStream',\n                  'logs:PutLogEvents',\n                ],\n                Effect: 'Allow',\n                Resource: {\n                  'Fn::Join': [\n                    '',\n                    [\n                      'arn:',\n                      {\n                        Ref: 'AWS::Partition',\n                      },\n                      ':logs:',\n                      {\n                        Ref: 'AWS::Region',\n                      },\n                      ':',\n                      {\n                        Ref: 'AWS::AccountId',\n                      },\n                      ':log-group:LogGroupName:*',\n                    ],\n                  ],\n                },\n              },\n              codeBucketAccessStatement,\n            ],\n          },\n          Roles: [\n            {\n              Ref: 'JobServiceRole4F432993',\n            },\n          ],\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should create spark ui bucket",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with no bucket or path provided"
            ],
            "updatePoint": {
                "line": 315,
                "column": 43
            },
            "line": 315,
            "code": "        test('should create spark ui bucket', () => {\n          Template.fromStack(stack).resourceCountIs('AWS::S3::Bucket', 1);\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should grant the role read/write permissions to the spark ui bucket",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with no bucket or path provided"
            ],
            "updatePoint": {
                "line": 319,
                "column": 81
            },
            "line": 319,
            "code": "        test('should grant the role read/write permissions to the spark ui bucket', () => {\n          Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: [\n                    's3:GetObject*',\n                    's3:GetBucket*',\n                    's3:List*',\n                    's3:DeleteObject*',\n                    's3:PutObject',\n                    's3:PutObjectLegalHold',\n                    's3:PutObjectRetention',\n                    's3:PutObjectTagging',\n                    's3:PutObjectVersionTagging',\n                    's3:Abort*',\n                  ],\n                  Effect: 'Allow',\n                  Resource: [\n                    {\n                      'Fn::GetAtt': [\n                        'JobSparkUIBucket8E6A0139',\n                        'Arn',\n                      ],\n                    },\n                    {\n                      'Fn::Join': [\n                        '',\n                        [\n                          {\n                            'Fn::GetAtt': [\n                              'JobSparkUIBucket8E6A0139',\n                              'Arn',\n                            ],\n                          },\n                          '/*',\n                        ],\n                      ],\n                    },\n                  ],\n                },\n                codeBucketAccessStatement,\n              ],\n              Version: '2012-10-17',\n            },\n            PolicyName: 'JobServiceRoleDefaultPolicy03F68F9D',\n            Roles: [\n              {\n                Ref: 'JobServiceRole4F432993',\n              },\n            ],\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should set spark arguments on the job",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with no bucket or path provided"
            ],
            "updatePoint": {
                "line": 373,
                "column": 51
            },
            "line": 373,
            "code": "        test('should set spark arguments on the job', () => {\n          Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n            DefaultArguments: {\n              '--enable-spark-ui': 'true',\n              '--spark-event-logs-path': {\n                'Fn::Join': [\n                  '',\n                  [\n                    's3://',\n                    {\n                      Ref: 'JobSparkUIBucket8E6A0139',\n                    },\n                  ],\n                ],\n              },\n            },\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should grant the role read/write permissions to the provided spark ui bucket",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with bucket provided"
            ],
            "updatePoint": {
                "line": 408,
                "column": 90
            },
            "line": 408,
            "code": "        test('should grant the role read/write permissions to the provided spark ui bucket', () => {\n          Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: [\n                    's3:GetObject*',\n                    's3:GetBucket*',\n                    's3:List*',\n                    's3:DeleteObject*',\n                    's3:PutObject',\n                    's3:PutObjectLegalHold',\n                    's3:PutObjectRetention',\n                    's3:PutObjectTagging',\n                    's3:PutObjectVersionTagging',\n                    's3:Abort*',\n                  ],\n                  Effect: 'Allow',\n                  Resource: [\n                    {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'arn:',\n                          {\n                            Ref: 'AWS::Partition',\n                          },\n                          ':s3:::sparkbucketname',\n                        ],\n                      ],\n                    },\n                    {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'arn:',\n                          {\n                            Ref: 'AWS::Partition',\n                          },\n                          ':s3:::sparkbucketname/*',\n                        ],\n                      ],\n                    },\n                  ],\n                },\n                codeBucketAccessStatement,\n              ],\n            },\n            Roles: [\n              {\n                Ref: 'JobServiceRole4F432993',\n              },\n            ],\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should set spark arguments on the job",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with bucket provided"
            ],
            "updatePoint": {
                "line": 464,
                "column": 51
            },
            "line": 464,
            "code": "        test('should set spark arguments on the job', () => {\n          Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n            DefaultArguments: {\n              '--enable-spark-ui': 'true',\n              '--spark-event-logs-path': `s3://${sparkUIBucketName}`,\n            },\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should set spark arguments on the job",
            "suites": [
                "Job",
                "new",
                "enabling spark ui",
                "with bucket and path provided"
            ],
            "updatePoint": {
                "line": 491,
                "column": 51
            },
            "line": 491,
            "code": "        test('should set spark arguments on the job', () => {\n          Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n            DefaultArguments: {\n              '--enable-spark-ui': 'true',\n              '--spark-event-logs-path': `s3://${sparkUIBucketName}/${prefix}`,\n            },\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "should synthesize correctly",
            "suites": [
                "Job",
                "new",
                "with extended props"
            ],
            "updatePoint": {
                "line": 527,
                "column": 39
            },
            "line": 527,
            "code": "      test('should synthesize correctly', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n          Command: {\n            Name: 'glueetl',\n            ScriptLocation: 's3://bucketname/script',\n          },\n          Role: {\n            'Fn::GetAtt': [\n              'JobServiceRole4F432993',\n              'Arn',\n            ],\n          },\n          DefaultArguments: {\n            '--job-language': 'scala',\n            '--class': 'com.amazon.test.ClassName',\n            '--enable-metrics': '',\n            'arg1': 'value1',\n            'arg2': 'value2',\n          },\n          Description: 'test job',\n          ExecutionProperty: {\n            MaxConcurrentRuns: 2,\n          },\n          GlueVersion: '2.0',\n          MaxRetries: 2,\n          Name: 'test-job',\n          NotificationProperty: {\n            NotifyDelayAfter: 1,\n          },\n          NumberOfWorkers: 10,\n          Tags: {\n            key: 'value',\n          },\n          Timeout: 5,\n          WorkerType: 'G.2X',\n          Connections: {\n            Connections: [\n              'ConnectionName',\n            ],\n          },\n          SecurityConfiguration: 'SecurityConfigurationName',\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with reserved args should throw",
            "suites": [
                "Job",
                "new",
                "with extended props"
            ],
            "updatePoint": {
                "line": 572,
                "column": 41
            },
            "line": 572,
            "code": "    test('with reserved args should throw', () => {\n      ['--debug', '--mode', '--JOB_NAME'].forEach((arg, index) => {\n        const defaultArguments: {[key: string]: string} = {};\n        defaultArguments[arg] = 'random value';\n\n        expect(() => new glue.Job(stack, `Job${index}`, {\n          executable: glue.JobExecutable.scalaEtl({\n            glueVersion: glue.GlueVersion.V2_0,\n            className,\n            script,\n          }),\n          defaultArguments,\n        })).toThrow(/argument is reserved by Glue/);\n      });\n    });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with unsupported glue version should throw",
            "suites": [
                "Job",
                "new",
                "shell job"
            ],
            "updatePoint": {
                "line": 589,
                "column": 54
            },
            "line": 589,
            "code": "      test('with unsupported glue version should throw', () => {\n        expect(() => new glue.Job(stack, 'Job', {\n          executable: glue.JobExecutable.pythonShell({\n            glueVersion: glue.GlueVersion.V0_9,\n            pythonVersion: glue.PythonVersion.TWO,\n            script,\n          }),\n        })).toThrow('Specified GlueVersion 0.9 does not support Python Shell');\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with unsupported Spark UI prop should throw",
            "suites": [
                "Job",
                "new",
                "shell job"
            ],
            "updatePoint": {
                "line": 599,
                "column": 55
            },
            "line": 599,
            "code": "      test('with unsupported Spark UI prop should throw', () => {\n        expect(() => new glue.Job(stack, 'Job', {\n          executable: glue.JobExecutable.pythonShell({\n            glueVersion: glue.GlueVersion.V1_0,\n            pythonVersion: glue.PythonVersion.THREE,\n            script,\n          }),\n          sparkUI: { enabled: true },\n        })).toThrow('Spark UI is not available for JobType.PYTHON_SHELL');\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with unsupported glue version should throw",
            "suites": [
                "Job",
                "new",
                "ray job"
            ],
            "updatePoint": {
                "line": 612,
                "column": 54
            },
            "line": 612,
            "code": "      test('with unsupported glue version should throw', () => {\n        expect(() => new glue.Job(stack, 'Job', {\n          executable: glue.JobExecutable.pythonRay({\n            glueVersion: glue.GlueVersion.V3_0,\n            pythonVersion: glue.PythonVersion.THREE_NINE,\n            script,\n          }),\n          workerType: glue.WorkerType.Z_2X,\n          workerCount: 2,\n        })).toThrow('Specified GlueVersion 3.0 does not support Ray');\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with unsupported Spark UI prop should throw",
            "suites": [
                "Job",
                "new",
                "ray job"
            ],
            "updatePoint": {
                "line": 624,
                "column": 55
            },
            "line": 624,
            "code": "      test('with unsupported Spark UI prop should throw', () => {\n        expect(() => new glue.Job(stack, 'Job', {\n          executable: glue.JobExecutable.pythonRay({\n            glueVersion: glue.GlueVersion.V4_0,\n            pythonVersion: glue.PythonVersion.THREE_NINE,\n            script,\n          }),\n          workerType: glue.WorkerType.Z_2X,\n          workerCount: 2,\n          sparkUI: { enabled: true },\n        })).toThrow('Spark UI is not available for JobType.RAY');\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "etl job with all props should synthesize correctly",
            "suites": [
                "Job",
                "new",
                "ray job"
            ],
            "updatePoint": {
                "line": 639,
                "column": 60
            },
            "line": 639,
            "code": "    test('etl job with all props should synthesize correctly', () => {\n      new glue.Job(stack, 'Job', {\n        executable: glue.JobExecutable.pythonEtl({\n          glueVersion: glue.GlueVersion.V2_0,\n          pythonVersion: glue.PythonVersion.THREE,\n          extraJarsFirst: true,\n          script,\n          extraPythonFiles,\n          extraJars,\n          extraFiles,\n        }),\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        GlueVersion: '2.0',\n        Command: {\n          Name: 'glueetl',\n          ScriptLocation: 's3://bucketname/script',\n          PythonVersion: '3',\n        },\n        Role: {\n          'Fn::GetAtt': [\n            'JobServiceRole4F432993',\n            'Arn',\n          ],\n        },\n        DefaultArguments: {\n          '--job-language': 'python',\n          '--extra-jars': 's3://bucketname/file1.jar,s3://bucketname/file2.jar',\n          '--extra-py-files': 's3://bucketname/file1.py,s3://bucketname/file2.py',\n          '--extra-files': 's3://bucketname/file1.txt,s3://bucketname/file2.txt',\n          '--user-jars-first': 'true',\n        },\n      });\n    });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "streaming job with all props should synthesize correctly",
            "suites": [
                "Job",
                "new",
                "ray job"
            ],
            "updatePoint": {
                "line": 675,
                "column": 66
            },
            "line": 675,
            "code": "    test('streaming job with all props should synthesize correctly', () => {\n      new glue.Job(stack, 'Job', {\n        executable: glue.JobExecutable.scalaStreaming({\n          glueVersion: glue.GlueVersion.V2_0,\n          extraJarsFirst: true,\n          className,\n          script,\n          extraJars,\n          extraFiles,\n        }),\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::Glue::Job', {\n        GlueVersion: '2.0',\n        Command: {\n          Name: 'gluestreaming',\n          ScriptLocation: 's3://bucketname/script',\n        },\n        Role: {\n          'Fn::GetAtt': [\n            'JobServiceRole4F432993',\n            'Arn',\n          ],\n        },\n        DefaultArguments: {\n          '--job-language': 'scala',\n          '--class': 'com.amazon.test.ClassName',\n          '--extra-jars': 's3://bucketname/file1.jar,s3://bucketname/file2.jar',\n          '--extra-files': 's3://bucketname/file1.txt,s3://bucketname/file2.txt',\n          '--user-jars-first': 'true',\n        },\n      });\n    });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": ".onEvent() should create the expected event rule",
            "suites": [
                "Job",
                "new",
                "event rules and rule-based metrics"
            ],
            "updatePoint": {
                "line": 720,
                "column": 60
            },
            "line": 720,
            "code": "      test('.onEvent() should create the expected event rule', () => {\n        job.onEvent('eventId', {});\n\n        Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n          EventPattern: {\n            'source': [\n              'aws.glue',\n            ],\n            'detail-type': [\n              'Glue Job State Change',\n              'Glue Job Run Status',\n            ],\n            'detail': {\n              jobName: [\n                {\n                  Ref: 'JobB9D00F9F',\n                },\n              ],\n            },\n          },\n          State: 'ENABLED',\n        });\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": " should create a rule with correct properties",
            "suites": [
                "Job",
                "new",
                "event rules and rule-based metrics"
            ],
            "updatePoint": {
                "line": 749,
                "column": 75
            },
            "line": 749,
            "code": "        test(`${testCase.name} should create a rule with correct properties`, () => {\n          testCase.invoke(job);\n\n          Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n            Description: {\n              'Fn::Join': [\n                '',\n                [\n                  'Rule triggered when Glue job ',\n                  {\n                    Ref: 'JobB9D00F9F',\n                  },\n                  ` is in ${testCase.state} state`,\n                ],\n              ],\n            },\n            EventPattern: {\n              'source': [\n                'aws.glue',\n              ],\n              'detail-type': [\n                'Glue Job State Change',\n                'Glue Job Run Status',\n              ],\n              'detail': {\n                state: [\n                  testCase.state,\n                ],\n                jobName: [\n                  {\n                    Ref: 'JobB9D00F9F',\n                  },\n                ],\n              },\n            },\n            State: 'ENABLED',\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": " should create the expected singleton event rule and corresponding metric",
            "suites": [
                "Job",
                "new",
                "event rules and rule-based metrics"
            ],
            "updatePoint": {
                "line": 794,
                "column": 103
            },
            "line": 794,
            "code": "        test(`${testCase.name} should create the expected singleton event rule and corresponding metric`, () => {\n          const metric = testCase.invoke(job);\n          testCase.invoke(job);\n\n          expect(metric).toEqual(new cloudwatch.Metric({\n            dimensionsMap: {\n              RuleName: (job.node.findChild(testCase.ruleId) as events.Rule).ruleName,\n            },\n            metricName: 'TriggeredRules',\n            namespace: 'AWS/Events',\n            statistic: 'Sum',\n          }));\n\n          Template.fromStack(stack).resourceCountIs('AWS::Events::Rule', 1);\n          Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n            Description: {\n              'Fn::Join': [\n                '',\n                [\n                  'Rule triggered when Glue job ',\n                  {\n                    Ref: 'JobB9D00F9F',\n                  },\n                  ` is in ${testCase.state} state`,\n                ],\n              ],\n            },\n            EventPattern: {\n              'source': [\n                'aws.glue',\n              ],\n              'detail-type': [\n                'Glue Job State Change',\n                'Glue Job Run Status',\n              ],\n              'detail': {\n                state: [\n                  testCase.state,\n                ],\n                jobName: [\n                  {\n                    Ref: 'JobB9D00F9F',\n                  },\n                ],\n              },\n            },\n            State: 'ENABLED',\n          });\n        });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with MetricType.COUNT should create a count sum metric",
            "suites": [
                "Job",
                "new",
                ".metric()"
            ],
            "updatePoint": {
                "line": 848,
                "column": 66
            },
            "line": 848,
            "code": "      test('with MetricType.COUNT should create a count sum metric', () => {\n        const metricName = 'glue.driver.aggregate.bytesRead';\n        const props = { statistic: cloudwatch.Statistic.SUM };\n\n        expect(job.metric(metricName, glue.MetricType.COUNT, props)).toEqual(new cloudwatch.Metric({\n          metricName,\n          statistic: 'Sum',\n          namespace: 'Glue',\n          dimensionsMap: {\n            JobName: job.jobName,\n            JobRunId: 'ALL',\n            Type: 'count',\n          },\n        }));\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "with MetricType.GAUGE should create a gauge average metric",
            "suites": [
                "Job",
                "new",
                ".metric()"
            ],
            "updatePoint": {
                "line": 864,
                "column": 70
            },
            "line": 864,
            "code": "      test('with MetricType.GAUGE should create a gauge average metric', () => {\n        const metricName = 'glue.driver.BlockManager.disk.diskSpaceUsed_MB';\n        const props = { statistic: cloudwatch.Statistic.AVERAGE };\n\n        expect(job.metric(metricName, glue.MetricType.GAUGE, props)).toEqual(new cloudwatch.Metric({\n          metricName,\n          statistic: 'Average',\n          namespace: 'Glue',\n          dimensionsMap: {\n            JobName: job.jobName,\n            JobRunId: 'ALL',\n            Type: 'gauge',\n          },\n        }));\n      });",
            "file": "job.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "boolean type",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 18
            },
            "line": 3,
            "code": "test('boolean type', () => {\n  expect(Schema.BOOLEAN.inputString).toEqual('boolean');\n  expect(Schema.BOOLEAN.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "binary type",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 17
            },
            "line": 8,
            "code": "test('binary type', () => {\n  expect(Schema.BINARY.inputString).toEqual('binary');\n  expect(Schema.BINARY.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "bigint type",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 17
            },
            "line": 13,
            "code": "test('bigint type', () => {\n  expect(Schema.BIG_INT.inputString).toEqual('bigint');\n  expect(Schema.BIG_INT.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "double type",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 17
            },
            "line": 18,
            "code": "test('double type', () => {\n  expect(Schema.DOUBLE.inputString).toEqual('double');\n  expect(Schema.DOUBLE.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "float type",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 16
            },
            "line": 23,
            "code": "test('float type', () => {\n  expect(Schema.FLOAT.inputString).toEqual('float');\n  expect(Schema.FLOAT.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "integer type",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 18
            },
            "line": 28,
            "code": "test('integer type', () => {\n  expect(Schema.INTEGER.inputString).toEqual('int');\n  expect(Schema.INTEGER.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "smallint type",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 19
            },
            "line": 33,
            "code": "test('smallint type', () => {\n  expect(Schema.SMALL_INT.inputString).toEqual('smallint');\n  expect(Schema.SMALL_INT.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "tinyint type",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 18
            },
            "line": 38,
            "code": "test('tinyint type', () => {\n  expect(Schema.TINY_INT.inputString).toEqual('tinyint');\n  expect(Schema.TINY_INT.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "decimal type",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 18
            },
            "line": 43,
            "code": "test('decimal type', () => {\n  expect(Schema.decimal(16).inputString).toEqual('decimal(16)');\n  expect(Schema.decimal(16, 1).inputString).toEqual('decimal(16,1)');\n  expect(Schema.decimal(16).isPrimitive).toEqual(true);\n  expect(Schema.decimal(16, 1).isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "date type",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 15
            },
            "line": 51,
            "code": "test('date type', () => {\n  expect(Schema.DATE.inputString).toEqual('date');\n  expect(Schema.DATE.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "timestamp type",
            "suites": [],
            "updatePoint": {
                "line": 56,
                "column": 20
            },
            "line": 56,
            "code": "test('timestamp type', () => {\n  expect(Schema.TIMESTAMP.inputString).toEqual('timestamp');\n  expect(Schema.TIMESTAMP.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "string type",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 17
            },
            "line": 61,
            "code": "test('string type', () => {\n  expect(Schema.STRING.inputString).toEqual('string');\n  expect(Schema.STRING.isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "char type",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 15
            },
            "line": 66,
            "code": "test('char type', () => {\n  expect(Schema.char(1).inputString).toEqual('char(1)');\n  expect(Schema.char(1).isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "char length must be test(at least 1",
            "suites": [],
            "updatePoint": {
                "line": 71,
                "column": 41
            },
            "line": 71,
            "code": "test('char length must be test(at least 1', () => {\n  expect(() => Schema.char(1)).not.toThrow();\n  expect(() => Schema.char(0)).toThrow();\n  expect(() => Schema.char(-1)).toThrow();\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "char length must test(be <= 255",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 37
            },
            "line": 77,
            "code": "test('char length must test(be <= 255', () => {\n  expect(() => Schema.char(255)).not.toThrow();\n  expect(() => Schema.char(256)).toThrow();\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "varchar type",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 18
            },
            "line": 82,
            "code": "test('varchar type', () => {\n  expect(Schema.varchar(1).inputString).toEqual('varchar(1)');\n  expect(Schema.varchar(1).isPrimitive).toEqual(true);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "varchar length must be test(at least 1",
            "suites": [],
            "updatePoint": {
                "line": 87,
                "column": 44
            },
            "line": 87,
            "code": "test('varchar length must be test(at least 1', () => {\n  expect(() => Schema.varchar(1)).not.toThrow();\n  expect(() => Schema.varchar(0)).toThrow();\n  expect(() => Schema.varchar(-1)).toThrow();\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "varchar length must test(be <= 65535",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 42
            },
            "line": 93,
            "code": "test('varchar length must test(be <= 65535', () => {\n  expect(() => Schema.varchar(65535)).not.toThrow();\n  expect(() => Schema.varchar(65536)).toThrow();\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "test(array<string>",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 24
            },
            "line": 98,
            "code": "test('test(array<string>', () => {\n  const type = Schema.array(Schema.STRING);\n  expect(type.inputString).toEqual('array<string>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "array<test(char(1)>",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 25
            },
            "line": 104,
            "code": "test('array<test(char(1)>', () => {\n  const type = Schema.array(Schema.char(1));\n  expect(type.inputString).toEqual('array<char(1)>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "test(array<array>",
            "suites": [],
            "updatePoint": {
                "line": 110,
                "column": 23
            },
            "line": 110,
            "code": "test('test(array<array>', () => {\n  const type = Schema.array(\n    Schema.array(Schema.STRING));\n  expect(type.inputString).toEqual('array<array<string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "test(array<map>",
            "suites": [],
            "updatePoint": {
                "line": 117,
                "column": 21
            },
            "line": 117,
            "code": "test('test(array<map>', () => {\n  const type = Schema.array(\n    Schema.map(Schema.STRING, Schema.STRING));\n  expect(type.inputString).toEqual('array<map<string,string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "test(array<struct>",
            "suites": [],
            "updatePoint": {
                "line": 124,
                "column": 24
            },
            "line": 124,
            "code": "test('test(array<struct>', () => {\n  const type = Schema.array(\n    Schema.struct([{\n      name: 'key',\n      type: Schema.STRING,\n    }]));\n  expect(type.inputString).toEqual('array<struct<key:string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<test(string,string>",
            "suites": [],
            "updatePoint": {
                "line": 134,
                "column": 29
            },
            "line": 134,
            "code": "test('map<test(string,string>', () => {\n  const type = Schema.map(\n    Schema.STRING,\n    Schema.STRING,\n  );\n  expect(type.inputString).toEqual('map<string,string>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<test(int,string>",
            "suites": [],
            "updatePoint": {
                "line": 143,
                "column": 26
            },
            "line": 143,
            "code": "test('map<test(int,string>', () => {\n  const type = Schema.map(\n    Schema.INTEGER,\n    Schema.STRING,\n  );\n  expect(type.inputString).toEqual('map<int,string>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<char(1),test(char(1)>",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 31
            },
            "line": 152,
            "code": "test('map<char(1),test(char(1)>', () => {\n  const type = Schema.map(\n    Schema.char(1),\n    Schema.char(1),\n  );\n  expect(type.inputString).toEqual('map<char(1),char(1)>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<test(string,array>",
            "suites": [],
            "updatePoint": {
                "line": 161,
                "column": 28
            },
            "line": 161,
            "code": "test('map<test(string,array>', () => {\n  const type = Schema.map(\n    Schema.char(1),\n    Schema.array(Schema.STRING),\n  );\n  expect(type.inputString).toEqual('map<char(1),array<string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<test(string,map>",
            "suites": [],
            "updatePoint": {
                "line": 170,
                "column": 26
            },
            "line": 170,
            "code": "test('map<test(string,map>', () => {\n  const type = Schema.map(\n    Schema.char(1),\n    Schema.map(\n      Schema.STRING,\n      Schema.STRING),\n  );\n  expect(type.inputString).toEqual('map<char(1),map<string,string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map<test(string,struct>",
            "suites": [],
            "updatePoint": {
                "line": 181,
                "column": 29
            },
            "line": 181,
            "code": "test('map<test(string,struct>', () => {\n  const type = Schema.map(\n    Schema.char(1),\n    Schema.struct([{\n      name: 'key',\n      type: Schema.STRING,\n    }]),\n  );\n  expect(type.inputString).toEqual('map<char(1),struct<key:string>>');\n  expect(type.isPrimitive).toEqual(false);\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "map throws if keyType is test(non-primitive",
            "suites": [],
            "updatePoint": {
                "line": 193,
                "column": 49
            },
            "line": 193,
            "code": "test('map throws if keyType is test(non-primitive', () => {\n  expect(() => Schema.map(\n    Schema.array(Schema.STRING),\n    Schema.STRING,\n  )).toThrow();\n  expect(() => Schema.map(\n    Schema.map(Schema.STRING, Schema.STRING),\n    Schema.STRING,\n  )).toThrow();\n  expect(() => Schema.map(\n    Schema.struct([{\n      name: 'key',\n      type: Schema.STRING,\n    }]),\n    Schema.STRING,\n  )).toThrow();\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "struct type",
            "suites": [],
            "updatePoint": {
                "line": 211,
                "column": 17
            },
            "line": 211,
            "code": "test('struct type', () => {\n  const type = Schema.struct([{\n    name: 'primitive',\n    type: Schema.STRING,\n  }, {\n    name: 'with_comment',\n    type: Schema.STRING,\n    comment: 'this has a comment',\n  }, {\n    name: 'array',\n    type: Schema.array(Schema.STRING),\n  }, {\n    name: 'map',\n    type: Schema.map(Schema.STRING, Schema.STRING),\n  }, {\n    name: 'nested_struct',\n    type: Schema.struct([{\n      name: 'nested',\n      type: Schema.STRING,\n      comment: 'nested comment',\n    }]),\n  }]);\n\n  expect(type.isPrimitive).toEqual(false);\n  expect(type.inputString).toEqual(\n    // eslint-disable-next-line max-len\n    'struct<primitive:string,with_comment:string COMMENT \\'this has a comment\\',array:array<string>,map:map<string,string>,nested_struct:struct<nested:string COMMENT \\'nested comment\\'>>',\n  );\n});",
            "file": "schema.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "throws when a security configuration has no encryption config",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 67
            },
            "line": 6,
            "code": "test('throws when a security configuration has no encryption config', () => {\n  const stack = new cdk.Stack();\n\n  expect(() => new glue.SecurityConfiguration(stack, 'SecurityConfiguration'))\n    .toThrowError(/One of cloudWatchEncryption, jobBookmarksEncryption or s3Encryption must be defined/);\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a security configuration with encryption configuration requiring kms key and providing an explicit one",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 108
            },
            "line": 13,
            "code": "test('a security configuration with encryption configuration requiring kms key and providing an explicit one', () => {\n  const stack = new cdk.Stack();\n  const keyArn = 'arn:aws:kms:us-west-2:111122223333:key/test-key';\n  const key = kms.Key.fromKeyArn(stack, 'ImportedKey', keyArn);\n\n  const securityConfiguration = new glue.SecurityConfiguration(stack, 'SecurityConfiguration', {\n    cloudWatchEncryption: {\n      mode: glue.CloudWatchEncryptionMode.KMS,\n      kmsKey: key,\n    },\n  });\n\n  expect(securityConfiguration.cloudWatchEncryptionKey?.keyArn).toEqual(keyArn);\n  expect(securityConfiguration.jobBookmarksEncryptionKey).toBeUndefined();\n  expect(securityConfiguration.s3EncryptionKey).toBeUndefined();\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::SecurityConfiguration', {\n    Name: 'SecurityConfiguration',\n    EncryptionConfiguration: {\n      CloudWatchEncryption: {\n        CloudWatchEncryptionMode: 'SSE-KMS',\n        KmsKeyArn: keyArn,\n      },\n    },\n  });\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a security configuration with an encryption configuration requiring kms key but not providing an explicit one",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 115
            },
            "line": 40,
            "code": "test('a security configuration with an encryption configuration requiring kms key but not providing an explicit one', () => {\n  const stack = new cdk.Stack();\n\n  const securityConfiguration = new glue.SecurityConfiguration(stack, 'SecurityConfiguration', {\n    cloudWatchEncryption: {\n      mode: glue.CloudWatchEncryptionMode.KMS,\n    },\n  });\n\n  expect(securityConfiguration.cloudWatchEncryptionKey).toBeDefined();\n  expect(securityConfiguration.jobBookmarksEncryptionKey).toBeUndefined();\n  expect(securityConfiguration.s3EncryptionKey).toBeUndefined();\n\n  Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::SecurityConfiguration', {\n    Name: 'SecurityConfiguration',\n    EncryptionConfiguration: {\n      CloudWatchEncryption: {\n        CloudWatchEncryptionMode: 'SSE-KMS',\n        KmsKeyArn: stack.resolve(securityConfiguration.cloudWatchEncryptionKey?.keyArn),\n      },\n    },\n  });\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "a security configuration with all encryption configs and mixed kms key inputs",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 83
            },
            "line": 66,
            "code": "test('a security configuration with all encryption configs and mixed kms key inputs', () => {\n  const stack = new cdk.Stack();\n  const keyArn = 'arn:aws:kms:us-west-2:111122223333:key/test-key';\n  const key = kms.Key.fromKeyArn(stack, 'ImportedKey', keyArn);\n\n  const securityConfiguration = new glue.SecurityConfiguration(stack, 'SecurityConfiguration', {\n    cloudWatchEncryption: {\n      mode: glue.CloudWatchEncryptionMode.KMS,\n    },\n    jobBookmarksEncryption: {\n      mode: glue.JobBookmarksEncryptionMode.CLIENT_SIDE_KMS,\n      kmsKey: key,\n    },\n    s3Encryption: {\n      mode: glue.S3EncryptionMode.S3_MANAGED,\n    },\n  });\n\n  expect(securityConfiguration.cloudWatchEncryptionKey).toBeDefined();\n  expect(securityConfiguration.jobBookmarksEncryptionKey?.keyArn).toEqual(keyArn);\n  expect(securityConfiguration.s3EncryptionKey).toBeUndefined();\n\n  Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::SecurityConfiguration', {\n    Name: 'SecurityConfiguration',\n    EncryptionConfiguration: {\n      CloudWatchEncryption: {\n        CloudWatchEncryptionMode: 'SSE-KMS',\n        // auto-created kms key\n        KmsKeyArn: stack.resolve(securityConfiguration.cloudWatchEncryptionKey?.keyArn),\n      },\n      JobBookmarksEncryption: {\n        JobBookmarksEncryptionMode: 'CSE-KMS',\n        // explicitly provided kms key\n        KmsKeyArn: keyArn,\n      },\n      S3Encryptions: [{\n        S3EncryptionMode: 'SSE-S3',\n      }],\n    },\n  });\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fromSecurityConfigurationName",
            "suites": [],
            "updatePoint": {
                "line": 110,
                "column": 35
            },
            "line": 110,
            "code": "test('fromSecurityConfigurationName', () => {\n  const stack = new cdk.Stack();\n  const name = 'name';\n\n  const securityConfiguration = glue.SecurityConfiguration.fromSecurityConfigurationName(stack, 'ImportedSecurityConfiguration', name);\n\n  expect(securityConfiguration.securityConfigurationName).toEqual(name);\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can specify a physical name",
            "suites": [],
            "updatePoint": {
                "line": 119,
                "column": 33
            },
            "line": 119,
            "code": "test('can specify a physical name', () => {\n  const stack = new cdk.Stack();\n  new glue.SecurityConfiguration(stack, 'SecurityConfiguration', {\n    securityConfigurationName: 'MySecurityConfiguration',\n    cloudWatchEncryption: {\n      mode: glue.CloudWatchEncryptionMode.KMS,\n    },\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::SecurityConfiguration', {\n    Name: 'MySecurityConfiguration',\n  });\n});",
            "file": "security-configuration.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "unpartitioned JSON table",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 30
            },
            "line": 10,
            "code": "test('unpartitioned JSON table', () => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const database = new glue.Database(dbStack, 'Database');\n\n  const tableStack = new cdk.Stack(app, 'table');\n  const table = new glue.Table(tableStack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.UNENCRYPTED);\n\n  Template.fromStack(tableStack).hasResource('AWS::S3::Bucket', {\n    Type: 'AWS::S3::Bucket',\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n\n  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Name: 'tabletable8fff2c2b',\n      Description: 'tabletable8fff2c2b generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "partitioned JSON table",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 28
            },
            "line": 78,
            "code": "test('partitioned JSON table', () => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const database = new glue.Database(dbStack, 'Database');\n\n  const tableStack = new cdk.Stack(app, 'table');\n  const table = new glue.Table(tableStack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    partitionKeys: [{\n      name: 'year',\n      type: glue.Schema.SMALL_INT,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.UNENCRYPTED);\n  expect(table.encryptionKey).toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Name: 'tabletable8fff2c2b',\n      Description: 'tabletable8fff2c2b generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      PartitionKeys: [\n        {\n          Name: 'year',\n          Type: 'smallint',\n        },\n      ],\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "compressed table",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 22
            },
            "line": 152,
            "code": "test('compressed table', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    compressed: true,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryptionKey).toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Name: 'table',\n      Description: 'table generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: true,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "table.node.defaultChild",
            "suites": [],
            "updatePoint": {
                "line": 214,
                "column": 29
            },
            "line": 214,
            "code": "test('table.node.defaultChild', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  // WHEN\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    compressed: true,\n    dataFormat: glue.DataFormat.JSON,\n  });\n\n  // THEN\n  expect(table.node.defaultChild instanceof CfnTable).toEqual(true);\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: SSE-S3",
            "suites": [],
            "updatePoint": {
                "line": 234,
                "column": 29
            },
            "line": 234,
            "code": "test('encrypted table: SSE-S3', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.S3_MANAGED,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.S3_MANAGED);\n  expect(table.encryptionKey).toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Name: 'table',\n      Description: 'table generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {\n    BucketEncryption: {\n      ServerSideEncryptionConfiguration: [\n        {\n          ServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'AES256',\n          },\n        },\n      ],\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: SSE-KMS (implicitly created key)",
            "suites": [],
            "updatePoint": {
                "line": 309,
                "column": 55
            },
            "line": 309,
            "code": "test('encrypted table: SSE-KMS (implicitly created key)', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.KMS,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.KMS);\n  expect(table.encryptionKey).toEqual(table.bucket.encryptionKey);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {\n    Description: 'Created by Default/Table/Bucket',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {\n    BucketEncryption: {\n      ServerSideEncryptionConfiguration: [\n        {\n          ServerSideEncryptionByDefault: {\n            KMSMasterKeyID: {\n              'Fn::GetAtt': [\n                'TableBucketKey3E9F984A',\n                'Arn',\n              ],\n            },\n            SSEAlgorithm: 'aws:kms',\n          },\n        },\n      ],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Name: 'table',\n      Description: 'table generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: SSE-KMS (explicitly created key)",
            "suites": [],
            "updatePoint": {
                "line": 393,
                "column": 55
            },
            "line": 393,
            "code": "test('encrypted table: SSE-KMS (explicitly created key)', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n  const encryptionKey = new kms.Key(stack, 'MyKey', {\n    description: 'OurKey',\n  });\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.KMS,\n    encryptionKey,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.KMS);\n  expect(table.encryptionKey).toEqual(table.bucket.encryptionKey);\n  expect(table.encryptionKey).not.toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {\n    Description: 'OurKey',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {\n    BucketEncryption: {\n      ServerSideEncryptionConfiguration: [\n        {\n          ServerSideEncryptionByDefault: {\n            KMSMasterKeyID: {\n              'Fn::GetAtt': [\n                'MyKey6AB29FA6',\n                'Arn',\n              ],\n            },\n            SSEAlgorithm: 'aws:kms',\n          },\n        },\n      ],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Description: 'table generated by CDK',\n      Name: 'table',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: SSE-KMS_MANAGED",
            "suites": [],
            "updatePoint": {
                "line": 482,
                "column": 38
            },
            "line": 482,
            "code": "test('encrypted table: SSE-KMS_MANAGED', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.KMS_MANAGED,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.KMS_MANAGED);\n  expect(table.encryptionKey).toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {\n    BucketEncryption: {\n      ServerSideEncryptionConfiguration: [\n        {\n          ServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'aws:kms',\n          },\n        },\n      ],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Name: 'table',\n      Description: 'table generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: CSE-KMS (implicitly created key)",
            "suites": [],
            "updatePoint": {
                "line": 557,
                "column": 55
            },
            "line": 557,
            "code": "test('encrypted table: CSE-KMS (implicitly created key)', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);\n  expect(table.encryptionKey).not.toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Description: 'table generated by CDK',\n      Name: 'table',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: CSE-KMS (explicitly created key)",
            "suites": [],
            "updatePoint": {
                "line": 622,
                "column": 55
            },
            "line": 622,
            "code": "test('encrypted table: CSE-KMS (explicitly created key)', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n  const encryptionKey = new kms.Key(stack, 'MyKey', {\n    description: 'MyKey',\n  });\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,\n    encryptionKey,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);\n  expect(table.encryptionKey).not.toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {\n    Description: 'MyKey',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Description: 'table generated by CDK',\n      Name: 'table',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'TableBucketDA42407C',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "encrypted table: CSE-KMS (explicitly passed bucket and key)",
            "suites": [],
            "updatePoint": {
                "line": 693,
                "column": 65
            },
            "line": 693,
            "code": "test('encrypted table: CSE-KMS (explicitly passed bucket and key)', () => {\n  const stack = new cdk.Stack();\n  const database = new glue.Database(stack, 'Database');\n  const bucket = new s3.Bucket(stack, 'Bucket');\n  const encryptionKey = new kms.Key(stack, 'MyKey', {\n    description: 'MyKey',\n  });\n\n  const table = new glue.Table(stack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    bucket,\n    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,\n    encryptionKey,\n    dataFormat: glue.DataFormat.JSON,\n  });\n  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);\n  expect(table.encryptionKey).not.toEqual(undefined);\n  expect(table.bucket.encryptionKey).toEqual(undefined);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {\n    Description: 'MyKey',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      Ref: 'DatabaseB269D8BB',\n    },\n    TableInput: {\n      Description: 'table generated by CDK',\n      Name: 'table',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: true,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'Bucket83908E77',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "explicit s3 bucket and prefix",
            "suites": [],
            "updatePoint": {
                "line": 766,
                "column": 35
            },
            "line": 766,
            "code": "test('explicit s3 bucket and prefix', () => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const stack = new cdk.Stack(app, 'app');\n  const bucket = new s3.Bucket(stack, 'ExplicitBucket');\n  const database = new glue.Database(dbStack, 'Database');\n\n  new glue.Table(stack, 'Table', {\n    database,\n    bucket,\n    s3Prefix: 'prefix/',\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Description: 'apptablecb9c398f generated by CDK',\n      Name: 'apptablecb9c398f',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'ExplicitBucket0AA51A3F',\n              },\n              '/prefix/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "explicit s3 bucket and with empty prefix",
            "suites": [],
            "updatePoint": {
                "line": 830,
                "column": 46
            },
            "line": 830,
            "code": "test('explicit s3 bucket and with empty prefix', () => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const stack = new cdk.Stack(app, 'app');\n  const bucket = new s3.Bucket(stack, 'ExplicitBucket');\n  const database = new glue.Database(dbStack, 'Database');\n\n  new glue.Table(stack, 'Table', {\n    database,\n    bucket,\n    s3Prefix: '',\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Description: 'apptablecb9c398f generated by CDK',\n      Name: 'apptablecb9c398f',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      StorageDescriptor: {\n        Columns: [\n          {\n            Name: 'col',\n            Type: 'string',\n          },\n        ],\n        Compressed: false,\n        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',\n        Location: {\n          'Fn::Join': [\n            '',\n            [\n              's3://',\n              {\n                Ref: 'ExplicitBucket0AA51A3F',\n              },\n              '/',\n            ],\n          ],\n        },\n        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',\n        SerdeInfo: {\n          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',\n        },\n        StoredAsSubDirectories: false,\n      },\n      TableType: 'EXTERNAL_TABLE',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fails if no partition keys",
            "suites": [
                "add partition index"
            ],
            "updatePoint": {
                "line": 895,
                "column": 34
            },
            "line": 895,
            "code": "  test('fails if no partition keys', () => {\n    const stack = new cdk.Stack();\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    expect(() => table.addPartitionIndex({\n      indexName: 'my-part',\n      keyNames: ['part'],\n    })).toThrowError(/The table must have partition keys to create a partition index/);\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fails if partition index does not match partition keys",
            "suites": [
                "add partition index"
            ],
            "updatePoint": {
                "line": 914,
                "column": 62
            },
            "line": 914,
            "code": "  test('fails if partition index does not match partition keys', () => {\n    const stack = new cdk.Stack();\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      partitionKeys: [{\n        name: 'part',\n        type: glue.Schema.SMALL_INT,\n      }],\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    expect(() => table.addPartitionIndex({\n      indexName: 'my-part',\n      keyNames: ['not-part'],\n    })).toThrowError(/All index keys must also be partition keys/);\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fails with index name < 1 character",
            "suites": [
                "add partition index"
            ],
            "updatePoint": {
                "line": 937,
                "column": 43
            },
            "line": 937,
            "code": "  test('fails with index name < 1 character', () => {\n    const stack = new cdk.Stack();\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      partitionKeys: [{\n        name: 'part',\n        type: glue.Schema.SMALL_INT,\n      }],\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    expect(() => table.addPartitionIndex({\n      indexName: '',\n      keyNames: ['part'],\n    })).toThrowError(/Index name must be between 1 and 255 characters, but got 0/);\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "fails with > 3 indexes",
            "suites": [
                "add partition index"
            ],
            "updatePoint": {
                "line": 960,
                "column": 30
            },
            "line": 960,
            "code": "  test('fails with > 3 indexes', () => {\n    const stack = new cdk.Stack();\n    const database = new glue.Database(stack, 'Database');\n\n    const indexes: PartitionIndex[] = [{\n      indexName: 'ind1',\n      keyNames: ['part'],\n    }, {\n      indexName: 'ind2',\n      keyNames: ['part'],\n    }, {\n      indexName: 'ind3',\n      keyNames: ['part'],\n    }, {\n      indexName: 'ind4',\n      keyNames: ['part'],\n    }];\n\n    expect(() => new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      partitionKeys: [{\n        name: 'part',\n        type: glue.Schema.SMALL_INT,\n      }],\n      partitionIndexes: indexes,\n      dataFormat: glue.DataFormat.JSON,\n    })).toThrowError('Maximum number of partition indexes allowed is 3');\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "custom permissions",
            "suites": [
                "grants"
            ],
            "updatePoint": {
                "line": 995,
                "column": 26
            },
            "line": 995,
            "code": "  test('custom permissions', () => {\n    const stack = new cdk.Stack();\n    const user = new iam.User(stack, 'User');\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      compressed: true,\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    table.grant(user, ['glue:UpdateTable']);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: 'glue:UpdateTable',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':glue:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':table/',\n                  {\n                    Ref: 'DatabaseB269D8BB',\n                  },\n                  '/',\n                  {\n                    Ref: 'Table4C2D914F',\n                  },\n                ],\n              ],\n            },\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      PolicyName: 'UserDefaultPolicy1F97781E',\n      Users: [\n        {\n          Ref: 'User00B015A1',\n        },\n      ],\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "read only",
            "suites": [
                "grants"
            ],
            "updatePoint": {
                "line": 1058,
                "column": 17
            },
            "line": 1058,
            "code": "  test('read only', () => {\n    const stack = new cdk.Stack();\n    const user = new iam.User(stack, 'User');\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      compressed: true,\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    table.grantRead(user);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: [\n              'glue:BatchGetPartition',\n              'glue:GetPartition',\n              'glue:GetPartitions',\n              'glue:GetTable',\n              'glue:GetTables',\n              'glue:GetTableVersion',\n              'glue:GetTableVersions',\n            ],\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':glue:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':table/',\n                  {\n                    Ref: 'DatabaseB269D8BB',\n                  },\n                  '/',\n                  {\n                    Ref: 'Table4C2D914F',\n                  },\n                ],\n              ],\n            },\n          },\n          {\n            Action: [\n              's3:GetObject*',\n              's3:GetBucket*',\n              's3:List*',\n            ],\n            Effect: 'Allow',\n            Resource: [\n              {\n                'Fn::GetAtt': [\n                  'TableBucketDA42407C',\n                  'Arn',\n                ],\n              },\n              {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      'Fn::GetAtt': [\n                        'TableBucketDA42407C',\n                        'Arn',\n                      ],\n                    },\n                    '/*',\n                  ],\n                ],\n              },\n            ],\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      PolicyName: 'UserDefaultPolicy1F97781E',\n      Users: [\n        {\n          Ref: 'User00B015A1',\n        },\n      ],\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "write only",
            "suites": [
                "grants"
            ],
            "updatePoint": {
                "line": 1159,
                "column": 18
            },
            "line": 1159,
            "code": "  test('write only', () => {\n    const stack = new cdk.Stack();\n    const user = new iam.User(stack, 'User');\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      compressed: true,\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    table.grantWrite(user);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: [\n              'glue:BatchCreatePartition',\n              'glue:BatchDeletePartition',\n              'glue:CreatePartition',\n              'glue:DeletePartition',\n              'glue:UpdatePartition',\n            ],\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':glue:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':table/',\n                  {\n                    Ref: 'DatabaseB269D8BB',\n                  },\n                  '/',\n                  {\n                    Ref: 'Table4C2D914F',\n                  },\n                ],\n              ],\n            },\n          },\n          {\n            Action: [\n              's3:DeleteObject*',\n              's3:PutObject',\n              's3:PutObjectLegalHold',\n              's3:PutObjectRetention',\n              's3:PutObjectTagging',\n              's3:PutObjectVersionTagging',\n              's3:Abort*',\n            ],\n            Effect: 'Allow',\n            Resource: [\n              {\n                'Fn::GetAtt': [\n                  'TableBucketDA42407C',\n                  'Arn',\n                ],\n              },\n              {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      'Fn::GetAtt': [\n                        'TableBucketDA42407C',\n                        'Arn',\n                      ],\n                    },\n                    '/*',\n                  ],\n                ],\n              },\n            ],\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      PolicyName: 'UserDefaultPolicy1F97781E',\n      Users: [\n        {\n          Ref: 'User00B015A1',\n        },\n      ],\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "read and write",
            "suites": [
                "grants"
            ],
            "updatePoint": {
                "line": 1262,
                "column": 22
            },
            "line": 1262,
            "code": "  test('read and write', () => {\n    const stack = new cdk.Stack();\n    const user = new iam.User(stack, 'User');\n    const database = new glue.Database(stack, 'Database');\n\n    const table = new glue.Table(stack, 'Table', {\n      database,\n      columns: [{\n        name: 'col',\n        type: glue.Schema.STRING,\n      }],\n      compressed: true,\n      dataFormat: glue.DataFormat.JSON,\n    });\n\n    table.grantReadWrite(user);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: [\n              'glue:BatchGetPartition',\n              'glue:GetPartition',\n              'glue:GetPartitions',\n              'glue:GetTable',\n              'glue:GetTables',\n              'glue:GetTableVersion',\n              'glue:GetTableVersions',\n              'glue:BatchCreatePartition',\n              'glue:BatchDeletePartition',\n              'glue:CreatePartition',\n              'glue:DeletePartition',\n              'glue:UpdatePartition',\n            ],\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':glue:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':table/',\n                  {\n                    Ref: 'DatabaseB269D8BB',\n                  },\n                  '/',\n                  {\n                    Ref: 'Table4C2D914F',\n                  },\n                ],\n              ],\n            },\n          },\n          {\n            Action: [\n              's3:GetObject*',\n              's3:GetBucket*',\n              's3:List*',\n              's3:DeleteObject*',\n              's3:PutObject',\n              's3:PutObjectLegalHold',\n              's3:PutObjectRetention',\n              's3:PutObjectTagging',\n              's3:PutObjectVersionTagging',\n              's3:Abort*',\n            ],\n            Effect: 'Allow',\n            Resource: [\n              {\n                'Fn::GetAtt': [\n                  'TableBucketDA42407C',\n                  'Arn',\n                ],\n              },\n              {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      'Fn::GetAtt': [\n                        'TableBucketDA42407C',\n                        'Arn',\n                      ],\n                    },\n                    '/*',\n                  ],\n                ],\n              },\n            ],\n          },\n        ],\n        Version: '2012-10-17',\n      },\n      PolicyName: 'UserDefaultPolicy1F97781E',\n      Users: [\n        {\n          Ref: 'User00B015A1',\n        },\n      ],\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "at least one column",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1377,
                "column": 27
            },
            "line": 1377,
            "code": "  test('at least one column', () => {\n    expect(() => {\n      createTable({\n        columns: [],\n      });\n    }).toThrowError('you must specify at least one column for the table');\n\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "unique column names",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1386,
                "column": 27
            },
            "line": 1386,
            "code": "  test('unique column names', () => {\n    expect(() => {\n      createTable({\n        columns: [{\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }, {\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }],\n      });\n    }).toThrowError(\"column names and partition keys must be unique, but 'col1' is duplicated\");\n\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "unique partition keys",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1401,
                "column": 29
            },
            "line": 1401,
            "code": "  test('unique partition keys', () => {\n    expect(() => {\n      createTable({\n        columns: [{\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }],\n        partitionKeys: [{\n          name: 'p1',\n          type: glue.Schema.STRING,\n        }, {\n          name: 'p1',\n          type: glue.Schema.STRING,\n        }],\n      });\n    }).toThrowError(\"column names and partition keys must be unique, but 'p1' is duplicated\");\n\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "column names and partition keys are all unique",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1420,
                "column": 54
            },
            "line": 1420,
            "code": "  test('column names and partition keys are all unique', () => {\n    expect(() => {\n      createTable({\n        columns: [{\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }],\n        partitionKeys: [{\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }],\n      });\n    }).toThrowError(\"column names and partition keys must be unique, but 'col1' is duplicated\");\n\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can not specify an explicit bucket and encryption",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1436,
                "column": 57
            },
            "line": 1436,
            "code": "  test('can not specify an explicit bucket and encryption', () => {\n    expect(() => {\n      createTable({\n        columns: [{\n          name: 'col1',\n          type: glue.Schema.STRING,\n        }],\n        bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),\n        encryption: glue.TableEncryption.KMS,\n      });\n    }).toThrowError('you can not specify encryption settings if you also provide a bucket');\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can explicitly pass bucket if Encryption undefined",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1449,
                "column": 58
            },
            "line": 1449,
            "code": "  test('can explicitly pass bucket if Encryption undefined', () => {\n    expect(() => createTable({\n      columns: [{\n        name: 'col1',\n        type: glue.Schema.STRING,\n      }],\n      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),\n      encryption: undefined,\n    })).not.toThrow();\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can explicitly pass bucket if Unencrypted",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1460,
                "column": 49
            },
            "line": 1460,
            "code": "  test('can explicitly pass bucket if Unencrypted', () => {\n    expect(() => createTable({\n      columns: [{\n        name: 'col1',\n        type: glue.Schema.STRING,\n      }],\n      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),\n      encryption: undefined,\n    })).not.toThrow();\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can explicitly pass bucket if ClientSideKms",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1471,
                "column": 51
            },
            "line": 1471,
            "code": "  test('can explicitly pass bucket if ClientSideKms', () => {\n    expect(() => createTable({\n      columns: [{\n        name: 'col1',\n        type: glue.Schema.STRING,\n      }],\n      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),\n      encryption: glue.TableEncryption.CLIENT_SIDE_KMS,\n    })).not.toThrow();\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "Table.fromTableArn",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1483,
                "column": 24
            },
            "line": 1483,
            "code": "test('Table.fromTableArn', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n\n  // WHEN\n  const table = glue.Table.fromTableArn(stack, 'boom', 'arn:aws:glue:us-east-1:123456789012:table/db1/tbl1');\n\n  // THEN\n  expect(table.tableArn).toEqual('arn:aws:glue:us-east-1:123456789012:table/db1/tbl1');\n  expect(table.tableName).toEqual('tbl1');\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "Partition filtering on table %s",
            "suites": [
                "validate"
            ],
            "line": 1495,
            "code": "test.each([\n  ['enabled', true],\n  ['disabled', false],\n])('Partition filtering on table %s', (_, enabled) => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const database = new glue.Database(dbStack, 'Database');\n\n  const tableStack = new cdk.Stack(app, 'table');\n  new glue.Table(tableStack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    partitionKeys: [{\n      name: 'year',\n      type: glue.Schema.SMALL_INT,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n    enablePartitionFiltering: enabled,\n  });\n\n  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Name: 'tabletable8fff2c2b',\n      Description: 'tabletable8fff2c2b generated by CDK',\n      Parameters: {\n        'classification': 'json',\n        'has_encrypted_data': false,\n        'partition_filtering.enabled': enabled,\n      },\n      PartitionKeys: Match.anyValue(),\n      StorageDescriptor: Match.anyValue(),\n      TableType: Match.anyValue(),\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "Partition filtering on table is not defined (default behavior)",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1540,
                "column": 68
            },
            "line": 1540,
            "code": "test('Partition filtering on table is not defined (default behavior)', () => {\n  const app = new cdk.App();\n  const dbStack = new cdk.Stack(app, 'db');\n  const database = new glue.Database(dbStack, 'Database');\n\n  const tableStack = new cdk.Stack(app, 'table');\n  new glue.Table(tableStack, 'Table', {\n    database,\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    partitionKeys: [{\n      name: 'year',\n      type: glue.Schema.SMALL_INT,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n    enablePartitionFiltering: undefined,\n  });\n\n  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {\n    CatalogId: {\n      Ref: 'AWS::AccountId',\n    },\n    DatabaseName: {\n      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',\n    },\n    TableInput: {\n      Name: 'tabletable8fff2c2b',\n      Description: 'tabletable8fff2c2b generated by CDK',\n      Parameters: {\n        classification: 'json',\n        has_encrypted_data: false,\n      },\n      PartitionKeys: Match.anyValue(),\n      StorageDescriptor: Match.anyValue(),\n      TableType: Match.anyValue(),\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "can specify a physical name",
            "suites": [
                "validate"
            ],
            "updatePoint": {
                "line": 1581,
                "column": 33
            },
            "line": 1581,
            "code": "test('can specify a physical name', () => {\n  const app = new cdk.App();\n  const stack = new cdk.Stack(app, 'Stack');\n  const database = new glue.Database(stack, 'Database');\n  new glue.Table(stack, 'Table', {\n    database,\n    tableName: 'my_table',\n    columns: [{\n      name: 'col',\n      type: glue.Schema.STRING,\n    }],\n    dataFormat: glue.DataFormat.JSON,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {\n    TableInput: {\n      Name: 'my_table',\n      Description: 'my_table generated by CDK',\n    },\n  });\n});",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-glue/test"
        },
        {
            "name": "Default cloudwatch logs action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 36,
                "index": 306
            },
            "line": 7,
            "code": "test('Default cloudwatch logs action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const logGroup = logs.LogGroup.fromLogGroupArn(stack, 'my-log-group', 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group');\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchLogsAction(logGroup));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        CloudwatchLogs: {\n          LogGroupName: 'my-log-group',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: ['logs:CreateLogStream', 'logs:PutLogEvents'],\n        Effect: 'Allow',\n        Resource: 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group:*'\n      }, {\n        Action: 'logs:DescribeLogStreams',\n        Effect: 'Allow',\n        Resource: 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group:*'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "cloudwatch/cloudwatch-logs-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 18,
                "index": 2034
            },
            "line": 62,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const logGroup = logs.LogGroup.fromLogGroupArn(stack, 'my-log-group', 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchLogsAction(logGroup, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        CloudwatchLogs: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "cloudwatch/cloudwatch-logs-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "When multiple actions are omitted role property, the actions use same one role",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 84,
                "index": 3071
            },
            "line": 91,
            "code": "test('When multiple actions are omitted role property, the actions use same one role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const logGroup1 = logs.LogGroup.fromLogGroupArn(stack, 'my-log-group1', 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group1');\n  const logGroup2 = logs.LogGroup.fromLogGroupArn(stack, 'my-log-group2', 'arn:aws:logs:us-east-1:123456789012:log-group:my-log-group2');\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchLogsAction(logGroup1));\n  topicRule.addAction(new actions.CloudWatchLogsAction(logGroup2));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        CloudwatchLogs: {\n          LogGroupName: 'my-log-group1',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }, {\n        CloudwatchLogs: {\n          LogGroupName: 'my-log-group2',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n});",
            "file": "cloudwatch/cloudwatch-logs-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default cloudwatch metric action",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 38,
                "index": 262
            },
            "line": 6,
            "code": "test('Default cloudwatch metric action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, namespace, unit, value, timestamp FROM 'device/+/data'\")\n  });\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchPutMetricAction({\n    metricName: '${topic(2)}',\n    metricNamespace: '${namespace}',\n    metricUnit: '${unit}',\n    metricValue: '${value}'\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        CloudwatchMetric: {\n          MetricName: '${topic(2)}',\n          MetricNamespace: '${namespace}',\n          MetricUnit: '${unit}',\n          MetricValue: '${value}',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'cloudwatch:PutMetricData',\n        Effect: 'Allow',\n        Resource: '*'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "cloudwatch/cloudwatch-put-metric-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set timestamp",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 23,
                "index": 1892
            },
            "line": 64,
            "code": "test('can set timestamp', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, namespace, unit, value, timestamp FROM 'device/+/data'\")\n  });\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchPutMetricAction({\n    metricName: '${topic(2)}',\n    metricNamespace: '${namespace}',\n    metricUnit: '${unit}',\n    metricValue: '${value}',\n    metricTimestamp: '${timestamp()}'\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        CloudwatchMetric: {\n          MetricTimestamp: '${timestamp()}'\n        }\n      })]\n    }\n  });\n});",
            "file": "cloudwatch/cloudwatch-put-metric-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 18,
                "index": 2660
            },
            "line": 91,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, namespace, unit, value, timestamp FROM 'device/+/data'\")\n  });\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.CloudWatchPutMetricAction({\n    metricName: '${topic(2)}',\n    metricNamespace: '${namespace}',\n    metricUnit: '${unit}',\n    metricValue: '${value}',\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        CloudwatchMetric: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "cloudwatch/cloudwatch-put-metric-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default cloudwatch alarm action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 37,
                "index": 319
            },
            "line": 7,
            "code": "test('Default cloudwatch alarm action', () => {\n  // Given\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, stateReason, stateValue FROM 'device/+/data'\")\n  });\n  const alarm = cloudwatch.Alarm.fromAlarmArn(stack, 'MyAlarm', 'arn:aws:cloudwatch:us-east-1:123456789012:alarm:MyAlarm');\n\n  // When\n  topicRule.addAction(new actions.CloudWatchSetAlarmStateAction(alarm, {\n    reason: 'Test reason',\n    alarmStateToSet: cloudwatch.AlarmState.ALARM\n  }));\n\n  // Then\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        CloudwatchAlarm: {\n          AlarmName: 'MyAlarm',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          },\n          StateReason: 'Test reason',\n          StateValue: cloudwatch.AlarmState.ALARM\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'cloudwatch:SetAlarmState',\n        Effect: 'Allow',\n        Resource: alarm.alarmArn\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "cloudwatch/cloudwatch-set-alarm-state-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 18,
                "index": 2005
            },
            "line": 63,
            "code": "test('can set role', () => {\n  // Given\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, stateReason, stateValue FROM 'device/+/data'\")\n  });\n\n  // When\n  topicRule.addAction(new actions.CloudWatchSetAlarmStateAction(cloudwatch.Alarm.fromAlarmArn(stack, 'MyAlarm', 'arn:aws:cloudwatch:us-east-1:123456789012:alarm:MyAlarm'), {\n    reason: '${stateReason}',\n    alarmStateToSet: cloudwatch.AlarmState.ALARM,\n    role: iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest')\n  }));\n\n  // Then\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        CloudwatchAlarm: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "cloudwatch/cloudwatch-set-alarm-state-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "set default reason",
            "suites": [],
            "updatePoint": {
                "line": 92,
                "column": 24,
                "index": 3045
            },
            "line": 92,
            "code": "test('set default reason', () => {\n  // Given\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id, stateReason, stateValue FROM 'device/+/data'\")\n  });\n  const alarm = cloudwatch.Alarm.fromAlarmArn(stack, 'MyAlarm', 'arn:aws:cloudwatch:us-east-1:123456789012:alarm:MyAlarm');\n\n  // When\n  topicRule.addAction(new actions.CloudWatchSetAlarmStateAction(alarm, {\n    alarmStateToSet: cloudwatch.AlarmState.ALARM\n  }));\n\n  // Then\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        CloudwatchAlarm: {\n          AlarmName: 'MyAlarm',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          },\n          StateReason: \"Set state of 'MyAlarm' to 'ALARM'\",\n          StateValue: cloudwatch.AlarmState.ALARM\n        }\n      }]\n    }\n  });\n});",
            "file": "cloudwatch/cloudwatch-set-alarm-state-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default dynamoDBv2 action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 31,
                "index": 309
            },
            "line": 7,
            "code": "test('Default dynamoDBv2 action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const table = dynamodb.Table.fromTableArn(stack, 'MyTable', 'arn:aws:dynamodb:xx-west-1:111122223333:table/my-table');\n\n  // WHEN\n  topicRule.addAction(new actions.DynamoDBv2PutItemAction(table));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        DynamoDBv2: {\n          PutItem: {\n            TableName: 'my-table'\n          },\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'dynamodb:PutItem',\n        Effect: 'Allow',\n        Resource: 'arn:aws:dynamodb:xx-west-1:111122223333:table/my-table'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "dynamodbv2/dynamodbv2-put-item-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 18,
                "index": 1854
            },
            "line": 60,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const table = dynamodb.Table.fromTableArn(stack, 'MyTable', 'arn:aws:dynamodb:xx-west-1:111122223333:table/my-table');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.DynamoDBv2PutItemAction(table, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        DynamoDBv2: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "dynamodbv2/dynamodbv2-put-item-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default IoT republish action",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 34,
                "index": 493
            },
            "line": 14,
            "code": "test('Default IoT republish action', () => {\n  // WHEN\n  topicRule.addAction(new actions.IotRepublishMqttAction('test-topic'));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Republish: {\n          Topic: 'test-topic',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'iot:Publish',\n        Effect: 'Allow',\n        Resource: '*'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "iot/iot-republish-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set qualityOfService",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 30,
                "index": 1629
            },
            "line": 58,
            "code": "test('can set qualityOfService', () => {\n  // WHEN\n  topicRule.addAction(new actions.IotRepublishMqttAction('test-topic', {\n    qualityOfService: actions.MqttQualityOfService.AT_LEAST_ONCE\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Republish: {\n          Qos: 1\n        }\n      })]\n    }\n  });\n});",
            "file": "iot/iot-republish-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 18,
                "index": 2032
            },
            "line": 75,
            "code": "test('can set role', () => {\n  // WHEN\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n  topicRule.addAction(new actions.IotRepublishMqttAction('test-topic', {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Republish: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "iot/iot-republish-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default IoT Events input action",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 37,
                "index": 630
            },
            "line": 17,
            "code": "test('Default IoT Events input action', () => {\n  // WHEN\n  topicRule.addAction(new actions.IotEventsPutMessageAction(input));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        IotEvents: {\n          InputName: 'my_input',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'iotevents:BatchPutMessage',\n        Effect: 'Allow',\n        Resource: {\n          'Fn::Join': ['', ['arn:', {\n            Ref: 'AWS::Partition'\n          }, ':iotevents:', {\n            Ref: 'AWS::Region'\n          }, ':', {\n            Ref: 'AWS::AccountId'\n          }, ':input/my_input']]\n        }\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "iot/iotevents-put-message-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set batchMode",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 23,
                "index": 1999
            },
            "line": 69,
            "code": "test('can set batchMode', () => {\n  // WHEN\n  topicRule.addAction(new actions.IotEventsPutMessageAction(input, {\n    batchMode: true\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        IotEvents: {\n          BatchMode: true\n        }\n      }]\n    }\n  });\n});",
            "file": "iot/iotevents-put-message-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set messageId",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 23,
                "index": 2349
            },
            "line": 86,
            "code": "test('can set messageId', () => {\n  // WHEN\n  topicRule.addAction(new actions.IotEventsPutMessageAction(input, {\n    messageId: '${topic()}-${timestamp()}'\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        IotEvents: {\n          MessageId: '${topic()}-${timestamp()}'\n        }\n      }]\n    }\n  });\n});",
            "file": "iot/iotevents-put-message-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 103,
                "column": 18,
                "index": 2740
            },
            "line": 103,
            "code": "test('can set role', () => {\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.IotEventsPutMessageAction(input, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        IotEvents: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "iot/iotevents-put-message-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "cannot set both batchMode and messageId",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 45,
                "index": 3373
            },
            "line": 126,
            "code": "test('cannot set both batchMode and messageId', () => {\n  expect(() => {\n    new actions.IotEventsPutMessageAction(input, {\n      batchMode: true,\n      messageId: '${topic()}-${timestamp()}'\n    });\n  }).toThrow('messageId is not allowed when batchMode is true');\n});",
            "file": "iot/iotevents-put-message-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default firehose stream action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 36,
                "index": 324
            },
            "line": 7,
            "code": "test('Default firehose stream action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = firehose.DeliveryStream.fromDeliveryStreamArn(stack, 'MyStream', 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/my-stream');\n\n  // WHEN\n  topicRule.addAction(new actions.FirehosePutRecordAction(stream));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Firehose: {\n          DeliveryStreamName: 'my-stream',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: ['firehose:PutRecord', 'firehose:PutRecordBatch'],\n        Effect: 'Allow',\n        Resource: 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/my-stream'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "kinesis-firehose/firehose-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set batchMode",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 23,
                "index": 1919
            },
            "line": 58,
            "code": "test('can set batchMode', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = firehose.DeliveryStream.fromDeliveryStreamArn(stack, 'MyStream', 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/my-stream');\n\n  // WHEN\n  topicRule.addAction(new actions.FirehosePutRecordAction(stream, {\n    batchMode: true\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Firehose: {\n          BatchMode: true\n        }\n      })]\n    }\n  });\n});",
            "file": "kinesis-firehose/firehose-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set separotor",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 23,
                "index": 2646
            },
            "line": 82,
            "code": "test('can set separotor', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = firehose.DeliveryStream.fromDeliveryStreamArn(stack, 'MyStream', 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/my-stream');\n\n  // WHEN\n  topicRule.addAction(new actions.FirehosePutRecordAction(stream, {\n    recordSeparator: actions.FirehoseRecordSeparator.NEWLINE\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Firehose: {\n          Separator: '\\n'\n        }\n      })]\n    }\n  });\n});",
            "file": "kinesis-firehose/firehose-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 18,
                "index": 3409
            },
            "line": 106,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = firehose.DeliveryStream.fromDeliveryStreamArn(stack, 'MyStream', 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/my-stream');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.FirehosePutRecordAction(stream, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Firehose: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "kinesis-firehose/firehose-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default kinesis stream action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 35,
                "index": 311
            },
            "line": 7,
            "code": "test('Default kinesis stream action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = kinesis.Stream.fromStreamArn(stack, 'MyStream', 'arn:aws:kinesis:xx-west-1:111122223333:stream/my-stream');\n\n  // WHEN\n  topicRule.addAction(new actions.KinesisPutRecordAction(stream, {\n    partitionKey: '${newuuid()}'\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Kinesis: {\n          StreamName: 'my-stream',\n          PartitionKey: '${newuuid()}',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'kinesis:PutRecord',\n        Effect: 'Allow',\n        Resource: 'arn:aws:kinesis:xx-west-1:111122223333:stream/my-stream'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "kinesis-stream/kinesis-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "passes undefined to partitionKey if empty string is given",
            "suites": [],
            "updatePoint": {
                "line": 61,
                "column": 63,
                "index": 1951
            },
            "line": 61,
            "code": "test('passes undefined to partitionKey if empty string is given', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = kinesis.Stream.fromStreamArn(stack, 'MyStream', 'arn:aws:kinesis:xx-west-1:111122223333:stream/my-stream');\n\n  // WHEN\n  topicRule.addAction(new actions.KinesisPutRecordAction(stream, {\n    partitionKey: ''\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Kinesis: {\n          PartitionKey: Match.absent()\n        }\n      })]\n    }\n  });\n});",
            "file": "kinesis-stream/kinesis-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 85,
                "column": 18,
                "index": 2659
            },
            "line": 85,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const stream = kinesis.Stream.fromStreamArn(stack, 'MyStream', 'arn:aws:kinesis:xx-west-1:111122223333:stream/my-stream');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.KinesisPutRecordAction(stream, {\n    partitionKey: '${newuuid()}',\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Kinesis: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "kinesis-stream/kinesis-put-record-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "create a topic rule with lambda action and a lambda permission to be invoked by the topic rule",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 100,
                "index": 323
            },
            "line": 6,
            "code": "test('create a topic rule with lambda action and a lambda permission to be invoked by the topic rule', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const func = new lambda.Function(stack, 'MyFunction', {\n    runtime: lambda.Runtime.NODEJS_14_X,\n    handler: 'index.handler',\n    code: lambda.Code.fromInline('console.log(\"foo\")')\n  });\n\n  // WHEN\n  topicRule.addAction(new actions.LambdaFunctionAction(func));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Lambda: {\n          FunctionArn: {\n            'Fn::GetAtt': ['MyFunction3BAA72D1', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Permission', {\n    Action: 'lambda:InvokeFunction',\n    FunctionName: {\n      'Fn::GetAtt': ['MyFunction3BAA72D1', 'Arn']\n    },\n    Principal: 'iot.amazonaws.com',\n    SourceAccount: {\n      Ref: 'AWS::AccountId'\n    },\n    SourceArn: {\n      'Fn::GetAtt': ['MyTopicRule4EC2091C', 'Arn']\n    }\n  });\n});",
            "file": "lambda/lambda-function-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "create two different permissions, when two topic rules have the same action",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 81,
                "index": 1527
            },
            "line": 47,
            "code": "test('create two different permissions, when two topic rules have the same action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const func = new lambda.Function(stack, 'MyFunction', {\n    runtime: lambda.Runtime.NODEJS_14_X,\n    handler: 'index.handler',\n    code: lambda.Code.fromInline('console.log(\"foo\")')\n  });\n  const action = new actions.LambdaFunctionAction(func);\n\n  // WHEN\n  new iot.TopicRule(stack, 'MyTopicRule1', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\"),\n    actions: [action]\n  });\n  new iot.TopicRule(stack, 'MyTopicRule2', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\"),\n    actions: [action]\n  });\n\n  // THEN\n  Template.fromStack(stack).resourceCountIs('AWS::Lambda::Permission', 2);\n});",
            "file": "lambda/lambda-function-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default s3 action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 23,
                "index": 289
            },
            "line": 7,
            "code": "test('Default s3 action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const bucket = s3.Bucket.fromBucketArn(stack, 'MyBucket', 'arn:aws:s3::123456789012:test-bucket');\n\n  // WHEN\n  topicRule.addAction(new actions.S3PutObjectAction(bucket));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        S3: {\n          BucketName: 'test-bucket',\n          Key: '${topic()}/${timestamp()}',\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 's3:PutObject',\n        Effect: 'Allow',\n        Resource: 'arn:aws:s3::123456789012:test-bucket/*'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "s3/s3-put-object-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set key of bucket",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 27,
                "index": 1803
            },
            "line": 59,
            "code": "test('can set key of bucket', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const bucket = s3.Bucket.fromBucketArn(stack, 'MyBucket', 'arn:aws:s3::123456789012:test-bucket');\n\n  // WHEN\n  topicRule.addAction(new actions.S3PutObjectAction(bucket, {\n    key: 'test-key'\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        S3: {\n          Key: 'test-key'\n        }\n      })]\n    }\n  });\n});",
            "file": "s3/s3-put-object-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set canned ACL and it convert to kebab case",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 53,
                "index": 2498
            },
            "line": 83,
            "code": "test('can set canned ACL and it convert to kebab case', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const bucket = s3.Bucket.fromBucketArn(stack, 'MyBucket', 'arn:aws:s3::123456789012:test-bucket');\n\n  // WHEN\n  topicRule.addAction(new actions.S3PutObjectAction(bucket, {\n    accessControl: s3.BucketAccessControl.BUCKET_OWNER_FULL_CONTROL\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        S3: {\n          CannedAcl: 'bucket-owner-full-control'\n        }\n      })]\n    }\n  });\n});",
            "file": "s3/s3-put-object-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 107,
                "column": 18,
                "index": 3229
            },
            "line": 107,
            "code": "test('can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const bucket = s3.Bucket.fromBucketArn(stack, 'MyBucket', 'arn:aws:s3::123456789012:test-bucket');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.S3PutObjectAction(bucket, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        S3: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "s3/s3-put-object-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default SNS topic action",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 30,
                "index": 682
            },
            "line": 18,
            "code": "test('Default SNS topic action', () => {\n  // WHEN\n  topicRule.addAction(new actions.SnsTopicAction(snsTopic));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Sns: {\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          },\n          TargetArn: SNS_TOPIC_ARN\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'sns:Publish',\n        Effect: 'Allow',\n        Resource: SNS_TOPIC_ARN\n      }]\n    },\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "sns/sns-topic-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Can set messageFormat",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 27,
                "index": 1683
            },
            "line": 59,
            "code": "test('Can set messageFormat', () => {\n  // WHEN\n  topicRule.addAction(new actions.SnsTopicAction(snsTopic, {\n    messageFormat: actions.SnsActionMessageFormat.JSON\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Sns: {\n          MessageFormat: 'JSON'\n        }\n      })]\n    }\n  });\n});",
            "file": "sns/sns-topic-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Can set role",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 18,
                "index": 2073
            },
            "line": 76,
            "code": "test('Can set role', () => {\n  // GIVEN\n  const roleArn = 'arn:aws:iam::123456789012:role/testrole';\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', roleArn);\n\n  // WHEN\n  topicRule.addAction(new actions.SnsTopicAction(snsTopic, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Sns: {\n          RoleArn: roleArn\n        }\n      })]\n    }\n  });\n});",
            "file": "sns/sns-topic-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Action with FIFO topic throws error",
            "suites": [],
            "updatePoint": {
                "line": 97,
                "column": 41,
                "index": 2571
            },
            "line": 97,
            "code": "test('Action with FIFO topic throws error', () => {\n  // GIVEN\n  const snsFifoTopic = sns.Topic.fromTopicArn(stack, 'MyFifoTopic', `${SNS_TOPIC_ARN}.fifo`);\n  expect(() => {\n    topicRule.addAction(new actions.SnsTopicAction(snsFifoTopic));\n  }).toThrowError('IoT Rule actions cannot be used with FIFO SNS Topics, please pass a non-FIFO Topic instead');\n});",
            "file": "sns/sns-topic-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default SQS queue action",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 30,
                "index": 298
            },
            "line": 7,
            "code": "test('Default SQS queue action', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const queue = sqs.Queue.fromQueueArn(stack, 'MyQueue', 'arn:aws:sqs::123456789012:test-queue');\n\n  // WHEN\n  topicRule.addAction(new actions.SqsQueueAction(queue));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [{\n        Sqs: {\n          QueueUrl: {\n            'Fn::Join': ['', ['https://sqs..', {\n              Ref: 'AWS::URLSuffix'\n            }, '/123456789012/test-queue']]\n          },\n          RoleArn: {\n            'Fn::GetAtt': ['MyTopicRuleTopicRuleActionRoleCE2D05DA', 'Arn']\n          }\n        }\n      }]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: {\n          Service: 'iot.amazonaws.com'\n        }\n      }],\n      Version: '2012-10-17'\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [{\n        Action: 'sqs:SendMessage',\n        Effect: 'Allow',\n        Resource: 'arn:aws:sqs::123456789012:test-queue'\n      }],\n      Version: '2012-10-17'\n    },\n    PolicyName: 'MyTopicRuleTopicRuleActionRoleDefaultPolicy54A701F7',\n    Roles: [{\n      Ref: 'MyTopicRuleTopicRuleActionRoleCE2D05DA'\n    }]\n  });\n});",
            "file": "sqs/sqs-queue-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Can set useBase64",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 23,
                "index": 1886
            },
            "line": 62,
            "code": "test('Can set useBase64', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const queue = sqs.Queue.fromQueueArn(stack, 'MyQueue', 'arn:aws:sqs::123456789012:test-queue');\n\n  // WHEN\n  topicRule.addAction(new actions.SqsQueueAction(queue, {\n    useBase64: true\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Sqs: {\n          UseBase64: true\n        }\n      })]\n    }\n  });\n});",
            "file": "sqs/sqs-queue-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Can set role",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 18,
                "index": 2540
            },
            "line": 86,
            "code": "test('Can set role', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20160323(\"SELECT topic(2) as device_id FROM 'device/+/data'\")\n  });\n  const queue = sqs.Queue.fromQueueArn(stack, 'MyQueue', 'arn:aws:sqs::123456789012:test-queue');\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/ForTest');\n\n  // WHEN\n  topicRule.addAction(new actions.SqsQueueAction(queue, {\n    role\n  }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [Match.objectLike({\n        Sqs: {\n          RoleArn: 'arn:aws:iam::123456789012:role/ForTest'\n        }\n      })]\n    }\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['ForTest']\n  });\n});",
            "file": "sqs/sqs-queue-action.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot-actions/test"
        },
        {
            "name": "Default property",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 22
            },
            "line": 5,
            "code": "test('Default property', () => {\n  const stack = new cdk.Stack();\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [],\n      Sql: \"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\",\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can get topic rule name",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 29
            },
            "line": 20,
            "code": "test('can get topic rule name', () => {\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  new cdk.CfnResource(stack, 'Res', {\n    type: 'Test::Resource',\n    properties: {\n      TopicRuleName: topicRule.topicRuleName,\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('Test::Resource', {\n    TopicRuleName: { Ref: 'MyTopicRule4EC2091C' },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can get topic rule arn",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 28
            },
            "line": 38,
            "code": "test('can get topic rule arn', () => {\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  new cdk.CfnResource(stack, 'Res', {\n    type: 'Test::Resource',\n    properties: {\n      TopicRuleArn: topicRule.topicRuleArn,\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('Test::Resource', {\n    TopicRuleArn: {\n      'Fn::GetAtt': ['MyTopicRule4EC2091C', 'Arn'],\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set physical name",
            "suites": [],
            "updatePoint": {
                "line": 58,
                "column": 27
            },
            "line": 58,
            "code": "test('can set physical name', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n\n  // WHEN\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    topicRuleName: 'PhysicalName',\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    RuleName: 'PhysicalName',\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set description",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 25
            },
            "line": 74,
            "code": "test('can set description', () => {\n  const stack = new cdk.Stack();\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    description: 'test-description',\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Description: 'test-description',\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set ruleDisabled",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 26
            },
            "line": 89,
            "code": "test('can set ruleDisabled', () => {\n  const stack = new cdk.Stack();\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    enabled: false,\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      RuleDisabled: true,\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set sql with using %s",
            "suites": [],
            "line": 104,
            "code": "test.each([\n  ['fromStringAsVer20151008', iot.IotSql.fromStringAsVer20151008, '2015-10-08'],\n  ['fromStringAsVer20160323', iot.IotSql.fromStringAsVer20160323, '2016-03-23'],\n  ['fromStringAsVerNewestUnstable', iot.IotSql.fromStringAsVerNewestUnstable, 'beta'],\n])('can set sql with using %s', (_, factoryMethod, version) => {\n  const stack = new cdk.Stack();\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: factoryMethod(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      AwsIotSqlVersion: version,\n      Sql: \"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\",\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "Using %s fails when setting empty sql",
            "suites": [],
            "line": 123,
            "code": "test.each([\n  ['fromStringAsVer20151008', iot.IotSql.fromStringAsVer20151008],\n  ['fromStringAsVer20160323', iot.IotSql.fromStringAsVer20160323],\n  ['fromStringAsVerNewestUnstable', iot.IotSql.fromStringAsVerNewestUnstable],\n])('Using %s fails when setting empty sql', (_, factoryMethod) => {\n  expect(() => {\n    factoryMethod('');\n  }).toThrow('IoT SQL string cannot be empty');\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set actions",
            "suites": [],
            "updatePoint": {
                "line": 133,
                "column": 21
            },
            "line": 133,
            "code": "test('can set actions', () => {\n  const stack = new cdk.Stack();\n\n  const action1: iot.IAction = {\n    _bind: () => ({\n      configuration: {\n        http: { url: 'http://example.com' },\n      },\n    }),\n  };\n  const action2: iot.IAction = {\n    _bind: () => ({\n      configuration: {\n        lambda: { functionArn: 'test-functionArn' },\n      },\n    }),\n  };\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n    actions: [action1, action2],\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [\n        { Http: { Url: 'http://example.com' } },\n        { Lambda: { FunctionArn: 'test-functionArn' } },\n      ],\n      Sql: \"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\",\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can add an action",
            "suites": [],
            "updatePoint": {
                "line": 167,
                "column": 23
            },
            "line": 167,
            "code": "test('can add an action', () => {\n  const stack = new cdk.Stack();\n\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n  topicRule.addAction({\n    _bind: () => ({\n      configuration: {\n        http: { url: 'http://example.com' },\n      },\n    }),\n  });\n  topicRule.addAction({\n    _bind: () => ({\n      configuration: {\n        lambda: { functionArn: 'test-functionArn' },\n      },\n    }),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      Actions: [\n        { Http: { Url: 'http://example.com' } },\n        { Lambda: { FunctionArn: 'test-functionArn' } },\n      ],\n      Sql: \"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\",\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "cannot add an action as empty object",
            "suites": [],
            "updatePoint": {
                "line": 199,
                "column": 42
            },
            "line": 199,
            "code": "test('cannot add an action as empty object', () => {\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  const emptyKeysAction: iot.IAction = {\n    _bind: () => ({\n      configuration: {},\n    }),\n  };\n\n  expect(() => {\n    topicRule.addAction(emptyKeysAction);\n  }).toThrow('An action property cannot be an empty object.');\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "cannot add an action that have multiple keys",
            "suites": [],
            "updatePoint": {
                "line": 216,
                "column": 50
            },
            "line": 216,
            "code": "test('cannot add an action that have multiple keys', () => {\n  const stack = new cdk.Stack();\n  const topicRule = new iot.TopicRule(stack, 'MyTopicRule', {\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  const multipleKeysAction: iot.IAction = {\n    _bind: () => ({\n      configuration: {\n        http: { url: 'http://example.com' },\n        lambda: { functionArn: 'test-functionArn' },\n      },\n    }),\n  };\n\n  expect(() => {\n    topicRule.addAction(multipleKeysAction);\n  }).toThrow('An action property cannot have multiple keys, received: http,lambda');\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can set errorAction",
            "suites": [],
            "updatePoint": {
                "line": 236,
                "column": 25
            },
            "line": 236,
            "code": "test('can set errorAction', () => {\n  const stack = new cdk.Stack();\n\n  const action: iot.IAction = {\n    _bind: () => ({\n      configuration: {\n        http: { url: 'http://example.com' },\n      },\n    }),\n  };\n\n  new iot.TopicRule(stack, 'MyTopicRule', {\n    errorAction: action,\n    sql: iot.IotSql.fromStringAsVer20151008(\"SELECT topic(2) as device_id, temperature FROM 'device/+/data'\"),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoT::TopicRule', {\n    TopicRulePayload: {\n      ErrorAction: {\n        Http: { Url: 'http://example.com' },\n      },\n    },\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "can import a TopicRule by ARN",
            "suites": [],
            "updatePoint": {
                "line": 261,
                "column": 35
            },
            "line": 261,
            "code": "test('can import a TopicRule by ARN', () => {\n  const stack = new cdk.Stack();\n\n  const topicRuleArn = 'arn:aws:iot:ap-northeast-1:123456789012:rule/my-topic-rule-name';\n\n  const topicRule = iot.TopicRule.fromTopicRuleArn(stack, 'TopicRuleFromArn', topicRuleArn);\n\n  expect(topicRule).toMatchObject({\n    topicRuleArn,\n    topicRuleName: 'my-topic-rule-name',\n  });\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "fails importing a TopicRule by ARN if the ARN is missing the name of the TopicRule",
            "suites": [],
            "updatePoint": {
                "line": 274,
                "column": 88
            },
            "line": 274,
            "code": "test('fails importing a TopicRule by ARN if the ARN is missing the name of the TopicRule', () => {\n  const stack = new cdk.Stack();\n\n  const topicRuleArn = 'arn:aws:iot:ap-northeast-1:123456789012:rule/';\n\n  expect(() => {\n    iot.TopicRule.fromTopicRuleArn(stack, 'TopicRuleFromArn', topicRuleArn);\n  }).toThrow(\"Missing topic rule name in ARN: 'arn:aws:iot:ap-northeast-1:123456789012:rule/'\");\n});",
            "file": "topic-rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iot/test"
        },
        {
            "name": "Default property",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 22
            },
            "line": 13,
            "code": "test('Default property', () => {\n  // WHEN\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName',\n        condition: iotevents.Expression.fromString('test-eventCondition'),\n      }],\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      InitialStateName: 'test-state',\n      States: [{\n        StateName: 'test-state',\n        OnEnter: {\n          Events: [{\n            EventName: 'test-eventName',\n            Condition: 'test-eventCondition',\n          }],\n        },\n      }],\n    },\n    RoleArn: {\n      'Fn::GetAtt': ['MyDetectorModelDetectorModelRoleF2FB4D88', 'Arn'],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    AssumeRolePolicyDocument: {\n      Statement: [{\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'iotevents.amazonaws.com' },\n      }],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can get detector model name",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 33
            },
            "line": 55,
            "code": "test('can get detector model name', () => {\n  // GIVEN\n  const detectorModel = new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName',\n        condition: iotevents.Expression.fromString('test-eventCondition'),\n      }],\n    }),\n  });\n\n  // WHEN\n  new cdk.CfnResource(stack, 'Res', {\n    type: 'Test::Resource',\n    properties: {\n      DetectorModelName: detectorModel.detectorModelName,\n    },\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('Test::Resource', {\n    DetectorModelName: { Ref: 'MyDetectorModel559C0B0E' },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set %s",
            "suites": [],
            "line": 81,
            "code": "test.each([\n  ['physical name', { detectorModelName: 'test-detector-model' }, { DetectorModelName: 'test-detector-model' }],\n  ['description', { description: 'test-detector-model-description' }, { DetectorModelDescription: 'test-detector-model-description' }],\n  ['evaluationMethod', { evaluationMethod: iotevents.EventEvaluation.SERIAL }, { EvaluationMethod: 'SERIAL' }],\n  ['detectorKey', { detectorKey: 'payload.deviceId' }, { Key: 'payload.deviceId' }],\n])('can set %s', (_, partialProps, expected) => {\n  // WHEN\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    ...partialProps,\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName',\n        condition: iotevents.Expression.fromString('test-eventCondition'),\n      }],\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', expected);\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set multiple events to State",
            "suites": [],
            "updatePoint": {
                "line": 103,
                "column": 38
            },
            "line": 103,
            "code": "test('can set multiple events to State', () => {\n  // WHEN\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [\n        {\n          eventName: 'test-eventName1',\n          condition: iotevents.Expression.fromString('test-eventCondition'),\n        },\n        {\n          eventName: 'test-eventName2',\n        },\n      ],\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      States: [\n        Match.objectLike({\n          OnEnter: {\n            Events: [\n              {\n                EventName: 'test-eventName1',\n                Condition: 'test-eventCondition',\n              },\n              {\n                EventName: 'test-eventName2',\n              },\n            ],\n          },\n        }),\n      ],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set actions to events",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 31
            },
            "line": 142,
            "code": "test('can set actions to events', () => {\n  // WHEN\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName1',\n        condition: iotevents.Expression.currentInput(input),\n        actions: [{\n          _bind: () => ({\n            configuration: {\n              lambda: {\n                functionArn: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn',\n              },\n            },\n          }),\n        }],\n      }],\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      States: [\n        Match.objectLike({\n          OnEnter: {\n            Events: [{\n              Actions: [{ Lambda: { FunctionArn: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn' } }],\n            }],\n          },\n        }),\n      ],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set %s to State",
            "suites": [],
            "line": 179,
            "code": "test.each([\n  ['onInput', { onInput: [{ eventName: 'test-eventName1' }] }, { OnInput: { Events: [{ EventName: 'test-eventName1' }] } }],\n  ['onExit', { onExit: [{ eventName: 'test-eventName1' }] }, { OnExit: { Events: [{ EventName: 'test-eventName1' }] } }],\n])('can set %s to State', (_, events, expected) => {\n  // WHEN\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{ eventName: 'test-eventName1', condition: iotevents.Expression.currentInput(input) }],\n      ...events,\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      States: [Match.objectLike(expected)],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set an action to multiple detector models",
            "suites": [],
            "updatePoint": {
                "line": 200,
                "column": 51
            },
            "line": 200,
            "code": "test('can set an action to multiple detector models', () => {\n  // GIVEN an action\n  const action: iotevents.IAction = {\n    _bind: (_, { role }) => {\n      role.addToPrincipalPolicy(new iam.PolicyStatement({\n        actions: ['lambda:InvokeFunction'],\n        resources: ['arn:aws:lambda:us-east-1:123456789012:function:MyFn'],\n      }));\n      return {\n        configuration: {\n          lambda: { functionArn: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn' },\n        },\n      };\n    },\n  };\n\n  // WHEN the action is set to two detector models\n  new iotevents.DetectorModel(stack, 'MyDetectorModel1', {\n    detectorModelName: 'MyDetectorModel1',\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName1',\n        condition: iotevents.Expression.currentInput(input),\n        actions: [action],\n      }],\n    }),\n  });\n  new iotevents.DetectorModel(stack, 'MyDetectorModel2', {\n    detectorModelName: 'MyDetectorModel2',\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName1',\n        condition: iotevents.Expression.currentInput(input),\n        actions: [action],\n      }],\n    }),\n  });\n\n  // THEN creates two detector model resouces and two iam policy resources\n  Template.fromStack(stack).resourceCountIs('AWS::IoTEvents::DetectorModel', 2);\n  Template.fromStack(stack).resourceCountIs('AWS::IAM::Policy', 2);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelName: 'MyDetectorModel1',\n    DetectorModelDefinition: {\n      States: [\n        Match.objectLike({\n          OnEnter: {\n            Events: [{\n              Actions: [{ Lambda: { FunctionArn: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn' } }],\n            }],\n          },\n        }),\n      ],\n    },\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelName: 'MyDetectorModel2',\n    DetectorModelDefinition: {\n      States: [\n        Match.objectLike({\n          OnEnter: {\n            Events: [{\n              Actions: [{ Lambda: { FunctionArn: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn' } }],\n            }],\n          },\n        }),\n      ],\n    },\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    Roles: [{ Ref: 'MyDetectorModel1DetectorModelRoleB36845CD' }],\n    PolicyDocument: {\n      Statement: [{\n        Action: 'lambda:InvokeFunction',\n        Effect: 'Allow',\n        Resource: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn',\n      }],\n    },\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    Roles: [{ Ref: 'MyDetectorModel2DetectorModelRole3C437E90' }],\n    PolicyDocument: {\n      Statement: [{\n        Action: 'lambda:InvokeFunction',\n        Effect: 'Allow',\n        Resource: 'arn:aws:lambda:us-east-1:123456789012:function:MyFn',\n      }],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set states with transitions",
            "suites": [],
            "updatePoint": {
                "line": 294,
                "column": 37
            },
            "line": 294,
            "code": "test('can set states with transitions', () => {\n  // GIVEN\n  const firstState = new iotevents.State({\n    stateName: 'firstState',\n    onEnter: [{\n      eventName: 'test-eventName',\n      condition: iotevents.Expression.currentInput(input),\n    }],\n  });\n  const secondState = new iotevents.State({\n    stateName: 'secondState',\n  });\n  const thirdState = new iotevents.State({\n    stateName: 'thirdState',\n  });\n\n  // WHEN\n  // transition as 1st -> 2nd\n  firstState.transitionTo(secondState, {\n    when: iotevents.Expression.eq(\n      iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      iotevents.Expression.fromString('12'),\n    ),\n  });\n  // transition as 2nd -> 1st, make circular reference\n  secondState.transitionTo(firstState, {\n    eventName: 'secondToFirst',\n    when: iotevents.Expression.eq(\n      iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      iotevents.Expression.fromString('21'),\n    ),\n  });\n  // transition as 2nd -> 3rd, to test recursive calling\n  secondState.transitionTo(thirdState, {\n    when: iotevents.Expression.eq(\n      iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      iotevents.Expression.fromString('23'),\n    ),\n  });\n\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: firstState,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      States: [\n        {\n          StateName: 'firstState',\n          OnInput: {\n            TransitionEvents: [{\n              EventName: 'firstState_to_secondState',\n              NextState: 'secondState',\n              Condition: '$input.test-input.payload.temperature == 12',\n            }],\n          },\n        },\n        {\n          StateName: 'secondState',\n          OnInput: {\n            TransitionEvents: [\n              {\n                EventName: 'secondToFirst',\n                NextState: 'firstState',\n                Condition: '$input.test-input.payload.temperature == 21',\n              },\n              {\n                EventName: 'secondState_to_thirdState',\n                NextState: 'thirdState',\n                Condition: '$input.test-input.payload.temperature == 23',\n              },\n            ],\n          },\n        },\n        {\n          StateName: 'thirdState',\n        },\n      ],\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set actions to transitions",
            "suites": [],
            "updatePoint": {
                "line": 377,
                "column": 36
            },
            "line": 377,
            "code": "test('can set actions to transitions', () => {\n  // GIVEN\n  const firstState = new iotevents.State({\n    stateName: 'firstState',\n    onEnter: [{\n      eventName: 'test-eventName',\n      condition: iotevents.Expression.currentInput(input),\n    }],\n  });\n  const secondState = new iotevents.State({\n    stateName: 'secondState',\n  });\n\n  // WHEN\n  firstState.transitionTo(secondState, {\n    when: iotevents.Expression.eq(\n      iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      iotevents.Expression.fromString('12'),\n    ),\n    executing: [{ _bind: () => ({ configuration: { setTimer: { timerName: 'test-timer' } } }) }],\n  });\n\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    initialState: firstState,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    DetectorModelDefinition: {\n      States: Match.arrayWith([Match.objectLike({\n        StateName: 'firstState',\n        OnInput: {\n          TransitionEvents: [{\n            Actions: [{ SetTimer: { TimerName: 'test-timer' } }],\n          }],\n        },\n      })]),\n    },\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set role",
            "suites": [],
            "updatePoint": {
                "line": 418,
                "column": 18
            },
            "line": 418,
            "code": "test('can set role', () => {\n  // WHEN\n  const role = iam.Role.fromRoleArn(stack, 'test-role', 'arn:aws:iam::123456789012:role/ForTest');\n  new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n    role,\n    initialState: new iotevents.State({\n      stateName: 'test-state',\n      onEnter: [{\n        eventName: 'test-eventName',\n        condition: iotevents.Expression.fromString('test-eventCondition'),\n      }],\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n    RoleArn: 'arn:aws:iam::123456789012:role/ForTest',\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can import a DetectorModel by detectorModelName",
            "suites": [],
            "updatePoint": {
                "line": 438,
                "column": 53
            },
            "line": 438,
            "code": "test('can import a DetectorModel by detectorModelName', () => {\n  // WHEN\n  const detectorModelName = 'detector-model-name';\n  const detectorModel = iotevents.DetectorModel.fromDetectorModelName(stack, 'ExistingDetectorModel', detectorModelName);\n\n  // THEN\n  expect(detectorModel).toMatchObject({\n    detectorModelName: detectorModelName,\n  });\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "cannot create without condition",
            "suites": [],
            "updatePoint": {
                "line": 449,
                "column": 37
            },
            "line": 449,
            "code": "test('cannot create without condition', () => {\n  expect(() => {\n    new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n      initialState: new iotevents.State({\n        stateName: 'test-state',\n        onEnter: [{\n          eventName: 'test-eventName',\n        }],\n      }),\n    });\n  }).toThrow('Detector Model must have at least one Input with a condition');\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "cannot create without event",
            "suites": [],
            "updatePoint": {
                "line": 462,
                "column": 33
            },
            "line": 462,
            "code": "test('cannot create without event', () => {\n  expect(() => {\n    new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n      initialState: new iotevents.State({\n        stateName: 'test-state',\n      }),\n    });\n  }).toThrow('Detector Model must have at least one Input with a condition');\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "cannot create transitions that transit to duprecated target state",
            "suites": [],
            "updatePoint": {
                "line": 472,
                "column": 71
            },
            "line": 472,
            "code": "test('cannot create transitions that transit to duprecated target state', () => {\n  const firstState = new iotevents.State({\n    stateName: 'firstState',\n    onEnter: [{\n      eventName: 'test-eventName',\n    }],\n  });\n  const secondState = new iotevents.State({\n    stateName: 'secondState',\n  });\n\n  firstState.transitionTo(secondState, {\n    when: iotevents.Expression.eq(\n      iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n      iotevents.Expression.fromString('12.1'),\n    ),\n  });\n\n  expect(() => {\n    firstState.transitionTo(secondState, {\n      when: iotevents.Expression.eq(\n        iotevents.Expression.inputAttribute(input, 'payload.temperature'),\n        iotevents.Expression.fromString('12.2'),\n      ),\n    });\n  }).toThrow(\"State 'firstState' already has a transition defined to 'secondState'\");\n});",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "%s",
            "suites": [
                "Expression"
            ],
            "line": 502,
            "code": "  test.each([\n    ['currentInput', (testInput: iotevents.IInput) => E.currentInput(testInput), 'currentInput(\"test-input\")'],\n    ['timeout', () => E.timeout('test-timer'), 'timeout(\"test-timer\")'],\n    ['inputAttribute', (testInput: iotevents.IInput) => E.inputAttribute(testInput, 'json.path'), '$input.test-input.json.path'],\n    ['add', () => E.add(E.fromString('5'), E.fromString('2')), '5 + 2'],\n    ['subtract', () => E.subtract(E.fromString('5'), E.fromString('2')), '5 - 2'],\n    ['divide', () => E.divide(E.fromString('5'), E.fromString('2')), '5 / 2'],\n    ['multiply', () => E.multiply(E.fromString('5'), E.fromString('2')), '5 * 2'],\n    ['concat', () => E.concat(E.fromString('\"aaa\"'), E.fromString('\"bbb\"')), '\"aaa\" + \"bbb\"'],\n    ['bitwiseOr', () => E.bitwiseOr(E.fromString('5'), E.fromString('2')), '5 | 2'],\n    ['bitwiseAnd', () => E.bitwiseAnd(E.fromString('5'), E.fromString('2')), '5 & 2'],\n    ['bitwiseXor', () => E.bitwiseXor(E.fromString('5'), E.fromString('2')), '5 ^ 2'],\n    ['eq', () => E.eq(E.fromString('\"aaa\"'), E.fromString('\"bbb\"')), '\"aaa\" == \"bbb\"'],\n    ['neq', () => E.neq(E.fromString('\"aaa\"'), E.fromString('\"bbb\"')), '\"aaa\" != \"bbb\"'],\n    ['lt', () => E.lt(E.fromString('5'), E.fromString('2')), '5 < 2'],\n    ['lte', () => E.lte(E.fromString('5'), E.fromString('2')), '5 <= 2'],\n    ['gt', () => E.gt(E.fromString('5'), E.fromString('2')), '5 > 2'],\n    ['gte', () => E.gte(E.fromString('5'), E.fromString('2')), '5 >= 2'],\n    ['and', () => E.and(E.fromString('true'), E.fromString('false')), 'true && false'],\n    ['or', () => E.or(E.fromString('true'), E.fromString('false')), 'true || false'],\n    ['operator priority', () => E.and(\n      E.and(E.fromString('false'), E.fromString('false')),\n      E.or(E.fromString('true'), E.fromString('true')),\n    ), 'false && false && (true || true)'],\n  ])('%s', (_, getExpression, expectedCondition) => {\n    // WHEN\n    new iotevents.DetectorModel(stack, 'MyDetectorModel', {\n      initialState: new iotevents.State({\n        stateName: 'test-state',\n        onEnter: [{\n          eventName: 'test-eventName',\n          condition: getExpression(input),\n        }],\n      }),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::DetectorModel', {\n      DetectorModelDefinition: {\n        States: [\n          Match.objectLike({\n            OnEnter: {\n              Events: [Match.objectLike({\n                Condition: expectedCondition,\n              })],\n            },\n          }),\n        ],\n      },\n    });\n  });",
            "file": "detector-model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "Default property",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 22
            },
            "line": 11,
            "code": "test('Default property', () => {\n  // WHEN\n  new iotevents.Input(stack, 'MyInput', {\n    attributeJsonPaths: ['payload.temperature'],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::Input', {\n    InputDefinition: {\n      Attributes: [{ JsonPath: 'payload.temperature' }],\n    },\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can get input name",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 24
            },
            "line": 25,
            "code": "test('can get input name', () => {\n  // GIVEN\n  const input = new iotevents.Input(stack, 'MyInput', {\n    attributeJsonPaths: ['payload.temperature'],\n  });\n\n  // WHEN\n  new cdk.CfnResource(stack, 'Res', {\n    type: 'Test::Resource',\n    properties: {\n      InputName: input.inputName,\n    },\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('Test::Resource', {\n    InputName: { Ref: 'MyInput08947B23' },\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can get input ARN",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 23
            },
            "line": 45,
            "code": "test('can get input ARN', () => {\n  // GIVEN\n  const input = new iotevents.Input(stack, 'MyInput', {\n    attributeJsonPaths: ['payload.temperature'],\n  });\n\n  // WHEN\n  new cdk.CfnResource(stack, 'Res', {\n    type: 'Test::Resource',\n    properties: {\n      InputArn: input.inputArn,\n    },\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('Test::Resource', {\n    InputArn: {\n      'Fn::Join': ['', [\n        'arn:',\n        { Ref: 'AWS::Partition' },\n        ':iotevents:',\n        { Ref: 'AWS::Region' },\n        ':',\n        { Ref: 'AWS::AccountId' },\n        ':input/',\n        { Ref: 'MyInput08947B23' },\n      ]],\n    },\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can set physical name",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 27
            },
            "line": 76,
            "code": "test('can set physical name', () => {\n  // WHEN\n  new iotevents.Input(stack, 'MyInput', {\n    inputName: 'test_input',\n    attributeJsonPaths: ['payload.temperature'],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IoTEvents::Input', {\n    InputName: 'test_input',\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can import a Input by inputName",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 37
            },
            "line": 89,
            "code": "test('can import a Input by inputName', () => {\n  // WHEN\n  const inputName = 'test-input-name';\n  const topicRule = iotevents.Input.fromInputName(stack, 'InputFromInputName', inputName);\n\n  // THEN\n  expect(topicRule).toMatchObject({\n    inputName,\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "cannot be created with an empty array of attributeJsonPaths",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 65
            },
            "line": 100,
            "code": "test('cannot be created with an empty array of attributeJsonPaths', () => {\n  expect(() => {\n    new iotevents.Input(stack, 'MyInput', {\n      attributeJsonPaths: [],\n    });\n  }).toThrow('attributeJsonPaths property cannot be empty');\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "can grant the permission to put message",
            "suites": [],
            "updatePoint": {
                "line": 108,
                "column": 45
            },
            "line": 108,
            "code": "test('can grant the permission to put message', () => {\n  const role = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::account-id:role/role-name');\n  const input = new iotevents.Input(stack, 'MyInput', {\n    attributeJsonPaths: ['payload.temperature'],\n  });\n\n  // WHEN\n  input.grantWrite(role);\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n    PolicyDocument: {\n      Statement: [\n        {\n          Action: 'iotevents:BatchPutMessage',\n          Effect: 'Allow',\n          Resource: {\n            'Fn::Join': ['', [\n              'arn:',\n              { Ref: 'AWS::Partition' },\n              ':iotevents:',\n              { Ref: 'AWS::Region' },\n              ':',\n              { Ref: 'AWS::AccountId' },\n              ':input/',\n              { Ref: 'MyInput08947B23' },\n            ]],\n          },\n        },\n      ],\n    },\n    PolicyName: 'MyRolePolicy64AB00A5',\n    Roles: ['role-name'],\n  });\n});",
            "file": "input.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-iotevents/test"
        },
        {
            "name": "channel default properties",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 32
            },
            "line": 22,
            "code": "test('channel default properties', () => {\n  new ivs.Channel(stack, 'Channel');\n\n  Template.fromStack(stack).hasResource('AWS::IVS::Channel', {\n    Properties: {\n      Name: 'Channel',\n    },\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel name",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 18
            },
            "line": 32,
            "code": "test('channel name', () => {\n  new ivs.Channel(stack, 'Channel', {\n    channelName: 'CarrotsAreTasty',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::Channel', {\n    Name: 'CarrotsAreTasty',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel is authorized",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 27
            },
            "line": 42,
            "code": "test('channel is authorized', () => {\n  new ivs.Channel(stack, 'Channel', {\n    authorized: true,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::Channel', {\n    Authorized: true,\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel type",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 18
            },
            "line": 52,
            "code": "test('channel type', () => {\n  new ivs.Channel(stack, 'Channel', {\n    type: ivs.ChannelType.BASIC,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::Channel', {\n    Type: 'BASIC',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel latency mode",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 26
            },
            "line": 62,
            "code": "test('channel latency mode', () => {\n  new ivs.Channel(stack, 'Channel', {\n    latencyMode: ivs.LatencyMode.NORMAL,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::Channel', {\n    LatencyMode: 'NORMAL',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel from arn",
            "suites": [],
            "updatePoint": {
                "line": 72,
                "column": 22
            },
            "line": 72,
            "code": "test('channel from arn', () => {\n  const channel = ivs.Channel.fromChannelArn(stack, 'Channel', 'arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh');\n\n  expect(stack.resolve(channel.channelArn)).toBe('arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel invalid name throws validation error",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 50
            },
            "line": 78,
            "code": "test('channel invalid name throws validation error', () => {\n  expect(() => new ivs.Channel(stack, 'Channel', {\n    channelName: 'Would you like a carrot?',\n  })).toThrow('channelName must contain only numbers, letters, hyphens and underscores, got: \\'Would you like a carrot?\\'');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "playback key pair mandatory properties",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 44
            },
            "line": 84,
            "code": "test('playback key pair mandatory properties', () => {\n  new ivs.PlaybackKeyPair(stack, 'PlaybackKeyPair', {\n    publicKeyMaterial: publicKey,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::PlaybackKeyPair', {\n    PublicKeyMaterial: publicKey,\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "playback key pair name",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 28
            },
            "line": 94,
            "code": "test('playback key pair name', () => {\n  new ivs.PlaybackKeyPair(stack, 'PlaybackKeyPair', {\n    publicKeyMaterial: publicKey,\n    playbackKeyPairName: 'CarrotsAreNutritious',\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::PlaybackKeyPair', {\n    PublicKeyMaterial: publicKey,\n    Name: 'CarrotsAreNutritious',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "playback key pair invalid name throws validation error",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 60
            },
            "line": 106,
            "code": "test('playback key pair invalid name throws validation error', () => {\n  expect(() => new ivs.PlaybackKeyPair(stack, 'PlaybackKeyPair', {\n    publicKeyMaterial: 'Carrots Are Orange',\n    playbackKeyPairName: 'Would you like a carrot?',\n  })).toThrow('playbackKeyPairName must contain only numbers, letters, hyphens and underscores, got: \\'Would you like a carrot?\\'');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "stream key mandatory properties",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 37
            },
            "line": 113,
            "code": "test('stream key mandatory properties', () => {\n  new ivs.StreamKey(stack, 'StreamKey', {\n    channel: ivs.Channel.fromChannelArn(stack, 'ChannelRef', 'arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh'),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::StreamKey', {\n    ChannelArn: 'arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel and stream key.. at the same time",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 47
            },
            "line": 123,
            "code": "test('channel and stream key.. at the same time', () => {\n  const channel = new ivs.Channel(stack, 'Channel');\n  channel.addStreamKey('StreamKey');\n\n  Template.fromStack(stack).templateMatches({\n    Resources: {\n      Channel4048F119: {\n        Type: 'AWS::IVS::Channel',\n      },\n      ChannelStreamKey60BDC2BE: {\n        Type: 'AWS::IVS::StreamKey',\n        Properties: {\n          ChannelArn: { 'Fn::GetAtt': ['Channel4048F119', 'Arn'] },\n        },\n      },\n    },\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "stream key from channel reference",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 39
            },
            "line": 142,
            "code": "test('stream key from channel reference', () => {\n  const channel = ivs.Channel.fromChannelArn(stack, 'Channel', 'arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh');\n  channel.addStreamKey('StreamKey');\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IVS::StreamKey', {\n    ChannelArn: 'arn:aws:ivs:us-west-2:123456789012:channel/abcdABCDefgh',\n  });\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel from invalid channel arn throws error",
            "suites": [],
            "updatePoint": {
                "line": 151,
                "column": 51
            },
            "line": 151,
            "code": "test('channel from invalid channel arn throws error', () => {\n  expect(() => ivs.Channel.fromChannelArn(stack, 'ChannelRef', 'this is an invalid arn, in fact, it is a carrot 🥕'))\n    .toThrow('ARNs must start with \\\"arn:\\\" and have at least 6 components: this is an invalid arn, in fact, it is a carrot 🥕');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel from invalid channel arn service throws error",
            "suites": [],
            "updatePoint": {
                "line": 156,
                "column": 59
            },
            "line": 156,
            "code": "test('channel from invalid channel arn service throws error', () => {\n  expect(\n    () => ivs.Channel.fromChannelArn(stack, 'ChannelRef', 'arn:aws:ec2:us-west-2:123456789012:instance/abcdABCDefgh'))\n    .toThrow('Invalid service, expected \\'ivs\\', got \\'ec2\\'');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "channel from invalid channel arn resource throws error",
            "suites": [],
            "updatePoint": {
                "line": 162,
                "column": 60
            },
            "line": 162,
            "code": "test('channel from invalid channel arn resource throws error', () => {\n  expect(\n    () => ivs.Channel.fromChannelArn(stack, 'ChannelRef', 'arn:aws:ivs:us-west-2:123456789012:stream-key/abcdABCDefgh'))\n    .toThrow('Invalid resource, expected \\'channel\\', got \\'stream-key\\'');\n});",
            "file": "ivs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-ivs/test"
        },
        {
            "name": "default Flink Application",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 29,
                "column": 33
            },
            "line": 29,
            "code": "  test('default Flink Application', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      runtime: flink.Runtime.FLINK_1_11,\n      code: flink.ApplicationCode.fromBucket(bucket, 'my-app.jar'),\n      applicationName: 'MyFlinkApplication',\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationName: 'MyFlinkApplication',\n      RuntimeEnvironment: 'FLINK-1_11',\n      ServiceExecutionRole: {\n        'Fn::GetAtt': [\n          'FlinkApplicationRole2F7BCBF6',\n          'Arn',\n        ],\n      },\n      ApplicationConfiguration: {\n        ApplicationCodeConfiguration: {\n          CodeContent: {\n            S3ContentLocation: {\n              BucketARN: stack.resolve(bucket.bucketArn),\n              FileKey: 'my-app.jar',\n            },\n          },\n          CodeContentType: 'ZIPFILE',\n        },\n        ApplicationSnapshotConfiguration: {\n          SnapshotsEnabled: true,\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResource('AWS::KinesisAnalyticsV2::Application', {\n      DeletionPolicy: 'Delete',\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [{\n          Action: 'sts:AssumeRole',\n          Effect: 'Allow',\n          Principal: {\n            Service: 'kinesisanalytics.amazonaws.com',\n          },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: Match.arrayEquals([\n          { Action: 'cloudwatch:PutMetricData', Effect: 'Allow', Resource: '*' },\n          // Access to read from the code bucket\n          {\n            Action: ['s3:GetObject*', 's3:GetBucket*', 's3:List*'],\n            Effect: 'Allow',\n            Resource: Match.anyValue(),\n          },\n          {\n            Action: 'logs:DescribeLogGroups',\n            Effect: 'Allow',\n            Resource: {\n              // looks like arn:aws:logs:us-east-1:123456789012:log-group:*,\n              'Fn::Join': ['', [\n                'arn:',\n                { Ref: 'AWS::Partition' },\n                ':logs:',\n                { Ref: 'AWS::Region' },\n                ':',\n                { Ref: 'AWS::AccountId' },\n                ':log-group:*',\n              ]],\n            },\n          },\n          {\n            Action: 'logs:DescribeLogStreams',\n            Effect: 'Allow',\n            Resource: {\n              // looks like: arn:aws:logs:us-east-1:123456789012:log-group:my-log-group:*,\n              'Fn::GetAtt': ['FlinkApplicationLogGroup7739479C', 'Arn'],\n            },\n          },\n          {\n            Action: 'logs:PutLogEvents',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': ['', [\n                'arn:',\n                { Ref: 'AWS::Partition' },\n                ':logs:',\n                { Ref: 'AWS::Region' },\n                ':',\n                { Ref: 'AWS::AccountId' },\n                ':log-group:',\n                { Ref: 'FlinkApplicationLogGroup7739479C' },\n                ':log-stream:',\n                { Ref: 'FlinkApplicationLogStreamB633AF32' },\n              ]],\n            },\n          },\n        ]),\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "providing a custom role",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 135,
                "column": 31
            },
            "line": 135,
            "code": "  test('providing a custom role', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      role: new iam.Role(stack, 'CustomRole', {\n        assumedBy: new iam.ServicePrincipal('custom-principal'),\n      }),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [\n          {\n            Action: 'sts:AssumeRole',\n            Effect: 'Allow',\n            Principal: {\n              Service: 'custom-principal.amazonaws.com',\n            },\n          },\n        ],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "addToPrincipalPolicy",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 159,
                "column": 28
            },
            "line": 159,
            "code": "  test('addToPrincipalPolicy', () => {\n    const app = new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n    });\n\n    app.addToRolePolicy(new iam.PolicyStatement({\n      actions: ['custom:action'],\n      resources: ['*'],\n    }));\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: Match.arrayWith([\n          Match.objectLike({ Action: 'custom:action', Effect: 'Allow', Resource: '*' }),\n        ]),\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "providing a custom runtime",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 178,
                "column": 34
            },
            "line": 178,
            "code": "  test('providing a custom runtime', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      runtime: flink.Runtime.of('custom'),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      RuntimeEnvironment: 'custom',\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "providing a custom removal policy",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 189,
                "column": 41
            },
            "line": 189,
            "code": "  test('providing a custom removal policy', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      removalPolicy: core.RemovalPolicy.RETAIN,\n    });\n\n    Template.fromStack(stack).hasResource('AWS::KinesisAnalyticsV2::Application', {\n      DeletionPolicy: 'Retain',\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "granting permissions to resources",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 200,
                "column": 41
            },
            "line": 200,
            "code": "  test('granting permissions to resources', () => {\n    const app = new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n    });\n\n    const dataBucket = new s3.Bucket(stack, 'DataBucket');\n    dataBucket.grantRead(app);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Version: '2012-10-17',\n        Statement: Match.arrayWith([\n          Match.objectLike({ Action: ['s3:GetObject*', 's3:GetBucket*', 's3:List*'] }),\n        ]),\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "using an asset for code",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 218,
                "column": 31
            },
            "line": 218,
            "code": "  test('using an asset for code', () => {\n    const app = new core.App({\n      context: {\n        [cxapi.NEW_STYLE_STACK_SYNTHESIS_CONTEXT]: false,\n      },\n    });\n    stack = new core.Stack(app);\n\n    const code = flink.ApplicationCode.fromAsset(path.join(__dirname, 'code-asset'));\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      code,\n    });\n    const assetRef = 'AssetParameters8be9e0b5f53d41e9a3b1d51c9572c65f24f8170a7188d0ed57fb7d571de4d577S3BucketEBA17A67';\n    const versionKeyRef = 'AssetParameters8be9e0b5f53d41e9a3b1d51c9572c65f24f8170a7188d0ed57fb7d571de4d577S3VersionKey5922697E';\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        ApplicationCodeConfiguration: {\n          CodeContent: {\n            S3ContentLocation: {\n              BucketARN: {\n                'Fn::Join': ['', [\n                  'arn:',\n                  { Ref: 'AWS::Partition' },\n                  ':s3:::',\n                  { Ref: assetRef },\n                ]],\n              },\n              FileKey: {\n                'Fn::Join': ['', [\n                  { 'Fn::Select': [0, { 'Fn::Split': ['||', { Ref: versionKeyRef }] }] },\n                  { 'Fn::Select': [1, { 'Fn::Split': ['||', { Ref: versionKeyRef }] }] },\n                ]],\n              },\n            },\n          },\n          CodeContentType: 'ZIPFILE',\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "adding property groups",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 261,
                "column": 30
            },
            "line": 261,
            "code": "  test('adding property groups', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      propertyGroups: {\n        FlinkApplicationProperties: {\n          SomeProperty: 'SomeValue',\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        EnvironmentProperties: {\n          PropertyGroups: [\n            {\n              PropertyGroupId: 'FlinkApplicationProperties',\n              PropertyMap: {\n                SomeProperty: 'SomeValue',\n              },\n            },\n          ],\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "checkpointEnabled setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 287,
                "column": 33
            },
            "line": 287,
            "code": "  test('checkpointEnabled setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      checkpointingEnabled: false,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          CheckpointConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            CheckpointingEnabled: false,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "checkpointInterval setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 305,
                "column": 34
            },
            "line": 305,
            "code": "  test('checkpointInterval setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      checkpointInterval: core.Duration.minutes(5),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          CheckpointConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            CheckpointInterval: 300_000,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "minPauseBetweenCheckpoints setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 323,
                "column": 42
            },
            "line": 323,
            "code": "  test('minPauseBetweenCheckpoints setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      minPauseBetweenCheckpoints: core.Duration.seconds(10),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          CheckpointConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            MinPauseBetweenCheckpoints: 10_000,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "logLevel setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 341,
                "column": 24
            },
            "line": 341,
            "code": "  test('logLevel setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      logLevel: flink.LogLevel.DEBUG,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          MonitoringConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            LogLevel: 'DEBUG',\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "metricsLevel setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 359,
                "column": 28
            },
            "line": 359,
            "code": "  test('metricsLevel setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      metricsLevel: flink.MetricsLevel.PARALLELISM,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          MonitoringConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            MetricsLevel: 'PARALLELISM',\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "autoscalingEnabled setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 377,
                "column": 34
            },
            "line": 377,
            "code": "  test('autoscalingEnabled setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      autoScalingEnabled: false,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          ParallelismConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            AutoScalingEnabled: false,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "parallelism setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 395,
                "column": 27
            },
            "line": 395,
            "code": "  test('parallelism setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      parallelism: 2,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          ParallelismConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            Parallelism: 2,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "parallelismPerKpu setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 413,
                "column": 33
            },
            "line": 413,
            "code": "  test('parallelismPerKpu setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      parallelismPerKpu: 2,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        FlinkApplicationConfiguration: {\n          ParallelismConfiguration: {\n            ConfigurationType: 'CUSTOM',\n            ParallelismPerKPU: 2,\n          },\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "snapshotsEnabled setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 431,
                "column": 32
            },
            "line": 431,
            "code": "  test('snapshotsEnabled setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      snapshotsEnabled: false,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::Application', {\n      ApplicationConfiguration: {\n        ApplicationSnapshotConfiguration: {\n          SnapshotsEnabled: false,\n        },\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "default logging option",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 446,
                "column": 30
            },
            "line": 446,
            "code": "  test('default logging option', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      snapshotsEnabled: false,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisAnalyticsV2::ApplicationCloudWatchLoggingOption', {\n      ApplicationName: {\n        Ref: 'FlinkApplicationC5836815',\n      },\n      CloudWatchLoggingOption: {\n        LogStreamARN: {\n          'Fn::Join': [\n            '',\n            [\n              'arn:',\n              {\n                Ref: 'AWS::Partition',\n              },\n              ':logs:',\n              {\n                Ref: 'AWS::Region',\n              },\n              ':',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              ':log-group:',\n              {\n                Ref: 'FlinkApplicationLogGroup7739479C',\n              },\n              ':log-stream:',\n              {\n                Ref: 'FlinkApplicationLogStreamB633AF32',\n              },\n            ],\n          ],\n        },\n      },\n    });\n\n    Template.fromStack(stack).hasResource('AWS::Logs::LogGroup', {\n      Properties: {\n        RetentionInDays: 731,\n      },\n      UpdateReplacePolicy: 'Retain',\n      DeletionPolicy: 'Retain',\n    });\n\n    Template.fromStack(stack).hasResource('AWS::Logs::LogStream', {\n      UpdateReplacePolicy: 'Retain',\n      DeletionPolicy: 'Retain',\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "logGroup setting",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 501,
                "column": 24
            },
            "line": 501,
            "code": "  test('logGroup setting', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      logGroup: new logs.LogGroup(stack, 'LogGroup', {\n        logGroupName: 'custom',\n      }),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Logs::LogGroup', {\n      LogGroupName: 'custom',\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "using a VPC with default vpcSubnets and securityGroups",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 514,
                "column": 62
            },
            "line": 514,
            "code": "  test('using a VPC with default vpcSubnets and securityGroups', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      vpc: new ec2.Vpc(stack, 'VPC'),\n    });\n\n    const template = Template.fromStack(stack);\n    template.hasResourceProperties(\n      'AWS::KinesisAnalyticsV2::Application',\n      {\n        ApplicationConfiguration: {\n          VpcConfigurations: [\n            {\n              SecurityGroupIds: [\n                {\n                  'Fn::GetAtt': ['FlinkApplicationSecurityGroup1FD816EE', 'GroupId'],\n                },\n              ],\n              SubnetIds: [\n                {\n                  Ref: 'VPCPrivateSubnet1Subnet8BCA10E0',\n                },\n                {\n                  Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A',\n                },\n              ],\n            },\n          ],\n        },\n      },\n    );\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: Match.arrayWith([\n          {\n            Action: [\n              'ec2:DescribeVpcs',\n              'ec2:DescribeSubnets',\n              'ec2:DescribeSecurityGroups',\n              'ec2:DescribeDhcpOptions',\n              'ec2:CreateNetworkInterface',\n              'ec2:CreateNetworkInterfacePermission',\n              'ec2:DescribeNetworkInterfaces',\n              'ec2:DeleteNetworkInterface',\n            ],\n            Effect: 'Allow',\n            Resource: '*',\n          },\n        ]),\n      },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "providing securityGroups",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 568,
                "column": 32
            },
            "line": 568,
            "code": "  test('providing securityGroups', () => {\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      vpc,\n      securityGroups: [\n        new ec2.SecurityGroup(stack, 'ProvidedSecurityGroup', { vpc }),\n      ],\n    });\n\n    Template.fromStack(stack).hasResourceProperties(\n      'AWS::KinesisAnalyticsV2::Application',\n      {\n        ApplicationConfiguration: {\n          VpcConfigurations: [\n            {\n              SecurityGroupIds: [\n                {\n                  'Fn::GetAtt': ['ProvidedSecurityGroup3C7655DD', 'GroupId'],\n                },\n              ],\n            },\n          ],\n        },\n      },\n    );\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "providing a subnetSelection",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 596,
                "column": 35
            },
            "line": 596,
            "code": "  test('providing a subnetSelection', () => {\n    new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      vpc: new ec2.Vpc(stack, 'VPC'),\n      vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC },\n    });\n\n    Template.fromStack(stack).hasResourceProperties(\n      'AWS::KinesisAnalyticsV2::Application',\n      {\n        ApplicationConfiguration: {\n          VpcConfigurations: [\n            {\n              SubnetIds: [\n                {\n                  Ref: 'VPCPublicSubnet1SubnetB4246D30',\n                },\n                {\n                  Ref: 'VPCPublicSubnet2Subnet74179F39',\n                },\n              ],\n            },\n          ],\n        },\n      },\n    );\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "using connections on a created Application",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 624,
                "column": 50
            },
            "line": 624,
            "code": "  test('using connections on a created Application', () => {\n    const app = new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n      vpc: new ec2.Vpc(stack, 'VPC'),\n    });\n\n    app.connections.allowFromAnyIpv4(ec2.Port.tcp(443));\n\n    Template.fromStack(stack).hasResourceProperties(\n      'AWS::EC2::SecurityGroup',\n      {\n        SecurityGroupEgress: [{\n          Description: 'Allow all outbound traffic by default',\n          IpProtocol: '-1',\n        }],\n        SecurityGroupIngress: [{\n          Description: 'from 0.0.0.0/0:443',\n          FromPort: 443,\n          IpProtocol: 'tcp',\n          ToPort: 443,\n        }],\n      },\n    );\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "using connections on an imported Application",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 649,
                "column": 52
            },
            "line": 649,
            "code": "  test('using connections on an imported Application', () => {\n    const app = flink.Application.fromApplicationAttributes(stack, 'FlinkApplication', {\n      applicationArn: 'arn:aws:kinesisanalytics:us-west-2:012345678901:application/my-app',\n      securityGroups: [ec2.SecurityGroup.fromSecurityGroupId(stack, 'ImportedSG', 'sg-123456789')],\n    });\n\n    app.connections.allowFromAnyIpv4(ec2.Port.tcp(443));\n\n    Template.fromStack(stack).hasResourceProperties(\n      'AWS::EC2::SecurityGroupIngress',\n      {\n        FromPort: 443,\n        GroupId: 'sg-123456789',\n        IpProtocol: 'tcp',\n        ToPort: 443,\n      },\n    );\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating vpnSubnets prop requires vpc prop",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 668,
                "column": 52
            },
            "line": 668,
            "code": "  test('validating vpnSubnets prop requires vpc prop', () => {\n    expect(() => {\n      new flink.Application(stack, 'FlinkApplication', {\n        ...requiredProps,\n        vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC },\n      });\n    }).toThrow(/vpc prop required when passing vpcSubnets/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating securityGroups prop requires vpc prop",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 677,
                "column": 56
            },
            "line": 677,
            "code": "  test('validating securityGroups prop requires vpc prop', () => {\n    expect(() => {\n      const vpc = new ec2.Vpc(stack, 'VPC');\n      const securityGroup = new ec2.SecurityGroup(stack, 'SecurityGroup', {\n        vpc,\n      });\n      new flink.Application(stack, 'Error', {\n        ...requiredProps,\n        securityGroups: [securityGroup],\n      });\n    }).toThrow(/vpc prop required when passing securityGroups/);\n\n    // empty array for securityGroups is treated the same as undefined\n    expect(() => {\n      new flink.Application(stack, 'OK', {\n        ...requiredProps,\n        securityGroups: [],\n      });\n    }).not.toThrow();\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating vpc provided when using connections for created App",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 698,
                "column": 70
            },
            "line": 698,
            "code": "  test('validating vpc provided when using connections for created App', () => {\n    let app = new flink.Application(stack, 'FlinkApplication', {\n      ...requiredProps,\n    });\n    expect(() => {\n      app.connections;\n    }).toThrow(/This Application isn\\'t associated with a VPC/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating vpc provided when using connections for imported App",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 707,
                "column": 71
            },
            "line": 707,
            "code": "  test('validating vpc provided when using connections for imported App', () => {\n    let app = flink.Application.fromApplicationName(stack, 'FlinkApplication', 'Name');\n    expect(() => {\n      app.connections;\n    }).toThrow(/This Application isn\\'t associated with a VPC/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating applicationName",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 714,
                "column": 34
            },
            "line": 714,
            "code": "  test('validating applicationName', () => {\n    // Expect no error with valid name\n    new flink.Application(stack, 'ValidString', {\n      ...requiredProps,\n      applicationName: 'my-VALID.app_name',\n    });\n\n    // Expect no error with ref\n    new flink.Application(stack, 'ValidRef', {\n      ...requiredProps,\n      applicationName: new core.CfnParameter(stack, 'Parameter').valueAsString,\n    });\n\n    expect(() => {\n      new flink.Application(stack, 'Empty', {\n        ...requiredProps,\n        applicationName: '',\n      });\n    }).toThrow(/cannot be empty/);\n\n    expect(() => {\n      new flink.Application(stack, 'InvalidCharacters', {\n        ...requiredProps,\n        applicationName: '!!!',\n      });\n    }).toThrow(/may only contain letters, numbers, underscores, hyphens, and periods/);\n\n    expect(() => {\n      new flink.Application(stack, 'TooLong', {\n        ...requiredProps,\n        applicationName: 'a'.repeat(129),\n      });\n    }).toThrow(/max length is 128/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating parallelism",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 749,
                "column": 30
            },
            "line": 749,
            "code": "  test('validating parallelism', () => {\n    // Expect no error with valid value\n    new flink.Application(stack, 'ValidNumber', {\n      ...requiredProps,\n      parallelism: 32,\n    });\n\n    // Expect no error with ref\n    new flink.Application(stack, 'ValidRef', {\n      ...requiredProps,\n      parallelism: new core.CfnParameter(stack, 'Parameter', {\n        type: 'Number',\n      }).valueAsNumber,\n    });\n\n    expect(() => {\n      new flink.Application(stack, 'TooSmall', {\n        ...requiredProps,\n        parallelism: 0,\n      });\n    }).toThrow(/must be at least 1/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "validating parallelismPerKpu",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 772,
                "column": 36
            },
            "line": 772,
            "code": "  test('validating parallelismPerKpu', () => {\n    // Expect no error with valid value\n    new flink.Application(stack, 'ValidNumber', {\n      ...requiredProps,\n      parallelismPerKpu: 10,\n    });\n\n    // Expect no error with ref\n    new flink.Application(stack, 'ValidRef', {\n      ...requiredProps,\n      parallelismPerKpu: new core.CfnParameter(stack, 'Parameter', {\n        type: 'Number',\n      }).valueAsNumber,\n    });\n\n    expect(() => {\n      new flink.Application(stack, 'TooSmall', {\n        ...requiredProps,\n        parallelismPerKpu: 0,\n      });\n    }).toThrow(/must be at least 1/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "fromFlinkApplicationName",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 795,
                "column": 32
            },
            "line": 795,
            "code": "  test('fromFlinkApplicationName', () => {\n    const flinkApp = flink.Application.fromApplicationName(stack, 'Imported', 'my-app');\n\n    expect(flinkApp.applicationName).toEqual('my-app');\n    expect(stack.resolve(flinkApp.applicationArn)).toEqual({\n      'Fn::Join': ['', [\n        'arn:',\n        { Ref: 'AWS::Partition' },\n        ':kinesisanalytics:',\n        { Ref: 'AWS::Region' },\n        ':',\n        { Ref: 'AWS::AccountId' },\n        ':application/my-app',\n      ]],\n    });\n    expect(flinkApp.addToRolePolicy(new iam.PolicyStatement())).toBe(false);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "fromFlinkApplicationArn",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 813,
                "column": 31
            },
            "line": 813,
            "code": "  test('fromFlinkApplicationArn', () => {\n    const arn = 'arn:aws:kinesisanalytics:us-west-2:012345678901:application/my-app';\n    const flinkApp = flink.Application.fromApplicationArn(stack, 'Imported', arn);\n\n    expect(flinkApp.applicationName).toEqual('my-app');\n    expect(flinkApp.applicationArn).toEqual(arn);\n    expect(flinkApp.addToRolePolicy(new iam.PolicyStatement())).toBe(false);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "fromFlinkApplicationAttributes",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 822,
                "column": 38
            },
            "line": 822,
            "code": "  test('fromFlinkApplicationAttributes', () => {\n    const arn = 'arn:aws:kinesisanalytics:us-west-2:012345678901:application/my-app';\n    const flinkApp = flink.Application.fromApplicationAttributes(stack, 'Imported', {\n      applicationArn: arn,\n    });\n\n    expect(flinkApp.applicationName).toEqual('my-app');\n    expect(flinkApp.applicationArn).toEqual(arn);\n    expect(flinkApp.addToRolePolicy(new iam.PolicyStatement())).toBe(false);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "get metric",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 833,
                "column": 18
            },
            "line": 833,
            "code": "  test('get metric', () => {\n    const flinkApp = new flink.Application(stack, 'Application', { ...requiredProps });\n    expect(flinkApp.metric('KPUs', { statistic: 'Sum' }))\n      .toMatchObject({\n        namespace: 'AWS/KinesisAnalytics',\n        metricName: 'KPUs',\n        dimensions: { Application: flinkApp.applicationName },\n        statistic: 'Sum',\n      });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "canned metrics",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 844,
                "column": 22
            },
            "line": 844,
            "code": "  test('canned metrics', () => {\n    const flinkApp = new flink.Application(stack, 'Application', { ...requiredProps });\n\n    // Table driven test with: [method, metricName, default statistic]\n    const assertions: Array<[(options?: cloudwatch.MetricOptions) => cloudwatch.Metric, string, string]> = [\n      [flinkApp.metricKpus, 'KPUs', 'Average'],\n      [flinkApp.metricDowntime, 'downtime', 'Average'],\n      [flinkApp.metricUptime, 'uptime', 'Average'],\n      [flinkApp.metricFullRestarts, 'fullRestarts', 'Sum'],\n      [flinkApp.metricNumberOfFailedCheckpoints, 'numberOfFailedCheckpoints', 'Sum'],\n      [flinkApp.metricLastCheckpointDuration, 'lastCheckpointDuration', 'Maximum'],\n      [flinkApp.metricLastCheckpointSize, 'lastCheckpointSize', 'Maximum'],\n      [flinkApp.metricCpuUtilization, 'cpuUtilization', 'Average'],\n      [flinkApp.metricHeapMemoryUtilization, 'heapMemoryUtilization', 'Average'],\n      [flinkApp.metricOldGenerationGCTime, 'oldGenerationGCTime', 'Sum'],\n      [flinkApp.metricOldGenerationGCCount, 'oldGenerationGCCount', 'Sum'],\n      [flinkApp.metricThreadsCount, 'threadsCount', 'Average'],\n      [flinkApp.metricNumRecordsIn, 'numRecordsIn', 'Average'],\n      [flinkApp.metricNumRecordsInPerSecond, 'numRecordsInPerSecond', 'Average'],\n      [flinkApp.metricNumRecordsOut, 'numRecordsOut', 'Average'],\n      [flinkApp.metricNumRecordsOutPerSecond, 'numRecordsOutPerSecond', 'Average'],\n      [flinkApp.metricNumLateRecordsDropped, 'numLateRecordsDropped', 'Sum'],\n      [flinkApp.metricCurrentInputWatermark, 'currentInputWatermark', 'Maximum'],\n      [flinkApp.metricCurrentOutputWatermark, 'currentOutputWatermark', 'Maximum'],\n      [flinkApp.metricManagedMemoryUsed, 'managedMemoryUsed', 'Average'],\n      [flinkApp.metricManagedMemoryTotal, 'managedMemoryTotal', 'Average'],\n      [flinkApp.metricManagedMemoryUtilization, 'managedMemoryUtilization', 'Average'],\n      [flinkApp.metricIdleTimeMsPerSecond, 'idleTimeMsPerSecond', 'Average'],\n      [flinkApp.metricBackPressuredTimeMsPerSecond, 'backPressuredTimeMsPerSecond', 'Average'],\n      [flinkApp.metricBusyTimePerMsPerSecond, 'busyTimePerMsPerSecond', 'Average'],\n    ];\n\n    assertions.forEach(([method, metricName, defaultStatistic]) => {\n      // Test metrics with no options provided\n      expect(method.call(flinkApp)).toMatchObject({\n        metricName,\n        statistic: defaultStatistic,\n        namespace: 'AWS/KinesisAnalytics',\n        dimensions: {\n          Application: flinkApp.applicationName,\n        },\n      });\n\n      // Make sure we can override the default statistic and add other options\n      expect(method.call(flinkApp, { statistic: 'special', color: '#00ff00' })).toMatchObject({\n        statistic: 'special',\n        color: '#00ff00',\n      });\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisanalytics-flink/test"
        },
        {
            "name": "provides defaults when no configuration is provided",
            "suites": [
                "S3 destination"
            ],
            "updatePoint": {
                "line": 24,
                "column": 57
            },
            "line": 24,
            "code": "  it('provides defaults when no configuration is provided', () => {\n    new firehose.DeliveryStream(stack, 'DeliveryStream', {\n      destinations: [new firehosedestinations.S3Bucket(bucket, { role: destinationRole })],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      ExtendedS3DestinationConfiguration: {\n        BucketARN: stack.resolve(bucket.bucketArn),\n        CloudWatchLoggingOptions: {\n          Enabled: true,\n        },\n        RoleARN: stack.resolve(destinationRole.roleArn),\n      },\n    });\n    Template.fromStack(stack).resourceCountIs('AWS::Logs::LogGroup', 1);\n    Template.fromStack(stack).resourceCountIs('AWS::Logs::LogStream', 1);\n  });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates a role when none is provided",
            "suites": [
                "S3 destination"
            ],
            "updatePoint": {
                "line": 42,
                "column": 42
            },
            "line": 42,
            "code": "  it('creates a role when none is provided', () => {\n\n    new firehose.DeliveryStream(stack, 'DeliveryStream', {\n      destinations: [new firehosedestinations.S3Bucket(bucket)],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      ExtendedS3DestinationConfiguration: {\n        RoleARN: {\n          'Fn::GetAtt': [\n            'DeliveryStreamS3DestinationRoleD96B8345',\n            'Arn',\n          ],\n        },\n      },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [\n          {\n            Effect: 'Allow',\n            Principal: {\n              Service: 'firehose.amazonaws.com',\n            },\n            Action: 'sts:AssumeRole',\n          },\n        ],\n      },\n    });\n  });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "grants read/write access to the bucket",
            "suites": [
                "S3 destination"
            ],
            "updatePoint": {
                "line": 73,
                "column": 44
            },
            "line": 73,
            "code": "  it('grants read/write access to the bucket', () => {\n    const destination = new firehosedestinations.S3Bucket(bucket, { role: destinationRole });\n\n    new firehose.DeliveryStream(stack, 'DeliveryStream', {\n      destinations: [destination],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      Roles: [stack.resolve(destinationRole.roleName)],\n      PolicyDocument: {\n        Statement: Match.arrayWith([\n          {\n            Action: [\n              's3:GetObject*',\n              's3:GetBucket*',\n              's3:List*',\n              's3:DeleteObject*',\n              's3:PutObject',\n              's3:PutObjectLegalHold',\n              's3:PutObjectRetention',\n              's3:PutObjectTagging',\n              's3:PutObjectVersionTagging',\n              's3:Abort*',\n            ],\n            Effect: 'Allow',\n            Resource: [\n              stack.resolve(bucket.bucketArn),\n              { 'Fn::Join': ['', [stack.resolve(bucket.bucketArn), '/*']] },\n            ],\n          },\n        ]),\n      },\n    });\n  });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "bucket and log group grants are depended on by delivery stream",
            "suites": [
                "S3 destination"
            ],
            "updatePoint": {
                "line": 108,
                "column": 68
            },
            "line": 108,
            "code": "  it('bucket and log group grants are depended on by delivery stream', () => {\n    const logGroup = logs.LogGroup.fromLogGroupName(stack, 'Log Group', 'evergreen');\n    const destination = new firehosedestinations.S3Bucket(bucket, { role: destinationRole, logGroup });\n    new firehose.DeliveryStream(stack, 'DeliveryStream', {\n      destinations: [destination],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyName: 'DestinationRoleDefaultPolicy1185C75D',\n      Roles: [stack.resolve(destinationRole.roleName)],\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: [\n              's3:GetObject*',\n              's3:GetBucket*',\n              's3:List*',\n              's3:DeleteObject*',\n              's3:PutObject',\n              's3:PutObjectLegalHold',\n              's3:PutObjectRetention',\n              's3:PutObjectTagging',\n              's3:PutObjectVersionTagging',\n              's3:Abort*',\n            ],\n            Effect: 'Allow',\n            Resource: [\n              stack.resolve(bucket.bucketArn),\n              { 'Fn::Join': ['', [stack.resolve(bucket.bucketArn), '/*']] },\n            ],\n          },\n          {\n            Action: [\n              'logs:CreateLogStream',\n              'logs:PutLogEvents',\n            ],\n            Effect: 'Allow',\n            Resource: stack.resolve(logGroup.logGroupArn),\n          },\n        ],\n      },\n    });\n    Template.fromStack(stack).hasResource('AWS::KinesisFirehose::DeliveryStream', {\n      DependsOn: ['DestinationRoleDefaultPolicy1185C75D'],\n    });\n  });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates resources and configuration by default",
            "suites": [
                "S3 destination",
                "logging"
            ],
            "updatePoint": {
                "line": 156,
                "column": 54
            },
            "line": 156,
            "code": "    it('creates resources and configuration by default', () => {\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket)],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::Logs::LogGroup', 1);\n      Template.fromStack(stack).resourceCountIs('AWS::Logs::LogStream', 1);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          CloudWatchLoggingOptions: {\n            Enabled: true,\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "does not create resources or configuration if disabled",
            "suites": [
                "S3 destination",
                "logging"
            ],
            "updatePoint": {
                "line": 172,
                "column": 62
            },
            "line": 172,
            "code": "    it('does not create resources or configuration if disabled', () => {\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, { logging: false })],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::Logs::LogGroup', 0);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          CloudWatchLoggingOptions: Match.absent(),\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "uses provided log group",
            "suites": [
                "S3 destination",
                "logging"
            ],
            "updatePoint": {
                "line": 185,
                "column": 31
            },
            "line": 185,
            "code": "    it('uses provided log group', () => {\n      const logGroup = new logs.LogGroup(stack, 'Log Group');\n\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, { logGroup })],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::Logs::LogGroup', 1);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          CloudWatchLoggingOptions: {\n            Enabled: true,\n            LogGroupName: stack.resolve(logGroup.logGroupName),\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "throws error if logging disabled but log group provided",
            "suites": [
                "S3 destination",
                "logging"
            ],
            "updatePoint": {
                "line": 203,
                "column": 63
            },
            "line": 203,
            "code": "    it('throws error if logging disabled but log group provided', () => {\n      const destination = new firehosedestinations.S3Bucket(bucket, { logging: false, logGroup: new logs.LogGroup(stack, 'Log Group') });\n\n      expect(() => new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      })).toThrowError('logging cannot be set to false when logGroup is provided');\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "grants log group write permissions to destination role",
            "suites": [
                "S3 destination",
                "logging"
            ],
            "updatePoint": {
                "line": 211,
                "column": 62
            },
            "line": 211,
            "code": "    it('grants log group write permissions to destination role', () => {\n      const logGroup = new logs.LogGroup(stack, 'Log Group');\n\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, { logGroup, role: destinationRole })],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        Roles: [stack.resolve(destinationRole.roleName)],\n        PolicyDocument: {\n          Statement: Match.arrayWith([\n            {\n              Action: [\n                'logs:CreateLogStream',\n                'logs:PutLogEvents',\n              ],\n              Effect: 'Allow',\n              Resource: stack.resolve(logGroup.logGroupArn),\n            },\n          ]),\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates configuration for LambdaFunctionProcessor",
            "suites": [
                "S3 destination",
                "processing configuration"
            ],
            "updatePoint": {
                "line": 254,
                "column": 57
            },
            "line": 254,
            "code": "    it('creates configuration for LambdaFunctionProcessor', () => {\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destinationWithBasicLambdaProcessor],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::Lambda::Function', 1);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          ProcessingConfiguration: {\n            Enabled: true,\n            Processors: [{\n              Type: 'Lambda',\n              Parameters: [\n                {\n                  ParameterName: 'RoleArn',\n                  ParameterValue: stack.resolve(destinationRole.roleArn),\n                },\n                {\n                  ParameterName: 'LambdaArn',\n                  ParameterValue: stack.resolve(lambdaFunction.functionArn),\n                },\n              ],\n            }],\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "set all optional parameters",
            "suites": [
                "S3 destination",
                "processing configuration"
            ],
            "updatePoint": {
                "line": 282,
                "column": 35
            },
            "line": 282,
            "code": "    it('set all optional parameters', () => {\n      const processor = new firehose.LambdaFunctionProcessor(lambdaFunction, {\n        bufferInterval: cdk.Duration.minutes(1),\n        bufferSize: cdk.Size.mebibytes(1),\n        retries: 5,\n      });\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        role: destinationRole,\n        processor: processor,\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::Lambda::Function', 1);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          ProcessingConfiguration: {\n            Enabled: true,\n            Processors: [{\n              Type: 'Lambda',\n              Parameters: [\n                {\n                  ParameterName: 'RoleArn',\n                  ParameterValue: stack.resolve(destinationRole.roleArn),\n                },\n                {\n                  ParameterName: 'LambdaArn',\n                  ParameterValue: stack.resolve(lambdaFunction.functionArn),\n                },\n                {\n                  ParameterName: 'BufferIntervalInSeconds',\n                  ParameterValue: '60',\n                },\n                {\n                  ParameterName: 'BufferSizeInMBs',\n                  ParameterValue: '1',\n                },\n                {\n                  ParameterName: 'NumberOfRetries',\n                  ParameterValue: '5',\n                },\n              ],\n            }],\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "grants invoke access to the lambda function and delivery stream depends on grant",
            "suites": [
                "S3 destination",
                "processing configuration"
            ],
            "updatePoint": {
                "line": 331,
                "column": 88
            },
            "line": 331,
            "code": "    it('grants invoke access to the lambda function and delivery stream depends on grant', () => {\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destinationWithBasicLambdaProcessor],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyName: 'DestinationRoleDefaultPolicy1185C75D',\n        Roles: [stack.resolve(destinationRole.roleName)],\n        PolicyDocument: {\n          Statement: Match.arrayWith([\n            {\n              Action: 'lambda:InvokeFunction',\n              Effect: 'Allow',\n              Resource: [\n                stack.resolve(lambdaFunction.functionArn),\n                { 'Fn::Join': ['', [stack.resolve(lambdaFunction.functionArn), ':*']] },\n              ],\n            },\n          ]),\n        },\n      });\n      Template.fromStack(stack).hasResource('AWS::KinesisFirehose::DeliveryStream', {\n        DependsOn: ['DestinationRoleDefaultPolicy1185C75D'],\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "configures when specified",
            "suites": [
                "S3 destination",
                "compression"
            ],
            "updatePoint": {
                "line": 359,
                "column": 33
            },
            "line": 359,
            "code": "    it('configures when specified', () => {\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        compression: firehosedestinations.Compression.GZIP,\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          CompressionFormat: 'GZIP',\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "allows custom compression types",
            "suites": [
                "S3 destination",
                "compression"
            ],
            "updatePoint": {
                "line": 374,
                "column": 39
            },
            "line": 374,
            "code": "    it('allows custom compression types', () => {\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        compression: firehosedestinations.Compression.of('SNAZZY'),\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          CompressionFormat: 'SNAZZY',\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates configuration when interval and size provided",
            "suites": [
                "S3 destination",
                "buffering"
            ],
            "updatePoint": {
                "line": 391,
                "column": 61
            },
            "line": 391,
            "code": "    it('creates configuration when interval and size provided', () => {\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          bufferingInterval: cdk.Duration.minutes(1),\n          bufferingSize: cdk.Size.mebibytes(1),\n        })],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          BufferingHints: {\n            IntervalInSeconds: 60,\n            SizeInMBs: 1,\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "validates bufferingInterval",
            "suites": [
                "S3 destination",
                "buffering"
            ],
            "updatePoint": {
                "line": 409,
                "column": 35
            },
            "line": 409,
            "code": "    it('validates bufferingInterval', () => {\n      expect(() => new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          bufferingInterval: cdk.Duration.seconds(30),\n          bufferingSize: cdk.Size.mebibytes(1),\n        })],\n      })).toThrowError('Buffering interval must be between 60 and 900 seconds. Buffering interval provided was 30 seconds.');\n\n      expect(() => new firehose.DeliveryStream(stack, 'DeliveryStream2', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          bufferingInterval: cdk.Duration.minutes(16),\n          bufferingSize: cdk.Size.mebibytes(1),\n        })],\n      })).toThrowError('Buffering interval must be between 60 and 900 seconds. Buffering interval provided was 960 seconds.');\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "validates bufferingSize",
            "suites": [
                "S3 destination",
                "buffering"
            ],
            "updatePoint": {
                "line": 425,
                "column": 31
            },
            "line": 425,
            "code": "    it('validates bufferingSize', () => {\n      expect(() => new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          bufferingInterval: cdk.Duration.minutes(1),\n          bufferingSize: cdk.Size.mebibytes(0),\n\n        })],\n      })).toThrowError('Buffering size must be between 1 and 128 MiBs. Buffering size provided was 0 MiBs');\n\n      expect(() => new firehose.DeliveryStream(stack, 'DeliveryStream2', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          bufferingInterval: cdk.Duration.minutes(1),\n          bufferingSize: cdk.Size.mebibytes(256),\n        })],\n      })).toThrowError('Buffering size must be between 1 and 128 MiBs. Buffering size provided was 256 MiBs');\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates configuration",
            "suites": [
                "S3 destination",
                "destination encryption"
            ],
            "updatePoint": {
                "line": 444,
                "column": 29
            },
            "line": 444,
            "code": "    it('creates configuration', () => {\n      const key = new kms.Key(stack, 'Key');\n\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          encryptionKey: key,\n          role: destinationRole,\n        })],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          EncryptionConfiguration: {\n            KMSEncryptionConfig: {\n              AWSKMSKeyARN: stack.resolve(key.keyArn),\n            },\n          },\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "grants encrypt/decrypt access to the destination encryptionKey",
            "suites": [
                "S3 destination",
                "destination encryption"
            ],
            "updatePoint": {
                "line": 465,
                "column": 70
            },
            "line": 465,
            "code": "    it('grants encrypt/decrypt access to the destination encryptionKey', () => {\n      const key = new kms.Key(stack, 'Key');\n\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [new firehosedestinations.S3Bucket(bucket, {\n          encryptionKey: key,\n          role: destinationRole,\n        })],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        Roles: [stack.resolve(destinationRole.roleName)],\n        PolicyDocument: {\n          Statement: Match.arrayWith([{\n            Action: [\n              'kms:Decrypt',\n              'kms:Encrypt',\n              'kms:ReEncrypt*',\n              'kms:GenerateDataKey*',\n            ],\n            Effect: 'Allow',\n            Resource: stack.resolve(key.keyArn),\n          }]),\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "set backupMode to ALL creates resources",
            "suites": [
                "S3 destination",
                "s3 backup configuration"
            ],
            "updatePoint": {
                "line": 494,
                "column": 47
            },
            "line": 494,
            "code": "    it('set backupMode to ALL creates resources', () => {\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        role: destinationRole,\n        s3Backup: {\n          mode: firehosedestinations.BackupMode.ALL,\n        },\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          S3BackupConfiguration: {\n            CloudWatchLoggingOptions: {\n              Enabled: true,\n            },\n            RoleARN: stack.resolve(destinationRole.roleArn),\n          },\n          S3BackupMode: 'Enabled',\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "sets backup configuration if backup bucket provided",
            "suites": [
                "S3 destination",
                "s3 backup configuration"
            ],
            "updatePoint": {
                "line": 518,
                "column": 59
            },
            "line": 518,
            "code": "    it('sets backup configuration if backup bucket provided', () => {\n      const backupBucket = new s3.Bucket(stack, 'MyBackupBucket');\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        role: destinationRole,\n        s3Backup: {\n          bucket: backupBucket,\n        },\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          S3BackupConfiguration: {\n            BucketARN: stack.resolve(backupBucket.bucketArn),\n            CloudWatchLoggingOptions: {\n              Enabled: true,\n            },\n            RoleARN: stack.resolve(destinationRole.roleArn),\n          },\n          S3BackupMode: 'Enabled',\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "throws error if backupMode set to FAILED",
            "suites": [
                "S3 destination",
                "s3 backup configuration"
            ],
            "updatePoint": {
                "line": 544,
                "column": 48
            },
            "line": 544,
            "code": "    it('throws error if backupMode set to FAILED', () => {\n      expect(() => new firehosedestinations.S3Bucket(bucket, {\n        role: destinationRole,\n        s3Backup: {\n          mode: firehosedestinations.BackupMode.FAILED,\n        },\n      })).toThrowError('S3 destinations do not support BackupMode.FAILED');\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "by default does not create resources",
            "suites": [
                "S3 destination",
                "s3 backup configuration"
            ],
            "updatePoint": {
                "line": 553,
                "column": 44
            },
            "line": 553,
            "code": "    it('by default does not create resources', () => {\n      const destination = new firehosedestinations.S3Bucket(bucket);\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::S3::Bucket', 1);\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          S3BackupConfiguration: Match.absent(),\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "sets full backup configuration",
            "suites": [
                "S3 destination",
                "s3 backup configuration"
            ],
            "updatePoint": {
                "line": 567,
                "column": 38
            },
            "line": 567,
            "code": "    it('sets full backup configuration', () => {\n      const backupBucket = new s3.Bucket(stack, 'MyBackupBucket');\n      const key = new kms.Key(stack, 'Key');\n      const logGroup = new logs.LogGroup(stack, 'BackupLogGroup');\n      const destination = new firehosedestinations.S3Bucket(bucket, {\n        role: destinationRole,\n        s3Backup: {\n          mode: firehosedestinations.BackupMode.ALL,\n          bucket: backupBucket,\n          dataOutputPrefix: 'myBackupPrefix',\n          errorOutputPrefix: 'myBackupErrorPrefix',\n          bufferingSize: cdk.Size.mebibytes(1),\n          bufferingInterval: cdk.Duration.minutes(1),\n          compression: firehosedestinations.Compression.ZIP,\n          encryptionKey: key,\n          logging: true,\n          logGroup: logGroup,\n        },\n      });\n      new firehose.DeliveryStream(stack, 'DeliveryStream', {\n        destinations: [destination],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n        ExtendedS3DestinationConfiguration: {\n          S3BackupConfiguration: {\n            BucketARN: stack.resolve(backupBucket.bucketArn),\n            CloudWatchLoggingOptions: {\n              Enabled: true,\n              LogGroupName: stack.resolve(logGroup.logGroupName),\n            },\n            RoleARN: stack.resolve(destinationRole.roleArn),\n            EncryptionConfiguration: {\n              KMSEncryptionConfig: {\n                AWSKMSKeyARN: stack.resolve(key.keyArn),\n              },\n            },\n            Prefix: 'myBackupPrefix',\n            ErrorOutputPrefix: 'myBackupErrorPrefix',\n            BufferingHints: {},\n            CompressionFormat: 'ZIP',\n          },\n          S3BackupMode: 'Enabled',\n        },\n      });\n    });",
            "file": "s3-bucket.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose-destinations/test"
        },
        {
            "name": "creates stream with default values",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 44,
                "column": 42
            },
            "line": 44,
            "code": "  test('creates stream with default values', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamEncryptionConfigurationInput: Match.absent(),\n      DeliveryStreamName: Match.absent(),\n      DeliveryStreamType: 'DirectPut',\n      KinesisStreamSourceConfiguration: Match.absent(),\n      ExtendedS3DestinationConfiguration: {\n        BucketARN: bucketArn,\n        RoleARN: roleArn,\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "provided role is set as grant principal",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 61,
                "column": 47
            },
            "line": 61,
            "code": "  test('provided role is set as grant principal', () => {\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('firehose.amazonaws.com'),\n    });\n\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      role: role,\n    });\n\n    expect(deliveryStream.grantPrincipal).toBe(role);\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "not providing role creates one",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 74,
                "column": 38
            },
            "line": 74,
            "code": "  test('not providing role creates one', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n      AssumeRolePolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Principal: {\n              Service: 'firehose.amazonaws.com',\n            },\n          }),\n        ],\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "providing source stream creates configuration and grants permission",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 92,
                "column": 75
            },
            "line": 92,
            "code": "  test('providing source stream creates configuration and grants permission', () => {\n    const sourceStream = new kinesis.Stream(stack, 'Source Stream');\n\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      sourceStream: sourceStream,\n      role: deliveryStreamRole,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          {\n            Effect: 'Allow',\n            Action: Match.arrayWith([\n              'kinesis:GetRecords',\n              'kinesis:GetShardIterator',\n              'kinesis:ListShards',\n              'kinesis:DescribeStream',\n            ]),\n            Resource: stack.resolve(sourceStream.streamArn),\n          },\n        ],\n      },\n      Roles: [stack.resolve(deliveryStreamRole.roleName)],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamType: 'KinesisStreamAsSource',\n      KinesisStreamSourceConfiguration: {\n        KinesisStreamARN: stack.resolve(sourceStream.streamArn),\n        RoleARN: stack.resolve(deliveryStreamRole.roleArn),\n      },\n    });\n    Template.fromStack(stack).hasResource('AWS::KinesisFirehose::DeliveryStream', {\n      DependsOn: Match.arrayWith(['DeliveryStreamRoleDefaultPolicy2759968B']),\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting customer-owned encryption creates key and configuration",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 130,
                "column": 74
            },
            "line": 130,
            "code": "  test('requesting customer-owned encryption creates key and configuration', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.CUSTOMER_MANAGED,\n      role: deliveryStreamRole,\n    });\n\n    Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Action: Match.arrayWith([\n              'kms:Decrypt',\n              'kms:Encrypt',\n            ]),\n          }),\n        ],\n      },\n      Roles: [stack.resolve(deliveryStreamRole.roleName)],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamEncryptionConfigurationInput: {\n        KeyARN: {\n          'Fn::GetAtt': [\n            'DeliveryStreamKey56A6407F',\n            'Arn',\n          ],\n        },\n        KeyType: 'CUSTOMER_MANAGED_CMK',\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "providing encryption key creates configuration",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 164,
                "column": 54
            },
            "line": 164,
            "code": "  test('providing encryption key creates configuration', () => {\n    const key = new kms.Key(stack, 'Key');\n\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryptionKey: key,\n      role: deliveryStreamRole,\n    });\n\n    Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Action: Match.arrayWith([\n              'kms:Decrypt',\n              'kms:Encrypt',\n            ]),\n            Resource: stack.resolve(key.keyArn),\n          }),\n        ],\n      },\n      Roles: [stack.resolve(deliveryStreamRole.roleName)],\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamEncryptionConfigurationInput: {\n        KeyARN: stack.resolve(key.keyArn),\n        KeyType: 'CUSTOMER_MANAGED_CMK',\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting AWS-owned key does not create key and creates configuration",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 196,
                "column": 78
            },
            "line": 196,
            "code": "  test('requesting AWS-owned key does not create key and creates configuration', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.AWS_OWNED,\n      role: deliveryStreamRole,\n    });\n\n    Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::IAM::Policy', 0);\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamType: 'DirectPut',\n      DeliveryStreamEncryptionConfigurationInput: {\n        KeyARN: Match.absent(),\n        KeyType: 'AWS_OWNED_CMK',\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting no encryption creates no configuration",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 214,
                "column": 57
            },
            "line": 214,
            "code": "  test('requesting no encryption creates no configuration', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.UNENCRYPTED,\n      role: deliveryStreamRole,\n    });\n\n    Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 0);\n    Template.fromStack(stack).resourceCountIs('AWS::IAM::Policy', 0);\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      DeliveryStreamType: 'DirectPut',\n      DeliveryStreamEncryptionConfigurationInput: Match.absent(),\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting AWS-owned key and providing a key throws an error",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 229,
                "column": 68
            },
            "line": 229,
            "code": "  test('requesting AWS-owned key and providing a key throws an error', () => {\n    const key = new kms.Key(stack, 'Key');\n\n    expect(() => new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.AWS_OWNED,\n      encryptionKey: key,\n    })).toThrowError('Specified stream encryption as AWS_OWNED but provided a customer-managed key');\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting no encryption and providing a key throws an error",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 239,
                "column": 68
            },
            "line": 239,
            "code": "  test('requesting no encryption and providing a key throws an error', () => {\n    const key = new kms.Key(stack, 'Key');\n\n    expect(() => new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.UNENCRYPTED,\n      encryptionKey: key,\n    })).toThrowError('Specified stream encryption as UNENCRYPTED but provided a customer-managed key');\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "requesting encryption or providing a key when source is a stream throws an error",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 249,
                "column": 88
            },
            "line": 249,
            "code": "  test('requesting encryption or providing a key when source is a stream throws an error', () => {\n    const sourceStream = new kinesis.Stream(stack, 'Source Stream');\n\n    expect(() => new firehose.DeliveryStream(stack, 'Delivery Stream 1', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.AWS_OWNED,\n      sourceStream,\n    })).toThrowError('Requested server-side encryption but delivery stream source is a Kinesis data stream. Specify server-side encryption on the data stream instead.');\n    expect(() => new firehose.DeliveryStream(stack, 'Delivery Stream 2', {\n      destinations: [mockS3Destination],\n      encryption: firehose.StreamEncryption.CUSTOMER_MANAGED,\n      sourceStream,\n    })).toThrowError('Requested server-side encryption but delivery stream source is a Kinesis data stream. Specify server-side encryption on the data stream instead.');\n    expect(() => new firehose.DeliveryStream(stack, 'Delivery Stream 3', {\n      destinations: [mockS3Destination],\n      encryptionKey: new kms.Key(stack, 'Key'),\n      sourceStream,\n    })).toThrowError('Requested server-side encryption but delivery stream source is a Kinesis data stream. Specify server-side encryption on the data stream instead.');\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "grant provides access to stream",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 269,
                "column": 39
            },
            "line": 269,
            "code": "  test('grant provides access to stream', () => {\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n    });\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    deliveryStream.grant(role, 'firehose:PutRecord');\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Action: 'firehose:PutRecord',\n            Resource: stack.resolve(deliveryStream.deliveryStreamArn),\n          }),\n        ],\n      },\n      Roles: [stack.resolve(role.roleName)],\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "grantPutRecords provides PutRecord* access to stream",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 292,
                "column": 60
            },
            "line": 292,
            "code": "  test('grantPutRecords provides PutRecord* access to stream', () => {\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n    });\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    deliveryStream.grantPutRecords(role);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [\n          Match.objectLike({\n            Action: [\n              'firehose:PutRecord',\n              'firehose:PutRecordBatch',\n            ],\n            Resource: stack.resolve(deliveryStream.deliveryStreamArn),\n          }),\n        ],\n      },\n      Roles: [stack.resolve(role.roleName)],\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "dependables supplied from destination are depended on by just the CFN resource",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 318,
                "column": 86
            },
            "line": 318,
            "code": "  test('dependables supplied from destination are depended on by just the CFN resource', () => {\n    const dependableId = stack.resolve((Node.of(dependable).defaultChild as cdk.CfnResource).logicalId);\n\n    new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    Template.fromStack(stack).hasResource('AWS::KinesisFirehose::DeliveryStream', {\n      DependsOn: [dependableId],\n    });\n    Template.fromStack(stack).hasResource('AWS::IAM::Role', {\n      DependsOn: Match.absent(),\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "supplying 0 or multiple destinations throws",
            "suites": [
                "delivery stream"
            ],
            "updatePoint": {
                "line": 333,
                "column": 51
            },
            "line": 333,
            "code": "  test('supplying 0 or multiple destinations throws', () => {\n    expect(() => new firehose.DeliveryStream(stack, 'No Destinations', {\n      destinations: [],\n    })).toThrowError(/Only one destination is allowed per delivery stream/);\n    expect(() => new firehose.DeliveryStream(stack, 'Too Many Destinations', {\n      destinations: [mockS3Destination, mockS3Destination],\n    })).toThrowError(/Only one destination is allowed per delivery stream/);\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metric",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 352,
                "column": 16
            },
            "line": 352,
            "code": "    test('metric', () => {\n      const metric = deliveryStream.metric('IncomingRecords');\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'IncomingRecords',\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metricIncomingBytes",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 366,
                "column": 29
            },
            "line": 366,
            "code": "    test('metricIncomingBytes', () => {\n      const metric = deliveryStream.metricIncomingBytes();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'IncomingBytes',\n        statistic: cloudwatch.Statistic.SUM,\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metricIncomingRecords",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 381,
                "column": 31
            },
            "line": 381,
            "code": "    test('metricIncomingRecords', () => {\n      const metric = deliveryStream.metricIncomingRecords();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'IncomingRecords',\n        statistic: cloudwatch.Statistic.SUM,\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metricBackupToS3Bytes",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 396,
                "column": 31
            },
            "line": 396,
            "code": "    test('metricBackupToS3Bytes', () => {\n      const metric = deliveryStream.metricBackupToS3Bytes();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'BackupToS3.Bytes',\n        statistic: cloudwatch.Statistic.SUM,\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metricBackupToS3DataFreshness",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 411,
                "column": 39
            },
            "line": 411,
            "code": "    test('metricBackupToS3DataFreshness', () => {\n      const metric = deliveryStream.metricBackupToS3DataFreshness();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'BackupToS3.DataFreshness',\n        statistic: cloudwatch.Statistic.AVERAGE,\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "metricBackupToS3Records",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 426,
                "column": 33
            },
            "line": 426,
            "code": "    test('metricBackupToS3Records', () => {\n      const metric = deliveryStream.metricBackupToS3Records();\n\n      expect(metric).toMatchObject({\n        account: stack.account,\n        region: stack.region,\n        namespace: 'AWS/Firehose',\n        metricName: 'BackupToS3.Records',\n        statistic: cloudwatch.Statistic.SUM,\n        dimensions: {\n          DeliveryStreamName: deliveryStream.deliveryStreamName,\n        },\n      });\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "allows connections for Firehose IP addresses using map when region not specified",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 442,
                "column": 88
            },
            "line": 442,
            "code": "  test('allows connections for Firehose IP addresses using map when region not specified', () => {\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const securityGroup = new ec2.SecurityGroup(stack, 'Security Group', { vpc });\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    securityGroup.connections.allowFrom(deliveryStream, ec2.Port.allTcp());\n\n    Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroup', {\n      SecurityGroupIngress: [\n        Match.objectLike({\n          CidrIp: {\n            'Fn::FindInMap': Match.arrayWith([\n              {\n                Ref: 'AWS::Region',\n              },\n              'FirehoseCidrBlock',\n            ]),\n          },\n        }),\n      ],\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "allows connections for Firehose IP addresses using literal when region specified",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 467,
                "column": 88
            },
            "line": 467,
            "code": "  test('allows connections for Firehose IP addresses using literal when region specified', () => {\n    stack = new cdk.Stack(undefined, undefined, { env: { region: 'us-west-1' } });\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const securityGroup = new ec2.SecurityGroup(stack, 'Security Group', { vpc });\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    securityGroup.connections.allowFrom(deliveryStream, ec2.Port.allTcp());\n\n    Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroup', {\n      SecurityGroupIngress: [\n        Match.objectLike({\n          CidrIp: '13.57.135.192/27',\n        }),\n      ],\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "only adds one Firehose IP address mapping to stack even if multiple delivery streams defined",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 486,
                "column": 100
            },
            "line": 486,
            "code": "  test('only adds one Firehose IP address mapping to stack even if multiple delivery streams defined', () => {\n    new firehose.DeliveryStream(stack, 'Delivery Stream 1', {\n      destinations: [mockS3Destination],\n    });\n    new firehose.DeliveryStream(stack, 'Delivery Stream 2', {\n      destinations: [mockS3Destination],\n    });\n\n    Template.fromStack(stack).hasMapping('*', {\n      'af-south-1': {\n        FirehoseCidrBlock: '13.244.121.224/27',\n      },\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "can add tags",
            "suites": [
                "delivery stream",
                "metric methods provide a Metric with configured and attached properties"
            ],
            "updatePoint": {
                "line": 501,
                "column": 20
            },
            "line": 501,
            "code": "  test('can add tags', () => {\n    const deliveryStream = new firehose.DeliveryStream(stack, 'Delivery Stream', {\n      destinations: [mockS3Destination],\n    });\n\n    cdk.Tags.of(deliveryStream).add('tagKey', 'tagValue');\n\n    Template.fromStack(stack).hasResourceProperties('AWS::KinesisFirehose::DeliveryStream', {\n      Tags: [\n        {\n          Key: 'tagKey',\n          Value: 'tagValue',\n        },\n      ],\n    });\n  });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "from name",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 519,
                "column": 19
            },
            "line": 519,
            "code": "    test('from name', () => {\n      const deliveryStream = firehose.DeliveryStream.fromDeliveryStreamName(stack, 'DeliveryStream', 'mydeliverystream');\n\n      expect(deliveryStream.deliveryStreamName).toBe('mydeliverystream');\n      expect(stack.resolve(deliveryStream.deliveryStreamArn)).toStrictEqual({\n        'Fn::Join': ['', ['arn:', stack.resolve(stack.partition), ':firehose:', stack.resolve(stack.region), ':', stack.resolve(stack.account), ':deliverystream/mydeliverystream']],\n      });\n      expect(deliveryStream.grantPrincipal).toBeInstanceOf(iam.UnknownPrincipal);\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "from ARN",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 529,
                "column": 18
            },
            "line": 529,
            "code": "    test('from ARN', () => {\n      const deliveryStream = firehose.DeliveryStream.fromDeliveryStreamArn(stack, 'DeliveryStream', 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/mydeliverystream');\n\n      expect(deliveryStream.deliveryStreamName).toBe('mydeliverystream');\n      expect(deliveryStream.deliveryStreamArn).toBe('arn:aws:firehose:xx-west-1:111122223333:deliverystream/mydeliverystream');\n      expect(deliveryStream.grantPrincipal).toBeInstanceOf(iam.UnknownPrincipal);\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "from attributes (just name)",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 537,
                "column": 37
            },
            "line": 537,
            "code": "    test('from attributes (just name)', () => {\n      const deliveryStream = firehose.DeliveryStream.fromDeliveryStreamAttributes(stack, 'DeliveryStream', { deliveryStreamName: 'mydeliverystream' });\n\n      expect(deliveryStream.deliveryStreamName).toBe('mydeliverystream');\n      expect(stack.resolve(deliveryStream.deliveryStreamArn)).toStrictEqual({\n        'Fn::Join': ['', ['arn:', stack.resolve(stack.partition), ':firehose:', stack.resolve(stack.region), ':', stack.resolve(stack.account), ':deliverystream/mydeliverystream']],\n      });\n      expect(deliveryStream.grantPrincipal).toBeInstanceOf(iam.UnknownPrincipal);\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "from attributes (just ARN)",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 547,
                "column": 36
            },
            "line": 547,
            "code": "    test('from attributes (just ARN)', () => {\n      const deliveryStream = firehose.DeliveryStream.fromDeliveryStreamAttributes(stack, 'DeliveryStream', { deliveryStreamArn: 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/mydeliverystream' });\n\n      expect(deliveryStream.deliveryStreamName).toBe('mydeliverystream');\n      expect(deliveryStream.deliveryStreamArn).toBe('arn:aws:firehose:xx-west-1:111122223333:deliverystream/mydeliverystream');\n      expect(deliveryStream.grantPrincipal).toBeInstanceOf(iam.UnknownPrincipal);\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "from attributes (with role)",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 555,
                "column": 37
            },
            "line": 555,
            "code": "    test('from attributes (with role)', () => {\n      const role = iam.Role.fromRoleArn(stack, 'Delivery Stream Role', 'arn:aws:iam::111122223333:role/DeliveryStreamRole');\n      const deliveryStream = firehose.DeliveryStream.fromDeliveryStreamAttributes(stack, 'DeliveryStream', { deliveryStreamName: 'mydeliverystream', role });\n\n      expect(deliveryStream.deliveryStreamName).toBe('mydeliverystream');\n      expect(stack.resolve(deliveryStream.deliveryStreamArn)).toStrictEqual({\n        'Fn::Join': ['', ['arn:', stack.resolve(stack.partition), ':firehose:', stack.resolve(stack.region), ':', stack.resolve(stack.account), ':deliverystream/mydeliverystream']],\n      });\n      expect(deliveryStream.grantPrincipal).toBe(role);\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "throws when malformatted ARN",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 566,
                "column": 38
            },
            "line": 566,
            "code": "    test('throws when malformatted ARN', () => {\n      expect(() => firehose.DeliveryStream.fromDeliveryStreamAttributes(stack, 'DeliveryStream', { deliveryStreamArn: 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/' }))\n        .toThrowError(\"No delivery stream name found in ARN: 'arn:aws:firehose:xx-west-1:111122223333:deliverystream/'\");\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "throws when without name or ARN",
            "suites": [
                "delivery stream",
                "importing"
            ],
            "updatePoint": {
                "line": 571,
                "column": 41
            },
            "line": 571,
            "code": "    test('throws when without name or ARN', () => {\n      expect(() => firehose.DeliveryStream.fromDeliveryStreamAttributes(stack, 'DeliveryStream', {}))\n        .toThrowError('Either deliveryStreamName or deliveryStreamArn must be provided in DeliveryStreamAttributes');\n    });",
            "file": "delivery-stream.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-kinesisfirehose/test"
        },
        {
            "name": "bundling",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 14
            },
            "line": 31,
            "code": "test('bundling', () => {\n  Bundling.bundle({\n    entry,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n    forcedDockerBundling: true,\n    environment: {\n      KEY: 'value',\n    },\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(path.dirname(moduleDir), {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      environment: {\n        KEY: 'value',\n        CGO_ENABLED: '0',\n        GO111MODULE: 'on',\n        GOARCH: 'amd64',\n        GOOS: 'linux',\n      },\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap ./cmd/api',\n        ].join(' && '),\n      ],\n    }),\n  });\n\n  expect(DockerImage.fromBuild).toHaveBeenCalledWith(expect.stringMatching(/aws-lambda-go\\/lib$/), expect.objectContaining({\n    buildArgs: expect.objectContaining({\n      IMAGE: expect.stringMatching(/build-go/),\n    }),\n    platform: 'linux/amd64',\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "bundling with file as entry",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 33
            },
            "line": 70,
            "code": "test('bundling with file as entry', () => {\n  Bundling.bundle({\n    entry: '/project/main.go',\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap ./main.go',\n        ].join(' && '),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "bundling with file in subdirectory as entry",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 49
            },
            "line": 91,
            "code": "test('bundling with file in subdirectory as entry', () => {\n  Bundling.bundle({\n    entry: '/project/cmd/api/main.go',\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap ./cmd/api/main.go',\n        ].join(' && '),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "bundling with file other than main.go in subdirectory as entry",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 68
            },
            "line": 112,
            "code": "test('bundling with file other than main.go in subdirectory as entry', () => {\n  Bundling.bundle({\n    entry: '/project/cmd/api/api.go',\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap ./cmd/api/api.go',\n        ].join(' && '),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "go with Windows paths",
            "suites": [],
            "updatePoint": {
                "line": 133,
                "column": 27
            },
            "line": 133,
            "code": "test('go with Windows paths', () => {\n  const osPlatformMock = jest.spyOn(os, 'platform').mockReturnValue('win32');\n  Bundling.bundle({\n    entry: 'C:\\\\my-project\\\\cmd\\\\api',\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir: 'C:\\\\my-project\\\\go.mod',\n    forcedDockerBundling: true,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(expect.any(String), expect.objectContaining({\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      command: expect.arrayContaining([\n        expect.stringContaining('cmd/api'),\n      ]),\n    }),\n  }));\n  osPlatformMock.mockRestore();\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "with Docker build args",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 28
            },
            "line": 154,
            "code": "test('with Docker build args', () => {\n  Bundling.bundle({\n    entry,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n    forcedDockerBundling: true,\n    buildArgs: {\n      HELLO: 'WORLD',\n    },\n  });\n  expect(DockerImage.fromBuild).toHaveBeenCalledWith(expect.stringMatching(/aws-lambda-go\\/lib$/), expect.objectContaining({\n    buildArgs: expect.objectContaining({\n      HELLO: 'WORLD',\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Local bundling",
            "suites": [],
            "updatePoint": {
                "line": 172,
                "column": 20
            },
            "line": 172,
            "code": "test('Local bundling', () => {\n  const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n    status: 0,\n    stderr: Buffer.from('stderr'),\n    stdout: Buffer.from('go version go1.15 linux/amd64'),\n    pid: 123,\n    output: ['stdout', 'stderr'],\n    signal: null,\n  });\n\n  const bundler = new Bundling({\n    moduleDir,\n    entry,\n    environment: {\n      KEY: 'value',\n    },\n    runtime: Runtime.PROVIDED_AL2,\n    architecture: Architecture.X86_64,\n  });\n\n  expect(bundler.local).toBeDefined();\n\n  const tryBundle = bundler.local?.tryBundle('/outdir', { image: Runtime.GO_1_X.bundlingDockerImage });\n  expect(tryBundle).toBe(true);\n\n  expect(spawnSyncMock).toHaveBeenCalledWith(\n    'bash',\n    expect.arrayContaining(['-c', expect.stringContaining('cmd/api')]),\n    expect.objectContaining({\n      env: expect.objectContaining({ KEY: 'value' }),\n      cwd: expect.stringContaining('/project'),\n    }),\n  );\n\n  // Docker image is not built\n  expect(DockerImage.fromBuild).not.toHaveBeenCalled();\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Incorrect go version",
            "suites": [],
            "updatePoint": {
                "line": 210,
                "column": 26
            },
            "line": 210,
            "code": "test('Incorrect go version', () => {\n  getGoBuildVersionMock.mockReturnValueOnce(false);\n\n  const bundler = new Bundling({\n    entry,\n    moduleDir,\n    runtime: Runtime.PROVIDED_AL2,\n    architecture: Architecture.X86_64,\n  });\n\n  const tryBundle = bundler.local?.tryBundle('/outdir', { image: Runtime.GO_1_X.bundlingDockerImage });\n\n  expect(tryBundle).toBe(false);\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling docker image",
            "suites": [],
            "updatePoint": {
                "line": 226,
                "column": 34
            },
            "line": 226,
            "code": "test('Custom bundling docker image', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    dockerImage: DockerImage.fromRegistry('my-custom-image'),\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      image: { image: 'my-custom-image' },\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Go build flags can be passed",
            "suites": [],
            "updatePoint": {
                "line": 244,
                "column": 34
            },
            "line": 244,
            "code": "test('Go build flags can be passed', () => {\n  Bundling.bundle({\n    entry,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n    environment: {\n      KEY: 'value',\n    },\n    goBuildFlags: ['-ldflags \"-s -w\"'],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      environment: {\n        KEY: 'value',\n        CGO_ENABLED: '0',\n        GO111MODULE: 'on',\n        GOARCH: 'amd64',\n        GOOS: 'linux',\n      },\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap -ldflags \"-s -w\" ./cmd/api',\n        ].join(' && '),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "AssetHashType can be specified",
            "suites": [],
            "updatePoint": {
                "line": 276,
                "column": 36
            },
            "line": 276,
            "code": "test('AssetHashType can be specified', () => {\n  Bundling.bundle({\n    entry,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    moduleDir,\n    environment: {\n      KEY: 'value',\n    },\n    assetHashType: AssetHashType.OUTPUT,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      environment: {\n        KEY: 'value',\n        CGO_ENABLED: '0',\n        GO111MODULE: 'on',\n        GOARCH: 'amd64',\n        GOOS: 'linux',\n      },\n      command: [\n        'bash', '-c',\n        [\n          'go build -o /asset-output/bootstrap ./cmd/api',\n        ].join(' && '),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "with command hooks",
            "suites": [],
            "updatePoint": {
                "line": 309,
                "column": 24
            },
            "line": 309,
            "code": "test('with command hooks', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.PROVIDED_AL2,\n    architecture: Architecture.X86_64,\n    commandHooks: {\n      beforeBundling(inputDir: string, outputDir: string): string[] {\n        return [\n          `echo hello > ${inputDir}/a.txt`,\n          `cp ${inputDir}/a.txt ${outputDir}`,\n        ];\n      },\n      afterBundling(inputDir: string, outputDir: string): string[] {\n        return [`cp ${inputDir}/b.txt ${outputDir}/txt`];\n      },\n    },\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(path.dirname(moduleDir), {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        expect.stringMatching(/^echo hello > \\/asset-input\\/a.txt && cp \\/asset-input\\/a.txt \\/asset-output && .+ && cp \\/asset-input\\/b.txt \\/asset-output\\/txt$/),\n      ],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling entrypoint",
            "suites": [],
            "updatePoint": {
                "line": 339,
                "column": 32
            },
            "line": 339,
            "code": "test('Custom bundling entrypoint', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    entrypoint: ['/cool/entrypoint', '--cool-entrypoint-arg'],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      entrypoint: ['/cool/entrypoint', '--cool-entrypoint-arg'],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling volumes",
            "suites": [],
            "updatePoint": {
                "line": 357,
                "column": 29
            },
            "line": 357,
            "code": "test('Custom bundling volumes', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling volumesFrom",
            "suites": [],
            "updatePoint": {
                "line": 375,
                "column": 33
            },
            "line": 375,
            "code": "test('Custom bundling volumesFrom', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    volumesFrom: ['777f7dc92da7'],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      volumesFrom: ['777f7dc92da7'],\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling workingDirectory",
            "suites": [],
            "updatePoint": {
                "line": 393,
                "column": 38
            },
            "line": 393,
            "code": "test('Custom bundling workingDirectory', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    workingDirectory: '/working-directory',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      workingDirectory: '/working-directory',\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling user",
            "suites": [],
            "updatePoint": {
                "line": 411,
                "column": 26
            },
            "line": 411,
            "code": "test('Custom bundling user', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    user: 'user:group',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      user: 'user:group',\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling securityOpt",
            "suites": [],
            "updatePoint": {
                "line": 429,
                "column": 33
            },
            "line": 429,
            "code": "test('Custom bundling securityOpt', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    securityOpt: 'no-new-privileges',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      securityOpt: 'no-new-privileges',\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling network",
            "suites": [],
            "updatePoint": {
                "line": 447,
                "column": 29
            },
            "line": 447,
            "code": "test('Custom bundling network', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    network: 'host',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      network: 'host',\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Custom bundling file copy variant",
            "suites": [],
            "updatePoint": {
                "line": 465,
                "column": 39
            },
            "line": 465,
            "code": "test('Custom bundling file copy variant', () => {\n  Bundling.bundle({\n    entry,\n    moduleDir,\n    runtime: Runtime.GO_1_X,\n    architecture: Architecture.X86_64,\n    forcedDockerBundling: true,\n    bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith('/project', {\n    assetHashType: AssetHashType.OUTPUT,\n    bundling: expect.objectContaining({\n      bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n    }),\n  });\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "golang is available",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 25
            },
            "line": 9,
            "code": "test('golang is available', async () => {\n  const proc = spawnSync(docker, [\n    'run', 'golang',\n    'sh', '-c',\n    'go version',\n  ]);\n  expect(proc.status).toEqual(0);\n});",
            "file": "docker.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "GoFunction with defaults",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 30
            },
            "line": 27,
            "code": "test('GoFunction with defaults', () => {\n  // WHEN\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-go\\/test\\/lambda-handler-vendor\\/cmd\\/api$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'bootstrap',\n    Runtime: 'provided.al2',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "GoFunction with using provided runtime",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 44
            },
            "line": 43,
            "code": "test('GoFunction with using provided runtime', () => {\n  // WHEN\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    runtime: Runtime.PROVIDED,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-go\\/test\\/lambda-handler-vendor\\/cmd\\/api$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'bootstrap',\n    Runtime: 'provided',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "GoFunction with using golang runtime",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 42
            },
            "line": 60,
            "code": "test('GoFunction with using golang runtime', () => {\n  // WHEN\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    runtime: Runtime.GO_1_X,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-go\\/test\\/lambda-handler-vendor\\/cmd\\/api$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'bootstrap',\n    Runtime: 'go1.x',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "GoFunction with container env vars",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 40
            },
            "line": 77,
            "code": "test('GoFunction with container env vars', () => {\n  // WHEN\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    bundling: {\n      environment: {\n        KEY: 'VALUE',\n      },\n    },\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    environment: {\n      KEY: 'VALUE',\n    },\n  }));\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "throws with the wrong runtime family",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 42
            },
            "line": 95,
            "code": "test('throws with the wrong runtime family', () => {\n  expect(() => new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    runtime: Runtime.PYTHON_3_8,\n  })).toThrow(/Only `go` and `provided` runtimes are supported/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "resolves entry to an absolute path",
            "suites": [],
            "updatePoint": {
                "line": 102,
                "column": 40
            },
            "line": 102,
            "code": "test('resolves entry to an absolute path', () => {\n  // WHEN\n  new GoFunction(stack, 'fn', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api/main.go'),\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-go\\/test\\/lambda-handler-vendor\\/cmd\\/api\\/main.go$/),\n  }));\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "throws with no existing go.mod file",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 41
            },
            "line": 113,
            "code": "test('throws with no existing go.mod file', () => {\n  expect(() => new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    moduleDir: '/does/not/exist/go.mod',\n  })).toThrow(/go.mod file at \\/does\\/not\\/exist\\/go.mod doesn't exist/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "throws with incorrect moduleDir file",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 42
            },
            "line": 120,
            "code": "test('throws with incorrect moduleDir file', () => {\n  expect(() => new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    moduleDir: '/does/not/exist.mod',\n  })).toThrow(/moduleDir is specifying a file that is not go.mod/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "custom moduleDir can be used",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 34
            },
            "line": 127,
            "code": "test('custom moduleDir can be used', () => {\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    moduleDir: path.join(__dirname, 'lambda-handler-vendor'),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'bootstrap',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "custom moduleDir with file path can be used",
            "suites": [],
            "updatePoint": {
                "line": 138,
                "column": 49
            },
            "line": 138,
            "code": "test('custom moduleDir with file path can be used', () => {\n  new GoFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-vendor/cmd/api'),\n    moduleDir: path.join(__dirname, 'lambda-handler-vendor/go.mod'),\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'bootstrap',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Starting at process.cwd()",
            "suites": [
                "findUp"
            ],
            "updatePoint": {
                "line": 12,
                "column": 33
            },
            "line": 12,
            "code": "  test('Starting at process.cwd()', () => {\n    expect(findUp('README.md')).toMatch(/aws-lambda-go\\/README.md$/);\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Non existing file",
            "suites": [
                "findUp"
            ],
            "updatePoint": {
                "line": 16,
                "column": 25
            },
            "line": 16,
            "code": "  test('Non existing file', () => {\n    expect(findUp('non-existing-file.unknown')).toBe(undefined);\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Starting at a specific path",
            "suites": [
                "findUp"
            ],
            "updatePoint": {
                "line": 20,
                "column": 35
            },
            "line": 20,
            "code": "  test('Starting at a specific path', () => {\n    expect(findUp('util.test.ts', path.join(__dirname, 'integ-handlers'))).toMatch(/aws-lambda-go\\/test\\/util.test.ts$/);\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Non existing file starting at a non existing relative path",
            "suites": [
                "findUp"
            ],
            "updatePoint": {
                "line": 24,
                "column": 66
            },
            "line": 24,
            "code": "  test('Non existing file starting at a non existing relative path', () => {\n    expect(findUp('not-to-be-found.txt', 'non-existing/relative/path')).toBe(undefined);\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Starting at a relative path",
            "suites": [
                "findUp"
            ],
            "updatePoint": {
                "line": 28,
                "column": 35
            },
            "line": 28,
            "code": "  test('Starting at a relative path', () => {\n    expect(findUp('util.test.ts', 'test/integ-handlers')).toMatch(/aws-lambda-go\\/test\\/util.test.ts$/);\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "normal execution",
            "suites": [
                "exec"
            ],
            "updatePoint": {
                "line": 34,
                "column": 24
            },
            "line": 34,
            "code": "  test('normal execution', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      status: 0,\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('stdout'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    const proc = exec(\n      'cmd',\n      ['arg1', 'arg2'],\n      { env: { KEY: 'value' } },\n    );\n\n    expect(spawnSyncMock).toHaveBeenCalledWith(\n      'cmd',\n      ['arg1', 'arg2'],\n      { env: { KEY: 'value' } },\n    );\n    expect(proc.stdout.toString()).toBe('stdout');\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "non zero status",
            "suites": [
                "exec"
            ],
            "updatePoint": {
                "line": 60,
                "column": 23
            },
            "line": 60,
            "code": "  test('non zero status', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      status: 999,\n      stderr: Buffer.from('error occured'),\n      stdout: Buffer.from('stdout'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    expect(() => exec('cmd', ['arg1', 'arg2'])).toThrow('error occured');\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "with error",
            "suites": [
                "exec"
            ],
            "updatePoint": {
                "line": 75,
                "column": 18
            },
            "line": 75,
            "code": "  test('with error', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      error: new Error('bad error'),\n      status: 0,\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('stdout'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    expect(() => exec('cmd', ['arg1', 'arg2'])).toThrow(new Error('bad error'));\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "returns the version",
            "suites": [
                "getGoBuildVersion"
            ],
            "updatePoint": {
                "line": 93,
                "column": 27
            },
            "line": 93,
            "code": "  test('returns the version', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      status: 0,\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('go version go1.15 linux/amd64'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    expect(getGoBuildVersion()).toBe(true);\n    expect(spawnSyncMock).toHaveBeenCalledWith('go', ['version']);\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "returns undefined on non zero status",
            "suites": [
                "getGoBuildVersion"
            ],
            "updatePoint": {
                "line": 109,
                "column": 44
            },
            "line": 109,
            "code": "  test('returns undefined on non zero status', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      status: 127, // status error\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('stdout'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    expect(getGoBuildVersion()).toBeUndefined();\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "returns undefined on error",
            "suites": [
                "getGoBuildVersion"
            ],
            "updatePoint": {
                "line": 124,
                "column": 34
            },
            "line": 124,
            "code": "  test('returns undefined on error', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      error: new Error('bad error'),\n      status: 0,\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('stdout'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n\n    expect(getGoBuildVersion()).toBeUndefined();\n\n    spawnSyncMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Windows",
            "suites": [
                "getGoBuildVersion"
            ],
            "updatePoint": {
                "line": 140,
                "column": 15
            },
            "line": 140,
            "code": "  test('Windows', () => {\n    const spawnSyncMock = jest.spyOn(child_process, 'spawnSync').mockReturnValue({\n      status: 0,\n      stderr: Buffer.from('stderr'),\n      stdout: Buffer.from('go version go1.15 windows/amd64'),\n      pid: 123,\n      output: ['stdout', 'stderr'],\n      signal: null,\n    });\n    const osPlatformMock = jest.spyOn(os, 'platform').mockReturnValue('win32');\n\n    expect(getGoBuildVersion()).toBe(true);\n    expect(spawnSyncMock).toHaveBeenCalledWith('go', expect.any(Array));\n\n    spawnSyncMock.mockRestore();\n    osPlatformMock.mockRestore();\n  });",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-go/test"
        },
        {
            "name": "Bundling a function without dependencies",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 46
            },
            "line": 27,
            "code": "test('Bundling a function without dependencies', () => {\n  const entry = path.join(__dirname, 'lambda-handler-nodeps');\n  const assetCode = Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    architecture: Architecture.X86_64,\n  });\n\n  // Correctly bundles\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output && cd /asset-output',\n      ],\n    }),\n  }));\n\n  expect(DockerImage.fromBuild).toHaveBeenCalledWith(expect.stringMatching(path.join(__dirname, '../lib')), expect.objectContaining({\n    buildArgs: expect.objectContaining({\n      IMAGE: expect.stringMatching(/build-python/),\n    }),\n    platform: 'linux/amd64',\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with requirements.txt",
            "suites": [],
            "updatePoint": {
                "line": 56,
                "column": 47
            },
            "line": 56,
            "code": "test('Bundling a function with requirements.txt', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  const assetCode = Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    architecture: Architecture.X86_64,\n  });\n\n  // Correctly bundles\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output && cd /asset-output && python -m pip install -r requirements.txt -t /asset-output',\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('requirements.txt');\n  expect(files).toContain('.ignorelist');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with requirements.txt using assetExcludes",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 67
            },
            "line": 80,
            "code": "test('Bundling a function with requirements.txt using assetExcludes', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  const assetCode = Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    architecture: Architecture.X86_64,\n    assetExcludes: ['.ignorelist'],\n  });\n\n  // Correctly bundles\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        \"rsync -rLv --exclude='.ignorelist' /asset-input/ /asset-output && cd /asset-output && python -m pip install -r requirements.txt -t /asset-output\",\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('requirements.txt');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling Python 2.7 with requirements.txt installed",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 57
            },
            "line": 104,
            "code": "test('Bundling Python 2.7 with requirements.txt installed', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_2_7,\n    architecture: Architecture.X86_64,\n  });\n\n  // Correctly bundles with requirements.txt pip installed\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output && cd /asset-output && python -m pip install -r requirements.txt -t /asset-output',\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling Python 2.7 with requirements.txt installed",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 57
            },
            "line": 123,
            "code": "test('Bundling Python 2.7 with requirements.txt installed', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_2_7,\n    architecture: Architecture.X86_64,\n  });\n\n  // Correctly bundles with requirements.txt pip installed\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output && cd /asset-output && python -m pip install -r requirements.txt -t /asset-output',\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a layer with dependencies",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 40
            },
            "line": 142,
            "code": "test('Bundling a layer with dependencies', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python && python -m pip install -r requirements.txt -t /asset-output/python',\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a python code layer",
            "suites": [],
            "updatePoint": {
                "line": 162,
                "column": 34
            },
            "line": 162,
            "code": "test('Bundling a python code layer', () => {\n  const entry = path.join(__dirname, 'lambda-handler-nodeps');\n\n  Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python',\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with pipenv dependencies",
            "suites": [],
            "updatePoint": {
                "line": 182,
                "column": 50
            },
            "line": 182,
            "code": "test('Bundling a function with pipenv dependencies', () => {\n  const entry = path.join(__dirname, 'lambda-handler-pipenv');\n\n  const assetCode = Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python && PIPENV_VENV_IN_PROJECT=1 pipenv lock -r > requirements.txt && rm -rf .venv && python -m pip install -r requirements.txt -t /asset-output/python',\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('Pipfile');\n  expect(files).toContain('Pipfile.lock');\n  // Contains hidden files.\n  expect(files).toContain('.ignorefile');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with pipenv dependencies with assetExcludes",
            "suites": [],
            "updatePoint": {
                "line": 209,
                "column": 69
            },
            "line": 209,
            "code": "test('Bundling a function with pipenv dependencies with assetExcludes', () => {\n  const entry = path.join(__dirname, 'lambda-handler-pipenv');\n\n  const assetCode = Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n    assetExcludes: ['.ignorefile'],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        \"rsync -rLv --exclude='.ignorefile' /asset-input/ /asset-output/python && cd /asset-output/python && PIPENV_VENV_IN_PROJECT=1 pipenv lock -r > requirements.txt && rm -rf .venv && python -m pip install -r requirements.txt -t /asset-output/python\",\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('Pipfile');\n  expect(files).toContain('Pipfile.lock');\n  // Contains hidden files.\n  expect(files).toContain('.ignorefile');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with poetry dependencies",
            "suites": [],
            "updatePoint": {
                "line": 237,
                "column": 50
            },
            "line": 237,
            "code": "test('Bundling a function with poetry dependencies', () => {\n  const entry = path.join(__dirname, 'lambda-handler-poetry');\n\n  const assetCode = Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python && poetry export --without-hashes --with-credentials --format requirements.txt --output requirements.txt && python -m pip install -r requirements.txt -t /asset-output/python',\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('pyproject.toml');\n  expect(files).toContain('poetry.lock');\n  // Contains hidden files.\n  expect(files).toContain('.ignorefile');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with poetry and assetExcludes",
            "suites": [],
            "updatePoint": {
                "line": 264,
                "column": 55
            },
            "line": 264,
            "code": "test('Bundling a function with poetry and assetExcludes', () => {\n  const entry = path.join(__dirname, 'lambda-handler-poetry');\n\n  Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n    assetExcludes: ['.ignorefile'],\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        \"rsync -rLv --exclude='.ignorefile' /asset-input/ /asset-output/python && cd /asset-output/python && poetry export --without-hashes --with-credentials --format requirements.txt --output requirements.txt && python -m pip install -r requirements.txt -t /asset-output/python\",\n      ],\n    }),\n  }));\n\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with poetry and no assetExcludes",
            "suites": [],
            "updatePoint": {
                "line": 286,
                "column": 58
            },
            "line": 286,
            "code": "test('Bundling a function with poetry and no assetExcludes', () => {\n  const entry = path.join(__dirname, 'lambda-handler-poetry');\n\n  Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        expect.not.stringContaining('--exclude'),\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with poetry dependencies, with hashes",
            "suites": [],
            "updatePoint": {
                "line": 306,
                "column": 63
            },
            "line": 306,
            "code": "test('Bundling a function with poetry dependencies, with hashes', () => {\n  const entry = path.join(__dirname, 'lambda-handler-poetry');\n\n  const assetCode = Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n    poetryIncludeHashes: true,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python && poetry export --with-credentials --format requirements.txt --output requirements.txt && python -m pip install -r requirements.txt -t /asset-output/python',\n      ],\n    }),\n  }));\n\n  const files = fs.readdirSync(assetCode.path);\n  expect(files).toContain('index.py');\n  expect(files).toContain('pyproject.toml');\n  expect(files).toContain('poetry.lock');\n  // Contains hidden files.\n  expect(files).toContain('.ignorefile');\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a function with custom bundling image",
            "suites": [],
            "updatePoint": {
                "line": 334,
                "column": 52
            },
            "line": 334,
            "code": "test('Bundling a function with custom bundling image', () => {\n  const entry = path.join(__dirname, 'lambda-handler-custom-build');\n  const image = DockerImage.fromBuild(path.join(entry));\n\n  Bundling.bundle({\n    entry: path.join(entry, '.'),\n    runtime: Runtime.PYTHON_3_9,\n    architecture: Architecture.X86_64,\n    outputPathSuffix: 'python',\n    image,\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      image,\n      command: [\n        'bash', '-c',\n        'rsync -rLv /asset-input/ /asset-output/python && cd /asset-output/python && python -m pip install -r requirements.txt -t /asset-output/python',\n      ],\n    }),\n  }));\n\n  expect(DockerImage.fromBuild).toHaveBeenCalledTimes(1);\n  expect(DockerImage.fromBuild).toHaveBeenCalledWith(expect.stringMatching(entry));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom build args",
            "suites": [],
            "updatePoint": {
                "line": 360,
                "column": 37
            },
            "line": 360,
            "code": "test('Bundling with custom build args', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  const testPypi = 'https://test.pypi.org/simple/';\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    buildArgs: { PIP_INDEX_URL: testPypi },\n  });\n\n  expect(DockerImage.fromBuild).toHaveBeenCalledWith(expect.stringMatching(path.join(__dirname, '../lib')), expect.objectContaining({\n    buildArgs: expect.objectContaining({\n      PIP_INDEX_URL: testPypi,\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom environment vars`",
            "suites": [],
            "updatePoint": {
                "line": 376,
                "column": 44
            },
            "line": 376,
            "code": "test('Bundling with custom environment vars`', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    environment: {\n      KEY: 'value',\n    },\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      environment: {\n        KEY: 'value',\n      },\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with volumes from other container",
            "suites": [],
            "updatePoint": {
                "line": 395,
                "column": 48
            },
            "line": 395,
            "code": "test('Bundling with volumes from other container', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    volumesFrom: ['777f7dc92da7'],\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      volumesFrom: ['777f7dc92da7'],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom volume paths",
            "suites": [],
            "updatePoint": {
                "line": 411,
                "column": 39
            },
            "line": 411,
            "code": "test('Bundling with custom volume paths', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      volumes: [{ hostPath: '/host-path', containerPath: '/container-path' }],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom working directory",
            "suites": [],
            "updatePoint": {
                "line": 427,
                "column": 44
            },
            "line": 427,
            "code": "test('Bundling with custom working directory', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    workingDirectory: '/my-dir',\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      workingDirectory: '/my-dir',\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom user",
            "suites": [],
            "updatePoint": {
                "line": 443,
                "column": 31
            },
            "line": 443,
            "code": "test('Bundling with custom user', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    user: 'user:group',\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      user: 'user:group',\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom securityOpt",
            "suites": [],
            "updatePoint": {
                "line": 459,
                "column": 38
            },
            "line": 459,
            "code": "test('Bundling with custom securityOpt', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    securityOpt: 'no-new-privileges',\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      securityOpt: 'no-new-privileges',\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with custom network",
            "suites": [],
            "updatePoint": {
                "line": 475,
                "column": 34
            },
            "line": 475,
            "code": "test('Bundling with custom network', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    network: 'host',\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      network: 'host',\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling with docker copy variant",
            "suites": [],
            "updatePoint": {
                "line": 491,
                "column": 39
            },
            "line": 491,
            "code": "test('Bundling with docker copy variant', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      bundlingFileAccess: BundlingFileAccess.VOLUME_COPY,\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Do not build docker image when skipping bundling",
            "suites": [],
            "updatePoint": {
                "line": 507,
                "column": 54
            },
            "line": 507,
            "code": "test('Do not build docker image when skipping bundling', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    skip: true,\n  });\n\n  expect(DockerImage.fromBuild).not.toHaveBeenCalled();\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Build docker image when bundling is not skipped",
            "suites": [],
            "updatePoint": {
                "line": 518,
                "column": 53
            },
            "line": 518,
            "code": "test('Build docker image when bundling is not skipped', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    skip: false,\n  });\n\n  expect(DockerImage.fromBuild).toHaveBeenCalled();\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "with command hooks",
            "suites": [],
            "updatePoint": {
                "line": 529,
                "column": 24
            },
            "line": 529,
            "code": "test('with command hooks', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  Bundling.bundle({\n    entry: entry,\n    runtime: Runtime.PYTHON_3_7,\n    skip: false,\n    commandHooks: {\n      beforeBundling(inputDir: string, outputDir: string): string[] {\n        return [\n          `echo hello > ${inputDir}/a.txt`,\n          `cp ${inputDir}/a.txt ${outputDir}`,\n        ];\n      },\n      afterBundling(inputDir: string, outputDir: string): string[] {\n        return [`cp ${inputDir}/b.txt ${outputDir}/txt`];\n      },\n    },\n  });\n\n  expect(Code.fromAsset).toHaveBeenCalledWith(entry, expect.objectContaining({\n    bundling: expect.objectContaining({\n      command: [\n        'bash', '-c',\n        expect.stringMatching(/^echo hello > \\/asset-input\\/a.txt && cp \\/asset-input\\/a.txt \\/asset-output && .+ && cp \\/asset-input\\/b.txt \\/asset-output\\/txt$/),\n      ],\n    }),\n  }));\n});",
            "file": "bundling.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "PythonFunction with defaults",
            "suites": [],
            "updatePoint": {
                "line": 48,
                "column": 34
            },
            "line": 48,
            "code": "test('PythonFunction with defaults', () => {\n  new PythonFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler'),\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-python\\/test\\/lambda-handler$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'index.handler',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "PythonFunction with index in a subdirectory",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 49
            },
            "line": 63,
            "code": "test('PythonFunction with index in a subdirectory', () => {\n  new PythonFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-sub'),\n    index: 'inner/custom_index.py',\n    handler: 'custom_handler',\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-python\\/test\\/lambda-handler-sub$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'inner.custom_index.custom_handler',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "PythonFunction with index in a nested subdirectory",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 56
            },
            "line": 80,
            "code": "test('PythonFunction with index in a nested subdirectory', () => {\n  new PythonFunction(stack, 'handler', {\n    entry: path.join(__dirname, 'lambda-handler-sub-nested'),\n    index: 'inner/inner2/custom_index.py',\n    handler: 'custom_handler',\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry: expect.stringMatching(/aws-lambda-python\\/test\\/lambda-handler-sub-nested$/),\n  }));\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Handler: 'inner.inner2.custom_index.custom_handler',\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "throws when index is not py",
            "suites": [],
            "updatePoint": {
                "line": 97,
                "column": 33
            },
            "line": 97,
            "code": "test('throws when index is not py', () => {\n  expect(() => new PythonFunction(stack, 'Fn', {\n    entry: path.join(__dirname, 'lambda-handler'),\n    index: 'index.js',\n    runtime: Runtime.PYTHON_3_8,\n  })).toThrow(/Only Python \\(\\.py\\) index files are supported/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "throws when entry does not exist",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 38
            },
            "line": 105,
            "code": "test('throws when entry does not exist', () => {\n  expect(() => new PythonFunction(stack, 'Fn', {\n    entry: 'notfound',\n    runtime: Runtime.PYTHON_3_8,\n  })).toThrow(/Cannot find index file at/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "throws with the wrong runtime family",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 42
            },
            "line": 112,
            "code": "test('throws with the wrong runtime family', () => {\n  expect(() => new PythonFunction(stack, 'handler1', {\n    entry: path.join(__dirname, 'lambda-handler'),\n    runtime: Runtime.NODEJS_14_X,\n  })).toThrow(/Only `PYTHON` runtimes are supported/);\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "allows specifying hash type",
            "suites": [],
            "updatePoint": {
                "line": 119,
                "column": 33
            },
            "line": 119,
            "code": "test('allows specifying hash type', () => {\n  new PythonFunction(stack, 'source1', {\n    entry: path.join(__dirname, 'lambda-handler-nodeps'),\n    index: 'index.py',\n    handler: 'handler',\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  new PythonFunction(stack, 'source2', {\n    entry: path.join(__dirname, 'lambda-handler-nodeps'),\n    index: 'index.py',\n    handler: 'handler',\n    runtime: Runtime.PYTHON_3_8,\n    bundling: { assetHashType: AssetHashType.SOURCE },\n  });\n\n  new PythonFunction(stack, 'output', {\n    entry: path.join(__dirname, 'lambda-handler-nodeps'),\n    index: 'index.py',\n    handler: 'handler',\n    runtime: Runtime.PYTHON_3_8,\n    bundling: { assetHashType: AssetHashType.OUTPUT },\n  });\n\n  new PythonFunction(stack, 'custom', {\n    entry: path.join(__dirname, 'lambda-handler-nodeps'),\n    index: 'index.py',\n    handler: 'handler',\n    runtime: Runtime.PYTHON_3_8,\n    bundling: { assetHash: 'MY_CUSTOM_HASH' },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Code: {\n      S3Bucket: 'mock-bucket-name',\n      S3Key: 'SOURCE_MOCK',\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Code: {\n      S3Bucket: 'mock-bucket-name',\n      S3Key: 'OUTPUT_MOCK',\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Lambda::Function', {\n    Code: {\n      S3Bucket: 'mock-bucket-name',\n      S3Key: 'MY_CUSTOM_HASH',\n    },\n  });\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Allows use of custom bundling image",
            "suites": [],
            "updatePoint": {
                "line": 173,
                "column": 41
            },
            "line": 173,
            "code": "test('Allows use of custom bundling image', () => {\n  const entry = path.join(__dirname, 'lambda-handler-custom-build');\n  const image = DockerImage.fromBuild(path.join(entry));\n\n  new PythonFunction(stack, 'function', {\n    entry,\n    runtime: Runtime.PYTHON_3_8,\n    bundling: { image },\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    image,\n  }));\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Skip bundling when stack does not require it",
            "suites": [],
            "updatePoint": {
                "line": 188,
                "column": 50
            },
            "line": 188,
            "code": "test('Skip bundling when stack does not require it', () => {\n  const spy = jest.spyOn(stack, 'bundlingRequired', 'get').mockReturnValue(false);\n  const entry = path.join(__dirname, 'lambda-handler');\n\n  new PythonFunction(stack, 'function', {\n    entry,\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    skip: true,\n  }));\n\n  spy.mockRestore();\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Do not skip bundling when stack requires it",
            "suites": [],
            "updatePoint": {
                "line": 204,
                "column": 49
            },
            "line": 204,
            "code": "test('Do not skip bundling when stack requires it', () => {\n  const spy = jest.spyOn(stack, 'bundlingRequired', 'get').mockReturnValue(true);\n  const entry = path.join(__dirname, 'lambda-handler');\n\n  new PythonFunction(stack, 'function', {\n    entry,\n    runtime: Runtime.PYTHON_3_8,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    skip: false,\n  }));\n\n  spy.mockRestore();\n});",
            "file": "function.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Bundling a layer from files",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 33
            },
            "line": 32,
            "code": "test('Bundling a layer from files', () => {\n  const entry = path.join(__dirname, 'test/lambda-handler-project');\n  new PythonLayerVersion(stack, 'layer', {\n    entry,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    entry,\n    outputPathSuffix: 'python',\n  }));\n});",
            "file": "layer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Fails when bundling a layer for a runtime not supported",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 61
            },
            "line": 44,
            "code": "test('Fails when bundling a layer for a runtime not supported', () => {\n  expect(() => {\n    new PythonLayerVersion(stack, 'layer', {\n      entry: '/some/path',\n      compatibleRuntimes: [Runtime.PYTHON_2_7, Runtime.NODEJS],\n    });\n  }).toThrow(/PYTHON.*support/);\n});",
            "file": "layer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Allows use of custom bundling image",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 41
            },
            "line": 53,
            "code": "test('Allows use of custom bundling image', () => {\n  const entry = path.join(__dirname, 'lambda-handler-custom-build');\n  const image = DockerImage.fromBuild(path.join(entry));\n\n  new PythonLayerVersion(stack, 'layer', {\n    entry,\n    bundling: { image },\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    image,\n  }));\n});",
            "file": "layer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Skip bundling when stack does not require it",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 50
            },
            "line": 67,
            "code": "test('Skip bundling when stack does not require it', () => {\n  const spy = jest.spyOn(stack, 'bundlingRequired', 'get').mockReturnValue(false);\n  const entry = path.join(__dirname, 'lambda-handler-project');\n\n  new PythonLayerVersion(stack, 'layer', {\n    entry,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    skip: true,\n  }));\n\n  spy.mockRestore();\n});",
            "file": "layer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Do not skip bundling when stack requires it",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 49
            },
            "line": 82,
            "code": "test('Do not skip bundling when stack requires it', () => {\n  const spy = jest.spyOn(stack, 'bundlingRequired', 'get').mockReturnValue(true);\n  const entry = path.join(__dirname, 'lambda-handler-project');\n\n  new PythonLayerVersion(stack, 'layer', {\n    entry,\n  });\n\n  expect(Bundling.bundle).toHaveBeenCalledWith(expect.objectContaining({\n    skip: false,\n  }));\n\n  spy.mockRestore();\n});",
            "file": "layer.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Packaging with no dependencies",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 36
            },
            "line": 4,
            "code": "test('Packaging with no dependencies', () => {\n  const entry = path.join(__dirname, 'lambda-handler-nodeps');\n  const packaging = Packaging.fromEntry(entry);\n\n  // pip packaging identified.\n  expect(packaging).toEqual(Packaging.withNoPackaging());\n});",
            "file": "packaging.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Packaging with requirements.txt",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 37
            },
            "line": 12,
            "code": "test('Packaging with requirements.txt', () => {\n  const entry = path.join(__dirname, 'lambda-handler');\n  const packaging = Packaging.fromEntry(entry);\n\n  // pip packaging identified.\n  expect(packaging).toEqual(Packaging.withPip());\n});",
            "file": "packaging.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Packaging with pipenv",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 27
            },
            "line": 20,
            "code": "test('Packaging with pipenv', () => {\n  const entry = path.join(__dirname, 'lambda-handler-pipenv');\n  const packaging = Packaging.fromEntry(entry);\n\n  // pip packaging identified.\n  expect(packaging).toEqual(Packaging.withPipenv());\n});",
            "file": "packaging.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "Packaging with poetry",
            "suites": [],
            "updatePoint": {
                "line": 28,
                "column": 27
            },
            "line": 28,
            "code": "test('Packaging with poetry', () => {\n  const entry = path.join(__dirname, 'lambda-handler-poetry');\n  const packaging = Packaging.fromEntry(entry);\n\n  // pip packaging identified.\n  expect(packaging).toEqual(Packaging.withPoetry());\n});",
            "file": "packaging.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-lambda-python/test"
        },
        {
            "name": "create a place index",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 26
            },
            "line": 11,
            "code": "test('create a place index', () => {\n  new PlaceIndex(stack, 'PlaceIndex');\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Location::PlaceIndex', {\n    DataSource: 'Esri',\n    IndexName: 'PlaceIndex',\n  });\n});",
            "file": "place-index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-location/test"
        },
        {
            "name": "throws with invalid name",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 30
            },
            "line": 20,
            "code": "test('throws with invalid name', () => {\n  expect(() => new PlaceIndex(stack, 'PlaceIndex', {\n    placeIndexName: 'inv@lid',\n  })).toThrow(/Invalid place index name/);\n});",
            "file": "place-index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-location/test"
        },
        {
            "name": "grant search actions",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 26
            },
            "line": 26,
            "code": "test('grant search actions', () => {\n  const placeIndex = new PlaceIndex(stack, 'PlaceIndex', {\n    dataSource: DataSource.HERE,\n    intendedUse: IntendedUse.STORAGE,\n  });\n\n  const role = new iam.Role(stack, 'Role', {\n    assumedBy: new iam.ServicePrincipal('foo'),\n  });\n\n  placeIndex.grantSearch(role);\n\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', Match.objectLike({\n    PolicyDocument: Match.objectLike({\n      Statement: [\n        {\n          Action: [\n            'geo:SearchPlaceIndexForPosition',\n            'geo:SearchPlaceIndexForSuggestions',\n            'geo:SearchPlaceIndexForText',\n          ],\n          Effect: 'Allow',\n          Resource: {\n            'Fn::GetAtt': [\n              'PlaceIndex21B3574E',\n              'Arn',\n            ],\n          },\n        },\n      ],\n    }),\n  }));\n});",
            "file": "place-index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-location/test"
        },
        {
            "name": "import from arn",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 21
            },
            "line": 60,
            "code": "test('import from arn', () => {\n  const placeIndexArn = stack.formatArn({\n    service: 'geo',\n    resource: 'place-index',\n    resourceName: 'MyPlaceIndex',\n  });\n  const placeIndex = PlaceIndex.fromPlaceIndexArn(stack, 'PlaceIndex', placeIndexArn);\n\n  // THEN\n  expect(placeIndex.placeIndexName).toEqual('MyPlaceIndex');\n  expect(placeIndex.placeIndexArn).toEqual(placeIndexArn);\n});",
            "file": "place-index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-location/test"
        },
        {
            "name": "import from name",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 22
            },
            "line": 73,
            "code": "test('import from name', () => {\n  // WHEN\n  const placeIndexName = 'MyPlaceIndex';\n  const placeIndex = PlaceIndex.fromPlaceIndexName(stack, 'PlaceIndex', placeIndexName);\n\n  // THEN\n  expect(placeIndex.placeIndexName).toEqual(placeIndexName);\n  expect(placeIndex.placeIndexArn).toEqual(stack.formatArn({\n    service: 'geo',\n    resource: 'place-index',\n    resourceName: 'MyPlaceIndex',\n  }));\n});",
            "file": "place-index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-location/test"
        },
        {
            "name": "created with expected Kafka version %j",
            "suites": [
                "MSK Cluster"
            ],
            "line": 25,
            "code": "  test.each([\n    [msk.KafkaVersion.V1_1_1, '1.1.1'],\n    [msk.KafkaVersion.V2_2_1, '2.2.1'],\n    [msk.KafkaVersion.V2_3_1, '2.3.1'],\n    [msk.KafkaVersion.V2_4_1_1, '2.4.1.1'],\n    [msk.KafkaVersion.V2_5_1, '2.5.1'],\n    [msk.KafkaVersion.V2_6_0, '2.6.0'],\n    [msk.KafkaVersion.V2_6_1, '2.6.1'],\n    [msk.KafkaVersion.V2_6_2, '2.6.2'],\n    [msk.KafkaVersion.V2_6_3, '2.6.3'],\n    [msk.KafkaVersion.V2_7_0, '2.7.0'],\n    [msk.KafkaVersion.V2_7_1, '2.7.1'],\n    [msk.KafkaVersion.V2_7_2, '2.7.2'],\n    [msk.KafkaVersion.V2_8_0, '2.8.0'],\n    [msk.KafkaVersion.V2_8_1, '2.8.1'],\n    [msk.KafkaVersion.V3_1_1, '3.1.1'],\n    [msk.KafkaVersion.V3_2_0, '3.2.0'],\n    [msk.KafkaVersion.V3_3_1, '3.3.1'],\n    [msk.KafkaVersion.V3_3_2, '3.3.2'],\n  ],\n  )('created with expected Kafka version %j', (parameter, result) => {\n    new msk.Cluster(stack, 'Cluster', {\n      clusterName: 'cluster',\n      kafkaVersion: parameter,\n      vpc,\n    });\n\n    Template.fromStack(stack).hasResource(\n      'AWS::MSK::Cluster', {},\n    );\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      KafkaVersion: result,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "created with default properties",
            "suites": [
                "MSK Cluster"
            ],
            "updatePoint": {
                "line": 60,
                "column": 39
            },
            "line": 60,
            "code": "  test('created with default properties', () => {\n    new msk.Cluster(stack, 'Cluster', {\n      clusterName: 'cluster',\n      kafkaVersion: msk.KafkaVersion.V2_6_1,\n      vpc,\n    });\n\n    Template.fromStack(stack).hasResource(\n      'AWS::MSK::Cluster',\n      {\n        DeletionPolicy: 'Retain',\n        UpdateReplacePolicy: 'Retain',\n      },\n    );\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      KafkaVersion: '2.6.1',\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      EncryptionInfo: {\n        EncryptionInTransit: { ClientBroker: 'TLS', InCluster: true },\n      },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      NumberOfBrokerNodes: 2,\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      BrokerNodeGroupInfo: {\n        StorageInfo: { EBSStorageInfo: { VolumeSize: 1000 } },\n      },\n    });\n    Template.fromStack(stack).resourceCountIs('AWS::EC2::SecurityGroup', 1);\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      BrokerNodeGroupInfo: {\n        SecurityGroups: [\n          {\n            'Fn::GetAtt': ['ClusterSecurityGroup0921994B', 'GroupId'],\n          },\n        ],\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if client broker encryption is set to plaintext",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with tls auth"
            ],
            "updatePoint": {
                "line": 104,
                "column": 65
            },
            "line": 104,
            "code": "      test('fails if client broker encryption is set to plaintext', () => {\n        expect(\n          () =>\n            new msk.Cluster(stack, 'Cluster', {\n              clusterName: 'cluster',\n              kafkaVersion: msk.KafkaVersion.V2_6_1,\n              vpc,\n              encryptionInTransit: {\n                clientBroker: msk.ClientBrokerEncryption.PLAINTEXT,\n              },\n              clientAuthentication: msk.ClientAuthentication.tls({\n                certificateAuthorities: [\n                  acmpca.CertificateAuthority.fromCertificateAuthorityArn(\n                    stack,\n                    'CertificateAuthority',\n                    'arn:aws:acm-pca:us-west-2:1234567890:certificate-authority/11111111-1111-1111-1111-111111111111',\n                  ),\n                ],\n              }),\n            }),\n        ).toThrow(\n          'To enable client authentication, you must enabled TLS-encrypted traffic between clients and brokers.',\n        );\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if tls encryption is set to plaintext",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/scram auth"
            ],
            "updatePoint": {
                "line": 131,
                "column": 55
            },
            "line": 131,
            "code": "      test('fails if tls encryption is set to plaintext', () => {\n        expect(() => new msk.Cluster(stack, 'Cluster', {\n          clusterName: 'cluster',\n          kafkaVersion: msk.KafkaVersion.V2_6_1,\n          vpc,\n          encryptionInTransit: {\n            clientBroker: msk.ClientBrokerEncryption.PLAINTEXT,\n          },\n          clientAuthentication: msk.ClientAuthentication.sasl({\n            scram: true,\n          }),\n        }),\n        ).toThrow(\n          'To enable client authentication, you must enabled TLS-encrypted traffic between clients and brokers.',\n        );\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if tls encryption is set to tls and plaintext",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/scram auth"
            ],
            "updatePoint": {
                "line": 148,
                "column": 63
            },
            "line": 148,
            "code": "      test('fails if tls encryption is set to tls and plaintext', () => {\n        expect(\n          () =>\n            new msk.Cluster(stack, 'Cluster', {\n              clusterName: 'cluster',\n              kafkaVersion: msk.KafkaVersion.V2_6_1,\n              vpc,\n              encryptionInTransit: {\n                clientBroker: msk.ClientBrokerEncryption.TLS_PLAINTEXT,\n              },\n              clientAuthentication: msk.ClientAuthentication.sasl({\n                scram: true,\n              }),\n            }),\n        ).toThrow(\n          'To enable SASL/SCRAM or IAM authentication, you must only allow TLS-encrypted traffic between clients and brokers.',\n        );\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "iam enabled is true",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/iam auth"
            ],
            "updatePoint": {
                "line": 169,
                "column": 31
            },
            "line": 169,
            "code": "      test('iam enabled is true', () => {\n        new msk.Cluster(stack, 'Cluster', {\n          clusterName: 'cluster',\n          kafkaVersion: msk.KafkaVersion.V2_6_1,\n          vpc,\n          encryptionInTransit: {\n            clientBroker: msk.ClientBrokerEncryption.TLS,\n          },\n          clientAuthentication: msk.ClientAuthentication.sasl({\n            iam: true,\n          }),\n        });\n        Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n          ClientAuthentication: {\n            Sasl: { Iam: { Enabled: true } },\n          },\n        });\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if tls encryption is set to plaintext",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/iam auth"
            ],
            "updatePoint": {
                "line": 187,
                "column": 55
            },
            "line": 187,
            "code": "      test('fails if tls encryption is set to plaintext', () => {\n        expect(\n          () =>\n            new msk.Cluster(stack, 'Cluster', {\n              clusterName: 'cluster',\n              kafkaVersion: msk.KafkaVersion.V2_6_1,\n              vpc,\n              encryptionInTransit: {\n                clientBroker: msk.ClientBrokerEncryption.PLAINTEXT,\n              },\n              clientAuthentication: msk.ClientAuthentication.sasl({\n                iam: true,\n              }),\n            }),\n        ).toThrow(\n          'To enable client authentication, you must enabled TLS-encrypted traffic between clients and brokers.',\n        );\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if tls encryption is set to tls and plaintext",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/iam auth"
            ],
            "updatePoint": {
                "line": 206,
                "column": 63
            },
            "line": 206,
            "code": "      test('fails if tls encryption is set to tls and plaintext', () => {\n        expect(\n          () =>\n            new msk.Cluster(stack, 'Cluster', {\n              clusterName: 'cluster',\n              kafkaVersion: msk.KafkaVersion.V2_6_1,\n              vpc,\n              encryptionInTransit: {\n                clientBroker: msk.ClientBrokerEncryption.TLS_PLAINTEXT,\n              },\n              clientAuthentication: msk.ClientAuthentication.sasl({\n                iam: true,\n              }),\n            }),\n        ).toThrow(\n          'To enable SASL/SCRAM or IAM authentication, you must only allow TLS-encrypted traffic between clients and brokers.',\n        );\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "Snapshot test with all values set (iam/sasl)",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "with sasl/iam auth and tls"
            ],
            "updatePoint": {
                "line": 227,
                "column": 56
            },
            "line": 227,
            "code": "      test('Snapshot test with all values set (iam/sasl)', () => {\n        const cluster = new msk.Cluster(stack, 'kafka', {\n          clusterName: 'test-cluster',\n          kafkaVersion: msk.KafkaVersion.V2_6_1,\n          vpc,\n          securityGroups: [\n            ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg1', 'sg-123'),\n            ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg2', 'sg-456'),\n          ],\n          ebsStorageInfo: {\n            volumeSize: 100,\n            encryptionKey: kms.Key.fromKeyArn(\n              stack,\n              'kms',\n              'arn:aws:kms:us-east-1:111122223333:key/1234abc',\n            ),\n          },\n          encryptionInTransit: {\n            clientBroker: msk.ClientBrokerEncryption.TLS,\n          },\n          clientAuthentication: msk.ClientAuthentication.saslTls({\n            iam: true,\n            certificateAuthorities: [\n              acmpca.CertificateAuthority.fromCertificateAuthorityArn(\n                stack,\n                'CertificateAuthority',\n                'arn:aws:acm-pca:us-west-2:1234567890:certificate-authority/11111111-1111-1111-1111-111111111111',\n              ),\n            ],\n          }),\n          monitoring: {\n            enablePrometheusJmxExporter: true,\n            enablePrometheusNodeExporter: true,\n            clusterMonitoringLevel: msk.ClusterMonitoringLevel.PER_TOPIC_PER_BROKER,\n          },\n          logging: {\n            s3: {\n              bucket: s3.Bucket.fromBucketName(stack, 'Bucket', 'a-bucket'),\n            },\n            cloudwatchLogGroup: logs.LogGroup.fromLogGroupName(\n              stack,\n              'LogGroup',\n              'a-log-group',\n            ),\n            firehoseDeliveryStreamName: 'a-delivery-stream',\n          },\n        });\n\n        cluster.connections.allowFrom(\n          ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg3', 'sg-3'),\n          ec2.Port.tcp(2181),\n        );\n\n        // THEN\n        expect(Template.fromStack(stack)).toMatchSnapshot();\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "with alias msk/${clusterName}/sasl/scram",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "creates a customer master key"
            ],
            "updatePoint": {
                "line": 300,
                "column": 52
            },
            "line": 300,
            "code": "      test('with alias msk/${clusterName}/sasl/scram', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::KMS::Alias', {\n          AliasName: 'alias/msk/cluster/sasl/scram',\n        });\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "with a policy allowing the secrets manager service to use the key",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "creates a customer master key"
            ],
            "updatePoint": {
                "line": 306,
                "column": 77
            },
            "line": 306,
            "code": "      test('with a policy allowing the secrets manager service to use the key', () => {\n        Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {\n          KeyPolicy: {\n            'Statement': [\n              {\n                'Action': 'kms:*',\n                'Effect': 'Allow',\n                'Principal': {\n                  'AWS': {\n                    'Fn::Join': [\n                      '',\n                      [\n                        'arn:',\n                        {\n                          'Ref': 'AWS::Partition',\n                        },\n                        ':iam::',\n                        {\n                          'Ref': 'AWS::AccountId',\n                        },\n                        ':root',\n                      ],\n                    ],\n                  },\n                },\n                'Resource': '*',\n              },\n              {\n                'Action': [\n                  'kms:Encrypt',\n                  'kms:Decrypt',\n                  'kms:ReEncrypt*',\n                  'kms:GenerateDataKey*',\n                  'kms:CreateGrant',\n                  'kms:DescribeKey',\n                ],\n                'Condition': {\n                  'StringEquals': {\n                    'kms:ViaService': {\n                      'Fn::Join': [\n                        '',\n                        [\n                          'secretsmanager.',\n                          {\n                            'Ref': 'AWS::Region',\n                          },\n                          '.amazonaws.com',\n                        ],\n                      ],\n                    },\n                    'kms:CallerAccount': {\n                      'Ref': 'AWS::AccountId',\n                    },\n                  },\n                },\n                Effect: 'Allow',\n                Principal: { AWS: '*' },\n                Resource: '*',\n                Sid: 'Allow access through AWS Secrets Manager for all principals in the account that are authorized to use AWS Secrets Manager',\n              },\n            ],\n            'Version': '2012-10-17',\n          },\n        });\n      });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if more than one authentication method is enabled",
            "suites": [
                "MSK Cluster",
                "created with authentication enabled",
                "creates a customer master key"
            ],
            "updatePoint": {
                "line": 373,
                "column": 65
            },
            "line": 373,
            "code": "    test('fails if more than one authentication method is enabled', () => {\n      expect(\n        () =>\n          new msk.Cluster(stack, 'Cluster', {\n            clusterName: 'cluster',\n            kafkaVersion: msk.KafkaVersion.V2_6_1,\n            vpc,\n            encryptionInTransit: {\n              clientBroker: msk.ClientBrokerEncryption.TLS,\n            },\n            clientAuthentication: msk.ClientAuthentication.sasl({\n              iam: true,\n              scram: true,\n            }),\n          }),\n      ).toThrow('Only one client authentication method can be enabled.');\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "prefixes instance type with \"kafka\"",
            "suites": [
                "MSK Cluster",
                "created with an instance type set"
            ],
            "updatePoint": {
                "line": 393,
                "column": 45
            },
            "line": 393,
            "code": "    test('prefixes instance type with \"kafka\"', () => {\n      new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        instanceType: ec2.InstanceType.of(\n          ec2.InstanceClass.M5,\n          ec2.InstanceSize.XLARGE,\n        ),\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n        BrokerNodeGroupInfo: { InstanceType: 'kafka.m5.xlarge' },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "prefixes instance type with \"kafka\"",
            "suites": [
                "MSK Cluster",
                "created with an instance type set"
            ],
            "updatePoint": {
                "line": 410,
                "column": 43
            },
            "line": 410,
            "code": "  test('prefixes instance type with \"kafka\"', () => {\n    new msk.Cluster(stack, 'Cluster', {\n      clusterName: 'cluster',\n      kafkaVersion: msk.KafkaVersion.V2_6_1,\n      vpc,\n      instanceType: ec2.InstanceType.of(\n        ec2.InstanceClass.M5,\n        ec2.InstanceSize.XLARGE,\n      ),\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      BrokerNodeGroupInfo: { InstanceType: 'kafka.m5.xlarge' },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "log group is set",
            "suites": [
                "MSK Cluster",
                "created with logging enabled"
            ],
            "updatePoint": {
                "line": 427,
                "column": 26
            },
            "line": 427,
            "code": "    test('log group is set', () => {\n      new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        logging: {\n          cloudwatchLogGroup: new logs.LogGroup(stack, 'LogGroup'),\n        },\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n        LoggingInfo: {\n          BrokerLogs: {\n            CloudWatchLogs: {\n              Enabled: true,\n              LogGroup: {\n                Ref: 'LogGroupF5B46931',\n              },\n            },\n          },\n        },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "s3 bucket is set",
            "suites": [
                "MSK Cluster",
                "created with logging enabled"
            ],
            "updatePoint": {
                "line": 451,
                "column": 26
            },
            "line": 451,
            "code": "    test('s3 bucket is set', () => {\n      new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        logging: {\n          s3: { bucket: new s3.Bucket(stack, 'Bucket') },\n        },\n      });\n\n      Template.fromStack(stack).resourceCountIs('AWS::S3::BucketPolicy', 0);\n      Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n        LoggingInfo: {\n          BrokerLogs: {\n            S3: {\n              Bucket: {\n                Ref: 'Bucket83908E77',\n              },\n              Enabled: true,\n            },\n          },\n        },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "feature flag @aws-cdk/aws-s3:defaultBucketPolicy",
            "suites": [
                "MSK Cluster",
                "created with logging enabled"
            ],
            "updatePoint": {
                "line": 476,
                "column": 58
            },
            "line": 476,
            "code": "    test('feature flag @aws-cdk/aws-s3:defaultBucketPolicy', () => {\n      const localStack = new core.Stack();\n      localStack.node.setContext('@aws-cdk/aws-s3:createDefaultLoggingPolicy', true);\n      new msk.Cluster(localStack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc: new ec2.Vpc(localStack, 'Vpc'),\n        logging: {\n          s3: { bucket: new s3.Bucket(localStack, 'Bucket') },\n        },\n      });\n\n      Template.fromStack(localStack).hasResourceProperties('AWS::S3::BucketPolicy', {\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: 's3:PutObject',\n              Effect: 'Allow',\n              Condition: {\n                StringEquals: {\n                  's3:x-amz-acl': 'bucket-owner-full-control',\n                  'aws:SourceAccount': {\n                    Ref: 'AWS::AccountId',\n                  },\n                },\n                ArnLike: {\n                  'aws:SourceArn': {\n                    'Fn::Join': [\n                      '',\n                      [\n                        'arn:',\n                        {\n                          Ref: 'AWS::Partition',\n                        },\n                        ':logs:',\n                        {\n                          Ref: 'AWS::Region',\n                        },\n                        ':',\n                        {\n                          Ref: 'AWS::AccountId',\n                        },\n                        ':*',\n                      ],\n                    ],\n                  },\n                },\n              },\n              Principal: {\n                Service: 'delivery.logs.amazonaws.com',\n              },\n              Resource: {\n                'Fn::Join': [\n                  '',\n                  [\n                    {\n                      'Fn::GetAtt': [\n                        'Bucket83908E77',\n                        'Arn',\n                      ],\n                    },\n                    '/AWSLogs/',\n                    {\n                      Ref: 'AWS::AccountId',\n                    },\n                    '/*',\n                  ],\n                ],\n              },\n            },\n            {\n              Action: [\n                's3:GetBucketAcl',\n                's3:ListBucket',\n              ],\n              Condition: {\n                StringEquals: {\n                  'aws:SourceAccount': {\n                    Ref: 'AWS::AccountId',\n                  },\n                },\n                ArnLike: {\n                  'aws:SourceArn': {\n                    'Fn::Join': [\n                      '',\n                      [\n                        'arn:',\n                        {\n                          Ref: 'AWS::Partition',\n                        },\n                        ':logs:',\n                        {\n                          Ref: 'AWS::Region',\n                        },\n                        ':',\n                        {\n                          Ref: 'AWS::AccountId',\n                        },\n                        ':*',\n                      ],\n                    ],\n                  },\n                },\n              },\n              Effect: 'Allow',\n              Principal: {\n                Service: 'delivery.logs.amazonaws.com',\n              },\n              Resource: {\n                'Fn::GetAtt': [\n                  'Bucket83908E77',\n                  'Arn',\n                ],\n              },\n            },\n          ],\n        },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "firehose delivery stream is set",
            "suites": [
                "MSK Cluster",
                "created with logging enabled"
            ],
            "updatePoint": {
                "line": 596,
                "column": 41
            },
            "line": 596,
            "code": "    test('firehose delivery stream is set', () => {\n      new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        logging: {\n          firehoseDeliveryStreamName: 'a-stream',\n        },\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n        LoggingInfo: {\n          BrokerLogs: {\n            Firehose: {\n              DeliveryStream: 'a-stream',\n              Enabled: true,\n            },\n          },\n        },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "exceeds max",
            "suites": [
                "MSK Cluster",
                "ebs volume size is within bounds"
            ],
            "updatePoint": {
                "line": 620,
                "column": 21
            },
            "line": 620,
            "code": "    test('exceeds max', () => {\n      expect(() => new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        ebsStorageInfo: { volumeSize: 16385 },\n      })).toThrow(\n        'EBS volume size should be in the range 1-16384',\n      );\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "below minimum",
            "suites": [
                "MSK Cluster",
                "ebs volume size is within bounds"
            ],
            "updatePoint": {
                "line": 631,
                "column": 23
            },
            "line": 631,
            "code": "    test('below minimum', () => {\n      expect(() => new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        ebsStorageInfo: { volumeSize: 0 },\n      })).toThrow(\n        'EBS volume size should be in the range 1-16384',\n      );\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "create an encrypted cluster with a custom KMS key",
            "suites": [
                "MSK Cluster",
                "ebs volume size is within bounds"
            ],
            "updatePoint": {
                "line": 643,
                "column": 57
            },
            "line": 643,
            "code": "  test('create an encrypted cluster with a custom KMS key', () => {\n    new msk.Cluster(stack, 'Cluster', {\n      clusterName: 'cluster',\n      kafkaVersion: msk.KafkaVersion.V2_6_1,\n      vpc,\n      ebsStorageInfo: { encryptionKey: new kms.Key(stack, 'Key') },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::MSK::Cluster', {\n      EncryptionInfo: {\n        EncryptionAtRest: {\n          DataVolumeKMSKeyId: {\n            Ref: 'Key961B73FD',\n          },\n        },\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "cluster name is set",
            "suites": [
                "MSK Cluster",
                "importing an existing cluster with an ARN"
            ],
            "updatePoint": {
                "line": 670,
                "column": 29
            },
            "line": 670,
            "code": "    test('cluster name is set', () => {\n      expect(cluster.clusterName).toEqual('a-cluster');\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "cluster arn is set",
            "suites": [
                "MSK Cluster",
                "importing an existing cluster with an ARN"
            ],
            "updatePoint": {
                "line": 674,
                "column": 28
            },
            "line": 674,
            "code": "    test('cluster arn is set', () => {\n      expect(cluster.clusterArn).toEqual(clusterArn);\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "Snapshot test with all values set",
            "suites": [
                "MSK Cluster",
                "importing an existing cluster with an ARN"
            ],
            "updatePoint": {
                "line": 679,
                "column": 41
            },
            "line": 679,
            "code": "  test('Snapshot test with all values set', () => {\n    const cluster = new msk.Cluster(stack, 'kafka', {\n      clusterName: 'test-cluster',\n      kafkaVersion: msk.KafkaVersion.V2_6_1,\n      vpc,\n      securityGroups: [\n        ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg1', 'sg-123'),\n        ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg2', 'sg-456'),\n      ],\n      ebsStorageInfo: {\n        volumeSize: 100,\n        encryptionKey: kms.Key.fromKeyArn(\n          stack,\n          'kms',\n          'arn:aws:kms:us-east-1:111122223333:key/1234abc',\n        ),\n      },\n      encryptionInTransit: {\n        clientBroker: msk.ClientBrokerEncryption.TLS,\n      },\n      clientAuthentication: msk.ClientAuthentication.tls({\n        certificateAuthorities: [\n          acmpca.CertificateAuthority.fromCertificateAuthorityArn(\n            stack,\n            'CertificateAuthority',\n            'arn:aws:acm-pca:us-west-2:1234567890:certificate-authority/11111111-1111-1111-1111-111111111111',\n          ),\n        ],\n      }),\n      monitoring: {\n        enablePrometheusJmxExporter: true,\n        enablePrometheusNodeExporter: true,\n        clusterMonitoringLevel: msk.ClusterMonitoringLevel.PER_TOPIC_PER_BROKER,\n      },\n      logging: {\n        s3: {\n          bucket: s3.Bucket.fromBucketName(stack, 'Bucket', 'a-bucket'),\n        },\n        cloudwatchLogGroup: logs.LogGroup.fromLogGroupName(\n          stack,\n          'LogGroup',\n          'a-log-group',\n        ),\n        firehoseDeliveryStreamName: 'a-delivery-stream',\n      },\n    });\n\n    cluster.connections.allowFrom(\n      ec2.SecurityGroup.fromSecurityGroupId(stack, 'sg3', 'sg-3'),\n      ec2.Port.tcp(2181),\n    );\n\n    // THEN\n    expect(Template.fromStack(stack)).toMatchSnapshot();\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "fails if sasl/scram not enabled",
            "suites": [
                "MSK Cluster",
                "when creating sasl/scram users"
            ],
            "updatePoint": {
                "line": 736,
                "column": 41
            },
            "line": 736,
            "code": "    test('fails if sasl/scram not enabled', () => {\n      const cluster = new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n      });\n\n      expect(() => cluster.addUser('my-user')).toThrow(\n        'Cannot create users if an authentication KMS key has not been created/provided.',\n      );\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "creates a secret with the secret name prefixed with AmazonMSK_",
            "suites": [
                "MSK Cluster",
                "when creating sasl/scram users"
            ],
            "updatePoint": {
                "line": 748,
                "column": 72
            },
            "line": 748,
            "code": "    test('creates a secret with the secret name prefixed with AmazonMSK_', () => {\n      const cluster = new msk.Cluster(stack, 'Cluster', {\n        clusterName: 'cluster',\n        kafkaVersion: msk.KafkaVersion.V2_6_1,\n        vpc,\n        clientAuthentication: msk.ClientAuthentication.sasl({\n          scram: true,\n        }),\n      });\n\n      const username = 'my-user';\n      cluster.addUser(username);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n        'Name': {\n          'Fn::Join': [\n            '',\n            [\n              'AmazonMSK_',\n              {\n                'Fn::Select': [\n                  1,\n                  {\n                    'Fn::Split': [\n                      '/',\n                      {\n                        'Ref': 'ClusterEB0386A7',\n                      },\n                    ],\n                  },\n                ],\n              },\n              '_my-user',\n            ],\n          ],\n        },\n      });\n    });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-msk/test"
        },
        {
            "name": "check that instantiation works",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 13,
                "column": 38
            },
            "line": 13,
            "code": "  test('check that instantiation works', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResource('AWS::Neptune::DBCluster', {\n      Properties: {\n        DBSubnetGroupName: { Ref: 'DatabaseSubnets3C9252C9' },\n        VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['DatabaseSecurityGroup5C91FDCB', 'GroupId'] }],\n        StorageEncrypted: true,\n      },\n      DeletionPolicy: 'Retain',\n      UpdateReplacePolicy: 'Retain',\n    });\n\n    Template.fromStack(stack).hasResource('AWS::Neptune::DBInstance', {\n      DeletionPolicy: 'Retain',\n      UpdateReplacePolicy: 'Retain',\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBSubnetGroup', {\n      SubnetIds: [\n        { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n        { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n        { Ref: 'VPCPrivateSubnet3Subnet3EDCD457' },\n      ],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "can create a cluster with a single instance",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 49,
                "column": 51
            },
            "line": 49,
            "code": "  test('can create a cluster with a single instance', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      instances: 1,\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      DBSubnetGroupName: { Ref: 'DatabaseSubnets3C9252C9' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['DatabaseSecurityGroup5C91FDCB', 'GroupId'] }],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "errors when less than one instance is specified",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 68,
                "column": 55
            },
            "line": 68,
            "code": "  test('errors when less than one instance is specified', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    expect(() => {\n      new DatabaseCluster(stack, 'Database', {\n        instances: 0,\n        vpc,\n        instanceType: InstanceType.R5_LARGE,\n      });\n    }).toThrowError('At least one instance is required');\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "errors when only one subnet is specified",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 83,
                "column": 48
            },
            "line": 83,
            "code": "  test('errors when only one subnet is specified', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC', {\n      maxAzs: 1,\n    });\n\n    // WHEN\n    expect(() => {\n      new DatabaseCluster(stack, 'Database', {\n        instances: 1,\n        vpc,\n        vpcSubnets: {\n          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,\n        },\n        instanceType: InstanceType.R5_LARGE,\n      });\n    }).toThrowError('Cluster requires at least 2 subnets, got 1');\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "can create a cluster with custom engine version",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 103,
                "column": 55
            },
            "line": 103,
            "code": "  test('can create a cluster with custom engine version', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      engineVersion: EngineVersion.V1_0_4_1,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      EngineVersion: '1.0.4.1',\n      DBSubnetGroupName: { Ref: 'DatabaseSubnets3C9252C9' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['DatabaseSecurityGroup5C91FDCB', 'GroupId'] }],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "can create a cluster for engine version %s",
            "suites": [
                "DatabaseCluster"
            ],
            "line": 123,
            "code": "  test.each([\n    ['1.1.1.0', EngineVersion.V1_1_1_0], ['1.2.0.0', EngineVersion.V1_2_0_0],\n  ])('can create a cluster for engine version %s', (expected, version) => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      engineVersion: version,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      EngineVersion: expected,\n      DBSubnetGroupName: { Ref: 'DatabaseSubnets3C9252C9' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['DatabaseSecurityGroup5C91FDCB', 'GroupId'] }],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "can create a cluster with imported vpc and security group",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 146,
                "column": 65
            },
            "line": 146,
            "code": "  test('can create a cluster with imported vpc and security group', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = ec2.Vpc.fromLookup(stack, 'VPC', {\n      vpcId: 'VPC12345',\n    });\n    const sg = ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'SecurityGroupId12345');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      instances: 1,\n      vpc,\n      securityGroups: [sg],\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      DBSubnetGroupName: { Ref: 'DatabaseSubnets3C9252C9' },\n      VpcSecurityGroupIds: ['SecurityGroupId12345'],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cluster with parameter group",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 169,
                "column": 36
            },
            "line": 169,
            "code": "  test('cluster with parameter group', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const group = new ClusterParameterGroup(stack, 'Params', {\n      description: 'bye',\n      parameters: {\n        param: 'value',\n      },\n    });\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      clusterParameterGroup: group,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      DBClusterParameterGroupName: { Ref: 'ParamsA8366201' },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cluster with associated role",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 193,
                "column": 36
            },
            "line": 193,
            "code": "  test('cluster with associated role', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('rds.amazonaws.com'),\n    });\n    role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonS3ReadOnlyAccess'));\n\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      associatedRoles: [role],\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      AssociatedRoles: [\n        {\n          RoleArn: {\n            'Fn::GetAtt': [\n              'Role1ABCC5F0',\n              'Arn',\n            ],\n          },\n        },\n      ],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cluster with imported parameter group",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 225,
                "column": 45
            },
            "line": 225,
            "code": "  test('cluster with imported parameter group', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const group = ClusterParameterGroup.fromClusterParameterGroupName(stack, 'Params', 'ParamGroupName');\n\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      clusterParameterGroup: group,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      DBClusterParameterGroupName: 'ParamGroupName',\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "create an encrypted cluster with custom KMS key",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 245,
                "column": 55
            },
            "line": 245,
            "code": "  test('create an encrypted cluster with custom KMS key', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      kmsKey: new kms.Key(stack, 'Key'),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      KmsKeyId: {\n        'Fn::GetAtt': [\n          'Key961B73FD',\n          'Arn',\n        ],\n      },\n      StorageEncrypted: true,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "creating a cluster defaults to using encryption",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 269,
                "column": 55
            },
            "line": 269,
            "code": "  test('creating a cluster defaults to using encryption', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      StorageEncrypted: true,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "supplying a KMS key with storageEncryption false throws an error",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 286,
                "column": 72
            },
            "line": 286,
            "code": "  test('supplying a KMS key with storageEncryption false throws an error', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    function action() {\n      new DatabaseCluster(stack, 'Database', {\n        vpc,\n        instanceType: InstanceType.R5_LARGE,\n        kmsKey: new kms.Key(stack, 'Key'),\n        storageEncrypted: false,\n      });\n    }\n\n    // THEN\n    expect(action).toThrow();\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cluster exposes different read and write endpoints",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 305,
                "column": 58
            },
            "line": 305,
            "code": "  test('cluster exposes different read and write endpoints', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const cluster = new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    expect(stack.resolve(cluster.clusterEndpoint)).not.toBe(stack.resolve(cluster.clusterReadEndpoint));\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "instance identifier used when present",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 320,
                "column": 45
            },
            "line": 320,
            "code": "  test('instance identifier used when present', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const instanceIdentifierBase = 'instanceidentifierbase-';\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      instanceIdentifierBase,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      DBInstanceIdentifier: `${instanceIdentifierBase}1`,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cluster identifier used",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 339,
                "column": 31
            },
            "line": 339,
            "code": "  test('cluster identifier used', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const clusterIdentifier = 'clusteridentifier-';\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      dbClusterName: clusterIdentifier,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      DBInstanceIdentifier: `${clusterIdentifier}instance1`,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "imported cluster has supplied attributes",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 358,
                "column": 48
            },
            "line": 358,
            "code": "  test('imported cluster has supplied attributes', () => {\n    // GIVEN\n    const stack = testStack();\n\n    // WHEN\n    const cluster = DatabaseCluster.fromDatabaseClusterAttributes(stack, 'Database', {\n      clusterEndpointAddress: 'addr',\n      clusterIdentifier: 'identifier',\n      clusterResourceIdentifier: 'resourceIdentifier',\n      port: 3306,\n      readerEndpointAddress: 'reader-address',\n      securityGroup: ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'sg-123456789', {\n        allowAllOutbound: false,\n      }),\n    });\n\n    // THEN\n    expect(cluster.clusterEndpoint.hostname).toEqual('addr');\n    expect(cluster.clusterEndpoint.port).toEqual(3306);\n    expect(cluster.clusterIdentifier).toEqual('identifier');\n    expect(cluster.clusterReadEndpoint.hostname).toEqual('reader-address');\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "imported cluster with imported security group honors allowAllOutbound",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 381,
                "column": 77
            },
            "line": 381,
            "code": "  test('imported cluster with imported security group honors allowAllOutbound', () => {\n    // GIVEN\n    const stack = testStack();\n\n    const cluster = DatabaseCluster.fromDatabaseClusterAttributes(stack, 'Database', {\n      clusterEndpointAddress: 'addr',\n      clusterIdentifier: 'identifier',\n      clusterResourceIdentifier: 'resourceIdentifier',\n      port: 3306,\n      readerEndpointAddress: 'reader-address',\n      securityGroup: ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'sg-123456789', {\n        allowAllOutbound: false,\n      }),\n    });\n\n    // WHEN\n    cluster.connections.allowToAnyIpv4(ec2.Port.tcp(443));\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroupEgress', {\n      GroupId: 'sg-123456789',\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "backup retention period respected",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 405,
                "column": 41
            },
            "line": 405,
            "code": "  test('backup retention period respected', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      backupRetention: cdk.Duration.days(20),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      BackupRetentionPeriod: 20,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "backup maintenance window respected",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 423,
                "column": 43
            },
            "line": 423,
            "code": "  test('backup maintenance window respected', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      backupRetention: cdk.Duration.days(20),\n      preferredBackupWindow: '07:34-08:04',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      BackupRetentionPeriod: 20,\n      PreferredBackupWindow: '07:34-08:04',\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "regular maintenance window respected",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 443,
                "column": 44
            },
            "line": 443,
            "code": "  test('regular maintenance window respected', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Database', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      preferredMaintenanceWindow: '07:34-08:04',\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      PreferredMaintenanceWindow: '07:34-08:04',\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "iam authentication - off by default",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 461,
                "column": 43
            },
            "line": 461,
            "code": "  test('iam authentication - off by default', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      IamAuthEnabled: Match.absent(),\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "grantConnect - enables IAM auth and grants neptune-db:* to the grantee",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 478,
                "column": 78
            },
            "line": 478,
            "code": "  test('grantConnect - enables IAM auth and grants neptune-db:* to the grantee', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const cluster = new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n    const role = new iam.Role(stack, 'DBRole', {\n      assumedBy: new iam.AccountPrincipal(stack.account),\n    });\n    cluster.grantConnect(role);\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      IamAuthEnabled: true,\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [{\n          Effect: 'Allow',\n          Action: 'neptune-db:*',\n          Resource: {\n            'Fn::Join': [\n              '', [\n                'arn:', {\n                  Ref: 'AWS::Partition',\n                },\n                ':neptune-db:',\n                {\n                  Ref: 'AWS::Region',\n                },\n                ':',\n                {\n                  Ref: 'AWS::AccountId',\n                },\n                ':',\n                {\n                  'Fn::GetAtt': [\n                    'ClusterEB0386A7',\n                    'ClusterResourceId',\n                  ],\n                },\n                '/*',\n              ],\n            ],\n          },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "grantConnect - throws if IAM auth disabled",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 533,
                "column": 50
            },
            "line": 533,
            "code": "  test('grantConnect - throws if IAM auth disabled', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const cluster = new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      iamAuthentication: false,\n    });\n    const role = new iam.Role(stack, 'DBRole', {\n      assumedBy: new iam.AccountPrincipal(stack.account),\n    });\n\n    // THEN\n    expect(() => { cluster.grantConnect(role); }).toThrow(/Cannot grant permissions when IAM authentication is disabled/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "grant - enables IAM auth and grants specified actions to the grantee",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 552,
                "column": 76
            },
            "line": 552,
            "code": "  test('grant - enables IAM auth and grants specified actions to the grantee', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const cluster = new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n    const role = new iam.Role(stack, 'DBRole', {\n      assumedBy: new iam.AccountPrincipal(stack.account),\n    });\n    cluster.grant(role, 'neptune-db:ReadDataViaQuery', 'neptune-db:WriteDataViaQuery');\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      IamAuthEnabled: true,\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: [{\n          Effect: 'Allow',\n          Action: ['neptune-db:ReadDataViaQuery', 'neptune-db:WriteDataViaQuery'],\n          Resource: {\n            'Fn::Join': [\n              '', [\n                'arn:', {\n                  Ref: 'AWS::Partition',\n                },\n                ':neptune-db:',\n                {\n                  Ref: 'AWS::Region',\n                },\n                ':',\n                {\n                  Ref: 'AWS::AccountId',\n                },\n                ':',\n                {\n                  'Fn::GetAtt': [\n                    'ClusterEB0386A7',\n                    'ClusterResourceId',\n                  ],\n                },\n                '/*',\n              ],\n            ],\n          },\n        }],\n        Version: '2012-10-17',\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "grant - throws if IAM auth disabled",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 607,
                "column": 43
            },
            "line": 607,
            "code": "  test('grant - throws if IAM auth disabled', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    const cluster = new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      iamAuthentication: false,\n    });\n    const role = new iam.Role(stack, 'DBRole', {\n      assumedBy: new iam.AccountPrincipal(stack.account),\n    });\n\n    // THEN\n    expect(() => { cluster.grant(role, 'neptune-db:ReadDataViaQuery', 'neptune-db:WriteDataViaQuery'); }).toThrow(/Cannot grant permissions when IAM authentication is disabled/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "autoMinorVersionUpgrade is enabled when configured",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 626,
                "column": 58
            },
            "line": 626,
            "code": "  test('autoMinorVersionUpgrade is enabled when configured', () => {\n\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      autoMinorVersionUpgrade: true,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      AutoMinorVersionUpgrade: true,\n    });\n\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "autoMinorVersionUpgrade is not enabled when not configured",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 646,
                "column": 66
            },
            "line": 646,
            "code": "  test('autoMinorVersionUpgrade is not enabled when not configured', () => {\n\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      AutoMinorVersionUpgrade: false,\n    });\n\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cloudwatchLogsExports is enabled when configured",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 665,
                "column": 56
            },
            "line": 665,
            "code": "  test('cloudwatchLogsExports is enabled when configured', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      cloudwatchLogsExports: [LogType.AUDIT],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      EnableCloudwatchLogsExports: ['audit'],\n    });\n    Template.fromStack(stack).resourceCountIs('Custom::LogRetention', 0);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "cloudwatchLogsExports log retention is enabled when configured",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 684,
                "column": 70
            },
            "line": 684,
            "code": "  test('cloudwatchLogsExports log retention is enabled when configured', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n\n    // WHEN\n    new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n      cloudwatchLogsExports: [LogType.AUDIT],\n      cloudwatchLogsRetention: logs.RetentionDays.ONE_MONTH,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBCluster', {\n      EnableCloudwatchLogsExports: ['audit'],\n    });\n    Template.fromStack(stack).hasResourceProperties('Custom::LogRetention', {\n      LogGroupName: {\n        'Fn::Join': [\n          '',\n          [\n            '/aws/neptune/',\n            {\n              Ref: 'ClusterEB0386A7',\n            },\n            '/audit',\n          ],\n        ],\n      },\n      RetentionInDays: 30,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "metric - constructs metric with correct namespace and dimension and inputs",
            "suites": [
                "DatabaseCluster"
            ],
            "updatePoint": {
                "line": 718,
                "column": 82
            },
            "line": 718,
            "code": "  test('metric - constructs metric with correct namespace and dimension and inputs', () => {\n    // GIVEN\n    const stack = testStack();\n    const vpc = new ec2.Vpc(stack, 'VPC');\n    const cluster = new DatabaseCluster(stack, 'Cluster', {\n      vpc,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // WHEN\n    const metric = cluster.metric('SparqlRequestsPerSec');\n    new cloudwatch.Alarm(stack, 'Alarm', {\n      evaluationPeriods: 1,\n      threshold: 1,\n      comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n      metric: metric,\n    });\n\n    // THEN\n    expect(metric).toEqual(new cloudwatch.Metric({\n      namespace: 'AWS/Neptune',\n      dimensionsMap: {\n        DBClusterIdentifier: cluster.clusterIdentifier,\n      },\n      metricName: 'SparqlRequestsPerSec',\n    }));\n    Template.fromStack(stack).hasResourceProperties('AWS::CloudWatch::Alarm', {\n      Namespace: 'AWS/Neptune',\n      MetricName: 'SparqlRequestsPerSec',\n      Dimensions: [\n        {\n          Name: 'DBClusterIdentifier',\n          Value: stack.resolve(cluster.clusterIdentifier),\n        },\n      ],\n      ComparisonOperator: 'LessThanThreshold',\n      EvaluationPeriods: 1,\n      Threshold: 1,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "accepts valid port string numbers",
            "suites": [
                "Endpoint"
            ],
            "updatePoint": {
                "line": 4,
                "column": 41
            },
            "line": 4,
            "code": "  test('accepts valid port string numbers', () => {\n    // GIVEN\n    for (const port of [1, 50, 65535]) {\n      // WHEN\n      const endpoint = new Endpoint('127.0.0.1', port);\n\n      // THEN\n      expect(endpoint.port).toBe(port);\n    }\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "check that instantiation works",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 10,
                "column": 38
            },
            "line": 10,
            "code": "  test('check that instantiation works', () => {\n    // GIVEN\n    const stack = testStack();\n\n    // WHEN\n    new DatabaseInstance(stack, 'Instance', {\n      cluster: stack.cluster,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResource('AWS::Neptune::DBInstance', {\n      Properties: {\n        DBClusterIdentifier: { Ref: 'DatabaseB269D8BB' },\n        DBInstanceClass: 'db.r5.large',\n      },\n      DeletionPolicy: 'Retain',\n      UpdateReplacePolicy: 'Retain',\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "check that the endpoint works",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 31,
                "column": 37
            },
            "line": 31,
            "code": "  test('check that the endpoint works', () => {\n    // GIVEN\n    const stack = testStack();\n    const instance = new DatabaseInstance(stack, 'Instance', {\n      cluster: stack.cluster,\n      instanceType: InstanceType.R5_LARGE,\n    });\n    const exportName = 'DbInstanceEndpoint';\n\n    // WHEN\n    new cdk.CfnOutput(stack, exportName, {\n      exportName,\n      value: instance.instanceEndpoint.socketAddress,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasOutput(exportName, {\n      Export: { Name: exportName },\n      Value: {\n        'Fn::Join': [\n          '',\n          [\n            { 'Fn::GetAtt': ['InstanceC1063A87', 'Endpoint'] },\n            ':',\n            { 'Fn::GetAtt': ['InstanceC1063A87', 'Port'] },\n          ],\n        ],\n      },\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "check importing works as expected",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 62,
                "column": 41
            },
            "line": 62,
            "code": "  test('check importing works as expected', () => {\n    // GIVEN\n    const stack = testStack();\n    const endpointExportName = 'DbInstanceEndpoint';\n    const instanceEndpointAddress = '127.0.0.1';\n    const instanceIdentifier = 'InstanceID';\n    const port = 8888;\n\n    // WHEN\n    const instance = DatabaseInstance.fromDatabaseInstanceAttributes(stack, 'Instance', {\n      instanceEndpointAddress,\n      instanceIdentifier,\n      port,\n    });\n    new cdk.CfnOutput(stack, 'EndpointOutput', {\n      exportName: endpointExportName,\n      value: instance.instanceEndpoint.socketAddress,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasOutput('EndpointOutput', {\n      Export: { Name: endpointExportName },\n      Value: `${instanceEndpointAddress}:${port}`,\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "instance with parameter group",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 88,
                "column": 37
            },
            "line": 88,
            "code": "  test('instance with parameter group', () => {\n    // GIVEN\n    const stack = testStack();\n\n    // WHEN\n    const group = new ParameterGroup(stack, 'Params', {\n      description: 'bye',\n      parameters: {\n        param: 'value',\n      },\n    });\n    new DatabaseInstance(stack, 'Instance', {\n      cluster: stack.cluster,\n      instanceType: InstanceType.R5_LARGE,\n      parameterGroup: group,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      DBParameterGroupName: { Ref: 'ParamsA8366201' },\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "instance type from CfnParameter",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 111,
                "column": 39
            },
            "line": 111,
            "code": "  test('instance type from CfnParameter', () => {\n    // GIVEN\n    const stack = testStack();\n\n    const instanceType = new cdk.CfnParameter(stack, 'NeptuneInstaneType', {\n      description: 'Instance type of graph database Neptune',\n      type: 'String',\n      allowedValues: [\n        'db.r5.xlarge',\n        'db.r5.2xlarge',\n        'db.r5.4xlarge',\n        'db.r5.8xlarge',\n        'db.r5.12xlarge',\n      ],\n      default: 'db.r5.8xlarge',\n    });\n    // WHEN\n    new DatabaseInstance(stack, 'Instance', {\n      cluster: stack.cluster,\n      instanceType: InstanceType.of(instanceType.valueAsString),\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBInstance', {\n      DBInstanceClass: {\n        Ref: 'NeptuneInstaneType',\n      },\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "instance type from string throws if missing db prefix",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 141,
                "column": 61
            },
            "line": 141,
            "code": "  test('instance type from string throws if missing db prefix', () => {\n    expect(() => { InstanceType.of('r5.xlarge');}).toThrowError(/instance type must start with 'db.'/);\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "metric - constructs metric with correct namespace and dimension and inputs",
            "suites": [
                "DatabaseInstance"
            ],
            "updatePoint": {
                "line": 145,
                "column": 82
            },
            "line": 145,
            "code": "  test('metric - constructs metric with correct namespace and dimension and inputs', () => {\n    // GIVEN\n    const stack = testStack();\n    const instance = new DatabaseInstance(stack, 'Instance', {\n      cluster: stack.cluster,\n      instanceType: InstanceType.R5_LARGE,\n    });\n\n    // WHEN\n    const metric = instance.metric('SparqlRequestsPerSec');\n    new cloudwatch.Alarm(stack, 'Alarm', {\n      evaluationPeriods: 1,\n      threshold: 1,\n      comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,\n      metric: metric,\n    });\n\n    // THEN\n    expect(metric).toEqual(new cloudwatch.Metric({\n      namespace: 'AWS/Neptune',\n      dimensionsMap: {\n        DBInstanceIdentifier: instance.instanceIdentifier,\n      },\n      metricName: 'SparqlRequestsPerSec',\n    }));\n    Template.fromStack(stack).hasResourceProperties('AWS::CloudWatch::Alarm', {\n      Namespace: 'AWS/Neptune',\n      MetricName: 'SparqlRequestsPerSec',\n      Dimensions: [\n        {\n          Name: 'DBInstanceIdentifier',\n          Value: stack.resolve(instance.instanceIdentifier),\n        },\n      ],\n      ComparisonOperator: 'LessThanThreshold',\n      EvaluationPeriods: 1,\n      Threshold: 1,\n    });\n  });",
            "file": "instance.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "create a cluster parameter group",
            "suites": [
                "ClusterParameterGroup"
            ],
            "updatePoint": {
                "line": 7,
                "column": 40
            },
            "line": 7,
            "code": "  test('create a cluster parameter group', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new ClusterParameterGroup(stack, 'Params', {\n      description: 'desc',\n      parameters: {\n        key: 'value',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBClusterParameterGroup', {\n      Description: 'desc',\n      Family: 'neptune1',\n      Parameters: {\n        key: 'value',\n      },\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "create a cluster parameter group with family %s",
            "suites": [
                "ClusterParameterGroup"
            ],
            "line": 29,
            "code": "  test.each([\n    ['neptune1', ParameterGroupFamily.NEPTUNE_1], ['neptune1.2', ParameterGroupFamily.NEPTUNE_1_2],\n  ])('create a cluster parameter group with family %s', (expectedFamily, family) => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new ClusterParameterGroup(stack, 'Params', {\n      description: 'desc',\n      family,\n      parameters: {\n        key: 'value',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBClusterParameterGroup', {\n      Description: 'desc',\n      Family: expectedFamily,\n      Parameters: {\n        key: 'value',\n      },\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "create a instance/db parameter group",
            "suites": [
                "ClusterParameterGroup"
            ],
            "updatePoint": {
                "line": 54,
                "column": 44
            },
            "line": 54,
            "code": "  test('create a instance/db parameter group', () => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new ParameterGroup(stack, 'Params', {\n      description: 'desc',\n      parameters: {\n        key: 'value',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBParameterGroup', {\n      Description: 'desc',\n      Family: 'neptune1',\n      Parameters: {\n        key: 'value',\n      },\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "create a a instance/db parameter group with family %s",
            "suites": [
                "ClusterParameterGroup"
            ],
            "line": 76,
            "code": "  test.each([\n    ['neptune1', ParameterGroupFamily.NEPTUNE_1], ['neptune1.2', ParameterGroupFamily.NEPTUNE_1_2],\n  ])('create a a instance/db parameter group with family %s', (expectedFamily, family) => {\n    // GIVEN\n    const stack = new Stack();\n\n    // WHEN\n    new ParameterGroup(stack, 'Params', {\n      description: 'desc',\n      family,\n      parameters: {\n        key: 'value',\n      },\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBParameterGroup', {\n      Description: 'desc',\n      Family: expectedFamily,\n      Parameters: {\n        key: 'value',\n      },\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "creates a subnet group from minimal properties",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 52
            },
            "line": 14,
            "code": "test('creates a subnet group from minimal properties', () => {\n  new SubnetGroup(stack, 'Group', {\n    description: 'MyGroup',\n    vpc,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBSubnetGroup', {\n    DBSubnetGroupDescription: 'MyGroup',\n    SubnetIds: [\n      { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n      { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n    ],\n  });\n});",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "creates a subnet group from all properties",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 48
            },
            "line": 29,
            "code": "test('creates a subnet group from all properties', () => {\n  new SubnetGroup(stack, 'Group', {\n    description: 'My Shared Group',\n    subnetGroupName: 'SharedGroup',\n    vpc,\n    vpcSubnets: { subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBSubnetGroup', {\n    DBSubnetGroupDescription: 'My Shared Group',\n    DBSubnetGroupName: 'SharedGroup',\n    SubnetIds: [\n      { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n      { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n    ],\n  });\n});",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "defaults to private subnets",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 48,
                "column": 35
            },
            "line": 48,
            "code": "  test('defaults to private subnets', () => {\n    new SubnetGroup(stack, 'Group', {\n      description: 'MyGroup',\n      vpc,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBSubnetGroup', {\n      DBSubnetGroupDescription: 'MyGroup',\n      SubnetIds: [\n        { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n        { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n      ],\n    });\n  });",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "can specify subnet type",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 63,
                "column": 31
            },
            "line": 63,
            "code": "  test('can specify subnet type', () => {\n    new SubnetGroup(stack, 'Group', {\n      description: 'MyGroup',\n      vpc,\n      vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Neptune::DBSubnetGroup', {\n      DBSubnetGroupDescription: 'MyGroup',\n      SubnetIds: [\n        { Ref: 'VPCPublicSubnet1SubnetB4246D30' },\n        { Ref: 'VPCPublicSubnet2Subnet74179F39' },\n      ],\n    });\n  });",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "import group by name",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 80,
                "column": 26
            },
            "line": 80,
            "code": "test('import group by name', () => {\n  const subnetGroup = SubnetGroup.fromSubnetGroupName(stack, 'Group', 'my-subnet-group');\n  expect(subnetGroup.subnetGroupName).toBe('my-subnet-group');\n});",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-neptune/test"
        },
        {
            "name": "check that instantiation works",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 36
            },
            "line": 18,
            "code": "test('check that instantiation works', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n    Properties: {\n      AllowVersionUpgrade: true,\n      MasterUsername: 'admin',\n      MasterUserPassword: 'tooshort',\n      ClusterType: 'multi-node',\n      AutomatedSnapshotRetentionPeriod: 1,\n      Encrypted: true,\n      NumberOfNodes: 2,\n      NodeType: 'dc2.large',\n      DBName: 'default_db',\n      PubliclyAccessible: false,\n      ClusterSubnetGroupName: { Ref: 'RedshiftSubnetsDFE70E0A' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['RedshiftSecurityGroup796D74A7', 'GroupId'] }],\n    },\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n\n  Template.fromStack(stack).hasResource('AWS::Redshift::ClusterSubnetGroup', {\n    Properties: {\n      Description: 'Subnets for Redshift Redshift cluster',\n      SubnetIds: [\n        { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n        { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n        { Ref: 'VPCPrivateSubnet3Subnet3EDCD457' },\n      ],\n    },\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can create a cluster with imported vpc and security group",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 63
            },
            "line": 62,
            "code": "test('can create a cluster with imported vpc and security group', () => {\n  // GIVEN\n  vpc = ec2.Vpc.fromLookup(stack, 'ImportedVPC', {\n    vpcId: 'VPC12345',\n  });\n  const sg = ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'SecurityGroupId12345');\n\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n    securityGroups: [sg],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    ClusterSubnetGroupName: { Ref: 'RedshiftSubnetsDFE70E0A' },\n    MasterUsername: 'admin',\n    MasterUserPassword: 'tooshort',\n    VpcSecurityGroupIds: ['SecurityGroupId12345'],\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "creates a secret when master credentials are not specified",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 64
            },
            "line": 88,
            "code": "test('creates a secret when master credentials are not specified', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    MasterUsername: {\n      'Fn::Join': [\n        '',\n        [\n          '{{resolve:secretsmanager:',\n          {\n            Ref: 'RedshiftSecretA08D42D6',\n          },\n          ':SecretString:username::}}',\n        ],\n      ],\n    },\n    MasterUserPassword: {\n      'Fn::Join': [\n        '',\n        [\n          '{{resolve:secretsmanager:',\n          {\n            Ref: 'RedshiftSecretA08D42D6',\n          },\n          ':SecretString:password::}}',\n        ],\n      ],\n    },\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n    GenerateSecretString: {\n      ExcludeCharacters: '\"@/\\\\\\ \\'',\n      GenerateStringKey: 'password',\n      PasswordLength: 30,\n      SecretStringTemplate: '{\"username\":\"admin\"}',\n    },\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Single Node Clusters do not define node count",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 137,
                "column": 53
            },
            "line": 137,
            "code": "  test('Single Node Clusters do not define node count', () => {\n    // WHEN\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      clusterType: ClusterType.SINGLE_NODE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterType: 'single-node',\n      NumberOfNodes: Match.absent(),\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Single Node Clusters treat 1 node as undefined",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 154,
                "column": 54
            },
            "line": 154,
            "code": "  test('Single Node Clusters treat 1 node as undefined', () => {\n    // WHEN\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      clusterType: ClusterType.SINGLE_NODE,\n      numberOfNodes: 1,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterType: 'single-node',\n      NumberOfNodes: Match.absent(),\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Single Node Clusters throw if any other node count is specified",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 172,
                "column": 71
            },
            "line": 172,
            "code": "  test('Single Node Clusters throw if any other node count is specified', () => {\n    expect(() => {\n      new Cluster(stack, 'Redshift', {\n        masterUser: {\n          masterUsername: 'admin',\n        },\n        vpc,\n        clusterType: ClusterType.SINGLE_NODE,\n        numberOfNodes: 2,\n      });\n    }).toThrow(/Number of nodes must be not be supplied or be 1 for cluster type single-node/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Multi-Node Clusters default to 2 nodes",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 185,
                "column": 46
            },
            "line": 185,
            "code": "  test('Multi-Node Clusters default to 2 nodes', () => {\n    // WHEN\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      clusterType: ClusterType.MULTI_NODE,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterType: 'multi-node',\n      NumberOfNodes: 2,\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Multi-Node Clusters throw with %s nodes",
            "suites": [
                "node count"
            ],
            "line": 202,
            "code": "  test.each([0, 1, -1, 101])('Multi-Node Clusters throw with %s nodes', (numberOfNodes: number) => {\n    expect(() => {\n      new Cluster(stack, 'Redshift', {\n        masterUser: {\n          masterUsername: 'admin',\n        },\n        vpc,\n        clusterType: ClusterType.MULTI_NODE,\n        numberOfNodes,\n      });\n    }).toThrow(/Number of nodes for cluster type multi-node must be at least 2 and no more than 100/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Multi-Node Clusters should allow input parameter for number of nodes",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 215,
                "column": 76
            },
            "line": 215,
            "code": "  test('Multi-Node Clusters should allow input parameter for number of nodes', () => {\n    // WHEN\n    const numberOfNodesParam = new cdk.CfnParameter(stack, 'numberOfNodes', {\n      type: 'Number',\n    });\n\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      clusterType: ClusterType.MULTI_NODE,\n      numberOfNodes: numberOfNodesParam.valueAsNumber,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterType: 'multi-node',\n      NumberOfNodes: {\n        Ref: 'numberOfNodes',\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "create an encrypted cluster with custom KMS key",
            "suites": [
                "node count"
            ],
            "updatePoint": {
                "line": 240,
                "column": 53
            },
            "line": 240,
            "code": "test('create an encrypted cluster with custom KMS key', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    encryptionKey: new kms.Key(stack, 'Key'),\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    KmsKeyId: {\n      Ref: 'Key961B73FD',\n    },\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "cluster instantiated with parameter group",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 258,
                "column": 49
            },
            "line": 258,
            "code": "  test('cluster instantiated with parameter group', () => {\n    // WHEN\n    const group = new ClusterParameterGroup(stack, 'Params', {\n      description: 'bye',\n      parameters: {\n        param: 'value',\n      },\n    });\n\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      parameterGroup: group,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterParameterGroupName: { Ref: 'ParamsA8366201' },\n    });\n\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding to the cluster parameter group on a cluster not instantiated with a parameter group",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 282,
                "column": 98
            },
            "line": 282,
            "code": "  test('Adding to the cluster parameter group on a cluster not instantiated with a parameter group', () => {\n\n    // WHEN\n    const cluster = new Cluster(stack, 'Redshift', {\n      clusterName: 'foobar',\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n\n    cluster.addToParameterGroup('foo', 'bar');\n\n    const template = Template.fromStack(stack);\n    template.hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterParameterGroupName: { Ref: Match.anyValue() },\n    });\n\n    template.hasResourceProperties('AWS::Redshift::ClusterParameterGroup', {\n      Description: 'Parameter Group for the foobar Redshift cluster',\n      ParameterGroupFamily: 'redshift-1.0',\n      Parameters: [\n        {\n          ParameterName: 'foo',\n          ParameterValue: 'bar',\n        },\n      ],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding to the cluster parameter group on a cluster instantiated with a parameter group",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 312,
                "column": 94
            },
            "line": 312,
            "code": "  test('Adding to the cluster parameter group on a cluster instantiated with a parameter group', () => {\n\n    // WHEN\n    const group = new ClusterParameterGroup(stack, 'Params', {\n      description: 'lorem ipsum',\n      parameters: {\n        param: 'value',\n      },\n    });\n\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      parameterGroup: group,\n    });\n    cluster.addToParameterGroup('foo', 'bar');\n\n    const template = Template.fromStack(stack);\n    template.hasResourceProperties('AWS::Redshift::Cluster', {\n      ClusterParameterGroupName: { Ref: Match.anyValue() },\n    });\n\n    template.hasResourceProperties('AWS::Redshift::ClusterParameterGroup', {\n      Description: 'lorem ipsum',\n      ParameterGroupFamily: 'redshift-1.0',\n      Parameters: [\n        {\n          ParameterName: 'param',\n          ParameterValue: 'value',\n        },\n        {\n          ParameterName: 'foo',\n          ParameterValue: 'bar',\n        },\n      ],\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding a parameter to an IClusterParameterGroup",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 352,
                "column": 55
            },
            "line": 352,
            "code": "  test('Adding a parameter to an IClusterParameterGroup', () => {\n    // GIVEN\n    const cluster = new Cluster(stack, 'Redshift', {\n      clusterName: 'foobar',\n      parameterGroup: ClusterParameterGroup.fromClusterParameterGroupName(stack, 'Params', 'foo'),\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n\n    // WHEN\n    expect(() => cluster.addToParameterGroup('param', 'value2'))\n      // THEN\n      .toThrowError('Cannot add a parameter to an imported parameter group');\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "publicly accessible cluster",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 371,
                "column": 33
            },
            "line": 371,
            "code": "test('publicly accessible cluster', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n    publiclyAccessible: true,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    PubliclyAccessible: true,\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "imported cluster with imported security group honors allowAllOutbound",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 387,
                "column": 75
            },
            "line": 387,
            "code": "test('imported cluster with imported security group honors allowAllOutbound', () => {\n  // GIVEN\n  const cluster = Cluster.fromClusterAttributes(stack, 'Database', {\n    clusterEndpointAddress: 'addr',\n    clusterName: 'identifier',\n    clusterEndpointPort: 3306,\n    securityGroups: [\n      ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'sg-123456789', {\n        allowAllOutbound: false,\n      }),\n    ],\n  });\n\n  // WHEN\n  cluster.connections.allowToAnyIpv4(ec2.Port.tcp(443));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroupEgress', {\n    GroupId: 'sg-123456789',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can create a cluster with logging enabled",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 409,
                "column": 47
            },
            "line": 409,
            "code": "test('can create a cluster with logging enabled', () => {\n  // GIVEN\n  const bucket = s3.Bucket.fromBucketName(stack, 'bucket', 'logging-bucket');\n\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n    loggingProperties: {\n      loggingBucket: bucket,\n      loggingKeyPrefix: 'prefix',\n    },\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    LoggingProperties: {\n      BucketName: 'logging-bucket',\n      S3KeyPrefix: 'prefix',\n    },\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws when trying to add rotation to a cluster without secret",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 434,
                "column": 68
            },
            "line": 434,
            "code": "test('throws when trying to add rotation to a cluster without secret', () => {\n  // WHEN\n  const cluster = new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n  });\n\n  // THEN\n  expect(() => {\n    cluster.addRotationSingleUser();\n  }).toThrowError();\n\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws validation error when trying to set encryptionKey without enabling encryption",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 451,
                "column": 90
            },
            "line": 451,
            "code": "test('throws validation error when trying to set encryptionKey without enabling encryption', () => {\n  // GIVEN\n  const key = new kms.Key(stack, 'kms-key');\n\n  // WHEN\n  const props = {\n    encrypted: false,\n    encryptionKey: key,\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n  };\n\n  // THEN\n  expect(() => {\n    new Cluster(stack, 'Redshift', props);\n  }).toThrowError();\n\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws when trying to add single user rotation multiple times",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 472,
                "column": 67
            },
            "line": 472,
            "code": "test('throws when trying to add single user rotation multiple times', () => {\n  // GIVEN\n  const cluster = new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n  });\n\n  // WHEN\n  cluster.addRotationSingleUser();\n\n  // THEN\n  expect(() => {\n    cluster.addRotationSingleUser();\n  }).toThrowError();\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can use existing cluster subnet group",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 490,
                "column": 43
            },
            "line": 490,
            "code": "test('can use existing cluster subnet group', () => {\n  // GIVEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n    subnetGroup: ClusterSubnetGroup.fromClusterSubnetGroupName(stack, 'Group', 'my-existing-cluster-subnet-group'),\n  });\n\n  Template.fromStack(stack).resourceCountIs('AWS::Redshift::ClusterSubnetGroup', 0);\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::Cluster', {\n    ClusterSubnetGroupName: 'my-existing-cluster-subnet-group',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "default child returns a CfnCluster",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 506,
                "column": 40
            },
            "line": 506,
            "code": "test('default child returns a CfnCluster', () => {\n  const cluster = new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n    },\n    vpc,\n  });\n\n  expect(cluster.node.defaultChild).toBeInstanceOf(CfnCluster);\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "resize type (%s)",
            "suites": [
                "parameter group"
            ],
            "line": 517,
            "code": "test.each([\n  ['elastic', false],\n  ['classic', true],\n])('resize type (%s)', (_, classicResizing) => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    classicResizing,\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n    Properties: {\n      AllowVersionUpgrade: true,\n      MasterUsername: 'admin',\n      MasterUserPassword: 'tooshort',\n      ClusterType: 'multi-node',\n      AutomatedSnapshotRetentionPeriod: 1,\n      Encrypted: true,\n      NumberOfNodes: 2,\n      NodeType: 'dc2.large',\n      DBName: 'default_db',\n      PubliclyAccessible: false,\n      ClusterSubnetGroupName: { Ref: 'RedshiftSubnetsDFE70E0A' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['RedshiftSecurityGroup796D74A7', 'GroupId'] }],\n      Classic: classicResizing,\n    },\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "resize type not set",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 553,
                "column": 25
            },
            "line": 553,
            "code": "test('resize type not set', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n    Properties: {\n      AllowVersionUpgrade: true,\n      MasterUsername: 'admin',\n      MasterUserPassword: 'tooshort',\n      ClusterType: 'multi-node',\n      AutomatedSnapshotRetentionPeriod: 1,\n      Encrypted: true,\n      NumberOfNodes: 2,\n      NodeType: 'dc2.large',\n      DBName: 'default_db',\n      PubliclyAccessible: false,\n      ClusterSubnetGroupName: { Ref: 'RedshiftSubnetsDFE70E0A' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['RedshiftSecurityGroup796D74A7', 'GroupId'] }],\n    },\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "elastic ip address",
            "suites": [
                "parameter group"
            ],
            "updatePoint": {
                "line": 584,
                "column": 24
            },
            "line": 584,
            "code": "test('elastic ip address', () => {\n  // WHEN\n  new Cluster(stack, 'Redshift', {\n    masterUser: {\n      masterUsername: 'admin',\n      masterPassword: cdk.SecretValue.unsafePlainText('tooshort'),\n    },\n    vpc,\n    elasticIp: '1.3.3.7',\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n    Properties: {\n      AllowVersionUpgrade: true,\n      MasterUsername: 'admin',\n      MasterUserPassword: 'tooshort',\n      ClusterType: 'multi-node',\n      AutomatedSnapshotRetentionPeriod: 1,\n      Encrypted: true,\n      NumberOfNodes: 2,\n      NodeType: 'dc2.large',\n      DBName: 'default_db',\n      PubliclyAccessible: false,\n      ClusterSubnetGroupName: { Ref: 'RedshiftSubnetsDFE70E0A' },\n      VpcSecurityGroupIds: [{ 'Fn::GetAtt': ['RedshiftSecurityGroup796D74A7', 'GroupId'] }],\n      ElasticIp: '1.3.3.7',\n    },\n    DeletionPolicy: 'Retain',\n    UpdateReplacePolicy: 'Retain',\n  });\n});",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throw error for cluster without parameter group",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 618,
                "column": 55
            },
            "line": 618,
            "code": "  test('throw error for cluster without parameter group', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n    cluster.enableRebootForParameterChanges();\n    // WHEN\n    expect(() => Template.fromStack(stack))\n      // THEN\n      .toThrowError(/Cannot enable reboot for parameter changes/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throw error for cluster with imported parameter group",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 633,
                "column": 61
            },
            "line": 633,
            "code": "  test('throw error for cluster with imported parameter group', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      parameterGroup: ClusterParameterGroup.fromClusterParameterGroupName(stack, 'foo', 'bar'),\n    });\n    cluster.enableRebootForParameterChanges();\n    // WHEN\n    expect(() => Template.fromStack(stack))\n      // THEN\n      .toThrowError(/Cannot enable reboot for parameter changes/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "not throw error when parameter group is created after enabling reboots",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 649,
                "column": 78
            },
            "line": 649,
            "code": "  test('not throw error when parameter group is created after enabling reboots', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      rebootForParameterChanges: true,\n    });\n    cluster.addToParameterGroup('foo', 'bar');\n    // WHEN\n    expect(() => Template.fromStack(stack))\n      // THEN\n      .not.toThrowError(/Cannot enable reboot for parameter changes/);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "not create duplicate resources when reboot feature is enabled multiple times on a cluster",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 665,
                "column": 97
            },
            "line": 665,
            "code": "  test('not create duplicate resources when reboot feature is enabled multiple times on a cluster', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      rebootForParameterChanges: true,\n    });\n    cluster.addToParameterGroup('foo', 'bar');\n    //WHEN\n    cluster.enableRebootForParameterChanges();\n    // THEN\n    Template.fromStack(stack).resourceCountIs('Custom::RedshiftClusterRebooter', 1);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "cluster with parameter group",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 681,
                "column": 36
            },
            "line": 681,
            "code": "  test('cluster with parameter group', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n    cluster.addToParameterGroup('foo', 'bar');\n\n    const cluster2 = new Cluster(stack, 'Redshift2', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n    cluster2.addToParameterGroup('foo', 'bar');\n\n    // WHEN\n    cluster.enableRebootForParameterChanges();\n    cluster2.enableRebootForParameterChanges();\n\n    //THEN\n    const template = Template.fromStack(stack);\n    template.resourceCountIs('Custom::RedshiftClusterRebooter', 2);\n    template.templateMatches({\n      Resources: {\n        SingletonLambda511e207f13df4b8bb632c32b30b65ac281740AC5: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Handler: 'index.handler',\n            Runtime: 'nodejs16.x',\n            Timeout: 900,\n          },\n        },\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Custom resource ParametersString property updates",
            "suites": [
                "reboot for Parameter Changes"
            ],
            "updatePoint": {
                "line": 720,
                "column": 57
            },
            "line": 720,
            "code": "  test('Custom resource ParametersString property updates', () => {\n    // Given\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n    cluster.addToParameterGroup('foo', 'bar');\n    cluster.enableRebootForParameterChanges();\n\n    // WHEN\n    cluster.addToParameterGroup('lorem', 'ipsum');\n\n    //THEN\n    const template = Template.fromStack(stack);\n    template.hasResourceProperties('Custom::RedshiftClusterRebooter', {\n      ParametersString: JSON.stringify(\n        {\n          foo: 'bar',\n          lorem: 'ipsum',\n        },\n      ),\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Default role not in role list",
            "suites": [
                "default IAM role"
            ],
            "updatePoint": {
                "line": 749,
                "column": 37
            },
            "line": 749,
            "code": "  test('Default role not in role list', () => {\n    // GIVEN\n    const clusterRole1 = new iam.Role(stack, 'clusterRole1', { assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com') });\n    const defaultRole1 = new iam.Role(stack, 'defaultRole1', { assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com') });\n\n    expect(() => {\n      new Cluster(stack, 'Redshift', {\n        masterUser: {\n          masterUsername: 'admin',\n        },\n        vpc,\n        roles: [clusterRole1],\n        defaultRole: defaultRole1,\n      });\n    }).toThrow(/Default role must be included in role list./);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws error when default role not attached to cluster when adding default role post creation",
            "suites": [
                "default IAM role"
            ],
            "updatePoint": {
                "line": 766,
                "column": 101
            },
            "line": 766,
            "code": "  test('throws error when default role not attached to cluster when adding default role post creation', () => {\n    const defaultRole1 = new iam.Role(stack, 'defaultRole1', { assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com') });\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n\n    expect(() => {\n      cluster.addDefaultIamRole(defaultRole1);\n    }).toThrow(/Default role must be associated to the Redshift cluster to be set as the default role./);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "roles can be directly attached to cluster during declaration",
            "suites": [
                "IAM role"
            ],
            "updatePoint": {
                "line": 782,
                "column": 68
            },
            "line": 782,
            "code": "  test('roles can be directly attached to cluster during declaration', () => {\n    // GIVEN\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n    });\n    new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      roles: [role],\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n      Properties: {\n        IamRoles: Match.arrayEquals([\n          { 'Fn::GetAtt': [Match.stringLikeRegexp('Role*'), 'Arn'] },\n        ]),\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "roles can be attached to cluster after declaration",
            "suites": [
                "IAM role"
            ],
            "updatePoint": {
                "line": 805,
                "column": 58
            },
            "line": 805,
            "code": "  test('roles can be attached to cluster after declaration', () => {\n    // GIVEN\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n    });\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n\n    // WHEN\n    cluster.addIamRole(role);\n\n    // THEN\n    Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n      Properties: {\n        IamRoles: Match.arrayEquals([\n          { 'Fn::GetAtt': [Match.stringLikeRegexp('Role*'), 'Arn'] },\n        ]),\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "roles can be attached to cluster in another stack",
            "suites": [
                "IAM role"
            ],
            "updatePoint": {
                "line": 830,
                "column": 57
            },
            "line": 830,
            "code": "  test('roles can be attached to cluster in another stack', () => {\n    // GIVEN\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n    });\n\n    const newTestStack = new cdk.Stack(stack, 'NewTestStack', { env: { account: stack.account, region: stack.region } });\n    const role = new iam.Role(newTestStack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n    });\n\n    // WHEN\n    cluster.addIamRole(role);\n\n    // THEN\n    Template.fromStack(stack).hasResource('AWS::Redshift::Cluster', {\n      Properties: {\n        IamRoles: Match.arrayEquals([\n          { 'Fn::ImportValue': Match.stringLikeRegexp('NewTestStack:ExportsOutputFnGetAttRole*') },\n        ]),\n      },\n    });\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws when adding role that is already in cluster",
            "suites": [
                "IAM role"
            ],
            "updatePoint": {
                "line": 857,
                "column": 58
            },
            "line": 857,
            "code": "  test('throws when adding role that is already in cluster', () => {\n    // GIVEN\n    const role = new iam.Role(stack, 'Role', {\n      assumedBy: new iam.ServicePrincipal('redshift.amazonaws.com'),\n    });\n    const cluster = new Cluster(stack, 'Redshift', {\n      masterUser: {\n        masterUsername: 'admin',\n      },\n      vpc,\n      roles: [role],\n    });\n\n    expect(() =>\n      // WHEN\n      cluster.addIamRole(role),\n      // THEN\n    ).toThrow(`Role '${role.roleArn}' is already attached to the cluster`);\n  });",
            "file": "cluster.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "calls sub handler",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 23
            },
            "line": 31,
            "code": "test('calls sub handler', async () => {\n  const event = baseEvent;\n\n  await handler(event);\n\n  expect(mockSubHandler).toHaveBeenCalled();\n});",
            "file": "database-query-provider/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws with unregistered subhandler",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 41
            },
            "line": 39,
            "code": "test('throws with unregistered subhandler', async () => {\n  const event = {\n    ...baseEvent,\n    ResourceProperties: {\n      ...resourceProperties,\n      handler: 'unregistered',\n    },\n  };\n\n  await expect(handler(event)).rejects.toThrow(/Requested handler unregistered is not in supported set/);\n  expect(mockSubHandler).not.toHaveBeenCalled();\n});",
            "file": "database-query-provider/index.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes properties in statement and creates physical resource ID",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 47,
                "column": 75
            },
            "line": 47,
            "code": "  test('serializes properties in statement and creates physical resource ID', async () => {\n    const event = baseEvent;\n\n    await expect(managePrivileges(resourceProperties, event)).resolves.toEqual({\n      PhysicalResourceId: 'clusterName:databaseName:username:requestId',\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `GRANT INSERT, SELECT ON ${tableName} TO ${username}`,\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "executes statement",
            "suites": [
                "delete"
            ],
            "updatePoint": {
                "line": 66,
                "column": 26
            },
            "line": 66,
            "code": "  test('executes statement', async () => {\n    const event = baseEvent;\n\n    await managePrivileges(resourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `REVOKE INSERT, SELECT ON ${tableName} FROM ${username}`,\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if cluster name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 85,
                "column": 40
            },
            "line": 85,
            "code": "  test('replaces if cluster name changes', async () => {\n    const newClusterName = 'newClusterName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      clusterName: newClusterName,\n    };\n\n    await expect(managePrivileges(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      ClusterIdentifier: newClusterName,\n      Sql: expect.stringMatching(/GRANT/),\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if admin user ARN changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 101,
                "column": 50
            },
            "line": 101,
            "code": "  test('does not replace if admin user ARN changes', async () => {\n    const newAdminUserArn = 'newAdminUserArn';\n    const newResourceProperties = {\n      ...resourceProperties,\n      adminUserArn: newAdminUserArn,\n    };\n\n    await expect(managePrivileges(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).not.toHaveBeenCalled();\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if database name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 114,
                "column": 41
            },
            "line": 114,
            "code": "  test('replaces if database name changes', async () => {\n    const newDatabaseName = 'newDatabaseName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      databaseName: newDatabaseName,\n    };\n\n    await expect(managePrivileges(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Database: newDatabaseName,\n      Sql: expect.stringMatching(/GRANT/),\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if user name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 130,
                "column": 37
            },
            "line": 130,
            "code": "  test('replaces if user name changes', async () => {\n    const newUsername = 'newUsername';\n    const newResourceProperties = {\n      ...resourceProperties,\n      username: newUsername,\n    };\n\n    await expect(managePrivileges(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: expect.stringMatching(new RegExp(`GRANT .* TO ${newUsername}`)),\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace when privileges change",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 145,
                "column": 47
            },
            "line": 145,
            "code": "  test('does not replace when privileges change', async () => {\n    const newTableName = 'newTableName';\n    const newTablePrivileges = [{ tableName: newTableName, actions: ['DROP'] }];\n    const newResourceProperties = {\n      ...resourceProperties,\n      tablePrivileges: newTablePrivileges,\n    };\n\n    await expect(managePrivileges(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `REVOKE INSERT, SELECT ON ${tableName} FROM ${username}`,\n    }));\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `GRANT DROP ON ${newTableName} TO ${username}`,\n    }));\n  });",
            "file": "database-query-provider/privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes properties in statement and creates physical resource ID",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 56,
                "column": 75
            },
            "line": 56,
            "code": "  test('serializes properties in statement and creates physical resource ID', async () => {\n    const event = baseEvent;\n\n    await expect(manageTable(resourceProperties, event)).resolves.toEqual({\n      PhysicalResourceId: `${tableNamePrefix}${requestIdTruncated}`,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1))`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not modify table name if no suffix generation requested",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 67,
                "column": 68
            },
            "line": 67,
            "code": "  test('does not modify table name if no suffix generation requested', async () => {\n    const event = baseEvent;\n    const newResourceProperties = {\n      ...resourceProperties,\n      tableName: {\n        ...resourceProperties.tableName,\n        generateSuffix: 'false',\n      },\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.toEqual({\n      PhysicalResourceId: tableNamePrefix,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE TABLE ${tableNamePrefix} (col1 varchar(1))`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes distKey and distStyle in statement",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 85,
                "column": 53
            },
            "line": 85,
            "code": "  test('serializes distKey and distStyle in statement', async () => {\n    const event = baseEvent;\n    const newResourceProperties: ResourcePropertiesType = {\n      ...resourceProperties,\n      tableColumns: [{ name: 'col1', dataType: 'varchar(1)', distKey: true }],\n      distStyle: TableDistStyle.KEY,\n    };\n\n    await manageTable(newResourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1)) DISTSTYLE KEY DISTKEY(col1)`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes sortKeys and sortStyle in statement",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 100,
                "column": 54
            },
            "line": 100,
            "code": "  test('serializes sortKeys and sortStyle in statement', async () => {\n    const event = baseEvent;\n    const newResourceProperties: ResourcePropertiesType = {\n      ...resourceProperties,\n      tableColumns: [\n        { name: 'col1', dataType: 'varchar(1)', sortKey: true },\n        { name: 'col2', dataType: 'varchar(1)' },\n        { name: 'col3', dataType: 'varchar(1)', sortKey: true },\n      ],\n      sortStyle: TableSortStyle.COMPOUND,\n    };\n\n    await manageTable(newResourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1),col2 varchar(1),col3 varchar(1)) COMPOUND SORTKEY(col1,col3)`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes distKey and sortKeys as string booleans",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 119,
                "column": 58
            },
            "line": 119,
            "code": "  test('serializes distKey and sortKeys as string booleans', async () => {\n    const event = baseEvent;\n    const newResourceProperties: ResourcePropertiesType = {\n      ...resourceProperties,\n      tableColumns: [\n        { name: 'col1', dataType: 'varchar(4)', distKey: 'true' as unknown as boolean },\n        { name: 'col2', dataType: 'float', sortKey: 'true' as unknown as boolean },\n        { name: 'col3', dataType: 'float', sortKey: 'true' as unknown as boolean },\n      ],\n      distStyle: TableDistStyle.KEY,\n      sortStyle: TableSortStyle.COMPOUND,\n    };\n\n    await manageTable(newResourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(4),col2 float,col3 float) DISTSTYLE KEY DISTKEY(col1) COMPOUND SORTKEY(col2,col3)`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes table comment in statement",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 139,
                "column": 45
            },
            "line": 139,
            "code": "  test('serializes table comment in statement', async () => {\n    const event = baseEvent;\n    const newResourceProperties: ResourcePropertiesType = {\n      ...resourceProperties,\n      tableComment: 'table comment',\n    };\n\n    await manageTable(newResourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `COMMENT ON TABLE ${tableNamePrefix}${requestIdTruncated} IS 'table comment'`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "executes statement",
            "suites": [
                "delete"
            ],
            "updatePoint": {
                "line": 161,
                "column": 26
            },
            "line": 161,
            "code": "  test('executes statement', async () => {\n    const event = baseEvent;\n\n    await manageTable(resourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `DROP TABLE ${physicalResourceId}`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if cluster name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 180,
                "column": 40
            },
            "line": 180,
            "code": "  test('replaces if cluster name changes', async () => {\n    const newClusterName = 'newClusterName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      clusterName: newClusterName,\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      ClusterIdentifier: newClusterName,\n      Sql: expect.stringMatching(new RegExp(`CREATE TABLE ${tableNamePrefix}${requestIdTruncated}`)),\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if admin user ARN changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 196,
                "column": 50
            },
            "line": 196,
            "code": "  test('does not replace if admin user ARN changes', async () => {\n    const newAdminUserArn = 'newAdminUserArn';\n    const newResourceProperties = {\n      ...resourceProperties,\n      adminUserArn: newAdminUserArn,\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).not.toHaveBeenCalled();\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if database name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 209,
                "column": 41
            },
            "line": 209,
            "code": "  test('replaces if database name changes', async () => {\n    const newDatabaseName = 'newDatabaseName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      databaseName: newDatabaseName,\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Database: newDatabaseName,\n      Sql: expect.stringMatching(new RegExp(`CREATE TABLE ${tableNamePrefix}${requestIdTruncated}`)),\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if table name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 225,
                "column": 38
            },
            "line": 225,
            "code": "  test('replaces if table name changes', async () => {\n    const newTableNamePrefix = 'newTableNamePrefix';\n    const newResourceProperties = {\n      ...resourceProperties,\n      tableName: {\n        ...resourceProperties.tableName,\n        prefix: newTableNamePrefix,\n      },\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: expect.stringMatching(new RegExp(`CREATE TABLE ${newTableNamePrefix}${requestIdTruncated}`)),\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if table columns removed",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 243,
                "column": 49
            },
            "line": 243,
            "code": "  test('does not replace if table columns removed', async () => {\n    const newResourceProperties = {\n      ...resourceProperties,\n      tableColumns: [],\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `ALTER TABLE ${physicalResourceId} DROP COLUMN col1`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if table columns added",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 257,
                "column": 47
            },
            "line": 257,
            "code": "  test('does not replace if table columns added', async () => {\n    const newTableColumnName = 'col2';\n    const newTableColumnDataType = 'varchar(1)';\n    const newTableColumns = [{ name: 'col1', dataType: 'varchar(1)' }, { name: newTableColumnName, dataType: newTableColumnDataType }];\n    const newResourceProperties = {\n      ...resourceProperties,\n      tableColumns: newTableColumns,\n    };\n\n    await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `ALTER TABLE ${physicalResourceId} ADD ${newTableColumnName} ${newTableColumnDataType}`,\n    }));\n  });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if column name changed",
            "suites": [
                "update",
                "column name"
            ],
            "updatePoint": {
                "line": 275,
                "column": 49
            },
            "line": 275,
            "code": "    test('does not replace if column name changed', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [\n            { id: 'col1', name: 'col1', dataType: 'varchar(1)' },\n          ],\n        },\n      };\n      const newTableColumnName = 'col2';\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: [\n          { id: 'col1', name: newTableColumnName, dataType: 'varchar(1)' },\n        ],\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} RENAME COLUMN col1 TO ${newTableColumnName}`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if column id assigned, from undefined",
            "suites": [
                "update",
                "column name"
            ],
            "updatePoint": {
                "line": 301,
                "column": 64
            },
            "line": 301,
            "code": "    test('does not replace if column id assigned, from undefined', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [\n            { name: 'col1', dataType: 'varchar(1)' },\n          ],\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: [\n          { id: 'col1', name: 'col1', dataType: 'varchar(1)' },\n        ],\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).not.toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} RENAME COLUMN col1 TO col1`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if distStyle is added",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 328,
                "column": 40
            },
            "line": 328,
            "code": "    test('replaces if distStyle is added', async () => {\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        distStyle: TableDistStyle.EVEN,\n      };\n\n      await expect(manageTable(newResourceProperties, event)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1)) DISTSTYLE EVEN`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if distStyle is removed",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 342,
                "column": 42
            },
            "line": 342,
            "code": "    test('replaces if distStyle is removed', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          distStyle: TableDistStyle.EVEN,\n        },\n      };\n      const newResourceProperties = {\n        ...resourceProperties,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1))`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if distStyle is changed",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 362,
                "column": 50
            },
            "line": 362,
            "code": "    test('does not replace if distStyle is changed', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          distStyle: TableDistStyle.EVEN,\n        },\n      };\n      const newDistStyle = TableDistStyle.ALL;\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        distStyle: newDistStyle,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER DISTSTYLE ${newDistStyle}`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if distKey is added",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 384,
                "column": 38
            },
            "line": 384,
            "code": "    test('replaces if distKey is added', async () => {\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: [{ name: 'col1', dataType: 'varchar(1)', distKey: true }],\n      };\n\n      await expect(manageTable(newResourceProperties, event)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1)) DISTKEY(col1)`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if distKey is removed",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 398,
                "column": 40
            },
            "line": 398,
            "code": "    test('replaces if distKey is removed', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [{ name: 'col1', dataType: 'varchar(1)', distKey: true }],\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1))`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if distKey is changed",
            "suites": [
                "update",
                "distStyle and distKey"
            ],
            "updatePoint": {
                "line": 418,
                "column": 48
            },
            "line": 418,
            "code": "    test('does not replace if distKey is changed', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [\n            { name: 'col1', dataType: 'varchar(1)', distKey: true },\n            { name: 'col2', dataType: 'varchar(1)' },\n          ],\n        },\n      };\n      const newDistKey = 'col2';\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: [\n          { name: 'col1', dataType: 'varchar(1)' },\n          { name: 'col2', dataType: 'varchar(1)', distKey: true },\n        ],\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER DISTKEY ${newDistKey}`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces when same sortStyle, different sortKey columns: INTERLEAVED",
            "suites": [
                "update",
                "sortStyle and sortKeys"
            ],
            "updatePoint": {
                "line": 457,
                "column": 78
            },
            "line": 457,
            "code": "    test('replaces when same sortStyle, different sortKey columns: INTERLEAVED', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: oldTableColumnsWithSortKeys,\n          sortStyle: TableSortStyle.INTERLEAVED,\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: newTableColumnsWithSortKeys,\n        sortStyle: TableSortStyle.INTERLEAVED,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1),col2 varchar(1)) INTERLEAVED SORTKEY(col2)`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces when different sortStyle: INTERLEAVED",
            "suites": [
                "update",
                "sortStyle and sortKeys"
            ],
            "updatePoint": {
                "line": 480,
                "column": 56
            },
            "line": 480,
            "code": "    test('replaces when different sortStyle: INTERLEAVED', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: oldTableColumnsWithSortKeys,\n          sortStyle: TableSortStyle.AUTO,\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: oldTableColumnsWithSortKeys,\n        sortStyle: TableSortStyle.INTERLEAVED,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.not.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `CREATE TABLE ${tableNamePrefix}${requestIdTruncated} (col1 varchar(1),col2 varchar(1)) INTERLEAVED SORTKEY(col1)`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace when same sortStyle, different sortKey columns: COMPOUND",
            "suites": [
                "update",
                "sortStyle and sortKeys"
            ],
            "updatePoint": {
                "line": 503,
                "column": 83
            },
            "line": 503,
            "code": "    test('does not replace when same sortStyle, different sortKey columns: COMPOUND', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: oldTableColumnsWithSortKeys,\n          sortStyle: TableSortStyle.COMPOUND,\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: newTableColumnsWithSortKeys,\n        sortStyle: TableSortStyle.COMPOUND,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER COMPOUND SORTKEY(col2)`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace when different sortStyle: COMPOUND",
            "suites": [
                "update",
                "sortStyle and sortKeys"
            ],
            "updatePoint": {
                "line": 526,
                "column": 61
            },
            "line": 526,
            "code": "    test('does not replace when different sortStyle: COMPOUND', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: oldTableColumnsWithSortKeys,\n          sortStyle: TableSortStyle.AUTO,\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: oldTableColumnsWithSortKeys,\n        sortStyle: TableSortStyle.COMPOUND,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER COMPOUND SORTKEY(col1)`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace when different sortStyle: AUTO",
            "suites": [
                "update",
                "sortStyle and sortKeys"
            ],
            "updatePoint": {
                "line": 549,
                "column": 57
            },
            "line": 549,
            "code": "    test('does not replace when different sortStyle: AUTO', async () => {\n      const newEvent: AWSLambda.CloudFormationCustomResourceEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: oldTableColumnsWithSortKeys,\n          sortStyle: TableSortStyle.COMPOUND,\n        },\n      };\n      const newResourceProperties: ResourcePropertiesType = {\n        ...resourceProperties,\n        tableColumns: oldTableColumnsWithSortKeys,\n        sortStyle: TableSortStyle.AUTO,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER SORTKEY AUTO`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if comment added on table",
            "suites": [
                "update",
                "table comment"
            ],
            "updatePoint": {
                "line": 574,
                "column": 52
            },
            "line": 574,
            "code": "    test('does not replace if comment added on table', async () => {\n      const newComment = 'newComment';\n      const newResourceProperties = {\n        ...resourceProperties,\n        tableComment: newComment,\n      };\n\n      await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `COMMENT ON TABLE ${physicalResourceId} IS '${newComment}'`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if comment removed on table",
            "suites": [
                "update",
                "table comment"
            ],
            "updatePoint": {
                "line": 589,
                "column": 54
            },
            "line": 589,
            "code": "    test('does not replace if comment removed on table', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableComment: 'oldComment',\n        },\n      };\n      const newResourceProperties = {\n        ...resourceProperties,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `COMMENT ON TABLE ${physicalResourceId} IS NULL`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if comment added on column",
            "suites": [
                "update",
                "column comment"
            ],
            "updatePoint": {
                "line": 611,
                "column": 53
            },
            "line": 611,
            "code": "    test('does not replace if comment added on column', async () => {\n      const newComment = 'newComment';\n      const newResourceProperties = {\n        ...resourceProperties,\n        tableColumns: [{ name: 'col1', dataType: 'varchar(1)', comment: newComment }],\n      };\n\n      await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `COMMENT ON COLUMN ${physicalResourceId}.col1 IS '${newComment}'`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if comment removed on column",
            "suites": [
                "update",
                "column comment"
            ],
            "updatePoint": {
                "line": 626,
                "column": 55
            },
            "line": 626,
            "code": "    test('does not replace if comment removed on column', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [{ name: 'col1', dataType: 'varchar(1)', comment: 'oldComment' }],\n        },\n      };\n\n      await expect(manageTable(resourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `COMMENT ON COLUMN ${physicalResourceId}.col1 IS NULL`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if encoding added on column",
            "suites": [
                "update",
                "column encoding"
            ],
            "updatePoint": {
                "line": 645,
                "column": 54
            },
            "line": 645,
            "code": "    test('does not replace if encoding added on column', async () => {\n      const newResourceProperties = {\n        ...resourceProperties,\n        tableColumns: [{ name: 'col1', dataType: 'varchar(1)', encoding: ColumnEncoding.RAW }],\n      };\n\n      await expect(manageTable(newResourceProperties, event)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER COLUMN col1 ENCODE RAW`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if encoding removed on column",
            "suites": [
                "update",
                "column encoding"
            ],
            "updatePoint": {
                "line": 659,
                "column": 56
            },
            "line": 659,
            "code": "    test('does not replace if encoding removed on column', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [{ name: 'col1', dataType: 'varchar(1)', encoding: ColumnEncoding.RAW }],\n        },\n      };\n      const newResourceProperties = {\n        ...resourceProperties,\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER COLUMN col1 ENCODE AUTO`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "adds a comma between multiple statements",
            "suites": [
                "update",
                "column encoding"
            ],
            "updatePoint": {
                "line": 679,
                "column": 50
            },
            "line": 679,
            "code": "    test('adds a comma between multiple statements', async () => {\n      const newEvent = {\n        ...event,\n        OldResourceProperties: {\n          ...event.OldResourceProperties,\n          tableColumns: [{ name: 'col1', dataType: 'varchar(1)' }, { name: 'col2', dataType: 'varchar(1)' }],\n        },\n      };\n\n      const newResourceProperties = {\n        ...resourceProperties,\n        tableColumns: [{ name: 'col1', dataType: 'varchar(1)', encoding: ColumnEncoding.RAW }, { name: 'col2', dataType: 'varchar(1)', encoding: ColumnEncoding.RAW }],\n      };\n\n      await expect(manageTable(newResourceProperties, newEvent)).resolves.toMatchObject({\n        PhysicalResourceId: physicalResourceId,\n      });\n      expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n        Sql: `ALTER TABLE ${physicalResourceId} ALTER COLUMN col1 ENCODE RAW, ALTER COLUMN col2 ENCODE RAW`,\n      }));\n    });",
            "file": "database-query-provider/table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "serializes properties in statement and creates physical resource ID",
            "suites": [
                "create"
            ],
            "updatePoint": {
                "line": 51,
                "column": 75
            },
            "line": 51,
            "code": "  test('serializes properties in statement and creates physical resource ID', async () => {\n    const event = baseEvent;\n\n    await expect(manageUser(resourceProperties, event)).resolves.toEqual({\n      PhysicalResourceId: 'clusterName:databaseName:username:requestId',\n      Data: {\n        username: username,\n      },\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: `CREATE USER username PASSWORD '${password}'`,\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "executes statement",
            "suites": [
                "delete"
            ],
            "updatePoint": {
                "line": 73,
                "column": 26
            },
            "line": 73,
            "code": "  test('executes statement', async () => {\n    const event = baseEvent;\n\n    await manageUser(resourceProperties, event);\n\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: 'DROP USER username',\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if cluster name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 92,
                "column": 40
            },
            "line": 92,
            "code": "  test('replaces if cluster name changes', async () => {\n    const newClusterName = 'newClusterName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      clusterName: newClusterName,\n    };\n\n    await expect(manageUser(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      ClusterIdentifier: newClusterName,\n      Sql: expect.stringMatching(/CREATE USER/),\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if admin user ARN changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 108,
                "column": 50
            },
            "line": 108,
            "code": "  test('does not replace if admin user ARN changes', async () => {\n    const newAdminUserArn = 'newAdminUserArn';\n    const newResourceProperties = {\n      ...resourceProperties,\n      adminUserArn: newAdminUserArn,\n    };\n\n    await expect(manageUser(newResourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).not.toHaveBeenCalled();\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if database name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 121,
                "column": 41
            },
            "line": 121,
            "code": "  test('replaces if database name changes', async () => {\n    const newDatabaseName = 'newDatabaseName';\n    const newResourceProperties = {\n      ...resourceProperties,\n      databaseName: newDatabaseName,\n    };\n\n    await expect(manageUser(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Database: newDatabaseName,\n      Sql: expect.stringMatching(/CREATE USER/),\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "replaces if user name changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 137,
                "column": 37
            },
            "line": 137,
            "code": "  test('replaces if user name changes', async () => {\n    const newUsername = 'newUsername';\n    const newResourceProperties = {\n      ...resourceProperties,\n      username: newUsername,\n    };\n\n    await expect(manageUser(newResourceProperties, event)).resolves.not.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: expect.stringMatching(new RegExp(`CREATE USER ${newUsername}`)),\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not replace if password changes",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 152,
                "column": 44
            },
            "line": 152,
            "code": "  test('does not replace if password changes', async () => {\n    const newPassword = 'newPassword';\n    mockGetSecretValue.mockImplementationOnce(() => ({ promise: jest.fn(() => ({ SecretString: JSON.stringify({ password: newPassword }) })) }));\n\n    await expect(manageUser(resourceProperties, event)).resolves.toMatchObject({\n      PhysicalResourceId: physicalResourceId,\n    });\n    expect(mockExecuteStatement).toHaveBeenCalledWith(expect.objectContaining({\n      Sql: expect.stringMatching(new RegExp(`ALTER USER ${username} PASSWORD '${password}'`)),\n    }));\n  });",
            "file": "database-query-provider/user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "takes from cluster by default",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 32,
                "column": 37
            },
            "line": 32,
            "code": "    it('takes from cluster by default', () => {\n      new DatabaseQuery(stack, 'Query', {\n        ...minimalProps,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        adminUserArn: { Ref: 'ClusterSecretAttachment769E6258' },\n      });\n    });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "grants read permission to handler",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 42,
                "column": 41
            },
            "line": 42,
            "code": "    it('grants read permission to handler', () => {\n      new DatabaseQuery(stack, 'Query', {\n        ...minimalProps,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        PolicyDocument: {\n          Statement: Match.arrayWith([{\n            Action: ['secretsmanager:GetSecretValue', 'secretsmanager:DescribeSecret'],\n            Effect: 'Allow',\n            Resource: { Ref: 'ClusterSecretAttachment769E6258' },\n          }]),\n        },\n        Roles: [{ Ref: 'QueryRedshiftDatabase3de5bea727da479686625efb56431b5fServiceRole0A90D717' }],\n      });\n    });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "uses admin user if provided",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 59,
                "column": 35
            },
            "line": 59,
            "code": "    it('uses admin user if provided', () => {\n      cluster = new redshift.Cluster(stack, 'Cluster With Provided Admin Secret', {\n        vpc,\n        vpcSubnets: {\n          subnetType: ec2.SubnetType.PUBLIC,\n        },\n        masterUser: {\n          masterUsername: 'admin',\n          masterPassword: cdk.SecretValue.unsafePlainText('INSECURE_NOT_FOR_PRODUCTION'),\n        },\n        publiclyAccessible: true,\n      });\n\n      new DatabaseQuery(stack, 'Query', {\n        ...minimalProps,\n        adminUser: secretsmanager.Secret.fromSecretNameV2(stack, 'Imported Admin User', 'imported-admin-secret'),\n        cluster,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        adminUserArn: {\n          'Fn::Join': [\n            '',\n            [\n              'arn:',\n              {\n                Ref: 'AWS::Partition',\n              },\n              ':secretsmanager:',\n              {\n                Ref: 'AWS::Region',\n              },\n              ':',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              ':secret:imported-admin-secret',\n            ],\n          ],\n        },\n      });\n    });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws error if admin user not provided and cluster was provided a admin password",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 102,
                "column": 89
            },
            "line": 102,
            "code": "    it('throws error if admin user not provided and cluster was provided a admin password', () => {\n      cluster = new redshift.Cluster(stack, 'Cluster With Provided Admin Secret', {\n        vpc,\n        vpcSubnets: {\n          subnetType: ec2.SubnetType.PUBLIC,\n        },\n        masterUser: {\n          masterUsername: 'admin',\n          masterPassword: cdk.SecretValue.unsafePlainText('INSECURE_NOT_FOR_PRODUCTION'),\n        },\n        publiclyAccessible: true,\n      });\n\n      expect(() => new DatabaseQuery(stack, 'Query', {\n        ...minimalProps,\n        cluster,\n      })).toThrowError('Administrative access to the Redshift cluster is required but an admin user secret was not provided and the cluster did not generate admin user credentials (they were provided explicitly)');\n    });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws error if admin user not provided and cluster was imported",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 121,
                "column": 72
            },
            "line": 121,
            "code": "    it('throws error if admin user not provided and cluster was imported', () => {\n      cluster = redshift.Cluster.fromClusterAttributes(stack, 'Imported Cluster', {\n        clusterName: 'imported-cluster',\n        clusterEndpointAddress: 'imported-cluster.abcdefghijk.xx-west-1.redshift.amazonaws.com',\n        clusterEndpointPort: 5439,\n      });\n\n      expect(() => new DatabaseQuery(stack, 'Query', {\n        ...minimalProps,\n        cluster,\n      })).toThrowError('Administrative access to the Redshift cluster is required but an admin user secret was not provided and the cluster was imported');\n    });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "provides database params to Lambda handler",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 135,
                "column": 48
            },
            "line": 135,
            "code": "  it('provides database params to Lambda handler', () => {\n    new DatabaseQuery(stack, 'Query', {\n      ...minimalProps,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      clusterName: {\n        Ref: 'ClusterEB0386A7',\n      },\n      adminUserArn: {\n        Ref: 'ClusterSecretAttachment769E6258',\n      },\n      databaseName: 'databaseName',\n      handler: 'handler',\n    });\n  });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "grants statement permissions to handler",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 152,
                "column": 45
            },
            "line": 152,
            "code": "  it('grants statement permissions to handler', () => {\n    new DatabaseQuery(stack, 'Query', {\n      ...minimalProps,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: Match.arrayWith([{\n          Action: ['redshift-data:DescribeStatement', 'redshift-data:ExecuteStatement'],\n          Effect: 'Allow',\n          Resource: '*',\n        }]),\n      },\n      Roles: [{ Ref: 'QueryRedshiftDatabase3de5bea727da479686625efb56431b5fServiceRole0A90D717' }],\n    });\n  });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "passes removal policy through",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 169,
                "column": 35
            },
            "line": 169,
            "code": "  it('passes removal policy through', () => {\n    new DatabaseQuery(stack, 'Query', {\n      ...minimalProps,\n      removalPolicy: cdk.RemovalPolicy.DESTROY,\n    });\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      DeletionPolicy: 'Delete',\n    });\n  });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "passes applyRemovalPolicy through",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 180,
                "column": 39
            },
            "line": 180,
            "code": "  it('passes applyRemovalPolicy through', () => {\n    const query = new DatabaseQuery(stack, 'Query', {\n      ...minimalProps,\n    });\n\n    query.applyRemovalPolicy(cdk.RemovalPolicy.DESTROY);\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      DeletionPolicy: 'Delete',\n    });\n  });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "passes gettAtt through",
            "suites": [
                "database query",
                "admin user"
            ],
            "updatePoint": {
                "line": 192,
                "column": 28
            },
            "line": 192,
            "code": "  it('passes gettAtt through', () => {\n    const query = new DatabaseQuery(stack, 'Query', {\n      ...minimalProps,\n    });\n\n    expect(stack.resolve(query.getAtt('attribute'))).toStrictEqual({ 'Fn::GetAtt': ['Query435140A1', 'attribute'] });\n    expect(stack.resolve(query.getAttString('attribute'))).toStrictEqual({ 'Fn::GetAtt': ['Query435140A1', 'attribute'] });\n  });",
            "file": "database-query.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "create a cluster parameter group",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 38
            },
            "line": 5,
            "code": "test('create a cluster parameter group', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n\n  // WHEN\n  new ClusterParameterGroup(stack, 'Params', {\n    description: 'desc',\n    parameters: {\n      param: 'value',\n    },\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterParameterGroup', {\n    Description: 'desc',\n    ParameterGroupFamily: 'redshift-1.0',\n    Parameters: [\n      {\n        ParameterName: 'param',\n        ParameterValue: 'value',\n      },\n    ],\n  });\n\n});",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding a new parameter",
            "suites": [
                "Adding parameters to an existing group"
            ],
            "updatePoint": {
                "line": 32,
                "column": 30
            },
            "line": 32,
            "code": "  test('Adding a new parameter', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const params = new ClusterParameterGroup(stack, 'Params', {\n      description: 'desc',\n      parameters: {\n        param: 'value',\n      },\n    });\n\n    // WHEN\n    params.addParameter('param2', 'value2');\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterParameterGroup', {\n      Description: 'desc',\n      ParameterGroupFamily: 'redshift-1.0',\n      Parameters: [\n        {\n          ParameterName: 'param',\n          ParameterValue: 'value',\n        },\n        {\n          ParameterName: 'param2',\n          ParameterValue: 'value2',\n        },\n      ],\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding an existing named parameter with the same value",
            "suites": [
                "Adding parameters to an existing group"
            ],
            "updatePoint": {
                "line": 62,
                "column": 62
            },
            "line": 62,
            "code": "  test('Adding an existing named parameter with the same value', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const params = new ClusterParameterGroup(stack, 'Params', {\n      description: 'desc',\n      parameters: {\n        param: 'value',\n      },\n    });\n\n    // WHEN\n    params.addParameter('param', 'value');\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterParameterGroup', {\n      Description: 'desc',\n      ParameterGroupFamily: 'redshift-1.0',\n      Parameters: [\n        {\n          ParameterName: 'param',\n          ParameterValue: 'value',\n        },\n      ],\n    });\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "Adding an existing named parameter with a different value",
            "suites": [
                "Adding parameters to an existing group"
            ],
            "updatePoint": {
                "line": 88,
                "column": 65
            },
            "line": 88,
            "code": "  test('Adding an existing named parameter with a different value', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const params = new ClusterParameterGroup(stack, 'Params', {\n      description: 'desc',\n      parameters: {\n        param: 'value',\n      },\n    });\n\n    // WHEN\n    expect(() => params.addParameter('param', 'value2'))\n      // THEN\n      .toThrowError('The parameter group already contains the parameter');\n  });",
            "file": "parameter-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "adding table privilege creates custom resource",
            "suites": [
                "table privileges"
            ],
            "updatePoint": {
                "line": 47,
                "column": 52
            },
            "line": 47,
            "code": "  it('adding table privilege creates custom resource', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    user.addTablePrivileges(table, redshift.TableAction.INSERT);\n    user.addTablePrivileges(table2, redshift.TableAction.SELECT, redshift.TableAction.DROP);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      username: {\n        'Fn::GetAtt': [\n          'UserFDDCDD17',\n          'username',\n        ],\n      },\n      tablePrivileges: [{ tableName: 'tableName', actions: ['INSERT'] }, { tableName: 'tableName2', actions: ['SELECT', 'DROP'] }],\n    });\n  });",
            "file": "privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "table privileges are deduplicated",
            "suites": [
                "table privileges"
            ],
            "updatePoint": {
                "line": 64,
                "column": 39
            },
            "line": 64,
            "code": "  it('table privileges are deduplicated', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    user.addTablePrivileges(table, redshift.TableAction.INSERT, redshift.TableAction.INSERT, redshift.TableAction.DELETE);\n    user.addTablePrivileges(table, redshift.TableAction.SELECT, redshift.TableAction.DELETE);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      username: {\n        'Fn::GetAtt': [\n          'UserFDDCDD17',\n          'username',\n        ],\n      },\n      tablePrivileges: [{ tableName: 'tableName', actions: ['SELECT', 'DELETE', 'INSERT'] }],\n    });\n  });",
            "file": "privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "table privileges are removed when ALL specified",
            "suites": [
                "table privileges"
            ],
            "updatePoint": {
                "line": 81,
                "column": 53
            },
            "line": 81,
            "code": "  it('table privileges are removed when ALL specified', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    user.addTablePrivileges(table, redshift.TableAction.ALL, redshift.TableAction.INSERT);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      username: {\n        'Fn::GetAtt': [\n          'UserFDDCDD17',\n          'username',\n        ],\n      },\n      tablePrivileges: [{ tableName: 'tableName', actions: ['ALL'] }],\n    });\n  });",
            "file": "privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "SELECT table privilege is added when UPDATE or DELETE is specified",
            "suites": [
                "table privileges"
            ],
            "updatePoint": {
                "line": 97,
                "column": 72
            },
            "line": 97,
            "code": "  it('SELECT table privilege is added when UPDATE or DELETE is specified', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    user.addTablePrivileges(table, redshift.TableAction.UPDATE);\n    user.addTablePrivileges(table2, redshift.TableAction.DELETE);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      username: {\n        'Fn::GetAtt': [\n          'UserFDDCDD17',\n          'username',\n        ],\n      },\n      tablePrivileges: [{ tableName: 'tableName', actions: ['UPDATE', 'SELECT'] }, { tableName: 'tableName2', actions: ['DELETE', 'SELECT'] }],\n    });\n  });",
            "file": "privileges.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "creates a subnet group from minimal properties",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 52
            },
            "line": 14,
            "code": "test('creates a subnet group from minimal properties', () => {\n  new ClusterSubnetGroup(stack, 'Group', {\n    description: 'MyGroup',\n    vpc,\n  });\n\n  Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterSubnetGroup', {\n    Description: 'MyGroup',\n    SubnetIds: [\n      { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n      { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n    ],\n  });\n});",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "defaults to private subnets",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 30,
                "column": 35
            },
            "line": 30,
            "code": "  test('defaults to private subnets', () => {\n    new ClusterSubnetGroup(stack, 'Group', {\n      description: 'MyGroup',\n      vpc,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterSubnetGroup', {\n      Description: 'MyGroup',\n      SubnetIds: [\n        { Ref: 'VPCPrivateSubnet1Subnet8BCA10E0' },\n        { Ref: 'VPCPrivateSubnet2SubnetCFCDAA7A' },\n      ],\n    });\n  });",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can specify subnet type",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 45,
                "column": 31
            },
            "line": 45,
            "code": "  test('can specify subnet type', () => {\n    new ClusterSubnetGroup(stack, 'Group', {\n      description: 'MyGroup',\n      vpc,\n      vpcSubnets: { subnetType: ec2.SubnetType.PUBLIC },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::Redshift::ClusterSubnetGroup', {\n      Description: 'MyGroup',\n      SubnetIds: [\n        { Ref: 'VPCPublicSubnet1SubnetB4246D30' },\n        { Ref: 'VPCPublicSubnet2Subnet74179F39' },\n      ],\n    });\n  });",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "import group by name",
            "suites": [
                "subnet selection"
            ],
            "updatePoint": {
                "line": 62,
                "column": 26
            },
            "line": 62,
            "code": "test('import group by name', () => {\n  const subnetGroup = ClusterSubnetGroup.fromClusterSubnetGroupName(stack, 'Group', 'my-subnet-group');\n\n  expect(subnetGroup.clusterSubnetGroupName).toBe('my-subnet-group');\n});",
            "file": "subnet-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "creates using custom resource",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 39,
                "column": 35
            },
            "line": 39,
            "code": "  it('creates using custom resource', () => {\n    new redshift.Table(stack, 'Table', {\n      ...databaseOptions,\n      tableColumns,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      tableName: {\n        prefix: 'Table',\n        generateSuffix: 'true',\n      },\n      tableColumns,\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "tableName property is pulled from custom resource",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 54,
                "column": 55
            },
            "line": 54,
            "code": "  it('tableName property is pulled from custom resource', () => {\n    const table = new redshift.Table(stack, 'Table', {\n      ...databaseOptions,\n      tableColumns,\n    });\n\n    expect(stack.resolve(table.tableName)).toStrictEqual({\n      Ref: 'Table7ABB320E',\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "uses table name when provided",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 65,
                "column": 35
            },
            "line": 65,
            "code": "  it('uses table name when provided', () => {\n    new redshift.Table(stack, 'Table', {\n      ...databaseOptions,\n      tableName,\n      tableColumns,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      tableName: {\n        prefix: tableName,\n        generateSuffix: 'false',\n      },\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can import from name and columns",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 80,
                "column": 38
            },
            "line": 80,
            "code": "  it('can import from name and columns', () => {\n    const table = redshift.Table.fromTableAttributes(stack, 'Table', {\n      tableName,\n      tableColumns,\n      cluster,\n      databaseName: 'databaseName',\n    });\n\n    expect(table.tableName).toBe(tableName);\n    expect(table.tableColumns).toStrictEqual(tableColumns);\n    expect(table.cluster).toBe(cluster);\n    expect(table.databaseName).toBe('databaseName');\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "grant adds privileges to user",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 94,
                "column": 35
            },
            "line": 94,
            "code": "  it('grant adds privileges to user', () => {\n    const user = redshift.User.fromUserAttributes(stack, 'User', {\n      ...databaseOptions,\n      username: 'username',\n      password: cdk.SecretValue.unsafePlainText('INSECURE_NOT_FOR_PRODUCTION'),\n    });\n    const table = redshift.Table.fromTableAttributes(stack, 'Table', {\n      tableName,\n      tableColumns,\n      cluster,\n      databaseName: 'databaseName',\n    });\n\n    table.grant(user, redshift.TableAction.INSERT);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      handler: 'user-table-privileges',\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "retains table on deletion by default",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 114,
                "column": 42
            },
            "line": 114,
            "code": "  it('retains table on deletion by default', () => {\n    new redshift.Table(stack, 'Table', {\n      ...databaseOptions,\n      tableColumns,\n    });\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      Properties: {\n        handler: 'table',\n      },\n      DeletionPolicy: 'Retain',\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "destroys table on deletion if requested",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 128,
                "column": 45
            },
            "line": 128,
            "code": "  it('destroys table on deletion if requested', () => {\n    const table = new redshift.Table(stack, 'Table', {\n      ...databaseOptions,\n      tableColumns,\n    });\n\n    table.applyRemovalPolicy(cdk.RemovalPolicy.DESTROY);\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      Properties: {\n        handler: 'table',\n      },\n      DeletionPolicy: 'Delete',\n    });\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if column ids are similar",
            "suites": [
                "cluster table"
            ],
            "updatePoint": {
                "line": 144,
                "column": 38
            },
            "line": 144,
            "code": "  it('throws if column ids are similar', async () => {\n    const updatedTableColumns: redshift.Column[] = [\n      { id: 'col1', name: 'col1', dataType: 'varchar(4)' },\n      { id: 'col1', name: 'col2', dataType: 'float' },\n    ];\n\n    expect(\n      () => new redshift.Table(stack, 'Table', {\n        ...databaseOptions,\n        tableColumns: updatedTableColumns,\n      }),\n    ).toThrow(\"Column id 'col1' is not unique.\");\n  });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "uses column ids if feature flag provided",
            "suites": [
                "cluster table",
                "@aws-cdk/aws-redshift:columnId"
            ],
            "updatePoint": {
                "line": 159,
                "column": 48
            },
            "line": 159,
            "code": "    it('uses column ids if feature flag provided', () => {\n      const app = new cdk.App({ context: { [REDSHIFT_COLUMN_ID]: true } });\n      const newStack = new cdk.Stack(app, 'NewStack');\n      vpc = new ec2.Vpc(newStack, 'VPC');\n      cluster = new redshift.Cluster(newStack, 'Cluster', {\n        vpc: vpc,\n        vpcSubnets: {\n          subnetType: ec2.SubnetType.PUBLIC,\n        },\n        masterUser: {\n          masterUsername: 'admin',\n        },\n        publiclyAccessible: true,\n      });\n      databaseOptions = {\n        cluster: cluster,\n        databaseName: 'databaseName',\n      };\n\n      new redshift.Table(newStack, 'Table', {\n        ...databaseOptions,\n        tableColumns,\n      });\n\n      Template.fromStack(newStack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        useColumnIds: true,\n      });\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "does not use column ids if feature flag not provided",
            "suites": [
                "cluster table",
                "@aws-cdk/aws-redshift:columnId"
            ],
            "updatePoint": {
                "line": 188,
                "column": 60
            },
            "line": 188,
            "code": "    it('does not use column ids if feature flag not provided', () => {\n      new redshift.Table(stack, 'Table', {\n        ...databaseOptions,\n        tableColumns,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        useColumnIds: false,\n      });\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if more than one distKeys are configured",
            "suites": [
                "cluster table",
                "distKey and distStyle"
            ],
            "updatePoint": {
                "line": 201,
                "column": 55
            },
            "line": 201,
            "code": "    it('throws if more than one distKeys are configured', () => {\n      const updatedTableColumns: redshift.Column[] = [\n        ...tableColumns,\n        { name: 'col3', dataType: 'varchar(4)', distKey: true },\n        { name: 'col4', dataType: 'float', distKey: true },\n      ];\n\n      expect(\n        () => new redshift.Table(stack, 'Table', {\n          ...databaseOptions,\n          tableColumns: updatedTableColumns,\n        }),\n      ).toThrow(/Only one column can be configured as distKey./);\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if distStyle other than KEY is configured with configured distKey column",
            "suites": [
                "cluster table",
                "distKey and distStyle"
            ],
            "updatePoint": {
                "line": 216,
                "column": 87
            },
            "line": 216,
            "code": "    it('throws if distStyle other than KEY is configured with configured distKey column', () => {\n      const updatedTableColumns: redshift.Column[] = [\n        ...tableColumns,\n        { name: 'col3', dataType: 'varchar(4)', distKey: true },\n      ];\n\n      expect(\n        () => new redshift.Table(stack, 'Table', {\n          ...databaseOptions,\n          tableColumns: updatedTableColumns,\n          distStyle: redshift.TableDistStyle.EVEN,\n        }),\n      ).toThrow(`Only 'TableDistStyle.KEY' can be configured when distKey is also configured. Found ${redshift.TableDistStyle.EVEN}`);\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if KEY distStyle is configired with no distKey column",
            "suites": [
                "cluster table",
                "distKey and distStyle"
            ],
            "updatePoint": {
                "line": 231,
                "column": 68
            },
            "line": 231,
            "code": "    it('throws if KEY distStyle is configired with no distKey column', () => {\n      expect(\n        () => new redshift.Table(stack, 'Table', {\n          ...databaseOptions,\n          tableColumns,\n          distStyle: redshift.TableDistStyle.KEY,\n        }),\n      ).toThrow('distStyle of \"TableDistStyle.KEY\" can only be configured when distKey is also configured.');\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "configures default sortStyle based on sortKeys if no sortStyle is passed: AUTO",
            "suites": [
                "cluster table",
                "sortKeys and sortStyle"
            ],
            "updatePoint": {
                "line": 243,
                "column": 86
            },
            "line": 243,
            "code": "    it('configures default sortStyle based on sortKeys if no sortStyle is passed: AUTO', () => {\n      // GIVEN\n      const tableColumnsWithoutSortKey = tableColumns;\n\n      // WHEN\n      new redshift.Table(stack, 'Table', {\n        ...databaseOptions,\n        tableColumns: tableColumnsWithoutSortKey,\n      });\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        sortStyle: redshift.TableSortStyle.AUTO,\n      });\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "configures default sortStyle based on sortKeys if no sortStyle is passed: COMPOUND",
            "suites": [
                "cluster table",
                "sortKeys and sortStyle"
            ],
            "updatePoint": {
                "line": 259,
                "column": 90
            },
            "line": 259,
            "code": "    it('configures default sortStyle based on sortKeys if no sortStyle is passed: COMPOUND', () => {\n      // GIVEN\n      const tableColumnsWithSortKey: redshift.Column[] = [\n        ...tableColumns,\n        { name: 'col3', dataType: 'varchar(4)', sortKey: true },\n      ];\n\n      // WHEN\n      new redshift.Table(stack, 'Table', {\n        ...databaseOptions,\n        tableColumns: tableColumnsWithSortKey,\n      });\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n        sortStyle: redshift.TableSortStyle.COMPOUND,\n      });\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if sortStlye other than AUTO is passed with no configured sortKeys",
            "suites": [
                "cluster table",
                "sortKeys and sortStyle"
            ],
            "updatePoint": {
                "line": 278,
                "column": 81
            },
            "line": 278,
            "code": "    it('throws if sortStlye other than AUTO is passed with no configured sortKeys', () => {\n      expect(\n        () => new redshift.Table(stack, 'Table', {\n          ...databaseOptions,\n          tableColumns,\n          sortStyle: redshift.TableSortStyle.COMPOUND,\n        }),\n      ).toThrow(`sortStyle of '${redshift.TableSortStyle.COMPOUND}' can only be configured when sortKey is also configured.`);\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "throws if sortStlye of AUTO is passed with some configured sortKeys",
            "suites": [
                "cluster table",
                "sortKeys and sortStyle"
            ],
            "updatePoint": {
                "line": 288,
                "column": 75
            },
            "line": 288,
            "code": "    it('throws if sortStlye of AUTO is passed with some configured sortKeys', () => {\n      // GIVEN\n      const tableColumnsWithSortKey: redshift.Column[] = [\n        ...tableColumns,\n        { name: 'col3', dataType: 'varchar(4)', sortKey: true },\n      ];\n\n      // THEN\n      expect(\n        () => new redshift.Table(stack, 'Table', {\n          ...databaseOptions,\n          tableColumns: tableColumnsWithSortKey,\n          sortStyle: redshift.TableSortStyle.AUTO,\n        }),\n      ).toThrow(`sortStyle of '${redshift.TableSortStyle.AUTO}' cannot be configured when sortKey is also configured.`);\n    });",
            "file": "table.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "creates using custom resource",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 34,
                "column": 35
            },
            "line": 34,
            "code": "  it('creates using custom resource', () => {\n    new redshift.User(stack, 'User', databaseOptions);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      passwordSecretArn: { Ref: 'UserSecretAttachment02022609' },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n      PolicyDocument: {\n        Statement: Match.arrayWith([{\n          Action: ['secretsmanager:GetSecretValue', 'secretsmanager:DescribeSecret'],\n          Effect: 'Allow',\n          Resource: { Ref: 'UserSecretAttachment02022609' },\n        }]),\n      },\n      Roles: [{ Ref: 'QueryRedshiftDatabase3de5bea727da479686625efb56431b5fServiceRole0A90D717' }],\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "creates database secret",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 52,
                "column": 29
            },
            "line": 52,
            "code": "  it('creates database secret', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n      GenerateSecretString: {\n        SecretStringTemplate: `{\"username\":\"${cdk.Names.uniqueId(user).toLowerCase()}\"}`,\n      },\n    });\n    Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::SecretTargetAttachment', {\n      SecretId: { Ref: 'UserSecretE2C04A69' },\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "username property is pulled from custom resource",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 65,
                "column": 54
            },
            "line": 65,
            "code": "  it('username property is pulled from custom resource', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    expect(stack.resolve(user.username)).toStrictEqual({\n      'Fn::GetAtt': [\n        'UserFDDCDD17',\n        'username',\n      ],\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "password property is pulled from attached secret",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 76,
                "column": 54
            },
            "line": 76,
            "code": "  it('password property is pulled from attached secret', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    expect(stack.resolve(user.password)).toStrictEqual({\n      'Fn::Join': [\n        '',\n        [\n          '{{resolve:secretsmanager:',\n          {\n            Ref: 'UserSecretAttachment02022609',\n          },\n          ':SecretString:password::}}',\n        ],\n      ],\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "secret property is exposed",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 93,
                "column": 32
            },
            "line": 93,
            "code": "  it('secret property is exposed', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    expect(stack.resolve(user.secret.secretArn)).toStrictEqual({\n      Ref: 'UserSecretE2C04A69',\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "uses username when provided",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 101,
                "column": 33
            },
            "line": 101,
            "code": "  it('uses username when provided', () => {\n    const username = 'username';\n\n    new redshift.User(stack, 'User', {\n      ...databaseOptions,\n      username,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n      GenerateSecretString: {\n        SecretStringTemplate: `{\"username\":\"${username}\"}`,\n      },\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "can import from username and password",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 116,
                "column": 43
            },
            "line": 116,
            "code": "  it('can import from username and password', () => {\n    const userSecret = secretsmanager.Secret.fromSecretNameV2(stack, 'User Secret', 'redshift-user-secret');\n\n    const user = redshift.User.fromUserAttributes(stack, 'User', {\n      ...databaseOptions,\n      username: userSecret.secretValueFromJson('username').toString(),\n      password: userSecret.secretValueFromJson('password'),\n    });\n\n    expect(stack.resolve(user.username)).toStrictEqual({\n      'Fn::Join': [\n        '',\n        [\n          '{{resolve:secretsmanager:arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':secretsmanager:',\n          {\n            Ref: 'AWS::Region',\n          },\n          ':',\n          {\n            Ref: 'AWS::AccountId',\n          },\n          ':secret:redshift-user-secret:SecretString:username::}}',\n        ],\n      ],\n    });\n    expect(stack.resolve(user.password)).toStrictEqual({\n      'Fn::Join': [\n        '',\n        [\n          '{{resolve:secretsmanager:arn:',\n          {\n            Ref: 'AWS::Partition',\n          },\n          ':secretsmanager:',\n          {\n            Ref: 'AWS::Region',\n          },\n          ':',\n          {\n            Ref: 'AWS::AccountId',\n          },\n          ':secret:redshift-user-secret:SecretString:password::}}',\n        ],\n      ],\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "destroys user on deletion by default",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 167,
                "column": 42
            },
            "line": 167,
            "code": "  it('destroys user on deletion by default', () => {\n    new redshift.User(stack, 'User', databaseOptions);\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      Properties: {\n        passwordSecretArn: { Ref: 'UserSecretAttachment02022609' },\n      },\n      DeletionPolicy: 'Delete',\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "retains user on deletion if requested",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 178,
                "column": 43
            },
            "line": 178,
            "code": "  it('retains user on deletion if requested', () => {\n    const user = new redshift.User(stack, 'User', databaseOptions);\n\n    user.applyRemovalPolicy(cdk.RemovalPolicy.RETAIN);\n\n    Template.fromStack(stack).hasResource('Custom::RedshiftDatabaseQuery', {\n      Properties: {\n        passwordSecretArn: { Ref: 'UserSecretAttachment02022609' },\n      },\n      DeletionPolicy: 'Retain',\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "uses encryption key if one is provided",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 191,
                "column": 44
            },
            "line": 191,
            "code": "  it('uses encryption key if one is provided', () => {\n    const encryptionKey = new kms.Key(stack, 'Key');\n\n    new redshift.User(stack, 'User', {\n      ...databaseOptions,\n      encryptionKey,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::SecretsManager::Secret', {\n      KmsKeyId: stack.resolve(encryptionKey.keyArn),\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "addTablePrivileges grants access to table",
            "suites": [
                "cluster user"
            ],
            "updatePoint": {
                "line": 204,
                "column": 47
            },
            "line": 204,
            "code": "  it('addTablePrivileges grants access to table', () => {\n    const user = redshift.User.fromUserAttributes(stack, 'User', {\n      ...databaseOptions,\n      username: 'username',\n      password: cdk.SecretValue.unsafePlainText('INSECURE_NOT_FOR_PRODUCTION'),\n    });\n    const table = redshift.Table.fromTableAttributes(stack, 'Table', {\n      tableName: 'tableName',\n      tableColumns: [{ name: 'col1', dataType: 'varchar(4)' }, { name: 'col2', dataType: 'float' }],\n      cluster,\n      databaseName: 'databaseName',\n    });\n\n    user.addTablePrivileges(table, redshift.TableAction.INSERT);\n\n    Template.fromStack(stack).hasResourceProperties('Custom::RedshiftDatabaseQuery', {\n      handler: 'user-table-privileges',\n    });\n  });",
            "file": "user.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-redshift/test"
        },
        {
            "name": "domain list from strings",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 30
            },
            "line": 12,
            "code": "test('domain list from strings', () => {\n  // WHEN\n  new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromList([\n      'first-domain.com',\n      'second-domain.net',\n      '*.wildcard.com',\n    ]),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallDomainList', {\n    Domains: [\n      'first-domain.com',\n      'second-domain.net',\n      '*.wildcard.com',\n    ],\n  });\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "domain list from S3 URL",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 29
            },
            "line": 32,
            "code": "test('domain list from S3 URL', () => {\n  // WHEN\n  new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromS3Url('s3://bucket/prefix/object'),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallDomainList', {\n    DomainFileUrl: 's3://bucket/prefix/object',\n  });\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "domain list from S3",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 25
            },
            "line": 44,
            "code": "test('domain list from S3', () => {\n  // WHEN\n  new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromS3(Bucket.fromBucketName(stack, 'Bucket', 'bucket'), 'prefix/object'),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallDomainList', {\n    DomainFileUrl: 's3://bucket/prefix/object',\n  });\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "domain list from asset",
            "suites": [],
            "updatePoint": {
                "line": 56,
                "column": 28
            },
            "line": 56,
            "code": "test('domain list from asset', () => {\n  // WHEN\n  new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromAsset(path.join(__dirname, 'domains.txt')),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallDomainList', {\n    DomainFileUrl: {\n      'Fn::Sub': 's3://cdk-hnb659fds-assets-${AWS::AccountId}-${AWS::Region}/e820b3f07bf66854be0dfd6f3ec357a10d644f2011069e5ad07d42f4f89ed35a.txt',\n    },\n  });\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "throws with invalid name",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 30
            },
            "line": 70,
            "code": "test('throws with invalid name', () => {\n  expect(() => new FirewallDomainList(stack, 'List', {\n    name: 'Inv@lid',\n    domains: FirewallDomains.fromList(['domain.com']),\n  })).toThrow(/Invalid domain list name/);\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "throws with invalid domain",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 32
            },
            "line": 77,
            "code": "test('throws with invalid domain', () => {\n  expect(() => new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromList(['valid.fr', 'inv@lid.com']),\n  })).toThrow(/Invalid domain/);\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "throws with fromAsset and not .txt",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 40
            },
            "line": 83,
            "code": "test('throws with fromAsset and not .txt', () => {\n  expect(() => new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromAsset('image.jpg'),\n  })).toThrow(/expects a file with the .txt extension/);\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "throws with invalid S3 URL",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 32
            },
            "line": 89,
            "code": "test('throws with invalid S3 URL', () => {\n  expect(() => new FirewallDomainList(stack, 'List', {\n    domains: FirewallDomains.fromS3Url('https://invalid/bucket/url'),\n  })).toThrow(/The S3 URL must start with s3:\\/\\//);\n});",
            "file": "firewall-domain-list.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "basic rule group",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 22
            },
            "line": 13,
            "code": "test('basic rule group', () => {\n  // WHEN\n  new FirewallRuleGroup(stack, 'RuleGroup', {\n    rules: [\n      {\n        priority: 10,\n        firewallDomainList,\n        action: FirewallRuleAction.block(),\n      },\n    ],\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallRuleGroup', {\n    FirewallRules: [\n      {\n        Action: 'BLOCK',\n        BlockResponse: 'NODATA',\n        FirewallDomainListId: 'domain-list-id',\n        Priority: 10,\n      },\n    ],\n  });\n});",
            "file": "firewall-rule-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "use addRule to add rules",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 30
            },
            "line": 38,
            "code": "test('use addRule to add rules', () => {\n  // GIVEN\n  const ruleGroup = new FirewallRuleGroup(stack, 'RuleGroup', {\n    rules: [\n      {\n        priority: 10,\n        firewallDomainList,\n        action: FirewallRuleAction.allow(),\n      },\n    ],\n  });\n\n  // WHEN\n  ruleGroup.addRule({\n    priority: 20,\n    firewallDomainList: FirewallDomainList.fromFirewallDomainListId(stack, 'OtherList', 'other-list-id'),\n    action: FirewallRuleAction.allow(),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallRuleGroup', {\n    FirewallRules: [\n      {\n        Action: 'ALLOW',\n        FirewallDomainListId: 'domain-list-id',\n        Priority: 10,\n      },\n      {\n        Action: 'ALLOW',\n        FirewallDomainListId: 'other-list-id',\n        Priority: 20,\n      },\n    ],\n  });\n});",
            "file": "firewall-rule-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "rule with response override",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 33
            },
            "line": 74,
            "code": "test('rule with response override', () => {\n  // GIVEN\n  const ruleGroup = new FirewallRuleGroup(stack, 'RuleGroup');\n\n  // WHEN\n  ruleGroup.addRule({\n    priority: 10,\n    firewallDomainList,\n    action: FirewallRuleAction.block(DnsBlockResponse.override('amazon.com', Duration.minutes(5))),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallRuleGroup', {\n    FirewallRules: [\n      {\n        Action: 'BLOCK',\n        BlockOverrideDnsType: 'CNAME',\n        BlockOverrideDomain: 'amazon.com',\n        BlockOverrideTtl: 300,\n        BlockResponse: 'OVERRIDE',\n        FirewallDomainListId: 'domain-list-id',\n        Priority: 10,\n      },\n    ],\n  });\n});",
            "file": "firewall-rule-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "associate rule group with a vpc",
            "suites": [],
            "updatePoint": {
                "line": 101,
                "column": 37
            },
            "line": 101,
            "code": "test('associate rule group with a vpc', () => {\n  // GIVEN\n  const vpc = new Vpc(stack, 'Vpc');\n  const ruleGroup = new FirewallRuleGroup(stack, 'RuleGroup');\n\n  // WHEN\n  ruleGroup.associate('Association', {\n    priority: 101,\n    vpc,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Route53Resolver::FirewallRuleGroupAssociation', {\n    FirewallRuleGroupId: {\n      'Fn::GetAtt': [\n        'RuleGroup06BA8844',\n        'Id',\n      ],\n    },\n    Priority: 101,\n    VpcId: {\n      Ref: 'Vpc8378EB38',\n    },\n  });\n});",
            "file": "firewall-rule-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "throws when associating with a priority not between 100-9,000",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 67
            },
            "line": 127,
            "code": "test('throws when associating with a priority not between 100-9,000', () => {\n  // GIVEN\n  const vpc = new Vpc(stack, 'Vpc');\n  const ruleGroup = new FirewallRuleGroup(stack, 'RuleGroup');\n\n  // THEN\n  expect(() => ruleGroup.associate('Association', {\n    priority: 100,\n    vpc,\n  })).toThrow(/Priority must be greater than 100 and less than 9000/);\n});",
            "file": "firewall-rule-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-route53resolver/test"
        },
        {
            "name": "Can create a valid access point",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 37
            },
            "line": 21,
            "code": "test('Can create a valid access point', () => {\n  const accessPoint = new AccessPoint(stack, 'MyObjectLambda', {\n    bucket,\n    handler,\n    accessPointName: 'obj-lambda',\n    supportsGetObjectRange: true,\n    supportsGetObjectPartNumber: true,\n    payload: { foo: 10 },\n  });\n  new cdk.CfnOutput(stack, 'AccessPointName', {\n    value: accessPoint.accessPointName,\n  });\n  new cdk.CfnOutput(stack, 'DomainName', {\n    value: accessPoint.domainName,\n  });\n  new cdk.CfnOutput(stack, 'RegionalDomainName', {\n    value: accessPoint.regionalDomainName,\n  });\n  new cdk.CfnOutput(stack, 'VirtualHostedUrl', {\n    value: accessPoint.virtualHostedUrlForObject('key', {\n      regional: true,\n    }),\n  });\n  new cdk.CfnOutput(stack, 'VirtualHostedRegionalUrl', {\n    value: accessPoint.virtualHostedUrlForObject('key', {\n      regional: false,\n    }),\n  });\n\n  expect(Template.fromStack(stack).findOutputs('*')).toEqual(\n    {\n      AccessPointName: {\n        Value: {\n          Ref: 'MyObjectLambda3F9602DC',\n        },\n      },\n      DomainName: {\n        Value: {\n          'Fn::Join': [\n            '',\n            [\n              {\n                Ref: 'MyObjectLambda3F9602DC',\n              },\n              '-',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              '.s3-object-lambda.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n            ],\n          ],\n        },\n      },\n      RegionalDomainName: {\n        Value: {\n          'Fn::Join': [\n            '',\n            [\n              {\n                Ref: 'MyObjectLambda3F9602DC',\n              },\n              '-',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              '.s3-object-lambda.',\n              {\n                Ref: 'AWS::Region',\n              },\n              '.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n            ],\n          ],\n        },\n      },\n      VirtualHostedRegionalUrl: {\n        Value: {\n          'Fn::Join': [\n            '',\n            [\n              'https://',\n              {\n                Ref: 'MyObjectLambda3F9602DC',\n              },\n              '-',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              '.s3-object-lambda.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n              '/key',\n            ],\n          ],\n        },\n      },\n      VirtualHostedUrl: {\n        Value: {\n          'Fn::Join': [\n            '',\n            [\n              'https://',\n              {\n                Ref: 'MyObjectLambda3F9602DC',\n              },\n              '-',\n              {\n                Ref: 'AWS::AccountId',\n              },\n              '.s3-object-lambda.',\n              {\n                Ref: 'AWS::Region',\n              },\n              '.',\n              {\n                Ref: 'AWS::URLSuffix',\n              },\n              '/key',\n            ],\n          ],\n        },\n      },\n    },\n  );\n\n  Template.fromStack(stack).hasResourceProperties('AWS::S3ObjectLambda::AccessPoint', {\n    ObjectLambdaConfiguration: {\n      AllowedFeatures: [\n        'GetObject-PartNumber',\n        'GetObject-Range',\n      ],\n      TransformationConfigurations: [\n        {\n          Actions: [\n            'GetObject',\n          ],\n          ContentTransformation: {\n            AwsLambda: {\n              FunctionArn: {\n                'Fn::GetAtt': [\n                  'MyFunction3BAA72D1',\n                  'Arn',\n                ],\n              },\n              FunctionPayload: '{\"foo\":10}',\n            },\n          },\n        },\n      ],\n    },\n  });\n});",
            "file": "s3objectlambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-s3objectlambda/test"
        },
        {
            "name": "Can create an access point without specifying the name",
            "suites": [],
            "updatePoint": {
                "line": 180,
                "column": 60
            },
            "line": 180,
            "code": "test('Can create an access point without specifying the name', () => {\n  new AccessPoint(stack, 'MyObjectLambda', {\n    bucket,\n    handler,\n  });\n  Template.fromStack(stack).hasResourceProperties('AWS::S3ObjectLambda::AccessPoint', {\n    ObjectLambdaConfiguration: {\n      AllowedFeatures: [],\n    },\n  });\n});",
            "file": "s3objectlambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-s3objectlambda/test"
        },
        {
            "name": "Slashes are removed from the virtual hosted url",
            "suites": [],
            "updatePoint": {
                "line": 192,
                "column": 53
            },
            "line": 192,
            "code": "test('Slashes are removed from the virtual hosted url', () => {\n  const accessPoint = new AccessPoint(stack, 'MyObjectLambda', {\n    bucket,\n    handler,\n  });\n  new cdk.CfnOutput(stack, 'VirtualHostedUrlNoKey', {\n    value: accessPoint.virtualHostedUrlForObject(),\n  });\n  new cdk.CfnOutput(stack, 'VirtualHostedUrlKeyBeginsSlash', {\n    value: accessPoint.virtualHostedUrlForObject('/key1/key2'),\n  });\n  new cdk.CfnOutput(stack, 'VirtualHostedUrlKeyEndsSlash', {\n    value: accessPoint.virtualHostedUrlForObject('key1/key2/'),\n  });\n  expect(Template.fromStack(stack).findOutputs('*')).toEqual( {\n    VirtualHostedUrlKeyBeginsSlash: {\n      Value: {\n        'Fn::Join': [\n          '',\n          [\n            'https://',\n            {\n              Ref: 'MyObjectLambda3F9602DC',\n            },\n            '-',\n            {\n              Ref: 'AWS::AccountId',\n            },\n            '.s3-object-lambda.',\n            {\n              Ref: 'AWS::Region',\n            },\n            '.',\n            {\n              Ref: 'AWS::URLSuffix',\n            },\n            '/key1/key2',\n          ],\n        ],\n      },\n    },\n    VirtualHostedUrlKeyEndsSlash: {\n      Value: {\n        'Fn::Join': [\n          '',\n          [\n            'https://',\n            {\n              Ref: 'MyObjectLambda3F9602DC',\n            },\n            '-',\n            {\n              Ref: 'AWS::AccountId',\n            },\n            '.s3-object-lambda.',\n            {\n              Ref: 'AWS::Region',\n            },\n            '.',\n            {\n              Ref: 'AWS::URLSuffix',\n            },\n            '/key1/key2',\n          ],\n        ],\n      },\n    },\n    VirtualHostedUrlNoKey: {\n      Value: {\n        'Fn::Join': [\n          '',\n          [\n            'https://',\n            {\n              Ref: 'MyObjectLambda3F9602DC',\n            },\n            '-',\n            {\n              Ref: 'AWS::AccountId',\n            },\n            '.s3-object-lambda.',\n            {\n              Ref: 'AWS::Region',\n            },\n            '.',\n            {\n              Ref: 'AWS::URLSuffix',\n            },\n          ],\n        ],\n      },\n    },\n  });\n});",
            "file": "s3objectlambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-s3objectlambda/test"
        },
        {
            "name": "Validates the access point name",
            "suites": [],
            "updatePoint": {
                "line": 287,
                "column": 37
            },
            "line": 287,
            "code": "test('Validates the access point name', () => {\n  expect(() => new AccessPoint(stack, 'MyObjectLambda1', {\n    bucket,\n    handler,\n    accessPointName: 'aa',\n  })).toThrowError(/name must be between 3 and 50 characters long/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda2', {\n    bucket,\n    handler,\n    accessPointName: 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',\n  })).toThrowError(/name must be between 3 and 50 characters long/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda3', {\n    bucket,\n    handler,\n    accessPointName: 'aaaa-s3alias',\n  })).toThrowError(/name cannot end with the suffix -s3alias/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda4', {\n    bucket,\n    handler,\n    accessPointName: '-aaaaa',\n  })).toThrowError(/name cannot begin or end with a dash/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda5', {\n    bucket,\n    handler,\n    accessPointName: 'aaaaa-',\n  })).toThrowError(/name cannot begin or end with a dash/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda6', {\n    bucket,\n    handler,\n    accessPointName: 'Aaaaa',\n  })).toThrowError(/name must begin with a number or lowercase letter and not contain underscores, uppercase letters, or periods/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda7', {\n    bucket,\n    handler,\n    accessPointName: '$aaaaa',\n  })).toThrowError(/name must begin with a number or lowercase letter and not contain underscores, uppercase letters, or periods/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda8', {\n    bucket,\n    handler,\n    accessPointName: 'aaaAaaa',\n  })).toThrowError(/name must begin with a number or lowercase letter and not contain underscores, uppercase letters, or periods/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda9', {\n    bucket,\n    handler,\n    accessPointName: 'aaa_aaa',\n  })).toThrowError(/name must begin with a number or lowercase letter and not contain underscores, uppercase letters, or periods/);\n  expect(() => new AccessPoint(stack, 'MyObjectLambda10', {\n    bucket,\n    handler,\n    accessPointName: 'aaa.aaa',\n  })).toThrowError(/name must begin with a number or lowercase letter and not contain underscores, uppercase letters, or periods/);\n});",
            "file": "s3objectlambda.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-s3objectlambda/test"
        },
        {
            "name": "with more than 10 production variants, an exception is thrown",
            "suites": [
                "When synthesizing a stack containing an EndpointConfig"
            ],
            "updatePoint": {
                "line": 6,
                "column": 69
            },
            "line": 6,
            "code": "  test('with more than 10 production variants, an exception is thrown', () => {\n    // GIVEN\n    const app = new cdk.App();\n    const stack = new cdk.Stack(app);\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', {\n      instanceProductionVariants: [{\n        variantName: 'variant',\n        model,\n      }],\n    });\n    for (let i = 0; i < 10; i++) {\n      endpointConfig.addInstanceProductionVariant({ variantName: `variant-${i}`, model });\n    }\n\n    // WHEN\n    const when = () => app.synth();\n\n    // THEN\n    expect(when).toThrow(/Can\\'t have more than 10 production variants/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with no production variants, an exception is thrown",
            "suites": [
                "When synthesizing a stack containing an EndpointConfig"
            ],
            "updatePoint": {
                "line": 28,
                "column": 59
            },
            "line": 28,
            "code": "  test('with no production variants, an exception is thrown', () => {\n    // GIVEN\n    const app = new cdk.App();\n    const stack = new cdk.Stack(app);\n    new sagemaker.EndpointConfig(stack, 'EndpointConfig');\n\n    // WHEN\n    const when = () => app.synth();\n\n    // THEN\n    expect(when).toThrow(/Must configure at least 1 production variant/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with too few instances specified, an exception is thrown",
            "suites": [
                "When adding a production variant to an EndpointConfig"
            ],
            "updatePoint": {
                "line": 43,
                "column": 64
            },
            "line": 43,
            "code": "  test('with too few instances specified, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n\n    // WHEN\n    const when = () =>\n      endpointConfig.addInstanceProductionVariant({\n        variantName: 'new-variant',\n        model,\n        initialInstanceCount: 0,\n      });\n\n    // THEN\n    expect(when).toThrow(/Invalid Production Variant Props: Must have at least one instance/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with a negative weight, an exception is thrown",
            "suites": [
                "When adding a production variant to an EndpointConfig"
            ],
            "updatePoint": {
                "line": 61,
                "column": 54
            },
            "line": 61,
            "code": "  test('with a negative weight, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n\n    // WHEN\n    const when = () =>\n      endpointConfig.addInstanceProductionVariant({\n        variantName: 'new-variant',\n        model,\n        initialVariantWeight: -1,\n      });\n\n    // THEN\n    expect(when).toThrow(/Invalid Production Variant Props: Cannot have negative variant weight/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with a duplicate variant name, an exception is thrown",
            "suites": [
                "When adding a production variant to an EndpointConfig"
            ],
            "updatePoint": {
                "line": 79,
                "column": 61
            },
            "line": 79,
            "code": "  test('with a duplicate variant name, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n\n    // WHEN\n    const when = () => endpointConfig.addInstanceProductionVariant({ variantName: 'variant', model });\n\n    // THEN\n    expect(when).toThrow(/There is already a Production Variant with name 'variant'/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "that exists, the variant is returned",
            "suites": [
                "When searching an EndpointConfig for a production variant"
            ],
            "updatePoint": {
                "line": 94,
                "column": 44
            },
            "line": 94,
            "code": "  test('that exists, the variant is returned', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n\n    // WHEN\n    const variant = endpointConfig._findInstanceProductionVariant('variant');\n\n    // THEN\n    expect(variant.variantName).toEqual('variant');\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "that does not exist, an exception is thrown",
            "suites": [
                "When searching an EndpointConfig for a production variant"
            ],
            "updatePoint": {
                "line": 107,
                "column": 51
            },
            "line": 107,
            "code": "  test('that does not exist, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n\n    // WHEN\n    const when = () => endpointConfig._findInstanceProductionVariant('missing-variant');\n\n    // THEN\n    expect(when).toThrow(/No variant with name: 'missing-variant'/);\n  });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When importing an endpoint configuration by ARN, the name is determined correctly",
            "suites": [
                "When searching an EndpointConfig for a production variant"
            ],
            "updatePoint": {
                "line": 121,
                "column": 87
            },
            "line": 121,
            "code": "test('When importing an endpoint configuration by ARN, the name is determined correctly', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n\n  // WHEN\n  const endpointConfig = sagemaker.EndpointConfig.fromEndpointConfigArn(stack, 'EndpointConfig', 'arn:aws:sagemaker:us-west-2:123456789012:endpoint-config/my-name');\n\n  // THEN\n  expect(endpointConfig.endpointConfigName).toEqual('my-name');\n});",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When importing an endpoint configuration by name, the ARN is constructed correctly",
            "suites": [
                "When searching an EndpointConfig for a production variant"
            ],
            "updatePoint": {
                "line": 132,
                "column": 88
            },
            "line": 132,
            "code": "test('When importing an endpoint configuration by name, the ARN is constructed correctly', () => {\n  // GIVEN\n  const stack = new cdk.Stack(undefined, undefined, {\n    env:\n      {\n        region: 'us-west-2',\n        account: '123456789012',\n      },\n  });\n\n  // WHEN\n  const endpointConfig = sagemaker.EndpointConfig.fromEndpointConfigName(stack, 'EndpointConfig', 'my-name');\n\n  // THEN\n  expect(endpointConfig.endpointConfigArn).toMatch(/arn:.+:sagemaker:us-west-2:123456789012:endpoint-config\\/my-name/);\n});",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack account boundaries, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an owned Model instance"
            ],
            "updatePoint": {
                "line": 151,
                "column": 58
            },
            "line": 151,
            "code": "    test('across stack account boundaries, synthesis fails', () => {\n      // GIVEN\n      const app = new cdk.App();\n      const originStack = new cdk.Stack(app, 'OriginStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '123456789012',\n          },\n      });\n      const originStackModel = new sagemaker.Model(originStack, 'MyModel', {\n        modelName: 'explicitly-named-model',\n        containers: [{\n          image: sagemaker.ContainerImage.fromAsset(path.join(__dirname, 'test-image')),\n        }],\n      });\n      const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '234567890123',\n          },\n      });\n\n      // WHEN\n      const when = () =>\n        new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n          instanceProductionVariants: [{\n            variantName: 'my-variant',\n            model: originStackModel,\n          }],\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot use model in account 123456789012 for endpoint configuration in account 234567890123/);\n    });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack region boundaries, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an owned Model instance"
            ],
            "updatePoint": {
                "line": 188,
                "column": 57
            },
            "line": 188,
            "code": "    test('across stack region boundaries, synthesis fails', () => {\n      // GIVEN\n      const app = new cdk.App();\n      const originStack = new cdk.Stack(app, 'OriginStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '123456789012',\n          },\n      });\n      const originStackModel = new sagemaker.Model(originStack, 'MyModel', {\n        modelName: 'explicitly-named-model',\n        containers: [{\n          image: sagemaker.ContainerImage.fromAsset(path.join(__dirname, 'test-image')),\n        }],\n      });\n      const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n        env:\n          {\n            region: 'us-east-1',\n            account: '123456789012',\n          },\n      });\n\n      // WHEN\n      const when = () =>\n        new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n          instanceProductionVariants: [{\n            variantName: 'my-variant',\n            model: originStackModel,\n          }],\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot use model in region us-west-2 for endpoint configuration in region us-east-1/);\n    });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack account boundaries, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an unowned IModel instance",
                "imported by name"
            ],
            "updatePoint": {
                "line": 228,
                "column": 60
            },
            "line": 228,
            "code": "      test('across stack account boundaries, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '123456789012',\n            },\n        });\n        const originStackModel = sagemaker.Model.fromModelName(originStack, 'MyModel', 'explicitly-named-model');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n            instanceProductionVariants: [{\n              variantName: 'my-variant',\n              model: originStackModel,\n            }],\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use model in account 123456789012 for endpoint configuration in account 234567890123/);\n      });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack region boundaries, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an unowned IModel instance",
                "imported by name"
            ],
            "updatePoint": {
                "line": 260,
                "column": 59
            },
            "line": 260,
            "code": "      test('across stack region boundaries, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '123456789012',\n            },\n        });\n        const originStackModel = sagemaker.Model.fromModelName(originStack, 'MyModel', 'explicitly-named-model');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n            instanceProductionVariants: [{\n              variantName: 'my-variant',\n              model: originStackModel,\n            }],\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use model in region us-west-2 for endpoint configuration in region us-east-1/);\n      });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "in a different account than both stacks, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an unowned IModel instance",
                "imported by ARN"
            ],
            "updatePoint": {
                "line": 294,
                "column": 68
            },
            "line": 294,
            "code": "      test('in a different account than both stacks, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n        const originStackModel = sagemaker.Model.fromModelArn(originStack, 'MyModel', 'arn:aws:sagemaker:us-west-2:123456789012:endpoint-config/explicitly-named-model');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n            instanceProductionVariants: [{\n              variantName: 'my-variant',\n              model: originStackModel,\n            }],\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use model in account 123456789012 for endpoint configuration in account 234567890123/);\n      });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "in a different region than both stacks, synthesis fails",
            "suites": [
                "When sharing a model from an origin stack with a destination stack",
                "which represents an unowned IModel instance",
                "imported by ARN"
            ],
            "updatePoint": {
                "line": 326,
                "column": 67
            },
            "line": 326,
            "code": "      test('in a different region than both stacks, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n        const originStackModel = sagemaker.Model.fromModelArn(originStack, 'MyModel', 'arn:aws:sagemaker:us-west-2:123456789012:endpoint-config/explicitly-named-model');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.EndpointConfig(destinationStack, 'MyEndpointConfig', {\n            instanceProductionVariants: [{\n              variantName: 'my-variant',\n              model: originStackModel,\n            }],\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use model in region us-west-2 for endpoint configuration in region us-east-1/);\n      });",
            "file": "endpoint-config.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "that exists, the variant is returned",
            "suites": [
                "When searching an Endpoint for a production variant"
            ],
            "updatePoint": {
                "line": 5,
                "column": 44
            },
            "line": 5,
            "code": "  test('that exists, the variant is returned', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n\n    // WHEN\n    const variant = endpoint.findInstanceProductionVariant('variant');\n\n    // THEN\n    expect(variant.variantName).toEqual('variant');\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "that does not exist, an exception is thrown",
            "suites": [
                "When searching an Endpoint for a production variant"
            ],
            "updatePoint": {
                "line": 19,
                "column": 51
            },
            "line": 19,
            "code": "  test('that does not exist, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n\n    // WHEN\n    const when = () => endpoint.findInstanceProductionVariant('missing-variant');\n\n    // THEN\n    expect(when).toThrow(/No variant with name: 'missing-variant'/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "from an imported IEndpointConfig, an exception is thrown",
            "suites": [
                "When searching an Endpoint for a production variant"
            ],
            "updatePoint": {
                "line": 33,
                "column": 64
            },
            "line": 33,
            "code": "  test('from an imported IEndpointConfig, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const endpointConfig = sagemaker.EndpointConfig.fromEndpointConfigName(stack, 'EndpointConfig', 'MyEndpointConfig');\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n\n    // WHEN\n    const when = () => endpoint.findInstanceProductionVariant('variant');\n\n    // THEN\n    expect(when).toThrow(/Production variant lookup is not supported for an imported IEndpointConfig/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with one production variant, the variant is returned",
            "suites": [
                "When fetching production variants from an Endpoint"
            ],
            "updatePoint": {
                "line": 48,
                "column": 60
            },
            "line": 48,
            "code": "  test('with one production variant, the variant is returned', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n\n    // WHEN\n    const variants: sagemaker.IEndpointInstanceProductionVariant[] = endpoint.instanceProductionVariants;\n\n    // THEN\n    expect(variants.length).toEqual(1);\n    expect(variants[0].variantName).toEqual('variant');\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with an imported IEndpointConfig, an exception is thrown",
            "suites": [
                "When fetching production variants from an Endpoint"
            ],
            "updatePoint": {
                "line": 63,
                "column": 64
            },
            "line": 63,
            "code": "  test('with an imported IEndpointConfig, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const endpointConfig = sagemaker.EndpointConfig.fromEndpointConfigName(stack, 'EndpointConfig', 'MyEndpointConfig');\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n\n    // WHEN\n    const when = () => endpoint.instanceProductionVariants;\n\n    // THEN\n    expect(when).toThrow(/Production variant lookup is not supported for an imported IEndpointConfig/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack account boundaries, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an owned EndpointConfig instance"
            ],
            "updatePoint": {
                "line": 107,
                "column": 58
            },
            "line": 107,
            "code": "    test('across stack account boundaries, synthesis fails', () => {\n      // GIVEN\n      const app = new cdk.App();\n      const originStack = new cdk.Stack(app, 'OriginStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '123456789012',\n          },\n      });\n      const originStackEndpointConfig = new sagemaker.EndpointConfig(originStack, 'MyEndpointConfig', {\n        endpointConfigName: 'explicit-name',\n        instanceProductionVariants: [{\n          variantName: 'my-variant',\n          model: sagemaker.Model.fromModelName(originStack, 'MyModel', 'my-model'),\n        }],\n      });\n      const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '234567890123',\n          },\n      });\n\n      // WHEN\n      const when = () =>\n        new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n          endpointConfig: originStackEndpointConfig,\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot use endpoint configuration in account 123456789012 for endpoint in account 234567890123/);\n    });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack region boundaries, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an owned EndpointConfig instance"
            ],
            "updatePoint": {
                "line": 142,
                "column": 57
            },
            "line": 142,
            "code": "    test('across stack region boundaries, synthesis fails', () => {\n      // GIVEN\n      const app = new cdk.App();\n      const originStack = new cdk.Stack(app, 'OriginStack', {\n        env:\n          {\n            region: 'us-west-2',\n            account: '123456789012',\n          },\n      });\n      const originStackEndpointConfig = new sagemaker.EndpointConfig(originStack, 'MyEndpointConfig', {\n        endpointConfigName: 'explicit-name',\n        instanceProductionVariants: [{\n          variantName: 'my-variant',\n          model: sagemaker.Model.fromModelName(originStack, 'MyModel', 'my-model'),\n        }],\n      });\n      const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n        env:\n          {\n            region: 'us-east-1',\n            account: '123456789012',\n          },\n      });\n\n      // WHEN\n      const when = () =>\n        new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n          endpointConfig: originStackEndpointConfig,\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot use endpoint configuration in region us-west-2 for endpoint in region us-east-1/);\n    });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack account boundaries, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an unowned IEndpointConfig instance",
                "imported by name"
            ],
            "updatePoint": {
                "line": 180,
                "column": 60
            },
            "line": 180,
            "code": "      test('across stack account boundaries, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '123456789012',\n            },\n        });\n        const originStackEndpointConfig = sagemaker.EndpointConfig.fromEndpointConfigName(originStack, 'MyEndpointConfig', 'explicit-name');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n            endpointConfig: originStackEndpointConfig,\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use endpoint configuration in account 123456789012 for endpoint in account 234567890123/);\n      });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "across stack region boundaries, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an unowned IEndpointConfig instance",
                "imported by name"
            ],
            "updatePoint": {
                "line": 209,
                "column": 59
            },
            "line": 209,
            "code": "      test('across stack region boundaries, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '123456789012',\n            },\n        });\n        const originStackEndpointConfig = sagemaker.EndpointConfig.fromEndpointConfigName(originStack, 'MyEndpointConfig', 'explicit-name');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n            endpointConfig: originStackEndpointConfig,\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use endpoint configuration in region us-west-2 for endpoint in region us-east-1/);\n      });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "in a different account than both stacks, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an unowned IEndpointConfig instance",
                "imported by ARN"
            ],
            "updatePoint": {
                "line": 240,
                "column": 68
            },
            "line": 240,
            "code": "      test('in a different account than both stacks, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n        const originStackEndpointConfig = sagemaker.EndpointConfig.fromEndpointConfigArn(originStack, 'MyEndpointConfig', 'arn:aws:sagemaker:us-west-2:123456789012:endpoint/explicit-name');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-west-2',\n              account: '234567890123',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n            endpointConfig: originStackEndpointConfig,\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use endpoint configuration in account 123456789012 for endpoint in account 234567890123/);\n      });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "in a different region than both stacks, synthesis fails",
            "suites": [
                "When sharing an endpoint config from an origin stack with a destination stack",
                "which represents an unowned IEndpointConfig instance",
                "imported by ARN"
            ],
            "updatePoint": {
                "line": 269,
                "column": 67
            },
            "line": 269,
            "code": "      test('in a different region than both stacks, synthesis fails', () => {\n        // GIVEN\n        const app = new cdk.App();\n        const originStack = new cdk.Stack(app, 'OriginStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n        const originStackEndpointConfig = sagemaker.EndpointConfig.fromEndpointConfigArn(originStack, 'MyEndpointConfig', 'arn:aws:sagemaker:us-west-2:123456789012:endpoint/explicit-name');\n        const destinationStack = new cdk.Stack(app, 'DestinationStack', {\n          env:\n            {\n              region: 'us-east-1',\n              account: '123456789012',\n            },\n        });\n\n        // WHEN\n        const when = () =>\n          new sagemaker.Endpoint(destinationStack, 'MyEndpoint', {\n            endpointConfig: originStackEndpointConfig,\n          });\n\n        // THEN\n        expect(when).toThrow(/Cannot use endpoint configuration in region us-west-2 for endpoint in region us-east-1/);\n      });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with minimum capacity greater than initial instance count, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 302,
                "column": 89
            },
            "line": 302,
            "code": "  test('with minimum capacity greater than initial instance count, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model }] });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n\n    // WHEN\n    const when = () => variant.autoScaleInstanceCount({\n      minCapacity: 2,\n      maxCapacity: 3,\n    });\n\n    // THEN\n    expect(when).toThrow(/minCapacity cannot be greater than initial instance count: 1/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with maximum capacity less than initial instance count, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 320,
                "column": 86
            },
            "line": 320,
            "code": "  test('with maximum capacity less than initial instance count, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', { instanceProductionVariants: [{ variantName: 'variant', model, initialInstanceCount: 2 }] });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n\n    // WHEN\n    const when = () => variant.autoScaleInstanceCount({ maxCapacity: 1 });\n\n    // THEN\n    expect(when).toThrow(/maxCapacity cannot be less than initial instance count: 2/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with burstable instance type, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 335,
                "column": 60
            },
            "line": 335,
            "code": "  test('with burstable instance type, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', {\n      instanceProductionVariants: [{\n        variantName: 'variant',\n        model,\n        instanceType: sagemaker.InstanceType.T2_MEDIUM,\n      }],\n    });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n\n    // WHEN\n    const when = () => variant.autoScaleInstanceCount({ maxCapacity: 3 });\n\n    // THEN\n    expect(when).toThrow(/AutoScaling not supported for burstable instance types like ml.t2.medium/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "which already has auto-scaling enabled, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 356,
                "column": 70
            },
            "line": 356,
            "code": "  test('which already has auto-scaling enabled, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', {\n      instanceProductionVariants: [{\n        variantName: 'variant',\n        model,\n        instanceType: sagemaker.InstanceType.M5_LARGE,\n      }],\n    });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n    variant.autoScaleInstanceCount({ maxCapacity: 3 });\n\n    // WHEN\n    const when = () => variant.autoScaleInstanceCount({ maxCapacity: 3 });\n\n    // THEN\n    expect(when).toThrow(/AutoScaling of task count already enabled for this service/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with a safety factor of zero, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 378,
                "column": 60
            },
            "line": 378,
            "code": "  test('with a safety factor of zero, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', {\n      instanceProductionVariants: [{\n        variantName: 'variant',\n        model,\n        initialInstanceCount: 2,\n        instanceType: sagemaker.InstanceType.M5_LARGE,\n      }],\n    });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n    const instanceCount = variant.autoScaleInstanceCount({ maxCapacity: 3 });\n\n    // WHEN\n    const when = () =>\n      instanceCount.scaleOnInvocations('LimitRPS', {\n        maxRequestsPerSecond: 30,\n        safetyFactor: 0,\n      });\n\n    // THEN\n    expect(when).toThrow(/Safety factor \\(0\\) must be greater than 0.0 and less than or equal 1\\.0/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with a safety factor greater than one, an exception is thrown",
            "suites": [
                "When auto-scaling a production variant's instance count"
            ],
            "updatePoint": {
                "line": 405,
                "column": 69
            },
            "line": 405,
            "code": "  test('with a safety factor greater than one, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const model = sagemaker.Model.fromModelName(stack, 'Model', 'model');\n    const endpointConfig = new sagemaker.EndpointConfig(stack, 'EndpointConfig', {\n      instanceProductionVariants: [{\n        variantName: 'variant',\n        model,\n        initialInstanceCount: 2,\n        instanceType: sagemaker.InstanceType.M5_LARGE,\n      }],\n    });\n    const endpoint = new sagemaker.Endpoint(stack, 'Endpoint', { endpointConfig });\n    const variant = endpoint.findInstanceProductionVariant('variant');\n    const instanceCount = variant.autoScaleInstanceCount({ maxCapacity: 3 });\n\n    // WHEN\n    const when = () =>\n      instanceCount.scaleOnInvocations('LimitRPS', {\n        maxRequestsPerSecond: 30,\n        safetyFactor: 1.1,\n      });\n\n    // THEN\n    expect(when).toThrow(/Safety factor \\(1\\.1\\) must be greater than 0.0 and less than or equal 1\\.0/);\n  });",
            "file": "endpoint.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "by supplying a directory, an exception is thrown",
            "suites": [
                "When creating model data from a local asset"
            ],
            "updatePoint": {
                "line": 5,
                "column": 56
            },
            "line": 5,
            "code": "  test('by supplying a directory, an exception is thrown', () => {\n    // WHEN\n    const when = () => sagemaker.ModelData.fromAsset(path.join(__dirname, 'test-artifacts'));\n\n    // THEN\n    expect(when).toThrow(/Asset must be a gzipped tar file with extension .tar.gz/);\n  });",
            "file": "model-data.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "by supplying a zip file, an exception is thrown",
            "suites": [
                "When creating model data from a local asset"
            ],
            "updatePoint": {
                "line": 13,
                "column": 55
            },
            "line": 13,
            "code": "  test('by supplying a zip file, an exception is thrown', () => {\n    // WHEN\n    const when = () => sagemaker.ModelData.fromAsset(path.join(__dirname, 'test-artifacts', 'invalid-artifact.zip'));\n\n    // THEN\n    expect(when).toThrow(/Asset must be a gzipped tar file with extension .tar.gz/);\n  });",
            "file": "model-data.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "by supplying a file with an unsupported extension, an exception is thrown",
            "suites": [
                "When creating model data from a local asset"
            ],
            "updatePoint": {
                "line": 21,
                "column": 81
            },
            "line": 21,
            "code": "  test('by supplying a file with an unsupported extension, an exception is thrown', () => {\n    // WHEN\n    const when = () => sagemaker.ModelData.fromAsset(path.join(__dirname, 'test-artifacts', 'invalid-artifact.tar'));\n\n    // THEN\n    expect(when).toThrow(/Asset must be a gzipped tar file with extension .tar.gz/);\n  });",
            "file": "model-data.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with more than 15 containers, an exception is thrown on synthesis",
            "suites": [
                "When instantiating SageMaker Model"
            ],
            "updatePoint": {
                "line": 12,
                "column": 73
            },
            "line": 12,
            "code": "  test('with more than 15 containers, an exception is thrown on synthesis', () => {\n    // GIVEN\n    const app = new cdk.App();\n    const stack = new cdk.Stack(app);\n    const testRepo = ecr.Repository.fromRepositoryName(stack, 'testRepo', '123456789012.dkr.ecr.us-west-2.amazonaws.com/mymodel');\n    const containers = [{ image: sagemaker.ContainerImage.fromEcrRepository(testRepo) }];\n    for (let i = 0; i < 15; i++) {\n      const containerDefinition = {\n        image: sagemaker.ContainerImage.fromEcrRepository(testRepo),\n      };\n      containers.push(containerDefinition);\n    }\n    new sagemaker.Model(stack, 'Model', { containers });\n\n    // WHEN\n    const when = () => app.synth();\n\n    // THEN\n    expect(when).toThrow(/Cannot have more than 15 containers in inference pipeline/);\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with no containers, an exception is thrown on synthesis",
            "suites": [
                "When instantiating SageMaker Model"
            ],
            "updatePoint": {
                "line": 33,
                "column": 63
            },
            "line": 33,
            "code": "  test('with no containers, an exception is thrown on synthesis', () => {\n    // GIVEN\n    const app = new cdk.App();\n    const stack = new cdk.Stack(app);\n    new sagemaker.Model(stack, 'Model');\n\n    // WHEN\n    const when = () => app.synth();\n\n    // THEN\n    expect(when).toThrow(/Must configure at least 1 container for model/);\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with a ContainerImage implementation which adds constructs of its own, the new constructs are present",
            "suites": [
                "When instantiating SageMaker Model"
            ],
            "updatePoint": {
                "line": 46,
                "column": 109
            },
            "line": 46,
            "code": "  test('with a ContainerImage implementation which adds constructs of its own, the new constructs are present', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    class ConstructCreatingContainerImage extends sagemaker.ContainerImage {\n      public bind(scope: constructs.Construct, _model: sagemaker.Model): sagemaker.ContainerImageConfig {\n        new iam.User(scope, 'User', {\n          userName: 'ExtraConstructUserName',\n        });\n        return {\n          imageName: 'anything',\n        };\n      }\n    }\n\n    // WHEN\n    new sagemaker.Model(stack, 'Model', {\n      containers: [{\n        image: new ConstructCreatingContainerImage(),\n      }],\n    });\n\n    // THEN\n    const template = Template.fromStack(stack);\n    template.hasResourceProperties('AWS::SageMaker::Model', {});\n    template.hasResourceProperties('AWS::IAM::User', {\n      UserName: 'ExtraConstructUserName',\n    });\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "with 2 identical ContainerDefinitions, each file-based asset is instantiated once",
            "suites": [
                "When instantiating SageMaker Model"
            ],
            "updatePoint": {
                "line": 75,
                "column": 89
            },
            "line": 75,
            "code": "  test('with 2 identical ContainerDefinitions, each file-based asset is instantiated once', () => {\n    // GIVEN\n    const app = new cdk.App();\n    const stack = new cdk.Stack(app);\n    const image = sagemaker.ContainerImage.fromAsset(path.join(__dirname, 'test-image'));\n    const modelData = sagemaker.ModelData.fromAsset(path.join(__dirname, 'test-artifacts', 'valid-artifact.tar.gz'));\n    const container: sagemaker.ContainerDefinition = { image, modelData };\n    new sagemaker.Model(stack, 'Model', {\n      containers: [\n        container,\n        container,\n      ],\n    });\n\n    // WHEN\n    const assembly = app.synth();\n\n    // THEN\n    const manifest = JSON.parse(fs.readFileSync(path.join(assembly.directory, `${stack.stackName}.assets.json`), 'utf-8'));\n    // The assembly asset manifest should include:\n    // - Two file assets for the model data asset and the stack template\n    // - One Docker image asset\n    expect(Object.entries(manifest.files)).toHaveLength(2);\n    expect(Object.entries(manifest.dockerImages)).toHaveLength(1);\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "and security groups, no security group is created",
            "suites": [
                "When instantiating SageMaker Model",
                "with a VPC"
            ],
            "updatePoint": {
                "line": 102,
                "column": 59
            },
            "line": 102,
            "code": "    test('and security groups, no security group is created', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n      const vpc = new ec2.Vpc(stack, 'testVPC');\n\n      // WHEN\n      new sagemaker.Model(stack, 'Model', {\n        containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n        vpc,\n        securityGroups: [new ec2.SecurityGroup(stack, 'SG', { vpc })],\n      });\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroup', Match.not({\n        GroupDescription: 'Default/Model/SecurityGroup',\n      }));\n    });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "but no security groups, a security group is created",
            "suites": [
                "When instantiating SageMaker Model",
                "with a VPC"
            ],
            "updatePoint": {
                "line": 120,
                "column": 61
            },
            "line": 120,
            "code": "    test('but no security groups, a security group is created', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      new sagemaker.Model(stack, 'Model', {\n        containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n        vpc: new ec2.Vpc(stack, 'testVPC'),\n      });\n\n      // THEN\n      Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroup', {\n        GroupDescription: 'Default/Model/SecurityGroup',\n      });\n    });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "and both security groups and allowAllOutbound are specified, an exception is thrown",
            "suites": [
                "When instantiating SageMaker Model",
                "with a VPC"
            ],
            "updatePoint": {
                "line": 136,
                "column": 93
            },
            "line": 136,
            "code": "    test('and both security groups and allowAllOutbound are specified, an exception is thrown', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n      const vpc = new ec2.Vpc(stack, 'testVPC');\n\n      // WHEN\n      const when = () =>\n        new sagemaker.Model(stack, 'Model', {\n          containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n          vpc,\n          securityGroups: [new ec2.SecurityGroup(stack, 'SG', { vpc })],\n          allowAllOutbound: false,\n        });\n\n      // THEN\n      expect(when).toThrow(/Configure 'allowAllOutbound' directly on the supplied SecurityGroups/);\n    });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "but security groups are specified, an exception is thrown",
            "suites": [
                "When instantiating SageMaker Model",
                "without a VPC"
            ],
            "updatePoint": {
                "line": 156,
                "column": 67
            },
            "line": 156,
            "code": "    test('but security groups are specified, an exception is thrown', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n      const vpcNotSpecified = new ec2.Vpc(stack, 'VPC');\n\n      // WHEN\n      const when = () =>\n        new sagemaker.Model(stack, 'Model', {\n          containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n          securityGroups: [new ec2.SecurityGroup(stack, 'SG', { vpc: vpcNotSpecified })],\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot configure 'securityGroups' or 'allowAllOutbound' without configuring a VPC/);\n    });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "but allowAllOutbound is specified, an exception is thrown",
            "suites": [
                "When instantiating SageMaker Model",
                "without a VPC"
            ],
            "updatePoint": {
                "line": 172,
                "column": 67
            },
            "line": 172,
            "code": "    test('but allowAllOutbound is specified, an exception is thrown', () => {\n      // GIVEN\n      const stack = new cdk.Stack();\n\n      // WHEN\n      const when = () =>\n        new sagemaker.Model(stack, 'Model', {\n          containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n          allowAllOutbound: false,\n        });\n\n      // THEN\n      expect(when).toThrow(/Cannot configure 'securityGroups' or 'allowAllOutbound' without configuring a VPC/);\n    });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "from a model with no VPC, an exception is thrown",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 190,
                "column": 56
            },
            "line": 190,
            "code": "  test('from a model with no VPC, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const modelWithoutVpc = new sagemaker.Model(stack, 'Model', {\n      containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n    });\n\n    // WHEN\n    const when = () => modelWithoutVpc.connections;\n\n    // THEN\n    expect(when).toThrow(/Cannot manage network access without configuring a VPC/);\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "from an imported model with no security groups specified, an exception is thrown",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 204,
                "column": 88
            },
            "line": 204,
            "code": "  test('from an imported model with no security groups specified, an exception is thrown', () => {\n    // GIVEN\n    const stack = new cdk.Stack();\n    const importedModel = sagemaker.Model.fromModelAttributes(stack, 'Model', {\n      modelArn: 'arn:aws:sagemaker:us-west-2:123456789012:model/MyModel',\n    });\n\n    // WHEN\n    const when = () => importedModel.connections;\n\n    // THEN\n    expect(when).toThrow(/Cannot manage network access without configuring a VPC/);\n  });",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When adding security group after model instantiation, it is reflected in VpcConfig of Model",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 219,
                "column": 97
            },
            "line": 219,
            "code": "test('When adding security group after model instantiation, it is reflected in VpcConfig of Model', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const vpc = new ec2.Vpc(stack, 'testVPC');\n  const model = new sagemaker.Model(stack, 'Model', {\n    containers: [{ image: sagemaker.ContainerImage.fromEcrRepository(new ecr.Repository(stack, 'Repo')) }],\n    vpc,\n  });\n\n  // WHEN\n  model.connections.addSecurityGroup(new ec2.SecurityGroup(stack, 'AdditionalGroup', { vpc }));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::SageMaker::Model', {\n    VpcConfig: {\n      SecurityGroupIds: [\n        {\n          'Fn::GetAtt': [\n            'ModelSecurityGroup2A7C9E10',\n            'GroupId',\n          ],\n        },\n        {\n          'Fn::GetAtt': [\n            'AdditionalGroup4973CFAA',\n            'GroupId',\n          ],\n        },\n      ],\n    },\n  });\n});",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When allowing traffic from an imported model with a security group, an S3 egress rule should be present",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 252,
                "column": 109
            },
            "line": 252,
            "code": "test('When allowing traffic from an imported model with a security group, an S3 egress rule should be present', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n  const model = sagemaker.Model.fromModelAttributes(stack, 'Model', {\n    modelArn: 'arn:aws:sagemaker:us-west-2:123456789012:model/MyModel',\n    securityGroups: [ec2.SecurityGroup.fromSecurityGroupId(stack, 'SG', 'sg-123456789', {\n      allowAllOutbound: false,\n    })],\n  });\n\n  // WHEN\n  model.connections.allowToAnyIpv4(ec2.Port.tcp(443));\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::EC2::SecurityGroupEgress', {\n    GroupId: 'sg-123456789',\n  });\n});",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When importing a model by ARN, the model name is determined correctly",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 271,
                "column": 75
            },
            "line": 271,
            "code": "test('When importing a model by ARN, the model name is determined correctly', () => {\n  // GIVEN\n  const stack = new cdk.Stack();\n\n  // WHEN\n  const model = sagemaker.Model.fromModelArn(stack, 'Model', 'arn:aws:sagemaker:us-west-2:123456789012:model/MyModel');\n\n  // THEN\n  expect(model.modelName).toEqual('MyModel');\n});",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "When importing a model by name, the ARN is constructed correctly",
            "suites": [
                "When accessing Connections object"
            ],
            "updatePoint": {
                "line": 282,
                "column": 70
            },
            "line": 282,
            "code": "test('When importing a model by name, the ARN is constructed correctly', () => {\n  // GIVEN\n  const stack = new cdk.Stack(undefined, undefined, {\n    env:\n      {\n        region: 'us-west-2',\n        account: '123456789012',\n      },\n  });\n\n  // WHEN\n  const model = sagemaker.Model.fromModelName(stack, 'Model', 'my-name');\n\n  // THEN\n  expect(model.modelArn).toMatch(/arn:.+:sagemaker:us-west-2:123456789012:model\\/my-name/);\n});",
            "file": "model.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-sagemaker/test"
        },
        {
            "name": "ApplicationAssociator will associate allStacks created inside cdkApp",
            "suites": [
                "Scope based Associations with Application within Same Account"
            ],
            "updatePoint": {
                "line": 17,
                "column": 76
            },
            "line": 17,
            "code": "  test('ApplicationAssociator will associate allStacks created inside cdkApp', () => {\n    const appAssociator = new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n      })],\n    });\n\n    const anotherStack = new AppRegistrySampleStack(app, 'SampleStack');\n    Template.fromStack(appAssociator.appRegistryApplication.stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::Application', 1);\n    Template.fromStack(appAssociator.appRegistryApplication.stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Name: 'MyAssociatedApplication',\n      Tags: { managedBy: 'CDK_Application_Associator' },\n    });\n    Template.fromStack(appAssociator.appRegistryApplication.stack).hasOutput('DefaultCdkApplicationApplicationManagerUrl27C138EF', {});\n    Template.fromStack(anotherStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(anotherStack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: 'MyAssociatedApplication',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator with url disabled will not create cfn output",
            "suites": [
                "Scope based Associations with Application within Same Account"
            ],
            "updatePoint": {
                "line": 39,
                "column": 74
            },
            "line": 39,
            "code": "  test('ApplicationAssociator with url disabled will not create cfn output', () => {\n    const appAssociator = new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n        emitApplicationManagerUrlAsOutput: false,\n      })],\n    });\n\n    const anotherStack = new AppRegistrySampleStack(app, 'SampleStack');\n    Template.fromStack(appAssociator.appRegistryApplication.stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::Application', 1);\n    Template.fromStack(appAssociator.appRegistryApplication.stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Name: 'MyAssociatedApplication',\n      Tags: { managedBy: 'CDK_Application_Associator' },\n    });\n\n    expect(\n      Template.fromStack(appAssociator.appRegistryApplication.stack)\n        .findOutputs('*', {}),\n    ).toEqual({});\n    Template.fromStack(anotherStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(anotherStack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: 'MyAssociatedApplication',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate Attribute Group with application created by ApplicationAssociator",
            "suites": [
                "Associate attribute group with Application"
            ],
            "updatePoint": {
                "line": 77,
                "column": 83
            },
            "line": 77,
            "code": "  test('Associate Attribute Group with application created by ApplicationAssociator', () => {\n\n    const customAttributeGroup = new CustomAppRegistryAttributeGroup(app, 'AppRegistryAttributeGroup');\n\n    const appAssociator = new appreg.ApplicationAssociator(app, 'TestApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'TestAssociatedApplication',\n        stackName: 'TestAssociatedApplicationStack',\n      })],\n    });\n\n    customAttributeGroup.attributeGroup.associateWith(appAssociator.appRegistryApplication);\n    Template.fromStack(customAttributeGroup.attributeGroup.stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', 1);\n    Template.fromStack(customAttributeGroup.attributeGroup.stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', {\n      Application: 'TestAssociatedApplication',\n      AttributeGroup: { 'Fn::GetAtt': ['MyFirstAttributeGroupDBC21379', 'Id'] },\n    });\n\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator in cross-account associates all stacks created inside cdk app",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 107,
                "column": 91
            },
            "line": 107,
            "code": "  test('ApplicationAssociator in cross-account associates all stacks created inside cdk app', () => {\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n      })],\n    });\n    const firstStack = new cdk.Stack(app, 'testStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    const nestedStack = new cdk.Stack(firstStack, 'MyFirstStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    Template.fromStack(firstStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(nestedStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator disables cfn output",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 124,
                "column": 49
            },
            "line": 124,
            "code": "  test('ApplicationAssociator disables cfn output', () => {\n    const appAssociator = new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n        emitApplicationManagerUrlAsOutput: false,\n      })],\n    });\n    const firstStack = new cdk.Stack(app, 'testStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    const nestedStack = new cdk.Stack(firstStack, 'MyFirstStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n\n    expect(\n      Template.fromStack(appAssociator.appRegistryApplication.stack).findOutputs('*', {}),\n    ).toEqual({});\n    Template.fromStack(firstStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(nestedStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator creation failed when neither Application name nor ARN is provided",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 146,
                "column": 95
            },
            "line": 146,
            "code": "  test('ApplicationAssociator creation failed when neither Application name nor ARN is provided', () => {\n    expect(() => {\n      new appreg.ApplicationAssociator(app, 'MyApplication', {\n        applications: [],\n      });\n    }).toThrow('Please pass exactly 1 instance of TargetApplication.createApplicationStack() or TargetApplication.existingApplicationFromArn() into the \"applications\" property');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator creation failed when both Application name and ARN is provided",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 154,
                "column": 92
            },
            "line": 154,
            "code": "  test('ApplicationAssociator creation failed when both Application name and ARN is provided', () => {\n    expect(() => {\n      new appreg.ApplicationAssociator(app, 'MyApplication', {\n        applications: [appreg.TargetApplication.existingApplicationFromArn({\n          applicationArnValue: 'arn:aws:servicecatalog:us-east-1:482211128593:/applications/0a17wtxeg5vilok0sbxfozwpq9',\n        }),\n        appreg.TargetApplication.createApplicationStack({\n          applicationName: 'MyAssociatedApplication',\n        })],\n      });\n    }).toThrow('Please pass exactly 1 instance of TargetApplication.createApplicationStack() or TargetApplication.existingApplicationFromArn() into the \"applications\" property');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associate resource on imported application",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 167,
                "column": 50
            },
            "line": 167,
            "code": "  test('associate resource on imported application', () => {\n    const resource = new cdk.Stack(app, 'MyStack');\n\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.existingApplicationFromArn({\n        applicationArnValue: 'arn:aws:servicecatalog:us-east-1:482211128593:/applications/0a17wtxeg5vilok0sbxfozwpq9',\n      })],\n    });\n\n    Template.fromStack(resource).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: '0a17wtxeg5vilok0sbxfozwpq9',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  }),",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator with cross account stacks inside cdkApp gives warning if associateCrossAccountStacks is not provided",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 182,
                "column": 130
            },
            "line": 182,
            "code": "  test('ApplicationAssociator with cross account stacks inside cdkApp gives warning if associateCrossAccountStacks is not provided', () => {\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n        env: { account: 'account2', region: 'region' },\n      })],\n    });\n\n    const crossAccountStack = new cdk.Stack(app, 'crossRegionStack', {\n      env: { account: 'account', region: 'region' },\n    });\n    Annotations.fromStack(crossAccountStack).hasWarning('*', 'Cross-account stack detected but application sharing and association will be skipped because cross-account option is not enabled.');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator with cross account stacks inside cdkApp does not give warning if associateCrossAccountStacks is set to true",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 197,
                "column": 137
            },
            "line": 197,
            "code": "  test('ApplicationAssociator with cross account stacks inside cdkApp does not give warning if associateCrossAccountStacks is set to true', () => {\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n        associateCrossAccountStacks: true,\n        env: { account: 'account', region: 'region' },\n      })],\n    });\n\n    const crossAccountStack = new cdk.Stack(app, 'crossRegionStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    Annotations.fromStack(crossAccountStack).hasNoWarning('*', 'Cross-account stack detected but application sharing and association will be skipped because cross-account option is not enabled.');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "ApplicationAssociator with cross region stacks inside cdkApp gives warning",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 213,
                "column": 82
            },
            "line": 213,
            "code": "  test('ApplicationAssociator with cross region stacks inside cdkApp gives warning', () => {\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n        env: { account: 'account2', region: 'region2' },\n      })],\n    });\n\n    const crossRegionStack = new cdk.Stack(app, 'crossRegionStack', {\n      env: { account: 'account', region: 'region' },\n    });\n    Annotations.fromStack(crossRegionStack).hasWarning('*', 'AppRegistry does not support cross region associations, deployment might fail if there is cross region stacks in the app.'\n        + ' Application region region2, stack region region');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Environment Agnostic ApplicationAssociator with cross region stacks inside cdkApp gives warning",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 229,
                "column": 103
            },
            "line": 229,
            "code": "  test('Environment Agnostic ApplicationAssociator with cross region stacks inside cdkApp gives warning', () => {\n    new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n      })],\n    });\n\n    const crossRegionStack = new cdk.Stack(app, 'crossRegionStack', {\n      env: { account: 'account', region: 'region' },\n    });\n    Annotations.fromStack(crossRegionStack).hasWarning('*', 'Environment agnostic stack determined, AppRegistry association might not work as expected in case you deploy cross-region or cross-account stack.');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Cdk App Containing Pipeline with stage but stage not associated throws error",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 243,
                "column": 84
            },
            "line": 243,
            "code": "  test('Cdk App Containing Pipeline with stage but stage not associated throws error', () => {\n    const application = new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n      })],\n    });\n    const pipelineStack = new AppRegistrySampleCodePipelineStack(app, 'PipelineStackA', {\n      application: application,\n      associateStage: false,\n    });\n    app.synth();\n    Annotations.fromStack(pipelineStack).hasWarning('*',\n      'Associate Stage: SampleStage to ensure all stacks in your cdk app are associated with AppRegistry. You can use ApplicationAssociator.associateStage to associate any stage.');\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Cdk App Containing Pipeline with stage and stage associated successfully gets synthesized",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 259,
                "column": 97
            },
            "line": 259,
            "code": "  test('Cdk App Containing Pipeline with stage and stage associated successfully gets synthesized', () => {\n    const application = new appreg.ApplicationAssociator(app, 'MyApplication', {\n      applications: [appreg.TargetApplication.createApplicationStack({\n        applicationName: 'MyAssociatedApplication',\n        stackName: 'MyAssociatedApplicationStack',\n      })],\n    });\n    const pipelineStack = new AppRegistrySampleCodePipelineStack(app, 'PipelineStackA', {\n      application: application,\n      associateStage: true,\n    });\n    app.synth();\n    Template.fromStack(application.appRegistryApplication.stack).hasOutput('DefaultCdkApplicationApplicationManagerUrl27C138EF', {});\n    Template.fromStack(pipelineStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n  });",
            "file": "application-associator.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "default application creation",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 18,
                "column": 36
            },
            "line": 18,
            "code": "  test('default application creation', () => {\n    new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'testApplication',\n    });\n\n    Template.fromStack(stack).templateMatches({\n      Resources: {\n        MyApplication5C63EC1D: {\n          Type: 'AWS::ServiceCatalogAppRegistry::Application',\n          Properties: {\n            Name: 'testApplication',\n          },\n        },\n      },\n    });\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "application with explicit description",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 35,
                "column": 45
            },
            "line": 35,
            "code": "  test('application with explicit description', () => {\n    const description = 'my test application description';\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'testApplication',\n      description: description,\n    });\n\n    expect(application.applicationManagerUrl).toContain('AWS_AppRegistry_Application-testApplication');\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Description: description,\n    });\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "application with application tags",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 48,
                "column": 41
            },
            "line": 48,
            "code": "  test('application with application tags', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'testApplication',\n    });\n\n    cdk.Tags.of(application).add('key1', 'value1');\n    cdk.Tags.of(application).add('key2', 'value2');\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Tags: {\n        key1: 'value1',\n        key2: 'value2',\n      },\n    });\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "for an application imported by ARN",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 64,
                "column": 42
            },
            "line": 64,
            "code": "  test('for an application imported by ARN', () => {\n    const application = appreg.Application.fromApplicationArn(stack, 'MyApplication',\n      'arn:aws:servicecatalog:us-east-1:123456789012:/applications/0aqmvxvgmry0ecc4mjhwypun6i');\n\n    expect(application.applicationId).toEqual('0aqmvxvgmry0ecc4mjhwypun6i');\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for application imported by ARN missing applicationId",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 71,
                "column": 67
            },
            "line": 71,
            "code": "  test('fails for application imported by ARN missing applicationId', () => {\n    expect(() => {\n      appreg.Application.fromApplicationArn(stack, 'MyApplication',\n        'arn:aws:servicecatalog:us-east-1:123456789012:/applications/');\n    }).toThrow(/Missing required Application ID from Application ARN:/);\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "application created with a token description does not throw validation error and creates",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 78,
                "column": 96
            },
            "line": 78,
            "code": "  test('application created with a token description does not throw validation error and creates', () => {\n    const tokenDescription = new cdk.CfnParameter(stack, 'Description');\n\n    new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'myApplication',\n      description: tokenDescription.valueAsString,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Description: {\n        Ref: 'Description',\n      },\n    });\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "application created with a token application name does not throw validation error",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 93,
                "column": 89
            },
            "line": 93,
            "code": "  test('application created with a token application name does not throw validation error', () => {\n    const tokenApplicationName= new cdk.CfnParameter(stack, 'ApplicationName');\n\n    new appreg.Application(stack, 'MyApplication', {\n      applicationName: tokenApplicationName.valueAsString,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::Application', {\n      Name: {\n        Ref: 'ApplicationName',\n      },\n    });\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for application with description length longer than allowed",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 107,
                "column": 73
            },
            "line": 107,
            "code": "  test('fails for application with description length longer than allowed', () => {\n    expect(() => {\n      new appreg.Application(stack, 'MyApplication', {\n        applicationName: 'testApplication',\n        description: 'too long description'.repeat(1000),\n      });\n    }).toThrow(/Invalid application description for resource/);\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for application creation with name too short",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 116,
                "column": 58
            },
            "line": 116,
            "code": "  test('fails for application creation with name too short', () => {\n    expect(() => {\n      new appreg.Application(stack, 'MyApplication', {\n        applicationName: '',\n      });\n    }).toThrow(/Invalid application name for resource/);\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for application with name too long",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 124,
                "column": 48
            },
            "line": 124,
            "code": "  test('fails for application with name too long', () => {\n    expect(() => {\n      new appreg.Application(stack, 'MyApplication', {\n        applicationName: 'testApplication'.repeat(50),\n      });\n    }).toThrow(/Invalid application name for resource/);\n  }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for application with name of invalid characters",
            "suites": [
                "Application"
            ],
            "updatePoint": {
                "line": 132,
                "column": 61
            },
            "line": 132,
            "code": "  test('fails for application with name of invalid characters', () => {\n    expect(() => {\n      new appreg.Application(stack, 'MyApplication', {\n        applicationName: 'My@ppl!iC@ #',\n      });\n    }).toThrow(/Invalid application name for resource/);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associate attribute group",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 149,
                "column": 35
            },
            "line": 149,
            "code": "    test('associate attribute group', () => {\n      const attributeGroup = new appreg.AttributeGroup(stack, 'AttributeGroup', {\n        attributeGroupName: 'AttributeGroupName',\n        attributes: {},\n      });\n\n      application.associateAttributeGroup(attributeGroup);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', {\n        Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n        AttributeGroup: { 'Fn::GetAtt': ['AttributeGroup409C6335', 'Id'] },\n      });\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associate new attribute group",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 163,
                "column": 39
            },
            "line": 163,
            "code": "    test('associate new attribute group', () => {\n      application.addAttributeGroup('AttributeGroup', {\n        attributeGroupName: 'AttributeGroupName',\n        attributes: {},\n        description: 'Description for Attribute Group',\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', {\n        Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n        AttributeGroup: { 'Fn::GetAtt': ['MyApplicationAttributeGroup0BD166B6', 'Id'] },\n      });\n\n      Template.fromStack(stack).templateMatches({\n        Resources: {\n          MyApplicationAttributeGroup0BD166B6: {\n            Type: 'AWS::ServiceCatalogAppRegistry::AttributeGroup',\n            Properties: {\n              Name: 'AttributeGroupName',\n              Attributes: {},\n            },\n          },\n        },\n      });\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "duplicate attribute group association are idempotent",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 188,
                "column": 62
            },
            "line": 188,
            "code": "    test('duplicate attribute group association are idempotent', () => {\n      const attributeGroup = new appreg.AttributeGroup(stack, 'AttributeGroup', {\n        attributeGroupName: 'attributeGroupName',\n        attributes: { key: 'value' },\n      });\n\n      // If these were not idempotent, the second call would produce an error for duplicate construct ID.\n      application.associateAttributeGroup(attributeGroup);\n      application.associateAttributeGroup(attributeGroup);\n\n      Template.fromStack(stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', 1);\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "multiple applications and attribute groups can associate",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 201,
                "column": 66
            },
            "line": 201,
            "code": "    test('multiple applications and attribute groups can associate', () => {\n      const application2 = new appreg.Application(stack, 'MyApplication2', {\n        applicationName: 'MyApplication2',\n      });\n\n      const attributeGroup1 = new appreg.AttributeGroup(stack, 'AttributeGroup', {\n        attributeGroupName: 'attributeGroupName',\n        attributes: { key: 'value' },\n      });\n\n      const attributeGroup2 = new appreg.AttributeGroup(stack, 'AttributeGroup2', {\n        attributeGroupName: 'attributeGroupName2',\n        attributes: { key: 'value' },\n      });\n\n      application.associateAttributeGroup(attributeGroup1);\n      application.associateAttributeGroup(attributeGroup2);\n\n      application2.associateAttributeGroup(attributeGroup1);\n      application2.associateAttributeGroup(attributeGroup2);\n\n      Template.fromStack(stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', 4);\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associate resource",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 225,
                "column": 28
            },
            "line": 225,
            "code": "    test('associate resource', () => {\n      const resource = new cdk.Stack(stack, 'MyStack');\n\n      application.associateStack(resource);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n        Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n        Resource: { 'Fn::ImportValue': 'MyStack:ExportsOutputRefAWSStackIdB2DD5BAA' },\n      });\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associate resource on imported application",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 236,
                "column": 52
            },
            "line": 236,
            "code": "    test('associate resource on imported application', () => {\n      const resource = new cdk.Stack(stack, 'MyStack');\n\n      const importedApplication = appreg.Application.fromApplicationArn(stack, 'ImportedApplication',\n        'arn:aws:servicecatalog:us-east-1:123456789012:/applications/0bqmvxvgmry0ecc4mjhwypun6i');\n\n      importedApplication.associateStack(resource);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n        Application: '0bqmvxvgmry0ecc4mjhwypun6i',\n        Resource: { 'Fn::ImportValue': 'MyStack:ExportsOutputRefAWSStackIdB2DD5BAA' },\n      });\n    }),",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "duplicate resource assocations are idempotent",
            "suites": [
                "Application",
                "Assocations on applications"
            ],
            "updatePoint": {
                "line": 250,
                "column": 55
            },
            "line": 250,
            "code": "    test('duplicate resource assocations are idempotent', () => {\n      const resource = new cdk.Stack(stack, 'MyStack');\n\n      // If these were not idempotent, the second call would produce an error for duplicate construct ID.\n      application.associateStack(resource);\n      application.associateStack(resource);\n\n      Template.fromStack(stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for sharing application without principals",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 270,
                "column": 58
            },
            "line": 270,
            "code": "    test('fails for sharing application without principals', () => {\n      expect(() => {\n        application.shareApplication('MyShareId', {\n          name: 'MyShare',\n        });\n      }).toThrow(/An entity must be provided for the share/);\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with an organization",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 278,
                "column": 48
            },
            "line": 278,
            "code": "    test('share application with an organization', () => {\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationReadOnly'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with an account",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 293,
                "column": 43
            },
            "line": 293,
            "code": "    test('share application with an account', () => {\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        accounts: ['123456789012'],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['123456789012'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationReadOnly'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with an IAM role",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 308,
                "column": 44
            },
            "line": 308,
            "code": "    test('share application with an IAM role', () => {\n      const myRole = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/myRole');\n\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        roles: [myRole],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:iam::123456789012:role/myRole'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationReadOnly'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with an IAM user",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 325,
                "column": 44
            },
            "line": 325,
            "code": "    test('share application with an IAM user', () => {\n      const myUser = iam.User.fromUserArn(stack, 'MyUser', 'arn:aws:iam::123456789012:user/myUser');\n\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        users: [myUser],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:iam::123456789012:user/myUser'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationReadOnly'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with organization, give explicit read only access to an application",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 342,
                "column": 95
            },
            "line": 342,
            "code": "    test('share application with organization, give explicit read only access to an application', () => {\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        sharePermission: appreg.SharePermission.READ_ONLY,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationReadOnly'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share application with organization, allow access to associate resources and attribute group with an application",
            "suites": [
                "Application",
                "Resource sharing of an application"
            ],
            "updatePoint": {
                "line": 358,
                "column": 122
            },
            "line": 358,
            "code": "    test('share application with organization, allow access to associate resources and attribute group with an application', () => {\n      application.shareApplication('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        sharePermission: appreg.SharePermission.ALLOW_ACCESS,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryApplicationAllowAssociation'],\n      });\n    });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate Stage in same account will associate allStacks Inside it",
            "suites": [
                "Scope based Associations with Application within Same Account"
            ],
            "updatePoint": {
                "line": 388,
                "column": 74
            },
            "line": 388,
            "code": "  test('Associate Stage in same account will associate allStacks Inside it', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n    const stage = new cdk.Stage(stack, 'MyStage');\n    const stageStack = new cdk.Stack(stage, 'MyStack');\n    application.associateAllStacksInScope(stage);\n    expect(stageStack.stackName).toEqual('MyStage-MyStack');\n    Template.fromStack(stageStack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: 'MyApplication',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate Stack in same account will associate allStacks Inside it",
            "suites": [
                "Scope based Associations with Application within Same Account"
            ],
            "updatePoint": {
                "line": 403,
                "column": 74
            },
            "line": 403,
            "code": "  test('Associate Stack in same account will associate allStacks Inside it', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n\n    const anotherStack = new AppRegistrySampleStack(app, 'SampleStack');\n    application.associateAllStacksInScope(app);\n    Template.fromStack(stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(anotherStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n      Resource: { Ref: 'AWS::StackId' },\n    });\n    Template.fromStack(anotherStack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: 'MyApplication',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "associateAllStacksInScope in cross-account associates all stacks from the context passed",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 437,
                "column": 96
            },
            "line": 437,
            "code": "  test('associateAllStacksInScope in cross-account associates all stacks from the context passed', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n    const firstStack = new cdk.Stack(app, 'testStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    const nestedStack = new cdk.Stack(firstStack, 'MyFirstStack', {\n      env: { account: 'account2', region: 'region' },\n    });\n    application.associateAllStacksInScope(app);\n    Template.fromStack(stack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(firstStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(nestedStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate Stage in cross account association will associate allStacks Inside it",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 453,
                "column": 87
            },
            "line": 453,
            "code": "  test('Associate Stage in cross account association will associate allStacks Inside it', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n    const stage = new cdk.Stage(app, 'MyStage', {\n      env: { account: 'account2', region: 'region' },\n    });\n    const stageStack = new cdk.Stack(stage, 'MyStack');\n    application.associateAllStacksInScope(stage);\n    Template.fromStack(stageStack).resourceCountIs('AWS::ServiceCatalogAppRegistry::ResourceAssociation', 1);\n    Template.fromStack(stageStack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Application: 'MyApplication',\n      Resource: { Ref: 'AWS::StackId' },\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate Stage in cross region throw error",
            "suites": [
                "Scope based Associations with Application with Cross Region/Account"
            ],
            "updatePoint": {
                "line": 469,
                "column": 51
            },
            "line": 469,
            "code": "  test('Associate Stage in cross region throw error', () => {\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n    const stage = new cdk.Stage(stack, 'MyStage', {\n      env: { account: 'account1', region: 'region1' },\n    });\n    const stageStack = new cdk.Stack(stage, 'MyStack');\n    application.associateAllStacksInScope(stage);\n    Annotations.fromStack(stageStack).hasWarning('*',\n      'AppRegistry does not support cross region associations, deployment might fail if there is cross region stacks in the app.'\n          + ' Application region region, stack region region1');\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate conditional nested stack with application",
            "suites": [
                "Conditional nested stack Associations with Application within Same Account"
            ],
            "updatePoint": {
                "line": 494,
                "column": 59
            },
            "line": 494,
            "code": "  test('Associate conditional nested stack with application', () => {\n    const stack = new MainStack(app, 'cdkApplication');\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyApplication',\n    });\n    application.associateApplicationWithStack(stack);\n    application.associateApplicationWithStack(stack.nestedStack);\n    Template.fromStack(stack.nestedStack).hasResource('AWS::ServiceCatalogAppRegistry::ResourceAssociation', {\n      Properties: {\n        Application: 'MyApplication',\n        Resource: { Ref: 'AWS::StackId' },\n        ResourceType: 'CFN_STACK',\n      },\n    });\n    Template.fromStack(stack.nestedStack).hasCondition('ShouldCreateStackCondition', {\n      'Fn::Equals': ['us-east-1'],\n    });\n  });",
            "file": "application.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "default attribute group creation",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 18,
                "column": 40
            },
            "line": 18,
            "code": "  test('default attribute group creation', () => {\n    new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: 'testAttributeGroup',\n      attributes: {\n        key: 'value',\n      },\n    });\n\n    Template.fromStack(stack).templateMatches({\n      Resources: {\n        MyAttributeGroup99099500: {\n          Type: 'AWS::ServiceCatalogAppRegistry::AttributeGroup',\n          Properties: {\n            Name: 'testAttributeGroup',\n            Attributes: {\n              key: 'value',\n            },\n          },\n        },\n      },\n    });\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "attribute group with explicit description",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 41,
                "column": 49
            },
            "line": 41,
            "code": "  test('attribute group with explicit description', () => {\n    const description = 'my test attribute group description';\n    new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: 'testAttributeGroup',\n      attributes: {\n        key: 'value',\n      },\n      description: description,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroup', {\n      Description: description,\n    });\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Attribute group with tags",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 56,
                "column": 33
            },
            "line": 56,
            "code": "  test('Attribute group with tags', () => {\n    const attributeGroup = new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: 'testAttributeGroup',\n      attributes: {\n        key: 'value',\n      },\n    });\n\n    cdk.Tags.of(attributeGroup).add('key1', 'value1');\n    cdk.Tags.of(attributeGroup).add('key2', 'value2');\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroup', {\n      Tags: {\n        key1: 'value1',\n        key2: 'value2',\n      },\n    });\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "for an attribute group imported by ARN",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 75,
                "column": 46
            },
            "line": 75,
            "code": "  test('for an attribute group imported by ARN', () => {\n    const attributeGroup = appreg.AttributeGroup.fromAttributeGroupArn(stack, 'MyAttributeGroup',\n      'arn:aws:servicecatalog:us-east-1:123456789012:/attribute-groups/0aqmvxvgmry0ecc4mjhwypun6i');\n    expect(attributeGroup.attributeGroupId).toEqual('0aqmvxvgmry0ecc4mjhwypun6i');\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate an application to an imported attribute group",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 81,
                "column": 63
            },
            "line": 81,
            "code": "  test('Associate an application to an imported attribute group', () => {\n    const attributeGroup = appreg.AttributeGroup.fromAttributeGroupArn(stack, 'MyAttributeGroup',\n      'arn:aws:servicecatalog:us-east-1:123456789012:/attribute-groups/0aqmvxvgmry0ecc4mjhwypun6i');\n    const application = new appreg.Application(stack, 'MyApplication', {\n      applicationName: 'MyTestApplication',\n    });\n    attributeGroup.associateWith(application);\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', {\n      Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n      AttributeGroup: '0aqmvxvgmry0ecc4mjhwypun6i',\n    });\n\n  });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for attribute group imported by ARN missing attributeGroupId",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 95,
                "column": 74
            },
            "line": 95,
            "code": "  test('fails for attribute group imported by ARN missing attributeGroupId', () => {\n    expect(() => {\n      appreg.AttributeGroup.fromAttributeGroupArn(stack, 'MyAttributeGroup',\n        'arn:aws:servicecatalog:us-east-1:123456789012:/attribute-groups/');\n    }).toThrow(/Missing required Attribute Group ID from Attribute Group ARN:/);\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "attribute group created with a token description does not throw validation error and creates",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 102,
                "column": 100
            },
            "line": 102,
            "code": "  test('attribute group created with a token description does not throw validation error and creates', () => {\n    const tokenDescription = new cdk.CfnParameter(stack, 'Description');\n\n    new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: 'testAttributeGroup',\n      attributes: {\n        key: 'value',\n      },\n      description: tokenDescription.valueAsString,\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroup', {\n      Description: {\n        Ref: 'Description',\n      },\n    });\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "attribute group created with a token attribute group name does not throw validation error",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 120,
                "column": 97
            },
            "line": 120,
            "code": "  test('attribute group created with a token attribute group name does not throw validation error', () => {\n    const tokenAttributeGroupName = new cdk.CfnParameter(stack, 'AttributeGroupName');\n\n    new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: tokenAttributeGroupName.valueAsString,\n      attributes: {\n        key: 'value',\n      },\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroup', {\n      Name: {\n        Ref: 'AttributeGroupName',\n      },\n    });\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for attribute group with description length longer than allowed",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 137,
                "column": 77
            },
            "line": 137,
            "code": "  test('fails for attribute group with description length longer than allowed', () => {\n    expect(() => {\n      new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n        attributeGroupName: 'testAttributeGroup',\n        attributes: {\n          key: 'value',\n        },\n        description: 'too long attribute description'.repeat(1000),\n      });\n    }).toThrow(/Invalid attribute group description for resource/);\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for attribute group creation with name too short",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 149,
                "column": 62
            },
            "line": 149,
            "code": "  test('fails for attribute group creation with name too short', () => {\n    expect(() => {\n      new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n        attributeGroupName: '',\n        attributes: {\n          key: 'value',\n        },\n      });\n    }).toThrow(/Invalid attribute group name for resource/);\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for attribute group with name too long",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 160,
                "column": 52
            },
            "line": 160,
            "code": "  test('fails for attribute group with name too long', () => {\n    expect(() => {\n      new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n        attributeGroupName: 'testAttributeNameTooLong'.repeat(50),\n        attributes: {\n          key: 'value',\n        },\n      });\n    }).toThrow(/Invalid attribute group name for resource/);\n  }),",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for attribute group name with name of invalid characters",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 171,
                "column": 70
            },
            "line": 171,
            "code": "  test('fails for attribute group name with name of invalid characters', () => {\n    expect(() => {\n      new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n        attributeGroupName: '@ttR!8Ut3 Gr0uP',\n        attributes: {\n          key: 'value',\n        },\n      });\n    }).toThrow(/Invalid attribute group name for resource/);\n  });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "attribute group created with empty attributes",
            "suites": [
                "Attribute Group"
            ],
            "updatePoint": {
                "line": 182,
                "column": 53
            },
            "line": 182,
            "code": "  test('attribute group created with empty attributes', () => {\n    new appreg.AttributeGroup(stack, 'MyAttributeGroup', {\n      attributeGroupName: 'testAttributeGroup',\n      attributes: {},\n    });\n\n    Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroup', {\n      Attributes: {},\n    });\n  });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Associate an application to an attribute group",
            "suites": [
                "Attribute Group",
                "Associate application to an attribute group"
            ],
            "updatePoint": {
                "line": 203,
                "column": 56
            },
            "line": 203,
            "code": "    test('Associate an application to an attribute group', () => {\n      const application = new appreg.Application(stack, 'MyApplication', {\n        applicationName: 'MyTestApplication',\n      });\n      attributeGroup.associateWith(application);\n      Template.fromStack(stack).hasResourceProperties('AWS::ServiceCatalogAppRegistry::AttributeGroupAssociation', {\n        Application: { 'Fn::GetAtt': ['MyApplication5C63EC1D', 'Id'] },\n        AttributeGroup: { 'Fn::GetAtt': ['MyAttributeGroupForAssociation6B3E1329', 'Id'] },\n      });\n\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "fails for sharing attribute group without principals",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 227,
                "column": 62
            },
            "line": 227,
            "code": "    test('fails for sharing attribute group without principals', () => {\n      expect(() => {\n        attributeGroup.shareAttributeGroup('MyShareId', {\n          name: 'MyShare',\n        });\n      }).toThrow(/An entity must be provided for the share/);\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with an organization",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 235,
                "column": 52
            },
            "line": 235,
            "code": "    test('share attribute group with an organization', () => {\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupReadOnly'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with an account",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 250,
                "column": 47
            },
            "line": 250,
            "code": "    test('share attribute group with an account', () => {\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        accounts: ['123456789012'],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['123456789012'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupReadOnly'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with an IAM role",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 265,
                "column": 48
            },
            "line": 265,
            "code": "    test('share attribute group with an IAM role', () => {\n      const myRole = iam.Role.fromRoleArn(stack, 'MyRole', 'arn:aws:iam::123456789012:role/myRole');\n\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        roles: [myRole],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:iam::123456789012:role/myRole'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupReadOnly'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with an IAM user",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 282,
                "column": 48
            },
            "line": 282,
            "code": "    test('share attribute group with an IAM user', () => {\n      const myUser = iam.User.fromUserArn(stack, 'MyUser', 'arn:aws:iam::123456789012:user/myUser');\n\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        users: [myUser],\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:iam::123456789012:user/myUser'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupReadOnly'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with organization, give explicit read only access to the attribute group",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 299,
                "column": 104
            },
            "line": 299,
            "code": "    test('share attribute group with organization, give explicit read only access to the attribute group', () => {\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        sharePermission: appreg.SharePermission.READ_ONLY,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupReadOnly'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "share attribute group with organization, give access to mutate attribute groups",
            "suites": [
                "Attribute Group",
                "Resource sharing of an attribute group"
            ],
            "updatePoint": {
                "line": 315,
                "column": 89
            },
            "line": 315,
            "code": "    test('share attribute group with organization, give access to mutate attribute groups', () => {\n      attributeGroup.shareAttributeGroup('MyShareId', {\n        name: 'MyShare',\n        organizationArns: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        sharePermission: appreg.SharePermission.ALLOW_ACCESS,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::RAM::ResourceShare', {\n        AllowExternalPrincipals: false,\n        Name: 'MyShare',\n        Principals: ['arn:aws:organizations::123456789012:organization/o-70oi5564q1'],\n        ResourceArns: [{ 'Fn::GetAtt': ['MyAttributeGroup99099500', 'Arn'] }],\n        PermissionArns: ['arn:aws:ram::aws:permission/AWSRAMPermissionServiceCatalogAppRegistryAttributeGroupAllowAssociation'],\n      });\n    });",
            "file": "attribute-group.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-servicecatalogappregistry/test"
        },
        {
            "name": "Basic canary properties work",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 34
            },
            "line": 8,
            "code": "test('Basic canary properties work', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    canaryName: 'mycanary',\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    successRetentionPeriod: Duration.days(10),\n    failureRetentionPeriod: Duration.days(10),\n    startAfterCreation: false,\n    timeToLive: Duration.minutes(30),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Name: 'mycanary',\n    SuccessRetentionPeriod: 10,\n    FailureRetentionPeriod: 10,\n    StartCanaryAfterCreation: false,\n    Schedule: Match.objectLike({ DurationInSeconds: '1800' }),\n    RuntimeVersion: 'syn-nodejs-puppeteer-3.8',\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Can set `DeleteLambdaResourceOnCanaryDeletion`",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 52
            },
            "line": 37,
            "code": "test('Can set `DeleteLambdaResourceOnCanaryDeletion`', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code'),\n    }),\n    enableAutoDeleteLambdas: true,\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    DeleteLambdaResourcesOnCanaryDeletion: true,\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Canary can have generated name",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 36
            },
            "line": 57,
            "code": "test('Canary can have generated name', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Name: 'canary',\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Name validation does not fail when using Tokens",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 53
            },
            "line": 76,
            "code": "test('Name validation does not fail when using Tokens', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    canaryName: Lazy.string({ produce: () => 'My Canary' }),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN: no exception\n  Template.fromStack(stack).resourceCountIs('AWS::Synthetics::Canary', 1);\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Throws when name is specified incorrectly",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 47
            },
            "line": 94,
            "code": "test('Throws when name is specified incorrectly', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // THEN\n  expect(() => new synthetics.Canary(stack, 'Canary', {\n    canaryName: 'My Canary',\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  }))\n    .toThrowError('Canary name must be lowercase, numbers, hyphens, or underscores (got \"My Canary\")');\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Throws when name has more than 21 characters",
            "suites": [],
            "updatePoint": {
                "line": 110,
                "column": 50
            },
            "line": 110,
            "code": "test('Throws when name has more than 21 characters', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // THEN\n  expect(() => new synthetics.Canary(stack, 'Canary', {\n    canaryName: 'a'.repeat(22),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  }))\n    .toThrowError(`Canary name is too large, must be between 1 and 21 characters, but is 22 (got \"${'a'.repeat(22)}\")`);\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "An existing role can be specified instead of auto-created",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 63
            },
            "line": 126,
            "code": "test('An existing role can be specified instead of auto-created', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  const role = new iam.Role(stack, 'role', {\n    assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),\n  });\n\n  // role.addToPolicy(/* required permissions per the documentation */);\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    role,\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    ExecutionRoleArn: stack.resolve(role.roleArn),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "An existing bucket and prefix can be specified instead of auto-created",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 76
            },
            "line": 152,
            "code": "test('An existing bucket and prefix can be specified instead of auto-created', () => {\n  // GIVEN\n  const stack = new Stack();\n  const bucket = new s3.Bucket(stack, 'mytestbucket');\n  const prefix = 'canary';\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    artifactsBucketLocation: { bucket, prefix },\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    ArtifactS3Location: stack.resolve(bucket.s3UrlForObject(prefix)),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Runtime can be specified",
            "suites": [],
            "updatePoint": {
                "line": 174,
                "column": 30
            },
            "line": 174,
            "code": "test('Runtime can be specified', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    RuntimeVersion: 'syn-nodejs-puppeteer-3.8',\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Python runtime can be specified",
            "suites": [],
            "updatePoint": {
                "line": 193,
                "column": 37
            },
            "line": 193,
            "code": "test('Python runtime can be specified', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    runtime: synthetics.Runtime.SYNTHETICS_PYTHON_SELENIUM_1_3,\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('# Synthetics handler code'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    RuntimeVersion: 'syn-python-selenium-1.3',\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "environment variables can be specified",
            "suites": [],
            "updatePoint": {
                "line": 212,
                "column": 44
            },
            "line": 212,
            "code": "test('environment variables can be specified', () => {\n  // GIVEN\n  const stack = new Stack();\n  const environmentVariables = {\n    TEST_KEY_1: 'TEST_VALUE_1',\n    TEST_KEY_2: 'TEST_VALUE_2',\n  };\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    environmentVariables: environmentVariables,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    RunConfig: {\n      EnvironmentVariables: environmentVariables,\n    },\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "environment variables are skipped if not provided",
            "suites": [],
            "updatePoint": {
                "line": 238,
                "column": 55
            },
            "line": 238,
            "code": "test('environment variables are skipped if not provided', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    RunConfig: Match.absent(),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Runtime can be customized",
            "suites": [],
            "updatePoint": {
                "line": 257,
                "column": 31
            },
            "line": 257,
            "code": "test('Runtime can be customized', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    runtime: new synthetics.Runtime('fancy-future-runtime-1337.42', synthetics.RuntimeFamily.OTHER),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    RuntimeVersion: 'fancy-future-runtime-1337.42',\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Schedule can be set with Rate",
            "suites": [],
            "updatePoint": {
                "line": 276,
                "column": 35
            },
            "line": 276,
            "code": "test('Schedule can be set with Rate', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.rate(Duration.minutes(3)),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Schedule: Match.objectLike({ Expression: 'rate(3 minutes)' }),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Schedule can be set to 1 minute",
            "suites": [],
            "updatePoint": {
                "line": 296,
                "column": 37
            },
            "line": 296,
            "code": "test('Schedule can be set to 1 minute', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.rate(Duration.minutes(1)),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Schedule: Match.objectLike({ Expression: 'rate(1 minute)' }),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Schedule can be set with Cron",
            "suites": [],
            "updatePoint": {
                "line": 316,
                "column": 35
            },
            "line": 316,
            "code": "test('Schedule can be set with Cron', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.cron({ minute: '30' }),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Schedule: Match.objectLike({ Expression: 'cron(30 * * * ? *)' }),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Schedule can be set with Expression",
            "suites": [],
            "updatePoint": {
                "line": 337,
                "column": 41
            },
            "line": 337,
            "code": "test('Schedule can be set with Expression', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.expression('rate(1 hour)'),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Schedule: Match.objectLike({ Expression: 'rate(1 hour)' }),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Schedule can be set to run once",
            "suites": [],
            "updatePoint": {
                "line": 357,
                "column": 37
            },
            "line": 357,
            "code": "test('Schedule can be set to run once', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.once(),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Schedule: Match.objectLike({ Expression: 'rate(0 minutes)' }),\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Throws when rate above 60 minutes",
            "suites": [],
            "updatePoint": {
                "line": 377,
                "column": 39
            },
            "line": 377,
            "code": "test('Throws when rate above 60 minutes', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // THEN\n  expect(() => new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.rate(Duration.minutes(61)),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  }))\n    .toThrowError('Schedule duration must be between 1 and 60 minutes');\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Throws when rate above is not a whole number of minutes",
            "suites": [],
            "updatePoint": {
                "line": 393,
                "column": 61
            },
            "line": 393,
            "code": "test('Throws when rate above is not a whole number of minutes', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // THEN\n  expect(() => new synthetics.Canary(stack, 'Canary', {\n    schedule: synthetics.Schedule.rate(Duration.seconds(59)),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  }))\n    .toThrowError('\\'59 seconds\\' cannot be converted into a whole number of minutes.');\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Can share artifacts bucket between canaries",
            "suites": [],
            "updatePoint": {
                "line": 409,
                "column": 49
            },
            "line": 409,
            "code": "test('Can share artifacts bucket between canaries', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  const canary1 = new synthetics.Canary(stack, 'Canary1', {\n    schedule: synthetics.Schedule.once(),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  const canary2 = new synthetics.Canary(stack, 'Canary2', {\n    schedule: synthetics.Schedule.once(),\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    artifactsBucketLocation: { bucket: canary1.artifactsBucket },\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  expect(canary1.artifactsBucket).toEqual(canary2.artifactsBucket);\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "can specify custom test",
            "suites": [],
            "updatePoint": {
                "line": 437,
                "column": 29
            },
            "line": 437,
            "code": "test('can specify custom test', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline(`\n        exports.handler = async () => {\n          console.log(\\'hello world\\');\n        };`),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n    Code: {\n      Handler: 'index.handler',\n      Script: `\n        exports.handler = async () => {\n          console.log(\\'hello world\\');\n        };`,\n    },\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "can specify vpc",
            "suites": [
                "canary in a vpc"
            ],
            "updatePoint": {
                "line": 466,
                "column": 23
            },
            "line": 466,
            "code": "  test('can specify vpc', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC', { maxAzs: 2 });\n\n    // WHEN\n    new synthetics.Canary(stack, 'Canary', {\n      test: synthetics.Test.custom({\n        handler: 'index.handler',\n        code: synthetics.Code.fromInline(`\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`),\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n      vpc,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n      Code: {\n        Handler: 'index.handler',\n        Script: `\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`,\n      },\n      VPCConfig: {\n        VpcId: {\n          Ref: Match.anyValue(),\n        },\n      },\n    });\n  });",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "default security group and subnets",
            "suites": [
                "canary in a vpc"
            ],
            "updatePoint": {
                "line": 501,
                "column": 42
            },
            "line": 501,
            "code": "  test('default security group and subnets', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC', { maxAzs: 2 });\n\n    // WHEN\n    new synthetics.Canary(stack, 'Canary', {\n      test: synthetics.Test.custom({\n        handler: 'index.handler',\n        code: synthetics.Code.fromInline(`\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`),\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n      vpc,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n      Code: {\n        Handler: 'index.handler',\n        Script: `\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`,\n      },\n      VPCConfig: {\n        VpcId: {\n          Ref: Match.anyValue(),\n        },\n        SecurityGroupIds: Match.anyValue(),\n        SubnetIds: [...vpc.privateSubnets.map(subnet => ({ Ref: Match.stringLikeRegexp(subnet.node.id) }))],\n      },\n    });\n  });",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "provided security group",
            "suites": [
                "canary in a vpc"
            ],
            "updatePoint": {
                "line": 538,
                "column": 31
            },
            "line": 538,
            "code": "  test('provided security group', () => {\n    // GIVEN\n    const stack = new Stack();\n    const vpc = new ec2.Vpc(stack, 'VPC', { maxAzs: 2 });\n    const sg = new ec2.SecurityGroup(stack, 'Sg', { vpc });\n\n    // WHEN\n    new synthetics.Canary(stack, 'Canary', {\n      test: synthetics.Test.custom({\n        handler: 'index.handler',\n        code: synthetics.Code.fromInline(`\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`),\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n      vpc,\n      securityGroups: [sg],\n    });\n\n    // THEN\n    const template = Template.fromStack(stack);\n    const sgTemplate = template.findResources('AWS::EC2::SecurityGroup');\n    const sgIds = Object.keys(sgTemplate);\n\n    expect(sgIds).toHaveLength(1);\n\n    template.hasResourceProperties('AWS::Synthetics::Canary', {\n      Code: {\n        Handler: 'index.handler',\n        Script: `\n          exports.handler = async () => {\n            console.log(\\'hello world\\');\n          };`,\n      },\n      VPCConfig: {\n        VpcId: {\n          Ref: Match.anyValue(),\n        },\n        SecurityGroupIds: [{ 'Fn::GetAtt': [sgIds[0], 'GroupId'] }],\n      },\n    });\n  });",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Role policy generated as expected",
            "suites": [
                "canary in a vpc"
            ],
            "updatePoint": {
                "line": 583,
                "column": 39
            },
            "line": 583,
            "code": "test('Role policy generated as expected', () => {\n  // GIVEN\n  const stack = new Stack();\n\n  // WHEN\n  new synthetics.Canary(stack, 'Canary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('/* Synthetics handler code */'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // THEN\n  Template.fromStack(stack).hasResourceProperties('AWS::IAM::Role', {\n    Policies: [{\n      PolicyDocument: {\n        Statement: [\n          {\n            Action: 's3:ListAllMyBuckets',\n            Effect: 'Allow',\n            Resource: '*',\n          },\n          {\n            Action: 's3:GetBucketLocation',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::GetAtt': [\n                'CanaryArtifactsBucket4A60D32B',\n                'Arn',\n              ],\n            },\n          },\n          {\n            Action: 's3:PutObject',\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  {\n                    'Fn::GetAtt': [\n                      'CanaryArtifactsBucket4A60D32B',\n                      'Arn',\n                    ],\n                  },\n                  '/*',\n                ],\n              ],\n            },\n          },\n          {\n            Action: 'cloudwatch:PutMetricData',\n            Condition: {\n              StringEquals: {\n                'cloudwatch:namespace': 'CloudWatchSynthetics',\n              },\n            },\n            Effect: 'Allow',\n            Resource: '*',\n          },\n          {\n            Action: [\n              'logs:CreateLogStream',\n              'logs:CreateLogGroup',\n              'logs:PutLogEvents',\n            ],\n            Effect: 'Allow',\n            Resource: {\n              'Fn::Join': [\n                '',\n                [\n                  'arn:',\n                  {\n                    Ref: 'AWS::Partition',\n                  },\n                  ':logs:',\n                  {\n                    Ref: 'AWS::Region',\n                  },\n                  ':',\n                  {\n                    Ref: 'AWS::AccountId',\n                  },\n                  ':log-group:/aws/lambda/cwsyn-*',\n                ],\n              ],\n            },\n          },\n        ],\n      },\n    }],\n  });\n});",
            "file": "canary.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fromInline works",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 24
            },
            "line": 10,
            "code": "  test('fromInline works', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // WHEN\n    const inline = synthetics.Code.fromInline(`\n      exports.handler = async () => {\n        console.log(\\'hello world\\');\n      };`);\n\n    // THEN\n    expect(inline.bind(stack, 'index.handler', RuntimeFamily.NODEJS).inlineCode).toEqual(`\n      exports.handler = async () => {\n        console.log(\\'hello world\\');\n      };`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if empty",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 22
            },
            "line": 27,
            "code": "  test('fails if empty', () => {\n    expect(() => synthetics.Code.fromInline(''))\n      .toThrowError('Canary inline code cannot be empty');\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if handler is not \"index.handler\"",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 47
            },
            "line": 32,
            "code": "  test('fails if handler is not \"index.handler\"', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // THEN\n    expect(() => synthetics.Code.fromInline('code').bind(stack, 'canary.handler', RuntimeFamily.NODEJS))\n      .toThrowError('The handler for inline code must be \"index.handler\" (got \"canary.handler\")');\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fromAsset works for node runtimes",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 41
            },
            "line": 43,
            "code": "  test('fromAsset works for node runtimes', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // WHEN\n    const directoryAsset = synthetics.Code.fromAsset(path.join(__dirname, 'canaries'));\n    new synthetics.Canary(stack, 'Canary', {\n      test: synthetics.Test.custom({\n        handler: 'canary.handler',\n        code: directoryAsset,\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n      Code: {\n        Handler: 'canary.handler',\n        S3Bucket: stack.resolve(directoryAsset.bind(stack, 'canary.handler', synthetics.RuntimeFamily.NODEJS).s3Location?.bucketName),\n        S3Key: stack.resolve(directoryAsset.bind(stack, 'canary.handler', synthetics.RuntimeFamily.NODEJS).s3Location?.objectKey),\n      },\n    });\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fromAsset works for python runtimes",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 43
            },
            "line": 67,
            "code": "  test('fromAsset works for python runtimes', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // WHEN\n    const directoryAsset = synthetics.Code.fromAsset(path.join(__dirname, 'canaries'));\n    new synthetics.Canary(stack, 'Canary', {\n      test: synthetics.Test.custom({\n        handler: 'canary.handler',\n        code: directoryAsset,\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_PYTHON_SELENIUM_1_3,\n    });\n\n    // THEN\n    Template.fromStack(stack).hasResourceProperties('AWS::Synthetics::Canary', {\n      Code: {\n        Handler: 'canary.handler',\n        S3Bucket: stack.resolve(directoryAsset.bind(stack, 'canary.handler', synthetics.RuntimeFamily.PYTHON).s3Location?.bucketName),\n        S3Key: stack.resolve(directoryAsset.bind(stack, 'canary.handler', synthetics.RuntimeFamily.PYTHON).s3Location?.objectKey),\n      },\n    });\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "only one Asset object gets created even if multiple canaries use the same AssetCode",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 91
            },
            "line": 91,
            "code": "  test('only one Asset object gets created even if multiple canaries use the same AssetCode', () => {\n    // GIVEN\n    const app = new App({\n      context: {\n        [cxapi.NEW_STYLE_STACK_SYNTHESIS_CONTEXT]: false,\n      },\n    });\n    const stack = new Stack(app, 'canaries');\n\n    // WHEN\n    const directoryAsset = synthetics.Code.fromAsset(path.join(__dirname, 'canaries'));\n    new synthetics.Canary(stack, 'Canary1', {\n      test: synthetics.Test.custom({\n        handler: 'canary.handler',\n        code: directoryAsset,\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    });\n\n    new synthetics.Canary(stack, 'Canary2', {\n      test: synthetics.Test.custom({\n        handler: 'canary.handler',\n        code: directoryAsset,\n      }),\n      runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n    });\n\n    // THEN\n    const assembly = app.synth();\n    const synthesized = assembly.stacks[0];\n\n    expect(synthesized.assets.length).toEqual(1);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if path does not exist",
            "suites": [],
            "updatePoint": {
                "line": 125,
                "column": 36
            },
            "line": 125,
            "code": "  test('fails if path does not exist', () => {\n    const assetPath = path.join(__dirname, 'does-not-exist');\n    expect(() => synthetics.Code.fromAsset(assetPath))\n      .toThrowError(`${assetPath} is not a valid path`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if non-zip asset is used",
            "suites": [],
            "updatePoint": {
                "line": 131,
                "column": 38
            },
            "line": 131,
            "code": "  test('fails if non-zip asset is used', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // THEN\n    const assetPath = path.join(__dirname, 'canaries', 'nodejs', 'node_modules', 'canary.js');\n    expect(() => synthetics.Code.fromAsset(assetPath).bind(stack, 'canary.handler', synthetics.RuntimeFamily.NODEJS))\n      .toThrowError(`Asset must be a .zip file or a directory (${assetPath})`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if node runtime and \"nodejs/node_modules\" folder structure not used",
            "suites": [],
            "updatePoint": {
                "line": 141,
                "column": 81
            },
            "line": 141,
            "code": "  test('fails if node runtime and \"nodejs/node_modules\" folder structure not used', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // THEN\n    const assetPath = path.join(__dirname, 'canaries', 'nodejs', 'node_modules');\n    expect(() => synthetics.Code.fromAsset(assetPath).bind(stack, 'canary.handler', synthetics.RuntimeFamily.NODEJS))\n      .toThrowError(`The canary resource requires that the handler is present at \"nodejs/node_modules/canary.js\" but not found at ${assetPath} (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_WritingCanary_Nodejs.html)`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if python runtime and \"python\" folder structure not used",
            "suites": [],
            "updatePoint": {
                "line": 151,
                "column": 70
            },
            "line": 151,
            "code": "  test('fails if python runtime and \"python\" folder structure not used', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // THEN\n    const assetPath = path.join(__dirname, 'canaries', 'python');\n    expect(() => synthetics.Code.fromAsset(assetPath).bind(stack, 'canary.handler', synthetics.RuntimeFamily.PYTHON))\n      .toThrowError(`The canary resource requires that the handler is present at \"python/canary.py\" but not found at ${assetPath} (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_WritingCanary_Python.html)`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fails if handler is specified incorrectly",
            "suites": [],
            "updatePoint": {
                "line": 161,
                "column": 49
            },
            "line": 161,
            "code": "  test('fails if handler is specified incorrectly', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n\n    // THEN\n    const assetPath = path.join(__dirname, 'canaries', 'nodejs', 'node_modules');\n    expect(() => synthetics.Code.fromAsset(assetPath).bind(stack, 'incorrect.handler', synthetics.RuntimeFamily.NODEJS))\n      .toThrowError(`The canary resource requires that the handler is present at \"nodejs/node_modules/incorrect.js\" but not found at ${assetPath} (https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_WritingCanary_Nodejs.html)`);\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "fromBucket works",
            "suites": [],
            "updatePoint": {
                "line": 174,
                "column": 24
            },
            "line": 174,
            "code": "  test('fromBucket works', () => {\n    // GIVEN\n    const stack = new Stack(new App(), 'canaries');\n    const bucket = new s3.Bucket(stack, 'CodeBucket');\n\n    // WHEN\n    const code = synthetics.Code.fromBucket(bucket, 'code.js');\n    const codeConfig = code.bind(stack, 'code.handler', RuntimeFamily.NODEJS);\n\n    // THEN\n    expect(codeConfig.s3Location?.bucketName).toEqual(bucket.bucketName);\n    expect(codeConfig.s3Location?.objectKey).toEqual('code.js');\n  });",
            "file": "code.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": ".metricXxx() methods can be used to obtain Metrics for the canary",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 71
            },
            "line": 4,
            "code": "test('.metricXxx() methods can be used to obtain Metrics for the canary', () => {\n  // GIVEN\n  const stack = new Stack(new App(), 'canaries');\n\n  const canary = new synthetics.Canary(stack, 'mycanary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('foo'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // WHEN\n  const metricSuccess = canary.metricSuccessPercent();\n  const metricFailed = canary.metricFailed();\n  const metricDuration = canary.metricDuration();\n\n  // THEN\n  expect(metricSuccess).toEqual(expect.objectContaining({\n    dimensions: { CanaryName: canary.canaryName },\n    namespace: 'CloudWatchSynthetics',\n    metricName: 'SuccessPercent',\n    statistic: 'Average',\n  }));\n\n  expect(metricFailed).toEqual(expect.objectContaining({\n    dimensions: { CanaryName: canary.canaryName },\n    namespace: 'CloudWatchSynthetics',\n    metricName: 'Failed',\n    statistic: 'Sum',\n  }));\n\n  expect(metricDuration).toEqual(expect.objectContaining({\n    dimensions: { CanaryName: canary.canaryName },\n    namespace: 'CloudWatchSynthetics',\n    metricName: 'Duration',\n    statistic: 'Average',\n  }));\n});",
            "file": "metric.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Metric can specify statistic",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 34
            },
            "line": 44,
            "code": "test('Metric can specify statistic', () => {\n  // GIVEN\n  const stack = new Stack(new App(), 'canaries');\n\n  const canary = new synthetics.Canary(stack, 'mycanary', {\n    test: synthetics.Test.custom({\n      handler: 'index.handler',\n      code: synthetics.Code.fromInline('foo'),\n    }),\n    runtime: synthetics.Runtime.SYNTHETICS_NODEJS_PUPPETEER_3_8,\n  });\n\n  // WHEN\n  const metric = canary.metricFailed({ statistic: 'Sum' });\n\n  // THEN\n  expect(metric).toEqual(expect.objectContaining({\n    dimensions: { CanaryName: canary.canaryName },\n    namespace: 'CloudWatchSynthetics',\n    metricName: 'Failed',\n    statistic: 'Sum',\n  }));\n});",
            "file": "metric.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "day and weekDay are mutex: given week day",
            "suites": [
                "cron"
            ],
            "updatePoint": {
                "line": 4,
                "column": 49
            },
            "line": 4,
            "code": "  test('day and weekDay are mutex: given week day', () => {\n    expect(synthetics.Schedule.cron({\n      weekDay: 'MON-FRI',\n    }).expressionString).toEqual('cron(* * ? * MON-FRI *)');\n  });",
            "file": "schedule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "day and weekDay are mutex: given month day",
            "suites": [
                "cron"
            ],
            "updatePoint": {
                "line": 10,
                "column": 50
            },
            "line": 10,
            "code": "  test('day and weekDay are mutex: given month day', () => {\n    expect(synthetics.Schedule.cron({\n      day: '1',\n    }).expressionString).toEqual('cron(* * 1 * ? *)');\n  });",
            "file": "schedule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "day and weekDay are mutex: given neither",
            "suites": [
                "cron"
            ],
            "updatePoint": {
                "line": 16,
                "column": 48
            },
            "line": 16,
            "code": "  test('day and weekDay are mutex: given neither', () => {\n    expect(synthetics.Schedule.cron({}).expressionString).toEqual('cron(* * * * ? *)');\n  });",
            "file": "schedule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "day and weekDay are mutex: throw if given both",
            "suites": [
                "cron"
            ],
            "updatePoint": {
                "line": 20,
                "column": 54
            },
            "line": 20,
            "code": "  test('day and weekDay are mutex: throw if given both', () => {\n    expect(() => synthetics.Schedule.cron({\n      day: '1',\n      weekDay: 'MON',\n    })).toThrow('Cannot supply both \\'day\\' and \\'weekDay\\', use at most one');\n  });",
            "file": "schedule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/aws-synthetics/test"
        },
        {
            "name": "Validate augmentation schema for ",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 52
            },
            "line": 25,
            "code": "  test(`Validate augmentation schema for ${resource}`, resourceAugmentationTest(resource));",
            "file": "augmentation.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "dropTypelessAttributes works correctly",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 44
            },
            "line": 4,
            "code": "test('dropTypelessAttributes works correctly', () => {\n  const spec: schema.Specification = {\n    Fingerprint: 'some-fingerprint',\n    PropertyTypes: {\n      'CDK::Test::Property': {\n        Properties: {\n          Type: ({\n            PrimitiveType: 'String',\n          } as schema.ScalarProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n    ResourceTypes: {\n      'CDK::Test::Resource': {\n        Attributes: {\n          Attribute1: ({\n            PrimitiveType: 'String',\n          } as schema.PrimitiveAttribute), // ts is being weird and doesn't correctly match the type\n          Attribute2: ({} as schema.PrimitiveAttribute),\n        },\n        Documentation: 'https://documentation-url/cdk/test/resource',\n        Properties: {\n          ResourceArn: ({\n            PrimitiveType: 'String',\n          } as schema.PrimitiveProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n  };\n\n  massageSpec(spec);\n\n  expect(spec).toEqual({\n    Fingerprint: 'some-fingerprint',\n    PropertyTypes: {\n      'CDK::Test::Property': {\n        Properties: {\n          Type: ({\n            PrimitiveType: 'String',\n          } as schema.ScalarProperty), // ts is being weird and doesn't correctly match the type\n        },\n      },\n    },\n    ResourceTypes: {\n      'CDK::Test::Resource': {\n        Attributes: {\n          Attribute1: ({\n            PrimitiveType: 'String',\n          }),\n        },\n        Documentation: 'https://documentation-url/cdk/test/resource',\n        Properties: {\n          ResourceArn: {\n            PrimitiveType: 'String',\n          },\n        },\n      },\n    },\n  });\n});",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check DynamoDB metrics",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 33
            },
            "line": 3,
            "code": "test('spot-check DynamoDB metrics', () => {\n  const metrics = cfnspec.cannedMetricsForService('AWS::DynamoDB');\n  expect(metrics.length).toBeGreaterThan(0);\n\n  const resLatency = metrics.find(m => m.metricName === 'SuccessfulRequestLatency');\n  expect(resLatency).toBeTruthy();\n\n  expect(resLatency?.dimensions).toEqual([['Operation', 'TableName']]);\n});",
            "file": "canned-metrics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check MediaStore metrics",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 35
            },
            "line": 13,
            "code": "test('spot-check MediaStore metrics', () => {\n  const metrics = cfnspec.cannedMetricsForService('AWS::MediaStore');\n  expect(metrics.length).toBeGreaterThan(0);\n});",
            "file": "canned-metrics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "Validate canned metrics for ",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 48
            },
            "line": 23,
            "code": "  test(`Validate canned metrics for ${namespace}`, () => {\n    const metrics = cfnspec.cannedMetricsForService(namespace);\n\n    // Check that there are no duplicates in these list (duplicates may occur because of duplicate\n    // dimensions, but those have readly been combined).\n    const uniqueMetricNames = new Set(metrics.map(m => `${m.namespace}/${m.metricName}`));\n    expect(uniqueMetricNames.size).toEqual(metrics.length);\n  });",
            "file": "canned-metrics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check Bucket statefulness",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 36
            },
            "line": 3,
            "code": "test('spot-check Bucket statefulness', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::S3::Bucket');\n  expect(anno.stateful).toBeTruthy();\n  expect(anno.mustBeEmptyToDelete).toBeTruthy();\n});",
            "file": "cfnlint-annotations.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check Table statefulness",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 35
            },
            "line": 9,
            "code": "test('spot-check Table statefulness', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::DynamoDB::Table');\n  expect(anno.stateful).toBeTruthy();\n  expect(anno.mustBeEmptyToDelete).toBeFalsy();\n});",
            "file": "cfnlint-annotations.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check MediaStore metrics",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 35
            },
            "line": 15,
            "code": "test('spot-check MediaStore metrics', () => {\n  const anno = cfnspec.cfnLintAnnotations('AWS::MediaStore::Thingy');\n  expect(anno.stateful).toBeFalsy();\n});",
            "file": "cfnlint-annotations.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check resource docs",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 30
            },
            "line": 3,
            "code": "test('spot-check resource docs', () => {\n  const bucketDocs = cfnspec.typeDocs('AWS::S3::Bucket');\n\n  expect(bucketDocs.description).toBeTruthy();\n  expect(bucketDocs.properties.BucketName).toBeTruthy();\n});",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check property type docs",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 35
            },
            "line": 10,
            "code": "test('spot-check property type docs', () => {\n  const destDocs = cfnspec.typeDocs('AWS::S3::Bucket.Destination');\n\n  expect(destDocs.description).toBeTruthy();\n  expect(destDocs.properties.Format).toBeTruthy();\n});",
            "file": "docs.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "filteredSpecification(/^AWS::S3::.*/)",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 43
            },
            "line": 4,
            "code": "test('filteredSpecification(/^AWS::S3::.*/)', () => {\n  const filteredSpec = filteredSpecification(/^AWS::S3::.*/);\n  expect(filteredSpec).not.toEqual(specification);\n  expect(filteredSpec.ResourceTypes).not.toEqual({});\n});",
            "file": "filtered-specification.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "filteredSpecification(s => s.startsWith(\"AWS::S3::\")",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 58
            },
            "line": 10,
            "code": "test('filteredSpecification(s => s.startsWith(\"AWS::S3::\")', () => {\n  const filteredSpec = filteredSpecification(s => s.startsWith('AWS::S3::'));\n  expect(filteredSpec).not.toEqual(specification);\n  expect(filteredSpec.ResourceTypes).not.toEqual({});\n});",
            "file": "filtered-specification.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "namespaces() includes some namespaces",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 43
            },
            "line": 3,
            "code": "test('namespaces() includes some namespaces', () => {\n  expect(namespaces().length).toBeGreaterThan(10);\n});",
            "file": "namespaces.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "can combine two independent records",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 41
            },
            "line": 11,
            "code": "test('can combine two independent records', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { b: 'b' },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "can combine two records with same value",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 45
            },
            "line": 27,
            "code": "test('can combine two records with same value', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a', b: 'b' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { b: 'b', c: 'c' },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: 'c',\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "cannot combine two records with conflicting values",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 56
            },
            "line": 44,
            "code": "test('cannot combine two records with conflicting values', () => {\n  expect(() => evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'fragment',\n      data: { a: 'x' },\n    },\n  })).toThrow(/Conflict/);\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "can apply json patches to records",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 39
            },
            "line": 57,
            "code": "test('can apply json patches to records', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        patch: {\n          operations: [{\n            op: 'move',\n            from: '/a',\n            path: '/b',\n          }],\n        },\n      },\n    },\n  })).toEqual({\n    b: 'a',\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "can apply json patches in nested context",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 46
            },
            "line": 80,
            "code": "test('can apply json patches in nested context', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { nested: { a: 'a' } },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        nested: {\n          patch: {\n            operations: [{\n              op: 'move',\n              from: '/a',\n              path: '/b',\n            }],\n          },\n        },\n      },\n    },\n  })).toEqual({\n    nested: { b: 'a' },\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "relative json patch paths can reference from the root",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 59
            },
            "line": 105,
            "code": "test('relative json patch paths can reference from the root', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a', nested: { b: 'b' } },\n    },\n    '002': {\n      type: 'patch',\n      data: {\n        nested: {\n          patch: {\n            operations: [{\n              op: 'move',\n              from: '$/a',\n              path: '/a',\n            }],\n          },\n        },\n      },\n    },\n  })).toEqual({\n    nested: { a: 'a', b: 'b' },\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "can nest sub-patch sets",
            "suites": [],
            "updatePoint": {
                "line": 130,
                "column": 29
            },
            "line": 130,
            "code": "test('can nest sub-patch sets', () => {\n  expect(evaluate({\n    '001': {\n      type: 'fragment',\n      data: { a: 'a' },\n    },\n    '002': {\n      type: 'set',\n      sources: {\n        '001': {\n          type: 'fragment',\n          data: { b: 'b' },\n        },\n        '002': {\n          type: 'fragment',\n          data: { c: 'c' },\n        },\n      },\n    },\n  })).toEqual({\n    a: 'a',\n    b: 'b',\n    c: 'c',\n  });\n});",
            "file": "patch-set.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check IAM identity tags",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 34
            },
            "line": 4,
            "code": "test('spot-check IAM identity tags', () => {\n  const prop = propertySpecification('AWS::IAM::Role', 'Policies');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineIdentityPolicies);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "IAM AssumeRolePolicy",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 26
            },
            "line": 9,
            "code": "test('IAM AssumeRolePolicy', () => {\n  // AssumeRolePolicyDocument is a resource policy, because it applies to the Role itself!\n  const prop = propertySpecification('AWS::IAM::Role', 'AssumeRolePolicyDocument');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineResourcePolicy);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check IAM resource tags",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 34
            },
            "line": 15,
            "code": "test('spot-check IAM resource tags', () => {\n  const prop = propertySpecification('AWS::KMS::Key', 'KeyPolicy');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.InlineResourcePolicy);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check resource policy resources",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 42
            },
            "line": 20,
            "code": "test('spot-check resource policy resources', () => {\n  expect(resourceSpecification('AWS::S3::BucketPolicy').ScrutinyType).toEqual(ResourceScrutinyType.ResourcePolicyResource);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "spot-check no misclassified tags",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 38
            },
            "line": 24,
            "code": "test('spot-check no misclassified tags', () => {\n  const prop = propertySpecification('AWS::SNS::Subscription', 'DeliveryPolicy');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.None);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "check Lambda permission resource scrutiny",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 47
            },
            "line": 29,
            "code": "test('check Lambda permission resource scrutiny', () => {\n  expect(resourceSpecification('AWS::Lambda::Permission').ScrutinyType).toEqual(ResourceScrutinyType.LambdaPermission);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "check role managedpolicyarns",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 34
            },
            "line": 33,
            "code": "test('check role managedpolicyarns', () => {\n  const prop = propertySpecification('AWS::IAM::Role', 'ManagedPolicyArns');\n  expect(prop.ScrutinyType).toEqual(PropertyScrutinyType.ManagedPolicies);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "check securityGroup scrutinies",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 36
            },
            "line": 38,
            "code": "test('check securityGroup scrutinies', () => {\n  const inProp = propertySpecification('AWS::EC2::SecurityGroup', 'SecurityGroupIngress');\n  expect(inProp.ScrutinyType).toEqual(PropertyScrutinyType.IngressRules);\n\n  const eProp = propertySpecification('AWS::EC2::SecurityGroup', 'SecurityGroupEgress');\n  expect(eProp.ScrutinyType).toEqual(PropertyScrutinyType.EgressRules);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "check securityGroupRule scrutinies",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 40
            },
            "line": 46,
            "code": "test('check securityGroupRule scrutinies', () => {\n  const inRes = resourceSpecification('AWS::EC2::SecurityGroupIngress');\n  expect(inRes.ScrutinyType).toEqual(ResourceScrutinyType.IngressRuleResource);\n\n  const eRes = resourceSpecification('AWS::EC2::SecurityGroupEgress');\n  expect(eRes.ScrutinyType).toEqual(ResourceScrutinyType.EgressRuleResource);\n});",
            "file": "scrutiny.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if Type and PrimitiveType are both absent",
            "suites": [
                "single-valued type"
            ],
            "updatePoint": {
                "line": 4,
                "column": 55
            },
            "line": 4,
            "code": "  test('error if Type and PrimitiveType are both absent', () => {\n    expect(errorsFor(resourceTypeProperty({}))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'Type', 'PrimitiveType'\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if referenced type does not exist",
            "suites": [
                "single-valued type"
            ],
            "updatePoint": {
                "line": 10,
                "column": 47
            },
            "line": 10,
            "code": "  test('error if referenced type does not exist', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'Xyz',\n    }))).toEqual([\n      expect.stringContaining(\"unknown property type name 'Xyz'\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if Type and PrimitiveType are both present",
            "suites": [
                "single-valued type"
            ],
            "updatePoint": {
                "line": 18,
                "column": 56
            },
            "line": 18,
            "code": "  test('error if Type and PrimitiveType are both present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'Asdf',\n      PrimitiveType: 'String',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'Type', 'PrimitiveType'\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if ItemType is present",
            "suites": [
                "single-valued type"
            ],
            "updatePoint": {
                "line": 27,
                "column": 36
            },
            "line": 27,
            "code": "  test('error if ItemType is present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      PrimitiveType: 'String',\n      ItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"only 'List' or 'Map' types\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if PrimitiveItemType is present and Type is not a collection",
            "suites": [
                "single-valued type"
            ],
            "updatePoint": {
                "line": 36,
                "column": 74
            },
            "line": 36,
            "code": "  test('error if PrimitiveItemType is present and Type is not a collection', () => {\n    expect(errorsFor(resourceTypeProperty({\n      PrimitiveType: 'String',\n      PrimitiveItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"only 'List' or 'Map' types\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if ItemType or PrimitiveItemType are both present",
            "suites": [
                "collection type"
            ],
            "updatePoint": {
                "line": 47,
                "column": 63
            },
            "line": 47,
            "code": "  test('error if ItemType or PrimitiveItemType are both present', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'List',\n      PrimitiveItemType: 'String',\n      ItemType: 'Asdf',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'ItemType', 'PrimitiveItemType'\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "error if ItemType or PrimitiveItemType are both absent",
            "suites": [
                "collection type"
            ],
            "updatePoint": {
                "line": 57,
                "column": 62
            },
            "line": 57,
            "code": "  test('error if ItemType or PrimitiveItemType are both absent', () => {\n    expect(errorsFor(resourceTypeProperty({\n      Type: 'List',\n    }))).toEqual([\n      expect.stringContaining(\"must have exactly one of 'ItemType', 'PrimitiveItemType'\"),\n    ]);\n  });",
            "file": "validate-cfn.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cfnspec/test"
        },
        {
            "name": "when there is no difference",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 33
            },
            "line": 12,
            "code": "test('when there is no difference', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      BucketPolicyResource: BUCKET_POLICY_RESOURCE,\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n  // Making a JSON-clone, because === is cheating!\n  const newTemplate = JSON.parse(JSON.stringify(currentTemplate));\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(0);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a resource is created",
            "suites": [],
            "updatePoint": {
                "line": 32,
                "column": 32
            },
            "line": 32,
            "code": "test('when a resource is created', () => {\n  const currentTemplate = { Resources: {} };\n\n  const newTemplate = { Resources: { BucketResource: { Type: 'AWS::S3::Bucket' } } };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isAddition).toBeTruthy();\n  expect(difference?.newResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_CREATE);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a resource is deleted (no DeletionPolicy)",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 52
            },
            "line": 47,
            "code": "test('when a resource is deleted (no DeletionPolicy)', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n      BucketPolicyResource: BUCKET_POLICY_RESOURCE,\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketPolicyResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isRemoval).toBeTruthy();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::BucketPolicy');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_DESTROY);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a resource is deleted (DeletionPolicy=Retain)",
            "suites": [],
            "updatePoint": {
                "line": 71,
                "column": 56
            },
            "line": 71,
            "code": "test('when a resource is deleted (DeletionPolicy=Retain)', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: { Type: 'AWS::S3::Bucket' },\n      BucketPolicyResource: {\n        Type: 'AWS::S3::BucketPolicy',\n        DeletionPolicy: 'Retain',\n        Properties: {\n          PolicyDocument: POLICY_DOCUMENT,\n          Bucket: { Ref: 'BucketResource' },\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: { BucketResource: { Type: 'AWS::S3::Bucket' } },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketPolicyResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.isRemoval).toBeTruthy();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::BucketPolicy');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_ORPHAN);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a property changes",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 29
            },
            "line": 100,
            "code": "test('when a property changes', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const newBucketName = `${bucketName}-v2`;\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: newBucketName,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: bucketName, newValue: newBucketName, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "change in dependencies counts as a simple update",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 54
            },
            "line": 142,
            "code": "test('change in dependencies counts as a simple update', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'SomeOtherResource'],\n      },\n    },\n  };\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_UPDATE);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a property is deleted",
            "suites": [],
            "updatePoint": {
                "line": 170,
                "column": 32
            },
            "line": 170,
            "code": "test('when a property is deleted', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: bucketName, newValue: undefined, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a property is added",
            "suites": [],
            "updatePoint": {
                "line": 208,
                "column": 30
            },
            "line": 208,
            "code": "test('when a property is added', () => {\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      QueueResource: {\n        Type: 'AWS::SQS::Queue',\n      },\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: bucketName,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    BucketName: { oldValue: undefined, newValue: bucketName, changeImpact: ResourceImpact.WILL_REPLACE, isDifferent: true },\n  });\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a resource type changed",
            "suites": [],
            "updatePoint": {
                "line": 246,
                "column": 34
            },
            "line": 246,
            "code": "test('when a resource type changed', () => {\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::IAM::Policy',\n        Properties: {\n          PolicyName: 'PolicyName',\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          BucketName: 'BucketName',\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBe(undefined);\n  expect(difference?.oldResourceType).toEqual('AWS::IAM::Policy');\n  expect(difference?.newResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.changeImpact).toBe(ResourceImpact.WILL_REPLACE);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "resource replacement is tracked through references",
            "suites": [],
            "updatePoint": {
                "line": 279,
                "column": 56
            },
            "line": 279,
            "code": "test('resource replacement is tracked through references', () => {\n  // If a resource is replaced, then that change shows that references are\n  // going to change. This may lead to replacement of downstream resources\n  // if the reference is used in an immutable property, and so on.\n\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: { BucketName: 'Name1' }, // Immutable prop\n      },\n      Queue: {\n        Type: 'AWS::SQS::Queue',\n        Properties: { QueueName: { Ref: 'Bucket' } }, // Immutable prop\n      },\n      Topic: {\n        Type: 'AWS::SNS::Topic',\n        Properties: { TopicName: { Ref: 'Queue' } }, // Immutable prop\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: { BucketName: 'Name2' },\n      },\n      Queue: {\n        Type: 'AWS::SQS::Queue',\n        Properties: { QueueName: { Ref: 'Bucket' } },\n      },\n      Topic: {\n        Type: 'AWS::SNS::Topic',\n        Properties: { TopicName: { Ref: 'Queue' } },\n      },\n    },\n  };\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.resources.differenceCount).toBe(3);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "adding and removing quotes from a numeric property causes no changes",
            "suites": [],
            "updatePoint": {
                "line": 325,
                "column": 74
            },
            "line": 325,
            "code": "test('adding and removing quotes from a numeric property causes no changes', () => {\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          CorsConfiguration: {\n            CorsRules: [\n              {\n                AllowedMethods: [\n                  'GET',\n                ],\n                AllowedOrigins: [\n                  '*',\n                ],\n                MaxAge: 10,\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          CorsConfiguration: {\n            CorsRules: [\n              {\n                AllowedMethods: [\n                  'GET',\n                ],\n                AllowedOrigins: [\n                  '*',\n                ],\n                MaxAge: '10',\n              },\n            ],\n          },\n        },\n      },\n    },\n  };\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "versions are correctly detected as not numbers",
            "suites": [],
            "updatePoint": {
                "line": 378,
                "column": 52
            },
            "line": 378,
            "code": "test('versions are correctly detected as not numbers', () => {\n  const currentTemplate = {\n    Resources: {\n      ImageBuilderComponent: {\n        Type: 'AWS::ImageBuilder::Component',\n        Properties: {\n          Platform: 'Linux',\n          Version: '0.0.1',\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      ImageBuilderComponent: {\n        Type: 'AWS::ImageBuilder::Component',\n        Properties: {\n          Platform: 'Linux',\n          Version: '0.0.2',\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "single element arrays are equivalent to the single element in DependsOn expressions",
            "suites": [],
            "updatePoint": {
                "line": 406,
                "column": 89
            },
            "line": 406,
            "code": "test('single element arrays are equivalent to the single element in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: 'SomeResource',\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "array equivalence is independent of element order in DependsOn expressions",
            "suites": [],
            "updatePoint": {
                "line": 434,
                "column": 80
            },
            "line": 434,
            "code": "test('array equivalence is independent of element order in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'AnotherResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['AnotherResource', 'SomeResource'],\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(0);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "arrays of different length are considered unequal in DependsOn expressions",
            "suites": [],
            "updatePoint": {
                "line": 462,
                "column": 80
            },
            "line": 462,
            "code": "test('arrays of different length are considered unequal in DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource', 'AnotherResource', 'LastResource'],\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['AnotherResource', 'SomeResource'],\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "arrays that differ only in element order are considered unequal outside of DependsOn expressions",
            "suites": [],
            "updatePoint": {
                "line": 490,
                "column": 102
            },
            "line": 490,
            "code": "test('arrays that differ only in element order are considered unequal outside of DependsOn expressions', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        BucketName: { 'Fn::Select': [0, ['name1', 'name2']] },\n      },\n    },\n  };\n\n  // WHEN\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        BucketName: { 'Fn::Select': [0, ['name2', 'name1']] },\n      },\n    },\n  };\n\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "boolean properties are considered equal with their stringified counterparts",
            "suites": [],
            "updatePoint": {
                "line": 518,
                "column": 81
            },
            "line": 518,
            "code": "test('boolean properties are considered equal with their stringified counterparts', () => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          PublicAccessBlockConfiguration: {\n            BlockPublicAcls: 'true',\n          },\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      Bucket: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          PublicAccessBlockConfiguration: {\n            BlockPublicAcls: true,\n          },\n        },\n      },\n    },\n  };\n\n  // WHEN\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(0);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a property changes including equivalent DependsOn",
            "suites": [],
            "updatePoint": {
                "line": 552,
                "column": 60
            },
            "line": 552,
            "code": "test('when a property changes including equivalent DependsOn', () => {\n  // GIVEN\n  const bucketName = 'ShineyBucketName';\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n        BucketName: bucketName,\n      },\n    },\n  };\n\n  // WHEN\n  const newBucketName = `${bucketName}-v2`;\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        DependsOn: ['SomeResource'],\n        BucketName: newBucketName,\n      },\n    },\n  };\n\n  // THEN\n  let differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n\n  differences = diffTemplate(newTemplate, currentTemplate);\n  expect(differences.resources.differenceCount).toBe(1);\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "reports a change when a string property with a number-like format changes from '%s' to '%s'",
            "suites": [],
            "line": 585,
            "code": "test.each([\n  ['0.31.1-prod', '0.31.2-prod'],\n  ['8.0.5.5.4-identifier', '8.0.5.5.5-identifier'],\n  ['1.1.1.1', '1.1.1.2'],\n  ['1.2.3', '1.2.4'],\n  ['2.2.2.2', '2.2.3.2'],\n  ['3.3.3.3', '3.4.3.3'],\n  ['2021-10-23T06:07:08.000Z', '2021-10-23T09:10:11.123Z'],\n])(\"reports a change when a string property with a number-like format changes from '%s' to '%s'\", (oldValue, newValue) => {\n  // GIVEN\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: [oldValue],\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: [newValue],\n        },\n      },\n    },\n  };\n  // WHEN\n  const differences = diffTemplate(currentTemplate, newTemplate);\n\n  // THEN\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).not.toBeUndefined();\n  expect(difference?.oldResourceType).toEqual('AWS::S3::Bucket');\n  expect(difference?.propertyUpdates).toEqual({\n    Tags: { oldValue: [oldValue], newValue: [newValue], changeImpact: ResourceImpact.WILL_UPDATE, isDifferent: true },\n  });\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "when a property with a number-like format doesn't change",
            "suites": [],
            "updatePoint": {
                "line": 629,
                "column": 63
            },
            "line": 629,
            "code": "test('when a property with a number-like format doesn\\'t change', () => {\n  const tags = ['0.31.1-prod', '8.0.5.5.4-identifier', '1.1.1.1', '1.2.3'];\n  const currentTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: tags,\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      BucketResource: {\n        Type: 'AWS::S3::Bucket',\n        Properties: {\n          Tags: tags,\n        },\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(0);\n  expect(differences.resources.differenceCount).toBe(0);\n  const difference = differences.resources.changes.BucketResource;\n  expect(difference).toBeUndefined();\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "handles a resource changing its Type",
            "suites": [],
            "updatePoint": {
                "line": 659,
                "column": 42
            },
            "line": 659,
            "code": "test('handles a resource changing its Type', () => {\n  const currentTemplate = {\n    Resources: {\n      FunctionApi: {\n        Type: 'AWS::Serverless::Api',\n        Properties: {\n          StageName: 'prod',\n        },\n      },\n    },\n  };\n  const newTemplate = {\n    Resources: {\n      FunctionApi: {\n        Type: 'AWS::ApiGateway::RestApi',\n      },\n    },\n  };\n\n  const differences = diffTemplate(currentTemplate, newTemplate);\n  expect(differences.differenceCount).toBe(1);\n  expect(differences.resources.differenceCount).toBe(1);\n  const difference = differences.resources.changes.FunctionApi;\n  expect(difference).toEqual({\n    isAddition: false,\n    isRemoval: false,\n    newValue: { Type: 'AWS::ApiGateway::RestApi' },\n    oldValue: { Properties: { StageName: 'prod' }, Type: 'AWS::Serverless::Api' },\n    otherDiffs: {},\n    propertyDiffs: {},\n    resourceTypes: { newType: 'AWS::ApiGateway::RestApi', oldType: 'AWS::Serverless::Api' },\n  });\n});",
            "file": "diff-template.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "adding of positive statements",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 5,
                "column": 37
            },
            "line": 5,
            "code": "  test('adding of positive statements', () => {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          Principal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "permissions diff can be printed",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 23,
                "column": 39
            },
            "line": 23,
            "code": "  test('permissions diff can be printed', () => {\n    // GIVEN\n    const diff = diffTemplate({}, template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          Principal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }));\n\n    // WHEN\n    // Behave like process.stderr, but have a 'columns' property to trigger the column width calculation\n    const stdErrMostly = Object.create(process.stderr, {\n      columns: { value: 80 },\n    });\n    formatSecurityChanges(stdErrMostly, diff);\n\n    // THEN: does not throw\n    expect(true).toBeTruthy();\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "adding of positive statements to an existing policy",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 48,
                "column": 59
            },
            "line": 48,
            "code": "  test('adding of positive statements to an existing policy', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n          {\n            Effect: 'Allow',\n            Action: 'sqs:LookAtMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "removal of not-statements",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 86,
                "column": 33
            },
            "line": 86,
            "code": "  test('removal of not-statements', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 'sqs:SendMessage',\n          Resource: '*',\n          NotPrincipal: { Service: 'sns.amazonaws.com' },\n        }),\n      }),\n    }), {});\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "changing of resource target",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 104,
                "column": 35
            },
            "line": 104,
            "code": "  test('changing of resource target', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyOtherQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "addition of ingress rules",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 136,
                "column": 33
            },
            "line": 136,
            "code": "  test('addition of ingress rules', () => {\n    // WHEN\n    const diff = diffTemplate(\n      template({\n      }),\n      template({\n        SG: resource('AWS::EC2::SecurityGroup', {\n          SecurityGroupIngress: [\n            {\n              CidrIp: '1.2.3.4/8',\n              FromPort: 80,\n              ToPort: 80,\n              IpProtocol: 'tcp',\n            },\n          ],\n        }),\n      }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "addition of egress rules",
            "suites": [
                "broadening is"
            ],
            "updatePoint": {
                "line": 158,
                "column": 32
            },
            "line": 158,
            "code": "  test('addition of egress rules', () => {\n    // WHEN\n    const diff = diffTemplate(\n      template({\n      }),\n      template({\n        SG: resource('AWS::EC2::SecurityGroup', {\n          SecurityGroupEgress: [\n            {\n              DestinationSecurityGroupId: { 'Fn::GetAtt': ['ThatOtherGroup', 'GroupId'] },\n              FromPort: 80,\n              ToPort: 80,\n              IpProtocol: 'tcp',\n            },\n          ],\n        }),\n      }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(true);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "removal of positive statements from an existing policy",
            "suites": [
                "broadening is not"
            ],
            "updatePoint": {
                "line": 182,
                "column": 62
            },
            "line": 182,
            "code": "  test('removal of positive statements from an existing policy', () => {\n    // WHEN\n    const diff = diffTemplate(template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n          {\n            Effect: 'Allow',\n            Action: 'sqs:LookAtMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }), template({\n      QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n        Queues: [{ Ref: 'MyQueue' }],\n        PolicyDocument: poldoc(\n          {\n            Effect: 'Allow',\n            Action: 'sqs:SendMessage',\n            Resource: '*',\n            Principal: { Service: 'sns.amazonaws.com' },\n          },\n        ),\n      }),\n    }));\n\n    // THEN\n    expect(diff.permissionsBroadened).toBe(false);\n  });",
            "file": "iam/broadening.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "shows new AssumeRolePolicyDocument",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 40
            },
            "line": 4,
            "code": "test('shows new AssumeRolePolicyDocument', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyRole.Arn}'] },\n        principals: { not: false, values: ['Service:lambda.amazonaws.com'] },\n        actions: { not: false, values: ['sts:AssumeRole'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "implicitly knows principal of identity policy for all resource types",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 74
            },
            "line": 29,
            "code": "test('implicitly knows principal of identity policy for all resource types', () => {\n  for (const attr of ['Roles', 'Users', 'Groups']) {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      MyPolicy: policy({\n        [attr]: [{ Ref: 'MyRole' }],\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:DoThatThing',\n          Resource: '*',\n        }),\n      }),\n    }));\n\n    // THEN\n    expect(diff.iamChanges._toJson()).toEqual({\n      statementAdditions: [\n        {\n          effect: 'Allow',\n          resources: { not: false, values: ['*'] },\n          principals: { not: false, values: ['AWS:${MyRole}'] },\n          actions: { not: false, values: ['s3:DoThatThing'] },\n        },\n      ],\n    });\n  }\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "policies on an identity object",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 36
            },
            "line": 57,
            "code": "test('policies on an identity object', () => {\n  for (const resourceType of ['Role', 'User', 'Group']) {\n    // WHEN\n    const diff = diffTemplate({}, template({\n      MyIdentity: resource(`AWS::IAM::${resourceType}`, {\n        Policies: [\n          {\n            PolicyName: 'Polly',\n            PolicyDocument: poldoc({\n              Effect: 'Allow',\n              Action: 's3:DoThatThing',\n              Resource: '*',\n            }),\n          },\n        ],\n      }),\n    }));\n\n    // THEN\n    expect(diff.iamChanges._toJson()).toEqual({\n      statementAdditions: [\n        {\n          effect: 'Allow',\n          resources: { not: false, values: ['*'] },\n          principals: { not: false, values: ['AWS:${MyIdentity}'] },\n          actions: { not: false, values: ['s3:DoThatThing'] },\n        },\n      ],\n    });\n  }\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "if policy is attached to multiple roles all are shown",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 59
            },
            "line": 89,
            "code": "test('if policy is attached to multiple roles all are shown', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyPolicy: policy({\n      Roles: [{ Ref: 'MyRole' }, { Ref: 'ThyRole' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 's3:DoThatThing',\n        Resource: '*',\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['*'] },\n        principals: { not: false, values: ['AWS:${MyRole}'] },\n        actions: { not: false, values: ['s3:DoThatThing'] },\n      },\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['*'] },\n        principals: { not: false, values: ['AWS:${ThyRole}'] },\n        actions: { not: false, values: ['s3:DoThatThing'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "correctly parses Lambda permissions",
            "suites": [],
            "updatePoint": {
                "line": 121,
                "column": 41
            },
            "line": 121,
            "code": "test('correctly parses Lambda permissions', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyPermission: resource('AWS::Lambda::Permission', {\n      Action: 'lambda:InvokeFunction',\n      FunctionName: { Ref: 'MyFunction' },\n      Principal: 's3.amazonaws.com',\n      SourceAccount: { Ref: 'AWS::AccountId' },\n      SourceArn: { 'Fn::GetAtt': ['MyBucketF68F3FF0', 'Arn'] },\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyFunction}'] },\n        principals: { not: false, values: ['Service:s3.amazonaws.com'] },\n        actions: { not: false, values: ['lambda:InvokeFunction'] },\n        condition: {\n          StringEquals: { 'AWS:SourceAccount': '${AWS::AccountId}' },\n          ArnLike: { 'AWS:SourceArn': '${MyBucketF68F3FF0.Arn}' },\n        },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "implicitly knows resource of (queue) resource policy even if * given",
            "suites": [],
            "updatePoint": {
                "line": 150,
                "column": 74
            },
            "line": 150,
            "code": "test('implicitly knows resource of (queue) resource policy even if * given', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "finds sole statement removals",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 35
            },
            "line": 177,
            "code": "test('finds sole statement removals', () => {\n  // WHEN\n  const diff = diffTemplate(template({\n    BucketPolicy: resource('AWS::S3::BucketPolicy', {\n      Bucket: { Ref: 'MyBucket' },\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 's3:PutObject',\n        Resource: '*',\n        Principal: { AWS: 'me' },\n      }),\n    }),\n  }), {});\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyBucket}'] },\n        principals: { not: false, values: ['AWS:me'] },\n        actions: { not: false, values: ['s3:PutObject'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "finds one of many statement removals",
            "suites": [],
            "updatePoint": {
                "line": 204,
                "column": 42
            },
            "line": 204,
            "code": "test('finds one of many statement removals', () => {\n  // WHEN\n  const diff = diffTemplate(\n    template({\n      BucketPolicy: resource('AWS::S3::BucketPolicy', {\n        Bucket: { Ref: 'MyBucket' },\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:PutObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }, {\n          Effect: 'Allow',\n          Action: 's3:LookAtObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }),\n      }),\n    }),\n    template({\n      BucketPolicy: resource('AWS::S3::BucketPolicy', {\n        Bucket: { Ref: 'MyBucket' },\n        PolicyDocument: poldoc({\n          Effect: 'Allow',\n          Action: 's3:LookAtObject',\n          Resource: '*',\n          Principal: { AWS: 'me' },\n        }),\n      }),\n    }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyBucket}'] },\n        principals: { not: false, values: ['AWS:me'] },\n        actions: { not: false, values: ['s3:PutObject'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "finds policy attachments",
            "suites": [],
            "updatePoint": {
                "line": 248,
                "column": 30
            },
            "line": 248,
            "code": "test('finds policy attachments', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    SomeRole: resource('AWS::IAM::Role', {\n      ManagedPolicyArns: ['arn:policy'],\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyAdditions: [\n      {\n        identityArn: '${SomeRole}',\n        managedPolicyArn: 'arn:policy',\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "finds policy removals",
            "suites": [],
            "updatePoint": {
                "line": 267,
                "column": 27
            },
            "line": 267,
            "code": "test('finds policy removals', () => {\n  // WHEN\n  const diff = diffTemplate(\n    template({\n      SomeRole: resource('AWS::IAM::Role', {\n        ManagedPolicyArns: ['arn:policy', 'arn:policy2'],\n      }),\n    }),\n    template({\n      SomeRole: resource('AWS::IAM::Role', {\n        ManagedPolicyArns: ['arn:policy2'],\n      }),\n    }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyRemovals: [\n      {\n        identityArn: '${SomeRole}',\n        managedPolicyArn: 'arn:policy',\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "queuepolicy queue change counts as removal+addition",
            "suites": [],
            "updatePoint": {
                "line": 292,
                "column": 57
            },
            "line": 292,
            "code": "test('queuepolicy queue change counts as removal+addition', () => {\n  // WHEN\n  const diff = diffTemplate(template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue1' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }), template({\n    QueuePolicy: resource('AWS::SQS::QueuePolicy', {\n      Queues: [{ Ref: 'MyQueue2' }],\n      PolicyDocument: poldoc({\n        Effect: 'Allow',\n        Action: 'sqs:SendMessage',\n        Resource: '*',\n        Principal: { Service: 'sns.amazonaws.com' },\n      }),\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue2}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n    statementRemovals: [\n      {\n        effect: 'Allow',\n        resources: { not: false, values: ['${MyQueue1}'] },\n        principals: { not: false, values: ['Service:sns.amazonaws.com'] },\n        actions: { not: false, values: ['sqs:SendMessage'] },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "supports Fn::If in the top-level property value of Role",
            "suites": [],
            "updatePoint": {
                "line": 337,
                "column": 61
            },
            "line": 337,
            "code": "test('supports Fn::If in the top-level property value of Role', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n      ManagedPolicyArns: {\n        'Fn::If': [\n          'SomeCondition',\n          ['then-managed-policy-arn'],\n          ['else-managed-policy-arn'],\n        ],\n      },\n    }),\n  }));\n\n  // THEN\n  expect(diff.iamChanges._toJson()).toEqual({\n    managedPolicyAdditions: [\n      {\n        identityArn: '${MyRole}',\n        managedPolicyArn: '{\"Fn::If\":[\"SomeCondition\",[\"then-managed-policy-arn\"],[\"else-managed-policy-arn\"]]}',\n      },\n    ],\n    statementAdditions: [\n      {\n        effect: 'Allow',\n        principals: { not: false, values: ['Service:lambda.amazonaws.com'] },\n        actions: { not: false, values: ['sts:AssumeRole'] },\n        resources: {\n          not: false,\n          values: ['${MyRole.Arn}'],\n        },\n      },\n    ],\n  });\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "supports Fn::If in the elements of an array-typed property of Role",
            "suites": [],
            "updatePoint": {
                "line": 378,
                "column": 72
            },
            "line": 378,
            "code": "test('supports Fn::If in the elements of an array-typed property of Role', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    MyRole: role({\n      AssumeRolePolicyDocument: poldoc({\n        Action: 'sts:AssumeRole',\n        Effect: 'Allow',\n        Principal: { Service: 'lambda.amazonaws.com' },\n      }),\n      Policies: [\n        {\n          'Fn::If': [\n            'SomeCondition',\n            {\n              PolicyName: 'S3',\n              PolicyDocument: poldoc({\n                Effect: 'Allow',\n                Action: 's3:GetObject',\n                Resource: '*',\n              }),\n            },\n            {\n              Ref: 'AWS::NoValue',\n            },\n          ],\n        },\n      ],\n    }),\n  }));\n\n  // THEN\n  const changedStatements = diff.iamChanges.summarizeStatements();\n\n  // there are 2 rows of changes\n  // (one for the AssumeRolePolicyDocument,\n  // one for the Policies),\n  // plus a row of headers\n  expect(changedStatements.length).toBe(3);\n\n  const changedPolicies = changedStatements[2];\n  const resourceColumn = 1, principalColumn = 4;\n\n  expect(changedPolicies[resourceColumn]).toContain('{\"Fn::If\":[\"SomeCondition\",{\"PolicyName\":\"S3\",\"PolicyDocument\":{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"s3:GetObject\",\"Resource\":\"*\"}]}}]}');\n  expect(changedPolicies[principalColumn]).toContain('AWS:${MyRole}');\n});",
            "file": "iam/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "can parse all positive fields",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 35
            },
            "line": 4,
            "code": "test('can parse all positive fields', () => {\n  const statement = new Statement({\n    Sid: 'Sid',\n    Effect: 'Allow',\n    Resource: ['resource'],\n    Action: ['action'],\n    Principal: [{ AWS: 'arn' }],\n    Condition: { StringEquals: { 'Amzn-This': 'That' } },\n  });\n\n  expect(statement.sid).toEqual('Sid');\n  expect(statement.effect).toEqual('Allow');\n  expect(statement.resources.values).toEqual(['resource']);\n  expect(statement.actions.values).toEqual(['action']);\n  expect(statement.principals.values).toEqual(['AWS:arn']);\n  expect(statement.condition).toEqual({ StringEquals: { 'Amzn-This': 'That' } });\n\n  expect(statement.resources.not).toBe(false);\n  expect(statement.actions.not).toBe(false);\n  expect(statement.principals.not).toBe(false);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "parses strings as singleton lists",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 39
            },
            "line": 26,
            "code": "test('parses strings as singleton lists', () => {\n  const statement = new Statement({\n    Resource: 'resource',\n  });\n\n  expect(statement.resources.values).toEqual(['resource']);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "correctly parses NotFields",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 32
            },
            "line": 34,
            "code": "test('correctly parses NotFields', () => {\n  const statement = new Statement({\n    NotResource: ['resource'],\n    NotAction: ['action'],\n    NotPrincipal: [{ AWS: 'arn' }],\n  });\n\n  expect(statement.resources.not).toBe(true);\n  expect(statement.actions.not).toBe(true);\n  expect(statement.principals.not).toBe(true);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "parse all LambdaPermission fields",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 39
            },
            "line": 46,
            "code": "test('parse all LambdaPermission fields', () => {\n  const statement = parseLambdaPermission({\n    Action: 'lambda:CallMeMaybe',\n    FunctionName: 'Function',\n    Principal: '*',\n    SourceAccount: '123456789012',\n    SourceArn: 'arn',\n  });\n\n  expect(statement.actions.values).toEqual(['lambda:CallMeMaybe']);\n  expect(statement.resources.values).toEqual(['Function']);\n  expect(statement.principals.values).toEqual(['*']);\n  expect(statement.condition).toEqual({\n    ArnLike: { 'AWS:SourceArn': 'arn' },\n    StringEquals: { 'AWS:SourceAccount': '123456789012' },\n  });\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "parse lambda eventsourcetoken",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 35
            },
            "line": 64,
            "code": "test('parse lambda eventsourcetoken', () => {\n  const statement = parseLambdaPermission({\n    Action: 'lambda:CallMeMaybe',\n    FunctionName: 'Function',\n    EventSourceToken: 'token',\n    Principal: '*',\n  });\n\n  expect(statement.condition).toEqual({\n    StringEquals: { 'lambda:EventSourceToken': 'token' },\n  });\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "stringify complex condition",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 33
            },
            "line": 77,
            "code": "test('stringify complex condition', () => {\n  // WHEN\n  const stringified = renderCondition({\n    StringEquals: { 'AWS:SourceAccount': '${AWS::AccountId}' },\n    ArnLike: { 'AWS:SourceArn': '${MyBucket.Arn}' },\n  }).split('\\n');\n\n  // THEN\n  expect(stringified).toEqual([\n    '\"StringEquals\": {',\n    '  \"AWS:SourceAccount\": \"${AWS::AccountId}\"',\n    '},',\n    '\"ArnLike\": {',\n    '  \"AWS:SourceArn\": \"${MyBucket.Arn}\"',\n    '}',\n  ]);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "an Allow statement with a NotPrincipal is negative",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 56
            },
            "line": 95,
            "code": "test('an Allow statement with a NotPrincipal is negative', () => {\n  // WHEN\n  const statement = new Statement({\n    Effect: 'Allow',\n    Resource: 'resource',\n    NotPrincipal: { AWS: 'me' },\n  });\n\n  // THEN\n  expect(statement.isNegativeStatement).toBe(true);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "a Deny statement with a NotPrincipal is positive",
            "suites": [],
            "updatePoint": {
                "line": 107,
                "column": 54
            },
            "line": 107,
            "code": "test('a Deny statement with a NotPrincipal is positive', () => {\n  // In effect, this is a roundabout way of saying only the given Principal\n  // should be allowed (\"everyone who's not me can't do this\").\n\n  // WHEN\n  const statement = new Statement({\n    Effect: 'Deny',\n    Resource: 'resource',\n    NotPrincipal: { AWS: 'me' },\n  });\n\n  // THEN\n  expect(statement.isNegativeStatement).toBe(false);\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "equality is reflexive",
            "suites": [],
            "updatePoint": {
                "line": 122,
                "column": 27
            },
            "line": 122,
            "code": "test('equality is reflexive', () => {\n  fc.assert(fc.property(\n    arbitraryStatement, (statement) => {\n      return new Statement(statement).equal(new Statement(statement));\n    },\n  ));\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "equality is symmetric",
            "suites": [],
            "updatePoint": {
                "line": 130,
                "column": 27
            },
            "line": 130,
            "code": "test('equality is symmetric', () => {\n  fc.assert(fc.property(\n    twoArbitraryStatements, (s) => {\n      const a = new Statement(s.statement1);\n      const b = new Statement(s.statement2);\n\n      fc.pre(a.equal(b));\n      return b.equal(a);\n    },\n  ));\n});",
            "file": "iam/statement.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "detect addition of all types of rules",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 43
            },
            "line": 4,
            "code": "test('detect addition of all types of rules', () => {\n  // WHEN\n  const diff = diffTemplate({}, template({\n    SG: resource('AWS::EC2::SecurityGroup', {\n      SecurityGroupIngress: [\n        {\n          CidrIp: '1.2.3.4/8',\n          FromPort: 80,\n          ToPort: 80,\n          IpProtocol: 'tcp',\n        },\n      ],\n      SecurityGroupEgress: [\n        {\n          DestinationSecurityGroupId: { 'Fn::GetAtt': ['ThatOtherGroup', 'GroupId'] },\n          FromPort: 80,\n          ToPort: 80,\n          IpProtocol: 'tcp',\n        },\n      ],\n    }),\n    InRule: resource('AWS::EC2::SecurityGroupIngress', {\n      GroupId: { 'Fn::GetAtt': ['SG', 'GroupId'] },\n      FromPort: -1,\n      ToPort: -1,\n      IpProtocol: 'icmp',\n      SourcePrefixListId: 'pl-1234',\n    }),\n    OutRule: resource('AWS::EC2::SecurityGroupEgress', {\n      GroupId: { 'Fn::GetAtt': ['SG', 'GroupId'] },\n      FromPort: -1,\n      ToPort: -1,\n      IpProtocol: 'udp',\n      CidrIp: '7.8.9.0/24',\n    }),\n  }));\n\n  // THEN\n  expect(diff.securityGroupChanges.toJson()).toEqual({\n    ingressRuleAdditions: [\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'tcp',\n        fromPort: 80,\n        toPort: 80,\n        peer: { kind: 'cidr-ip', ip: '1.2.3.4/8' },\n      },\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'icmp',\n        fromPort: -1,\n        toPort: -1,\n        peer: { kind: 'prefix-list', prefixListId: 'pl-1234' },\n      },\n    ],\n    egressRuleAdditions: [\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'tcp',\n        fromPort: 80,\n        toPort: 80,\n        peer: { kind: 'security-group', securityGroupId: '${ThatOtherGroup.GroupId}' },\n      },\n      {\n        groupId: '${SG.GroupId}',\n        ipProtocol: 'udp',\n        fromPort: -1,\n        toPort: -1,\n        peer: { kind: 'cidr-ip', ip: '7.8.9.0/24' },\n      },\n    ],\n  });\n});",
            "file": "network/detect-changes.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "can parse cidr-ip",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 23
            },
            "line": 4,
            "code": "test('can parse cidr-ip', () => {\n  const rule = new SecurityGroupRule({\n    GroupId: 'sg-1234',\n    IpProtocol: 'tcp',\n    FromPort: 10,\n    ToPort: 20,\n    CidrIp: '1.2.3.4/8',\n  });\n\n  expect(rule.groupId).toEqual('sg-1234');\n  expect(rule.ipProtocol).toEqual('tcp');\n  expect(rule.fromPort).toEqual(10);\n  expect(rule.toPort).toEqual(20);\n\n  const peer = rule.peer!;\n  if (peer.kind !== 'cidr-ip') { throw new Error('Fail'); }\n  expect(peer.ip).toEqual('1.2.3.4/8');\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "can parse cidr-ip 6",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 25
            },
            "line": 23,
            "code": "test('can parse cidr-ip 6', () => {\n  const rule = new SecurityGroupRule({\n    CidrIpv6: '::/0',\n  });\n\n  const peer = rule.peer!;\n  if (peer.kind !== 'cidr-ip') { throw new Error('Fail'); }\n  expect(peer.ip).toEqual('::/0');\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "can parse securityGroup",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 29
            },
            "line": 33,
            "code": "test('can parse securityGroup', () => {\n  for (const key of ['DestinationSecurityGroupId', 'SourceSecurityGroupId']) {\n    const rule = new SecurityGroupRule({\n      [key]: 'sg-1234',\n    });\n\n    const peer = rule.peer!;\n    if (peer.kind !== 'security-group') { throw new Error('Fail'); }\n    expect(peer.securityGroupId).toEqual('sg-1234');\n  }\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "can parse prefixlist",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 26
            },
            "line": 45,
            "code": "test('can parse prefixlist', () => {\n  for (const key of ['DestinationPrefixListId', 'SourcePrefixListId']) {\n    const rule = new SecurityGroupRule({\n      [key]: 'pl-1',\n    });\n\n    const peer = rule.peer!;\n    if (peer.kind !== 'prefix-list') { throw new Error('Fail'); }\n    expect(peer.prefixListId).toEqual('pl-1');\n  }\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "equality is reflexive",
            "suites": [],
            "updatePoint": {
                "line": 57,
                "column": 27
            },
            "line": 57,
            "code": "test('equality is reflexive', () => {\n  fc.assert(fc.property(\n    arbitraryRule, (statement) => {\n      return new SecurityGroupRule(statement).equal(new SecurityGroupRule(statement));\n    },\n  ));\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "equality is symmetric",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 27
            },
            "line": 65,
            "code": "test('equality is symmetric', () => {\n  fc.assert(fc.property(\n    twoArbitraryRules, (s) => {\n      const a = new SecurityGroupRule(s.rule1);\n      const b = new SecurityGroupRule(s.rule2);\n\n      fc.pre(a.equal(b));\n      return b.equal(a);\n    },\n  ));\n});",
            "file": "network/rule.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "resolves Ref",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 18
            },
            "line": 3,
            "code": "test('resolves Ref', () =>\n  expect(renderIntrinsics({ Ref: 'SomeLogicalId' })).toEqual('${SomeLogicalId}'));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "resolves Fn::GetAtt",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 25
            },
            "line": 6,
            "code": "test('resolves Fn::GetAtt', () =>\n  expect(renderIntrinsics({ 'Fn::GetAtt': ['SomeLogicalId', 'Attribute'] })).toEqual('${SomeLogicalId.Attribute}'));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "resolves Fn::Join",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 23
            },
            "line": 9,
            "code": "test('resolves Fn::Join', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', ['a', 'b', 'c']] })).toEqual('a/b/c'));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "removes AWS::NoValue from Fn::Join",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 40
            },
            "line": 12,
            "code": "test('removes AWS::NoValue from Fn::Join', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', ['a', { Ref: 'AWS::NoValue' }, 'b', 'c']] })).toEqual('a/b/c'));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "does not resolve Fn::Join if the second argument is not a list literal",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 76
            },
            "line": 15,
            "code": "test('does not resolve Fn::Join if the second argument is not a list literal', () =>\n  expect(renderIntrinsics({ 'Fn::Join': ['/', { Ref: 'ListParameter' }] })).toEqual('{\"Fn::Join\":[\"/\",\"${ListParameter}\"]}'));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "deep resolves intrinsics in object",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 40
            },
            "line": 18,
            "code": "test('deep resolves intrinsics in object', () =>\n  expect(renderIntrinsics({\n    Deeper1: { Ref: 'SomeLogicalId' },\n    Deeper2: 'Do not replace',\n  })).toEqual({\n    Deeper1: '${SomeLogicalId}',\n    Deeper2: 'Do not replace',\n  }));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "deep resolves intrinsics in array",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 39
            },
            "line": 27,
            "code": "test('deep resolves intrinsics in array', () =>\n  expect(renderIntrinsics([\n    { Ref: 'SomeLogicalId' },\n    'Do not replace',\n  ])).toEqual([\n    '${SomeLogicalId}',\n    'Do not replace',\n  ]));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "removes NoValue from object",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 33
            },
            "line": 36,
            "code": "test('removes NoValue from object', () =>\n  expect(renderIntrinsics({\n    Deeper1: { Ref: 'SomeLogicalId' },\n    Deeper2: { Ref: 'AWS::NoValue' },\n  })).toEqual({\n    Deeper1: '${SomeLogicalId}',\n  }));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "removes NoValue from array",
            "suites": [],
            "updatePoint": {
                "line": 44,
                "column": 32
            },
            "line": 44,
            "code": "test('removes NoValue from array', () =>\n  expect(renderIntrinsics([\n    { Ref: 'SomeLogicalId' },\n    { Ref: 'AWS::NoValue' },\n  ])).toEqual([\n    '${SomeLogicalId}',\n  ]));",
            "file": "render-intrinsics.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cloudformation-diff/test"
        },
        {
            "name": "cloud assembly builder",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 28
            },
            "line": 7,
            "code": "test('cloud assembly builder', () => {\n  // GIVEN\n  const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cloud-assembly-builder-tests'));\n  const session = new cxapi.CloudAssemblyBuilder(outdir);\n  const templateFile = 'foo.template.json';\n\n  // WHEN\n  session.addArtifact('my-first-artifact', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://1222344/us-east-1',\n    dependencies: ['minimal-artifact'],\n    metadata: {\n      foo: [{ data: '123', type: 'foo', trace: [] }],\n    },\n    properties: {\n      templateFile,\n      parameters: {\n        prop1: '1234',\n        prop2: '555',\n      },\n    },\n  });\n\n  session.addArtifact('tree-artifact', {\n    type: cxschema.ArtifactType.CDK_TREE,\n    properties: {\n      file: 'foo.tree.json',\n    },\n  });\n\n  session.addMissing({\n    key: 'foo',\n    provider: cxschema.ContextProvider.VPC_PROVIDER,\n    props: {\n      account: '1234',\n      region: 'us-east-1',\n      filter: {\n        a: 'a',\n      },\n    },\n  });\n\n  session.addArtifact('minimal-artifact', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://111/helo-world',\n    properties: {\n      templateFile,\n    },\n  });\n\n  fs.writeFileSync(path.join(session.outdir, templateFile), JSON.stringify({\n    Resources: {\n      MyTopic: {\n        Type: 'AWS::S3::Topic',\n      },\n    },\n  }));\n\n  const assembly = session.buildAssembly();\n  const manifest = assembly.manifest;\n\n  // THEN\n  // verify the manifest looks right\n  expect(manifest).toStrictEqual({\n    version: cxschema.Manifest.version(),\n    missing: [\n      {\n        key: 'foo',\n        provider: cxschema.ContextProvider.VPC_PROVIDER,\n        props: {\n          account: '1234',\n          region: 'us-east-1',\n          filter: {\n            a: 'a',\n          },\n        },\n      },\n    ],\n    artifacts: {\n      'tree-artifact': {\n        type: cxschema.ArtifactType.CDK_TREE,\n        properties: {\n          file: 'foo.tree.json',\n        },\n      },\n      'my-first-artifact': {\n        type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n        environment: 'aws://1222344/us-east-1',\n        dependencies: ['minimal-artifact'],\n        metadata: { foo: [{ data: '123', type: 'foo', trace: [] }] },\n        properties: {\n          templateFile: 'foo.template.json',\n          parameters: {\n            prop1: '1234',\n            prop2: '555',\n          },\n        },\n      },\n      'minimal-artifact': {\n        type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n        environment: 'aws://111/helo-world',\n        properties: { templateFile: 'foo.template.json' },\n      },\n    },\n  });\n\n  // verify we have a template file\n  expect(assembly.getStackByName('minimal-artifact').template).toStrictEqual({\n    Resources: {\n      MyTopic: {\n        Type: 'AWS::S3::Topic',\n      },\n    },\n  });\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "outdir must be a directory",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 32
            },
            "line": 123,
            "code": "test('outdir must be a directory', () => {\n  expect(() => new cxapi.CloudAssemblyBuilder(__filename)).toThrow('must be a directory');\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "outdir defaults to a temporary directory",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 46
            },
            "line": 127,
            "code": "test('outdir defaults to a temporary directory', () => {\n  const assembly = new cxapi.CloudAssemblyBuilder();\n  const realTmpDir = fs.realpathSync(os.tmpdir());\n  expect(assembly.outdir).toMatch(new RegExp(`^${path.join(realTmpDir, 'cdk.out')}`));\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "duplicate missing values with the same key are only reported once",
            "suites": [],
            "updatePoint": {
                "line": 133,
                "column": 71
            },
            "line": 133,
            "code": "test('duplicate missing values with the same key are only reported once', () => {\n  const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cloud-assembly-builder-tests'));\n  const session = new cxapi.CloudAssemblyBuilder(outdir);\n\n  const props: cxschema.ContextQueryProperties = {\n    account: '1234',\n    region: 'asdf',\n    filter: { a: 'a' },\n  };\n\n  session.addMissing({ key: 'foo', provider: cxschema.ContextProvider.VPC_PROVIDER, props });\n  session.addMissing({ key: 'foo', provider: cxschema.ContextProvider.VPC_PROVIDER, props });\n\n  const assembly = session.buildAssembly();\n\n  expect(assembly.manifest.missing!.length).toEqual(1);\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "write and read nested cloud assembly artifact",
            "suites": [],
            "updatePoint": {
                "line": 151,
                "column": 51
            },
            "line": 151,
            "code": "test('write and read nested cloud assembly artifact', () => {\n  // GIVEN\n  const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cloud-assembly-builder-tests'));\n  const session = new cxapi.CloudAssemblyBuilder(outdir);\n\n  const innerAsmDir = path.join(outdir, 'hello');\n  new cxapi.CloudAssemblyBuilder(innerAsmDir).buildAssembly();\n\n  // WHEN\n  session.addArtifact('Assembly', {\n    type: cxschema.ArtifactType.NESTED_CLOUD_ASSEMBLY,\n    properties: {\n      directoryName: 'hello',\n    } as cxschema.NestedCloudAssemblyProperties,\n  });\n  const asm = session.buildAssembly();\n\n  // THEN\n  const art = asm.tryGetArtifact('Assembly') as cxapi.NestedCloudAssemblyArtifact | undefined;\n  expect(art).toBeInstanceOf(cxapi.NestedCloudAssemblyArtifact);\n  expect(art?.fullPath).toEqual(path.join(outdir, 'hello'));\n\n  const nested = art?.nestedAssembly;\n  expect(nested?.artifacts.length).toEqual(0);\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "missing values are reported to top-level asm",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 50
            },
            "line": 177,
            "code": "test('missing values are reported to top-level asm', () => {\n  // GIVEN\n  const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cloud-assembly-builder-tests'));\n  const session = new cxapi.CloudAssemblyBuilder(outdir);\n\n  const innerAsm = session.createNestedAssembly('hello', 'hello');\n\n  // WHEN\n  const props: cxschema.ContextQueryProperties = {\n    account: '1234',\n    region: 'asdf',\n    filter: { a: 'a' },\n  };\n\n  innerAsm.addMissing({ key: 'foo', provider: cxschema.ContextProvider.VPC_PROVIDER, props });\n\n  // THEN\n  const assembly = session.buildAssembly();\n\n  expect(assembly.manifest.missing?.length).toEqual(1);\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "artifcats are written in topological order",
            "suites": [],
            "updatePoint": {
                "line": 199,
                "column": 48
            },
            "line": 199,
            "code": "test('artifcats are written in topological order', () => {\n  // GIVEN\n  const outdir = fs.mkdtempSync(path.join(os.tmpdir(), 'cloud-assembly-builder-tests'));\n  const session = new cxapi.CloudAssemblyBuilder(outdir);\n  const templateFile = 'foo.template.json';\n\n  const innerAsmDir = path.join(outdir, 'hello');\n  new cxapi.CloudAssemblyBuilder(innerAsmDir).buildAssembly();\n\n  // WHEN\n\n  // Create the following dependency order:\n  // A ->\n  //      C -> D\n  // B ->\n  session.addArtifact('artifact-D', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://1222344/us-east-1',\n    dependencies: ['artifact-C'],\n    properties: {\n      templateFile,\n    },\n  });\n\n  session.addArtifact('artifact-C', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://1222344/us-east-1',\n    dependencies: ['artifact-B', 'artifact-A'],\n    properties: {\n      templateFile,\n    },\n  });\n\n  session.addArtifact('artifact-B', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://1222344/us-east-1',\n    properties: {\n      templateFile,\n    },\n  });\n\n  session.addArtifact('artifact-A', {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: 'aws://1222344/us-east-1',\n    properties: {\n      templateFile,\n    },\n  });\n\n  const asm = session.buildAssembly();\n  const artifactsIds = asm.artifacts.map(a => a.id);\n\n  // THEN\n  expect(artifactsIds.indexOf('artifact-A')).toBeLessThan(artifactsIds.indexOf('artifact-C'));\n  expect(artifactsIds.indexOf('artifact-B')).toBeLessThan(artifactsIds.indexOf('artifact-C'));\n  expect(artifactsIds.indexOf('artifact-C')).toBeLessThan(artifactsIds.indexOf('artifact-D'));\n});",
            "file": "cloud-assembly-builder.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "empty assembly",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 20
            },
            "line": 7,
            "code": "test('empty assembly', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'empty'));\n  expect(assembly.artifacts).toEqual([]);\n  expect(assembly.runtime).toEqual({ libraries: { } });\n  expect(assembly.stacks).toEqual([]);\n  expect(assembly.version).toEqual('0.0.0');\n  expect(assembly.manifest).toMatchSnapshot();\n  expect(assembly.tree()).toBeUndefined();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with a single cloudformation stack and tree metadata",
            "suites": [],
            "updatePoint": {
                "line": 17,
                "column": 67
            },
            "line": 17,
            "code": "test('assembly with a single cloudformation stack and tree metadata', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'single-stack'));\n  expect(assembly.artifacts).toHaveLength(2);\n  expect(assembly.stacks).toHaveLength(1);\n  expect(assembly.manifest.missing).toBeUndefined();\n  expect(assembly.runtime).toEqual({ libraries: { } });\n\n  const stack = assembly.stacks[0];\n  expect(stack.manifest).toMatchSnapshot();\n  expect(stack.assets).toHaveLength(0);\n  expect(stack.dependencies).toEqual([]);\n  expect(stack.environment).toEqual({ account: '37736633', region: 'us-region-1', name: 'aws://37736633/us-region-1' });\n  expect(stack.template).toEqual({ Resources: { MyBucket: { Type: 'AWS::S3::Bucket' } } });\n  expect(stack.messages).toEqual([]);\n  expect(stack.manifest.metadata).toEqual(undefined);\n  expect(stack.originalName).toEqual('MyStackName');\n  expect(stack.stackName).toEqual('MyStackName');\n  expect(stack.id).toEqual('MyStackName');\n\n  const treeArtifact = assembly.tree();\n  expect(treeArtifact).toBeDefined();\n  expect(treeArtifact!.file).toEqual('foo.tree.json');\n  expect(treeArtifact!.manifest).toMatchSnapshot();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with invalid tree metadata",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 41
            },
            "line": 42,
            "code": "test('assembly with invalid tree metadata', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'invalid-manifest-type-tree'));\n  expect(() => assembly.tree()).toThrow(/Multiple artifacts/);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with tree metadata having no file property specified",
            "suites": [],
            "updatePoint": {
                "line": 47,
                "column": 67
            },
            "line": 47,
            "code": "test('assembly with tree metadata having no file property specified', () => {\n  expect(() => new CloudAssembly(path.join(FIXTURES, 'tree-no-file-property'))).toThrow(/Invalid assembly manifest/);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with cloudformation artifact having no environment property specified",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 84
            },
            "line": 51,
            "code": "test('assembly with cloudformation artifact having no environment property specified', () => {\n  expect(() => new CloudAssembly(path.join(FIXTURES, 'invalid-manifest-type-cloudformation'))).toThrow(/Invalid CloudFormation stack artifact/);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with missing context",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 35
            },
            "line": 55,
            "code": "test('assembly with missing context', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'missing-context'));\n  expect(assembly.manifest.missing).toMatchSnapshot();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assembly with multiple stacks",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 35
            },
            "line": 60,
            "code": "test('assembly with multiple stacks', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'multiple-stacks'));\n  expect(assembly.stacks).toHaveLength(2);\n  expect(assembly.artifacts).toHaveLength(2);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "fails for invalid environment format",
            "suites": [],
            "updatePoint": {
                "line": 66,
                "column": 42
            },
            "line": 66,
            "code": "test('fails for invalid environment format', () => {\n  expect(() => new CloudAssembly(path.join(FIXTURES, 'invalid-env-format')))\n    .toThrow('Unable to parse environment specification');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "fails if stack artifact does not have properties",
            "suites": [],
            "updatePoint": {
                "line": 71,
                "column": 54
            },
            "line": 71,
            "code": "test('fails if stack artifact does not have properties', () => {\n  expect(() => new CloudAssembly(path.join(FIXTURES, 'stack-without-params')))\n    .toThrow('Invalid CloudFormation stack artifact. Missing \\\"templateFile\\\" property in cloud assembly manifest');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "messages",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 14
            },
            "line": 76,
            "code": "test('messages', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'messages'));\n  expect(assembly.stacks[0].messages).toMatchSnapshot();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "assets",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 12
            },
            "line": 81,
            "code": "test('assets', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'assets'));\n  expect(assembly.stacks[0].assets).toMatchSnapshot();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "can-read-0.36.0",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 21
            },
            "line": 86,
            "code": "test('can-read-0.36.0', () => {\n  // WHEN\n  new CloudAssembly(path.join(FIXTURES, 'single-stack-0.36'));\n  // THEN: no exception\n  expect(true).toBeTruthy();\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "dependencies",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 18
            },
            "line": 93,
            "code": "test('dependencies', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'depends'));\n  expect(assembly.stacks).toHaveLength(4);\n\n  // expect stacks to be listed in topological order\n  expect(assembly.stacks.map(s => s.id)).toEqual(['StackA', 'StackD', 'StackC', 'StackB']);\n  expect(assembly.stacks[0].dependencies).toEqual([]);\n  expect(assembly.stacks[1].dependencies).toEqual([]);\n  expect(assembly.stacks[2].dependencies.map(x => x.id)).toEqual(['StackD']);\n  expect(assembly.stacks[3].dependencies.map(x => x.id)).toEqual(['StackC', 'StackD']);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "fails for invalid dependencies",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 36
            },
            "line": 105,
            "code": "test('fails for invalid dependencies', () => {\n  expect(() => new CloudAssembly(path.join(FIXTURES, 'invalid-depends'))).toThrow('Artifact StackC depends on non-existing artifact StackX');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "getStackByName fails if there are multiple stacks with the same name",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 74
            },
            "line": 120,
            "code": "test('getStackByName fails if there are multiple stacks with the same name', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'multiple-stacks-same-name'));\n  // eslint-disable-next-line max-len\n  expect(() => assembly.getStackByName('the-physical-name-of-the-stack')).toThrow(/There are multiple stacks with the stack name \\\"the-physical-name-of-the-stack\\\" \\(stack1\\,stack2\\)\\. Use \\\"getStackArtifact\\(id\\)\\\" instead/);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "getStackArtifact retrieves a stack by artifact id",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 55
            },
            "line": 126,
            "code": "test('getStackArtifact retrieves a stack by artifact id', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'multiple-stacks-same-name'));\n\n  expect(assembly.getStackArtifact('stack1').stackName).toEqual('the-physical-name-of-the-stack');\n  expect(assembly.getStackArtifact('stack2').stackName).toEqual('the-physical-name-of-the-stack');\n  expect(assembly.getStackArtifact('stack2').id).toEqual('stack2');\n  expect(assembly.getStackArtifact('stack1').id).toEqual('stack1');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "displayName shows hierarchical ID for nested stack without explicit stackName",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 83
            },
            "line": 135,
            "code": "test('displayName shows hierarchical ID for nested stack without explicit stackName', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'nested-stacks'));\n  const stackArtifact = assembly.getStackArtifact('topLevelStackNestedStackDAC87084');\n  expect(stackArtifact.hierarchicalId).toStrictEqual('topLevelStack/nestedStack');\n  expect(stackArtifact.displayName).toStrictEqual('topLevelStack/nestedStack');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "displayName shows hierarchical ID and stackName for nested stack with explicit stackName",
            "suites": [],
            "updatePoint": {
                "line": 142,
                "column": 94
            },
            "line": 142,
            "code": "test('displayName shows hierarchical ID and stackName for nested stack with explicit stackName', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'nested-stacks'));\n  const nestedStack = assembly.getStackArtifact('topLevelStackNestedStackWithStackName6D28EAEF');\n  expect(nestedStack.hierarchicalId).toStrictEqual('topLevelStack/nestedStackWithStackName');\n  expect(nestedStack.stackName).toStrictEqual('explicitStackName');\n  expect(nestedStack.displayName).toStrictEqual('topLevelStack/nestedStackWithStackName (explicitStackName)');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "displayName shows both hierarchical ID and stack name if needed",
            "suites": [],
            "updatePoint": {
                "line": 150,
                "column": 69
            },
            "line": 150,
            "code": "test('displayName shows both hierarchical ID and stack name if needed', () => {\n  const a1 = new CloudAssembly(path.join(FIXTURES, 'multiple-stacks-same-name'));\n  expect(a1.getStackArtifact('stack1').displayName).toStrictEqual('stack1 (the-physical-name-of-the-stack)');\n  expect(a1.getStackArtifact('stack2').displayName).toStrictEqual('stack2 (the-physical-name-of-the-stack)');\n\n  const a2 = new CloudAssembly(path.join(FIXTURES, 'single-stack'));\n  const art1 = a2.getStackArtifact('MyStackName');\n  const art2 = a2.getStackByName('MyStackName');\n\n  expect(art1).toBe(art2);\n  expect(art1.displayName).toBe('MyStackName');\n  expect(art1.id).toBe('MyStackName');\n  expect(art1.stackName).toBe('MyStackName');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "can read assembly with asset manifest",
            "suites": [],
            "updatePoint": {
                "line": 165,
                "column": 43
            },
            "line": 165,
            "code": "test('can read assembly with asset manifest', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'asset-manifest'));\n  expect(assembly.stacks).toHaveLength(1);\n  expect(assembly.artifacts).toHaveLength(2);\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "getStackArtifact retrieves a stack by artifact id from a nested assembly",
            "suites": [],
            "updatePoint": {
                "line": 171,
                "column": 78
            },
            "line": 171,
            "code": "test('getStackArtifact retrieves a stack by artifact id from a nested assembly', () => {\n  const assembly = new CloudAssembly(path.join(FIXTURES, 'nested-assemblies'));\n\n  expect(assembly.getStackArtifact('topLevelStack').stackName).toEqual('topLevelStack');\n  expect(assembly.getStackArtifact('stack1').stackName).toEqual('first-stack');\n  expect(assembly.getStackArtifact('stack2').stackName).toEqual('second-stack');\n  expect(assembly.getStackArtifact('topLevelStack').id).toEqual('topLevelStack');\n  expect(assembly.getStackArtifact('stack1').id).toEqual('stack1');\n  expect(assembly.getStackArtifact('stack2').id).toEqual('stack2');\n});",
            "file": "cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "format",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 12
            },
            "line": 3,
            "code": "test('format', () => {\n  expect(EnvironmentUtils.format('my-account', 'my-region')).toBe('aws://my-account/my-region');\n});",
            "file": "environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "parse",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 11
            },
            "line": 7,
            "code": "test('parse', () => {\n  expect(EnvironmentUtils.parse('aws://123456789/us-east-1')).toStrictEqual({\n    name: 'aws://123456789/us-east-1',\n    account: '123456789',\n    region: 'us-east-1',\n  });\n\n  // parser is not super strict to allow users to do some magical things if they want\n  expect(EnvironmentUtils.parse('aws://boom@voom.com/ok-x-x-123')).toStrictEqual({\n    name: 'aws://boom@voom.com/ok-x-x-123',\n    account: 'boom@voom.com',\n    region: 'ok-x-x-123',\n  });\n});",
            "file": "environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "parse failures",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 20
            },
            "line": 22,
            "code": "test('parse failures', () => {\n  expect(() => EnvironmentUtils.parse('boom')).toThrow('Unable to parse environment specification');\n  expect(() => EnvironmentUtils.parse('boom://boom/boom')).toThrow('Unable to parse environment specification');\n  expect(() => EnvironmentUtils.parse('boom://xx//xz/x/boom')).toThrow('Unable to parse environment specification');\n  expect(() => EnvironmentUtils.parse('aws:://998988383/fu-x-x')).toThrow('Unable to parse environment specification');\n});",
            "file": "environment.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "all future flags have defaults configured",
            "suites": [],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "test('all future flags have defaults configured', () => {\n  Object.keys(feats.FLAGS).forEach(flag => {\n    expect(typeof(feats.futureFlagDefault(flag))).toEqual('boolean');\n  });\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "futureFlagDefault returns false if non existent flag was given",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 68
            },
            "line": 12,
            "code": "test('futureFlagDefault returns false if non existent flag was given', () => {\n  expect(feats.futureFlagDefault('non-existent-flag')).toEqual(false);\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "feature flag defaults may not be changed anymore",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 54
            },
            "line": 16,
            "code": "test('feature flag defaults may not be changed anymore', () => {\n  // In principle, these flags were decided upon during the v2 alpha period, and they are now frozen\n  // and may not be changed anymore.\n  //\n  // One exception is allowed: to avoid a double negative in your flag name (`disableOldBehavior: true`).\n  //\n  // In that case, it is permitted to name the flag `oldBehavior`, add a new default set to `true`,\n  // and have the recommended value be `false`.\n  expect(feats.CURRENT_VERSION_FLAG_DEFAULTS).toEqual({\n    // V1->V2 defaults below here\n    [feats.APIGATEWAY_USAGEPLANKEY_ORDERINSENSITIVE_ID]: true,\n    [feats.ENABLE_STACK_NAME_DUPLICATES_CONTEXT]: true,\n    [feats.ENABLE_DIFF_NO_FAIL_CONTEXT]: true,\n    [feats.STACK_RELATIVE_EXPORTS_CONTEXT]: true,\n    [feats.NEW_STYLE_STACK_SYNTHESIS_CONTEXT]: true,\n    [feats.DOCKER_IGNORE_SUPPORT]: true,\n    [feats.SECRETS_MANAGER_PARSE_OWNED_SECRET_NAME]: true,\n    [feats.KMS_DEFAULT_KEY_POLICIES]: true,\n    [feats.S3_GRANT_WRITE_WITHOUT_ACL]: true,\n    [feats.ECS_REMOVE_DEFAULT_DESIRED_COUNT]: true,\n    [feats.RDS_LOWERCASE_DB_IDENTIFIER]: true,\n    [feats.EFS_DEFAULT_ENCRYPTION_AT_REST]: true,\n    [feats.LAMBDA_RECOGNIZE_VERSION_PROPS]: true,\n    [feats.CLOUDFRONT_DEFAULT_SECURITY_POLICY_TLS_V1_2_2021]: true,\n    // Add new disabling feature flags below this line\n    // ...\n\n  });\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "expired feature flags may not be changed anymore",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 54
            },
            "line": 46,
            "code": "test('expired feature flags may not be changed anymore', () => {\n  expect(feats.CURRENT_VERSION_EXPIRED_FLAGS).toEqual([\n    feats.DOCKER_IGNORE_SUPPORT,\n    feats.ECS_REMOVE_DEFAULT_DESIRED_COUNT,\n    feats.EFS_DEFAULT_ENCRYPTION_AT_REST,\n    feats.ENABLE_DIFF_NO_FAIL_CONTEXT,\n    feats.ENABLE_STACK_NAME_DUPLICATES_CONTEXT,\n    feats.KMS_DEFAULT_KEY_POLICIES,\n    feats.S3_GRANT_WRITE_WITHOUT_ACL,\n    feats.SECRETS_MANAGER_PARSE_OWNED_SECRET_NAME,\n  ].sort());\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "compareVersions(%p, %p) -> %p (and the reverse)",
            "suites": [],
            "line": 59,
            "code": "test.each([\n  ['1.2.3', '1.2.3', 0],\n  ['1.2.3', '1.2.4', -1],\n  ['1.2.3', '2.0.0', -1],\n  ['100.2.3', '2.0.0', 1],\n  ['V2NEXT', 'V2NEXT', 0],\n  ['1.0.0', 'V2NEXT', -1],\n  ['2.100.0', 'V2NEXT', -1],\n  ['3.100.0', 'V2NEXT', 1],\n])('compareVersions(%p, %p) -> %p (and the reverse)', (a, b, expected) => {\n  expect(compareVersions(a, b)).toEqual(expected);\n  expect(compareVersions(b, a)).toBeCloseTo(-expected, 10); // Gets around expect(-0).toEqual(0) failing... :x\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "for flag %p",
            "suites": [
                "introducedIn.v2 is either <=  or magic value \"\""
            ],
            "line": 76,
            "code": "  test.each(Object.keys(feats.FLAGS))('for flag %p', flag => {\n    const v2In = feats.FLAGS[flag].introducedIn.v2;\n    if (v2In === undefined || v2In === MAGIC_V2NEXT) {\n      return;\n    }\n\n    // If defined and not magic, it must be in the past w.r.t. the current v2 version\n    expect(compareVersions(v2In, currentv2)).not.toEqual(1);\n  });",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "features.ts should not contain a reference to the constant with the magic value",
            "suites": [
                "introducedIn.v2 is either <=  or magic value \"\""
            ],
            "updatePoint": {
                "line": 87,
                "column": 85
            },
            "line": 87,
            "code": "test('features.ts should not contain a reference to the constant with the magic value', () => {\n  // If it did, the above test would succeed but we would not be able to substitute the string at bump time\n  const featuresSourceFile = path.join(__dirname, '..', 'lib', 'features.ts');\n  expect(fs.readFileSync(featuresSourceFile, { encoding: 'utf-8' })).not.toContain('MAGIC_V2NEXT');\n});",
            "file": "features.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "complex placeholder substitution",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 38
            },
            "line": 3,
            "code": "test('complex placeholder substitution', async () => {\n  const replacer: IEnvironmentPlaceholderProvider = {\n    accountId: () => Promise.resolve('current_account'),\n    region: () => Promise.resolve('current_region'),\n    partition: () => Promise.resolve('current_partition'),\n  };\n\n  expect(await EnvironmentPlaceholders.replaceAsync({\n    destinations: {\n      theDestination: {\n        assumeRoleArn: 'arn:${AWS::Partition}:role-${AWS::AccountId}',\n        bucketName: 'some_bucket-${AWS::AccountId}-${AWS::Region}',\n        objectKey: 'some_key-${AWS::AccountId}-${AWS::Region}',\n      },\n    },\n  }, replacer)).toEqual({\n    destinations: {\n      theDestination: {\n        assumeRoleArn: 'arn:current_partition:role-current_account',\n        bucketName: 'some_bucket-current_account-current_region',\n        objectKey: 'some_key-current_account-current_region',\n      },\n    },\n  });\n});",
            "file": "placeholders.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "sync placeholder substitution",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 35
            },
            "line": 29,
            "code": "test('sync placeholder substitution', () => {\n  const replacer: EnvironmentPlaceholderValues = {\n    accountId: 'current_account',\n    region: 'current_region',\n    partition: 'current_partition',\n  };\n\n  expect(EnvironmentPlaceholders.replace({\n    destinations: {\n      theDestination: {\n        assumeRoleArn: 'arn:${AWS::Partition}:role-${AWS::AccountId}',\n        bucketName: 'some_bucket-${AWS::AccountId}-${AWS::Region}',\n        objectKey: 'some_key-${AWS::AccountId}-${AWS::Region}',\n      },\n    },\n  }, replacer)).toEqual({\n    destinations: {\n      theDestination: {\n        assumeRoleArn: 'arn:current_partition:role-current_account',\n        bucketName: 'some_bucket-current_account-current_region',\n        objectKey: 'some_key-current_account-current_region',\n      },\n    },\n  });\n\n});",
            "file": "placeholders.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "read tags from artifact properties",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 40
            },
            "line": 24,
            "code": "test('read tags from artifact properties', () => {\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n    properties: {\n      ...stackBase.properties,\n      tags: {\n        foo: 'bar',\n      },\n    },\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  expect(assembly.getStackByName('Stack').tags).toEqual({ foo: 'bar' });\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "stack tags get uppercased when written to Cloud Assembly",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 62
            },
            "line": 43,
            "code": "test('stack tags get uppercased when written to Cloud Assembly', () => {\n  // Backwards compatibility test\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n    metadata: {\n      '/Stack': [\n        {\n          type: 'aws:cdk:stack-tags',\n          data: [{ key: 'foo', value: 'bar' }],\n        },\n      ],\n    },\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  const manifestStructure = JSON.parse(fs.readFileSync(path.join(assembly.directory, 'manifest.json'), { encoding: 'utf-8' }));\n  expect(manifestStructure.artifacts.Stack.metadata['/Stack']).toEqual([\n    {\n      type: 'aws:cdk:stack-tags',\n      data: [\n        {\n          // Note: uppercase due to historical accident\n          Key: 'foo',\n          Value: 'bar',\n        },\n      ],\n    },\n  ]);\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "already uppercased stack tags get left alone",
            "suites": [],
            "updatePoint": {
                "line": 77,
                "column": 50
            },
            "line": 77,
            "code": "test('already uppercased stack tags get left alone', () => {\n  // Backwards compatibility test\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n    metadata: {\n      '/Stack': [\n        {\n          type: 'aws:cdk:stack-tags',\n          data: [{ Key: 'foo', Value: 'bar' } as any],\n        },\n      ],\n    },\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  const manifestStructure = JSON.parse(fs.readFileSync(path.join(assembly.directory, 'manifest.json'), { encoding: 'utf-8' }));\n  expect(manifestStructure.artifacts.Stack.metadata['/Stack']).toEqual([\n    {\n      type: 'aws:cdk:stack-tags',\n      data: [\n        {\n          // Note: uppercase due to historical accident\n          Key: 'foo',\n          Value: 'bar',\n        },\n      ],\n    },\n  ]);\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "read tags from stack metadata",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 35
            },
            "line": 112,
            "code": "test('read tags from stack metadata', () => {\n  // Backwards compatibility test\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n    metadata: {\n      '/Stack': [\n        {\n          type: 'aws:cdk:stack-tags',\n          data: [{ key: 'foo', value: 'bar' }],\n        },\n      ],\n    },\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  expect(assembly.getStackByName('Stack').tags).toEqual({ foo: 'bar' });\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "user friendly id is the assembly display name",
            "suites": [],
            "updatePoint": {
                "line": 134,
                "column": 51
            },
            "line": 134,
            "code": "test('user friendly id is the assembly display name', () => {\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n    displayName: 'some/path/to/the/stack',\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  expect(assembly.getStackByName('Stack').hierarchicalId).toEqual('some/path/to/the/stack');\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "user friendly id is the id itself if no display name is given",
            "suites": [],
            "updatePoint": {
                "line": 148,
                "column": 67
            },
            "line": 148,
            "code": "test('user friendly id is the id itself if no display name is given', () => {\n  // GIVEN\n  builder.addArtifact('Stack', {\n    ...stackBase,\n  });\n\n  // WHEN\n  const assembly = builder.buildAssembly();\n\n  // THEN\n  expect(assembly.getStackByName('Stack').hierarchicalId).toEqual('Stack');\n});",
            "file": "stack-artifact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/cx-api/test"
        },
        {
            "name": "creates a CFN WaitConditionHandle resource",
            "suites": [
                "Example Resource",
                "created with default properties"
            ],
            "updatePoint": {
                "line": 45,
                "column": 52
            },
            "line": 45,
            "code": "    test('creates a CFN WaitConditionHandle resource', () => {\n      // you can simply assert that a resource of a given type\n      // was generated in the resulting template\n      Template.fromStack(stack).resourceCountIs('AWS::CloudFormation::WaitConditionHandle', 1);\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "with count = 0 and timeout = 10",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 52,
                "column": 43
            },
            "line": 52,
            "code": "      test('with count = 0 and timeout = 10', () => {\n        // you can also assert the properties of the resulting resource\n        Template.fromStack(stack).hasResourceProperties('AWS::CloudFormation::WaitCondition', {\n          'Count': 0,\n          'Timeout': '10',\n          'Handle': {\n            // Don't be afraid of using the generated logical IDs in your tests!\n            // While they look random, they are actually only dependent on the\n            // path constructs have in the tree.\n            // Since changing logical IDs as the library changes actually causes\n            // problems for their customers (their CloudFormation resources will be replaced),\n            // it's good for the unit tests to verify that the logical IDs are stable.\n            'Ref': 'ExampleResourceWaitConditionHandle9C53A8D3',\n          },\n          // this is how you can check a given property is _not_ set\n          'RandomProperty': Match.absent(),\n        });\n      });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "with retention policy = Retain",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 71,
                "column": 42
            },
            "line": 71,
            "code": "      test('with retention policy = Retain', () => {\n        // hasResource asserts _all_ properties of a resource,\n        // while hasResourceProperties only those within the 'Property' block\n        Template.fromStack(stack).hasResource('AWS::CloudFormation::WaitCondition', {\n          'DeletionPolicy': 'Retain',\n          'UpdateReplacePolicy': 'Retain',\n        // by default, haveResource and haveResourceLike only assert the properties of a resource -\n        // here's how you make them look at the entire resource definition\n        });\n      });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "returns true from addToResourcePolicy",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 83,
                "column": 47
            },
            "line": 83,
            "code": "    test('returns true from addToResourcePolicy', () => {\n      const result = exampleResource.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['kms:*'],\n        resources: ['*'],\n      }));\n\n      expect(result).toBe(true);\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "correctly adds s3:Get* permissions when grantRead() is called",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 92,
                "column": 71
            },
            "line": 92,
            "code": "    test('correctly adds s3:Get* permissions when grantRead() is called', () => {\n      const role = new iam.Role(stack, 'Role', {\n        assumedBy: new iam.AnyPrincipal(),\n      });\n\n      exampleResource.grantRead(role);\n\n      Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {\n        'PolicyDocument': {\n          'Statement': [\n            {\n              'Action': 's3:Get*',\n              'Effect': 'Allow',\n              'Resource': {\n                'Fn::Join': ['', [\n                  'arn:',\n                  { 'Ref': 'AWS::Partition' },\n                  ':cloudformation:',\n                  { 'Ref': 'AWS::Region' },\n                  ':',\n                  { 'Ref': 'AWS::AccountId' },\n                  ':wait-condition/',\n                  { 'Ref': 'ExampleResourceAC53F4AE' },\n                ]],\n              },\n            },\n          ],\n        },\n      });\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "onEvent adds an Event Rule",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 123,
                "column": 36
            },
            "line": 123,
            "code": "    test('onEvent adds an Event Rule', () => {\n      exampleResource.onEvent('MyEvent');\n\n      Template.fromStack(stack).hasResourceProperties('AWS::Events::Rule', {\n        EventPattern: {\n          detail: {\n            'example-resource-name': [EXAMPLE_RESOURCE_NAME],\n          },\n        },\n      });\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "metricCount returns a metric with correct dimensions",
            "suites": [
                "Example Resource",
                "created with default properties",
                "creates a CFN WaitCondition resource"
            ],
            "updatePoint": {
                "line": 135,
                "column": 62
            },
            "line": 135,
            "code": "    test('metricCount returns a metric with correct dimensions', () => {\n      const countMetric = exampleResource.metricCount();\n\n      new cloudwatch.Alarm(stack, 'Alarm', {\n        metric: countMetric,\n        threshold: 10,\n        evaluationPeriods: 2,\n      });\n\n      Template.fromStack(stack).hasResourceProperties('AWS::CloudWatch::Alarm', {\n        EvaluationPeriods: 2,\n        Dimensions: [\n          {\n            Name: 'ExampleResource',\n            Value: EXAMPLE_RESOURCE_NAME,\n          },\n        ],\n        MetricName: 'Count',\n        Namespace: 'AWS/ExampleResource',\n      });\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "allows manipulating its connections object",
            "suites": [
                "Example Resource",
                "created with a VPC"
            ],
            "updatePoint": {
                "line": 169,
                "column": 52
            },
            "line": 169,
            "code": "    test('allows manipulating its connections object', () => {\n      exampleResource.connections.allowToAnyIpv4(ec2.Port.allTcp());\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "correctly fills out the subnetIds property of the created VPC endpoint",
            "suites": [
                "Example Resource",
                "created with a VPC"
            ],
            "updatePoint": {
                "line": 173,
                "column": 80
            },
            "line": 173,
            "code": "    test('correctly fills out the subnetIds property of the created VPC endpoint', () => {\n      Template.fromStack(stack).hasResourceProperties('AWS::EC2::VPCEndpoint', {\n        'SubnetIds': [\n          { 'Ref': 'VpcPrivateSubnet1Subnet536B997A' },\n          { 'Ref': 'VpcPrivateSubnet2Subnet3788AAA1' },\n        ],\n      });\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "throws when accessing connections",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 191,
                "column": 43
            },
            "line": 191,
            "code": "    test('throws when accessing connections', () => {\n      expect(() => exampleResource.connections).toThrow();\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "has the same name as it was imported with",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 195,
                "column": 51
            },
            "line": 195,
            "code": "    test('has the same name as it was imported with', () => {\n      expect(exampleResource.exampleResourceName).toEqual('my-example-resource-name');\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "renders the correct ARN for Example Resource",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 199,
                "column": 54
            },
            "line": 199,
            "code": "    test('renders the correct ARN for Example Resource', () => {\n      // We can't simply compare the value we get from exampleResource.exampleResourceArn,\n      // as it will contain unresolved late-bound values\n      // (what we in the CDK call Tokens).\n      // So, use a utility method on Stack that allows you to resolve those Tokens\n      // into their correct values.\n      const arn = stack.resolve(exampleResource.exampleResourceArn);\n      expect(arn).toEqual({\n        'Fn::Join': ['', [\n          'arn:',\n          { 'Ref': 'AWS::Partition' },\n          ':cloudformation:',\n          { 'Ref': 'AWS::Region' },\n          ':',\n          { 'Ref': 'AWS::AccountId' },\n          ':wait-condition/my-example-resource-name',\n        ]],\n      });\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "returns false from addToResourcePolicy",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 219,
                "column": 48
            },
            "line": 219,
            "code": "    test('returns false from addToResourcePolicy', () => {\n      const result = exampleResource.addToRolePolicy(new iam.PolicyStatement({\n        actions: ['kms:*'],\n        resources: ['*'],\n      }));\n\n      expect(result).toEqual(false);\n    });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "cannot be created with a physical name containing illegal characters",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 229,
                "column": 76
            },
            "line": 229,
            "code": "  test('cannot be created with a physical name containing illegal characters', () => {\n    // this is how we write tests that expect an exception to be thrown\n    expect(() => {\n      new er.ExampleResource(stack, 'ExampleResource', {\n        waitConditionHandleName: 'a-1234',\n      });\n    // it's not enough to know an exception was thrown -\n    // we have to verify that its message is what we expected\n    }).toThrow(/waitConditionHandleName must be non-empty and contain only letters and underscores, got: 'a-1234'/);\n  });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "does not fail validation if the physical name is a late-bound value",
            "suites": [
                "Example Resource",
                "imported by name"
            ],
            "updatePoint": {
                "line": 240,
                "column": 75
            },
            "line": 240,
            "code": "  test('does not fail validation if the physical name is a late-bound value', () => {\n    const parameter = new core.CfnParameter(stack, 'Parameter');\n\n    // no assertion necessary - the lack of an exception being thrown is all we need in this case\n    new er.ExampleResource(stack, 'ExampleResource', {\n      waitConditionHandleName: parameter.valueAsString,\n    });\n  });",
            "file": "example-resource.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/example-construct-library/test"
        },
        {
            "name": "",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 9,
                "column": 31
            },
            "line": 9,
            "code": "      test(`${service}${suffix}`, () => {\n        expect(Default.servicePrincipal(`${service}${suffix}`, region, urlSuffix)).toBe(`${service}.${region}.amazonaws.com`);\n      });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 14,
                "column": 31
            },
            "line": 14,
            "code": "      test(`${service}${suffix}`, () => {\n        expect(Default.servicePrincipal(`${service}${suffix}`, region, urlSuffix)).toBe(`${service}.${region}.${urlSuffix}`);\n      });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 20,
                "column": 31
            },
            "line": 20,
            "code": "      test(`${service}${suffix}`, () => {\n        expect(Default.servicePrincipal(`${service}${suffix}`, region, urlSuffix)).toBe(`${service}.amazonaws.com`);\n      });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 26,
                "column": 31
            },
            "line": 26,
            "code": "      test(`${service}${suffix}`, () => {\n        expect(Default.servicePrincipal(`${service}${suffix}`, region, urlSuffix)).toBe(`${service}.amazonaws.com`);\n      });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "with an \"exotic\" DNS suffix (.local)",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 33,
                "column": 44
            },
            "line": 33,
            "code": "  test('with an \"exotic\" DNS suffix (.local)', () => {\n    expect(Default.servicePrincipal('foo-service.local', region, urlSuffix)).toBe('foo-service.local');\n  });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "Exceptions: states in us-iso-east-1",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 37,
                "column": 43
            },
            "line": 37,
            "code": "  test('Exceptions: states in us-iso-east-1', () => {\n    expect(Default.servicePrincipal('states.amazonaws.com', 'us-iso-east-1', 'c2s.ic.gov')).toBe('states.amazonaws.com');\n  });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "Exceptions: states in us-isob-east-1",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 41,
                "column": 44
            },
            "line": 41,
            "code": "  test('Exceptions: states in us-isob-east-1', () => {\n    expect(Default.servicePrincipal('states.amazonaws.com', 'us-isob-east-1', 'sc2s.sgov.gov')).toBe('states.amazonaws.com');\n  });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "Exceptions: .amazonaws.com is us-iso-east-1",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 46,
                "column": 63
            },
            "line": 46,
            "code": "    test(`Exceptions: ${service}.amazonaws.com is us-iso-east-1`, () => {\n      expect(Default.servicePrincipal(`${service}.amazonaws.com`, 'us-iso-east-1', 'c2s.ic.gov')).toBe(`${service}.c2s.ic.gov`);\n    });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "Exceptions: codedeploy in ",
            "suites": [
                "servicePrincipal"
            ],
            "updatePoint": {
                "line": 52,
                "column": 47
            },
            "line": 52,
            "code": "    test(`Exceptions: codedeploy in ${cnRegion}`, () => {\n      expect(Default.servicePrincipal('codedeploy', cnRegion, 'amazonaws.com.cn')).toBe(`codedeploy.${cnRegion}.amazonaws.com.cn`);\n    });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "ssm",
            "suites": [
                "spot-check some service principals"
            ],
            "updatePoint": {
                "line": 60,
                "column": 11
            },
            "line": 60,
            "code": "  test('ssm', () => {\n    // SSM has advertised in its documentation that it is regional after a certain point, but that\n    // documentation only applies to SSM Inventory, not SSM Automation. Plus, there is no need for\n    // a different service principal, as all accounts are (at least currently) included in the global\n    // one.\n    expectServicePrincipals('ssm.amazonaws.com', {\n      'us-east-1': 'ssm.amazonaws.com',\n      'eu-north-1': 'ssm.amazonaws.com',\n      'ap-east-1': 'ssm.amazonaws.com',\n      'eu-south-1': 'ssm.amazonaws.com',\n    });\n  });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "EMR",
            "suites": [
                "spot-check some service principals"
            ],
            "updatePoint": {
                "line": 73,
                "column": 11
            },
            "line": 73,
            "code": "  test('EMR', () => {\n    expectServicePrincipals('elasticmapreduce.amazonaws.com', {\n      'us-east-1': 'elasticmapreduce.amazonaws.com',\n      'cn-north-1': 'elasticmapreduce.EXTENSION', // amazonaws.com.cn in China\n      'us-iso-east-1': 'elasticmapreduce.amazonaws.com',\n    });\n  });",
            "file": "default.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "returns undefined for an unknown fact",
            "suites": [
                "find"
            ],
            "updatePoint": {
                "line": 5,
                "column": 45
            },
            "line": 5,
            "code": "  test('returns undefined for an unknown fact', () => {\n    expect(Fact.find(AWS_REGIONS[0], 'not:a:known:fact')).toBe(undefined);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "returns undefined for an unknown region",
            "suites": [
                "find"
            ],
            "updatePoint": {
                "line": 9,
                "column": 47
            },
            "line": 9,
            "code": "  test('returns undefined for an unknown region', () => {\n    expect(Fact.find('bermuda-triangle-42', FactName.PARTITION)).toBe(undefined);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "throws error for an unknown fact",
            "suites": [
                "requireFact"
            ],
            "updatePoint": {
                "line": 15,
                "column": 40
            },
            "line": 15,
            "code": "  test('throws error for an unknown fact', () => {\n    expect(() => Fact.requireFact(AWS_REGIONS[0], 'not:a:known:fact')).toThrowError();\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "throws error for an unknown region",
            "suites": [
                "requireFact"
            ],
            "updatePoint": {
                "line": 19,
                "column": 42
            },
            "line": 19,
            "code": "  test('throws error for an unknown region', () => {\n    expect(() => Fact.requireFact('bermuda-triangle-42', FactName.PARTITION)).toThrowError();\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "allows registering an arbitrary fact",
            "suites": [
                "register"
            ],
            "updatePoint": {
                "line": 25,
                "column": 44
            },
            "line": 25,
            "code": "  test('allows registering an arbitrary fact', () => {\n    // GIVEN\n    const region = AWS_REGIONS[0];\n    const name = 'my:custom:fact';\n    const value = '1337';\n\n    // WHEN\n    expect(Fact.find(region, name)).toBe(undefined);\n    expect(() => Fact.register({ region, name, value })).not.toThrowError();\n\n    // THEN\n    expect(Fact.find(region, name)).toBe(value);\n\n    // Cleanup\n    Fact.unregister(region, name);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "allows re-registering a fact with the same value",
            "suites": [
                "register"
            ],
            "updatePoint": {
                "line": 42,
                "column": 56
            },
            "line": 42,
            "code": "  test('allows re-registering a fact with the same value', () => {\n    // GIVEN\n    const region = AWS_REGIONS[0];\n    const name = 'my:custom:fact';\n    const value = '1337';\n\n    // WHEN\n    expect(Fact.find(region, name)).toBe(undefined);\n    expect(() => Fact.register({ region, name, value })).not.toThrowError();\n\n    // THEN\n    expect(() => Fact.register({ region, name, value })).not.toThrowError();\n    expect(Fact.find(region, name)).toBe(value);\n\n    // Cleanup\n    Fact.unregister(region, name);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "disallows re-registering a fact with a different value",
            "suites": [
                "register"
            ],
            "updatePoint": {
                "line": 60,
                "column": 62
            },
            "line": 60,
            "code": "  test('disallows re-registering a fact with a different value', () => {\n    // GIVEN\n    const region = AWS_REGIONS[0];\n    const name = FactName.PARTITION;\n    const value = '1337';\n\n    // WHEN\n    expect(Fact.find(region, name)).not.toBe(value);\n\n    // THEN\n    expect(() => Fact.register({ region, name, value }))\n      .toThrowError(/already has a fact/);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "allows overriding an arbitrary fact",
            "suites": [
                "register"
            ],
            "updatePoint": {
                "line": 74,
                "column": 43
            },
            "line": 74,
            "code": "  test('allows overriding an arbitrary fact', () => {\n    // GIVEN\n    const region = AWS_REGIONS[0];\n    const name = 'my:custom:fact';\n    const value = '1337';\n\n    // WHEN\n    expect(Fact.find(region, name)).toBe(undefined);\n    expect(() => Fact.register({ region, name, value })).not.toThrowError();\n    expect(Fact.find(region, name)).toBe(value);\n\n    // THEN\n    expect(() => Fact.register({ region, name, value: 'Foo' }, true)).not.toThrowError();\n    expect(Fact.find(region, name)).toBe('Foo');\n\n    // Cleanup\n    Fact.unregister(region, name);\n  });",
            "file": "fact.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "built-in data is correct",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 30
            },
            "line": 5,
            "code": "test('built-in data is correct', () => {\n  const snapshot: any = {};\n  for (const name of AWS_REGIONS) {\n    const region = RegionInfo.get(name);\n\n    const servicePrincipals: { [service: string]: string | undefined } = {};\n    const lambdaInsightsVersions: { [service: string]: string | undefined } = {};\n    const lambdaInsightsArmVersions: { [service: string]: string | undefined } = {};\n\n    AWS_SERVICES.forEach(service => servicePrincipals[service] = region.servicePrincipal(service));\n\n    for (const version in CLOUDWATCH_LAMBDA_INSIGHTS_ARNS) {\n      lambdaInsightsVersions[version] = region.cloudwatchLambdaInsightsArn(version);\n\n      if ('arm64' in CLOUDWATCH_LAMBDA_INSIGHTS_ARNS[version]) {\n        lambdaInsightsArmVersions[version] = region.cloudwatchLambdaInsightsArn(version, 'arm64');\n      }\n    };\n\n    snapshot[name] = {\n      cdkMetadataResourceAvailable: region.cdkMetadataResourceAvailable,\n      domainSuffix: region.domainSuffix,\n      partition: region.partition,\n      s3StaticWebsiteEndpoint: region.s3StaticWebsiteEndpoint,\n      vpcEndPointServiceNamePrefix: region.vpcEndpointServiceNamePrefix,\n      servicePrincipals,\n      lambdaInsightsVersions,\n      lambdaInsightsArmVersions,\n    };\n  }\n  expect(snapshot).toMatchSnapshot();\n});",
            "file": "region-info.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "built-in data features known regions",
            "suites": [],
            "updatePoint": {
                "line": 38,
                "column": 42
            },
            "line": 38,
            "code": "test('built-in data features known regions', () => {\n  const regions = RegionInfo.regions;\n\n  for (const expected of AWS_REGIONS) {\n    expect(regions.map(region => region.name)).toContain(expected);\n  }\n});",
            "file": "region-info.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "limitedRegionMap only returns information for certain regions",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 67
            },
            "line": 46,
            "code": "test('limitedRegionMap only returns information for certain regions', () => {\n\n  const map = RegionInfo.limitedRegionMap(FactName.ELBV2_ACCOUNT, ['aws']);\n  expect(map['us-east-1']).toBeDefined();\n  expect(map['cn-north-1']).not.toBeDefined();\n\n  const map2 = RegionInfo.limitedRegionMap(FactName.ELBV2_ACCOUNT, ['aws-cn']);\n  expect(map2['us-east-1']).not.toBeDefined();\n  expect(map2['cn-north-1']).toBeDefined();\n});",
            "file": "region-info.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "%p should be opt-in: %p",
            "suites": [],
            "line": 58,
            "code": "test.each([\n  ['us-east-1', false],\n  ['me-south-1', true],\n  ['us-iso-west-1', false],\n])('%p should be opt-in: %p', (region, expected) => {\n  expect(RegionInfo.get(region).isOptInRegion).toEqual(expected);\n});",
            "file": "region-info.test.ts",
            "skipped": false,
            "dir": "packages/@aws-cdk/region-info/test"
        },
        {
            "name": "correctly rewrites naked \"import\"",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 41
            },
            "line": 4,
            "code": "  test('correctly rewrites naked \"import\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import '@aws-cdk/aws-s3/hello';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import 'aws-cdk-lib/aws-s3/hello';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "correctly rewrites naked \"require\"",
            "suites": [],
            "updatePoint": {
                "line": 20,
                "column": 42
            },
            "line": 20,
            "code": "  test('correctly rewrites naked \"require\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    require('@aws-cdk/aws-s3/hello');\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    require('aws-cdk-lib/aws-s3/hello');\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "correctly rewrites \"import from\"",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 40
            },
            "line": 36,
            "code": "  test('correctly rewrites \"import from\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import * as s3 from '@aws-cdk/aws-s3';\n    import * as cfndiff from '@aws-cdk/cloudformation-diff';\n    import { Stack } from \"@aws-cdk/core\";\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import * as cfndiff from '@aws-cdk/cloudformation-diff';\n    import { Stack } from \"aws-cdk-lib\";\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "correctly rewrites \"import = require\"",
            "suites": [],
            "updatePoint": {
                "line": 56,
                "column": 45
            },
            "line": 56,
            "code": "  test('correctly rewrites \"import = require\"', () => {\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import s3 = require('@aws-cdk/aws-s3');\n    import cfndiff = require('@aws-cdk/cloudformation-diff');\n    import { Stack } = require(\"@aws-cdk/core\");\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    // something before\n    import s3 = require('aws-cdk-lib/aws-s3');\n    import cfndiff = require('@aws-cdk/cloudformation-diff');\n    import { Stack } = require(\"aws-cdk-lib\");\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "correctly rewrites Cfn imports",
            "suites": [],
            "updatePoint": {
                "line": 76,
                "column": 38
            },
            "line": 76,
            "code": "  test('correctly rewrites Cfn imports', () => {\n    // Codestar example\n    const codestar = rewriteMonoPackageImports(`\n    // something before\n    import * as codestar from './codestar.generated';\n    import { CfnY } from '../codestar.generated';\n    import { CfnX } from '../lib/codestar.generated';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts', {\n      rewriteCfnImports: true,\n      packageUnscopedName: 'aws-codestar',\n    });\n\n    expect(codestar).toBe(`\n    // something before\n    import * as codestar from 'aws-cdk-lib/aws-codestar';\n    import { CfnY } from 'aws-cdk-lib/aws-codestar';\n    import { CfnX } from 'aws-cdk-lib/aws-codestar';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "correctly rewrites Cfn imports from an alpha module",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 59
            },
            "line": 100,
            "code": "  test('correctly rewrites Cfn imports from an alpha module', () => {\n    const customModules = {\n      '@aws-cdk/aws-kinesisfirehose': 'aws-kinesisfirehose-alpha',\n    };\n    const output = rewriteMonoPackageImports(`\n    // something before\n    import * as firehose from '@aws-cdk/aws-kinesisfirehose';\n    import { CfnDeliveryStream } from '@aws-cdk/aws-kinesisfirehose';\n    // something after\n\n    console.log('Look! I did something!');`, 'aws-cdk-lib', 'subject.ts', {\n      rewriteCfnImports: true,\n      customModules: customModules,\n    });\n\n    expect(output).toBe(`\n    // something before\n    import * as firehose from 'aws-kinesisfirehose-alpha';\n    import { CfnDeliveryStream } from 'aws-cdk-lib/aws-kinesisfirehose';\n    // something after\n\n    console.log('Look! I did something!');`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "parses ts code snippet",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 30
            },
            "line": 126,
            "code": "  test('parses ts code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "parses typescript code snippet",
            "suites": [],
            "updatePoint": {
                "line": 144,
                "column": 38
            },
            "line": 144,
            "code": "  test('parses typescript code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`typescript\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`typescript\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "parses text code snippet",
            "suites": [],
            "updatePoint": {
                "line": 162,
                "column": 32
            },
            "line": 162,
            "code": "  test('parses text code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`text\n    import * as s3 from '@aws-cdk/aws-s3';\n    import { Stack } from \"@aws-cdk/core\";\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`text\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import { Stack } from \"aws-cdk-lib\";\n    \\`\\`\\`\n    Some more README text.`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "ignores non ts|typescript|text code snippet",
            "suites": [],
            "updatePoint": {
                "line": 180,
                "column": 51
            },
            "line": 180,
            "code": "  test('ignores non ts|typescript|text code snippet', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`java\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`java\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "parses multiple snippets",
            "suites": [],
            "updatePoint": {
                "line": 196,
                "column": 32
            },
            "line": 196,
            "code": "  test('parses multiple snippets', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    \\`\\`\\`\n    Some more README text.\n    \\`\\`\\`ts\n    import { CfnDeliveryStream } from '@aws-cdk/aws-kinesisfirehose';\n    \\`\\`\\``, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    \\`\\`\\`\n    Some more README text.\n    \\`\\`\\`ts\n    import { CfnDeliveryStream } from 'aws-cdk-lib/aws-kinesisfirehose';\n    \\`\\`\\``);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "import declaration",
            "suites": [
                "constructs imports",
                "namespace imports"
            ],
            "updatePoint": {
                "line": 221,
                "column": 28
            },
            "line": 221,
            "code": "    test('import declaration', () => {\n      const output = rewriteMonoPackageImports(`\n      import * as core from '@aws-cdk/core';\n      class FooBar extends core.Construct {\n        private readonly foo: core.Construct;\n        private doStuff() { return new core.Construct(); }\n      }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import * as constructs from 'constructs';\n      import * as core from 'aws-cdk-lib';\n      class FooBar extends constructs.Construct {\n        private readonly foo: constructs.Construct;\n        private doStuff() { return new constructs.Construct(); }\n      }`);\n    });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "import equals declaration",
            "suites": [
                "constructs imports",
                "namespace imports"
            ],
            "updatePoint": {
                "line": 238,
                "column": 35
            },
            "line": 238,
            "code": "    test('import equals declaration', () => {\n      const output = rewriteMonoPackageImports(`\n      import core = require('@aws-cdk/core');\n      class FooBar extends core.Construct {\n        private readonly foo: core.Construct;\n        private doStuff() { return new core.Construct(); }\n      }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import * as constructs from 'constructs';\n      import core = require('aws-cdk-lib');\n      class FooBar extends constructs.Construct {\n        private readonly foo: constructs.Construct;\n        private doStuff() { return new constructs.Construct(); }\n      }`);\n    });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "no constructs imports",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 257,
                "column": 31
            },
            "line": 257,
            "code": "    test('no constructs imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { Stack, StackProps } from '@aws-cdk/core';\n      class FooBar extends Stack { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { Stack, StackProps } from 'aws-cdk-lib';\n      class FooBar extends Stack { }`);\n    });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "all constructs imports",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 268,
                "column": 32
            },
            "line": 268,
            "code": "    test('all constructs imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { IConstruct, Construct } from '@aws-cdk/core';\n      class FooBar implements IConstruct extends Construct { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { IConstruct, Construct } from 'constructs';\n      class FooBar implements IConstruct extends Construct { }`);\n    });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "mixed constructs and core imports",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 279,
                "column": 43
            },
            "line": 279,
            "code": "    test('mixed constructs and core imports', () => {\n      const output = rewriteMonoPackageImports(`\n      import { Stack, Construct, IConstruct, StackProps } from '@aws-cdk/core';\n      class FooBar implements IConstruct extends Construct { }`,\n      'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n      expect(output).toBe(`\n      import { Construct, IConstruct } from 'constructs';\n      import { Stack, StackProps } from 'aws-cdk-lib';\n      class FooBar implements IConstruct extends Construct { }`);\n    });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "exhaustive test",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 292,
                "column": 23
            },
            "line": 292,
            "code": "  test('exhaustive test', () => {\n    const output = rewriteMonoPackageImports(`\n    import * as core1 from '@aws-cdk/core';\n    // a comment of some kind\n    import core2 = require('@aws-cdk/core');\n    import { Stack } from '@aws-cdk/core';\n    // more comments\n    import { Construct as CoreConstruct } from '@aws-cdk/core';\n    import { IConstruct, Stack, StackProps } from '@aws-cdk/core';\n    import * as s3 from '@aws-cdk/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: core2.Construct;\n      public static bar1() { return CoreConstruct(); }\n      public static bar2() { return new class implements IConstruct {}; }\n    }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    import * as constructs from 'constructs';\n    import { IConstruct } from 'constructs';\n    import * as core1 from 'aws-cdk-lib';\n    // a comment of some kind\n    import core2 = require('aws-cdk-lib');\n    import { Stack } from 'aws-cdk-lib';\n    // more comments\n    import { Construct as CoreConstruct } from 'constructs';\n    import { Stack, StackProps } from 'aws-cdk-lib';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n\n    class FooBar implements constructs.IConstruct {\n      readonly foo1: constructs.Construct;\n      public static bar1() { return CoreConstruct(); }\n      public static bar2() { return new class implements IConstruct {}; }\n    }`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "does not rewrite constructs imports unless the option is explicitly set",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 328,
                "column": 79
            },
            "line": 328,
            "code": "  test('does not rewrite constructs imports unless the option is explicitly set', () => {\n    const output = rewriteMonoPackageImports(`\n    import * as core1 from '@aws-cdk/core';\n    // a comment of some kind\n    import { Stack } from '@aws-cdk/core';\n    // more comments\n    import { Construct as CoreConstruct } from '@aws-cdk/core';\n    import { IConstruct, Stack, StackProps } from '@aws-cdk/core';\n    import * as s3 from '@aws-cdk/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: CoreConstruct;\n      public static bar2() { return new class implements IConstruct {}; }\n    }`, 'aws-cdk-lib', 'subject.ts');\n\n    expect(output).toBe(`\n    import * as core1 from 'aws-cdk-lib';\n    // a comment of some kind\n    import { Stack } from 'aws-cdk-lib';\n    // more comments\n    import { Construct as CoreConstruct } from 'aws-cdk-lib';\n    import { IConstruct, Stack, StackProps } from 'aws-cdk-lib';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n\n    class FooBar implements core1.IConstruct {\n      readonly foo1: CoreConstruct;\n      public static bar2() { return new class implements IConstruct {}; }\n    }`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "puts constructs imports after shebang lines",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 358,
                "column": 51
            },
            "line": 358,
            "code": "  test('puts constructs imports after shebang lines', () => {\n    const output = rewriteMonoPackageImports(`\n    #!/usr/bin/env node\n    import * as core from '@aws-cdk/core';\n    class FooBar extends core.Construct {\n      private readonly foo: core.Construct;\n      private doStuff() { return new core.Construct(); }\n    }`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    #!/usr/bin/env node\n    import * as constructs from 'constructs';\n    import * as core from 'aws-cdk-lib';\n    class FooBar extends constructs.Construct {\n      private readonly foo: constructs.Construct;\n      private doStuff() { return new constructs.Construct(); }\n    }`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "supports rewriteReadmeImports",
            "suites": [
                "constructs imports",
                "named imports"
            ],
            "updatePoint": {
                "line": 377,
                "column": 37
            },
            "line": 377,
            "code": "  test('supports rewriteReadmeImports', () => {\n    const output = rewriteReadmeImports(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as s3 from '@aws-cdk/aws-s3';\n    import * as core from \"@aws-cdk/core\";\n    import { Construct, Stack } from \"@aws-cdk/core\";\n    class Foo extends core.Construct {\n      public bar() { return new Construct(); }\n    }\n    \\`\\`\\`\n    Some more README text.`, 'aws-cdk-lib', 'subject.ts', { rewriteConstructsImports: true });\n\n    expect(output).toBe(`\n    Some README text.\n    \\`\\`\\`ts\n    import * as constructs from 'constructs';\n    import { Construct } from 'constructs';\n    import * as s3 from 'aws-cdk-lib/aws-s3';\n    import * as core from \"aws-cdk-lib\";\n    import { Stack } from \"aws-cdk-lib\";\n    class Foo extends constructs.Construct {\n      public bar() { return new Construct(); }\n    }\n    \\`\\`\\`\n    Some more README text.`);\n  });",
            "file": "rewrite.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk-migration/test"
        },
        {
            "name": "default account cache uses CDK_HOME",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 41
            },
            "line": 21,
            "code": "test('default account cache uses CDK_HOME', () => {\n  process.env.CDK_HOME = '/banana';\n  const cache = new AccountAccessKeyCache();\n  expect((cache as any).cacheFile).toContain('/banana/');\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "account cache does not fail when given a nonwritable directory",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 68
            },
            "line": 27,
            "code": "test('account cache does not fail when given a nonwritable directory', async () => {\n  const accessError = new Error('Oh no');\n  (accessError as any).code = 'EACCES';\n\n  return withMocked(fs, 'mkdirs', async (mkdirs) => {\n    // Have to do this because mkdirs has 2 overloads and it confuses TypeScript\n    (mkdirs as unknown as jest.Mock<Promise<void>, [any]>).mockRejectedValue(accessError);\n\n    const cache = new AccountAccessKeyCache('/abc/xyz');\n    await cache.fetch('xyz', () => Promise.resolve({ accountId: 'asdf', partition: 'swa' }));\n\n    // No exception\n  });\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "get(k) when cache is empty",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 32
            },
            "line": 42,
            "code": "test('get(k) when cache is empty', async () => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n  try {\n    expect(await cache.get('foo')).toBeUndefined();\n    expect(await fs.pathExists(cacheFile)).toBeFalsy();\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "put(k,v) and then get(k)",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 30
            },
            "line": 52,
            "code": "test('put(k,v) and then get(k)', async () => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n\n  try {\n    await cache.put('key', { accountId: 'value', partition: 'aws' });\n    await cache.put('boo', { accountId: 'bar', partition: 'aws' });\n    expect(await cache.get('key')).toEqual({ accountId: 'value', partition: 'aws' });\n\n    // create another cache instance on the same file, should still work\n    const cache2 = new AccountAccessKeyCache(cacheFile);\n    expect(await cache2.get('boo')).toEqual({ accountId: 'bar', partition: 'aws' });\n\n    // whitebox: read the file\n    expect(await fs.readJson(cacheFile)).toEqual({\n      key: { accountId: 'value', partition: 'aws' },\n      boo: { accountId: 'bar', partition: 'aws' },\n    });\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fetch(k, resolver) can be used to \"atomically\" get + resolve + put",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 72
            },
            "line": 74,
            "code": "test('fetch(k, resolver) can be used to \"atomically\" get + resolve + put', async () => {\n  const { cacheDir, cache } = await makeCache();\n\n  try {\n    expect(await cache.get('foo')).toBeUndefined();\n    expect(await cache.fetch('foo', async () => ({ accountId: 'bar', partition: 'aws' }))).toEqual({ accountId: 'bar', partition: 'aws' });\n    expect(await cache.get('foo')).toEqual({ accountId: 'bar', partition: 'aws' });\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cache is nuked if it exceeds  entries",
            "suites": [],
            "updatePoint": {
                "line": 86,
                "column": 79
            },
            "line": 86,
            "code": "test(`cache is nuked if it exceeds ${AccountAccessKeyCache.MAX_ENTRIES} entries`, async () => {\n\n  const { cacheDir, cacheFile, cache } = await makeCache();\n\n  try {\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      await cache.put(`key${i}`, { accountId: `value${i}`, partition: 'aws' });\n    }\n\n    // verify all values are on disk\n    const otherCache = new AccountAccessKeyCache(cacheFile);\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      expect(await otherCache.get(`key${i}`)).toEqual({ accountId: `value${i}`, partition: 'aws' });\n    }\n\n    // add another value\n    await cache.put('nuke-me', { accountId: 'genesis', partition: 'aws' });\n\n    // now, we expect only `nuke-me` to exist on disk\n    expect(await otherCache.get('nuke-me')).toEqual({ accountId: 'genesis', partition: 'aws' });\n    for (let i = 0; i < AccountAccessKeyCache.MAX_ENTRIES; ++i) {\n      expect(await otherCache.get(`key${i}`)).toBeUndefined();\n    }\n  } finally {\n    await nukeCache(cacheDir);\n  }\n},\n// This makes a lot of promises, so it can queue for a while...\n30_000);",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cache pretends to be empty if cache file does not contain JSON",
            "suites": [],
            "updatePoint": {
                "line": 116,
                "column": 68
            },
            "line": 116,
            "code": "test('cache pretends to be empty if cache file does not contain JSON', async() => {\n  const { cacheDir, cacheFile, cache } = await makeCache();\n  try {\n    await fs.writeFile(cacheFile, '');\n\n    await expect(cache.get('abc')).resolves.toEqual(undefined);\n  } finally {\n    await nukeCache(cacheDir);\n  }\n});",
            "file": "account-cache.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do bootstrap",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 18
            },
            "line": 68,
            "code": "test('do bootstrap', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do bootstrap using custom bucket name",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 43
            },
            "line": 82,
            "code": "test('do bootstrap using custom bucket name', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      bucketName: 'foobar',\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBe('foobar');\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do bootstrap using KMS CMK",
            "suites": [],
            "updatePoint": {
                "line": 101,
                "column": 32
            },
            "line": 101,
            "code": "test('do bootstrap using KMS CMK', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      kmsKeyId: 'myKmsKey',\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBe('myKmsKey');\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bootstrap disable bucket Public Access Block Configuration",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 64
            },
            "line": 120,
            "code": "test('bootstrap disable bucket Public Access Block Configuration', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      publicAccessBlockConfiguration: false,\n    },\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('false');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do bootstrap with custom tags for toolkit stack",
            "suites": [],
            "updatePoint": {
                "line": 139,
                "column": 53
            },
            "line": 139,
            "code": "test('do bootstrap with custom tags for toolkit stack', async () => {\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    tags: [{ Key: 'Foo', Value: 'Bar' }],\n  });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(changeSetTemplate.Conditions.UsePublicAccessBlockConfiguration['Fn::Equals'][0]).toBe('true');\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing trusted accounts to the old bootstrapping results in an error",
            "suites": [],
            "updatePoint": {
                "line": 156,
                "column": 75
            },
            "line": 156,
            "code": "test('passing trusted accounts to the old bootstrapping results in an error', async () => {\n  await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      trustedAccounts: ['0123456789012'],\n    },\n  }))\n    .rejects\n    .toThrow('--trust can only be passed for the modern bootstrap experience.');\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing CFN execution policies to the old bootstrapping results in an error",
            "suites": [],
            "updatePoint": {
                "line": 167,
                "column": 81
            },
            "line": 167,
            "code": "test('passing CFN execution policies to the old bootstrapping results in an error', async () => {\n  await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    toolkitStackName: 'mockStack',\n    parameters: {\n      cloudFormationExecutionPolicies: ['arn:aws:iam::aws:policy/AdministratorAccess'],\n    },\n  }))\n    .rejects\n    .toThrow('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "even if the bootstrap stack is in a rollback state, can still retry bootstrapping it",
            "suites": [],
            "updatePoint": {
                "line": 178,
                "column": 90
            },
            "line": 178,
            "code": "test('even if the bootstrap stack is in a rollback state, can still retry bootstrapping it', async () => {\n  (cfnMocks.describeStacks! as jest.Mock)\n    .mockReset()\n    // First two calls, the stack exists with a 'rollback complete' status\n    // (first is for version checking, second is in deploy-stack.ts)\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'UPDATE_ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n            { OutputKey: 'BucketDomainName', OutputValue: 'aws.com' },\n          ],\n        },\n      ],\n    }))\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'UPDATE_ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n            { OutputKey: 'BucketDomainName', OutputValue: 'aws.com' },\n          ],\n        },\n      ],\n    }))\n    // Third call, stack has been created\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "even if the bootstrap stack failed to create, can still retry bootstrapping it",
            "suites": [],
            "updatePoint": {
                "line": 230,
                "column": 84
            },
            "line": 230,
            "code": "test('even if the bootstrap stack failed to create, can still retry bootstrapping it', async () => {\n  (cfnMocks.describeStacks! as jest.Mock)\n    .mockReset()\n    // First two calls, the stack exists with a 'rollback complete' status\n    // (first is for version checking, second is in deploy-stack.ts)\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n          ],\n        } as AWS.CloudFormation.Stack,\n      ],\n    }))\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'ROLLBACK_COMPLETE',\n          StackStatusReason: 'It is magic',\n          Outputs: [\n            { OutputKey: 'BucketName', OutputValue: 'bucket' },\n          ],\n        },\n      ],\n    }))\n    // Third call, we just did a delete and want to see it gone\n    .mockImplementationOnce(() => ({ Stacks: [] }))\n    // Fourth call, stack has been created\n    .mockImplementationOnce(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n\n  // WHEN\n  const ret = await bootstrapper.bootstrapEnvironment(env, sdk, { toolkitStackName: 'mockStack' });\n\n  // THEN\n  const bucketProperties = changeSetTemplate.Resources.StagingBucket.Properties;\n  expect(bucketProperties.BucketName).toBeUndefined();\n  expect(bucketProperties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.KMSMasterKeyID)\n    .toBeUndefined();\n  expect(ret.noOp).toBeFalsy();\n  expect(executed).toBeTruthy();\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack is not termination protected by default",
            "suites": [],
            "updatePoint": {
                "line": 283,
                "column": 51
            },
            "line": 283,
            "code": "test('stack is not termination protected by default', async () => {\n  // WHEN\n  await bootstrapper.bootstrapEnvironment(env, sdk);\n\n  // THEN\n  expect(executed).toBeTruthy();\n  expect(protectedTermination).toBeFalsy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack is termination protected when set",
            "suites": [],
            "updatePoint": {
                "line": 292,
                "column": 45
            },
            "line": 292,
            "code": "test('stack is termination protected when set', async () => {\n  // WHEN\n  await bootstrapper.bootstrapEnvironment(env, sdk, {\n    terminationProtection: true,\n  });\n\n  // THEN\n  expect(executed).toBeTruthy();\n  expect(protectedTermination).toBeTruthy();\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do showTemplate YAML",
            "suites": [],
            "updatePoint": {
                "line": 303,
                "column": 26
            },
            "line": 303,
            "code": "test('do showTemplate YAML', async () => {\n  process.stdout.write = jest.fn().mockImplementationOnce((template) => {\n    // THEN\n    expect(parse(template)).toHaveProperty('Description', 'The CDK Toolkit Stack. It was created by `cdk bootstrap` and manages resources necessary for managing your Cloud Applications with AWS CDK.');\n  });\n\n  // WHEN\n  await bootstrapper.showTemplate(false);\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do showTemplate JSON",
            "suites": [],
            "updatePoint": {
                "line": 313,
                "column": 26
            },
            "line": 313,
            "code": "test('do showTemplate JSON', async () => {\n  process.stdout.write = jest.fn().mockImplementationOnce((template) => {\n    // THEN\n    expect(JSON.parse(template)).toHaveProperty('Description', 'The CDK Toolkit Stack. It was created by `cdk bootstrap` and manages resources necessary for managing your Cloud Applications with AWS CDK.');\n  });\n\n  // WHEN\n  await bootstrapper.showTemplate(true);\n});",
            "file": "api/bootstrap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes the bucket name as a CFN parameter",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 62,
                "column": 49
            },
            "line": 62,
            "code": "  test('passes the bucket name as a CFN parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        bucketName: 'my-bucket-name',\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        FileAssetsBucketName: 'my-bucket-name',\n        PublicAccessBlockConfiguration: 'true',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes the KMS key ID as a CFN parameter",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 78,
                "column": 48
            },
            "line": 78,
            "code": "  test('passes the KMS key ID as a CFN parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n        kmsKeyId: 'my-kms-key-id',\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        FileAssetsBucketKmsKeyId: 'my-kms-key-id',\n        PublicAccessBlockConfiguration: 'true',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes false to PublicAccessBlockConfiguration",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 94,
                "column": 54
            },
            "line": 94,
            "code": "  test('passes false to PublicAccessBlockConfiguration', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n        publicAccessBlockConfiguration: false,\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        PublicAccessBlockConfiguration: 'false',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes true to PermissionsBoundary",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 109,
                "column": 42
            },
            "line": 109,
            "code": "  test('passes true to PermissionsBoundary', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        examplePermissionsBoundary: true,\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        InputPermissionsBoundary: 'cdk-hnb659fds-permissions-boundary',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes value to PermissionsBoundary",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 123,
                "column": 43
            },
            "line": 123,
            "code": "  test('passes value to PermissionsBoundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: 'existing-pb',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        customPermissionsBoundary: 'permissions-boundary-name',\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        InputPermissionsBoundary: 'permissions-boundary-name',\n      }),\n    }));\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Changing permissions boundary from existing-pb to permissions-boundary-name/),\n      ]),\n    ]));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "permission boundary switch message does not appear",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 150,
                "column": 58
            },
            "line": 150,
            "code": "  test('permission boundary switch message does not appear', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: '',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk);\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.not.arrayContaining([\n        expect.stringMatching(/Changing permissions boundary/),\n      ]),\n    ]));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "adding new permissions boundary",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 168,
                "column": 39
            },
            "line": 168,
            "code": "  test('adding new permissions boundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: '',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        customPermissionsBoundary: 'permissions-boundary-name',\n      },\n    });\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Adding new permissions boundary permissions-boundary-name/),\n      ]),\n    ]));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "removing existing permissions boundary",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 190,
                "column": 46
            },
            "line": 190,
            "code": "  test('removing existing permissions boundary', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'InputPermissionsBoundary',\n          ParameterValue: 'permissions-boundary-name',\n        },\n      ],\n    });\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {},\n    });\n\n    expect(stderrMock.mock.calls).toEqual(expect.arrayContaining([\n      expect.arrayContaining([\n        expect.stringMatching(/Removing existing permissions boundary permissions-boundary-name/),\n      ]),\n    ]));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing trusted accounts without CFN managed policies results in an error",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 210,
                "column": 81
            },
            "line": 210,
            "code": "  test('passing trusted accounts without CFN managed policies results in an error', async () => {\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    }))\n      .rejects\n      .toThrow(/--cloudformation-execution-policies/);\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing trusted accounts without CFN managed policies on the existing stack results in an error",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 220,
                "column": 103
            },
            "line": 220,
            "code": "  test('passing trusted accounts without CFN managed policies on the existing stack results in an error', async () => {\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'CloudFormationExecutionPolicies',\n          ParameterValue: '',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    }))\n      .rejects\n      .toThrow(/--cloudformation-execution-policies/);\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing no CFN managed policies without trusted accounts is okay",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 239,
                "column": 72
            },
            "line": 239,
            "code": "  test('passing no CFN managed policies without trusted accounts is okay', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {},\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        CloudFormationExecutionPolicies: '',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing trusted accounts for lookup generates the correct stack parameter",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 251,
                "column": 81
            },
            "line": 251,
            "code": "  test('passing trusted accounts for lookup generates the correct stack parameter', async () => {\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccountsForLookup: ['123456789012'],\n        cloudFormationExecutionPolicies: ['aws://foo'],\n      },\n    });\n\n    expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n      parameters: expect.objectContaining({\n        TrustedAccountsForLookup: '123456789012',\n      }),\n    }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allow adding trusted account if there was already a policy on the stack",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 266,
                "column": 79
            },
            "line": 266,
            "code": "  test('allow adding trusted account if there was already a policy on the stack', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'CloudFormationExecutionPolicies',\n          ParameterValue: 'arn:aws:something',\n        },\n      ],\n    });\n\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        trustedAccounts: ['123456789012'],\n      },\n    });\n    // Did not throw\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Do not allow downgrading bootstrap stack version",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 285,
                "column": 56
            },
            "line": 285,
            "code": "  test('Do not allow downgrading bootstrap stack version', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Outputs: [\n        {\n          OutputKey: 'BootstrapVersion',\n          OutputValue: '999',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    })).resolves.toEqual(expect.objectContaining({ noOp: true }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Do not allow overwriting bootstrap stack from a different vendor",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 303,
                "column": 72
            },
            "line": 303,
            "code": "  test('Do not allow overwriting bootstrap stack from a different vendor', async () => {\n    // GIVEN\n    mockTheToolkitInfo({\n      Parameters: [\n        {\n          ParameterKey: 'BootstrapVariant',\n          ParameterValue: 'JoeSchmoe',\n        },\n      ],\n    });\n\n    await expect(bootstrapper.bootstrapEnvironment(env, sdk, {\n    })).resolves.toEqual(expect.objectContaining({ noOp: true }));\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bootstrap template has the right exports",
            "suites": [
                "Bootstrapping v2"
            ],
            "updatePoint": {
                "line": 318,
                "column": 48
            },
            "line": 318,
            "code": "  test('bootstrap template has the right exports', async () => {\n    let template: any;\n    mockDeployStack.mockImplementation((args: DeployStackOptions) => {\n      template = args.stack.template;\n    });\n\n    await bootstrapper.bootstrapEnvironment(env, sdk, {\n      parameters: {\n        cloudFormationExecutionPolicies: ['arn:policy'],\n      },\n    });\n\n    const exports = Object.values(template.Outputs ?? {})\n      .filter((o: any) => o.Export !== undefined)\n      .map((o: any) => o.Export.Name);\n\n    expect(exports).toEqual([\n      // This used to be used by aws-s3-assets\n      { 'Fn::Sub': 'CdkBootstrap-${Qualifier}-FileAssetKeyArn' },\n    ]);\n  });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack is not termination protected by default",
            "suites": [
                "Bootstrapping v2",
                "termination protection"
            ],
            "updatePoint": {
                "line": 341,
                "column": 55
            },
            "line": 341,
            "code": "    test('stack is not termination protected by default', async () => {\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: false,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack is termination protected when option is set",
            "suites": [
                "Bootstrapping v2",
                "termination protection"
            ],
            "updatePoint": {
                "line": 355,
                "column": 59
            },
            "line": 355,
            "code": "    test('stack is termination protected when option is set', async () => {\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        terminationProtection: true,\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: true,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "termination protection is left alone when option is not given",
            "suites": [
                "Bootstrapping v2",
                "termination protection"
            ],
            "updatePoint": {
                "line": 370,
                "column": 71
            },
            "line": 370,
            "code": "    test('termination protection is left alone when option is not given', async () => {\n      mockTheToolkitInfo({\n        EnableTerminationProtection: true,\n      });\n\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: true,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "termination protection can be switched off",
            "suites": [
                "Bootstrapping v2",
                "termination protection"
            ],
            "updatePoint": {
                "line": 388,
                "column": 52
            },
            "line": 388,
            "code": "    test('termination protection can be switched off', async () => {\n      mockTheToolkitInfo({\n        EnableTerminationProtection: true,\n      });\n\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        terminationProtection: false,\n        parameters: {\n          cloudFormationExecutionPolicies: ['arn:policy'],\n        },\n      });\n\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        stack: expect.objectContaining({\n          terminationProtection: false,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "(new stack) createCustomerMasterKey=%p => parameter becomes %p ",
            "suites": [
                "Bootstrapping v2",
                "KMS key"
            ],
            "line": 409,
            "code": "    test.each([\n      // Default case\n      [undefined, 'AWS_MANAGED_KEY'],\n      // Create a new key\n      [true, ''],\n      // Don't create a new key\n      [false, 'AWS_MANAGED_KEY'],\n    ])('(new stack) createCustomerMasterKey=%p => parameter becomes %p ', async (createCustomerMasterKey, paramKeyId) => {\n      // GIVEN: no existing stack\n\n      // WHEN\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          createCustomerMasterKey,\n          cloudFormationExecutionPolicies: ['arn:booh'],\n        },\n      });\n\n      // THEN\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        parameters: expect.objectContaining({\n          FileAssetsBucketKmsKeyId: paramKeyId,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "(upgrading) current param %p, createCustomerMasterKey=%p => parameter becomes %p ",
            "suites": [
                "Bootstrapping v2",
                "KMS key"
            ],
            "line": 435,
            "code": "    test.each([\n      // Old bootstrap stack being upgraded to new one\n      [undefined, undefined, 'AWS_MANAGED_KEY'],\n      // There is a value, user doesn't request a change\n      ['arn:aws:key', undefined, undefined],\n      // Switch off existing key\n      ['arn:aws:key', false, 'AWS_MANAGED_KEY'],\n      // Switch on existing key\n      ['AWS_MANAGED_KEY', true, ''],\n    ])('(upgrading) current param %p, createCustomerMasterKey=%p => parameter becomes %p ', async (currentKeyId, createCustomerMasterKey, paramKeyId) => {\n      // GIVEN\n      mockTheToolkitInfo({\n        Parameters: currentKeyId ? [\n          {\n            ParameterKey: 'FileAssetsBucketKmsKeyId',\n            ParameterValue: currentKeyId,\n          },\n        ] : undefined,\n      });\n\n      // WHEN\n      await bootstrapper.bootstrapEnvironment(env, sdk, {\n        parameters: {\n          createCustomerMasterKey,\n          cloudFormationExecutionPolicies: ['arn:booh'],\n        },\n      });\n\n      // THEN\n      expect(mockDeployStack).toHaveBeenCalledWith(expect.objectContaining({\n        parameters: expect.objectContaining({\n          FileAssetsBucketKmsKeyId: paramKeyId,\n        }),\n      }));\n    });",
            "file": "api/bootstrap2.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not throw when selecting stack without errors",
            "suites": [],
            "updatePoint": {
                "line": 9,
                "column": 54
            },
            "line": 9,
            "code": "test('do not throw when selecting stack without errors', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const selected = await cxasm.selectStacks( { patterns: ['withouterrorsNODEPATH'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n  selected.processMetadataMessages();\n\n  // THEN\n  expect(selected.firstStack.template.resource).toBe('noerrorresource');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do throw when selecting stack with errors",
            "suites": [],
            "updatePoint": {
                "line": 23,
                "column": 47
            },
            "line": 23,
            "code": "test('do throw when selecting stack with errors', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const selected = await cxasm.selectStacks({ patterns: ['witherrors'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(() => selected.processMetadataMessages()).toThrow(/Found errors/);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select all top level stacks in the presence of nested assemblies",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 70
            },
            "line": 36,
            "code": "test('select all top level stacks in the presence of nested assemblies', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ allTopLevel: true, patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n  expect(x.stackIds).toContain('witherrors');\n  expect(x.stackIds).toContain('withouterrors');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select stacks by glob pattern",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 35
            },
            "line": 49,
            "code": "test('select stacks by glob pattern', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['with*'] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n  expect(x.stackIds).toContain('witherrors');\n  expect(x.stackIds).toContain('withouterrors');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior: all",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 26
            },
            "line": 62,
            "code": "test('select behavior: all', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior: none",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 27
            },
            "line": 73,
            "code": "test('select behavior: none', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.None });\n\n  // THEN\n  expect(x.stackCount).toBe(0);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior: single",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 29
            },
            "line": 84,
            "code": "test('select behavior: single', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack list error contains node paths",
            "suites": [],
            "updatePoint": {
                "line": 93,
                "column": 42
            },
            "line": 93,
            "code": "test('stack list error contains node paths', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('withouterrorsNODEPATH');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior: repeat",
            "suites": [],
            "updatePoint": {
                "line": 102,
                "column": 29
            },
            "line": 102,
            "code": "test('select behavior: repeat', async () => {\n  // GIVEN\n  const cxasm = await testCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['withouterrorsNODEPATH', 'withouterrorsNODEPATH'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(x.stackCount).toBe(1);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior with nested assemblies: all",
            "suites": [],
            "updatePoint": {
                "line": 115,
                "column": 49
            },
            "line": 115,
            "code": "test('select behavior with nested assemblies: all', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN\n  expect(x.stackCount).toBe(3);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior with nested assemblies: none",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 50
            },
            "line": 126,
            "code": "test('select behavior with nested assemblies: none', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.None });\n\n  // THEN\n  expect(x.stackCount).toBe(0);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior with nested assemblies: single",
            "suites": [],
            "updatePoint": {
                "line": 137,
                "column": 52
            },
            "line": 137,
            "code": "test('select behavior with nested assemblies: single', async () => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  await expect(cxasm.selectStacks({ patterns: [] }, { defaultBehavior: DefaultSelection.OnlySingle }))\n    .rejects.toThrow('Since this app includes more than a single stack, specify which stacks to use (wildcards are supported) or specify `--all`');\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "select behavior with nested assemblies: repeat",
            "suites": [],
            "updatePoint": {
                "line": 146,
                "column": 52
            },
            "line": 146,
            "code": "test('select behavior with nested assemblies: repeat', async() => {\n  // GIVEN\n  const cxasm = await testNestedCloudAssembly();\n\n  // WHEN\n  const x = await cxasm.selectStacks({ patterns: ['deeply/hidden/withouterrors', 'nested'] }, {\n    defaultBehavior: DefaultSelection.AllStacks,\n  });\n\n  // THEN\n  expect(x.stackCount).toBe(2);\n});",
            "file": "api/cloud-assembly.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "is generated for relocatable stacks from old frameworks",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 9,
                "column": 63
            },
            "line": 9,
            "code": "  test('is generated for relocatable stacks from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: `aws://${cxapi.UNKNOWN_ACCOUNT}/${cxapi.UNKNOWN_REGION}`, versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toEqual({\n        Type: 'AWS::CDK::Metadata',\n        Properties: {\n          // eslint-disable-next-line @typescript-eslint/no-require-imports\n          Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,\n        },\n        Condition: 'CDKMetadataAvailable',\n      });\n\n      expect(result.template.Conditions?.CDKMetadataAvailable).toBeDefined();\n    });\n  });",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "is generated for stacks in supported regions from old frameworks",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 29,
                "column": 72
            },
            "line": 29,
            "code": "  test('is generated for stacks in supported regions from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toEqual({\n        Type: 'AWS::CDK::Metadata',\n        Properties: {\n          // eslint-disable-next-line @typescript-eslint/no-require-imports\n          Modules: `${require('../../package.json').name}=${require('../../package.json').version}`,\n        },\n      });\n    });\n  });",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "is not generated for stacks in unsupported regions from old frameworks",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 46,
                "column": 78
            },
            "line": 46,
            "code": "  test('is not generated for stacks in unsupported regions from old frameworks', async () => {\n    await withFakeCurrentCxVersion('2.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/bermuda-triangle-1337', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toBeUndefined();\n    });\n  });",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "is not generated for new frameworks",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 57,
                "column": 43
            },
            "line": 57,
            "code": "  test('is not generated for new frameworks', async () => {\n    await withFakeCurrentCxVersion('8.0.0', async () => {\n      const cx = await testCloudExecutable({ env: 'aws://012345678912/us-east-1', versionReporting: true });\n      const cxasm = await cx.synthesize();\n\n      const result = cxasm.stackById('withouterrors').firstStack;\n      const metadata = result.template.Resources && result.template.Resources.CDKMetadata;\n      expect(metadata).toBeUndefined();\n    });\n  });",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stop executing if context providers are not making progress",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 69,
                "column": 65
            },
            "line": 69,
            "code": "test('stop executing if context providers are not making progress', async () => {\n  registerContextProvider(cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER, {\n    async getValue(_: { [key: string]: any }): Promise<any> {\n      return 'foo';\n    },\n  });\n\n  const cloudExecutable = new MockCloudExecutable({\n    stacks: [{\n      stackName: 'thestack',\n      template: { resource: 'noerrorresource' },\n    }],\n    // Always return the same missing keys, synthesis should still finish.\n    missing: [\n      { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },\n    ],\n  });\n  const cxasm = await cloudExecutable.synthesize();\n\n  // WHEN\n  await cxasm.selectStacks({ patterns: ['thestack'] }, { defaultBehavior: DefaultSelection.AllStacks });\n\n  // THEN: the test finishes normally});\n});",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fails if lookups are disabled and missing context is synthesized",
            "suites": [
                "AWS::CDK::Metadata"
            ],
            "updatePoint": {
                "line": 94,
                "column": 70
            },
            "line": 94,
            "code": "test('fails if lookups are disabled and missing context is synthesized', async () => {\n  // GIVEN\n  const cloudExecutable = new MockCloudExecutable({\n    stacks: [{\n      stackName: 'thestack',\n      template: { resource: 'noerrorresource' },\n    }],\n    // Always return the same missing keys, synthesis should still finish.\n    missing: [\n      { key: 'abcdef', props: { account: '1324', region: 'us-east-1' }, provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER },\n    ],\n  });\n  cloudExecutable.configuration.settings.set(['lookups'], false);\n\n  // WHEN\n  await expect(cloudExecutable.synthesize()).rejects.toThrow(/Context lookups have been disabled/);\n});",
            "file": "api/cloud-executable.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deployStack builds assets by default for backward compatibility",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 69
            },
            "line": 68,
            "code": "test('deployStack builds assets by default for backward compatibility', async () => {\n  const stack = testStackWithAssetManifest();\n\n  // WHEN\n  await deployments.deployStack({\n    stack,\n  });\n\n  // THEN\n  const expectedOptions = expect.objectContaining({\n    buildAssets: true,\n  });\n  expect(publishAssets).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), expectedOptions);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deployStack can disable asset building for prebuilds",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 58
            },
            "line": 83,
            "code": "test('deployStack can disable asset building for prebuilds', async () => {\n  const stack = testStackWithAssetManifest();\n\n  // WHEN\n  await deployments.deployStack({\n    stack,\n    buildAssets: false,\n  });\n\n  // THEN\n  const expectedOptions = expect.objectContaining({\n    buildAssets: false,\n  });\n  expect(publishAssets).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), expectedOptions);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes through hotswap=true to deployStack()",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 50
            },
            "line": 99,
            "code": "test('passes through hotswap=true to deployStack()', async () => {\n  // WHEN\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n    }),\n    hotswap: HotswapMode.FALL_BACK,\n  });\n\n  // THEN\n  expect(deployStack).toHaveBeenCalledWith(expect.objectContaining({\n    hotswap: HotswapMode.FALL_BACK,\n  }));\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "placeholders are substituted in CloudFormation execution role",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 67
            },
            "line": 114,
            "code": "test('placeholders are substituted in CloudFormation execution role', async () => {\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        cloudFormationExecutionRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n      },\n    }),\n  });\n\n  expect(deployStack).toHaveBeenCalledWith(expect.objectContaining({\n    roleArn: 'bloop:here:123456789012',\n  }));\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "role with placeholders is assumed if assumerole is given",
            "suites": [],
            "updatePoint": {
                "line": 129,
                "column": 62
            },
            "line": 129,
            "code": "test('role with placeholders is assumed if assumerole is given', async () => {\n  const mockForEnvironment = jest.fn().mockImplementation(() => { return { sdk: sdkProvider.sdk }; });\n  sdkProvider.forEnvironment = mockForEnvironment;\n\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n      },\n    }),\n  });\n\n  expect(mockForEnvironment).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.objectContaining({\n    assumeRoleArn: 'bloop:here:123456789012',\n  }));\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deployment fails if bootstrap stack is missing",
            "suites": [],
            "updatePoint": {
                "line": 147,
                "column": 52
            },
            "line": 147,
            "code": "test('deployment fails if bootstrap stack is missing', async () => {\n  await expect(deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n      },\n    }),\n  })).rejects.toThrow(/requires a bootstrap stack/);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deployment fails if bootstrap stack is too old",
            "suites": [],
            "updatePoint": {
                "line": 159,
                "column": 52
            },
            "line": 159,
            "code": "test('deployment fails if bootstrap stack is too old', async () => {\n  mockSuccessfulBootstrapStackLookup({\n    BootstrapVersion: 5,\n  });\n\n  await expect(deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n      },\n    }),\n  })).rejects.toThrow(/requires bootstrap stack version '99', found '5'/);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if toolkit stack cannot be found but SSM parameter name is present deployment succeeds",
            "suites": [],
            "updatePoint": {
                "line": 175,
                "column": 92
            },
            "line": 175,
            "code": "test('if toolkit stack cannot be found but SSM parameter name is present deployment succeeds', async () => {\n  // FIXME: Mocking a successful bootstrap stack lookup here should not be necessary.\n  // This should fail and return a placeholder failure object.\n  mockSuccessfulBootstrapStackLookup({\n    BootstrapVersion: 2,\n  });\n\n  let requestedParameterName: string;\n  sdkProvider.stubSSM({\n    getParameter(request) {\n      requestedParameterName = request.Name;\n      return {\n        Parameter: {\n          Value: '99',\n        },\n      };\n    },\n  });\n\n  await deployments.deployStack({\n    stack: testStack({\n      stackName: 'boop',\n      properties: {\n        assumeRoleArn: 'bloop:${AWS::Region}:${AWS::AccountId}',\n        requiresBootstrapStackVersion: 99,\n        bootstrapStackVersionSsmParameter: '/some/parameter',\n      },\n    }),\n  });\n\n  expect(requestedParameterName!).toEqual('/some/parameter');\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "readCurrentTemplateWithNestedStacks() can handle non-Resources in the template",
            "suites": [],
            "updatePoint": {
                "line": 208,
                "column": 84
            },
            "line": 208,
            "code": "test('readCurrentTemplateWithNestedStacks() can handle non-Resources in the template', async () => {\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'ParentOfStackWithOutputAndParameter',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    switch (stackName) {\n      case 'ParentOfStackWithOutputAndParameter':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedStack: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'NestedStack':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n          Parameters: {\n            NestedParam: {\n              Type: 'String',\n            },\n          },\n          Outputs: {\n            NestedOutput: {\n              Value: {\n                Ref: 'NestedResource',\n              },\n            },\n          },\n        });\n        break;\n\n      default:\n        throw new Error('unknown stack name ' + stackName + ' found');\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'ParentOfStackWithOutputAndParameter',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('ParentOfStackWithOutputAndParameter',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n    ),\n  );\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              NestedResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n            Outputs: {\n              NestedOutput: {\n                Value: {\n                  Ref: 'NestedResource',\n                },\n              },\n            },\n            Parameters: {\n              NestedParam: {\n                Type: 'String',\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              NestedResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n            Outputs: {\n              NestedOutput: {\n                Value: {\n                  Ref: 'NestedResource',\n                },\n              },\n            },\n            Parameters: {\n              NestedParam: {\n                Type: 'Number',\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-output-one-param-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works",
            "suites": [],
            "updatePoint": {
                "line": 363,
                "column": 91
            },
            "line": 363,
            "code": "test('readCurrentTemplateWithNestedStacks() with a 3-level nested + sibling structure works', async () => {\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'MultiLevelRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    switch (stackName) {\n      case 'MultiLevelRoot':\n        cfnStack.template = async () => ({\n          Resources: {\n            NestedStack: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'NestedStack':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n            GrandChildStackA: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-stack.nested.template.json',\n              },\n            },\n            GrandChildStackB: {\n              Type: 'AWS::CloudFormation::Stack',\n              Properties: {\n                TemplateURL: 'https://www.magic-url.com',\n              },\n              Metadata: {\n                'aws:asset:path': 'one-resource-stack.nested.template.json',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'GrandChildStackA':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n        });\n        break;\n\n      case 'GrandChildStackB':\n        cfnStack.template = async () => ({\n          Resources: {\n            SomeResource: {\n              Type: 'AWS::Something',\n              Properties: {\n                Property: 'old-value',\n              },\n            },\n          },\n        });\n        break;\n\n      default:\n        throw new Error('unknown stack name ' + stackName + ' found in cloudformation-deployments.test.ts');\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'MultiLevelRoot',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('MultiLevelRoot',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n    ),\n  );\n  pushStackResourceSummaries('NestedStack',\n    stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n    ),\n    stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n    ),\n  );\n  pushStackResourceSummaries('GrandChildStackA',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildA/abcd',\n    ),\n  );\n  pushStackResourceSummaries('GrandChildStackB',\n    stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildB/abcd',\n    ),\n  );\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              GrandChildStackA: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'old-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              GrandChildStackB: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'old-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              GrandChildStackA: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'new-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              GrandChildStackB: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  TemplateURL: 'https://www.magic-url.com',\n                  NestedTemplate: {\n                    Resources: {\n                      SomeResource: {\n                        Type: 'AWS::Something',\n                        Properties: {\n                          Property: 'new-value',\n                        },\n                      },\n                    },\n                  },\n                },\n                Metadata: {\n                  'aws:asset:path': 'one-resource-stack.nested.template.json',\n                },\n              },\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-two-stacks-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works",
            "suites": [],
            "updatePoint": {
                "line": 620,
                "column": 118
            },
            "line": 620,
            "code": "test('readCurrentTemplateWithNestedStacks() on an undeployed parent stack with an (also undeployed) nested stack works', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'UndeployedParent',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_cfn, _stackName: string) => {\n    cfnStack.template = async () => ({});\n\n    return cfnStack;\n  });\n  const rootStack = testStack({\n    stackName: 'UndeployedParent',\n    template: {\n      Resources: {\n        NestedStack: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-one-stack-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      NestedStack: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          NestedTemplate: {\n            Resources: {\n              NestedStack: {\n                Type: 'AWS::CloudFormation::Stack',\n                Properties: {\n                  NestedTemplate: {},\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  });\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "readCurrentTemplateWithNestedStacks() caches calls to listStackResources()",
            "suites": [],
            "updatePoint": {
                "line": 673,
                "column": 80
            },
            "line": 673,
            "code": "test('readCurrentTemplateWithNestedStacks() caches calls to listStackResources()', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'CachingRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_cfn, _stackName: string) => {\n    cfnStack.template = async () => ({\n      Resources:\n      {\n        NestedStackA: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n        NestedStackB: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    });\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'CachingRoot',\n    template: {\n      Resources: {\n        NestedStackA: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n        NestedStackB: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('CachingRoot',\n    stackSummaryOf('NestedStackA', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n    ),\n    stackSummaryOf('NestedStackB', 'AWS::CloudFormation::Stack',\n      'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n    ),\n  );\n\n  // WHEN\n  await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(numberOfTimesListStackResourcesWasCalled).toEqual(1);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "readCurrentTemplateWithNestedStacks() succesfully ignores stacks without metadata",
            "suites": [],
            "updatePoint": {
                "line": 749,
                "column": 87
            },
            "line": 749,
            "code": "test('readCurrentTemplateWithNestedStacks() succesfully ignores stacks without metadata', async () => {\n  // GIVEN\n  const cfnStack = new FakeCloudformationStack({\n    stackName: 'MetadataRoot',\n    stackId: 'StackId',\n  });\n  CloudFormationStack.lookup = (async (_, stackName: string) => {\n    if (stackName === 'MetadataRoot') {\n      cfnStack.template = async () => ({\n        Resources: {\n          WithMetadata: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-resource-stack.nested.template.json',\n            },\n          },\n        },\n      });\n\n    } else {\n      cfnStack.template = async () => ({\n        Resources: {\n          SomeResource: {\n            Type: 'AWS::Something',\n            Properties: {\n              Property: 'old-value',\n            },\n          },\n        },\n      });\n    }\n\n    return cfnStack;\n  });\n\n  const rootStack = testStack({\n    stackName: 'MetadataRoot',\n    template: {\n      Resources: {\n        WithoutMetadata: {\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Type: 'AWS::CloudFormation::Stack',\n        },\n        WithEmptyMetadata: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {},\n        },\n        WithMetadata: {\n          Type: 'AWS::CloudFormation::Stack',\n          Properties: {\n            TemplateURL: 'https://www.magic-url.com',\n          },\n          Metadata: {\n            'aws:asset:path': 'one-resource-stack.nested.template.json',\n          },\n        },\n      },\n    },\n  });\n\n  pushStackResourceSummaries('MetadataRoot', stackSummaryOf('WithMetadata', 'AWS::CloudFormation::Stack',\n    'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/one-resource-stack/abcd',\n  ));\n\n  // WHEN\n  const deployedTemplate = await deployments.readCurrentTemplateWithNestedStacks(rootStack);\n\n  // THEN\n  expect(deployedTemplate).toEqual({\n    Resources: {\n      WithMetadata: {\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'old-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-stack.nested.template.json',\n        },\n      },\n    },\n  });\n\n  expect(rootStack.template).toEqual({\n    Resources: {\n      WithoutMetadata: { // Unchanged\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n        },\n      },\n      WithEmptyMetadata: { // Unchanged\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n        },\n        Metadata: {},\n      },\n      WithMetadata: { // Changed\n        Type: 'AWS::CloudFormation::Stack',\n        Properties: {\n          TemplateURL: 'https://www.magic-url.com',\n          NestedTemplate: {\n            Resources: {\n              SomeResource: {\n                Type: 'AWS::Something',\n                Properties: {\n                  Property: 'new-value',\n                },\n              },\n            },\n          },\n        },\n        Metadata: {\n          'aws:asset:path': 'one-resource-stack.nested.template.json',\n        },\n      },\n    },\n  });\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "building assets",
            "suites": [],
            "updatePoint": {
                "line": 887,
                "column": 21
            },
            "line": 887,
            "code": "test('building assets', async () => {\n  // GIVEN\n  const stack = testStackWithAssetManifest();\n\n  // WHEN\n  await deployments.buildStackAssets({\n    stack,\n  });\n\n  // THEN\n  const expectedAssetManifest = expect.objectContaining({\n    directory: stack.assembly.directory,\n    manifest: expect.objectContaining({\n      files: expect.objectContaining({\n        fake: expect.anything(),\n      }),\n    }),\n  });\n  const expectedEnvironment = expect.objectContaining({\n    account: 'account',\n    name: 'aws://account/region',\n    region: 'region',\n  });\n  expect(buildAssets).toBeCalledWith(expectedAssetManifest, sdkProvider, expectedEnvironment, undefined);\n});",
            "file": "api/cloudformation-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.CLASSIC`",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 72
            },
            "line": 88,
            "code": "test(\"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.CLASSIC`\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    extraUserAgent: 'extra-user-agent',\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).toHaveBeenCalled();\n  // check that the extra User-Agent is honored\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('extra-user-agent');\n  // check that the fallback has been called if hotswapping failed\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('cdk-hotswap/fallback');\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.HOTSWAP_ONLY`",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 77
            },
            "line": 104,
            "code": "test(\"calls tryHotswapDeployment() if 'hotswap' is `HotswapMode.HOTSWAP_ONLY`\", async () => {\n  cfnMocks.describeStacks = jest.fn()\n    // we need the first call to return something in the Stacks prop,\n    // otherwise the access to `stackId` will fail\n    .mockImplementation(() => ({\n      Stacks: [\n        {\n          StackStatus: 'CREATE_COMPLETE',\n          StackStatusReason: 'It is magic',\n          EnableTerminationProtection: false,\n        },\n      ],\n    }));\n  sdk.stubCloudFormation(cfnMocks as any);\n  // WHEN\n  const deployStackResult = await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.HOTSWAP_ONLY,\n    extraUserAgent: 'extra-user-agent',\n    force: true, // otherwise, deployment would be skipped\n  });\n\n  // THEN\n  expect(deployStackResult.noOp).toEqual(true);\n  expect(tryHotswapDeployment).toHaveBeenCalled();\n  // check that the extra User-Agent is honored\n  expect(sdk.appendCustomUserAgent).toHaveBeenCalledWith('extra-user-agent');\n  // check that the fallback has not been called if hotswapping failed\n  expect(sdk.appendCustomUserAgent).not.toHaveBeenCalledWith('cdk-hotswap/fallback');\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly passes CFN parameters when hotswapping",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 54
            },
            "line": 135,
            "code": "test('correctly passes CFN parameters when hotswapping', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    parameters: {\n      A: 'A-value',\n      B: 'B=value',\n      C: undefined,\n      D: '',\n    },\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).toHaveBeenCalledWith(expect.anything(), { A: 'A-value', B: 'B=value' }, expect.anything(), expect.anything(), HotswapMode.FALL_BACK);\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "call CreateStack when method=direct and the stack doesnt exist yet",
            "suites": [],
            "updatePoint": {
                "line": 152,
                "column": 72
            },
            "line": 152,
            "code": "test('call CreateStack when method=direct and the stack doesnt exist yet', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'direct' },\n  });\n\n  // THEN\n  expect(cfnMocks.createStack).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "call UpdateStack when method=direct and the stack exists already",
            "suites": [],
            "updatePoint": {
                "line": 163,
                "column": 70
            },
            "line": 163,
            "code": "test('call UpdateStack when method=direct and the stack exists already', async () => {\n  // WHEN\n  givenStackExists();\n\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'direct' },\n    force: true,\n  });\n\n  // THEN\n  expect(cfnMocks.updateStack).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call tryHotswapDeployment() if 'hotswap' is false",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 64
            },
            "line": 177,
            "code": "test(\"does not call tryHotswapDeployment() if 'hotswap' is false\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: undefined,\n  });\n\n  // THEN\n  expect(tryHotswapDeployment).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "rollback still defaults to enabled even if 'hotswap' is enabled",
            "suites": [],
            "updatePoint": {
                "line": 188,
                "column": 69
            },
            "line": 188,
            "code": "test(\"rollback still defaults to enabled even if 'hotswap' is enabled\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: HotswapMode.FALL_BACK,\n    rollback: undefined,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n    DisableRollback: true,\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "rollback defaults to enabled if 'hotswap' is undefined",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 60
            },
            "line": 202,
            "code": "test(\"rollback defaults to enabled if 'hotswap' is undefined\", async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    hotswap: undefined,\n    rollback: undefined,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalledTimes(1);\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n    DisableRollback: expect.anything(),\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do deploy executable change set with 0 changes",
            "suites": [],
            "updatePoint": {
                "line": 217,
                "column": 52
            },
            "line": 217,
            "code": "test('do deploy executable change set with 0 changes', async () => {\n  // WHEN\n  const ret = await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(ret.noOp).toBeFalsy();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly passes CFN parameters, ignoring ones with empty values",
            "suites": [],
            "updatePoint": {
                "line": 228,
                "column": 70
            },
            "line": 228,
            "code": "test('correctly passes CFN parameters, ignoring ones with empty values', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    parameters: {\n      A: 'A-value',\n      B: 'B=value',\n      C: undefined,\n      D: '',\n    },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'A', ParameterValue: 'A-value' },\n      { ParameterKey: 'B', ParameterValue: 'B=value' },\n    ],\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "reuse previous parameters if requested",
            "suites": [],
            "updatePoint": {
                "line": 249,
                "column": 44
            },
            "line": 249,
            "code": "test('reuse previous parameters if requested', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      OtherParameter: 'SomeValue',\n    },\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', UsePreviousValue: true },\n      { ParameterKey: 'HasDefault', UsePreviousValue: true },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'SomeValue' },\n    ],\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "output written to stdout",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 285,
                "column": 32
            },
            "line": 285,
            "code": "  test('output written to stdout', async () => {\n    // GIVEN\n\n    await deployStack({\n      ...standardDeployStackArguments(),\n    });\n\n    // THEN\n    expect(stderrMock.mock.calls).toEqual([]);\n    expect(stdoutMock.mock.calls).not.toEqual([]);\n  });",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not reuse previous parameters if not requested",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 298,
                "column": 55
            },
            "line": 298,
            "code": "test('do not reuse previous parameters if not requested', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      HasValue: 'SomeValue',\n      OtherParameter: 'SomeValue',\n    },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'SomeValue' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'SomeValue' },\n    ],\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throw exception if not enough parameters supplied",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 326,
                "column": 55
            },
            "line": 326,
            "code": "test('throw exception if not enough parameters supplied', async () => {\n  // GIVEN\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'TheValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'TheOldValue' },\n    ],\n  });\n\n  // WHEN\n  await expect(deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      OtherParameter: 'SomeValue',\n    },\n  })).rejects.toThrow(/CloudFormation Parameters are missing a value/);\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy is skipped if template did not change",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 345,
                "column": 50
            },
            "line": 345,
            "code": "test('deploy is skipped if template did not change', async () => {\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toBeCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy is skipped if parameters are the same",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 358,
                "column": 50
            },
            "line": 358,
            "code": "test('deploy is skipped if parameters are the same', async () => {\n  // GIVEN\n  givenTemplateIs(FAKE_STACK_WITH_PARAMETERS.template);\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'HasValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'HasDefault' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'OtherParameter' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {},\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy is not skipped if parameters are different",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 381,
                "column": 55
            },
            "line": 381,
            "code": "test('deploy is not skipped if parameters are different', async () => {\n  // GIVEN\n  givenTemplateIs(FAKE_STACK_WITH_PARAMETERS.template);\n  givenStackExists({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'HasValue' },\n      { ParameterKey: 'HasDefault', ParameterValue: 'HasDefault' },\n      { ParameterKey: 'OtherParameter', ParameterValue: 'OtherParameter' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_WITH_PARAMETERS,\n    parameters: {\n      HasValue: 'NewValue',\n    },\n    usePreviousParameters: true,\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    Parameters: [\n      { ParameterKey: 'HasValue', ParameterValue: 'NewValue' },\n      { ParameterKey: 'HasDefault', UsePreviousValue: true },\n      { ParameterKey: 'OtherParameter', UsePreviousValue: true },\n    ],\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if existing stack failed to create, it is deleted and recreated",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 412,
                "column": 69
            },
            "line": 412,
            "code": "test('if existing stack failed to create, it is deleted and recreated', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'DELETE_COMPLETE' }, // Poll the successful deletion\n    { StackStatus: 'CREATE_COMPLETE' }, // Poll the recreation\n  );\n  givenTemplateIs({\n    DifferentThan: 'TheDefault',\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'CREATE',\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if existing stack failed to create, it is deleted and recreated even if the template did not change",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 435,
                "column": 105
            },
            "line": 435,
            "code": "test('if existing stack failed to create, it is deleted and recreated even if the template did not change', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'DELETE_COMPLETE' }, // Poll the successful deletion\n    { StackStatus: 'CREATE_COMPLETE' }, // Poll the recreation\n  );\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'CREATE',\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy not skipped if template did not change and --force is applied",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 455,
                "column": 74
            },
            "line": 455,
            "code": "test('deploy not skipped if template did not change and --force is applied', async () => {\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    force: true,\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy is skipped if template and tags did not change",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 469,
                "column": 59
            },
            "line": 469,
            "code": "test('deploy is skipped if template and tags did not change', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).not.toBeCalled();\n  expect(cfnMocks.executeChangeSet).not.toBeCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy not skipped if template did not change but tags changed",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 494,
                "column": 68
            },
            "line": 494,
            "code": "test('deploy not skipped if template did not change but tags changed', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key', Value: 'Value' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    stack: FAKE_STACK,\n    sdk,\n    sdkProvider,\n    resolvedEnvironment: mockResolvedEnvironment(),\n    tags: [\n      {\n        Key: 'Key',\n        Value: 'NewValue',\n      },\n    ],\n    toolkitInfo: ToolkitInfo.bootstraplessDeploymentsOnly(sdk),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deployStack reports no change if describeChangeSet returns specific error",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 525,
                "column": 79
            },
            "line": 525,
            "code": "test('deployStack reports no change if describeChangeSet returns specific error', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // WHEN\n  const deployResult = await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(deployResult.noOp).toEqual(true);\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy not skipped if template did not change but one tag removed",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 540,
                "column": 71
            },
            "line": 540,
            "code": "test('deploy not skipped if template did not change but one tag removed', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    tags: [\n      { Key: 'Key1', Value: 'Value1' },\n    ],\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.describeStacks).toHaveBeenCalledWith({ StackName: 'withouterrors' });\n  expect(cfnMocks.getTemplate).toHaveBeenCalledWith({ StackName: 'withouterrors', TemplateStage: 'Original' });\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy is not skipped if stack is in a _FAILED state",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 565,
                "column": 58
            },
            "line": 565,
            "code": "test('deploy is not skipped if stack is in a _FAILED state', async () => {\n  // GIVEN\n  givenStackExists({\n    StackStatus: 'DELETE_FAILED',\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    usePreviousParameters: true,\n  }).catch(() => {});\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 581,
                "column": 69
            },
            "line": 581,
            "code": "test('existing stack in UPDATE_ROLLBACK_COMPLETE state can be updated', async () => {\n  // GIVEN\n  givenStackExists(\n    { StackStatus: 'UPDATE_ROLLBACK_COMPLETE' }, // This is for the initial check\n    { StackStatus: 'UPDATE_COMPLETE' }, // Poll the update\n  );\n  givenTemplateIs({ changed: 123 });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.deleteStack).not.toHaveBeenCalled();\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    ChangeSetType: 'UPDATE',\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy not skipped if template changed",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 601,
                "column": 44
            },
            "line": 601,
            "code": "test('deploy not skipped if template changed', async () => {\n  // GIVEN\n  givenStackExists();\n  givenTemplateIs({ changed: 123 });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "not executed and no error if --no-execute is given",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 615,
                "column": 56
            },
            "line": 615,
            "code": "test('not executed and no error if --no-execute is given', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "empty change set is deleted if --execute is given",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 626,
                "column": 55
            },
            "line": 626,
            "code": "test('empty change set is deleted if --execute is given', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: true },\n    force: true, // Necessary to bypass \"skip deploy\"\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n\n  //the first deletion is for any existing cdk change sets, the second is for the deleting the new empty change set\n  expect(cfnMocks.deleteChangeSet).toHaveBeenCalledTimes(2);\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "empty change set is not deleted if --no-execute is given",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 650,
                "column": 62
            },
            "line": 650,
            "code": "test('empty change set is not deleted if --no-execute is given', async () => {\n  cfnMocks.describeChangeSet?.mockImplementation(() => ({\n    Status: 'FAILED',\n    StatusReason: 'No updates are to be performed.',\n  }));\n\n  // GIVEN\n  givenStackExists();\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalled();\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n\n  //the first deletion is for any existing cdk change sets\n  expect(cfnMocks.deleteChangeSet).toHaveBeenCalledTimes(1);\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "use S3 url for stack deployment if present in Stack Artifact",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 673,
                "column": 66
            },
            "line": 673,
            "code": "test('use S3 url for stack deployment if present in Stack Artifact', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: testStack({\n      stackName: 'withouterrors',\n      properties: {\n        stackTemplateAssetObjectUrl: 'https://use-me-use-me/',\n      },\n    }),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    TemplateURL: 'https://use-me-use-me/',\n  }));\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "use REST API S3 url with substituted placeholders if manifest url starts with s3://",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 692,
                "column": 89
            },
            "line": 692,
            "code": "test('use REST API S3 url with substituted placeholders if manifest url starts with s3://', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: testStack({\n      stackName: 'withouterrors',\n      properties: {\n        stackTemplateAssetObjectUrl: 's3://use-me-use-me-${AWS::AccountId}/object',\n      },\n    }),\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n    TemplateURL: 'https://s3.bermuda-triangle-1337.amazonaws.com/use-me-use-me-123456789/object',\n  }));\n  expect(cfnMocks.executeChangeSet).toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "changeset is created when stack exists in REVIEW_IN_PROGRESS status",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 711,
                "column": 73
            },
            "line": 711,
            "code": "test('changeset is created when stack exists in REVIEW_IN_PROGRESS status', async () => {\n  // GIVEN\n  givenStackExists({\n    StackStatus: 'REVIEW_IN_PROGRESS',\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(\n    expect.objectContaining({\n      ChangeSetType: 'CREATE',\n      StackName: 'withouterrors',\n    }),\n  );\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "changeset is updated when stack exists in CREATE_COMPLETE status",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 737,
                "column": 70
            },
            "line": 737,
            "code": "test('changeset is updated when stack exists in CREATE_COMPLETE status', async () => {\n  // GIVEN\n  givenStackExists({\n    Tags: [\n      { Key: 'Key1', Value: 'Value1' },\n      { Key: 'Key2', Value: 'Value2' },\n    ],\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    deploymentMethod: { method: 'change-set', execute: false },\n  });\n\n  // THEN\n  expect(cfnMocks.createChangeSet).toHaveBeenCalledWith(\n    expect.objectContaining({\n      ChangeSetType: 'UPDATE',\n      StackName: 'withouterrors',\n    }),\n  );\n  expect(cfnMocks.executeChangeSet).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deploy with termination protection enabled",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 762,
                "column": 48
            },
            "line": 762,
            "code": "test('deploy with termination protection enabled', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n    stack: FAKE_STACK_TERMINATION_PROTECTION,\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).toHaveBeenCalledWith(expect.objectContaining({\n    EnableTerminationProtection: true,\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "updateTerminationProtection not called when termination protection is undefined",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 775,
                "column": 85
            },
            "line": 775,
            "code": "test('updateTerminationProtection not called when termination protection is undefined', async () => {\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).not.toHaveBeenCalled();\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "updateTerminationProtection called when termination protection is undefined and stack has termination protection",
            "suites": [
                "ci=true"
            ],
            "updatePoint": {
                "line": 785,
                "column": 118
            },
            "line": 785,
            "code": "test('updateTerminationProtection called when termination protection is undefined and stack has termination protection', async () => {\n  // GIVEN\n  givenStackExists({\n    EnableTerminationProtection: true,\n  });\n\n  // WHEN\n  await deployStack({\n    ...standardDeployStackArguments(),\n  });\n\n  // THEN\n  expect(cfnMocks.updateTerminationProtection).toHaveBeenCalledWith(expect.objectContaining({\n    EnableTerminationProtection: false,\n  }));\n});",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "by default, we do not disable rollback (and also do not pass the flag)",
            "suites": [
                "disable rollback"
            ],
            "updatePoint": {
                "line": 803,
                "column": 78
            },
            "line": 803,
            "code": "  test('by default, we do not disable rollback (and also do not pass the flag)', async () => {\n    // WHEN\n    await deployStack({\n      ...standardDeployStackArguments(),\n    });\n\n    // THEN\n    expect(cfnMocks.executeChangeSet).toHaveBeenCalledTimes(1);\n    expect(cfnMocks.executeChangeSet).not.toHaveBeenCalledWith(expect.objectContaining({\n      DisableRollback: expect.anything(),\n    }));\n  });",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "rollback can be disabled by setting rollback: false",
            "suites": [
                "disable rollback"
            ],
            "updatePoint": {
                "line": 816,
                "column": 59
            },
            "line": 816,
            "code": "  test('rollback can be disabled by setting rollback: false', async () => {\n    // WHEN\n    await deployStack({\n      ...standardDeployStackArguments(),\n      rollback: false,\n    });\n\n    // THEN\n    expect(cfnMocks.executeChangeSet).toHaveBeenCalledWith(expect.objectContaining({\n      DisableRollback: true,\n    }));\n  });",
            "file": "api/deploy-stack.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cli throws when manifest version > schema version",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 55
            },
            "line": 63,
            "code": "test('cli throws when manifest version > schema version', async () => {\n\n  const app = createApp();\n  const currentSchemaVersion = cxschema.Manifest.version();\n  const mockManifestVersion = semver.inc(currentSchemaVersion, 'major');\n\n  // this mock will cause the framework to use a greater schema version than the real one,\n  // and should cause the CLI to fail.\n  const mockVersionNumber = ImportMock.mockFunction(cxschema.Manifest, 'version', mockManifestVersion);\n  try {\n    app.synth();\n  } finally {\n    mockVersionNumber.restore();\n  }\n\n  const expectedError = 'This CDK CLI is not compatible with the CDK library used by your application. Please upgrade the CLI to the latest version.'\n    + `\\n(Cloud assembly schema version mismatch: Maximum schema version supported is ${currentSchemaVersion}, but found ${mockManifestVersion})`;\n\n  config.settings.set(['app'], 'cdk.out');\n\n  await expect(execProgram(sdkProvider, config)).rejects.toEqual(new Error(expectedError));\n\n}, TEN_SECOND_TIMEOUT);",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cli does not throw when manifest version = schema version",
            "suites": [],
            "updatePoint": {
                "line": 87,
                "column": 63
            },
            "line": 87,
            "code": "test('cli does not throw when manifest version = schema version', async () => {\n\n  const app = createApp();\n  app.synth();\n\n  config.settings.set(['app'], 'cdk.out');\n\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n\n}, TEN_SECOND_TIMEOUT);",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cli does not throw when manifest version < schema version",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 63
            },
            "line": 99,
            "code": "test('cli does not throw when manifest version < schema version', async () => {\n\n  const app = createApp();\n  const currentSchemaVersion = cxschema.Manifest.version();\n\n  app.synth();\n\n  config.settings.set(['app'], 'cdk.out');\n\n  // this mock will cause the cli to think its exepcted schema version is\n  // greater that the version created in the manifest, which is what we are testing for.\n  const mockVersionNumber = ImportMock.mockFunction(cxschema.Manifest, 'version', semver.inc(currentSchemaVersion, 'major'));\n  try {\n    const { lock } = await execProgram(sdkProvider, config);\n    await lock.release();\n  } finally {\n    mockVersionNumber.restore();\n  }\n\n}, TEN_SECOND_TIMEOUT);",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validates --app key is present",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 36
            },
            "line": 120,
            "code": "test('validates --app key is present', async () => {\n  // GIVEN no config key for `app`\n  await expect(execProgram(sdkProvider, config)).rejects.toThrow(\n    '--app is required either in command-line, in cdk.json or in ~/.cdk.json',\n  );\n\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bypasses synth when app points to a cloud assembly",
            "suites": [],
            "updatePoint": {
                "line": 128,
                "column": 56
            },
            "line": 128,
            "code": "test('bypasses synth when app points to a cloud assembly', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cdk.out');\n  writeOutputAssembly();\n\n  // WHEN\n  const { assembly: cloudAssembly, lock } = await execProgram(sdkProvider, config);\n  expect(cloudAssembly.artifacts).toEqual([]);\n  expect(cloudAssembly.directory).toEqual('cdk.out');\n\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "the application set in --app is executed",
            "suites": [],
            "updatePoint": {
                "line": 141,
                "column": 46
            },
            "line": 141,
            "code": "test('the application set in --app is executed', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cloud-executable');\n  mockSpawn({\n    commandLine: 'cloud-executable',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "the application set in --app is executed as-is if it contains a filename that does not exist",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 98
            },
            "line": 154,
            "code": "test('the application set in --app is executed as-is if it contains a filename that does not exist', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'does-not-exist');\n  mockSpawn({\n    commandLine: 'does-not-exist',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "the application set in --app is executed with arguments",
            "suites": [],
            "updatePoint": {
                "line": 167,
                "column": 61
            },
            "line": 167,
            "code": "test('the application set in --app is executed with arguments', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'cloud-executable an-arg');\n  mockSpawn({\n    commandLine: 'cloud-executable an-arg',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "application set in --app as `*.js` always uses handler on windows",
            "suites": [],
            "updatePoint": {
                "line": 180,
                "column": 71
            },
            "line": 180,
            "code": "test('application set in --app as `*.js` always uses handler on windows', async () => {\n  // GIVEN\n  sinon.stub(process, 'platform').value('win32');\n  config.settings.set(['app'], 'windows.js');\n  mockSpawn({\n    commandLine: process.execPath + ' windows.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "application set in --app is `*.js` and executable",
            "suites": [],
            "updatePoint": {
                "line": 194,
                "column": 55
            },
            "line": 194,
            "code": "test('application set in --app is `*.js` and executable', async () => {\n  // GIVEN\n  config.settings.set(['app'], 'executable-app.js');\n  mockSpawn({\n    commandLine: 'executable-app.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n});",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cli throws when the `build` script fails",
            "suites": [],
            "updatePoint": {
                "line": 207,
                "column": 46
            },
            "line": 207,
            "code": "test('cli throws when the `build` script fails', async () => {\n  // GIVEN\n  config.settings.set(['build'], 'fake-command');\n  mockSpawn({\n    commandLine: 'fake-command',\n    exitCode: 127,\n  });\n\n  // WHEN\n  await expect(execProgram(sdkProvider, config)).rejects.toEqual(new Error('Subprocess exited with error 127'));\n}, TEN_SECOND_TIMEOUT);",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cli does not throw when the `build` script succeeds",
            "suites": [],
            "updatePoint": {
                "line": 219,
                "column": 57
            },
            "line": 219,
            "code": "test('cli does not throw when the `build` script succeeds', async () => {\n  // GIVEN\n  config.settings.set(['build'], 'real command');\n  config.settings.set(['app'], 'executable-app.js');\n  mockSpawn({\n    commandLine: 'real command', // `build` key is not split on whitespace\n    exitCode: 0,\n  },\n  {\n    commandLine: 'executable-app.js',\n    sideEffect: () => writeOutputAssembly(),\n  });\n\n  // WHEN\n  const { lock } = await execProgram(sdkProvider, config);\n  await lock.release();\n}, TEN_SECOND_TIMEOUT);",
            "file": "api/exec.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 17,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test(`A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'UNIT',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'UNIT',\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateResolver).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      typeName: 'Query',\n      fieldName: 'myField',\n      kind: 'UNIT',\n      requestMappingTemplate: '## new request template',\n      responseMappingTemplate: '## original response template',\n    });\n  });\n\n  test('does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'PIPELINE',\n            PipelineConfig: ['function1'],\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'PIPELINE',\n              PipelineConfig: ['function1'],\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ResponseMappingTemplate: '## original response template',\n            RequestMappingTemplate: '## original request template',\n            FieldName: 'oldField',\n            ApiId: 'apiId',\n            TypeName: 'Query',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ResponseMappingTemplate: '## original response template',\n              RequestMappingTemplate: '## new request template',\n              FieldName: 'newField',\n              ApiId: 'apiId',\n              TypeName: 'Query',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        typeName: 'Query',\n        fieldName: 'oldField',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n    }\n  });\n\n  test('does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::NotAResolver',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            FieldName: 'oldField',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::NotAResolver',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              FieldName: 'newField',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateFunction() API when it receives only a mapping template difference in a Function', async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n            FunctionVersion: '2018-05-29',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              Name: 'my-function',\n              ApiId: 'apiId',\n              DataSourceName: 'my-datasource',\n              FunctionVersion: '2018-05-29',\n              RequestMappingTemplate: '## original request template',\n              ResponseMappingTemplate: '## new response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateFunction).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      functionId: 'functionId',\n      functionVersion: '2018-05-29',\n      name: 'my-function',\n      requestMappingTemplate: '## original request template',\n      responseMappingTemplate: '## new response template',\n    });\n  });\n\n  test(`when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n              ApiId: 'apiId',\n              Name: 'my-function',\n              DataSourceName: 'new-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        dataSourceName: 'my-datasource',\n        functionId: 'functionId',\n        name: 'my-function',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n\n  test('does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::NotAFunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            Name: 'my-function',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::NotAFunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              Name: 'my-resolver',\n              DataSourceName: 'my-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });\n});",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 43
            },
            "line": 18,
            "code": "  test(`A new Resolver being added to the Stack returns undefined in CLASSIC mode and\n        returns a noOp in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 109
            },
            "line": 52,
            "code": "  test('calls the updateResolver() API when it receives only a mapping template difference in a Unit Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'UNIT',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'UNIT',\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateResolver).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      typeName: 'Query',\n      fieldName: 'myField',\n      kind: 'UNIT',\n      requestMappingTemplate: '## new request template',\n      responseMappingTemplate: '## original response template',\n    });\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver",
            "suites": [],
            "updatePoint": {
                "line": 118,
                "column": 121
            },
            "line": 118,
            "code": "  test('does not call the updateResolver() API when it receives only a mapping template difference in a Pipeline Resolver', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ApiId: 'apiId',\n            FieldName: 'myField',\n            TypeName: 'Query',\n            DataSourceName: 'my-datasource',\n            Kind: 'PIPELINE',\n            PipelineConfig: ['function1'],\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ApiId: 'apiId',\n              FieldName: 'myField',\n              TypeName: 'Query',\n              DataSourceName: 'my-datasource',\n              Kind: 'PIPELINE',\n              PipelineConfig: ['function1'],\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 184,
                "column": 67
            },
            "line": 183,
            "code": "  test(`when it receives a change that is not a mapping template difference in a Resolver, it does not call the updateResolver() API in CLASSIC mode\n        but does call the updateResolver() API in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::Resolver',\n          Properties: {\n            ResponseMappingTemplate: '## original response template',\n            RequestMappingTemplate: '## original request template',\n            FieldName: 'oldField',\n            ApiId: 'apiId',\n            TypeName: 'Query',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf(\n        'AppSyncResolver',\n        'AWS::AppSync::Resolver',\n        'arn:aws:appsync:us-east-1:111111111111:apis/apiId/types/Query/resolvers/myField',\n      ),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::Resolver',\n            Properties: {\n              ResponseMappingTemplate: '## original response template',\n              RequestMappingTemplate: '## new request template',\n              FieldName: 'newField',\n              ApiId: 'apiId',\n              TypeName: 'Query',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        typeName: 'Query',\n        fieldName: 'oldField',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed",
            "suites": [],
            "updatePoint": {
                "line": 253,
                "column": 146
            },
            "line": 253,
            "code": "  test('does not call the updateResolver() API when a resource with type that is not AWS::AppSync::Resolver but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncResolver: {\n          Type: 'AWS::AppSync::NotAResolver',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            FieldName: 'oldField',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncResolver: {\n            Type: 'AWS::AppSync::NotAResolver',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              FieldName: 'newField',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateFunction() API when it receives only a mapping template difference in a Function",
            "suites": [],
            "updatePoint": {
                "line": 303,
                "column": 104
            },
            "line": 303,
            "code": "  test('calls the updateFunction() API when it receives only a mapping template difference in a Function', async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n            FunctionVersion: '2018-05-29',\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              Name: 'my-function',\n              ApiId: 'apiId',\n              DataSourceName: 'my-datasource',\n              FunctionVersion: '2018-05-29',\n              RequestMappingTemplate: '## original request template',\n              ResponseMappingTemplate: '## new response template',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateFunction).toHaveBeenCalledWith({\n      apiId: 'apiId',\n      dataSourceName: 'my-datasource',\n      functionId: 'functionId',\n      functionVersion: '2018-05-29',\n      name: 'my-function',\n      requestMappingTemplate: '## original request template',\n      responseMappingTemplate: '## new response template',\n    });\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 364,
                "column": 37
            },
            "line": 363,
            "code": "  test(`when it receives a change that is not a mapping template difference in a Function, it does not call the updateFunction() API in CLASSIC mode\n        but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    const mockListFunctions = jest.fn().mockReturnValue({ functions: [{ name: 'my-function', functionId: 'functionId' }] });\n    hotswapMockSdkProvider.stubAppSync({ listFunctions: mockListFunctions, updateFunction: mockUpdateFunction });\n\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::FunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original request template',\n            ResponseMappingTemplate: '## original response template',\n            Name: 'my-function',\n            ApiId: 'apiId',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::FunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new request template',\n              ResponseMappingTemplate: '## original response template',\n              ApiId: 'apiId',\n              Name: 'my-function',\n              DataSourceName: 'new-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateFunction).toHaveBeenCalledWith({\n        apiId: 'apiId',\n        dataSourceName: 'my-datasource',\n        functionId: 'functionId',\n        name: 'my-function',\n        requestMappingTemplate: '## new request template',\n        responseMappingTemplate: '## original response template',\n      });\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed",
            "suites": [],
            "updatePoint": {
                "line": 430,
                "column": 159
            },
            "line": 430,
            "code": "  test('does not call the updateFunction() API when a resource with type that is not AWS::AppSync::FunctionConfiguration but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        AppSyncFunction: {\n          Type: 'AWS::AppSync::NotAFunctionConfiguration',\n          Properties: {\n            RequestMappingTemplate: '## original template',\n            Name: 'my-function',\n            DataSourceName: 'my-datasource',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          AppSyncFunction: {\n            Type: 'AWS::AppSync::NotAFunctionConfiguration',\n            Properties: {\n              RequestMappingTemplate: '## new template',\n              Name: 'my-resolver',\n              DataSourceName: 'my-datasource',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateFunction).not.toHaveBeenCalled();\n      expect(mockUpdateResolver).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/appsync-mapping-templates-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 15,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new CodeBuild Project is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateProject() API when it receives only a source difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test('calls the updateProject() API when it receives only a source version difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            SourceVersion: 'v1',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              SourceVersion: 'v2',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      sourceVersion: 'v2',\n    });\n  });\n\n  test('calls the updateProject() API when it receives only an environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            Environment: {\n              ComputeType: 'BUILD_GENERAL1_SMALL',\n              EnvironmentVariables: [\n                {\n                  Name: 'SUPER_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'super cool value',\n                },\n                {\n                  Name: 'SECOND_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'yet another super cool value',\n                },\n              ],\n              Image: 'aws/codebuild/standard:1.0',\n              ImagePullCredentialsType: 'CODEBUILD',\n              PrivilegedMode: false,\n              Type: 'LINUX_CONTAINER',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              Environment: {\n                ComputeType: 'BUILD_GENERAL1_SMALL',\n                EnvironmentVariables: [\n                  {\n                    Name: 'SUPER_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'changed value',\n                  },\n                  {\n                    Name: 'NEW_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'new value',\n                  },\n                ],\n                Image: 'aws/codebuild/standard:1.0',\n                ImagePullCredentialsType: 'CODEBUILD',\n                PrivilegedMode: false,\n                Type: 'LINUX_CONTAINER',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      environment: {\n        computeType: 'BUILD_GENERAL1_SMALL',\n        environmentVariables: [\n          {\n            name: 'SUPER_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'changed value',\n          },\n          {\n            name: 'NEW_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'new value',\n          },\n        ],\n        image: 'aws/codebuild/standard:1.0',\n        imagePullCredentialsType: 'CODEBUILD',\n        privilegedMode: false,\n        type: 'LINUX_CONTAINER',\n      },\n    });\n  });\n\n  test(\"correctly evaluates the project's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: {\n              'Fn::Join': ['-', [\n                { Ref: 'Bucket' },\n                'project',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: {\n                'Fn::Join': ['-', [\n                  { Ref: 'Bucket' },\n                  'project',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mybucket-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test(\"correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::Sub': '${Param1}' },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::Sub': '${Param1}' },\n                Type: 'CODEPIPELINE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                Type: 'S3',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('calls the updateProject() API when it receives a difference in a CodeBuild project with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mock-project-resource-id',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });\n\n  test('does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateProject).toHaveBeenCalledWith({\n        name: 'mock-project-resource-id',\n        source: {\n          type: 'NO_SOURCE',\n          buildspec: 'new-spec',\n        },\n      });\n    }\n  });\n  test('does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::NotCodeBuild::NotAProject',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::NotCodeBuild::NotAProject',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });\n});",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns undefined when a new CodeBuild Project is added to the Stack",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 76
            },
            "line": 16,
            "code": "  test('returns undefined when a new CodeBuild Project is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateProject() API when it receives only a source difference in a CodeBuild project",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 102
            },
            "line": 46,
            "code": "  test('calls the updateProject() API when it receives only a source difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateProject() API when it receives only a source version difference in a CodeBuild project",
            "suites": [],
            "updatePoint": {
                "line": 99,
                "column": 110
            },
            "line": 99,
            "code": "  test('calls the updateProject() API when it receives only a source version difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            SourceVersion: 'v1',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              SourceVersion: 'v2',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      sourceVersion: 'v2',\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateProject() API when it receives only an environment difference in a CodeBuild project",
            "suites": [],
            "updatePoint": {
                "line": 151,
                "column": 108
            },
            "line": 151,
            "code": "  test('calls the updateProject() API when it receives only an environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: 'my-project',\n            Environment: {\n              ComputeType: 'BUILD_GENERAL1_SMALL',\n              EnvironmentVariables: [\n                {\n                  Name: 'SUPER_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'super cool value',\n                },\n                {\n                  Name: 'SECOND_IMPORTANT_ENV_VAR',\n                  Type: 'PLAINTEXT',\n                  Value: 'yet another super cool value',\n                },\n              ],\n              Image: 'aws/codebuild/standard:1.0',\n              ImagePullCredentialsType: 'CODEBUILD',\n              PrivilegedMode: false,\n              Type: 'LINUX_CONTAINER',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: 'my-project',\n              Environment: {\n                ComputeType: 'BUILD_GENERAL1_SMALL',\n                EnvironmentVariables: [\n                  {\n                    Name: 'SUPER_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'changed value',\n                  },\n                  {\n                    Name: 'NEW_IMPORTANT_ENV_VAR',\n                    Type: 'PLAINTEXT',\n                    Value: 'new value',\n                  },\n                ],\n                Image: 'aws/codebuild/standard:1.0',\n                ImagePullCredentialsType: 'CODEBUILD',\n                PrivilegedMode: false,\n                Type: 'LINUX_CONTAINER',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      environment: {\n        computeType: 'BUILD_GENERAL1_SMALL',\n        environmentVariables: [\n          {\n            name: 'SUPER_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'changed value',\n          },\n          {\n            name: 'NEW_IMPORTANT_ENV_VAR',\n            type: 'PLAINTEXT',\n            value: 'new value',\n          },\n        ],\n        image: 'aws/codebuild/standard:1.0',\n        imagePullCredentialsType: 'CODEBUILD',\n        privilegedMode: false,\n        type: 'LINUX_CONTAINER',\n      },\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly evaluates the project's name when it references a different resource from the template",
            "suites": [],
            "updatePoint": {
                "line": 257,
                "column": 104
            },
            "line": 257,
            "code": "  test(\"correctly evaluates the project's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: {\n              'Fn::Join': ['-', [\n                { Ref: 'Bucket' },\n                'project',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: {\n                'Fn::Join': ['-', [\n                  { Ref: 'Bucket' },\n                  'project',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mybucket-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template",
            "suites": [],
            "updatePoint": {
                "line": 327,
                "column": 120
            },
            "line": 327,
            "code": "  test(\"correctly falls back to taking the project's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            Name: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              Name: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'my-project',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)",
            "suites": [],
            "updatePoint": {
                "line": 389,
                "column": 105
            },
            "line": 389,
            "code": "  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::Sub': '${Param1}' },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::Sub': '${Param1}' },\n                Type: 'CODEPIPELINE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)",
            "suites": [],
            "updatePoint": {
                "line": 439,
                "column": 128
            },
            "line": 439,
            "code": "  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the project's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'my-project'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                Type: 'S3',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateProject() API when it receives a difference in a CodeBuild project with no name",
            "suites": [],
            "updatePoint": {
                "line": 492,
                "column": 103
            },
            "line": 492,
            "code": "  test('calls the updateProject() API when it receives a difference in a CodeBuild project with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateProject).toHaveBeenCalledWith({\n      name: 'mock-project-resource-id',\n      source: {\n        type: 'NO_SOURCE',\n        buildspec: 'new-spec',\n      },\n    });\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project",
            "suites": [],
            "updatePoint": {
                "line": 544,
                "column": 155
            },
            "line": 544,
            "code": "  test('does not call the updateProject() API when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'current-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 596,
                "column": 98
            },
            "line": 595,
            "code": "  test(`when it receives a change that is not Source, SourceVersion, or Environment difference in a CodeBuild project alongside a hotswappable change,\n        it does not call the updateProject() API in CLASSIC mode, but it does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n            ConcurrentBuildLimit: 1,\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::CodeBuild::Project',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n              ConcurrentBuildLimit: 2,\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('CodeBuildProject', 'AWS::CodeBuild::Project', 'mock-project-resource-id'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateProject).toHaveBeenCalledWith({\n        name: 'mock-project-resource-id',\n        source: {\n          type: 'NO_SOURCE',\n          buildspec: 'new-spec',\n        },\n      });\n    }\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed",
            "suites": [],
            "updatePoint": {
                "line": 653,
                "column": 146
            },
            "line": 653,
            "code": "  test('does not call the updateProject() API when a resource with type that is not AWS::CodeBuild::Project but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        CodeBuildProject: {\n          Type: 'AWS::NotCodeBuild::NotAProject',\n          Properties: {\n            Source: {\n              BuildSpec: 'current-spec',\n              Type: 'NO_SOURCE',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          CodeBuildProject: {\n            Type: 'AWS::NotCodeBuild::NotAProject',\n            Properties: {\n              Source: {\n                BuildSpec: 'new-spec',\n                Type: 'NO_SOURCE',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateProject).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/code-build-projects-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 33,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n\n  test('any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n              Cpu: '512',\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n\n  test('a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n\n      expect(mockUpdateService).not.toHaveBeenCalledWith();\n    }\n  });\n\n  test('if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n        Function: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Environment: {\n              Variables: {\n                TaskDefRevArn: { Ref: 'TaskDef' },\n              },\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n          Function: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Environment: {\n                Variables: {\n                  TaskDefRevArn: { Ref: 'TaskDef' },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });\n\n  test('should call registerTaskDefinition with certain properties not lowercased', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Volumes: [\n              {\n                DockerVolumeConfiguration: {\n                  DriverOpts: { Option1: 'option1' },\n                  Labels: { Label1: 'label1' },\n                },\n              },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                {\n                  Image: 'image2',\n                  DockerLabels: { Label1: 'label1' },\n                  FirelensConfiguration: {\n                    Options: { Name: 'cloudwatch' },\n                  },\n                  LogConfiguration: {\n                    Options: { Option1: 'option1' },\n                  },\n                },\n              ],\n              Volumes: [\n                {\n                  DockerVolumeConfiguration: {\n                    DriverOpts: { Option1: 'option1' },\n                    Labels: { Label1: 'label1' },\n                  },\n                },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        {\n          image: 'image2',\n          dockerLabels: { Label1: 'label1' },\n          firelensConfiguration: {\n            options: {\n              Name: 'cloudwatch',\n            },\n          },\n          logConfiguration: {\n            options: { Option1: 'option1' },\n          },\n        },\n      ],\n      volumes: [\n        {\n          dockerVolumeConfiguration: {\n            driverOpts: { Option1: 'option1' },\n            labels: { Label1: 'label1' },\n          },\n        },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });\n});",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 127
            },
            "line": 34,
            "code": "  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition with a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments",
            "suites": [],
            "updatePoint": {
                "line": 108,
                "column": 162
            },
            "line": 108,
            "code": "  test('any other TaskDefinition property change besides ContainerDefinition cannot be hotswapped in CLASSIC mode but does not block HOTSWAP_ONLY mode deployments', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n              Cpu: '512',\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 195,
                "column": 169
            },
            "line": 195,
            "code": "  test('deleting any other TaskDefinition property besides ContainerDefinition results in a full deployment in CLASSIC mode and a hotswap deployment in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Cpu: '256',\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n        cpu: '256', // this uses the old value because a new value could cause a service replacement\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property",
            "suites": [],
            "updatePoint": {
                "line": 281,
                "column": 130
            },
            "line": 281,
            "code": "  test('should call registerTaskDefinition and updateService for a difference only in the TaskDefinition without a Family property', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        { image: 'image2' },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode",
            "suites": [],
            "updatePoint": {
                "line": 355,
                "column": 115
            },
            "line": 355,
            "code": "  test('a difference just in a TaskDefinition, without any services using it, is not hotswappable in FALL_BACK mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('TaskDef', 'AWS::ECS::TaskDefinition',\n        'arn:aws:ecs:region:account:task-definition/my-task-def:2'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n\n      expect(mockUpdateService).not.toHaveBeenCalledWith();\n    }\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 418,
                "column": 157
            },
            "line": 418,
            "code": "  test('if anything besides an ECS Service references the changed TaskDefinition, hotswapping is not possible in CLASSIC mode but is possible in HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n        Function: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Environment: {\n              Variables: {\n                TaskDefRevArn: { Ref: 'TaskDef' },\n              },\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                { Image: 'image2' },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n          Function: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Environment: {\n                Variables: {\n                  TaskDefRevArn: { Ref: 'TaskDef' },\n                },\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockRegisterTaskDef).not.toHaveBeenCalled();\n      expect(mockUpdateService).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockRegisterTaskDef).toBeCalledWith({\n        family: 'my-task-def',\n        containerDefinitions: [\n          { image: 'image2' },\n        ],\n      });\n      expect(mockUpdateService).toBeCalledWith({\n        service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n        cluster: 'my-cluster',\n        taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n        deploymentConfiguration: {\n          minimumHealthyPercent: 0,\n        },\n        forceNewDeployment: true,\n      });\n    }\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "should call registerTaskDefinition with certain properties not lowercased",
            "suites": [],
            "updatePoint": {
                "line": 522,
                "column": 81
            },
            "line": 522,
            "code": "  test('should call registerTaskDefinition with certain properties not lowercased', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        TaskDef: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'my-task-def',\n            ContainerDefinitions: [\n              { Image: 'image1' },\n            ],\n            Volumes: [\n              {\n                DockerVolumeConfiguration: {\n                  DriverOpts: { Option1: 'option1' },\n                  Labels: { Label1: 'label1' },\n                },\n              },\n            ],\n          },\n        },\n        Service: {\n          Type: 'AWS::ECS::Service',\n          Properties: {\n            TaskDefinition: { Ref: 'TaskDef' },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Service', 'AWS::ECS::Service',\n        'arn:aws:ecs:region:account:service/my-cluster/my-service'),\n    );\n    mockRegisterTaskDef.mockReturnValue({\n      taskDefinition: {\n        taskDefinitionArn: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          TaskDef: {\n            Type: 'AWS::ECS::TaskDefinition',\n            Properties: {\n              Family: 'my-task-def',\n              ContainerDefinitions: [\n                {\n                  Image: 'image2',\n                  DockerLabels: { Label1: 'label1' },\n                  FirelensConfiguration: {\n                    Options: { Name: 'cloudwatch' },\n                  },\n                  LogConfiguration: {\n                    Options: { Option1: 'option1' },\n                  },\n                },\n              ],\n              Volumes: [\n                {\n                  DockerVolumeConfiguration: {\n                    DriverOpts: { Option1: 'option1' },\n                    Labels: { Label1: 'label1' },\n                  },\n                },\n              ],\n            },\n          },\n          Service: {\n            Type: 'AWS::ECS::Service',\n            Properties: {\n              TaskDefinition: { Ref: 'TaskDef' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockRegisterTaskDef).toBeCalledWith({\n      family: 'my-task-def',\n      containerDefinitions: [\n        {\n          image: 'image2',\n          dockerLabels: { Label1: 'label1' },\n          firelensConfiguration: {\n            options: {\n              Name: 'cloudwatch',\n            },\n          },\n          logConfiguration: {\n            options: { Option1: 'option1' },\n          },\n        },\n      ],\n      volumes: [\n        {\n          dockerVolumeConfiguration: {\n            driverOpts: { Option1: 'option1' },\n            labels: { Label1: 'label1' },\n          },\n        },\n      ],\n    });\n    expect(mockUpdateService).toBeCalledWith({\n      service: 'arn:aws:ecs:region:account:service/my-cluster/my-service',\n      cluster: 'my-cluster',\n      taskDefinition: 'arn:aws:ecs:region:account:task-definition/my-task-def:3',\n      deploymentConfiguration: {\n        minimumHealthyPercent: 0,\n      },\n      forceNewDeployment: true,\n    });\n  });",
            "file": "api/hotswap/ecs-services-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 24,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns a deployStackResult with noOp=true when it receives an empty set of changes', async () => {\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, setup.cdkStackArtifactOf());\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toBeTruthy();\n    expect(deployStackResult?.stackArn).toEqual(setup.STACK_ID);\n  });\n\n  test('A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('changes only to CDK::Metadata result in a noOp', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        MetaData: {\n          Type: 'AWS::CDK::Metadata',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          MetaData: {\n            Type: 'AWS::CDK::Metadata',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });\n\n  test('resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf();\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('can correctly reference AWS::Partition in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': [\n                '',\n                [\n                  { Ref: 'AWS::Partition' },\n                  '-',\n                  'my-function',\n                ],\n              ],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'new-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': [\n                  '',\n                  [\n                    { Ref: 'AWS::Partition' },\n                    '-',\n                    'my-function',\n                  ],\n                ],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'aws-my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('can correctly reference AWS::URLSuffix in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['', [\n                'my-function-',\n                { Ref: 'AWS::URLSuffix' },\n                '-',\n                { Ref: 'AWS::URLSuffix' },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['', [\n                  'my-function-',\n                  { Ref: 'AWS::URLSuffix' },\n                  '-',\n                  { Ref: 'AWS::URLSuffix' },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function-amazonaws.com-amazonaws.com',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockGetEndpointSuffix).toHaveBeenCalledTimes(1);\n\n    // the User-Agent is set correctly\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.appendCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.removeCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n  });\n\n  test('changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SharedLogicalId: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'new-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SharedLogicalId: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n      Outputs: {\n        SomeOutput: {\n          Value: 'old-value',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n        Outputs: {\n          SomeOutput: {\n            Value: 'new-value',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('Multiple CfnEvaluationException will not cause unhandled rejections', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func1: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        Func2: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func1: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          Func2: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(deployStackResult).rejects.toThrowError(CfnEvaluationException);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });\n\n  test('deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });\n});",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns a deployStackResult with noOp=true when it receives an empty set of changes",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 91
            },
            "line": 25,
            "code": "  test('returns a deployStackResult with noOp=true when it receives an empty set of changes', async () => {\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, setup.cdkStackArtifactOf());\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toBeTruthy();\n    expect(deployStackResult?.stackArn).toEqual(setup.STACK_ID);\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 121
            },
            "line": 35,
            "code": "  test('A change to only a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 149
            },
            "line": 80,
            "code": "  test('A change to both a hotswappable resource and a non-hotswappable resource results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        SomethingElse: {\n          Type: 'AWS::CloudFormation::SomethingElse',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          SomethingElse: {\n            Type: 'AWS::CloudFormation::SomethingElse',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "changes only to CDK::Metadata result in a noOp",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 54
            },
            "line": 154,
            "code": "  test('changes only to CDK::Metadata result in a noOp', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        MetaData: {\n          Type: 'AWS::CDK::Metadata',\n          Properties: {\n            Prop: 'old-value',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          MetaData: {\n            Type: 'AWS::CDK::Metadata',\n            Properties: {\n              Prop: 'new-value',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 189,
                "column": 91
            },
            "line": 189,
            "code": "  test('resource deletions require full deployments for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf();\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can correctly reference AWS::Partition in hotswappable changes",
            "suites": [],
            "updatePoint": {
                "line": 220,
                "column": 70
            },
            "line": 220,
            "code": "  test('can correctly reference AWS::Partition in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': [\n                '',\n                [\n                  { Ref: 'AWS::Partition' },\n                  '-',\n                  'my-function',\n                ],\n              ],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'new-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': [\n                  '',\n                  [\n                    { Ref: 'AWS::Partition' },\n                    '-',\n                    'my-function',\n                  ],\n                ],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'aws-my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can correctly reference AWS::URLSuffix in hotswappable changes",
            "suites": [],
            "updatePoint": {
                "line": 289,
                "column": 70
            },
            "line": 289,
            "code": "  test('can correctly reference AWS::URLSuffix in hotswappable changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['', [\n                'my-function-',\n                { Ref: 'AWS::URLSuffix' },\n                '-',\n                { Ref: 'AWS::URLSuffix' },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['', [\n                  'my-function-',\n                  { Ref: 'AWS::URLSuffix' },\n                  '-',\n                  { Ref: 'AWS::URLSuffix' },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function-amazonaws.com-amazonaws.com',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockGetEndpointSuffix).toHaveBeenCalledTimes(1);\n\n    // the User-Agent is set correctly\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.appendCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n    expect(hotswapMockSdkProvider.mockSdkProvider.sdk.removeCustomUserAgent)\n      .toHaveBeenCalledWith('cdk-hotswap/success-lambda');\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 361,
                "column": 124
            },
            "line": 361,
            "code": "  test('changing the type of a deployed resource always results in a full deployment for HOTSWAP and a noOp for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        SharedLogicalId: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'new-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          SharedLogicalId: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 411,
                "column": 150
            },
            "line": 411,
            "code": "  test('A change to both a hotswappable resource and a stack output results in a full deployment for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n      Outputs: {\n        SomeOutput: {\n          Value: 'old-value',\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n        Outputs: {\n          SomeOutput: {\n            Value: 'new-value',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Multiple CfnEvaluationException will not cause unhandled rejections",
            "suites": [],
            "updatePoint": {
                "line": 483,
                "column": 75
            },
            "line": 483,
            "code": "  test('Multiple CfnEvaluationException will not cause unhandled rejections', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func1: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n        Func2: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            Environment: {\n              key: 'old',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func1: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n          Func2: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              Environment: {\n                key: { Ref: 'ErrorResource' },\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(deployStackResult).rejects.toThrowError(CfnEvaluationException);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 569,
                "column": 142
            },
            "line": 569,
            "code": "  test('deleting a resource and making a hotswappable change results in full deployments for HOTSWAP and a hotswap deployment for HOTSWAP_ONLY', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });",
            "file": "api/hotswap/hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 33,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ImageUri: 'new-image',\n    });\n  });\n\n  test('calls the getFunction() API with a delay of 5', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });\n});",
            "file": "api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaCode() API when it receives only a code difference in a Lambda function",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 101
            },
            "line": 34,
            "code": "  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ImageUri: 'new-image',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the getFunction() API with a delay of 5",
            "suites": [],
            "updatePoint": {
                "line": 82,
                "column": 53
            },
            "line": 82,
            "code": "  test('calls the getFunction() API with a delay of 5', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ImageUri: 'current-image',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ImageUri: 'new-image',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });",
            "file": "api/hotswap/lambda-functions-docker-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 30,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new Lambda function is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"correctly evaluates the function's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['-', [\n                'lambda',\n                { Ref: 'Bucket' },\n                'function',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['-', [\n                  'lambda',\n                  { Ref: 'Bucket' },\n                  'function',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'lambda-mybucket-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { Ref: 'AssetBucketParam' },\n              S3Key: 'current-key',\n            },\n            FunctionName: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { Ref: 'AssetBucketParam' },\n                S3Key: 'new-key',\n              },\n              FunctionName: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'asset-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::Sub': '${Param1}' },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::Sub': '${Param1}' },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'mock-function-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'mock-function-resource-id',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test(`when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });\n\n  test('does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::NotLambda::NotAFunction',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::NotLambda::NotAFunction',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls getFunction() after function code is updated with delay 1', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });\n\n  test('calls getFunction() after function code is updated and VpcId is empty string with delay 1', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: '',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });\n\n  test('calls getFunction() after function code is updated on a VPC function with delay 5', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: 'abc',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });\n\n  test('calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n  });\n\n  test('calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                Key1: 'Value1',\n                Key2: 'Value2',\n              },\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  Key1: 'Value1',\n                  Key2: 'Value2',\n                  NewKey: 'NewValue',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          Key1: 'Value1',\n          Key2: 'Value2',\n          NewKey: 'NewValue',\n        },\n      },\n    });\n  });\n\n  test('calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'new-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('Lambda hotswap works properly with changes of environment variables and description with tokens', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                literal: 'oldValue',\n              },\n            },\n            Description: {\n              'Fn::Join': ['', [\n                'oldValue',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  literal: 'newValue',\n                },\n              },\n              Description: {\n                'Fn::Join': ['', [\n                  'newValue',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          token: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n          literal: 'newValue',\n        },\n      },\n      Description: 'newValuearn:aws:events:here:123456789012:event-bus/my-event-bus',\n    });\n  });\n\n  test('S3ObjectVersion is hotswappable', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Key: 'current-key',\n              S3ObjectVersion: 'current-obj',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Key: 'new-key',\n                S3ObjectVersion: 'new-obj',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Key: 'new-key',\n      S3ObjectVersion: 'new-obj',\n    });\n  });\n});",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns undefined when a new Lambda function is added to the Stack",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 74
            },
            "line": 31,
            "code": "  test('returns undefined when a new Lambda function is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaCode() API when it receives only a code difference in a Lambda function",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 101
            },
            "line": 60,
            "code": "  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly evaluates the function's name when it references a different resource from the template",
            "suites": [],
            "updatePoint": {
                "line": 111,
                "column": 105
            },
            "line": 111,
            "code": "  test(\"correctly evaluates the function's name when it references a different resource from the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: {\n              'Fn::Join': ['-', [\n                'lambda',\n                { Ref: 'Bucket' },\n                'function',\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'mybucket'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: {\n                'Fn::Join': ['-', [\n                  'lambda',\n                  { Ref: 'Bucket' },\n                  'function',\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'lambda-mybucket-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template",
            "suites": [],
            "updatePoint": {
                "line": 181,
                "column": 121
            },
            "line": 181,
            "code": "  test(\"correctly falls back to taking the function's name from the current stack if it can't evaluate it in the template\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n        AssetBucketParam: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { Ref: 'AssetBucketParam' },\n              S3Key: 'current-key',\n            },\n            FunctionName: { Ref: 'Param1' },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n          AssetBucketParam: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { Ref: 'AssetBucketParam' },\n                S3Key: 'new-key',\n              },\n              FunctionName: { Ref: 'Param1' },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetBucketParam: 'asset-bucket' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'asset-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)",
            "suites": [],
            "updatePoint": {
                "line": 241,
                "column": 106
            },
            "line": 241,
            "code": "  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::Sub': '${Param1}' },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::Sub': '${Param1}' },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)",
            "suites": [],
            "updatePoint": {
                "line": 291,
                "column": 129
            },
            "line": 291,
            "code": "  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the function's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name",
            "suites": [],
            "updatePoint": {
                "line": 344,
                "column": 109
            },
            "line": 344,
            "code": "  test('calls the updateLambdaCode() API when it receives a code difference in a Lambda function with no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'current-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'current-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'mock-function-resource-id'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'mock-function-resource-id',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function",
            "suites": [],
            "updatePoint": {
                "line": 394,
                "column": 125
            },
            "line": 394,
            "code": "  test('does not call the updateLambdaCode() API when it receives a change that is not a code difference in a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 446,
                "column": 57
            },
            "line": 445,
            "code": "  test(`when it receives a non-hotswappable change that includes a code difference in a Lambda function, it does not call the updateLambdaCode()\n        API in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            PackageType: 'Zip',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              PackageType: 'Image',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'my-function',\n        S3Bucket: 'current-bucket',\n        S3Key: 'new-key',\n      });\n    }\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed",
            "suites": [],
            "updatePoint": {
                "line": 503,
                "column": 147
            },
            "line": 503,
            "code": "  test('does not call the updateLambdaCode() API when a resource with type that is not AWS::Lambda::Function but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::NotLambda::NotAFunction',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::NotLambda::NotAFunction',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls getFunction() after function code is updated with delay 1",
            "suites": [],
            "updatePoint": {
                "line": 558,
                "column": 71
            },
            "line": 558,
            "code": "  test('calls getFunction() after function code is updated with delay 1', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(mockMakeRequest).toHaveBeenCalledWith('getFunction', { FunctionName: 'my-function' });\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls getFunction() after function code is updated and VpcId is empty string with delay 1",
            "suites": [],
            "updatePoint": {
                "line": 610,
                "column": 97
            },
            "line": 610,
            "code": "  test('calls getFunction() after function code is updated and VpcId is empty string with delay 1', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: '',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 1,\n      }),\n    }));\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls getFunction() after function code is updated on a VPC function with delay 5",
            "suites": [],
            "updatePoint": {
                "line": 669,
                "column": 89
            },
            "line": 669,
            "code": "  test('calls getFunction() after function code is updated on a VPC function with delay 5', async () => {\n    // GIVEN\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({\n      VpcConfig: {\n        VpcId: 'abc',\n      },\n    });\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n          Metadata: {\n            'aws:asset:path': 'old-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'new-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(hotswapMockSdkProvider.getLambdaApiWaiters()).toEqual(expect.objectContaining({\n      updateFunctionPropertiesToFinish: expect.objectContaining({\n        name: 'UpdateFunctionPropertiesToFinish',\n        delay: 5,\n      }),\n    }));\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function",
            "suites": [],
            "updatePoint": {
                "line": 728,
                "column": 119
            },
            "line": 728,
            "code": "  test('calls the updateLambdaConfiguration() API when it receives difference in Description field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function",
            "suites": [],
            "updatePoint": {
                "line": 780,
                "column": 119
            },
            "line": 780,
            "code": "  test('calls the updateLambdaConfiguration() API when it receives difference in Environment field of a Lambda function', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                Key1: 'Value1',\n                Key2: 'Value2',\n              },\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  Key1: 'Value1',\n                  Key2: 'Value2',\n                  NewKey: 'NewValue',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          Key1: 'Value1',\n          Key2: 'Value2',\n          NewKey: 'NewValue',\n        },\n      },\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change",
            "suites": [],
            "updatePoint": {
                "line": 849,
                "column": 125
            },
            "line": 849,
            "code": "  test('calls both updateLambdaCode() and updateLambdaConfiguration() API when it receives both code and configuration change', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n            Description: 'Old Description',\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'new-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n              Description: 'New Description',\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Description: 'New Description',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Lambda hotswap works properly with changes of environment variables and description with tokens",
            "suites": [],
            "updatePoint": {
                "line": 906,
                "column": 103
            },
            "line": 906,
            "code": "  test('Lambda hotswap works properly with changes of environment variables and description with tokens', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 's3-bucket',\n              S3Key: 's3-key',\n            },\n            FunctionName: 'my-function',\n            Environment: {\n              Variables: {\n                token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                literal: 'oldValue',\n              },\n            },\n            Description: {\n              'Fn::Join': ['', [\n                'oldValue',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n              ]],\n            },\n          },\n          Metadata: {\n            'aws:asset:path': 'asset-path',\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 's3-bucket',\n                S3Key: 's3-key',\n              },\n              FunctionName: 'my-function',\n              Environment: {\n                Variables: {\n                  token: { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  literal: 'newValue',\n                },\n              },\n              Description: {\n                'Fn::Join': ['', [\n                  'newValue',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                ]],\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'asset-path',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaConfiguration).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      Environment: {\n        Variables: {\n          token: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n          literal: 'newValue',\n        },\n      },\n      Description: 'newValuearn:aws:events:here:123456789012:event-bus/my-event-bus',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "S3ObjectVersion is hotswappable",
            "suites": [],
            "updatePoint": {
                "line": 1003,
                "column": 39
            },
            "line": 1003,
            "code": "  test('S3ObjectVersion is hotswappable', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Key: 'current-key',\n              S3ObjectVersion: 'current-obj',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Key: 'new-key',\n                S3ObjectVersion: 'new-obj',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Key: 'new-key',\n      S3ObjectVersion: 'new-obj',\n    });\n  });",
            "file": "api/hotswap/lambda-functions-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "these tests do not depend on the hotswap type",
            "suites": [],
            "line": 23,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('these tests do not depend on the hotswap type', (hotswapMode) => {\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'exports.handler = () => {return true}',\n            },\n            Runtime: 'nodejs14.x',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const newCode = 'exports.handler = () => {return false}';\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: newCode,\n              },\n              Runtime: 'nodejs14.x',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });\n\n  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event, context):\\n  return True',\n            },\n            Runtime: 'python3.9',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event, context):\\n  return False',\n              },\n              Runtime: 'python3.9',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });\n\n  test('throw a CfnEvaluationException when it receives an unsupported function runtime', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event:, context:) true end',\n            },\n            Runtime: 'ruby2.7',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event:, context:) false end',\n              },\n              Runtime: 'ruby2.7',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const tryHotswap = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(tryHotswap).rejects.toThrow('runtime ruby2.7 is unsupported, only node.js and python runtimes are currently supported.');\n  });\n});",
            "file": "api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 123
            },
            "line": 24,
            "code": "  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'exports.handler = () => {return true}',\n            },\n            Runtime: 'nodejs14.x',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const newCode = 'exports.handler = () => {return false}';\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: newCode,\n              },\n              Runtime: 'nodejs14.x',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });",
            "file": "api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)",
            "suites": [],
            "updatePoint": {
                "line": 69,
                "column": 122
            },
            "line": 69,
            "code": "  test('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event, context):\\n  return True',\n            },\n            Runtime: 'python3.9',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event, context):\\n  return False',\n              },\n              Runtime: 'python3.9',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      ZipFile: expect.any(Buffer),\n    });\n  });",
            "file": "api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throw a CfnEvaluationException when it receives an unsupported function runtime",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 87
            },
            "line": 113,
            "code": "  test('throw a CfnEvaluationException when it receives an unsupported function runtime', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              ZipFile: 'def handler(event:, context:) true end',\n            },\n            Runtime: 'ruby2.7',\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                ZipFile: 'def handler(event:, context:) false end',\n              },\n              Runtime: 'ruby2.7',\n              FunctionName: 'my-function',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const tryHotswap = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    await expect(tryHotswap).rejects.toThrow('runtime ruby2.7 is unsupported, only node.js and python runtimes are currently supported.');\n  });",
            "file": "api/hotswap/lambda-functions-inline-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 24,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('hotswaps a Version if it points to a changed Function, even if it itself is unchanged', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n\n  test('hotswaps a Version if it points to a changed Function, even if it itself is replaced', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n\n  test('hotswaps a Version and an Alias if the Function they point to changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n        Alias: {\n          Type: 'AWS::Lambda::Alias',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n            FunctionVersion: { 'Fn::GetAtt': ['Version1', 'Version'] },\n            Name: 'dev',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n          Alias: {\n            Type: 'AWS::Lambda::Alias',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n              FunctionVersion: { 'Fn::GetAtt': ['Version2', 'Version'] },\n              Name: 'dev',\n            },\n          },\n        },\n      },\n    });\n    mockPublishVersion.mockReturnValue({\n      Version: 'v2',\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateAlias).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      FunctionVersion: 'v2',\n      Name: 'dev',\n    });\n  });\n});",
            "file": "api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hotswaps a Version if it points to a changed Function, even if it itself is unchanged",
            "suites": [],
            "updatePoint": {
                "line": 25,
                "column": 93
            },
            "line": 25,
            "code": "  test('hotswaps a Version if it points to a changed Function, even if it itself is unchanged', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });",
            "file": "api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hotswaps a Version if it points to a changed Function, even if it itself is replaced",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 92
            },
            "line": 80,
            "code": "  test('hotswaps a Version if it points to a changed Function, even if it itself is replaced', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });",
            "file": "api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hotswaps a Version and an Alias if the Function they point to changed",
            "suites": [],
            "updatePoint": {
                "line": 135,
                "column": 77
            },
            "line": 135,
            "code": "  test('hotswaps a Version and an Alias if the Function they point to changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            Code: {\n              S3Bucket: 'current-bucket',\n              S3Key: 'current-key',\n            },\n            FunctionName: 'my-function',\n          },\n        },\n        Version1: {\n          Type: 'AWS::Lambda::Version',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n          },\n        },\n        Alias: {\n          Type: 'AWS::Lambda::Alias',\n          Properties: {\n            FunctionName: { Ref: 'Func' },\n            FunctionVersion: { 'Fn::GetAtt': ['Version1', 'Version'] },\n            Name: 'dev',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version2: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n          Alias: {\n            Type: 'AWS::Lambda::Alias',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n              FunctionVersion: { 'Fn::GetAtt': ['Version2', 'Version'] },\n              Name: 'dev',\n            },\n          },\n        },\n      },\n    });\n    mockPublishVersion.mockReturnValue({\n      Version: 'v2',\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateAlias).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      FunctionVersion: 'v2',\n      Name: 'dev',\n    });\n  });",
            "file": "api/hotswap/lambda-versions-aliases-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 12,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('can hotswap a lambda function in a 1-level nested stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('hotswappable changes do not override hotswappable changes in their ancestors', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('TwoLevelLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'TwoLevelLambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'child-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('TwoLevelLambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'TwoLevelLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('hotswappable changes in nested stacks do not override hotswappable changes in their parent stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('SiblingLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'SiblingLambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('SiblingLambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'SiblingLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test(`non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NonHotswappableRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NonHotswappableRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NonHotswappableRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'NonHotswappableRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackDeletionRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackDeletionRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NestedStackDeletionRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    delete rootStack.template.Resources.NestedStack;\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackDeletionRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackCreationRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackCreationRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.NestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackCreationRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test(`attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackTypeChangeRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackTypeChangeRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          FutureNestedStack: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'spooky-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.FutureNestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackTypeChangeRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });\n\n  test('multi-sibling + 3-layer nested stack structure is hotswappable', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('MultiLayerRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const lambdaFunctionResource = {\n      Type: 'AWS::Lambda::Function',\n      Properties: {\n        Code: {\n          S3Bucket: 'current-bucket',\n          S3Key: 'current-key',\n        },\n      },\n      Metadata: {\n        'aws:asset:path': 'old-path',\n      },\n    };\n\n    const rootStack = testStack({\n      stackName: 'MultiLayerRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-two-stacks-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          GrandChildStackA: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          GrandChildStackB: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackA',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackB',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('MultiLayerRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'root-function'),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n      ),\n      setup.stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'child-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackA',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-A-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackB',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-B-function'),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Key = 'new-key';\n    const cdkStackArtifact = testStack({ stackName: 'MultiLayerRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-A-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-B-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });\n\n  test('can hotswap a lambda function in a 1-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoS3BucketParam: {\n                  Ref: 'S3BucketParam',\n                },\n                referencetoS3KeyParam: {\n                  Ref: 'S3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          S3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          S3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      S3BucketParam: 'bucket-param-value',\n      S3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n  });\n\n  test('can hotswap a lambda function in a 2-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoGrandChildS3BucketParam: {\n                  Ref: 'GrandChildS3BucketParam',\n                },\n                referencetoGrandChildS3KeyParam: {\n                  Ref: 'GrandChildS3KeyParam',\n                },\n                referencetoChildS3BucketParam: {\n                  Ref: 'ChildS3BucketParam',\n                },\n                referencetoChildS3KeyParam: {\n                  Ref: 'ChildS3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          GrandChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          GrandChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      GrandChildS3BucketParam: 'child-bucket-param-value',\n      GrandChildS3KeyParam: 'child-key-param-value',\n      ChildS3BucketParam: 'bucket-param-value',\n      ChildS3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'child-bucket-param-value',\n      S3Key: 'child-key-param-value',\n    });\n  });\n\n  test('looking up objects in nested stacks works', async () => {\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    mockPublishVersion = jest.fn();\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n      publishVersion: mockPublishVersion,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-version-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });\n});",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can hotswap a lambda function in a 1-level nested stack",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 63
            },
            "line": 13,
            "code": "  test('can hotswap a lambda function in a 1-level nested stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hotswappable changes do not override hotswappable changes in their ancestors",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 84
            },
            "line": 80,
            "code": "  test('hotswappable changes do not override hotswappable changes in their ancestors', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('TwoLevelLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'TwoLevelLambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'child-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('TwoLevelLambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'TwoLevelLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hotswappable changes in nested stacks do not override hotswappable changes in their parent stack",
            "suites": [],
            "updatePoint": {
                "line": 186,
                "column": 104
            },
            "line": 186,
            "code": "  test('hotswappable changes in nested stacks do not override hotswappable changes in their parent stack', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('SiblingLambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'SiblingLambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('SiblingLambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'SiblingLambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'new-bucket',\n      S3Key: 'current-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY",
            "suites": [],
            "updatePoint": {
                "line": 273,
                "column": 56
            },
            "line": 272,
            "code": "  test(`non-hotswappable changes in nested stacks result in a full deployment, even if their parent contains a hotswappable change in CLASSIC mode,\n        but perform a hotswap deployment in HOTSWAP_ONLY`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NonHotswappableRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NonHotswappableRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              PackageType: 'Image',\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NonHotswappableRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    const cdkStackArtifact = testStack({ stackName: 'NonHotswappableRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 367,
                "column": 64
            },
            "line": 366,
            "code": "  test(`deleting a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackDeletionRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackDeletionRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack.nested.template.json',\n            },\n          },\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('NestedStackDeletionRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    delete rootStack.template.Resources.NestedStack;\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackDeletionRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 460,
                "column": 64
            },
            "line": 459,
            "code": "  test(`creating a nested stack results in a full deployment in CLASSIC mode, even if their parent contains a hotswappable change,\n        but results in a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackCreationRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackCreationRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.NestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackCreationRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 527,
                "column": 53
            },
            "line": 526,
            "code": "  test(`attempting to hotswap a newly created nested stack with the same logical ID as a resource with a different type results in a full deployment in CLASSIC mode\n        and a hotswap deployment in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('NestedStackTypeChangeRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'NestedStackTypeChangeRoot',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'root-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          FutureNestedStack: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'new-key',\n              },\n              FunctionName: 'spooky-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n\n    rootStack.template.Resources.Func.Properties.Code.S3Bucket = 'new-bucket';\n    rootStack.template.Resources.FutureNestedStack = {\n      Type: 'AWS::CloudFormation::Stack',\n      Properties: {\n        TemplateURL: 'https://www.magic-url.com',\n      },\n      Metadata: {\n        'aws:asset:path': 'one-lambda-stack.nested.template.json',\n      },\n    };\n    const cdkStackArtifact = testStack({ stackName: 'NestedStackTypeChangeRoot', template: rootStack.template });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateLambdaCode).not.toHaveBeenCalled();\n\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n        FunctionName: 'root-function',\n        S3Bucket: 'new-bucket',\n        S3Key: 'current-key',\n      });\n    }\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "multi-sibling + 3-layer nested stack structure is hotswappable",
            "suites": [],
            "updatePoint": {
                "line": 606,
                "column": 70
            },
            "line": 606,
            "code": "  test('multi-sibling + 3-layer nested stack structure is hotswappable', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('MultiLayerRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const lambdaFunctionResource = {\n      Type: 'AWS::Lambda::Function',\n      Properties: {\n        Code: {\n          S3Bucket: 'current-bucket',\n          S3Key: 'current-key',\n        },\n      },\n      Metadata: {\n        'aws:asset:path': 'old-path',\n      },\n    };\n\n    const rootStack = testStack({\n      stackName: 'MultiLayerRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-two-stacks-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          GrandChildStackA: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          GrandChildStackB: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-unnamed-lambda-stack.nested.template.json',\n            },\n          },\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackA',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStackB',\n      template: {\n        Resources: {\n          Func: lambdaFunctionResource,\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('MultiLayerRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'root-function'),\n    );\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStackA', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackA/abcd',\n      ),\n      setup.stackSummaryOf('GrandChildStackB', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStackB/abcd',\n      ),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'child-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackA',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-A-function'),\n    );\n    setup.pushNestedStackResourceSummaries('GrandChildStackB',\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'grandchild-B-function'),\n    );\n\n    rootStack.template.Resources.Func.Properties.Code.S3Key = 'new-key';\n    const cdkStackArtifact = testStack({ stackName: 'MultiLayerRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'root-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'child-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-A-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'grandchild-B-function',\n      S3Bucket: 'current-bucket',\n      S3Key: 'new-key',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can hotswap a lambda function in a 1-level nested stack with asset parameters",
            "suites": [],
            "updatePoint": {
                "line": 741,
                "column": 85
            },
            "line": 741,
            "code": "  test('can hotswap a lambda function in a 1-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoS3BucketParam: {\n                  Ref: 'S3BucketParam',\n                },\n                referencetoS3KeyParam: {\n                  Ref: 'S3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          S3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          S3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      S3BucketParam: 'bucket-param-value',\n      S3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can hotswap a lambda function in a 2-level nested stack with asset parameters",
            "suites": [],
            "updatePoint": {
                "line": 829,
                "column": 85
            },
            "line": 829,
            "code": "  test('can hotswap a lambda function in a 2-level nested stack with asset parameters', async () => {\n    // GIVEN\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          ChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n              Parameters: {\n                referencetoGrandChildS3BucketParam: {\n                  Ref: 'GrandChildS3BucketParam',\n                },\n                referencetoGrandChildS3KeyParam: {\n                  Ref: 'GrandChildS3KeyParam',\n                },\n                referencetoChildS3BucketParam: {\n                  Ref: 'ChildS3BucketParam',\n                },\n                referencetoChildS3KeyParam: {\n                  Ref: 'ChildS3KeyParam',\n                },\n              },\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-one-stack-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n        Parameters: {\n          GrandChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          GrandChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3BucketParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n          ChildS3KeyParam: {\n            Type: 'String',\n            Description: 'S3 bucket for asset',\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'ChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n          GrandChildStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-stack-with-asset-parameters.nested.template.json',\n            },\n          },\n        },\n      },\n    }));\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'GrandChildStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n            Metadata: {\n              'aws:asset:path': 'old-path',\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('ChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/ChildStack/abcd',\n      ),\n    );\n\n    setup.pushNestedStackResourceSummaries('ChildStack',\n      setup.stackSummaryOf('GrandChildStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/GrandChildStack/abcd',\n      ),\n    );\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n      GrandChildS3BucketParam: 'child-bucket-param-value',\n      GrandChildS3KeyParam: 'child-key-param-value',\n      ChildS3BucketParam: 'bucket-param-value',\n      ChildS3KeyParam: 'key-param-value',\n    });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'bucket-param-value',\n      S3Key: 'key-param-value',\n    });\n    expect(mockUpdateLambdaCode).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n      S3Bucket: 'child-bucket-param-value',\n      S3Key: 'child-key-param-value',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looking up objects in nested stacks works",
            "suites": [],
            "updatePoint": {
                "line": 972,
                "column": 49
            },
            "line": 972,
            "code": "  test('looking up objects in nested stacks works', async () => {\n    hotswapMockSdkProvider = setup.setupHotswapNestedStackTests('LambdaRoot');\n    mockUpdateLambdaCode = jest.fn().mockReturnValue({});\n    mockPublishVersion = jest.fn();\n    hotswapMockSdkProvider.stubLambda({\n      updateFunctionCode: mockUpdateLambdaCode,\n      publishVersion: mockPublishVersion,\n    });\n\n    const rootStack = testStack({\n      stackName: 'LambdaRoot',\n      template: {\n        Resources: {\n          NestedStack: {\n            Type: 'AWS::CloudFormation::Stack',\n            Properties: {\n              TemplateURL: 'https://www.magic-url.com',\n            },\n            Metadata: {\n              'aws:asset:path': 'one-lambda-version-stack.nested.template.json',\n            },\n          },\n        },\n      },\n    });\n\n    setup.addTemplateToCloudFormationLookupMock(rootStack);\n    setup.addTemplateToCloudFormationLookupMock(testStack({\n      stackName: 'NestedStack',\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n            Properties: {\n              Code: {\n                S3Bucket: 'current-bucket',\n                S3Key: 'current-key',\n              },\n              FunctionName: 'my-function',\n            },\n          },\n          Version: {\n            Type: 'AWS::Lambda::Version',\n            Properties: {\n              FunctionName: { Ref: 'Func' },\n            },\n          },\n        },\n      },\n    }));\n\n    setup.pushNestedStackResourceSummaries('LambdaRoot',\n      setup.stackSummaryOf('NestedStack', 'AWS::CloudFormation::Stack',\n        'arn:aws:cloudformation:bermuda-triangle-1337:123456789012:stack/NestedStack/abcd',\n      ),\n    );\n\n    const cdkStackArtifact = testStack({ stackName: 'LambdaRoot', template: rootStack.template });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockPublishVersion).toHaveBeenCalledWith({\n      FunctionName: 'my-function',\n    });\n  });",
            "file": "api/hotswap/nested-stacks-hotswap.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 25,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n            DestinationBucketKeyPrefix: 'my-key/some-old-prefix',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: {\n                'Fn::Split': [\n                  '-',\n                  'key1-key2-key3',\n                ],\n              },\n              DestinationBucketName: 'dest-bucket',\n              DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n\n    expect(mockLambdaInvoke).toHaveBeenCalledWith({\n      FunctionName: 'a-lambda-arn',\n      Payload: JSON.stringify({\n        ...payloadWithoutCustomResProps,\n        ResourceProperties: {\n          SourceBucketNames: ['src-bucket'],\n          SourceObjectKeys: ['key1', 'key2', 'key3'],\n          DestinationBucketName: 'dest-bucket',\n          DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n        },\n      }),\n    });\n  });\n\n  test('does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::NotCDKBucketDeployment',\n          Properties: {\n            SourceObjectKeys: ['src-key-old'],\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::NotCDKBucketDeployment',\n            Properties: {\n              SourceObjectKeys: ['src-key-new'],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    }\n  });\n\n  test('does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        WebsiteBucketParamOld: { Type: 'String' },\n        WebsiteBucketParamNew: { Type: 'String' },\n      },\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceObjectKeys: ['src-key-old'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n        Policy: {\n          Type: 'AWS::IAM::Policy',\n          Properties: {\n            PolicyName: 'my-policy',\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: ['s3:GetObject*'],\n                  Effect: 'Allow',\n                  Resource: {\n                    Ref: 'WebsiteBucketParamOld',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          WebsiteBucketParamOld: { Type: 'String' },\n          WebsiteBucketParamNew: { Type: 'String' },\n        },\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceObjectKeys: ['src-key-new'],\n              SourceBucketNames: ['src-bucket'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n          Policy: {\n            Type: 'AWS::IAM::Policy',\n            Properties: {\n              PolicyName: 'my-policy',\n              PolicyDocument: {\n                Statement: [\n                  {\n                    Action: ['s3:GetObject*'],\n                    Effect: 'Allow',\n                    Resource: {\n                      Ref: 'WebsiteBucketParamNew',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'a-lambda-arn',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceObjectKeys: ['src-key-new'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        }),\n      });\n    }\n  });\n\n  test('throws an error when the serviceToken fails evaluation in the template', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: {\n              Ref: 'BadLamba',\n            },\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: {\n                Ref: 'BadLamba',\n              },\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'BadLamba' could not be found for evaluation/);\n\n    expect(mockLambdaInvoke).not.toHaveBeenCalled();\n  });\n\n  describe('old-style synthesis', () => {\n    const parameters = {\n      WebsiteBucketParamOld: { Type: 'String' },\n      WebsiteBucketParamNew: { Type: 'String' },\n      DifferentBucketParamNew: { Type: 'String' },\n    };\n\n    const serviceRole = {\n      Type: 'AWS::IAM::Role',\n      Properties: {\n        AssumeRolePolicyDocument: {\n          Statement: [\n            {\n              Action: 'sts:AssumeRole',\n              Effect: 'Allow',\n              Principal: {\n                Service: 'lambda.amazonaws.com',\n              },\n            },\n          ],\n          Version: '2012-10-17',\n        },\n      },\n    };\n\n    const policyOld = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-old',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policyNew = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-new',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamNew',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policy2Old = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-old-2',\n        Roles: [\n          { Ref: 'ServiceRole' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'WebsiteBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const policy2New = {\n      Type: 'AWS::IAM::Policy',\n      Properties: {\n        PolicyName: 'my-policy-new-2',\n        Roles: [\n          { Ref: 'ServiceRole2' },\n        ],\n        PolicyDocument: {\n          Statement: [\n            {\n              Action: ['s3:GetObject*'],\n              Effect: 'Allow',\n              Resource: {\n                Ref: 'DifferentBucketParamOld',\n              },\n            },\n          ],\n        },\n      },\n    };\n\n    const deploymentLambda = {\n      Type: 'AWS::Lambda::Function',\n      Role: {\n        'Fn::GetAtt': [\n          'ServiceRole',\n          'Arn',\n        ],\n      },\n    };\n\n    const s3DeploymentOld = {\n      Type: 'Custom::CDKBucketDeployment',\n      Properties: {\n        ServiceToken: {\n          'Fn::GetAtt': [\n            'S3DeploymentLambda',\n            'Arn',\n          ],\n        },\n        SourceBucketNames: ['src-bucket-old'],\n        SourceObjectKeys: ['src-key-old'],\n        DestinationBucketName: 'WebsiteBucketOld',\n      },\n    };\n\n    const s3DeploymentNew = {\n      Type: 'Custom::CDKBucketDeployment',\n      Properties: {\n        ServiceToken: {\n          'Fn::GetAtt': [\n            'S3DeploymentLambda',\n            'Arn',\n          ],\n        },\n        SourceBucketNames: ['src-bucket-new'],\n        SourceObjectKeys: ['src-key-new'],\n        DestinationBucketName: 'WebsiteBucketNew',\n      },\n    };\n\n    beforeEach(() => {\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda', 'AWS::Lambda::Function', 'my-deployment-lambda'),\n        setup.stackSummaryOf('ServiceRole', 'AWS::IAM::Role', 'my-service-role'),\n      );\n    });\n\n    test('calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis', async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          Parameters: parameters,\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { WebsiteBucketParamOld: 'WebsiteBucketOld', WebsiteBucketParamNew: 'WebsiteBucketNew' });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n    });\n\n    test(`does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                  'different-role',\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test(`does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          Endpoint: {\n            Type: 'AWS::Lambda::Permission',\n            Properties: {\n              Action: 'lambda:InvokeFunction',\n              FunctionName: {\n                'Fn::GetAtt': [\n                  'S3DeploymentLambda',\n                  'Arn',\n                ],\n              },\n              Principal: 'apigateway.amazonaws.com',\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            Endpoint: {\n              Type: 'AWS::Lambda::Permission',\n              Properties: {\n                Action: 'lambda:InvokeFunction',\n                FunctionName: {\n                  'Fn::GetAtt': [\n                    'S3DeploymentLambda',\n                    'Arn',\n                  ],\n                },\n                Principal: 'apigateway.amazonaws.com',\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test('calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis', async () => {\n      // GIVEN\n      const s3Deployment2Old = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-old'],\n          SourceObjectKeys: ['src-key-old'],\n          DestinationBucketName: 'DifferentBucketOld',\n        },\n      };\n\n      const s3Deployment2New = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-new'],\n          SourceObjectKeys: ['src-key-new'],\n          DestinationBucketName: 'DifferentBucketNew',\n        },\n      };\n\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          ServiceRole2: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3DeploymentLambda2: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          S3Deployment2: s3Deployment2Old,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            ServiceRole2: serviceRole,\n            Policy1: policyNew,\n            Policy2: policy2New,\n            S3DeploymentLambda: deploymentLambda,\n            S3DeploymentLambda2: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            S3Deployment2: s3Deployment2New,\n          },\n        },\n      });\n\n      // WHEN\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda2', 'AWS::Lambda::Function', 'my-deployment-lambda-2'),\n        setup.stackSummaryOf('ServiceRole2', 'AWS::IAM::Role', 'my-service-role-2'),\n      );\n\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n        WebsiteBucketParamOld: 'WebsiteBucketOld',\n        WebsiteBucketParamNew: 'WebsiteBucketNew',\n        DifferentBucketParamNew: 'WebsiteBucketNew',\n      });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda-2',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'DifferentBucketNew',\n          },\n        }),\n      });\n    });\n\n    test(`does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n\n    test(`does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          NotADeployment: {\n            Type: 'AWS::Not::S3Deployment',\n            Properties: {\n              Prop: {\n                Ref: 'ServiceRole',\n              },\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            NotADeployment: {\n              Type: 'AWS::Not::S3Deployment',\n              Properties: {\n                Prop: {\n                  Ref: 'ServiceRole',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });\n  });\n});",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 163
            },
            "line": 26,
            "code": "  test('calls the lambdaInvoke() API when it receives only an asset difference in an S3 bucket deployment and evaluates CFN expressions in S3 Deployment Properties', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n            DestinationBucketKeyPrefix: 'my-key/some-old-prefix',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: {\n                'Fn::Split': [\n                  '-',\n                  'key1-key2-key3',\n                ],\n              },\n              DestinationBucketName: 'dest-bucket',\n              DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n\n    expect(mockLambdaInvoke).toHaveBeenCalledWith({\n      FunctionName: 'a-lambda-arn',\n      Payload: JSON.stringify({\n        ...payloadWithoutCustomResProps,\n        ResourceProperties: {\n          SourceBucketNames: ['src-bucket'],\n          SourceObjectKeys: ['key1', 'key2', 'key3'],\n          DestinationBucketName: 'dest-bucket',\n          DestinationBucketKeyPrefix: 'my-key/some-new-prefix',\n        },\n      }),\n    });\n  });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 143
            },
            "line": 84,
            "code": "  test('does not call the invoke() API when a resource with type that is not Custom::CDKBucketDeployment but has the same properties is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::NotCDKBucketDeployment',\n          Properties: {\n            SourceObjectKeys: ['src-key-old'],\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::NotCDKBucketDeployment',\n            Properties: {\n              SourceObjectKeys: ['src-key-new'],\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 125
            },
            "line": 127,
            "code": "  test('does not call the invokeLambda() api if the updated Policy has no Roles in CLASSIC mode but does in HOTSWAP_ONLY mode', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        WebsiteBucketParamOld: { Type: 'String' },\n        WebsiteBucketParamNew: { Type: 'String' },\n      },\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: 'a-lambda-arn',\n            SourceObjectKeys: ['src-key-old'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n        Policy: {\n          Type: 'AWS::IAM::Policy',\n          Properties: {\n            PolicyName: 'my-policy',\n            PolicyDocument: {\n              Statement: [\n                {\n                  Action: ['s3:GetObject*'],\n                  Effect: 'Allow',\n                  Resource: {\n                    Ref: 'WebsiteBucketParamOld',\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          WebsiteBucketParamOld: { Type: 'String' },\n          WebsiteBucketParamNew: { Type: 'String' },\n        },\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: 'a-lambda-arn',\n              SourceObjectKeys: ['src-key-new'],\n              SourceBucketNames: ['src-bucket'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n          Policy: {\n            Type: 'AWS::IAM::Policy',\n            Properties: {\n              PolicyName: 'my-policy',\n              PolicyDocument: {\n                Statement: [\n                  {\n                    Action: ['s3:GetObject*'],\n                    Effect: 'Allow',\n                    Resource: {\n                      Ref: 'WebsiteBucketParamNew',\n                    },\n                  },\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockLambdaInvoke).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'a-lambda-arn',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceObjectKeys: ['src-key-new'],\n            SourceBucketNames: ['src-bucket'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        }),\n      });\n    }\n  });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws an error when the serviceToken fails evaluation in the template",
            "suites": [],
            "updatePoint": {
                "line": 227,
                "column": 78
            },
            "line": 227,
            "code": "  test('throws an error when the serviceToken fails evaluation in the template', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        S3Deployment: {\n          Type: 'Custom::CDKBucketDeployment',\n          Properties: {\n            ServiceToken: {\n              Ref: 'BadLamba',\n            },\n            SourceBucketNames: ['src-bucket'],\n            SourceObjectKeys: ['src-key-old'],\n            DestinationBucketName: 'dest-bucket',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          S3Deployment: {\n            Type: 'Custom::CDKBucketDeployment',\n            Properties: {\n              ServiceToken: {\n                Ref: 'BadLamba',\n              },\n              SourceBucketNames: ['src-bucket'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'dest-bucket',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'BadLamba' could not be found for evaluation/);\n\n    expect(mockLambdaInvoke).not.toHaveBeenCalled();\n  });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 426,
                "column": 157
            },
            "line": 426,
            "code": "    test('calls the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment and an IAM Policy difference using old-style synthesis', async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          Parameters: parameters,\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { WebsiteBucketParamOld: 'WebsiteBucketOld', WebsiteBucketParamNew: 'WebsiteBucketNew' });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 469,
                "column": 50
            },
            "line": 468,
            "code": "    test(`does not call the lambdaInvoke() API when the difference in the S3 deployment is referred to in one IAM policy change but not another\n          in CLASSIC mode but does in HOTSWAP_ONLY`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                  'different-role',\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 543,
                "column": 55
            },
            "line": 542,
            "code": "    test(`does not call the lambdaInvoke() API when the lambda that references the role is referred to by something other than an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          Endpoint: {\n            Type: 'AWS::Lambda::Permission',\n            Properties: {\n              Action: 'lambda:InvokeFunction',\n              FunctionName: {\n                'Fn::GetAtt': [\n                  'S3DeploymentLambda',\n                  'Arn',\n                ],\n              },\n              Principal: 'apigateway.amazonaws.com',\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            Endpoint: {\n              Type: 'AWS::Lambda::Permission',\n              Properties: {\n                Action: 'lambda:InvokeFunction',\n                FunctionName: {\n                  'Fn::GetAtt': [\n                    'S3DeploymentLambda',\n                    'Arn',\n                  ],\n                },\n                Principal: 'apigateway.amazonaws.com',\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 619,
                "column": 157
            },
            "line": 619,
            "code": "    test('calls the lambdaInvoke() API when it receives an asset difference in two S3 bucket deployments and IAM Policy differences using old-style synthesis', async () => {\n      // GIVEN\n      const s3Deployment2Old = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-old'],\n          SourceObjectKeys: ['src-key-old'],\n          DestinationBucketName: 'DifferentBucketOld',\n        },\n      };\n\n      const s3Deployment2New = {\n        Type: 'Custom::CDKBucketDeployment',\n        Properties: {\n          ServiceToken: {\n            'Fn::GetAtt': [\n              'S3DeploymentLambda2',\n              'Arn',\n            ],\n          },\n          SourceBucketNames: ['src-bucket-new'],\n          SourceObjectKeys: ['src-key-new'],\n          DestinationBucketName: 'DifferentBucketNew',\n        },\n      };\n\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          ServiceRole2: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3DeploymentLambda2: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          S3Deployment2: s3Deployment2Old,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            Parameters: parameters,\n            ServiceRole: serviceRole,\n            ServiceRole2: serviceRole,\n            Policy1: policyNew,\n            Policy2: policy2New,\n            S3DeploymentLambda: deploymentLambda,\n            S3DeploymentLambda2: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            S3Deployment2: s3Deployment2New,\n          },\n        },\n      });\n\n      // WHEN\n      setup.pushStackResourceSummaries(\n        setup.stackSummaryOf('S3DeploymentLambda2', 'AWS::Lambda::Function', 'my-deployment-lambda-2'),\n        setup.stackSummaryOf('ServiceRole2', 'AWS::IAM::Role', 'my-service-role-2'),\n      );\n\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, {\n        WebsiteBucketParamOld: 'WebsiteBucketOld',\n        WebsiteBucketParamNew: 'WebsiteBucketNew',\n        DifferentBucketParamNew: 'WebsiteBucketNew',\n      });\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'WebsiteBucketNew',\n          },\n        }),\n      });\n\n      expect(mockLambdaInvoke).toHaveBeenCalledWith({\n        FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda-2',\n        Payload: JSON.stringify({\n          ...payloadWithoutCustomResProps,\n          ResourceProperties: {\n            SourceBucketNames: ['src-bucket-new'],\n            SourceObjectKeys: ['src-key-new'],\n            DestinationBucketName: 'DifferentBucketNew',\n          },\n        }),\n      });\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 720,
                "column": 55
            },
            "line": 719,
            "code": "    test(`does not call the lambdaInvoke() API when it receives an asset difference in an S3 bucket deployment that references two different policies\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          Policy2: policy2Old,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            Policy2: {\n              Properties: {\n                Roles: [\n                  { Ref: 'ServiceRole' },\n                ],\n                PolicyDocument: {\n                  Statement: [\n                    {\n                      Action: ['s3:GetObject*'],\n                      Effect: 'Allow',\n                      Resource: {\n                        'Fn::GetAtt': [\n                          'DifferentBucketNew',\n                          'Arn',\n                        ],\n                      },\n                    },\n                  ],\n                },\n              },\n            },\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [
                "old-style synthesis"
            ],
            "updatePoint": {
                "line": 793,
                "column": 55
            },
            "line": 792,
            "code": "    test(`does not call the lambdaInvoke() API when a policy is referenced by a resource that is not an S3 deployment\n          in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n    async () => {\n      // GIVEN\n      setup.setCurrentCfnStackTemplate({\n        Resources: {\n          ServiceRole: serviceRole,\n          Policy1: policyOld,\n          S3DeploymentLambda: deploymentLambda,\n          S3Deployment: s3DeploymentOld,\n          NotADeployment: {\n            Type: 'AWS::Not::S3Deployment',\n            Properties: {\n              Prop: {\n                Ref: 'ServiceRole',\n              },\n            },\n          },\n        },\n      });\n\n      const cdkStackArtifact = setup.cdkStackArtifactOf({\n        template: {\n          Resources: {\n            ServiceRole: serviceRole,\n            Policy1: policyNew,\n            S3DeploymentLambda: deploymentLambda,\n            S3Deployment: s3DeploymentNew,\n            NotADeployment: {\n              Type: 'AWS::Not::S3Deployment',\n              Properties: {\n                Prop: {\n                  Ref: 'ServiceRole',\n                },\n              },\n            },\n          },\n        },\n      });\n\n      if (hotswapMode === HotswapMode.FALL_BACK) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).toBeUndefined();\n        expect(mockLambdaInvoke).not.toHaveBeenCalled();\n      } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n        // WHEN\n        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n        // THEN\n        expect(deployStackResult).not.toBeUndefined();\n        expect(mockLambdaInvoke).toHaveBeenCalledWith({\n          FunctionName: 'arn:aws:lambda:here:123456789012:function:my-deployment-lambda',\n          Payload: JSON.stringify({\n            ...payloadWithoutCustomResProps,\n            ResourceProperties: {\n              SourceBucketNames: ['src-bucket-new'],\n              SourceObjectKeys: ['src-key-new'],\n              DestinationBucketName: 'WebsiteBucketNew',\n            },\n          }),\n        });\n      }\n    });",
            "file": "api/hotswap/s3-bucket-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [],
            "line": 15,
            "code": "describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n  test('returns undefined when a new StateMachine is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ Prop: \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Pass\"',\n                  '      \"Result\": \"Success\"',\n                  '      \"End\": true',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '\\n',\n                  [\n                    '{',\n                    '  \"StartAt\": \"SuccessState\",',\n                    '  \"States\": {',\n                    '    \"SuccessState\": {',\n                    '      \"Type\": \"Succeed\"',\n                    '    }',\n                    '  }',\n                    '}',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: JSON.stringify({\n        StartAt: 'SuccessState',\n        States: {\n          SuccessState: {\n            Type: 'Succeed',\n          },\n        },\n      }, null, 2),\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ \"Prop\" : \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test(`does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n            LoggingConfiguration: { // non-definitionString property\n              IncludeExecutionData: true,\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n              LoggingConfiguration: {\n                IncludeExecutionData: false,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n        definition: '{ \"Prop\" : \"new-value\" }',\n        stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      });\n    }\n  });\n\n  test('does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::NotStepFunctions::NotStateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::NotStepFunctions::NotStateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });\n\n  test('can correctly hotswap old style synth changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: { AssetParam1: { Type: 'String' } },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: { Ref: 'AssetParam1' },\n            StateMachineName: 'machine-name',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: { AssetParam2: { Type: String } },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: { Ref: 'AssetParam2' },\n              StateMachineName: 'machine-name',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetParam2: 'asset-param-2' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: 'asset-param-2',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:machine-name',\n    });\n  });\n\n  test('calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Succeed\"',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '\"Resource\": ',\n                    { 'Fn::GetAtt': ['Func', 'Arn'] },\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n    );\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '\"Resource\": arn:aws:lambda:here:123456789012:function:my-func',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });\n\n  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"Param\" : ',\n                  { 'Fn::Sub': '${Param1}' },\n                  ' }',\n                ],\n              ],\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'my-machine'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"Param\" : ',\n                    { 'Fn::Sub': '${Param1}' },\n                    ' }',\n                  ],\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });\n\n  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"S3Bucket\" : ',\n                  { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                  ' }',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"S3Bucket\" : ',\n                    { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                    ' }',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });\n\n  test('knows how to handle attributes of the AWS::Events::EventBus resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': ['', [\n                '{\"EventBus1Arn\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                '\",\"EventBus1Name\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                '\",\"EventBus1Ref\":\"',\n                { Ref: 'EventBus' },\n                '\"}',\n              ]],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"EventBus2Arn\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  '\",\"EventBus2Name\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                  '\",\"EventBus2Ref\":\"',\n                  { Ref: 'EventBus' },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        EventBus2Arn: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n        EventBus2Name: 'my-event-bus',\n        EventBus2Ref: 'my-event-bus',\n      }),\n    });\n  });\n\n  test('knows how to handle attributes of the AWS::DynamoDB::Table resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Table: {\n          Type: 'AWS::DynamoDB::Table',\n          Properties: {\n            KeySchema: [{\n              AttributeName: 'name',\n              KeyType: 'HASH',\n            }],\n            AttributeDefinitions: [{\n              AttributeName: 'name',\n              AttributeType: 'S',\n            }],\n            BillingMode: 'PAY_PER_REQUEST',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{}',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Table', 'AWS::DynamoDB::Table', 'my-dynamodb-table'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Table: {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              KeySchema: [{\n                AttributeName: 'name',\n                KeyType: 'HASH',\n              }],\n              AttributeDefinitions: [{\n                AttributeName: 'name',\n                AttributeType: 'S',\n              }],\n              BillingMode: 'PAY_PER_REQUEST',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"TableName\":\"',\n                  { Ref: 'Table' },\n                  '\",\"TableArn\":\"',\n                  { 'Fn::GetAtt': ['Table', 'Arn'] },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        TableName: 'my-dynamodb-table',\n        TableArn: 'arn:aws:dynamodb:here:123456789012:table/my-dynamodb-table',\n      }),\n    });\n  });\n\n  test('does not explode if the DependsOn changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n          DependsOn: ['abc'],\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"old-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n          DependsOn: ['xyz'],\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n  });\n});",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns undefined when a new StateMachine is added to the Stack",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 71
            },
            "line": 16,
            "code": "  test('returns undefined when a new StateMachine is added to the Stack', async () => {\n    // GIVEN\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine",
            "suites": [],
            "updatePoint": {
                "line": 46,
                "column": 126
            },
            "line": 46,
            "code": "  test('calls the updateStateMachine() API when it receives only a definitionString change without Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ Prop: \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 123
            },
            "line": 84,
            "code": "  test('calls the updateStateMachine() API when it receives only a definitionString change with Fn::Join in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Pass\"',\n                  '      \"Result\": \"Success\"',\n                  '      \"End\": true',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '\\n',\n                  [\n                    '{',\n                    '  \"StartAt\": \"SuccessState\",',\n                    '  \"States\": {',\n                    '    \"SuccessState\": {',\n                    '      \"Type\": \"Succeed\"',\n                    '    }',\n                    '  }',\n                    '}',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: JSON.stringify({\n        StartAt: 'SuccessState',\n        States: {\n          SuccessState: {\n            Type: 'Succeed',\n          },\n        },\n      }, null, 2),\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name",
            "suites": [],
            "updatePoint": {
                "line": 159,
                "column": 128
            },
            "line": 159,
            "code": "  test('calls the updateStateMachine() API when it receives a change to the definitionString in a state machine that has no name', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '{ \"Prop\" : \"new-value\" }',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode",
            "suites": [],
            "updatePoint": {
                "line": 197,
                "column": 85
            },
            "line": 196,
            "code": "  test(`does not call the updateStateMachine() API when it receives a change to a property that is not the definitionString in a state machine\n        alongside a hotswappable change in CLASSIC mode but does in HOTSWAP_ONLY mode`,\n  async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ \"Prop\" : \"old-value\" }',\n            LoggingConfiguration: { // non-definitionString property\n              IncludeExecutionData: true,\n            },\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ \"Prop\" : \"new-value\" }',\n              LoggingConfiguration: {\n                IncludeExecutionData: false,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n        definition: '{ \"Prop\" : \"new-value\" }',\n        stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      });\n    }\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed",
            "suites": [],
            "updatePoint": {
                "line": 250,
                "column": 156
            },
            "line": 250,
            "code": "  test('does not call the updateStateMachine() API when a resource has a DefinitionString property but is not an AWS::StepFunctions::StateMachine is changed', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::NotStepFunctions::NotStateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::NotStepFunctions::NotStateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"new-value\" }',\n            },\n          },\n        },\n      },\n    });\n\n    if (hotswapMode === HotswapMode.FALL_BACK) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).toBeUndefined();\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    } else if (hotswapMode === HotswapMode.HOTSWAP_ONLY) {\n      // WHEN\n      const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n      // THEN\n      expect(deployStackResult).not.toBeUndefined();\n      expect(deployStackResult?.noOp).toEqual(true);\n      expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n    }\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can correctly hotswap old style synth changes",
            "suites": [],
            "updatePoint": {
                "line": 293,
                "column": 53
            },
            "line": 293,
            "code": "  test('can correctly hotswap old style synth changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: { AssetParam1: { Type: 'String' } },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: { Ref: 'AssetParam1' },\n            StateMachineName: 'machine-name',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: { AssetParam2: { Type: String } },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: { Ref: 'AssetParam2' },\n              StateMachineName: 'machine-name',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'));\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact, { AssetParam2: 'asset-param-2' });\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: 'asset-param-2',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:machine-name',\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine",
            "suites": [],
            "updatePoint": {
                "line": 334,
                "column": 132
            },
            "line": 334,
            "code": "  test('calls the updateStateMachine() API when it receives a change to the definitionString that uses Attributes in a state machine', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '\\n',\n                [\n                  '{',\n                  '  \"StartAt\" : \"SuccessState\"',\n                  '  \"States\" : {',\n                  '    \"SuccessState\": {',\n                  '      \"Type\": \"Succeed\"',\n                  '    }',\n                  '  }',\n                  '}',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Func: {\n            Type: 'AWS::Lambda::Function',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '\"Resource\": ',\n                    { 'Fn::GetAtt': ['Func', 'Arn'] },\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // WHEN\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-func'),\n    );\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      definition: '\"Resource\": arn:aws:lambda:here:123456789012:function:my-func',\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)",
            "suites": [],
            "updatePoint": {
                "line": 404,
                "column": 111
            },
            "line": 404,
            "code": "  test(\"will not perform a hotswap deployment if it cannot find a Ref target (outside the state machine's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Parameters: {\n        Param1: { Type: 'String' },\n      },\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"Param\" : ',\n                  { 'Fn::Sub': '${Param1}' },\n                  ' }',\n                ],\n              ],\n            },\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'my-machine'));\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Parameters: {\n          Param1: { Type: 'String' },\n        },\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"Param\" : ',\n                    { 'Fn::Sub': '${Param1}' },\n                    ' }',\n                  ],\n                ],\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(/Parameter or resource 'Param1' could not be found for evaluation/);\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)",
            "suites": [],
            "updatePoint": {
                "line": 462,
                "column": 135
            },
            "line": 462,
            "code": "  test(\"will not perform a hotswap deployment if it doesn't know how to handle a specific attribute (outside the state machines's name)\", async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Bucket: {\n          Type: 'AWS::S3::Bucket',\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': [\n                '',\n                [\n                  '{ Prop: \"old-value\" }, ',\n                  '{ \"S3Bucket\" : ',\n                  { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                  ' }',\n                ],\n              ],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Machine', 'AWS::StepFunctions::StateMachine', 'arn:aws:states:here:123456789012:stateMachine:my-machine'),\n      setup.stackSummaryOf('Bucket', 'AWS::S3::Bucket', 'my-bucket'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Bucket: {\n            Type: 'AWS::S3::Bucket',\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': [\n                  '',\n                  [\n                    '{ Prop: \"new-value\" }, ',\n                    '{ \"S3Bucket\" : ',\n                    { 'Fn::GetAtt': ['Bucket', 'UnknownAttribute'] },\n                    ' }',\n                  ],\n                ],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    await expect(() =>\n      hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact),\n    ).rejects.toThrow(\"We don't support the 'UnknownAttribute' attribute of the 'AWS::S3::Bucket' resource. This is a CDK limitation. Please report it at https://github.com/aws/aws-cdk/issues/new/choose\");\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "knows how to handle attributes of the AWS::Events::EventBus resource",
            "suites": [],
            "updatePoint": {
                "line": 525,
                "column": 76
            },
            "line": 525,
            "code": "  test('knows how to handle attributes of the AWS::Events::EventBus resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        EventBus: {\n          Type: 'AWS::Events::EventBus',\n          Properties: {\n            Name: 'my-event-bus',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: {\n              'Fn::Join': ['', [\n                '{\"EventBus1Arn\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                '\",\"EventBus1Name\":\"',\n                { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                '\",\"EventBus1Ref\":\"',\n                { Ref: 'EventBus' },\n                '\"}',\n              ]],\n            },\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('EventBus', 'AWS::Events::EventBus', 'my-event-bus'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          EventBus: {\n            Type: 'AWS::Events::EventBus',\n            Properties: {\n              Name: 'my-event-bus',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"EventBus2Arn\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Arn'] },\n                  '\",\"EventBus2Name\":\"',\n                  { 'Fn::GetAtt': ['EventBus', 'Name'] },\n                  '\",\"EventBus2Ref\":\"',\n                  { Ref: 'EventBus' },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        EventBus2Arn: 'arn:aws:events:here:123456789012:event-bus/my-event-bus',\n        EventBus2Name: 'my-event-bus',\n        EventBus2Ref: 'my-event-bus',\n      }),\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "knows how to handle attributes of the AWS::DynamoDB::Table resource",
            "suites": [],
            "updatePoint": {
                "line": 601,
                "column": 75
            },
            "line": 601,
            "code": "  test('knows how to handle attributes of the AWS::DynamoDB::Table resource', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Table: {\n          Type: 'AWS::DynamoDB::Table',\n          Properties: {\n            KeySchema: [{\n              AttributeName: 'name',\n              KeyType: 'HASH',\n            }],\n            AttributeDefinitions: [{\n              AttributeName: 'name',\n              AttributeType: 'S',\n            }],\n            BillingMode: 'PAY_PER_REQUEST',\n          },\n        },\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{}',\n            StateMachineName: 'my-machine',\n          },\n        },\n      },\n    });\n    setup.pushStackResourceSummaries(\n      setup.stackSummaryOf('Table', 'AWS::DynamoDB::Table', 'my-dynamodb-table'),\n    );\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Table: {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              KeySchema: [{\n                AttributeName: 'name',\n                KeyType: 'HASH',\n              }],\n              AttributeDefinitions: [{\n                AttributeName: 'name',\n                AttributeType: 'S',\n              }],\n              BillingMode: 'PAY_PER_REQUEST',\n            },\n          },\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: {\n                'Fn::Join': ['', [\n                  '{\"TableName\":\"',\n                  { Ref: 'Table' },\n                  '\",\"TableArn\":\"',\n                  { 'Fn::GetAtt': ['Table', 'Arn'] },\n                  '\"}',\n                ]],\n              },\n              StateMachineName: 'my-machine',\n            },\n          },\n        },\n      },\n    });\n\n    // THEN\n    const result = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    expect(result).not.toBeUndefined();\n    expect(mockUpdateMachineDefinition).toHaveBeenCalledWith({\n      stateMachineArn: 'arn:aws:states:here:123456789012:stateMachine:my-machine',\n      definition: JSON.stringify({\n        TableName: 'my-dynamodb-table',\n        TableArn: 'arn:aws:dynamodb:here:123456789012:table/my-dynamodb-table',\n      }),\n    });\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not explode if the DependsOn changes",
            "suites": [],
            "updatePoint": {
                "line": 680,
                "column": 49
            },
            "line": 680,
            "code": "  test('does not explode if the DependsOn changes', async () => {\n    // GIVEN\n    setup.setCurrentCfnStackTemplate({\n      Resources: {\n        Machine: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            DefinitionString: '{ Prop: \"old-value\" }',\n            StateMachineName: 'my-machine',\n          },\n          DependsOn: ['abc'],\n        },\n      },\n    });\n    const cdkStackArtifact = setup.cdkStackArtifactOf({\n      template: {\n        Resources: {\n          Machine: {\n            Type: 'AWS::StepFunctions::StateMachine',\n            Properties: {\n              DefinitionString: '{ Prop: \"old-value\" }',\n              StateMachineName: 'my-machine',\n            },\n          },\n          DependsOn: ['xyz'],\n        },\n      },\n    });\n\n    // WHEN\n    const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);\n\n    // THEN\n    expect(deployStackResult).not.toBeUndefined();\n    expect(deployStackResult?.noOp).toEqual(true);\n    expect(mockUpdateMachineDefinition).not.toHaveBeenCalled();\n  });",
            "file": "api/hotswap/state-machine-hotswap-deployments.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly caches calls to the CloudFormation API",
            "suites": [
                "Lazy ListStackResources"
            ],
            "updatePoint": {
                "line": 7,
                "column": 56
            },
            "line": 7,
            "code": "  test('correctly caches calls to the CloudFormation API', async () => {\n    // GIVEN\n    const listStackResMock: jest.Mock<AWS.CloudFormation.ListStackResourcesOutput, AWS.CloudFormation.ListStackResourcesInput[]> = jest.fn();\n    const mockSdk = new MockSdk();\n    mockSdk.stubCloudFormation({\n      listStackResources: listStackResMock,\n    });\n    listStackResMock.mockReturnValue({\n      StackResourceSummaries: [],\n      NextToken: undefined,\n    });\n    const res = new LazyListStackResources(mockSdk, 'StackName');\n\n    // WHEN\n    void res.listStackResources();\n    void res.listStackResources();\n    void res.listStackResources();\n    const result = await res.listStackResources();\n\n    // THEN\n    expect(result.length).toBe(0);\n    expect(listStackResMock).toHaveBeenCalledTimes(1);\n  });",
            "file": "api/lazy-list-stack-resources.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "add log groups from lambda function",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 41
            },
            "line": 19,
            "code": "test('add log groups from lambda function', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n          Properties: {\n            FunctionName: 'my-function',\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['/aws/lambda/my-function']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "add log groups from lambda function without physical name",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 63
            },
            "line": 42,
            "code": "test('add log groups from lambda function without physical name', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        Func: {\n          Type: 'AWS::Lambda::Function',\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('Func', 'AWS::Lambda::Function', 'my-function'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['/aws/lambda/my-function']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "empty template",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 20
            },
            "line": 62,
            "code": "test('empty template', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {},\n  });\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual([]);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "add log groups from ECS Task Definitions",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 46
            },
            "line": 75,
            "code": "test('add log groups from ECS Task Definitions', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        Def: {\n          Type: 'AWS::ECS::TaskDefinition',\n          Properties: {\n            Family: 'app',\n            ContainerDefinitions: [\n              {\n                LogConfiguration: {\n                  LogDriver: 'awslogs',\n                  Options: {\n                    'awslogs-group': { Ref: 'LogGroup' },\n                  },\n                },\n              },\n            ],\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "add log groups from State Machines",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 40
            },
            "line": 114,
            "code": "test('add log groups from State Machines', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        Def: {\n          Type: 'AWS::StepFunctions::StateMachine',\n          Properties: {\n            LoggingConfiguration: {\n              Destinations: [\n                {\n                  CloudWatchLogsLogGroup: {\n                    LogGroupArn: {\n                      'Fn::GetAtt': ['LogGroup', 'Arn'],\n                    },\n                  },\n                },\n              ],\n            },\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "excluded log groups are not added",
            "suites": [],
            "updatePoint": {
                "line": 153,
                "column": 39
            },
            "line": 153,
            "code": "test('excluded log groups are not added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n        LogGroup2: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group2',\n          },\n        },\n        Def: {\n          Type: 'AWS::CodeBuild::Project',\n          Properties: {\n            PojectName: 'project',\n            LogsConfig: {\n              CloudWatchLogs: {\n                GroupName: { Ref: 'LogGroup' },\n              },\n            },\n          },\n        },\n        FlowLog: {\n          Type: 'AWS::EC2::FlowLog',\n          Properties: {\n            LogDestination: { Ref: 'LogGroup' },\n          },\n        },\n        FlowLog2: {\n          Type: 'AWS::EC2::FlowLog',\n          Properties: {\n            LogDestination: {\n              'Fn::GetAtt': ['LogGroup2', 'Arn'],\n            },\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n  pushStackResourceSummaries(stackSummaryOf('LogGroup2', 'AWS::Logs::LogGroup', 'log_group2'));\n  pushStackResourceSummaries(stackSummaryOf('FlowLog', 'AWS::EC2::FlowLog', 'flow_log'));\n  pushStackResourceSummaries(stackSummaryOf('FlowLog2', 'AWS::EC2::FlowLog', 'flow_log2'));\n  pushStackResourceSummaries(stackSummaryOf('Def', 'AWS::CodeBuild:Project', 'project'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual([]);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "unassociated log groups are added",
            "suites": [],
            "updatePoint": {
                "line": 211,
                "column": 39
            },
            "line": 211,
            "code": "test('unassociated log groups are added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n          Properties: {\n            LogGroupName: 'log_group',\n          },\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "log groups without physical names are added",
            "suites": [],
            "updatePoint": {
                "line": 234,
                "column": 49
            },
            "line": 234,
            "code": "test('log groups without physical names are added', async () => {\n  // GIVEN\n  const cdkStackArtifact = cdkStackArtifactOf({\n    template: {\n      Resources: {\n        LogGroup: {\n          Type: 'AWS::Logs::LogGroup',\n        },\n      },\n    },\n  });\n  pushStackResourceSummaries(stackSummaryOf('LogGroup', 'AWS::Logs::LogGroup', 'log_group'));\n\n  // WHEN\n  const result = await findCloudWatchLogGroups(logsMockSdkProvider.mockSdkProvider, cdkStackArtifact);\n\n  // THEN\n  expect(result.logGroupNames).toEqual(['log_group']);\n});",
            "file": "api/logs/find-cloudwatch-logs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "process events",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 20
            },
            "line": 21,
            "code": "test('process events', async () => {\n  // GIVEN\n  const eventDate = new Date(T0 + 102 * 1000);\n  sdk.stubCloudWatchLogs({\n    filterLogEvents() {\n      return {\n        events: [event(102, 'message', eventDate)],\n      };\n    },\n  });\n  monitor.addLogGroups(\n    {\n      name: 'name',\n      account: '11111111111',\n      region: 'us-east-1',\n    },\n    sdk,\n    ['loggroup'],\n  );\n  // WHEN\n  monitor.activate();\n  // need time for the log processing to occur\n  await sleep(1000);\n\n  // THEN\n  const expectedLocaleTimeString = eventDate.toLocaleTimeString();\n  expect(stderrMock).toHaveBeenCalledTimes(1);\n  expect(stderrMock.mock.calls[0][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} message`,\n  );\n});",
            "file": "api/logs/logs-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "process truncated events",
            "suites": [],
            "updatePoint": {
                "line": 53,
                "column": 30
            },
            "line": 53,
            "code": "test('process truncated events', async () => {\n  // GIVEN\n  const eventDate = new Date(T0 + 102 * 1000);\n  const events: AWS.CloudWatchLogs.FilteredLogEvents = [];\n  for (let i = 0; i < 100; i++) {\n    events.push(event(102+i, 'message' + i, eventDate));\n  }\n\n  sdk.stubCloudWatchLogs({\n    filterLogEvents() {\n      return {\n        events,\n        nextToken: 'some-token',\n      };\n    },\n  });\n  monitor.addLogGroups(\n    {\n      name: 'name',\n      account: '11111111111',\n      region: 'us-east-1',\n    },\n    sdk,\n    ['loggroup'],\n  );\n  // WHEN\n  monitor.activate();\n  // need time for the log processing to occur\n  await sleep(1000);\n\n  // THEN\n  const expectedLocaleTimeString = eventDate.toLocaleTimeString();\n  expect(stderrMock).toHaveBeenCalledTimes(101);\n  expect(stderrMock.mock.calls[0][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} message`,\n  );\n  expect(stderrMock.mock.calls[100][0]).toContain(\n    `[${blue('loggroup')}] ${yellow(expectedLocaleTimeString)} >>> \\`watch\\` shows only the first 100 log messages - the rest have been truncated...`,\n  );\n});",
            "file": "api/logs/logs-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "uses default credentials by default",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 90,
                "column": 45
            },
            "line": 90,
            "code": "    test('uses default credentials by default', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          default: { aws_access_key_id: 'access', $account: '11111', $fakeStsOptions: { partition: 'aws-here' } },\n        },\n        config: {\n          default: { region: 'eu-bla-5' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-bla-5');\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('11111'), partition: 'aws-here' });\n\n      // Ask for a different region\n      const sdk = (await provider.forEnvironment({ ...env(uniq('11111')), region: 'rgn' }, Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('access'));\n      expect(sdk.currentRegion).toEqual('rgn');\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws if profile credentials are not for the right account",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 113,
                "column": 69
            },
            "line": 113,
            "code": "    test('throws if profile credentials are not for the right account', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          'profile boo': { aws_access_key_id: 'access', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile('boo');\n\n      await expect(provider.forEnvironment(env(uniq('some_account_#')), Mode.ForReading)).rejects.toThrow('Need to perform AWS calls');\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "use profile acct/region if agnostic env requested",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 126,
                "column": 59
            },
            "line": 126,
            "code": "    test('use profile acct/region if agnostic env requested', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          default: { aws_access_key_id: 'access', $account: '11111' },\n        },\n        config: {\n          default: { region: 'eu-bla-5' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // THEN\n      const sdk = (await provider.forEnvironment(cxapi.EnvironmentUtils.make(cxapi.UNKNOWN_ACCOUNT, cxapi.UNKNOWN_REGION), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('access'));\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('11111'));\n      expect(sdk.currentRegion).toEqual('eu-bla-5');\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passing profile skips EnvironmentCredentials",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 146,
                "column": 54
            },
            "line": 146,
            "code": "    test('passing profile skips EnvironmentCredentials', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          foo: { aws_access_key_id: 'access', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile('foo');\n\n      const environmentCredentialsPrototype = (new AWS.EnvironmentCredentials('AWS')).constructor.prototype;\n\n      await withMocked(environmentCredentialsPrototype, 'refresh', async (refresh) => {\n        refresh.mockImplementation((callback: (err?: Error) => void) => callback(new Error('This function should not have been called')));\n\n        // WHEN\n        expect((await provider.defaultAccount())?.accountId).toEqual(uniq('11111'));\n\n        expect(refresh).not.toHaveBeenCalled();\n      });\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "supports profile spread over config_file and credentials_file",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 168,
                "column": 71
            },
            "line": 168,
            "code": "    test('supports profile spread over config_file and credentials_file', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          foo: { aws_access_key_id: 'fooccess', $account: '22222' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile foo': { region: 'eu-west-1' },\n        },\n      });\n      const provider = await SdkProvider.withAwsCliCompatibleDefaults({ ...defaultCredOptions, profile: 'foo' });\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-west-1');\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });\n\n      const sdk = (await provider.forEnvironment(env(uniq('22222')), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('fooccess'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "supports profile only in config_file",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 190,
                "column": 46
            },
            "line": 190,
            "code": "    test('supports profile only in config_file', async () => {\n      // WHEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile foo': { aws_access_key_id: 'fooccess', $account: '22222' },\n        },\n      });\n      const provider = await providerFromProfile('foo');\n\n      // THEN\n      expect(provider.defaultRegion).toEqual('eu-bla-5'); // Fall back to default config\n      await expect(provider.defaultAccount()).resolves.toEqual({ accountId: uniq('22222'), partition: 'aws' });\n\n      const sdk = (await provider.forEnvironment(env(uniq('22222')), Mode.ForReading)).sdk;\n      expect(sdkConfig(sdk).credentials!.accessKeyId).toEqual(uniq('fooccess'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume-role configured in config",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 209,
                "column": 46
            },
            "line": 209,
            "code": "    test('can assume-role configured in config', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '11111' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile assumer': { region: 'us-east-2' },\n          'profile assumable': {\n            role_arn: 'arn:aws:iam::66666:role/Assumable',\n            source_profile: 'assumer',\n            $account: '66666',\n            $fakeStsOptions: { allowedAccounts: ['11111'] },\n          },\n        },\n      });\n      const provider = await providerFromProfile('assumable');\n\n      // WHEN\n      const sdk = (await provider.forEnvironment(env(uniq('66666')), Mode.ForReading)).sdk;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume role even if [default] profile is missing",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 236,
                "column": 62
            },
            "line": 236,
            "code": "    test('can assume role even if [default] profile is missing', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '22222' },\n          assumable: { role_arn: 'arn:aws:iam::12356789012:role/Assumable', source_profile: 'assumer', $account: '22222' },\n        },\n        config: {\n          'profile assumable': { region: 'eu-bla-5' },\n        },\n      });\n\n      // WHEN\n      const provider = await providerFromProfile('assumable');\n\n      // THEN\n      expect((await provider.defaultAccount())?.accountId).toEqual(uniq('22222'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "mfa_serial in profile will ask user for token",
            "suites": [
                "with intercepted network calls",
                "when CDK does not AssumeRole"
            ],
            "updatePoint": {
                "line": 256,
                "column": 55
            },
            "line": 256,
            "code": "    test('mfa_serial in profile will ask user for token', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        credentials: {\n          assumer: { aws_access_key_id: 'assumer', $account: '66666' },\n        },\n        config: {\n          'default': { region: 'eu-bla-5' },\n          'profile assumer': { region: 'us-east-2' },\n          'profile mfa-role': {\n            role_arn: 'arn:aws:iam::66666:role/Assumable',\n            source_profile: 'assumer',\n            mfa_serial: 'arn:aws:iam::account:mfa/user',\n            $account: '66666',\n          },\n        },\n      });\n      const provider = await providerFromProfile('mfa-role');\n\n      const promptlyMockCalls = (promptly.prompt as jest.Mock).mock.calls.length;\n\n      // THEN\n      const sdk = (await provider.forEnvironment(env(uniq('66666')), Mode.ForReading)).sdk;\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('66666'));\n      expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n        roleArn: 'arn:aws:iam::66666:role/Assumable',\n        serialNumber: 'arn:aws:iam::account:mfa/user',\n        tokenCode: '1234',\n      }));\n\n      // Mock response was set to fail to make sure we don't call STS\n      // Make sure the MFA mock was called during this test\n      expect((promptly.prompt as jest.Mock).mock.calls.length).toBe(promptlyMockCalls + 1);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "error we get from assuming a role is useful",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 300,
                "column": 53
            },
            "line": 300,
            "code": "    test('error we get from assuming a role is useful', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      const promise = provider.forEnvironment(env(uniq('88888')), Mode.ForReading, {\n        assumeRoleArn: 'doesnotexist.role.arn',\n      });\n\n      // THEN - error message contains both a helpful hint and the underlying AssumeRole message\n      await expect(promise).rejects.toThrow('(re)-bootstrap the environment');\n      await expect(promise).rejects.toThrow('doesnotexist.role.arn');\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "assuming a role sanitizes the username into the session name",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 320,
                "column": 70
            },
            "line": 320,
            "code": "    test('assuming a role sanitizes the username into the session name', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n\n      await withMocked(os, 'userInfo', async (userInfo) => {\n        userInfo.mockReturnValue({ username: 'skål', uid: 1, gid: 1, homedir: '/here', shell: '/bin/sh' });\n\n        // WHEN\n        const provider = await providerFromProfile(undefined);\n\n        const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n        await sdk.currentAccount();\n\n        // THEN\n        expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n          roleSessionName: 'aws-cdk-sk@l',\n        }));\n      });\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "assuming a role does not fail when OS username cannot be read",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 345,
                "column": 71
            },
            "line": 345,
            "code": "    test('assuming a role does not fail when OS username cannot be read', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n\n      await withMocked(os, 'userInfo', async (userInfo) => {\n        userInfo.mockImplementation(() => {\n          // SystemError thrown as documented: https://nodejs.org/docs/latest-v16.x/api/os.html#osuserinfooptions\n          throw new Error('SystemError on Linux: uv_os_get_passwd returned ENOENT. See #19401 issue.');\n        });\n\n        // WHEN\n        const provider = await providerFromProfile(undefined);\n\n        const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n        await sdk.currentAccount();\n\n        // THEN\n        expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n          roleSessionName: 'aws-cdk-noname',\n        }));\n      });\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "even if current credentials are for the wrong account, we will still use them to AssumeRole",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 373,
                "column": 101
            },
            "line": 373,
            "code": "    test('even if current credentials are for the wrong account, we will still use them to AssumeRole', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if AssumeRole fails but current credentials are for the right account, we will still use them",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 390,
                "column": 103
            },
            "line": 390,
            "code": "    test('if AssumeRole fails but current credentials are for the right account, we will still use them', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '88888' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN - assumeRole fails because the role can only be assumed from account 11111\n      const sdk = (await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: 'arn:aws:role' })).sdk as SDK;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('88888'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if AssumeRole fails because of ExpiredToken, then fail completely",
            "suites": [
                "with intercepted network calls",
                "when CDK AssumeRoles"
            ],
            "updatePoint": {
                "line": 407,
                "column": 75
            },
            "line": 407,
            "code": "    test('if AssumeRole fails because of ExpiredToken, then fail completely', async () => {\n      // GIVEN\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '88888' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN - assumeRole fails with a specific error\n      await expect(async () => {\n        await provider.forEnvironment(env(uniq('88888')), Mode.ForReading, { assumeRoleArn: '<FAIL:ExpiredToken>' });\n      }).rejects.toThrow(/ExpiredToken/);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not use plugins if current credentials are for expected account",
            "suites": [
                "with intercepted network calls",
                "Plugins"
            ],
            "updatePoint": {
                "line": 425,
                "column": 78
            },
            "line": 425,
            "code": "    test('does not use plugins if current credentials are for expected account', async () => {\n      prepareCreds({\n        fakeSts,\n        config: {\n          default: { aws_access_key_id: 'foo', $account: '11111' },\n        },\n      });\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('11111')), Mode.ForReading);\n      expect(pluginQueried).toEqual(false);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "uses plugin for account 99999",
            "suites": [
                "with intercepted network calls",
                "Plugins"
            ],
            "updatePoint": {
                "line": 437,
                "column": 39
            },
            "line": 437,
            "code": "    test('uses plugin for account 99999', async () => {\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading);\n      expect(pluginQueried).toEqual(true);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume role with credentials from plugin",
            "suites": [
                "with intercepted network calls",
                "Plugins"
            ],
            "updatePoint": {
                "line": 443,
                "column": 54
            },
            "line": 443,
            "code": "    test('can assume role with credentials from plugin', async () => {\n      fakeSts.registerRole(uniq('99999'), 'arn:aws:iam::99999:role/Assumable');\n\n      const provider = await providerFromProfile(undefined);\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading, {\n        assumeRoleArn: 'arn:aws:iam::99999:role/Assumable',\n      });\n\n      expect(fakeSts.assumedRoles[0]).toEqual(expect.objectContaining({\n        roleArn: 'arn:aws:iam::99999:role/Assumable',\n      }));\n      expect(pluginQueried).toEqual(true);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "even if AssumeRole fails but current credentials are from a plugin, we will still use them",
            "suites": [
                "with intercepted network calls",
                "Plugins"
            ],
            "updatePoint": {
                "line": 457,
                "column": 100
            },
            "line": 457,
            "code": "    test('even if AssumeRole fails but current credentials are from a plugin, we will still use them', async () => {\n      const provider = await providerFromProfile(undefined);\n      const sdk = (await provider.forEnvironment(env(uniq('99999')), Mode.ForReading, { assumeRoleArn: 'does:not:exist' })).sdk;\n\n      // THEN\n      expect((await sdk.currentAccount()).accountId).toEqual(uniq('99999'));\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "plugins are still queried even if current credentials are expired (or otherwise invalid)",
            "suites": [
                "with intercepted network calls",
                "Plugins"
            ],
            "updatePoint": {
                "line": 465,
                "column": 98
            },
            "line": 465,
            "code": "    test('plugins are still queried even if current credentials are expired (or otherwise invalid)', async () => {\n      // GIVEN\n      process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;\n      process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n      const provider = await providerFromProfile(undefined);\n\n      // WHEN\n      await provider.forEnvironment(env(uniq('99999')), Mode.ForReading);\n\n      // THEN\n      expect(pluginQueried).toEqual(true);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume role with ecs credentials",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 480,
                "column": 46
            },
            "line": 480,
            "code": "    test('can assume role with ecs credentials', async () => {\n      return withMocked(AWS.ECSCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'EcsContainer', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n      });\n\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume role with ec2 credentials",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 499,
                "column": 46
            },
            "line": 499,
            "code": "    test('can assume role with ec2 credentials', async () => {\n      return withMocked(AWS.EC2MetadataCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Ec2InstanceMetadata', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n\n      });\n\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can assume role with env credentials",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 519,
                "column": 46
            },
            "line": 519,
            "code": "    test('can assume role with env credentials', async () => {\n      return withMocked(AWS.EnvironmentCredentials.prototype, 'needsRefresh', async (needsRefresh) => {\n        // GIVEN\n        prepareCreds({\n          config: {\n            'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'Environment', $account: '22222' },\n          },\n        });\n        const provider = await providerFromProfile('ecs');\n\n        // WHEN\n        await provider.defaultAccount();\n\n        // THEN\n        expect(needsRefresh).toHaveBeenCalled();\n      });\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "assume fails with unsupported credential_source",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 537,
                "column": 57
            },
            "line": 537,
            "code": "    test('assume fails with unsupported credential_source', async () => {\n      // GIVEN\n      prepareCreds({\n        config: {\n          'profile ecs': { role_arn: 'arn:aws:iam::12356789012:role/Assumable', credential_source: 'unsupported', $account: '22222' },\n        },\n      });\n      const provider = await providerFromProfile('ecs');\n\n      // WHEN\n      const account = await provider.defaultAccount();\n\n      // THEN\n      expect(account?.accountId).toEqual(undefined);\n    });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "defaultAccount returns undefined if STS call fails",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 554,
                "column": 58
            },
            "line": 554,
            "code": "  test('defaultAccount returns undefined if STS call fails', async () => {\n    // GIVEN\n    process.env.AWS_ACCESS_KEY_ID = `${uid}akid`;\n    process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n\n    // WHEN\n    const provider = await providerFromProfile(undefined);\n\n    // THEN\n    await expect(provider.defaultAccount()).resolves.toBe(undefined);\n  });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "defaultAccount returns undefined, event if STS call fails with ExpiredToken",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 566,
                "column": 83
            },
            "line": 566,
            "code": "  test('defaultAccount returns undefined, event if STS call fails with ExpiredToken', async () => {\n    // GIVEN\n    process.env.AWS_ACCESS_KEY_ID = `${uid}'<FAIL:ExpiredToken>'`;\n    process.env.AWS_SECRET_ACCESS_KEY = 'sekrit';\n\n    // WHEN\n    const provider = await providerFromProfile(undefined);\n\n    // THEN\n    await expect(provider.defaultAccount()).resolves.toBe(undefined);\n  });",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "even when using a profile to assume another profile, STS calls goes through the proxy",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 579,
                "column": 91
            },
            "line": 579,
            "code": "test('even when using a profile to assume another profile, STS calls goes through the proxy', async () => {\n  prepareCreds({\n    credentials: {\n      assumer: { aws_access_key_id: 'assumer' },\n    },\n    config: {\n      'default': { region: 'eu-bla-5' },\n      'profile assumable': { role_arn: 'arn:aws:iam::66666:role/Assumable', source_profile: 'assumer', $account: '66666' },\n      'profile assumer': { region: 'us-east-2' },\n    },\n  });\n\n  // Messy mocking\n  let called = false;\n  jest.mock('proxy-agent', () => {\n    // eslint-disable-next-line @typescript-eslint/no-require-imports\n    class FakeAgent extends require('https').Agent {\n      public addRequest(_: any, __: any) {\n        // FIXME: this error takes 6 seconds to be completely handled. It\n        // might be retries in the SDK somewhere, or something about the Node\n        // event loop. I've spent an hour trying to figure it out and I can't,\n        // and I gave up. We'll just have to live with this until someone gets\n        // inspired.\n        const error = new Error('ABORTED BY TEST');\n        (error as any).code = 'RequestAbortedError';\n        (error as any).retryable = false;\n        called = true;\n        throw error;\n      }\n    }\n    return FakeAgent;\n  });\n\n  // WHEN\n  const provider = await SdkProvider.withAwsCliCompatibleDefaults({\n    ...defaultCredOptions,\n    profile: 'assumable',\n    httpOptions: {\n      proxyAddress: 'http://DOESNTMATTER/',\n    },\n  });\n\n  await provider.defaultAccount();\n\n  // THEN -- the fake proxy agent got called, we don't care about the result\n  expect(called).toEqual(true);\n});",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "default useragent is reasonable",
            "suites": [
                "with intercepted network calls",
                "support for credential_source"
            ],
            "updatePoint": {
                "line": 627,
                "column": 37
            },
            "line": 627,
            "code": "test('default useragent is reasonable', () => {\n  expect(defaultCliUserAgent()).toContain('aws-cdk/');\n});",
            "file": "api/sdk-provider.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints 0/4 progress report, when addActivity is called with an \"IN_PROGRESS\" ResourceStatus",
            "suites": [],
            "updatePoint": {
                "line": 15,
                "column": 97
            },
            "line": 15,
            "code": "test('prints 0/4 progress report, when addActivity is called with an \"IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/4 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE\" ResourceStatus",
            "suites": [],
            "updatePoint": {
                "line": 39,
                "column": 101
            },
            "line": 39,
            "code": "test('prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus",
            "suites": [],
            "updatePoint": {
                "line": 63,
                "column": 119
            },
            "line": 63,
            "code": "test('prints 1/4 progress report, when addActivity is called with an \"UPDATE_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE_CLEA')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints 1/4 progress report, when addActivity is called with an \"ROLLBACK_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus",
            "suites": [],
            "updatePoint": {
                "line": 88,
                "column": 121
            },
            "line": 88,
            "code": "test('prints 1/4 progress report, when addActivity is called with an \"ROLLBACK_COMPLETE_CLEAN_IN_PROGRESS\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 1/4 | ${HUMAN_TIME} | ${yellow('ROLLBACK_COMPLETE_CL')} | AWS::CloudFormation::Stack | ${yellow(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints 0/4 progress report, when addActivity is called with an \"UPDATE_FAILED\" ResourceStatus",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 99
            },
            "line": 112,
            "code": "test('prints 0/4 progress report, when addActivity is called with an \"UPDATE_FAILED\" ResourceStatus', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 3,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n  });\n\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/4 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not print \"Failed Resources:\" list, when all deployments are successful",
            "suites": [],
            "updatePoint": {
                "line": 137,
                "column": 82
            },
            "line": 137,
            "code": "test('does not print \"Failed Resources:\" list, when all deployments are successful', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack2',\n        ResourceStatus: 'UPDATE_COMPLETE',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(3);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 1/2 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack1'))}`);\n  expect(output[2].trim()).toStrictEqual(`stack-name | 2/2 | ${HUMAN_TIME} | ${green('UPDATE_COMPLETE     ')} | AWS::CloudFormation::Stack | ${green(bold('stack2'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prints \"Failed Resources:\" list, when at least one deployment fails",
            "suites": [],
            "updatePoint": {
                "line": 187,
                "column": 73
            },
            "line": 187,
            "code": "test('prints \"Failed Resources:\" list, when at least one deployment fails', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(4);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n  expect(output[2].trim()).toStrictEqual('Failed resources:');\n  expect(output[3].trim()).toStrictEqual(`stack-name | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "print failed resources because of hook failures",
            "suites": [],
            "updatePoint": {
                "line": 227,
                "column": 53
            },
            "line": 227,
            "code": "test('print failed resources because of hook failures', () => {\n  const historyActivityPrinter = new HistoryActivityPrinter({\n    resourceTypeColumnWidth: 23,\n    resourcesTotal: 1,\n    stream: process.stderr,\n  });\n\n  const output = stderr.inspectSync(() => {\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'IN_PROGRESS',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n        HookStatus: 'HOOK_COMPLETE_FAILED',\n        HookType: 'hook1',\n        HookStatusReason: 'stack1 must obey certain rules',\n      },\n    });\n    historyActivityPrinter.addActivity({\n      event: {\n        LogicalResourceId: 'stack1',\n        ResourceStatus: 'UPDATE_FAILED',\n        Timestamp: new Date(TIMESTAMP),\n        ResourceType: 'AWS::CloudFormation::Stack',\n        StackId: '',\n        EventId: '',\n        StackName: 'stack-name',\n        ResourceStatusReason: 'The following hook(s) failed: hook1',\n      },\n    });\n    historyActivityPrinter.stop();\n  });\n\n  expect(output.length).toStrictEqual(4);\n  expect(output[0].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${reset('IN_PROGRESS         ')} | AWS::CloudFormation::Stack | ${reset(bold('stack1'))}`);\n  expect(output[1].trim()).toStrictEqual(`stack-name | 0/2 | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1 The following hook(s) failed: hook1 : stack1 must obey certain rules'))}`);\n  expect(output[2].trim()).toStrictEqual('Failed resources:');\n  expect(output[3].trim()).toStrictEqual(`stack-name | ${HUMAN_TIME} | ${red('UPDATE_FAILED       ')} | AWS::CloudFormation::Stack | ${red(bold('stack1 The following hook(s) failed: hook1 : stack1 must obey certain rules'))}`);\n});",
            "file": "api/stack-activity-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 100
            },
            "line": 11,
            "code": "test('failure to read SSM parameter results in upgrade message for existing bootstrap stack under v5', async () => {\n  // GIVEN\n  const toolkitInfo = ToolkitInfo.fromStack(mockBootstrapStack(mockSdk, {\n    Outputs: [{ OutputKey: 'BootstrapVersion', OutputValue: '4' }],\n  }), mockSdk);\n\n  mockSdk.stubSsm({\n    getParameter() {\n      throw errorWithCode('AccessDeniedException', 'Computer says no');\n    },\n  });\n\n  // THEN\n  await expect(toolkitInfo.validateVersion(99, '/abc')).rejects.toThrow(/This CDK deployment requires bootstrap stack version/);\n});",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 110
            },
            "line": 27,
            "code": "test('failure to read SSM parameter results in exception passthrough for existing bootstrap stack v5 or higher', async () => {\n  // GIVEN\n  const toolkitInfo = ToolkitInfo.fromStack(mockBootstrapStack(mockSdk, {\n    Outputs: [{ OutputKey: 'BootstrapVersion', OutputValue: '5' }],\n  }), mockSdk);\n\n  mockSdk.stubSsm({\n    getParameter() {\n      throw errorWithCode('AccessDeniedException', 'Computer says no');\n    },\n  });\n\n  // THEN\n  await expect(toolkitInfo.validateVersion(99, '/abc')).rejects.toThrow(/Computer says no/);\n});",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validating version with explicit SSM parameter succeeds",
            "suites": [
                "validateversion without bootstrap stack"
            ],
            "updatePoint": {
                "line": 49,
                "column": 63
            },
            "line": 49,
            "code": "  test('validating version with explicit SSM parameter succeeds', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        return { Parameter: { Value: '10' } };\n      },\n    });\n\n    // THEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).resolves.toBeUndefined();\n  });",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validating version without explicit SSM parameter fails",
            "suites": [
                "validateversion without bootstrap stack"
            ],
            "updatePoint": {
                "line": 61,
                "column": 63
            },
            "line": 61,
            "code": "  test('validating version without explicit SSM parameter fails', async () => {\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, undefined)).rejects.toThrow(/This deployment requires a bootstrap stack with a known name/);\n  });",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validating version with access denied error gives upgrade hint",
            "suites": [
                "validateversion without bootstrap stack"
            ],
            "updatePoint": {
                "line": 66,
                "column": 70
            },
            "line": 66,
            "code": "  test('validating version with access denied error gives upgrade hint', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        throw errorWithCode('AccessDeniedException', 'Computer says no');\n      },\n    });\n\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).rejects.toThrow(/This CDK deployment requires bootstrap stack version/);\n  });",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validating version with missing parameter gives bootstrap hint",
            "suites": [
                "validateversion without bootstrap stack"
            ],
            "updatePoint": {
                "line": 78,
                "column": 70
            },
            "line": 78,
            "code": "  test('validating version with missing parameter gives bootstrap hint', async () => {\n    // GIVEN\n    mockSdk.stubSsm({\n      getParameter() {\n        throw errorWithCode('ParameterNotFound', 'Wut?');\n      },\n    });\n\n    // WHEN\n    await expect(toolkitInfo.validateVersion(8, '/abc')).rejects.toThrow(/Has the environment been bootstrapped?/);\n  });",
            "file": "api/toolkit-info.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "displayLines writes maximum lines based on rows if there are more lines than rows",
            "suites": [
                "Rewritable Block Tests"
            ],
            "updatePoint": {
                "line": 13,
                "column": 89
            },
            "line": 13,
            "code": "  test('displayLines writes maximum lines based on rows if there are more lines than rows', () => {\n    const lines = Array.from(Array(100).keys()).map(line => line.toString());\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(block.height!);\n  });",
            "file": "api/util/display.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "displayLines writes maximum lines based on lines length if there are less lines than rows",
            "suites": [
                "Rewritable Block Tests"
            ],
            "updatePoint": {
                "line": 22,
                "column": 97
            },
            "line": 22,
            "code": "  test('displayLines writes maximum lines based on lines length if there are less lines than rows', () => {\n    const lines = Array.from(Array(45).keys()).map(line => line.toString());\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(46);\n  });",
            "file": "api/util/display.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "displayLines writes maximum lines based on lines length if rows is undefined",
            "suites": [
                "Rewritable Block Tests"
            ],
            "updatePoint": {
                "line": 31,
                "column": 84
            },
            "line": 31,
            "code": "  test('displayLines writes maximum lines based on lines length if rows is undefined', () => {\n    const lines = Array.from(Array(5).keys()).map(line => line.toString());\n    process.stderr.rows = undefined as any;\n    const output = stderr.inspectSync(() => {\n      block.displayLines(lines);\n    });\n\n    expect(output.length).toEqual(6);\n  });",
            "file": "api/util/display.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "display accounts for newlines in output",
            "suites": [
                "Rewritable Block Tests"
            ],
            "updatePoint": {
                "line": 41,
                "column": 47
            },
            "line": 41,
            "code": "  test('display accounts for newlines in output', () => {\n    const output = stderr.inspectSync(() => {\n      block.displayLines(['before\\nafter']);\n    });\n    expect(output.length).toEqual(3); // cursorup + 2 lines\n  });",
            "file": "api/util/display.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "removeEmptyLines only removes trailing lines",
            "suites": [
                "Rewritable Block Tests"
            ],
            "updatePoint": {
                "line": 48,
                "column": 52
            },
            "line": 48,
            "code": "  test('removeEmptyLines only removes trailing lines', () => {\n    stderr.inspectSync(() => {\n      block.displayLines(Array.from(Array(5).keys()).map(x => `${x}`));\n    });\n    stderr.inspectSync(() => {\n      // Leaves 3 empty lines\n      block.displayLines(Array.from(Array(2).keys()).map(x => `${x}`));\n    });\n\n    const output = stderr.inspectSync(() => {\n      block.removeEmptyLines();\n    });\n    const expectedEmptyLines = 3;\n    expect(JSON.stringify(output)).toEqual(JSON.stringify([`\\u001b[${expectedEmptyLines}A`]));\n  });",
            "file": "api/util/display.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "convert to manifest and parameters",
            "suites": [
                "file assets"
            ],
            "updatePoint": {
                "line": 18,
                "column": 42
            },
            "line": 18,
            "code": "  test('convert to manifest and parameters', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        sourceHash: 'source-hash',\n        path: __filename,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(params).toEqual({\n      BucketParameter: 'MockToolkitBucketName',\n      KeyParameter: 'assets/SomeStackSomeResource4567/||source-hash.js',\n      ArtifactHashParameter: 'source-hash',\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        destination: {\n          bucketName: 'MockToolkitBucketName',\n          objectKey: 'assets/SomeStackSomeResource4567/source-hash.js',\n        },\n        source: {\n          packaging: 'file',\n          path: __filename,\n        },\n      }),\n    ]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "hash and ID the same => only one path component",
            "suites": [
                "file assets"
            ],
            "updatePoint": {
                "line": 56,
                "column": 55
            },
            "line": 56,
            "code": "  test('hash and ID the same => only one path component', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        sourceHash: 'source-hash',\n        path: __filename,\n        id: 'source-hash',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n      },\n    ]);\n\n    // WHEN\n    await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        destination: {\n          bucketName: 'MockToolkitBucketName',\n          objectKey: 'assets/source-hash.js',\n        },\n      }),\n    ]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "reuse",
            "suites": [
                "file assets"
            ],
            "updatePoint": {
                "line": 84,
                "column": 13
            },
            "line": 84,
            "code": "  test('reuse', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        path: __filename,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'file',\n        s3BucketParameter: 'BucketParameter',\n        s3KeyParameter: 'KeyParameter',\n        artifactHashParameter: 'ArtifactHashParameter',\n        sourceHash: 'boom',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit, ['SomeStackSomeResource4567']);\n\n    // THEN\n    expect(params).toEqual({\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "parameter and no repository name (old)",
            "suites": [
                "docker assets"
            ],
            "updatePoint": {
                "line": 110,
                "column": 46
            },
            "line": 110,
            "code": "  test('parameter and no repository name (old)', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        imageNameParameter: 'MyParameter',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n    mockFn(toolkit.prepareEcrRepository).mockResolvedValue({ repositoryUri: 'docker.uri' });\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(toolkit.prepareEcrRepository).toHaveBeenCalledWith('cdk/stack-construct-abc123');\n    expect(params).toEqual({\n      MyParameter: 'docker.uri:0123456789abcdef',\n    });\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        type: 'docker-image',\n        destination: {\n          imageTag: '0123456789abcdef',\n          repositoryName: 'cdk/stack-construct-abc123',\n        },\n        source: {\n          directory: '/foo',\n        },\n      }),\n    ]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if parameter is left out then repo and tag are required",
            "suites": [
                "docker assets"
            ],
            "updatePoint": {
                "line": 145,
                "column": 63
            },
            "line": 145,
            "code": "  test('if parameter is left out then repo and tag are required', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n\n    await expect(addMetadataAssetsToManifest(stack, assets, toolkit)).rejects.toThrow('Invalid Docker image asset');\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "no parameter and repo/tag name (new)",
            "suites": [
                "docker assets"
            ],
            "updatePoint": {
                "line": 159,
                "column": 44
            },
            "line": 159,
            "code": "  test('no parameter and repo/tag name (new)', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        id: 'Stack:Construct/ABC123',\n        repositoryName: 'reponame',\n        imageTag: '12345',\n        packaging: 'container-image',\n        path: '/foo',\n        sourceHash: '0123456789abcdef',\n      },\n    ]);\n    mockFn(toolkit.prepareEcrRepository).mockResolvedValue({ repositoryUri: 'docker.uri' });\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit);\n\n    // THEN\n    expect(toolkit.prepareEcrRepository).toHaveBeenCalledWith('reponame');\n    expect(params).toEqual({}); // No parameters!\n    expect(assets.toManifest('.').entries).toEqual([\n      expect.objectContaining({\n        type: 'docker-image',\n        destination: {\n          imageTag: '12345',\n          repositoryName: 'reponame',\n        },\n        source: {\n          directory: '/foo',\n        },\n      }),\n    ]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "reuse",
            "suites": [
                "docker assets"
            ],
            "updatePoint": {
                "line": 193,
                "column": 13
            },
            "line": 193,
            "code": "  test('reuse', async () => {\n    // GIVEN\n    const stack = stackWithAssets([\n      {\n        path: __dirname,\n        id: 'SomeStackSomeResource4567',\n        packaging: 'container-image',\n        imageNameParameter: 'asdf',\n        sourceHash: 'source-hash',\n      },\n    ]);\n\n    // WHEN\n    const params = await addMetadataAssetsToManifest(stack, assets, toolkit, ['SomeStackSomeResource4567']);\n\n    // THEN\n    expect(params).toEqual({\n    });\n\n    expect(assets.toManifest('.').entries).toEqual([]);\n  });",
            "file": "assets.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "the 'waiters' API is available in the current AWS SDK",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 59
            },
            "line": 14,
            "code": "test(\"the 'waiters' API is available in the current AWS SDK\", () => {\n  const waiters = (ecsService as any).api?.waiters;\n\n  expect(waiters).not.toBeUndefined();\n  expect(typeof waiters).toBe('object');\n});",
            "file": "aws-sdk-non-public-apis.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "the 'ResourceWaiter' API is available in the current AWS SDK",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 66
            },
            "line": 21,
            "code": "test(\"the 'ResourceWaiter' API is available in the current AWS SDK\", () => {\n  const resourceWaiter = new (AWS as any).ResourceWaiter(ecsService, 'servicesStable');\n\n  // make sure the 'wait' method is available\n  expect(typeof resourceWaiter.wait).toBe('function');\n});",
            "file": "aws-sdk-non-public-apis.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "build",
            "suites": [
                "buildAllStackAssets"
            ],
            "updatePoint": {
                "line": 15,
                "column": 13
            },
            "line": 15,
            "code": "  test('build', async () => {\n    // GIVEN\n    const buildStackAssets = jest.fn(() => sleep(1));\n\n    // WHEN/THEN\n    await expect(buildAllStackAssets(toPublish, { buildStackAssets }))\n      .resolves\n      .toBeUndefined();\n\n    expect(buildStackAssets).toBeCalledTimes(3);\n    expect(buildStackAssets).toBeCalledWith(A);\n    expect(buildStackAssets).toBeCalledWith(B);\n    expect(buildStackAssets).toBeCalledWith(C);\n  });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors",
            "suites": [
                "buildAllStackAssets"
            ],
            "updatePoint": {
                "line": 30,
                "column": 14
            },
            "line": 30,
            "code": "  test('errors', async () => {\n    // GIVEN\n    const buildStackAssets = async () => { throw new Error('Message'); };\n\n    // WHEN/THEN\n    await expect(buildAllStackAssets(toPublish, { buildStackAssets }))\n      .rejects\n      .toThrow('Building Assets Failed: Error: Message, Error: Message, Error: Message');\n  });",
            "file": "build.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "exits with 0 when everything is OK",
            "suites": [
                "`cdk docs`"
            ],
            "updatePoint": {
                "line": 29,
                "column": 42
            },
            "line": 29,
            "code": "  test('exits with 0 when everything is OK', async () => {\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });",
            "file": "cdk-docs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "exits with 0 when opening the browser fails",
            "suites": [
                "`cdk docs`"
            ],
            "updatePoint": {
                "line": 34,
                "column": 51
            },
            "line": 34,
            "code": "  test('exits with 0 when opening the browser fails', async () => {\n    mockery.registerMock('child_process', {\n      exec(_: string, cb: (err: Error, stdout?: string, stderr?: string) => void) {\n        cb(new Error('TEST'));\n      },\n    });\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });",
            "file": "cdk-docs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "exits with 0 when everything is OK",
            "suites": [
                "`cdk doctor`"
            ],
            "updatePoint": {
                "line": 20,
                "column": 42
            },
            "line": 20,
            "code": "  test('exits with 0 when everything is OK', async () => {\n    const argv: any = {};\n    const result = await realHandler({ args: argv } as any);\n    expect(result).toBe(0);\n  });",
            "file": "cdk-doctor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "lookup role is used",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 178,
                "column": 27
            },
            "line": 178,
            "code": "  test('lookup role is used', async () => {\n    // GIVEN\n    let requestedParameterName: string;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter(request) {\n        requestedParameterName = request.Name;\n        return {\n          Parameter: {\n            Value: '6',\n          },\n        };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(requestedParameterName!).toEqual('/bootstrap/parameter');\n    expect(mockForEnvironment.mock.calls.length).toEqual(2);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fallback to deploy role if bootstrap stack version is not valid",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 212,
                "column": 71
            },
            "line": 212,
            "code": "  test('fallback to deploy role if bootstrap stack version is not valid', async () => {\n    // GIVEN\n    let requestedParameterName: string;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter(request) {\n        requestedParameterName = request.Name;\n        return {\n          Parameter: {\n            Value: '1',\n          },\n        };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(requestedParameterName!).toEqual('/bootstrap/parameter');\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fallback to deploy role if bootstrap version parameter not found",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 253,
                "column": 72
            },
            "line": 253,
            "code": "  test('fallback to deploy role if bootstrap version parameter not found', async () => {\n    // GIVEN\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        throw new Error('not found');\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fallback to deploy role if forEnvironment throws",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 287,
                "column": 56
            },
            "line": 287,
            "code": "  test('fallback to deploy role if forEnvironment throws', async () => {\n    // GIVEN\n    // throw error first for the 'prepareSdkWithLookupRoleFor' call and succeed for the rest\n    mockForEnvironment = jest.fn().mockImplementationOnce(() => { throw new Error('error'); })\n      .mockImplementation(() => { return { sdk: mockCloudExecutable.sdkProvider.sdk, didAssumeRole: true };});\n    mockCloudExecutable.sdkProvider.forEnvironment = mockForEnvironment;\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return { };\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume bloop-lookup:here:123456789012/),\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "dont lookup bootstrap version parameter if default credentials are used",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 326,
                "column": 79
            },
            "line": 326,
            "code": "  test('dont lookup bootstrap version parameter if default credentials are used', async () => {\n    // GIVEN\n    mockForEnvironment = jest.fn().mockImplementation(() => { return { sdk: mockCloudExecutable.sdkProvider.sdk, didAssumeRole: false }; });\n    mockCloudExecutable.sdkProvider.forEnvironment = mockForEnvironment;\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return { };\n      },\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-C'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).toEqual(expect.arrayContaining([\n      expect.stringMatching(/please upgrade to bootstrap version >= 5/),\n    ]));\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(mockForEnvironment.mock.calls.length).toEqual(3);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: 'bloop-lookup:here:123456789012',\n    });\n    expect(mockForEnvironment.mock.calls[1][2]).toEqual({\n      assumeRoleArn: 'bloop:here:123456789012',\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not print warnings if lookup role not provided in stack artifact",
            "suites": [
                "readCurrentTemplate"
            ],
            "updatePoint": {
                "line": 362,
                "column": 75
            },
            "line": 362,
            "code": "  test('do not print warnings if lookup role not provided in stack artifact', async () => {\n    // GIVEN\n    mockCloudExecutable.sdkProvider.stubSSM({\n      getParameter() {\n        return {};\n      },\n    });\n    const cdkToolkit = new CdkToolkit({\n      cloudExecutable: mockCloudExecutable,\n      configuration: mockCloudExecutable.configuration,\n      sdkProvider: mockCloudExecutable.sdkProvider,\n      cloudFormation: new CloudFormationDeployments({ sdkProvider: mockCloudExecutable.sdkProvider }),\n    });\n\n    // WHEN\n    await cdkToolkit.deploy({\n      selector: { patterns: ['Test-Stack-A'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    });\n\n    // THEN\n    expect(flatten(stderrMock.mock.calls)).not.toEqual(expect.arrayContaining([\n      expect.stringMatching(/Could not assume/),\n      expect.stringMatching(/please upgrade to bootstrap version/),\n    ]));\n    expect(mockCloudExecutable.sdkProvider.sdk.ssm).not.toHaveBeenCalled();\n    expect(mockForEnvironment.mock.calls.length).toEqual(2);\n    expect(mockForEnvironment.mock.calls[0][2]).toEqual({\n      assumeRoleArn: undefined,\n      assumeRoleExternalId: undefined,\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fails when no valid stack names are given",
            "suites": [
                "deploy"
            ],
            "updatePoint": {
                "line": 397,
                "column": 49
            },
            "line": 397,
            "code": "  test('fails when no valid stack names are given', async () => {\n    // GIVEN\n    const toolkit = defaultToolkitSetup();\n\n    // WHEN\n    await expect(() => toolkit.deploy({\n      selector: { patterns: ['Test-Stack-D'] },\n      hotswap: HotswapMode.FULL_DEPLOYMENT,\n    })).rejects.toThrow('No stacks match the name(s) Test-Stack-D');\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes through the 'hotswap' option to CloudFormationDeployments.deployStack()",
            "suites": [
                "deploy",
                "with hotswap deployment"
            ],
            "updatePoint": {
                "line": 409,
                "column": 88
            },
            "line": 409,
            "code": "    test(\"passes through the 'hotswap' option to CloudFormationDeployments.deployStack()\", async () => {\n      // GIVEN\n      const mockCfnDeployments = instanceMockFrom(CloudFormationDeployments);\n      mockCfnDeployments.deployStack.mockReturnValue(Promise.resolve({\n        noOp: false,\n        outputs: {},\n        stackArn: 'stackArn',\n        stackArtifact: instanceMockFrom(cxapi.CloudFormationStackArtifact),\n      }));\n      const cdkToolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        cloudFormation: mockCfnDeployments,\n      });\n\n      // WHEN\n      await cdkToolkit.deploy({\n        selector: { patterns: ['Test-Stack-A-Display-Name'] },\n        requireApproval: RequireApproval.Never,\n        hotswap: HotswapMode.FALL_BACK,\n      });\n\n      // THEN\n      expect(mockCfnDeployments.deployStack).toHaveBeenCalledWith(expect.objectContaining({\n        hotswap: HotswapMode.FALL_BACK,\n      }));\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "without options",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 440,
                "column": 25
            },
            "line": 440,
            "code": "    test('without options', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A', 'Test-Stack-B'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "with stacks all stacks specified as double wildcard",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 451,
                "column": 61
            },
            "line": 451,
            "code": "    test('with stacks all stacks specified as double wildcard', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['**'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "with one stack specified",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 463,
                "column": 34
            },
            "line": 463,
            "code": "    test('with one stack specified', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A-Display-Name'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "with stacks all stacks specified as wildcard",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 474,
                "column": 54
            },
            "line": 474,
            "code": "    test('with stacks all stacks specified as wildcard', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['*'] },\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "with sns notification arns",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 485,
                "column": 36
            },
            "line": 485,
            "code": "    test('with sns notification arns', async () => {\n      // GIVEN\n      const notificationArns = [\n        'arn:aws:sns:us-east-2:444455556666:MyTopic',\n        'arn:aws:sns:eu-west-1:111155556666:my-great-topic',\n      ];\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        cloudFormation: new FakeCloudFormation({\n          'Test-Stack-A': { Foo: 'Bar' },\n          'Test-Stack-B': { Baz: 'Zinga!' },\n        }, notificationArns),\n      });\n\n      // WHEN\n      await toolkit.deploy({\n        selector: { patterns: ['Test-Stack-A', 'Test-Stack-B'] },\n        notificationArns,\n        hotswap: HotswapMode.FULL_DEPLOYMENT,\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fail with incorrect sns notification arns",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 509,
                "column": 51
            },
            "line": 509,
            "code": "    test('fail with incorrect sns notification arns', async () => {\n      // GIVEN\n      const notificationArns = ['arn:::cfn-my-cool-topic'];\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        cloudFormation: new FakeCloudFormation({\n          'Test-Stack-A': { Foo: 'Bar' },\n        }, notificationArns),\n      });\n\n      // WHEN\n      await expect(() =>\n        toolkit.deploy({\n          selector: { patterns: ['Test-Stack-A'] },\n          notificationArns,\n          hotswap: HotswapMode.FULL_DEPLOYMENT,\n        }),\n      ).rejects.toThrow('Notification arn arn:::cfn-my-cool-topic is not a valid arn for an SNS topic');\n\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "globless bootstrap uses environment without question",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 532,
                "column": 62
            },
            "line": 532,
            "code": "    test('globless bootstrap uses environment without question', async () => {\n    // GIVEN\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.bootstrap(['aws://56789/south-pole'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '56789',\n        region: 'south-pole',\n        name: 'aws://56789/south-pole',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "globby bootstrap uses whats in the stacks",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 548,
                "column": 51
            },
            "line": 548,
            "code": "    test('globby bootstrap uses whats in the stacks', async () => {\n      // GIVEN\n      const toolkit = defaultToolkitSetup();\n      cloudExecutable.configuration.settings.set(['app'], 'something');\n\n      // WHEN\n      await toolkit.bootstrap(['aws://*/bermuda-triangle-1'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '123456789012',\n        region: 'bermuda-triangle-1',\n        name: 'aws://123456789012/bermuda-triangle-1',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bootstrap can be invoked without the --app argument",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 565,
                "column": 61
            },
            "line": 565,
            "code": "    test('bootstrap can be invoked without the --app argument', async () => {\n      // GIVEN\n      cloudExecutable.configuration.settings.clear();\n      const mockSynthesize = jest.fn();\n      cloudExecutable.synthesize = mockSynthesize;\n\n      const toolkit = defaultToolkitSetup();\n\n      // WHEN\n      await toolkit.bootstrap(['aws://123456789012/west-pole'], bootstrapper, {});\n\n      // THEN\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledWith({\n        account: '123456789012',\n        region: 'west-pole',\n        name: 'aws://123456789012/west-pole',\n      }, expect.anything(), expect.anything());\n      expect(bootstrapper.bootstrapEnvironment).toHaveBeenCalledTimes(1);\n\n      expect(cloudExecutable.hasApp).toEqual(false);\n      expect(mockSynthesize).not.toHaveBeenCalled();\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can disable asset parallelism",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 588,
                "column": 39
            },
            "line": 588,
            "code": "    test('can disable asset parallelism', async () => {\n      // GIVEN\n      cloudExecutable = new MockCloudExecutable({\n        stacks: [MockStack.MOCK_STACK_WITH_ASSET],\n      });\n      const fakeCloudFormation = new FakeCloudFormation({});\n\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        cloudFormation: fakeCloudFormation,\n      });\n\n      // WHEN\n      // Not the best test but following this through to the asset publishing library fails\n      await withMocked(fakeCloudFormation, 'buildStackAssets', async (mockBuildStackAssets) => {\n        await toolkit.deploy({\n          selector: { patterns: ['Test-Stack-Asset'] },\n          assetParallelism: false,\n          hotswap: HotswapMode.FULL_DEPLOYMENT,\n        });\n\n        expect(mockBuildStackAssets).toHaveBeenCalledWith(expect.objectContaining({\n          buildOptions: expect.objectContaining({\n            parallel: false,\n          }),\n        }));\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can disable asset prebuild",
            "suites": [
                "deploy",
                "makes correct CloudFormation calls"
            ],
            "updatePoint": {
                "line": 619,
                "column": 36
            },
            "line": 619,
            "code": "    test('can disable asset prebuild', async () => {\n      // GIVEN\n      cloudExecutable = new MockCloudExecutable({\n        stacks: [MockStack.MOCK_STACK_WITH_ASSET],\n      });\n      const fakeCloudFormation = new FakeCloudFormation({});\n\n      const toolkit = new CdkToolkit({\n        cloudExecutable,\n        configuration: cloudExecutable.configuration,\n        sdkProvider: cloudExecutable.sdkProvider,\n        cloudFormation: fakeCloudFormation,\n      });\n\n      // WHEN\n      // Not the best test but following this through to the asset publishing library fails\n      await withMocked(fakeCloudFormation, 'buildStackAssets', async (mockBuildStackAssets) => {\n        await toolkit.deploy({\n          selector: { patterns: ['Test-Stack-Asset'] },\n          assetBuildTime: AssetBuildTime.JUST_IN_TIME,\n          hotswap: HotswapMode.FULL_DEPLOYMENT,\n        });\n\n        expect(mockBuildStackAssets).not.toHaveBeenCalled();\n      });\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "destroy correct stack",
            "suites": [
                "destroy"
            ],
            "updatePoint": {
                "line": 649,
                "column": 29
            },
            "line": 649,
            "code": "  test('destroy correct stack', async () => {\n    const toolkit = defaultToolkitSetup();\n\n    await expect(() => {\n      return toolkit.destroy({\n        selector: { patterns: ['Test-Stack-A/Test-Stack-C'] },\n        exclusively: true,\n        force: true,\n        fromDeploy: true,\n      });\n    }).resolves;\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "fails when no 'watch' settings are found",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 664,
                "column": 48
            },
            "line": 664,
            "code": "  test(\"fails when no 'watch' settings are found\", async () => {\n    const toolkit = defaultToolkitSetup();\n\n    await expect(() => {\n      return toolkit.watch({\n        selector: { patterns: [] },\n        hotswap: HotswapMode.HOTSWAP_ONLY,\n      });\n    }).rejects.toThrow(\"Cannot use the 'watch' command without specifying at least one directory to monitor. \" +\n      'Make sure to add a \"watch\" key to your cdk.json');\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "observes only the root directory by default",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 676,
                "column": 51
            },
            "line": 676,
            "code": "  test('observes only the root directory by default', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const includeArgs = fakeChokidarWatch.includeArgs;\n    expect(includeArgs.length).toBe(1);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows providing a single string in 'watch.include'",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 689,
                "column": 59
            },
            "line": 689,
            "code": "  test(\"allows providing a single string in 'watch.include'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      include: 'my-dir',\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.includeArgs).toStrictEqual(['my-dir']);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows providing an array of strings in 'watch.include'",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 703,
                "column": 63
            },
            "line": 703,
            "code": "  test(\"allows providing an array of strings in 'watch.include'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      include: ['my-dir1', '**/my-dir2/*'],\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.includeArgs).toStrictEqual(['my-dir1', '**/my-dir2/*']);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "ignores the output dir, dot files, dot directories, and node_modules by default",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 717,
                "column": 87
            },
            "line": 717,
            "code": "  test('ignores the output dir, dot files, dot directories, and node_modules by default', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    cloudExecutable.configuration.settings.set(['output'], 'cdk.out');\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    expect(fakeChokidarWatch.excludeArgs).toStrictEqual([\n      'cdk.out/**',\n      '**/.*',\n      '**/.*/**',\n      '**/node_modules/**',\n    ]);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows providing a single string in 'watch.exclude'",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 735,
                "column": 59
            },
            "line": 735,
            "code": "  test(\"allows providing a single string in 'watch.exclude'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      exclude: 'my-dir',\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const excludeArgs = fakeChokidarWatch.excludeArgs;\n    expect(excludeArgs.length).toBe(5);\n    expect(excludeArgs[0]).toBe('my-dir');\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows providing an array of strings in 'watch.exclude'",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 751,
                "column": 63
            },
            "line": 751,
            "code": "  test(\"allows providing an array of strings in 'watch.exclude'\", async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {\n      exclude: ['my-dir1', '**/my-dir2'],\n    });\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n\n    const excludeArgs = fakeChokidarWatch.excludeArgs;\n    expect(excludeArgs.length).toBe(6);\n    expect(excludeArgs[0]).toBe('my-dir1');\n    expect(excludeArgs[1]).toBe('**/my-dir2');\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows watching with deploy concurrency",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 768,
                "column": 47
            },
            "line": 768,
            "code": "  test('allows watching with deploy concurrency', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({\n      selector: { patterns: [] },\n      concurrency: 3,\n      hotswap: HotswapMode.HOTSWAP_ONLY,\n    });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ concurrency: 3 }));\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p mode",
            "suites": [
                "watch"
            ],
            "line": 784,
            "code": "  describe.each([HotswapMode.FALL_BACK, HotswapMode.HOTSWAP_ONLY])('%p mode', (hotswapMode) => {\n    test('passes through the correct hotswap mode to deployStack()', async () => {\n      cloudExecutable.configuration.settings.set(['watch'], {});\n      const toolkit = defaultToolkitSetup();\n      const cdkDeployMock = jest.fn();\n      toolkit.deploy = cdkDeployMock;\n\n      await toolkit.watch({ selector: { patterns: [] }, hotswap: hotswapMode });\n      fakeChokidarWatcherOn.readyCallback();\n\n      expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: hotswapMode }));\n    });\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "passes through the correct hotswap mode to deployStack()",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 785,
                "column": 66
            },
            "line": 785,
            "code": "    test('passes through the correct hotswap mode to deployStack()', async () => {\n      cloudExecutable.configuration.settings.set(['watch'], {});\n      const toolkit = defaultToolkitSetup();\n      const cdkDeployMock = jest.fn();\n      toolkit.deploy = cdkDeployMock;\n\n      await toolkit.watch({ selector: { patterns: [] }, hotswap: hotswapMode });\n      fakeChokidarWatcherOn.readyCallback();\n\n      expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: hotswapMode }));\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "respects HotswapMode.HOTSWAP_ONLY",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 798,
                "column": 41
            },
            "line": 798,
            "code": "  test('respects HotswapMode.HOTSWAP_ONLY', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.HOTSWAP_ONLY });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.HOTSWAP_ONLY }));\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "respects HotswapMode.FALL_BACK",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 810,
                "column": 38
            },
            "line": 810,
            "code": "  test('respects HotswapMode.FALL_BACK', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.FALL_BACK });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.FALL_BACK }));\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "respects HotswapMode.FULL_DEPLOYMENT",
            "suites": [
                "watch"
            ],
            "updatePoint": {
                "line": 823,
                "column": 44
            },
            "line": 823,
            "code": "  test('respects HotswapMode.FULL_DEPLOYMENT', async () => {\n    cloudExecutable.configuration.settings.set(['watch'], {});\n    const toolkit = defaultToolkitSetup();\n    const cdkDeployMock = jest.fn();\n    toolkit.deploy = cdkDeployMock;\n\n    await toolkit.watch({ selector: { patterns: [] }, hotswap: HotswapMode.FULL_DEPLOYMENT });\n    fakeChokidarWatcherOn.readyCallback();\n\n    expect(cdkDeployMock).toBeCalledWith(expect.objectContaining({ hotswap: HotswapMode.FULL_DEPLOYMENT }));\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not trigger a 'deploy' before the 'ready' event has fired",
            "suites": [
                "watch",
                "with file change events"
            ],
            "updatePoint": {
                "line": 850,
                "column": 72
            },
            "line": 850,
            "code": "    test(\"does not trigger a 'deploy' before the 'ready' event has fired\", async () => {\n      await fakeChokidarWatcherOn.fileEventCallback('add', 'my-file');\n\n      expect(cdkDeployMock).not.toHaveBeenCalled();\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "an initial 'deploy' is triggered, without any file changes",
            "suites": [
                "watch",
                "with file change events",
                "when the 'ready' event has already fired"
            ],
            "updatePoint": {
                "line": 864,
                "column": 70
            },
            "line": 864,
            "code": "      test(\"an initial 'deploy' is triggered, without any file changes\", async () => {\n        expect(cdkDeployMock).toHaveBeenCalledTimes(1);\n      });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does trigger a 'deploy' for a file change",
            "suites": [
                "watch",
                "with file change events",
                "when the 'ready' event has already fired"
            ],
            "updatePoint": {
                "line": 868,
                "column": 53
            },
            "line": 868,
            "code": "      test(\"does trigger a 'deploy' for a file change\", async () => {\n        await fakeChokidarWatcherOn.fileEventCallback('add', 'my-file');\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(2);\n      });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "triggers a 'deploy' twice for two file changes",
            "suites": [
                "watch",
                "with file change events",
                "when the 'ready' event has already fired"
            ],
            "updatePoint": {
                "line": 874,
                "column": 58
            },
            "line": 874,
            "code": "      test(\"triggers a 'deploy' twice for two file changes\", async () => {\n        await Promise.all([\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file1'),\n          fakeChokidarWatcherOn.fileEventCallback('change', 'my-file2'),\n        ]);\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(3);\n      });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "batches file changes that happen during 'deploy'",
            "suites": [
                "watch",
                "with file change events",
                "when the 'ready' event has already fired"
            ],
            "updatePoint": {
                "line": 883,
                "column": 60
            },
            "line": 883,
            "code": "      test(\"batches file changes that happen during 'deploy'\", async () => {\n        await Promise.all([\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file1'),\n          fakeChokidarWatcherOn.fileEventCallback('change', 'my-file2'),\n          fakeChokidarWatcherOn.fileEventCallback('unlink', 'my-file3'),\n          fakeChokidarWatcherOn.fileEventCallback('add', 'my-file4'),\n        ]);\n\n        expect(cdkDeployMock).toHaveBeenCalledTimes(3);\n      });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "successful synth outputs hierarchical stack ids",
            "suites": [
                "synth"
            ],
            "updatePoint": {
                "line": 898,
                "column": 55
            },
            "line": 898,
            "code": "  test('successful synth outputs hierarchical stack ids', async () => {\n    const toolkit = defaultToolkitSetup();\n    await toolkit.synth([], false, false);\n\n    // Separate tests as colorizing hampers detection\n    expect(stderrMock.mock.calls[1][0]).toMatch('Test-Stack-A-Display-Name');\n    expect(stderrMock.mock.calls[1][0]).toMatch('Test-Stack-B');\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "with no stdout option",
            "suites": [
                "synth"
            ],
            "updatePoint": {
                "line": 907,
                "column": 29
            },
            "line": 907,
            "code": "  test('with no stdout option', async () => {\n    // GIVE\n    const toolkit = defaultToolkitSetup();\n\n    // THEN\n    await toolkit.synth(['Test-Stack-A-Display-Name'], false, true);\n    expect(mockData.mock.calls.length).toEqual(0);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "causes synth to fail if autoValidate=true",
            "suites": [
                "synth",
                "stack with error and flagged for validation"
            ],
            "updatePoint": {
                "line": 935,
                "column": 51
            },
            "line": 935,
            "code": "    test('causes synth to fail if autoValidate=true', async() => {\n      const toolkit = defaultToolkitSetup();\n      const autoValidate = true;\n      await expect(toolkit.synth([], false, true, autoValidate)).rejects.toBeDefined();\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "causes synth to succeed if autoValidate=false",
            "suites": [
                "synth",
                "stack with error and flagged for validation"
            ],
            "updatePoint": {
                "line": 941,
                "column": 55
            },
            "line": 941,
            "code": "    test('causes synth to succeed if autoValidate=false', async() => {\n      const toolkit = defaultToolkitSetup();\n      const autoValidate = false;\n      await toolkit.synth([], false, true, autoValidate);\n      expect(mockData.mock.calls.length).toEqual(0);\n    });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack has error and was explicitly selected",
            "suites": [
                "synth",
                "stack with error and flagged for validation"
            ],
            "updatePoint": {
                "line": 949,
                "column": 51
            },
            "line": 949,
            "code": "  test('stack has error and was explicitly selected', async() => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_A,\n        MockStack.MOCK_STACK_B,\n      ],\n      nestedAssemblies: [{\n        stacks: [\n          { properties: { validateOnSynth: false }, ...MockStack.MOCK_STACK_WITH_ERROR },\n        ],\n      }],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await expect(toolkit.synth(['Test-Stack-A/witherrors'], false, true)).rejects.toBeDefined();\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack has error, is not flagged for validation and was not explicitly selected",
            "suites": [
                "synth",
                "stack with error and flagged for validation"
            ],
            "updatePoint": {
                "line": 967,
                "column": 86
            },
            "line": 967,
            "code": "  test('stack has error, is not flagged for validation and was not explicitly selected', async () => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_A,\n        MockStack.MOCK_STACK_B,\n      ],\n      nestedAssemblies: [{\n        stacks: [\n          { properties: { validateOnSynth: false }, ...MockStack.MOCK_STACK_WITH_ERROR },\n        ],\n      }],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.synth([], false, true);\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "stack has dependency and was explicitly selected",
            "suites": [
                "synth",
                "stack with error and flagged for validation"
            ],
            "updatePoint": {
                "line": 985,
                "column": 56
            },
            "line": 985,
            "code": "  test('stack has dependency and was explicitly selected', async () => {\n    cloudExecutable = new MockCloudExecutable({\n      stacks: [\n        MockStack.MOCK_STACK_C,\n        MockStack.MOCK_STACK_D,\n      ],\n    });\n\n    const toolkit = defaultToolkitSetup();\n\n    await toolkit.synth([MockStack.MOCK_STACK_D.stackName], true, false);\n\n    expect(mockData.mock.calls.length).toEqual(1);\n    expect(mockData.mock.calls[0][0]).toBeDefined();\n  });",
            "file": "cdk-toolkit.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "runs",
            "suites": [
                "context --list"
            ],
            "updatePoint": {
                "line": 6,
                "column": 12
            },
            "line": 6,
            "code": "  test('runs', async() => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: {},\n    } as any);\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can remove a context key",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 24,
                "column": 32
            },
            "line": 24,
            "code": "  test('can remove a context key', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('baz', 'quux');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n      baz: 'quux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'foo' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      baz: 'quux',\n    });\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can remove a context key using number",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 47,
                "column": 45
            },
            "line": 47,
            "code": "  test('can remove a context key using number', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('baz', 'quux');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n      baz: 'quux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: '1' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can reset matched pattern",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 71,
                "column": 33
            },
            "line": 71,
            "code": "  test('can reset matched pattern', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('match-a', 'baz');\n    configuration.context.set('match-b', 'qux');\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'qux',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "prefers an exact match",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 97,
                "column": 30
            },
            "line": 97,
            "code": "  test('prefers an exact match', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n    configuration.context.set('fo*', 'baz');\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'fo*': 'baz',\n    });\n\n    // WHEN\n    await realHandler({\n      configuration,\n      args: { reset: 'fo*' },\n    } as any);\n\n    // THEN\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "doesn't throw when at least one match is reset",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 121,
                "column": 55
            },
            "line": 121,
            "code": "  test('doesn\\'t throw when at least one match is reset', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      'foo': 'bar',\n      'match-a': 'baz',\n    }, true);\n    configuration.context = new Context(readOnlySettings, new Settings());\n    configuration.context.set('match-b', 'quux');\n\n    // When\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any));\n\n    // Then\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n    });\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when key not found",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 144,
                "column": 33
            },
            "line": 144,
            "code": "  test('throws when key not found', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'baz' },\n    } as any)).rejects.toThrow(/No context value matching key/);\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Doesn't throw when key not found and --force is set",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 160,
                "column": 60
            },
            "line": 160,
            "code": "  test('Doesn\\'t throw when key not found and --force is set', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'baz', force: true },\n    } as any));\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when no key of index found",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 177,
                "column": 41
            },
            "line": 177,
            "code": "  test('throws when no key of index found', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    configuration.context.set('foo', 'bar');\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: '2' },\n    } as any)).rejects.toThrow(/No context key with number/);\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when resetting read-only values",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 194,
                "column": 46
            },
            "line": 194,
            "code": "  test('throws when resetting read-only values', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      foo: 'bar',\n    }, true);\n    configuration.context = new Context(readOnlySettings);\n\n    expect(configuration.context.all).toEqual({\n      foo: 'bar',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'foo' },\n    } as any)).rejects.toThrow(/Cannot reset readonly context value with key/);\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when no matches could be reset",
            "suites": [
                "context --reset"
            ],
            "updatePoint": {
                "line": 214,
                "column": 45
            },
            "line": 214,
            "code": "  test('throws when no matches could be reset', async () => {\n    // GIVEN\n    const configuration = new Configuration();\n    const readOnlySettings = new Settings({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'quux',\n    }, true);\n    configuration.context = new Context(readOnlySettings);\n\n    expect(configuration.context.all).toEqual({\n      'foo': 'bar',\n      'match-a': 'baz',\n      'match-b': 'quux',\n    });\n\n    // THEN\n    await expect(realHandler({\n      configuration,\n      args: { reset: 'match-*' },\n    } as any)).rejects.toThrow(/None of the matched context values could be reset/);\n  });",
            "file": "commands/context-command.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "calls DescribeImages on the request",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 41
            },
            "line": 22,
            "code": "test('calls DescribeImages on the request', async () => {\n  // GIVEN\n  let request: aws.EC2.DescribeImagesRequest;\n  AWS.mock('EC2', 'describeImages', (params: aws.EC2.DescribeImagesRequest, cb: AwsCallback<aws.EC2.DescribeImagesResult>) => {\n    request = params;\n    return cb(null, { Images: [{ ImageId: 'ami-1234' }] });\n  });\n\n  // WHEN\n  await new AmiContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'asdf',\n    owners: ['some-owner'],\n    filters: {\n      'some-filter': ['filtered'],\n    },\n  });\n\n  // THEN\n  expect(request!).toEqual({\n    Owners: ['some-owner'],\n    Filters: [\n      {\n        Name: 'some-filter',\n        Values: ['filtered'],\n      },\n    ],\n  } as aws.EC2.DescribeImagesRequest);\n});",
            "file": "context-providers/amis.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns the most recent AMI matching the criteria",
            "suites": [],
            "updatePoint": {
                "line": 52,
                "column": 55
            },
            "line": 52,
            "code": "test('returns the most recent AMI matching the criteria', async () => {\n  // GIVEN\n  AWS.mock('EC2', 'describeImages', (_: aws.EC2.DescribeImagesRequest, cb: AwsCallback<aws.EC2.DescribeImagesResult>) => {\n    return cb(null, {\n      Images: [\n        {\n          ImageId: 'ami-1234',\n          CreationDate: '2016-06-22T08:39:59.000Z',\n        },\n        {\n          ImageId: 'ami-5678',\n          CreationDate: '2019-06-22T08:39:59.000Z',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await new AmiContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'asdf',\n    filters: {},\n  });\n\n  // THEN\n  expect(result).toBe('ami-5678');\n});",
            "file": "context-providers/amis.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up the requested (symmetric) VPC",
            "suites": [],
            "updatePoint": {
                "line": 22,
                "column": 44
            },
            "line": 22,
            "code": "test('looks up the requested (symmetric) VPC', async () => {\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, CidrBlock: '1.1.2.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-789012',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: 'gw-abcdef',\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when no such VPC is found",
            "suites": [],
            "updatePoint": {
                "line": 120,
                "column": 38
            },
            "line": 120,
            "code": "test('throws when no such VPC is found', async () => {\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, {});\n  });\n\n  await expect(new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  })).rejects.toThrow(/Could not find any VPCs matching/);\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when multiple VPCs are found",
            "suites": [],
            "updatePoint": {
                "line": 134,
                "column": 41
            },
            "line": 134,
            "code": "test('throws when multiple VPCs are found', async () => {\n  // GIVEN\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, { Vpcs: [{ VpcId: 'vpc-1' }, { VpcId: 'vpc-2' }] });\n  });\n\n  // WHEN\n  await expect(new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  })).rejects.toThrow(/Found 2 VPCs matching/);\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "uses the VPC main route table when a subnet has no specific association",
            "suites": [],
            "updatePoint": {
                "line": 150,
                "column": 77
            },
            "line": 150,
            "code": "test('uses the VPC main route table when a subnet has no specific association', async () => {\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, CidrBlock: '1.1.2.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-789012',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: 'gw-abcdef',\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize public subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 247,
                "column": 44
            },
            "line": 247,
            "code": "test('Recognize public subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize isolated subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 321,
                "column": 46
            },
            "line": 321,
            "code": "test('Recognize isolated subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Isolated',\n        type: 'Isolated',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize private subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 383,
                "column": 45
            },
            "line": 383,
            "code": "test('Recognize private subnet by route table', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'sub-123456',\n            availabilityZone: 'bermuda-triangle-1337',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "works for asymmetric subnets (not spanning the same Availability Zones)",
            "suites": [],
            "updatePoint": {
                "line": 457,
                "column": 77
            },
            "line": 457,
            "code": "test('works for asymmetric subnets (not spanning the same Availability Zones)', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'pri-sub-in-1b', AvailabilityZone: 'us-west-1b', MapPublicIpOnLaunch: false, CidrBlock: '1.1.1.1/24' },\n      { SubnetId: 'pub-sub-in-1c', AvailabilityZone: 'us-west-1c', MapPublicIpOnLaunch: true, CidrBlock: '1.1.2.1/24' },\n      { SubnetId: 'pub-sub-in-1b', AvailabilityZone: 'us-west-1b', MapPublicIpOnLaunch: true, CidrBlock: '1.1.3.1/24' },\n      { SubnetId: 'pub-sub-in-1a', AvailabilityZone: 'us-west-1a', MapPublicIpOnLaunch: true, CidrBlock: '1.1.4.1/24' },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'pri-sub-in-1b' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'Private',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'pri-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-123456',\n            cidr: '1.1.1.1/24',\n          },\n        ],\n      },\n      {\n        name: 'Public',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'pub-sub-in-1a',\n            availabilityZone: 'us-west-1a',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.4.1/24',\n          },\n          {\n            subnetId: 'pub-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.3.1/24',\n          },\n          {\n            subnetId: 'pub-sub-in-1c',\n            availabilityZone: 'us-west-1c',\n            routeTableId: 'rtb-789012',\n            cidr: '1.1.2.1/24',\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "allows specifying the subnet group name tag",
            "suites": [],
            "updatePoint": {
                "line": 558,
                "column": 49
            },
            "line": 558,
            "code": "test('allows specifying the subnet group name tag', async () => {\n  // GIVEN\n  mockVpcLookup({\n    subnets: [\n      {\n        SubnetId: 'pri-sub-in-1b',\n        AvailabilityZone: 'us-west-1b',\n        MapPublicIpOnLaunch: false,\n        Tags: [\n          { Key: 'Tier', Value: 'restricted' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1c',\n        AvailabilityZone: 'us-west-1c',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1b',\n        AvailabilityZone: 'us-west-1b',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n      {\n        SubnetId: 'pub-sub-in-1a',\n        AvailabilityZone: 'us-west-1a',\n        MapPublicIpOnLaunch: true,\n        Tags: [\n          { Key: 'Tier', Value: 'connectivity' },\n        ],\n      },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'pri-sub-in-1b' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  const result = await new VpcNetworkContextProviderPlugin(mockSDK).getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter: { foo: 'bar' },\n    returnAsymmetricSubnets: true,\n    subnetGroupNameTag: 'Tier',\n  });\n\n  expect(result).toEqual({\n    availabilityZones: [],\n    vpcCidrBlock: '1.1.1.1/16',\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    subnetGroups: [\n      {\n        name: 'restricted',\n        type: 'Private',\n        subnets: [\n          {\n            subnetId: 'pri-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-123456',\n            cidr: undefined,\n          },\n        ],\n      },\n      {\n        name: 'connectivity',\n        type: 'Public',\n        subnets: [\n          {\n            subnetId: 'pub-sub-in-1a',\n            availabilityZone: 'us-west-1a',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n          {\n            subnetId: 'pub-sub-in-1b',\n            availabilityZone: 'us-west-1b',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n          {\n            subnetId: 'pub-sub-in-1c',\n            availabilityZone: 'us-west-1c',\n            routeTableId: 'rtb-789012',\n            cidr: undefined,\n          },\n        ],\n      },\n    ],\n    vpcId: 'vpc-1234567',\n    vpnGatewayId: undefined,\n  });\n});",
            "file": "context-providers/asymmetric-vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors are reported into the context value",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 48
            },
            "line": 12,
            "code": "test('errors are reported into the context value', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      throw new Error('Something went wrong');\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1' }, provider: TEST_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is now in context\n\n  // NOTE: error key is inlined here because it's part of the CX-API\n  // compatibility surface.\n  expect(context.get('asdf').$providerError).toBe('Something went wrong');\n});",
            "file": "context-providers/generic.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "lookup role ARN is resolved",
            "suites": [],
            "updatePoint": {
                "line": 33,
                "column": 33
            },
            "line": 33,
            "code": "test('lookup role ARN is resolved', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(args: {[key: string]: any}): Promise<any> {\n      if (args.lookupRoleArn == null) {\n        throw new Error('No lookupRoleArn');\n      }\n\n      if (args.lookupRoleArn.includes('${AWS::Partition}')) {\n        throw new Error('Partition not resolved');\n      }\n\n      return 'some resolved value';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    {\n      key: 'asdf',\n      props: {\n        account: '1234',\n        region: 'us-east-1',\n        lookupRoleArn: 'arn:${AWS::Partition}:iam::280619947791:role/cdk-hnb659fds-lookup-role-280619947791-us-east-1',\n      },\n      provider: TEST_PROVIDER,\n    },\n  ], context, mockSDK);\n\n  // THEN - Value gets resolved\n  expect(context.get('asdf')).toEqual('some resolved value');\n});",
            "file": "context-providers/generic.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors are marked transient",
            "suites": [],
            "updatePoint": {
                "line": 67,
                "column": 33
            },
            "line": 67,
            "code": "test('errors are marked transient', async () => {\n  // GIVEN\n  contextproviders.registerContextProvider(TEST_PROVIDER, {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      throw new Error('Something went wrong');\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1' }, provider: TEST_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(context.get('asdf')[TRANSIENT_CONTEXT_KEY]).toBeTruthy();\n});",
            "file": "context-providers/generic.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "context provider can be registered using PluginHost",
            "suites": [],
            "updatePoint": {
                "line": 85,
                "column": 57
            },
            "line": 85,
            "code": "test('context provider can be registered using PluginHost', async () => {\n  let called = false;\n\n  // GIVEN\n  PluginHost.instance.registerContextProviderAlpha('prov', {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      called = true;\n      return '';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { account: '1234', region: 'us-east-1', pluginName: 'prov' }, provider: PLUGIN_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(called).toEqual(true);\n});",
            "file": "context-providers/generic.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "plugin context provider can be called without account/region",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 66
            },
            "line": 106,
            "code": "test('plugin context provider can be called without account/region', async () => {\n  // GIVEN\n  PluginHost.instance.registerContextProviderAlpha('prov', {\n    async getValue(_: {[key: string]: any}): Promise<any> {\n      return 'yay';\n    },\n  });\n  const context = new Context();\n\n  // WHEN\n  await contextproviders.provideContextValues([\n    { key: 'asdf', props: { banana: 'yellow', pluginName: 'prov' } as any, provider: PLUGIN_PROVIDER },\n  ], context, mockSDK);\n\n  // THEN - error is marked transient\n  expect(context.get('asdf')).toEqual('yay');\n});",
            "file": "context-providers/generic.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up the requested Key - single result",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 48
            },
            "line": 16,
            "code": "test('looks up the requested Key - single result', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n      Aliases: [\n        {\n          AliasName: 'alias/foo',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789000',\n  });\n});",
            "file": "context-providers/keys.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up the requested Key - multiple results",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 51
            },
            "line": 45,
            "code": "test('looks up the requested Key - multiple results', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n      Aliases: [\n        {\n          AliasName: 'alias/bar',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n        },\n        {\n          AliasName: 'alias/foo',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789001',\n        },\n        {\n          AliasName: 'alias/fooBar',\n          TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789002',\n        },\n      ],\n    });\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789001',\n  });\n});",
            "file": "context-providers/keys.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up the requested Key - multiple results with pagination",
            "suites": [],
            "updatePoint": {
                "line": 83,
                "column": 67
            },
            "line": 83,
            "code": "test('looks up the requested Key - multiple results with pagination', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    if (!params.Marker) {\n      return cb(null, {\n        Truncated: true,\n        NextMarker: 'nextMarker',\n        Aliases: [\n          {\n            AliasName: 'alias/key1',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789000',\n          },\n          {\n            AliasName: 'alias/key2',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789001',\n          },\n          {\n            AliasName: 'alias/key3',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789002',\n          },\n        ],\n      });\n    } else if (params.Marker == 'nextMarker') {\n      return cb(null, {\n        Aliases: [\n          {\n            AliasName: 'alias/key4',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789003',\n          },\n          {\n            AliasName: 'alias/foo',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789004',\n          },\n          {\n            AliasName: 'alias/key5',\n            TargetKeyId: '1234abcd-12ab-34cd-56ef-123456789005',\n          },\n        ],\n      });\n    }\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  });\n\n  // THEN\n  expect(result).toEqual({\n    keyId: '1234abcd-12ab-34cd-56ef-123456789004',\n  });\n});",
            "file": "context-providers/keys.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throw exception - no key found",
            "suites": [],
            "updatePoint": {
                "line": 140,
                "column": 36
            },
            "line": 140,
            "code": "test('throw exception - no key found', async () => {\n  // GIVEN\n  const provider = new KeyContextProviderPlugin(mockSDK);\n\n  AWS.mock('KMS', 'listAliases', (params: aws.KMS.ListAliasesRequest, cb: AwsCallback<aws.KMS.ListAliasesResponse>) => {\n    expect(params.KeyId).toBeUndefined();\n    return cb(null, {\n    });\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    aliasName: 'alias/foo',\n  })).rejects.toThrow(/Could not find any key with alias named/);\n\n});",
            "file": "context-providers/keys.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "describeTags yields tags by chunk",
            "suites": [
                "utilities"
            ],
            "updatePoint": {
                "line": 20,
                "column": 41
            },
            "line": 20,
            "code": "  test('describeTags yields tags by chunk', async () => {\n    const resourceTags: Record<string, aws.ELBv2.TagDescription> = {};\n    for (const resourceArn of [...Array(100)].map((_, i) => `arn:load-balancer-${i}`)) {\n      resourceTags[resourceArn] = {\n        ResourceArn: resourceArn,\n        Tags: [\n          { Key: 'name', Value: resourceArn },\n        ],\n      };\n    };\n\n    AWS.mock('ELBv2', 'describeTags', (_params: aws.ELBv2.DescribeTagsInput, cb: AwsCallback<aws.ELBv2.DescribeTagsOutput>) => {\n      expect(_params.ResourceArns.length).toBeLessThanOrEqual(20);\n\n      cb(null, {\n        TagDescriptions: _params.ResourceArns.map(resourceArn => ({\n          ResourceArn: resourceArn,\n          Tags: [\n            { Key: 'name', Value: resourceArn },\n          ],\n        })),\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n\n    const resourceTagsOut: Record<string, aws.ELBv2.TagDescription> = {};\n    for await (const tagDescription of describeTags(elbv2, Object.keys(resourceTags))) {\n      resourceTagsOut[tagDescription.ResourceArn!] = tagDescription;\n    }\n\n    expect(resourceTagsOut).toEqual(resourceTags);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "describeListenersByLoadBalancerArn traverses pages",
            "suites": [
                "utilities"
            ],
            "updatePoint": {
                "line": 54,
                "column": 58
            },
            "line": 54,
            "code": "  test('describeListenersByLoadBalancerArn traverses pages', async () => {\n    // arn:listener-0, arn:listener-1, ..., arn:listener-99\n    const listenerArns = [...Array(100)].map((_, i) => `arn:listener-${i}`);\n    expect(listenerArns[0]).toEqual('arn:listener-0');\n\n    AWS.mock('ELBv2', 'describeListeners', (_params: aws.ELBv2.DescribeListenersInput, cb: AwsCallback<aws.ELBv2.DescribeListenersOutput>) => {\n      const start = parseInt(_params.Marker ?? '0');\n      const end = start + 10;\n      const slice = listenerArns.slice(start, end);\n\n      cb(null, {\n        Listeners: slice.map(arn => ({\n          ListenerArn: arn,\n        })),\n        NextMarker: end < listenerArns.length ? end.toString() : undefined,\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n\n    const listenerArnsFromPages = Array<string>();\n    for await (const listener of describeListenersByLoadBalancerArn(elbv2, ['arn:load-balancer'])) {\n      listenerArnsFromPages.push(listener.ListenerArn!);\n    }\n\n    expect(listenerArnsFromPages).toEqual(listenerArns);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "describeLoadBalancers traverses pages",
            "suites": [
                "utilities"
            ],
            "updatePoint": {
                "line": 82,
                "column": 45
            },
            "line": 82,
            "code": "  test('describeLoadBalancers traverses pages', async () => {\n    const loadBalancerArns = [...Array(100)].map((_, i) => `arn:load-balancer-${i}`);\n    expect(loadBalancerArns[0]).toEqual('arn:load-balancer-0');\n\n    AWS.mock('ELBv2', 'describeLoadBalancers', (_params: aws.ELBv2.DescribeLoadBalancersInput, cb: AwsCallback<aws.ELBv2.DescribeLoadBalancersOutput>) => {\n      const start = parseInt(_params.Marker ?? '0');\n      const end = start + 10;\n      const slice = loadBalancerArns.slice(start, end);\n\n      cb(null, {\n        LoadBalancers: slice.map(loadBalancerArn => ({\n          LoadBalancerArn: loadBalancerArn,\n        })),\n        NextMarker: end < loadBalancerArns.length ? end.toString() : undefined,\n      });\n    });\n\n    const elbv2 = (await mockSDK.forEnvironment()).sdk.elbv2();\n    const loadBalancerArnsFromPages = (await describeLoadBalancers(elbv2, {})).map(l => l.LoadBalancerArn!);\n\n    expect(loadBalancerArnsFromPages).toEqual(loadBalancerArns);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "all tags match",
            "suites": [
                "utilities",
                "tagsMatch"
            ],
            "updatePoint": {
                "line": 106,
                "column": 24
            },
            "line": 106,
            "code": "    test('all tags match', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some', Value: 'tag' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(true);\n    });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "extra tags match",
            "suites": [
                "utilities",
                "tagsMatch"
            ],
            "updatePoint": {
                "line": 119,
                "column": 26
            },
            "line": 119,
            "code": "    test('extra tags match', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [\n          { Key: 'some', Value: 'tag' },\n          { Key: 'other', Value: 'tag2' },\n        ],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(true);\n    });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "no tags matches no tags",
            "suites": [
                "utilities",
                "tagsMatch"
            ],
            "updatePoint": {
                "line": 135,
                "column": 33
            },
            "line": 135,
            "code": "    test('no tags matches no tags', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [],\n      };\n\n      expect(tagsMatch(tagDescription, [])).toEqual(true);\n    });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "one tag matches of several",
            "suites": [
                "utilities",
                "tagsMatch"
            ],
            "updatePoint": {
                "line": 144,
                "column": 36
            },
            "line": 144,
            "code": "    test('one tag matches of several', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some', Value: 'tag' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n        { key: 'other', value: 'value' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(false);\n    });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "undefined tag does not error",
            "suites": [
                "utilities",
                "tagsMatch"
            ],
            "updatePoint": {
                "line": 158,
                "column": 38
            },
            "line": 158,
            "code": "    test('undefined tag does not error', () => {\n      const tagDescription = {\n        ResourceArn: 'arn:whatever',\n        Tags: [{ Key: 'some' }],\n      };\n\n      const requiredTags = [\n        { key: 'some', value: 'tag' },\n        { key: 'other', value: 'value' },\n      ];\n\n      expect(tagsMatch(tagDescription, requiredTags)).toEqual(false);\n    });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when no matches are found",
            "suites": [
                "load balancer context provider plugin"
            ],
            "updatePoint": {
                "line": 175,
                "column": 40
            },
            "line": 175,
            "code": "  test('errors when no matches are found', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerArn: 'arn:load-balancer1',\n      }),\n    ).rejects.toThrow(/No load balancers found/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when multiple load balancers match",
            "suites": [
                "load balancer context provider plugin"
            ],
            "updatePoint": {
                "line": 194,
                "column": 49
            },
            "line": 194,
            "code": "  test('errors when multiple load balancers match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer1', 'arn:load-balancer2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [\n          { key: 'some', value: 'tag' },\n        ],\n      }),\n    ).rejects.toThrow(/Multiple load balancers found/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by arn",
            "suites": [
                "load balancer context provider plugin"
            ],
            "updatePoint": {
                "line": 249,
                "column": 23
            },
            "line": 249,
            "code": "  test('looks up by arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer1'] },\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    const result = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerArn: 'arn:load-balancer1',\n    });\n\n    // THEN\n    expect(result.ipAddressType).toEqual('ipv4');\n    expect(result.loadBalancerArn).toEqual('arn:load-balancer1');\n    expect(result.loadBalancerCanonicalHostedZoneId).toEqual('Z1234');\n    expect(result.loadBalancerDnsName).toEqual('dns.example.com');\n    expect(result.securityGroupIds).toEqual(['sg-1234']);\n    expect(result.vpcId).toEqual('vpc-1234');\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by tags",
            "suites": [
                "load balancer context provider plugin"
            ],
            "updatePoint": {
                "line": 285,
                "column": 24
            },
            "line": 285,
            "code": "  test('looks up by tags', async() => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n        {\n          IpAddressType: 'ipv4',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n          Type: 'application',\n        },\n      ],\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer1', 'arn:load-balancer2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n            { Key: 'second', Value: 'tag2' },\n          ],\n        },\n      ],\n    });\n\n    // WHEN\n    const result = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [\n        { key: 'some', value: 'tag' },\n        { key: 'second', value: 'tag2' },\n      ],\n    });\n\n    expect(result.loadBalancerArn).toEqual('arn:load-balancer2');\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "filters by type",
            "suites": [
                "load balancer context provider plugin"
            ],
            "updatePoint": {
                "line": 342,
                "column": 23
            },
            "line": 342,
            "code": "  test('filters by type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          IpAddressType: 'ipv4',\n          Type: 'network',\n          LoadBalancerArn: 'arn:load-balancer1',\n          DNSName: 'dns1.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n        },\n        {\n          IpAddressType: 'ipv4',\n          Type: 'application',\n          LoadBalancerArn: 'arn:load-balancer2',\n          DNSName: 'dns2.example.com',\n          CanonicalHostedZoneId: 'Z1234',\n          SecurityGroups: ['sg-1234'],\n          VpcId: 'vpc-1234',\n        },\n      ],\n\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer1',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n    });\n\n    // WHEN\n    const loadBalancer = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n    });\n\n    expect(loadBalancer.loadBalancerArn).toEqual('arn:load-balancer2');\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when no associated load balancers match",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 393,
                "column": 54
            },
            "line": 393,
            "code": "  test('errors when no associated load balancers match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      }),\n    ).rejects.toThrow(/No associated load balancers found/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when no listeners match",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 412,
                "column": 38
            },
            "line": 412,
            "code": "  test('errors when no listeners match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          Type: 'application',\n        },\n      ],\n      listeners: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          ListenerArn: 'arn:listener',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerArn: 'arn:load-balancer',\n        listenerPort: 443,\n        listenerProtocol: cxschema.LoadBalancerListenerProtocol.HTTPS,\n      }),\n    ).rejects.toThrow(/No load balancer listeners found/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when multiple listeners match",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 446,
                "column": 44
            },
            "line": 446,
            "code": "  test('errors when multiple listeners match', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          Type: 'application',\n        },\n        {\n          LoadBalancerArn: 'arn:load-balancer2',\n          Type: 'application',\n        },\n      ],\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n      listeners: [\n        {\n          LoadBalancerArn: 'arn:load-balancer',\n          ListenerArn: 'arn:listener',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n        {\n          LoadBalancerArn: 'arn:load-balancer2',\n          ListenerArn: 'arn:listener2',\n          Port: 80,\n          Protocol: 'HTTP',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n        loadBalancerTags: [{ key: 'some', value: 'tag' }],\n        listenerPort: 80,\n        listenerProtocol: cxschema.LoadBalancerListenerProtocol.HTTP,\n      }),\n    ).rejects.toThrow(/Multiple load balancer listeners/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by listener arn",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 500,
                "column": 32
            },
            "line": 500,
            "code": "  test('looks up by listener arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeListenersExpected: { ListenerArns: ['arn:listener-arn'] },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn',\n          LoadBalancerArn: 'arn:load-balancer-arn',\n          Port: 999,\n        },\n      ],\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn'] },\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer-arn',\n          SecurityGroups: ['sg-1234', 'sg-2345'],\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      listenerArn: 'arn:listener-arn',\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn');\n    expect(listener.listenerPort).toEqual(999);\n    expect(listener.securityGroupIds).toEqual(['sg-1234', 'sg-2345']);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by associated load balancer arn",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 537,
                "column": 48
            },
            "line": 537,
            "code": "  test('looks up by associated load balancer arn', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn1'] },\n      loadBalancers: [\n        {\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: ['sg-1234'],\n          Type: 'application',\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn1' },\n      listeners: [\n        {\n          // This one\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          Port: 80,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerArn: 'arn:load-balancer-arn1',\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn1');\n    expect(listener.listenerPort).toEqual(80);\n    expect(listener.securityGroupIds).toEqual(['sg-1234']);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by associated load balancer tags",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 576,
                "column": 49
            },
            "line": 576,
            "code": "  test('looks up by associated load balancer tags', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: undefined },\n      loadBalancers: [\n        {\n          // This one should have the wrong tags\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: ['sg-1234', 'sg-2345'],\n          Type: 'application',\n        },\n        {\n          // Expecting this one\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          SecurityGroups: ['sg-3456', 'sg-4567'],\n          Type: 'application',\n        },\n      ],\n\n      describeTagsExpected: { ResourceArns: ['arn:load-balancer-arn1', 'arn:load-balancer-arn2'] },\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer-arn1',\n          Tags: [],\n        },\n        {\n          // Expecting this one\n          ResourceArn: 'arn:load-balancer-arn2',\n          Tags: [\n            { Key: 'some', Value: 'tag' },\n          ],\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn2' },\n      listeners: [\n        {\n          // This one\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 80,\n        },\n        {\n          ListenerArn: 'arn:listener-arn2',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 999,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [\n        { key: 'some', value: 'tag' },\n      ],\n      listenerPort: 999,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn2');\n    expect(listener.listenerPort).toEqual(999);\n    expect(listener.securityGroupIds).toEqual(['sg-3456', 'sg-4567']);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by listener port and proto",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 645,
                "column": 43
            },
            "line": 645,
            "code": "  test('looks up by listener port and proto', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    AWS.mock('ELBv2', 'describeLoadBalancers', (_params: aws.ELBv2.DescribeLoadBalancersInput, cb: AwsCallback<aws.ELBv2.DescribeLoadBalancersOutput>) => {\n      expect(_params).toEqual({});\n      cb(null, {\n        LoadBalancers: [\n          {\n            // Shouldn't have any matching listeners\n            IpAddressType: 'ipv4',\n            LoadBalancerArn: 'arn:load-balancer1',\n            DNSName: 'dns1.example.com',\n            CanonicalHostedZoneId: 'Z1234',\n            SecurityGroups: ['sg-1234'],\n            VpcId: 'vpc-1234',\n            Type: 'application',\n          },\n          {\n            // Should have a matching listener\n            IpAddressType: 'ipv4',\n            LoadBalancerArn: 'arn:load-balancer2',\n            DNSName: 'dns2.example.com',\n            CanonicalHostedZoneId: 'Z1234',\n            SecurityGroups: ['sg-2345'],\n            VpcId: 'vpc-1234',\n            Type: 'application',\n          },\n        ],\n      });\n    });\n\n    AWS.mock('ELBv2', 'describeTags', (_params: aws.ELBv2.DescribeTagsInput, cb: AwsCallback<aws.ELBv2.DescribeTagsOutput>) => {\n      cb(null, {\n        TagDescriptions: [\n          {\n            ResourceArn: 'arn:load-balancer1',\n            Tags: [{ Key: 'some', Value: 'tag' }],\n          },\n          {\n            ResourceArn: 'arn:load-balancer2',\n            Tags: [{ Key: 'some', Value: 'tag' }],\n          },\n        ],\n      });\n    });\n\n    AWS.mock('ELBv2', 'describeListeners', (params: aws.ELBv2.DescribeListenersInput, cb: AwsCallback<aws.ELBv2.DescribeListenersOutput>) => {\n      if (params.LoadBalancerArn === 'arn:load-balancer1') {\n        cb(null, {\n          Listeners: [\n            {\n            // Wrong port, wrong protocol => no match\n              ListenerArn: 'arn:listener-arn1',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'HTTP',\n              Port: 80,\n            },\n            {\n            // Wrong protocol, right port => no match\n              ListenerArn: 'arn:listener-arn3',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'HTTPS',\n              Port: 443,\n            },\n            {\n            // Wrong port, right protocol => no match\n              ListenerArn: 'arn:listener-arn4',\n              LoadBalancerArn: 'arn:load-balancer1',\n              Protocol: 'TCP',\n              Port: 999,\n            },\n          ],\n        });\n      } else if (params.LoadBalancerArn === 'arn:load-balancer2') {\n        cb(null, {\n          Listeners: [\n            {\n            // Wrong port, wrong protocol => no match\n              ListenerArn: 'arn:listener-arn5',\n              LoadBalancerArn: 'arn:load-balancer2',\n              Protocol: 'HTTP',\n              Port: 80,\n            },\n            {\n            // Right port, right protocol => match\n              ListenerArn: 'arn:listener-arn6',\n              LoadBalancerArn: 'arn:load-balancer2',\n              Port: 443,\n              Protocol: 'TCP',\n            },\n          ],\n        });\n      } else {\n        cb(new Error(`Unexpected request: ${JSON.stringify(params)}'`), {});\n      }\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.APPLICATION,\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      listenerProtocol: cxschema.LoadBalancerListenerProtocol.TCP,\n      listenerPort: 443,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn6');\n    expect(listener.listenerPort).toEqual(443);\n    expect(listener.securityGroupIds).toEqual(['sg-2345']);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "filters by associated load balancer type",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 759,
                "column": 48
            },
            "line": 759,
            "code": "  test('filters by associated load balancer type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeLoadBalancersExpected: { LoadBalancerArns: undefined },\n      loadBalancers: [\n        {\n          // This one has wrong type => no match\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: [],\n          Type: 'application',\n        },\n        {\n          // Right type => match\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          SecurityGroups: [],\n          Type: 'network',\n        },\n      ],\n\n      tagDescriptions: [\n        {\n          ResourceArn: 'arn:load-balancer-arn1',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n        {\n          ResourceArn: 'arn:load-balancer-arn2',\n          Tags: [{ Key: 'some', Value: 'tag' }],\n        },\n      ],\n\n      describeListenersExpected: { LoadBalancerArn: 'arn:load-balancer-arn2' },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn2',\n          LoadBalancerArn: 'arn:load-balancer-arn2',\n          Port: 443,\n        },\n      ],\n    });\n\n    // WHEN\n    const listener = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      loadBalancerType: cxschema.LoadBalancerType.NETWORK,\n      loadBalancerTags: [{ key: 'some', value: 'tag' }],\n      listenerPort: 443,\n    });\n\n    // THEN\n    expect(listener.listenerArn).toEqual('arn:listener-arn2');\n    expect(listener.listenerPort).toEqual(443);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when associated load balancer is wrong type",
            "suites": [
                "load balancer listener context provider plugin"
            ],
            "updatePoint": {
                "line": 815,
                "column": 58
            },
            "line": 815,
            "code": "  test('errors when associated load balancer is wrong type', async () => {\n    // GIVEN\n    const provider = new LoadBalancerListenerContextProviderPlugin(mockSDK);\n\n    mockALBLookup({\n      describeListenersExpected: { ListenerArns: ['arn:listener-arn1'] },\n      listeners: [\n        {\n          ListenerArn: 'arn:listener-arn1',\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          Port: 443,\n        },\n      ],\n\n      describeLoadBalancersExpected: { LoadBalancerArns: ['arn:load-balancer-arn1'] },\n      loadBalancers: [\n        {\n          // This one has wrong type => no match\n          LoadBalancerArn: 'arn:load-balancer-arn1',\n          SecurityGroups: [],\n          Type: 'application',\n        },\n      ],\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        loadBalancerType: cxschema.LoadBalancerType.NETWORK,\n        listenerArn: 'arn:listener-arn1',\n      }),\n    ).rejects.toThrow(/no associated load balancer found/i);\n  });",
            "file": "context-providers/load-balancers.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when no matches are found",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 19,
                "column": 40
            },
            "line": 19,
            "code": "  test('errors when no matches are found', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      cb(null, { SecurityGroups: [] });\n    });\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n      }),\n    ).rejects.toThrow(/No security groups found/i);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by security group id",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 37,
                "column": 37
            },
            "line": 37,
            "code": "  test('looks up by security group id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by security group id and vpc id",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 78,
                "column": 48
            },
            "line": 78,
            "code": "  test('looks up by security group id and vpc id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        GroupIds: ['sg-1234'],\n        Filters: [\n          {\n            Name: 'vpc-id',\n            Values: ['vpc-1234567'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n      vpcId: 'vpc-1234567',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by security group name",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 128,
                "column": 39
            },
            "line": 128,
            "code": "  test('looks up by security group name', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        Filters: [\n          {\n            Name: 'group-name',\n            Values: ['my-security-group'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupName: 'my-security-group',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up by security group name and vpc id",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 176,
                "column": 50
            },
            "line": 176,
            "code": "  test('looks up by security group name and vpc id', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({\n        Filters: [\n          {\n            Name: 'vpc-id',\n            Values: ['vpc-1234567'],\n          },\n          {\n            Name: 'group-name',\n            Values: ['my-security-group'],\n          },\n        ],\n      });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '0.0.0.0/0' },\n                ],\n              },\n              {\n                IpProtocol: '-1',\n                Ipv6Ranges: [\n                  { CidrIpv6: '::/0' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupName: 'my-security-group',\n      vpcId: 'vpc-1234567',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "detects non all-outbound egress",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 229,
                "column": 39
            },
            "line": 229,
            "code": "  test('detects non all-outbound egress', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n\n    // WHEN\n    const res = await provider.getValue({\n      account: '1234',\n      region: 'us-east-1',\n      securityGroupId: 'sg-1234',\n    });\n\n    // THEN\n    expect(res.securityGroupId).toEqual('sg-1234');\n    expect(res.allowAllOutbound).toEqual(false);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when more than one security group is found",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 264,
                "column": 57
            },
            "line": 264,
            "code": "  test('errors when more than one security group is found', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    AWS.mock('EC2', 'describeSecurityGroups', (_params: aws.EC2.DescribeSecurityGroupsRequest, cb: AwsCallback<aws.EC2.DescribeSecurityGroupsResult>) => {\n      expect(_params).toEqual({ GroupIds: ['sg-1234'] });\n      cb(null, {\n        SecurityGroups: [\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n          {\n            GroupId: 'sg-1234',\n            IpPermissionsEgress: [\n              {\n                IpProtocol: '-1',\n                IpRanges: [\n                  { CidrIp: '10.0.0.0/16' },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n    });\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n      }),\n    ).rejects.toThrow(/\\More than one security groups found matching/i);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when securityGroupId and securityGroupName are specified both",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 307,
                "column": 76
            },
            "line": 307,
            "code": "  test('errors when securityGroupId and securityGroupName are specified both', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n        securityGroupId: 'sg-1234',\n        securityGroupName: 'my-security-group',\n      }),\n    ).rejects.toThrow(/\\'securityGroupId\\' and \\'securityGroupName\\' can not be specified both when looking up a security group/i);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "errors when neither securityGroupId nor securityGroupName are specified",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 322,
                "column": 79
            },
            "line": 322,
            "code": "  test('errors when neither securityGroupId nor securityGroupName are specified', async () => {\n    // GIVEN\n    const provider = new SecurityGroupContextProviderPlugin(mockSDK);\n\n    // WHEN\n    await expect(\n      provider.getValue({\n        account: '1234',\n        region: 'us-east-1',\n      }),\n    ).rejects.toThrow(/\\'securityGroupId\\' or \\'securityGroupName\\' must be specified to look up a security group/i);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "identifies allTrafficEgress from SecurityGroup permissions",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 335,
                "column": 66
            },
            "line": 335,
            "code": "  test('identifies allTrafficEgress from SecurityGroup permissions', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n          },\n          {\n            IpProtocol: '-1',\n            Ipv6Ranges: [\n              { CidrIpv6: '::/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "identifies allTrafficEgress from SecurityGroup permissions when combined",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 356,
                "column": 80
            },
            "line": 356,
            "code": "  test('identifies allTrafficEgress from SecurityGroup permissions when combined', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n            Ipv6Ranges: [\n              { CidrIpv6: '::/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(true);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "identifies lacking allTrafficEgress from SecurityGroup permissions",
            "suites": [
                "security group context provider plugin"
            ],
            "updatePoint": {
                "line": 374,
                "column": 74
            },
            "line": 374,
            "code": "  test('identifies lacking allTrafficEgress from SecurityGroup permissions', () => {\n    expect(\n      hasAllTrafficEgress({\n        IpPermissionsEgress: [\n          {\n            IpProtocol: '-1',\n            IpRanges: [\n              { CidrIp: '10.0.0.0/16' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(false);\n\n    expect(\n      hasAllTrafficEgress({\n        IpPermissions: [\n          {\n            IpProtocol: 'TCP',\n            IpRanges: [\n              { CidrIp: '0.0.0.0/0' },\n            ],\n          },\n        ],\n      }),\n    ).toBe(false);\n  });",
            "file": "context-providers/security-groups.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "looks up the requested VPC",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 32
            },
            "line": 18,
            "code": "test('looks up the requested VPC', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when no such VPC is found",
            "suites": [],
            "updatePoint": {
                "line": 97,
                "column": 38
            },
            "line": 97,
            "code": "test('throws when no such VPC is found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, {});\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  })).rejects.toThrow(/Could not find any VPCs matching/);\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when subnet with subnetGroupNameTag not found",
            "suites": [],
            "updatePoint": {
                "line": 115,
                "column": 58
            },
            "line": 115,
            "code": "test('throws when subnet with subnetGroupNameTag not found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    subnetGroupNameTag: 'DOES_NOT_EXIST',\n    filter,\n  })).rejects.toThrow(/Invalid subnetGroupNameTag: Subnet .* does not have an associated tag with Key='DOES_NOT_EXIST'/);\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not throw when subnet with subnetGroupNameTag is found",
            "suites": [],
            "updatePoint": {
                "line": 175,
                "column": 65
            },
            "line": 175,
            "code": "test('does not throw when subnet with subnetGroupNameTag is found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true, Tags: [{ Key: 'DOES_EXIST', Value: 'SubnetName1' }] },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false, Tags: [{ Key: 'DOES_EXIST', Value: 'SubnetName2' }] },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ SubnetId: 'sub-789012' }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    subnetGroupNameTag: 'DOES_EXIST',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['SubnetName2'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['SubnetName1'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws when multiple VPCs are found",
            "suites": [],
            "updatePoint": {
                "line": 254,
                "column": 41
            },
            "line": 254,
            "code": "test('throws when multiple VPCs are found', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  AWS.mock('EC2', 'describeVpcs', (params: aws.EC2.DescribeVpcsRequest, cb: AwsCallback<aws.EC2.DescribeVpcsResult>) => {\n    expect(params.Filters).toEqual([{ Name: 'foo', Values: ['bar'] }]);\n    return cb(null, { Vpcs: [{ VpcId: 'vpc-1' }, { VpcId: 'vpc-2' }] });\n  });\n\n  // WHEN\n  await expect(provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  })).rejects.toThrow(/Found 2 VPCs matching/);\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "uses the VPC main route table when a subnet has no specific association",
            "suites": [],
            "updatePoint": {
                "line": 272,
                "column": 77
            },
            "line": 272,
            "code": "test('uses the VPC main route table when a subnet has no specific association', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: true },\n      { SubnetId: 'sub-789012', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.1.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n      {\n        Associations: [{ Main: true }],\n        RouteTableId: 'rtb-789012',\n        Routes: [\n          {\n            DestinationCidrBlock: '1.1.2.1/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n    vpnGateways: [{ VpnGatewayId: 'gw-abcdef' }],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-789012'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-789012'],\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: 'gw-abcdef',\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize public subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 350,
                "column": 44
            },
            "line": 350,
            "code": "test('Recognize public subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            GatewayId: 'igw-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: ['sub-123456'],\n    publicSubnetNames: ['Public'],\n    publicSubnetRouteTableIds: ['rtb-123456'],\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize private subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 414,
                "column": 45
            },
            "line": 414,
            "code": "test('Recognize private subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.2.0/26',\n            Origin: 'CreateRoute',\n            State: 'active',\n            VpcPeeringConnectionId: 'pcx-xxxxxx',\n          },\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n          {\n            DestinationCidrBlock: '0.0.0.0/0',\n            NatGatewayId: 'nat-xxxxxx',\n            Origin: 'CreateRoute',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: undefined,\n    isolatedSubnetNames: undefined,\n    isolatedSubnetRouteTableIds: undefined,\n    privateSubnetIds: ['sub-123456'],\n    privateSubnetNames: ['Private'],\n    privateSubnetRouteTableIds: ['rtb-123456'],\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Recognize isolated subnet by route table",
            "suites": [],
            "updatePoint": {
                "line": 478,
                "column": 46
            },
            "line": 478,
            "code": "test('Recognize isolated subnet by route table', async () => {\n  // GIVEN\n  const filter = { foo: 'bar' };\n  const provider = new VpcNetworkContextProviderPlugin(mockSDK);\n\n  mockVpcLookup({\n    subnets: [\n      { SubnetId: 'sub-123456', AvailabilityZone: 'bermuda-triangle-1337', MapPublicIpOnLaunch: false },\n    ],\n    routeTables: [\n      {\n        Associations: [{ SubnetId: 'sub-123456' }],\n        RouteTableId: 'rtb-123456',\n        Routes: [\n          {\n            DestinationCidrBlock: '10.0.1.0/24',\n            GatewayId: 'local',\n            Origin: 'CreateRouteTable',\n            State: 'active',\n          },\n        ],\n      },\n    ],\n  });\n\n  // WHEN\n  const result = await provider.getValue({\n    account: '1234',\n    region: 'us-east-1',\n    filter,\n  });\n\n  // THEN\n  expect(result).toEqual({\n    vpcId: 'vpc-1234567',\n    vpcCidrBlock: '1.1.1.1/16',\n    ownerAccountId: '123456789012',\n    availabilityZones: ['bermuda-triangle-1337'],\n    isolatedSubnetIds: ['sub-123456'],\n    isolatedSubnetNames: ['Isolated'],\n    isolatedSubnetRouteTableIds: ['rtb-123456'],\n    privateSubnetIds: undefined,\n    privateSubnetNames: undefined,\n    privateSubnetRouteTableIds: undefined,\n    publicSubnetIds: undefined,\n    publicSubnetNames: undefined,\n    publicSubnetRouteTableIds: undefined,\n    vpnGatewayId: undefined,\n    subnetGroups: undefined,\n  });\n});",
            "file": "context-providers/vpcs.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "load context from both files if available",
            "suites": [],
            "updatePoint": {
                "line": 27,
                "column": 47
            },
            "line": 27,
            "code": "test('load context from both files if available', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { boo: 'far' } });\n\n  // WHEN\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config.context.get('foo')).toBe('bar');\n  expect(config.context.get('boo')).toBe('far');\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deleted context disappears from new file",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 46
            },
            "line": 40,
            "code": "test('deleted context disappears from new file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { foo: 'bar' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  config.context.unset('foo');\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { foo: 'bar' } });\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "clear deletes from new file",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 33
            },
            "line": 55,
            "code": "test('clear deletes from new file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { foo: 'bar' });\n  await fs.writeJSON('cdk.json', { context: { boo: 'far' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  config.context.clear();\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { boo: 'far' } });\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "context is preserved in the location from which it is read",
            "suites": [],
            "updatePoint": {
                "line": 70,
                "column": 64
            },
            "line": 70,
            "code": "test('context is preserved in the location from which it is read', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.json', { context: { 'boo:boo': 'far' } });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ 'boo:boo': 'far' });\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({});\n  expect(await fs.readJSON('cdk.json')).toEqual({ context: { 'boo:boo': 'far' } });\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "surive no context in old file",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 35
            },
            "line": 84,
            "code": "test('surive no context in old file', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.json', { });\n  await fs.writeJSON('cdk.context.json', { boo: 'far' });\n  const config = await new Configuration({ readUserContext: false }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ boo: 'far' });\n  await config.saveContext();\n\n  // THEN\n  expect(await fs.readJSON('cdk.context.json')).toEqual({ boo: 'far' });\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "command line context is merged with stored context",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 56
            },
            "line": 98,
            "code": "test('command line context is merged with stored context', async () => {\n  // GIVEN\n  await fs.writeJSON('cdk.context.json', { boo: 'far' });\n  const config = await new Configuration({\n    readUserContext: false,\n    commandLineArguments: {\n      context: ['foo=bar'],\n      _: ['command'],\n    } as any,\n  }).load();\n\n  // WHEN\n  expect(config.context.all).toEqual({ foo: 'bar', boo: 'far' });\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can save and load",
            "suites": [],
            "updatePoint": {
                "line": 113,
                "column": 23
            },
            "line": 113,
            "code": "test('can save and load', async () => {\n  // GIVEN\n  const config1 = await new Configuration({ readUserContext: false }).load();\n  config1.context.set('some_key', 'some_value');\n  await config1.saveContext();\n  expect(config1.context.get('some_key')).toEqual('some_value');\n\n  // WHEN\n  const config2 = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config2.context.get('some_key')).toEqual('some_value');\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "transient values arent saved to disk",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 42
            },
            "line": 127,
            "code": "test('transient values arent saved to disk', async () => {\n  // GIVEN\n  const config1 = await new Configuration({ readUserContext: false }).load();\n  config1.context.set('some_key', { [TRANSIENT_CONTEXT_KEY]: true, value: 'some_value' });\n  await config1.saveContext();\n  expect(config1.context.get('some_key').value).toEqual('some_value');\n\n  // WHEN\n  const config2 = await new Configuration({ readUserContext: false }).load();\n\n  // THEN\n  expect(config2.context.get('some_key')).toEqual(undefined);\n});",
            "file": "context.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Success - Concurrency: $concurrency - $scenario",
            "suites": [
                "DeployStacks"
            ],
            "line": 38,
            "code": "  test.each([\n    // Concurrency 1\n    { scenario: 'No Stacks', concurrency: 1, toDeploy: [], expected: [] },\n    { scenario: 'A', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }], expected: ['A'] },\n    { scenario: 'A, B', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [] }], expected: ['A', 'B'] },\n    { scenario: 'A -> B', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }], expected: ['A', 'B'] },\n    { scenario: '[unsorted] A -> B', concurrency: 1, toDeploy: [{ id: 'B', dependencies: [{ id: 'A' }] }, { id: 'A', dependencies: [] }], expected: ['A', 'B'] },\n    { scenario: 'A -> B -> C', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }, { id: 'C', dependencies: [{ id: 'B' }] }], expected: ['A', 'B', 'C'] },\n    { scenario: 'A -> B, A -> C', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }, { id: 'C', dependencies: [{ id: 'A' }] }], expected: ['A', 'B', 'C'] },\n    {\n      scenario: 'A (slow), B',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'A', dependencies: [], name: SLOW },\n        { id: 'B', dependencies: [] },\n      ],\n      expected: ['A', 'B'],\n    },\n    {\n      scenario: 'A -> B, C -> D',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'A', dependencies: [] },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expected: ['A', 'C', 'B', 'D'],\n    },\n    {\n      scenario: 'A (slow) -> B, C -> D',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'A', dependencies: [], name: SLOW },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expected: ['A', 'C', 'B', 'D'],\n    },\n\n    // Concurrency 2\n    { scenario: 'No Stacks', concurrency: 2, toDeploy: [], expected: [] },\n    { scenario: 'A', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }], expected: ['A'] },\n    { scenario: 'A, B', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [] }], expected: ['A', 'B'] },\n    { scenario: 'A -> B', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }], expected: ['A', 'B'] },\n    { scenario: '[unsorted] A -> B', concurrency: 2, toDeploy: [{ id: 'B', dependencies: [{ id: 'A' }] }, { id: 'A', dependencies: [] }], expected: ['A', 'B'] },\n    { scenario: 'A -> B -> C', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }, { id: 'C', dependencies: [{ id: 'B' }] }], expected: ['A', 'B', 'C'] },\n    { scenario: 'A -> B, A -> C', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [{ id: 'A' }] }, { id: 'C', dependencies: [{ id: 'A' }] }], expected: ['A', 'B', 'C'] },\n    {\n      scenario: 'A, B',\n      concurrency: 2,\n      toDeploy: [\n        { id: 'A', dependencies: [], name: SLOW },\n        { id: 'B', dependencies: [] },\n      ],\n      expected: ['B', 'A'],\n    },\n    {\n      scenario: 'A -> B, C -> D',\n      concurrency: 2,\n      toDeploy: [\n        { id: 'A', dependencies: [] },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expected: ['A', 'C', 'B', 'D'],\n    },\n    {\n      scenario: 'A (slow) -> B, C -> D',\n      concurrency: 2,\n      toDeploy: [\n        { id: 'A', dependencies: [], name: SLOW },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expected: ['C', 'D', 'A', 'B'],\n    },\n    {\n      scenario: 'A -> B, A not selected',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'B', dependencies: [{ id: 'A' }] },\n      ],\n      expected: ['B'],\n    },\n  ])('Success - Concurrency: $concurrency - $scenario', async ({ concurrency, expected, toDeploy }) => {\n    await expect(deployStacks(toDeploy as unknown as Stack[], { concurrency, deployStack })).resolves.toBeUndefined();\n\n    expect(deployedStacks).toStrictEqual(expected);\n  });",
            "file": "deploy.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Failure - Concurrency: $concurrency - $scenario",
            "suites": [
                "DeployStacks"
            ],
            "line": 133,
            "code": "  test.each([\n    // Concurrency 1\n    { scenario: 'A (error)', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }], expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A (error), B', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }, { id: 'B', dependencies: [] }], expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A, B (error)', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [], displayName: 'B' }], expectedError: 'B', expectedStacks: ['A'] },\n    { scenario: 'A (error) -> B', concurrency: 1, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }, { id: 'B', dependencies: [{ id: 'A' }] }], expectedError: 'A', expectedStacks: [] },\n    { scenario: '[unsorted] A (error) -> B', concurrency: 1, toDeploy: [{ id: 'B', dependencies: [{ id: 'A' }] }, { id: 'A', dependencies: [], displayName: 'A' }], expectedError: 'A', expectedStacks: [] },\n    {\n      scenario: 'A (error) -> B, C -> D',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'A', dependencies: [], displayName: 'A' },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expectedError: 'A',\n      expectedStacks: [],\n    },\n    {\n      scenario: 'A -> B, C (error) -> D',\n      concurrency: 1,\n      toDeploy: [\n        { id: 'A', dependencies: [] },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [], displayName: 'C', name: SLOW },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expectedError: 'C',\n      expectedStacks: ['A'],\n    },\n\n    // Concurrency 2\n    { scenario: 'A (error)', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }], expectedError: 'A', expectedStacks: [] },\n    { scenario: 'A (error), B', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }, { id: 'B', dependencies: [] }], expectedError: 'A', expectedStacks: ['B'] },\n    { scenario: 'A, B (error)', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [] }, { id: 'B', dependencies: [], displayName: 'B' }], expectedError: 'B', expectedStacks: ['A'] },\n    { scenario: 'A (error) -> B', concurrency: 2, toDeploy: [{ id: 'A', dependencies: [], displayName: 'A' }, { id: 'B', dependencies: [{ id: 'A' }] }], expectedError: 'A', expectedStacks: [] },\n    { scenario: '[unsorted] A (error) -> B', concurrency: 2, toDeploy: [{ id: 'B', dependencies: [{ id: 'A' }] }, { id: 'A', dependencies: [], displayName: 'A' }], expectedError: 'A', expectedStacks: [] },\n    {\n      scenario: 'A (error) -> B, C -> D',\n      concurrency: 2,\n      toDeploy: [\n        { id: 'A', dependencies: [], displayName: 'A' },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [] },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expectedError: 'A',\n      expectedStacks: ['C'],\n    },\n    {\n      scenario: 'A -> B, C (error) -> D',\n      concurrency: 2,\n      toDeploy: [\n        { id: 'A', dependencies: [] },\n        { id: 'B', dependencies: [{ id: 'A' }] },\n        { id: 'C', dependencies: [], displayName: 'C', name: SLOW },\n        { id: 'D', dependencies: [{ id: 'C' }] },\n      ],\n      expectedError: 'C',\n      expectedStacks: ['A', 'B'],\n    },\n  ])('Failure - Concurrency: $concurrency - $scenario', async ({ concurrency, expectedError, toDeploy, expectedStacks }) => {\n    await expect(deployStacks(toDeploy as unknown as Stack[], { concurrency, deployStack })).rejects.toThrowError(expectedError);\n\n    expect(deployedStacks).toStrictEqual(expectedStacks);\n  });",
            "file": "deploy.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "diff can diff multiple stacks",
            "suites": [
                "non-nested stacks"
            ],
            "updatePoint": {
                "line": 69,
                "column": 37
            },
            "line": 69,
            "code": "  test('diff can diff multiple stacks', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['B'],\n      stream: buffer,\n    });\n\n    // THEN\n    const plainTextOutput = buffer.data.replace(/\\x1B\\[[0-?]*[ -/]*[@-~]/g, '');\n    expect(plainTextOutput).toContain('Stack A');\n    expect(plainTextOutput).toContain('Stack B');\n\n    expect(exitCode).toBe(0);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "exits with 1 with diffs and fail set to true",
            "suites": [
                "non-nested stacks"
            ],
            "updatePoint": {
                "line": 87,
                "column": 52
            },
            "line": 87,
            "code": "  test('exits with 1 with diffs and fail set to true', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['A'],\n      stream: buffer,\n      fail: true,\n    });\n\n    // THEN\n    expect(exitCode).toBe(1);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws an error if no valid stack names given",
            "suites": [
                "non-nested stacks"
            ],
            "updatePoint": {
                "line": 102,
                "column": 53
            },
            "line": 102,
            "code": "  test('throws an error if no valid stack names given', async () => {\n    const buffer = new StringWritable();\n\n    // WHEN\n    await expect(() => toolkit.diff({\n      stackNames: ['X', 'Y', 'Z'],\n      stream: buffer,\n    })).rejects.toThrow('No stacks match the name(s) X,Y,Z');\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "exits with 1 with diff in first stack, but not in second stack and fail set to true",
            "suites": [
                "non-nested stacks"
            ],
            "updatePoint": {
                "line": 112,
                "column": 91
            },
            "line": 112,
            "code": "  test('exits with 1 with diff in first stack, but not in second stack and fail set to true', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['A', 'D'],\n      stream: buffer,\n      fail: true,\n    });\n\n    // THEN\n    expect(exitCode).toBe(1);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws an error during diffs on stack with error metadata",
            "suites": [
                "non-nested stacks"
            ],
            "updatePoint": {
                "line": 127,
                "column": 65
            },
            "line": 127,
            "code": "  test('throws an error during diffs on stack with error metadata', async () => {\n    const buffer = new StringWritable();\n\n    // WHEN\n    await expect(() => toolkit.diff({\n      stackNames: ['C'],\n      stream: buffer,\n    })).rejects.toThrow(/Found errors/);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "diff can diff nested stacks",
            "suites": [
                "nested stacks"
            ],
            "updatePoint": {
                "line": 229,
                "column": 35
            },
            "line": 229,
            "code": "  test('diff can diff nested stacks', async () => {\n    // GIVEN\n    const buffer = new StringWritable();\n\n    // WHEN\n    const exitCode = await toolkit.diff({\n      stackNames: ['Parent'],\n      stream: buffer,\n    });\n\n    // THEN\n    const plainTextOutput = buffer.data.replace(/\\x1B\\[[0-?]*[ -/]*[@-~]/g, '')\n      .replace(/[ \\t]+$/mg, '');\n    expect(plainTextOutput.trim()).toEqual(`Stack Parent\nResources\n[~] AWS::CloudFormation::Stack AdditionChild\n └─ [~] Resources\n     └─ [~] .SomeResource:\n         └─ [+] Added: .Properties\n[~] AWS::CloudFormation::Stack DeletionChild\n └─ [~] Resources\n     └─ [~] .SomeResource:\n         └─ [-] Removed: .Properties\n[~] AWS::CloudFormation::Stack ChangedChild\n └─ [~] Resources\n     └─ [~] .SomeResource:\n         └─ [~] .Properties:\n             └─ [~] .Prop:\n                 ├─ [-] old-value\n                 └─ [+] new-value`);\n\n    expect(exitCode).toBe(0);\n  });",
            "file": "diff.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "discovers importable resources",
            "suites": [],
            "updatePoint": {
                "line": 78,
                "column": 36
            },
            "line": 78,
            "code": "test('discovers importable resources', async () => {\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, {\n    Resources: {},\n  });\n\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n  expect(additions).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "by default, its an error if there are non-addition changes in the template",
            "suites": [],
            "updatePoint": {
                "line": 92,
                "column": 80
            },
            "line": 92,
            "code": "test('by default, its an error if there are non-addition changes in the template', async () => {\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, {\n    Resources: {\n      SomethingThatDisappeared: {\n        Type: 'AWS::S3::Bucket',\n      },\n    },\n  });\n\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  await expect(importer.discoverImportableResources()).rejects.toThrow(/No resource updates or deletes/);\n\n  // But the error can be silenced\n  await expect(importer.discoverImportableResources(true)).resolves.toBeTruthy();\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "asks human for resource identifiers",
            "suites": [],
            "updatePoint": {
                "line": 108,
                "column": 41
            },
            "line": 108,
            "code": "test('asks human for resource identifiers', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('TheQueueName');\n  const importable = await importer.askForResourceIdentifiers(additions);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: {\n      QueueName: 'TheQueueName',\n    },\n  });\n  expect(importable.importResources).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "asks human to confirm automic import if identifier is in template",
            "suites": [],
            "updatePoint": {
                "line": 131,
                "column": 71
            },
            "line": 131,
            "code": "test('asks human to confirm automic import if identifier is in template', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_NAMED_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_NAMED_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true);\n  const importable = await importer.askForResourceIdentifiers(additions);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: {\n      QueueName: 'TheQueueName',\n    },\n  });\n  expect(importable.importResources).toEqual([\n    expect.objectContaining({\n      logicalId: 'MyQueue',\n    }),\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "asks human to confirm automic import if identifier is in template",
            "suites": [],
            "updatePoint": {
                "line": 154,
                "column": 71
            },
            "line": 154,
            "code": "test('asks human to confirm automic import if identifier is in template', async () => {\n  // GIVEN\n  givenCurrentStack(STACK_WITH_QUEUE.stackName, { Resources: {} });\n  const importer = new ResourceImporter(STACK_WITH_QUEUE, deployments);\n  const { additions } = await importer.discoverImportableResources();\n  const importMap: ImportMap = {\n    importResources: additions,\n    resourceMap: {\n      MyQueue: { QueueName: 'TheQueueName' },\n    },\n  };\n\n  // WHEN\n  await importer.importResources(importMap, {\n    stack: STACK_WITH_QUEUE,\n  });\n\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyQueue',\n      ResourceIdentifier: { QueueName: 'TheQueueName' },\n      ResourceType: 'AWS::SQS::Queue',\n    },\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "only use one identifier if multiple are in template",
            "suites": [],
            "updatePoint": {
                "line": 180,
                "column": 57
            },
            "line": 180,
            "code": "test('only use one identifier if multiple are in template', async () => {\n  // GIVEN\n  const stack = stackWithGlobalTable({\n    TableName: 'TheTableName',\n    TableArn: 'ThisFieldDoesntExistInReality',\n    TableStreamArn: 'NorDoesThisOne',\n  });\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true); // Confirm yes/no\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyTable',\n      ResourceIdentifier: { TableName: 'TheTableName' },\n      ResourceType: 'AWS::DynamoDB::GlobalTable',\n    },\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "only ask user for one identifier if multiple possible ones are possible",
            "suites": [],
            "updatePoint": {
                "line": 202,
                "column": 77
            },
            "line": 202,
            "code": "test('only ask user for one identifier if multiple possible ones are possible', async () => {\n  // GIVEN -- no identifiers in template, so ask user\n  const stack = stackWithGlobalTable({});\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('Banana');\n  const importable = await importTemplateFromClean(stack);\n\n  // THEN -- only asked once\n  expect(promptlyPrompt).toHaveBeenCalledTimes(1);\n  expect(importable.resourceMap).toEqual({\n    MyTable: { TableName: 'Banana' },\n  });\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "ask identifier if the value in the template is a CFN intrinsic",
            "suites": [],
            "updatePoint": {
                "line": 217,
                "column": 68
            },
            "line": 217,
            "code": "test('ask identifier if the value in the template is a CFN intrinsic', async () => {\n  // GIVEN -- identifier in template is a CFN intrinsic so it doesn't count\n  const stack = stackWithQueue({\n    QueueName: { Ref: 'SomeParam' },\n  });\n\n  // WHEN\n  promptlyPrompt.mockResolvedValue('Banana');\n  const importable = await importTemplateFromClean(stack);\n\n  // THEN\n  expect(importable.resourceMap).toEqual({\n    MyQueue: { QueueName: 'Banana' },\n  });\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "take compound identifiers from the template if found",
            "suites": [],
            "updatePoint": {
                "line": 233,
                "column": 58
            },
            "line": 233,
            "code": "test('take compound identifiers from the template if found', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({\n    HostedZoneId: 'z-123',\n    Name: 'KeyName',\n  });\n\n  // WHEN\n  promptlyConfirm.mockResolvedValue(true);\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyKSK',\n      ResourceIdentifier: { HostedZoneId: 'z-123', Name: 'KeyName' },\n      ResourceType: 'AWS::Route53::KeySigningKey',\n    },\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "ask user for compound identifiers if not found",
            "suites": [],
            "updatePoint": {
                "line": 254,
                "column": 52
            },
            "line": 254,
            "code": "test('ask user for compound identifiers if not found', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({});\n\n  // WHEN\n  promptlyPrompt.mockReturnValue('Banana');\n  await importTemplateFromClean(stack);\n\n  // THEN\n  expect(createChangeSetInput?.ResourcesToImport).toEqual([\n    {\n      LogicalResourceId: 'MyKSK',\n      ResourceIdentifier: { HostedZoneId: 'Banana', Name: 'Banana' },\n      ResourceType: 'AWS::Route53::KeySigningKey',\n    },\n  ]);\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not ask for second part of compound identifier if the user skips the first",
            "suites": [],
            "updatePoint": {
                "line": 272,
                "column": 83
            },
            "line": 272,
            "code": "test('do not ask for second part of compound identifier if the user skips the first', async () => {\n  // GIVEN\n  const stack = stackWithKeySigningKey({});\n\n  // WHEN\n  promptlyPrompt.mockReturnValue('');\n  const importMap = await importTemplateFromClean(stack);\n\n  // THEN\n  expect(importMap.resourceMap).toEqual({});\n});",
            "file": "import.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "verify \"future flags\" are added to cdk.json",
            "suites": [
                "constructs version"
            ],
            "updatePoint": {
                "line": 141,
                "column": 51
            },
            "line": 141,
            "code": "  test('verify \"future flags\" are added to cdk.json', async () => {\n\n    for (const templ of await availableInitTemplates()) {\n      for (const lang of templ.languages) {\n        await withTempDir(async tmpDir => {\n          await cliInit(templ.name, lang,\n            /* canUseNetwork */ false,\n            /* generateOnly */ true,\n            tmpDir);\n\n          // ok if template doesn't have a cdk.json file (e.g. the \"lib\" template)\n          if (!await fs.pathExists(path.join(tmpDir, 'cdk.json'))) {\n            return;\n          }\n\n          const config = await fs.readJson(path.join(tmpDir, 'cdk.json'));\n          const context = config.context || {};\n          for (const [key, actual] of Object.entries(context)) {\n            expect(key in cxapi.NEW_PROJECT_CONTEXT).toBeTruthy();\n            expect(cxapi.NEW_PROJECT_CONTEXT[key]).toEqual(actual);\n          }\n\n          // assert that expired future flags are not part of the cdk.json\n          Object.keys(context).forEach(k => {\n            expect(cxapi.CURRENT_VERSION_EXPIRED_FLAGS.includes(k)).toEqual(false);\n          });\n        });\n      }\n    }\n  },\n  // This is a lot to test, and it can be slow-ish, especially when ran with other tests.\n  30_000);",
            "file": "init.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "when no version number is present (e.g., local development), the v2 templates are chosen by default",
            "suites": [
                "constructs version"
            ],
            "updatePoint": {
                "line": 175,
                "column": 105
            },
            "line": 175,
            "code": "test('when no version number is present (e.g., local development), the v2 templates are chosen by default', async () => {\n  expect((await availableInitTemplates()).length).toBeGreaterThan(0);\n});",
            "file": "init.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correct format",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 96,
                "column": 24
            },
            "line": 96,
            "code": "    test('correct format', () => {\n      const result = formatNotices([BASIC_NOTICE])[0];\n      expect(result).toEqual(`16603\tToggling off auto_delete_objects for Bucket empties the bucket\n\n\tOverview: If a stack is deployed with an S3 bucket with\n\t          auto_delete_objects=True, and then re-deployed with\n\t          auto_delete_objects=False, all the objects in the bucket\n\t          will be deleted.\n\n\tAffected versions: cli: <=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/16603\n`);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "multiple affect versions",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 111,
                "column": 34
            },
            "line": 111,
            "code": "    test('multiple affect versions', () => {\n      const result = formatNotices([MULTIPLE_AFFECTED_VERSIONS_NOTICE])[0];\n      expect(result).toEqual(`17061\tError when building EKS cluster with monocdk import\n\n\tOverview: When using monocdk/aws-eks to build a stack containing an\n\t          EKS cluster, error is thrown about missing\n\t          lambda-layer-node-proxy-agent/layer/package.json.\n\n\tAffected versions: cli: <1.130.0 >=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/17061\n`);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly filter notices on cli",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 127,
                "column": 41
            },
            "line": 127,
            "code": "    test('correctly filter notices on cli', () => {\n      const notices = [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE];\n      expect(filterNotices(notices, {\n        cliVersion: '1.0.0',\n      })).toEqual([BASIC_NOTICE]);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.129.0',\n      })).toEqual([MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.126.0',\n      })).toEqual(notices);\n\n      expect(filterNotices(notices, {\n        cliVersion: '1.130.0',\n      })).toEqual([]);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly filter notices on framework",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 146,
                "column": 47
            },
            "line": 146,
            "code": "    test('correctly filter notices on framework', () => {\n      const notices = [FRAMEWORK_2_1_0_AFFECTED_NOTICE];\n\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-2_12_0'),\n      })).toEqual([]);\n\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-1_144_0'),\n      })).toEqual([FRAMEWORK_2_1_0_AFFECTED_NOTICE]);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "correctly filter notices on arbitrary modules",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 158,
                "column": 55
            },
            "line": 158,
            "code": "    test('correctly filter notices on arbitrary modules', () => {\n      const notices = [NOTICE_FOR_APIGATEWAYV2];\n\n      // module-level match\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([NOTICE_FOR_APIGATEWAYV2]);\n\n      // no apigatewayv2 in the tree\n      expect(filterNotices(notices, {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/built-with-2_12_0'),\n      })).toEqual([]);\n\n      // module name mismatch: apigateway != apigatewayv2\n      expect(filterNotices([NOTICE_FOR_APIGATEWAY], {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([]);\n\n      // construct-level match\n      expect(filterNotices([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE], {\n        outdir: path.join(__dirname, 'cloud-assembly-trees/experimental-module'),\n      })).toEqual([NOTICE_FOR_APIGATEWAYV2_CFN_STAGE]);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns data when download succeeds",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 187,
                "column": 45
            },
            "line": 187,
            "code": "    test('returns data when download succeeds', async () => {\n      const result = await mockCall(200, {\n        notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      expect(result).toEqual([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when the server returns an unexpected status code",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 195,
                "column": 85
            },
            "line": 195,
            "code": "    test('returns appropriate error when the server returns an unexpected status code', async () => {\n      const result = mockCall(500, {\n        notices: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      await expect(result).rejects.toThrow(/500/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when the server returns an unexpected structure",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 203,
                "column": 83
            },
            "line": 203,
            "code": "    test('returns appropriate error when the server returns an unexpected structure', async () => {\n      const result = mockCall(200, {\n        foo: [BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE],\n      });\n\n      await expect(result).rejects.toThrow(/key is missing/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when the server returns invalid json",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 211,
                "column": 72
            },
            "line": 211,
            "code": "    test('returns appropriate error when the server returns invalid json', async () => {\n      const result = mockCall(200, '-09aiskjkj838');\n\n      await expect(result).rejects.toThrow(/Failed to parse/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when HTTPS call throws",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 217,
                "column": 58
            },
            "line": 217,
            "code": "    test('returns appropriate error when HTTPS call throws', async () => {\n      const mockGet = jest.spyOn(https, 'get')\n        .mockImplementation(() => { throw new Error('No connection'); });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/No connection/);\n\n      mockGet.mockRestore();\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when the request has an error",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 228,
                "column": 65
            },
            "line": 228,
            "code": "    test('returns appropriate error when the request has an error', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .replyWithError('DNS resolution failed');\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/DNS resolution failed/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns appropriate error when the connection stays idle for too long",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 238,
                "column": 79
            },
            "line": 238,
            "code": "    test('returns appropriate error when the connection stays idle for too long', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .delayConnection(3500)\n        .reply(200, {\n          notices: [BASIC_NOTICE],\n        });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/timed out/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "returns empty array when the request takes too long to finish",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 251,
                "column": 71
            },
            "line": 251,
            "code": "    test('returns empty array when the request takes too long to finish', async () => {\n      nock('https://cli.cdk.dev-tools.aws.dev')\n        .get('/notices.json')\n        .delayBody(3500)\n        .reply(200, {\n          notices: [BASIC_NOTICE],\n        });\n\n      const result = dataSource.fetch();\n\n      await expect(result).rejects.toThrow(/timed out/);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "retrieves data from the delegate cache when the file is empty",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 282,
                "column": 71
            },
            "line": 282,
            "code": "    test('retrieves data from the delegate cache when the file is empty', async () => {\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "retrieves data from the file when the data is still valid",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 290,
                "column": 67
            },
            "line": 290,
            "code": "    test('retrieves data from the file when the data is still valid', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: Date.now() + 10000,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(cachedData);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "retrieves data from the delegate when the data is expired",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 302,
                "column": 67
            },
            "line": 302,
            "code": "    test('retrieves data from the delegate when the data is expired', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: 0,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "retrieves data from the delegate when the file cannot be read",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 314,
                "column": 71
            },
            "line": 314,
            "code": "    test('retrieves data from the delegate when the file cannot be read', async () => {\n      const debugSpy = jest.spyOn(logging, 'debug');\n\n      if (fs.existsSync('does-not-exist.json')) {\n        fs.unlinkSync('does-not-exist.json');\n      }\n\n      const dataSource = dataSourceWithDelegateReturning(freshData, 'does-not-exist.json');\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n      expect(debugSpy).not.toHaveBeenCalled();\n\n      debugSpy.mockRestore();\n\n      if (fs.existsSync('does-not-exist.json')) {\n        fs.unlinkSync('does-not-exist.json');\n      }\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "retrieved data from the delegate when it is configured to ignore the cache",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 335,
                "column": 84
            },
            "line": 335,
            "code": "    test('retrieved data from the delegate when it is configured to ignore the cache', async () => {\n      fs.writeJsonSync(fileName, {\n        notices: cachedData,\n        expiration: Date.now() + 10000,\n      });\n      const dataSource = dataSourceWithDelegateReturning(freshData, fileName, true);\n\n      const notices = await dataSource.fetch();\n\n      expect(notices).toEqual(freshData);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "error in delegate gets turned into empty result by cached source",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 347,
                "column": 74
            },
            "line": 347,
            "code": "    test('error in delegate gets turned into empty result by cached source', async () => {\n      // GIVEN\n      const delegate = {\n        fetch: jest.fn().mockRejectedValue(new Error('fetching failed')),\n      };\n      const dataSource = new CachedDataSource(fileName, delegate, true);\n\n      // WHEN\n      const notices = await dataSource.fetch();\n\n      // THEN\n      expect(notices).toEqual([]);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not show anything when there are no notices",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 372,
                "column": 58
            },
            "line": 372,
            "code": "    test('does not show anything when there are no notices', async () => {\n      const dataSource = createDataSource();\n      dataSource.fetch.mockResolvedValue([]);\n\n      const result = await generateMessage(dataSource, {\n        acknowledgedIssueNumbers: [],\n        outdir: '/tmp',\n      });\n\n      expect(result).toEqual('');\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "shows notices that pass the filter",
            "suites": [
                "cli notices"
            ],
            "updatePoint": {
                "line": 384,
                "column": 44
            },
            "line": 384,
            "code": "    test('shows notices that pass the filter', async () => {\n      const dataSource = createDataSource();\n      dataSource.fetch.mockResolvedValue([BASIC_NOTICE, MULTIPLE_AFFECTED_VERSIONS_NOTICE]);\n\n      const result = await generateMessage(dataSource, {\n        acknowledgedIssueNumbers: [17061],\n        outdir: '/tmp',\n      });\n\n      expect(result).toEqual(`\nNOTICES         (What's this? https://github.com/aws/aws-cdk/wiki/CLI-Notices)\n\n16603\tToggling off auto_delete_objects for Bucket empties the bucket\n\n\tOverview: If a stack is deployed with an S3 bucket with\n\t          auto_delete_objects=True, and then re-deployed with\n\t          auto_delete_objects=False, all the objects in the bucket\n\t          will be deleted.\n\n\tAffected versions: cli: <=1.126.0\n\n\tMore information at: https://github.com/aws/aws-cdk/issues/16603\n\n\nIf you don’t want to see a notice anymore, use \"cdk acknowledge <id>\". For example, \"cdk acknowledge 16603\".`);\n    });",
            "file": "notices.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "%p is in range: %p",
            "suites": [],
            "line": 5,
            "code": "test.each([\n  ['2.1', false],\n  ['2.2', true],\n  ['2', false],\n  ['3', true],\n  ['4', false],\n  ['4.3', true],\n  ['4.3', true],\n  ['4.2.294-220.533.amzn2.x86_64', true],\n])('%p is in range: %p', (version, expected) => {\n  expect(isVersionBetween(version, '2.1.0.6', '4.9.2')).toEqual(expected);\n});",
            "file": "platform-warnings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "writer lock excludes other locks",
            "suites": [],
            "updatePoint": {
                "line": 10,
                "column": 38
            },
            "line": 10,
            "code": "test('writer lock excludes other locks', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const w = await lock.acquireWrite();\n\n  // WHEN\n  try {\n    await expect(lock.acquireWrite()).rejects.toThrow(/currently synthing/);\n    await expect(lock.acquireRead()).rejects.toThrow(/currently synthing/);\n  } finally {\n    await w.release();\n  }\n});",
            "file": "rwlock.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "reader lock allows other readers but not writers",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 54
            },
            "line": 24,
            "code": "test('reader lock allows other readers but not writers', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const r = await lock.acquireRead();\n\n  // WHEN\n  try {\n    await expect(lock.acquireWrite()).rejects.toThrow(/currently reading/);\n\n    const r2 = await lock.acquireRead();\n    await r2.release();\n  } finally {\n    await r.release();\n  }\n});",
            "file": "rwlock.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can convert writer to reader lock",
            "suites": [],
            "updatePoint": {
                "line": 40,
                "column": 39
            },
            "line": 40,
            "code": "test('can convert writer to reader lock', async () => {\n  // GIVEN\n  const lock = new RWLock(testDir());\n  const w = await lock.acquireWrite();\n\n  // WHEN\n  const r = await w.convertToReaderLock();\n  try {\n    const r2 = await lock.acquireRead();\n    await r2.release();\n  } finally {\n    await r.release();\n  }\n});",
            "file": "rwlock.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "does not wrap lines",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 27
            },
            "line": 5,
            "code": "  test('does not wrap lines', () => {\n    const longString = 'Long string is long!'.repeat(1_024);\n    expect(toYAML({ longString })).toEqual(`longString: ${longString}\\n`);\n  });",
            "file": "serialize.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can delete values from Context object",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 43
            },
            "line": 4,
            "code": "test('can delete values from Context object', () => {\n  // GIVEN\n  const settings1 = new Settings({ foo: 'bar' });\n  const settings2 = new Settings({ boo: 'baz' });\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.unset('foo');\n\n  // THEN\n  expect(context.all).toEqual({ boo: 'baz' });\n  expect(settings1.all).toEqual({});\n  expect(settings2.all).toEqual({ boo: 'baz' });\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can set values in Context object",
            "suites": [],
            "updatePoint": {
                "line": 19,
                "column": 38
            },
            "line": 19,
            "code": "test('can set values in Context object', () => {\n  // GIVEN\n  const settings1 = new Settings();\n  const settings2 = new Settings();\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.set('foo', 'bar');\n\n  // THEN\n  expect(context.all).toEqual({ foo: 'bar' });\n  expect(settings1.all).toEqual({ foo: 'bar' });\n  expect(settings2.all).toEqual({});\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can set values in Context object if first is immutable",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 60
            },
            "line": 34,
            "code": "test('can set values in Context object if first is immutable', () => {\n  // GIVEN\n  const settings1 = new Settings();\n  const settings2 = new Settings();\n  const context = new Context(settings1.makeReadOnly(), settings2);\n\n  // WHEN\n  context.set('foo', 'bar');\n\n  // THEN\n  expect(context.all).toEqual({ foo: 'bar' });\n  expect(settings1.all).toEqual({ });\n  expect(settings2.all).toEqual({ foo: 'bar' });\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can clear all values in all objects",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 41
            },
            "line": 49,
            "code": "test('can clear all values in all objects', () => {\n  // GIVEN\n  const settings1 = new Settings({ foo: 'bar' });\n  const settings2 = new Settings({ foo: 'snar', boo: 'gar' });\n  const context = new Context(settings1, settings2);\n\n  // WHEN\n  context.clear();\n\n  // THEN\n  expect(context.all).toEqual({});\n  expect(settings1.all).toEqual({ });\n  expect(settings2.all).toEqual({});\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can parse string context from command line arguments",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 58
            },
            "line": 64,
            "code": "test('can parse string context from command line arguments', () => {\n  // GIVEN\n  const settings1 = Settings.fromCommandLineArguments({ context: ['foo=bar'], _: [Command.DEPLOY] });\n  const settings2 = Settings.fromCommandLineArguments({ context: ['foo='], _: [Command.DEPLOY] });\n\n  // THEN\n  expect(settings1.get(['context']).foo).toEqual( 'bar');\n  expect(settings2.get(['context']).foo).toEqual( '');\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can parse string context from command line arguments with equals sign in value",
            "suites": [],
            "updatePoint": {
                "line": 74,
                "column": 84
            },
            "line": 74,
            "code": "test('can parse string context from command line arguments with equals sign in value', () => {\n  // GIVEN\n  const settings1 = Settings.fromCommandLineArguments({ context: ['foo==bar='], _: [Command.DEPLOY] });\n  const settings2 = Settings.fromCommandLineArguments({ context: ['foo=bar='], _: [Command.DEPLOY] });\n\n  // THEN\n  expect(settings1.get(['context']).foo).toEqual( '=bar=');\n  expect(settings2.get(['context']).foo).toEqual( 'bar=');\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bundling stacks defaults to an empty list",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 47
            },
            "line": 84,
            "code": "test('bundling stacks defaults to an empty list', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.LIST],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual([]);\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bundling stacks defaults to ** for deploy",
            "suites": [],
            "updatePoint": {
                "line": 94,
                "column": 47
            },
            "line": 94,
            "code": "test('bundling stacks defaults to ** for deploy', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['**']);\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bundling stacks defaults to ** for watch",
            "suites": [],
            "updatePoint": {
                "line": 104,
                "column": 46
            },
            "line": 104,
            "code": "test('bundling stacks defaults to ** for watch', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.WATCH],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['**']);\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bundling stacks with deploy exclusively",
            "suites": [],
            "updatePoint": {
                "line": 114,
                "column": 45
            },
            "line": 114,
            "code": "test('bundling stacks with deploy exclusively', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n    exclusively: true,\n    STACKS: ['cool-stack'],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['cool-stack']);\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "bundling stacks with watch exclusively",
            "suites": [],
            "updatePoint": {
                "line": 126,
                "column": 44
            },
            "line": 126,
            "code": "test('bundling stacks with watch exclusively', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.WATCH],\n    exclusively: true,\n    STACKS: ['cool-stack'],\n  });\n\n  // THEN\n  expect(settings.get(['bundlingStacks'])).toEqual(['cool-stack']);\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "should include outputs-file in settings",
            "suites": [],
            "updatePoint": {
                "line": 138,
                "column": 45
            },
            "line": 138,
            "code": "test('should include outputs-file in settings', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.DEPLOY],\n    outputsFile: 'my-outputs-file.json',\n  });\n\n  // THEN\n  expect(settings.get(['outputsFile'])).toEqual('my-outputs-file.json');\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "providing a build arg",
            "suites": [],
            "updatePoint": {
                "line": 149,
                "column": 27
            },
            "line": 149,
            "code": "test('providing a build arg', () => {\n  // GIVEN\n  const settings = Settings.fromCommandLineArguments({\n    _: [Command.SYNTH],\n    build: 'mvn package',\n  });\n\n  // THEN\n  expect(settings.get(['build'])).toEqual('mvn package');\n});",
            "file": "settings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "tree matches predicate",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 83,
                "column": 30
            },
            "line": 83,
            "code": "  test('tree matches predicate', () => {\n    expect(some(tree, node => node.constructInfo?.fqn === '@aws-cdk/aws-s3.Bucket')).toBe(true);\n  });",
            "file": "tree.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "tree does not match predicate",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 87,
                "column": 37
            },
            "line": 87,
            "code": "  test('tree does not match predicate', () => {\n    expect(some(tree, node => node.constructInfo?.fqn === '@aws-cdk/aws-lambda.Function')).toBe(false);\n  });",
            "file": "tree.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "childless tree",
            "suites": [
                "some"
            ],
            "updatePoint": {
                "line": 91,
                "column": 22
            },
            "line": 91,
            "code": "  test('childless tree', () => {\n    const childless = {\n      id: 'App',\n      path: '',\n      constructInfo: {\n        fqn: 'aws-cdk-lib.App',\n        version: '1.162.0',\n      },\n    };\n\n    expect(some(childless, node => node.path.length > 0)).toBe(false);\n  });",
            "file": "tree.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "can find tree",
            "suites": [
                "loadTreeFromDir"
            ],
            "updatePoint": {
                "line": 106,
                "column": 21
            },
            "line": 106,
            "code": "  test('can find tree', () => {\n    const tree = loadTreeFromDir(path.join(__dirname, 'cloud-assembly-trees/built-with-1_144_0'));\n    expect(tree.id).toEqual('App');\n  });",
            "file": "tree.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cannot find tree",
            "suites": [
                "loadTreeFromDir"
            ],
            "updatePoint": {
                "line": 111,
                "column": 24
            },
            "line": 111,
            "code": "  test('cannot find tree', () => {\n    const tree = loadTreeFromDir(path.join(__dirname, 'cloud-assembly-trees/foo'));\n    expect(tree).toEqual({});\n  });",
            "file": "tree.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "load settings from both files if available",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 48
            },
            "line": 14,
            "code": "test('load settings from both files if available', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [PROJECT_CONFIG, {\n      project: 'foobar',\n    }],\n    [USER_CONFIG, {\n      project: 'foo',\n      test: 'bar',\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  const config = await new Configuration().load();\n\n  // THEN\n  expect(config.settings.get(['project'])).toBe('foobar');\n  expect(config.settings.get(['test'])).toBe('bar');\n});",
            "file": "usersettings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "load context from all 3 files if available",
            "suites": [],
            "updatePoint": {
                "line": 41,
                "column": 48
            },
            "line": 41,
            "code": "test('load context from all 3 files if available', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [PROJECT_CONFIG, {\n      context: {\n        project: 'foobar',\n      },\n    }],\n    [PROJECT_CONTEXT, {\n      foo: 'bar',\n    }],\n    [USER_CONFIG, {\n      context: {\n        test: 'bar',\n      },\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  const config = await new Configuration().load();\n\n  // THEN\n  expect(config.context.get('project')).toBe('foobar');\n  expect(config.context.get('foo')).toBe('bar');\n  expect(config.context.get('test')).toBe('bar');\n});",
            "file": "usersettings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "throws an error if the `build` key is specified in the user config",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 72
            },
            "line": 75,
            "code": "test('throws an error if the `build` key is specified in the user config', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [USER_CONFIG, {\n      build: 'foobar',\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  // THEN\n  await expect(new Configuration().load()).rejects.toEqual(new Error('The `build` key cannot be specified in the user config (~/.cdk.json), specify it in the project config (cdk.json) instead'));\n});",
            "file": "usersettings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Can specify the `quiet` key in the user config",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 52
            },
            "line": 95,
            "code": "test('Can specify the `quiet` key in the user config', async () => {\n  // GIVEN\n  const GIVEN_CONFIG: Map<string, any> = new Map([\n    [USER_CONFIG, {\n      quiet: true,\n    }],\n  ]);\n\n  // WHEN\n  mockedFs.pathExists.mockImplementation(path => {\n    return GIVEN_CONFIG.has(path);\n  });\n  mockedFs.readJSON.mockImplementation(path => {\n    return GIVEN_CONFIG.get(path);\n  });\n\n  // THEN\n  const config = await new Configuration().load();\n\n  expect(config.settings.get(['quiet'])).toBe(true);\n});",
            "file": "usersettings.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "applyDefaults() works",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 27
            },
            "line": 4,
            "code": "test('applyDefaults() works', () => {\n  const given = { a: 1 };\n  const defaults = { a: 2, b: 2 };\n\n  const output = applyDefaults(given, defaults);\n\n  expect(output).toEqual({ a: 1, b: 2 });\n});",
            "file": "util/applydefaults.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "flatten combines arrays",
            "suites": [],
            "updatePoint": {
                "line": 4,
                "column": 29
            },
            "line": 4,
            "code": "test('flatten combines arrays', () => {\n  const output = flatten([\n    ['a', 'b'],\n    [],\n    ['c'],\n  ]);\n\n  expect(output).toEqual(['a', 'b', 'c']);\n});",
            "file": "util/arrays.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "flatMap maps and combines",
            "suites": [],
            "updatePoint": {
                "line": 14,
                "column": 31
            },
            "line": 14,
            "code": "test('flatMap maps and combines', () => {\n  const input = ['A', 'B', 'C'];\n  const output = flatMap(input, x => [x.toLowerCase()]);\n\n  expect(output).toEqual(['a', 'b', 'c']);\n});",
            "file": "util/arrays.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "partition splits the collection in twain",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 46
            },
            "line": 21,
            "code": "test('partition splits the collection in twain', () => {\n  const xs = [1, 2, 3, 4, 5];\n  const evens = partition(xs, x => x % 2 === 0);\n\n  expect(evens).toEqual([2, 4]);\n  expect(xs).toEqual([1, 3, 5]);\n});",
            "file": "util/arrays.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "on an EC2 instance, region lookup queries IMDS",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 52
            },
            "line": 18,
            "code": "test('on an EC2 instance, region lookup queries IMDS', async () => {\n  return withMockedClassSingleton(AWS, 'MetadataService', async (mdService) => {\n    mdService.request\n      // First call for a token\n      .mockImplementationOnce((_1, _2, cb) => { cb(undefined as any, 'token'); })\n      // Second call for the region\n      .mockImplementationOnce((_1, _2, cb) => { cb(undefined as any, JSON.stringify({ region: 'some-region' })); });\n\n    const region = await AwsCliCompatible.region({ ec2instance: true });\n    expect(region).toEqual('some-region');\n  });\n});",
            "file": "util/awscli-compatible.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Use web identity when available",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 37
            },
            "line": 31,
            "code": "test('Use web identity when available', async () => {\n\n  // Scrub some environment variables that are maybe set for Ecs Credentials\n  delete process.env.ECS_CONTAINER_METADATA_URI_V4;\n  delete process.env.ECS_CONTAINER_METADATA_URI;\n  delete process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI;\n\n  // create and configure the web identity token file\n  process.env.AWS_WEB_IDENTITY_TOKEN_FILE = 'some-value';\n  process.env.AWS_ROLE_ARN = 'some-value';\n\n  // create the chain\n  const providers = (await AwsCliCompatible.credentialChain()).providers;\n\n  // make sure the web identity provider is in the chain\n  const webIdentify = (providers[5] as Function)();\n  expect(webIdentify).toBeInstanceOf(AWS.TokenFileWebIdentityCredentials);\n});",
            "file": "util/awscli-compatible.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "A non-existent stack pretends to have an empty template",
            "suites": [],
            "updatePoint": {
                "line": 31,
                "column": 61
            },
            "line": 31,
            "code": "test('A non-existent stack pretends to have an empty template', async () => {\n  // GIVEN\n  describeStackMock.mockImplementation(() => ({ Stacks: [] })); // No stacks exist\n\n  // WHEN\n  const stack = await CloudFormationStack.lookup(cfn, 'Dummy');\n\n  // THEN\n  expect(await stack.template()).toEqual({});\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Retrieving a processed template passes 'Processed' to CloudFormation",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 74
            },
            "line": 42,
            "code": "test(\"Retrieving a processed template passes 'Processed' to CloudFormation\", async () => {\n  // GIVEN\n  describeStackMock.mockImplementation(() => ({\n    Stacks: [\n      {\n        StackName: 'Dummy',\n      },\n    ],\n  }));\n  getTemplateMock.mockImplementation(() => ({\n    TemplateBody: '{}',\n  }));\n\n  // WHEN\n  const retrieveProcessedTemplate = true;\n  const cloudFormationStack = await CloudFormationStack.lookup(cfn, 'Dummy', retrieveProcessedTemplate);\n  await cloudFormationStack.template();\n\n  // THEN\n  expect(getTemplateMock).toHaveBeenCalledWith({\n    StackName: 'Dummy',\n    TemplateStage: 'Processed',\n  });\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)",
            "suites": [],
            "line": 67,
            "code": "test.each([\n  [false, false],\n  [false, true],\n  [true, false],\n  [true, true],\n])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)',\n  (haveDefault, havePrevious) => {\n    expect(makeParams(haveDefault, havePrevious, true)).toEqual({\n      apiParameters: [USE_OVERRIDE],\n      changed: true,\n    });\n  });",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "no default, no prev, no override => error",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 47
            },
            "line": 80,
            "code": "test('no default, no prev, no override => error', () => {\n  expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "no default, yes prev, no override => use previous",
            "suites": [],
            "updatePoint": {
                "line": 84,
                "column": 55
            },
            "line": 84,
            "code": "test('no default, yes prev, no override => use previous', () => {\n  expect(makeParams(false, true, false)).toEqual({\n    apiParameters: [USE_PREVIOUS],\n    changed: false,\n  });\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "default, no prev, no override => empty param set (and obviously changes to be applied)",
            "suites": [],
            "updatePoint": {
                "line": 91,
                "column": 92
            },
            "line": 91,
            "code": "test('default, no prev, no override => empty param set (and obviously changes to be applied)', () => {\n  expect(makeParams(true, false, false)).toEqual({\n    apiParameters: [],\n    changed: true,\n  });\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "default, prev, no override => use previous",
            "suites": [],
            "updatePoint": {
                "line": 98,
                "column": 48
            },
            "line": 98,
            "code": "test('default, prev, no override => use previous', () => {\n  expect(makeParams(true, true, false)).toEqual({\n    apiParameters: [USE_PREVIOUS],\n    changed: false,\n  });\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if a parameter is retrieved from SSM, the parameters always count as changed",
            "suites": [],
            "updatePoint": {
                "line": 105,
                "column": 82
            },
            "line": 105,
            "code": "test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: {\n        Type: 'AWS::SSM::Parameter::Name',\n        Default: '/Some/Key',\n      },\n    },\n  });\n  const oldValues = { Foo: '/Some/Key' };\n\n  // If we don't pass a new value\n  expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual('ssm');\n\n  // If we do pass a new value but it's the same as the old one\n  expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual('ssm');\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker",
            "suites": [],
            "updatePoint": {
                "line": 123,
                "column": 109
            },
            "line": 123,
            "code": "test('if a parameter is retrieved from SSM, the parameters doesnt count as changed if it has the magic marker', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: {\n        Type: 'AWS::SSM::Parameter::Name',\n        Default: '/Some/Key',\n        Description: `blabla ${SSMPARAM_NO_INVALIDATE}`,\n      },\n    },\n  });\n  const oldValues = { Foo: '/Some/Key' };\n\n  // If we don't pass a new value\n  expect(params.updateExisting({}, oldValues).hasChanges(oldValues)).toEqual(false);\n\n  // If we do pass a new value but it's the same as the old one\n  expect(params.updateExisting({ Foo: '/Some/Key' }, oldValues).hasChanges(oldValues)).toEqual(false);\n\n  // If we do pass a new value and it's different\n  expect(params.updateExisting({ Foo: '/OTHER/Key' }, oldValues).hasChanges(oldValues)).toEqual(true);\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "empty string is a valid update value",
            "suites": [],
            "updatePoint": {
                "line": 145,
                "column": 42
            },
            "line": 145,
            "code": "test('empty string is a valid update value', () => {\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  expect(params.updateExisting({ Foo: '' }, { Foo: 'ThisIsOld' }).apiParameters).toEqual([\n    { ParameterKey: 'Foo', ParameterValue: '' },\n  ]);\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "unknown parameter in overrides, pass it anyway",
            "suites": [],
            "updatePoint": {
                "line": 157,
                "column": 52
            },
            "line": 157,
            "code": "test('unknown parameter in overrides, pass it anyway', () => {\n  // Not sure if we really want this. It seems like it would be nice\n  // to not pass parameters that aren't expected, given that CFN will\n  // just error out. But maybe we want to be warned of typos...\n  const params = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  expect(params.updateExisting({ Bar: 'Bar' }, {}).apiParameters).toEqual([\n    { ParameterKey: 'Bar', ParameterValue: 'Bar' },\n  ]);\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "if an unsupplied parameter reverts to its default, it can still be dirty",
            "suites": [],
            "updatePoint": {
                "line": 172,
                "column": 78
            },
            "line": 172,
            "code": "test('if an unsupplied parameter reverts to its default, it can still be dirty', () => {\n  // GIVEN\n  const templateParams = TemplateParameters.fromTemplate({\n    Parameters: {\n      Foo: { Type: 'String', Default: 'Foo' },\n    },\n  });\n\n  // WHEN\n  const stackParams = templateParams.supplyAll({});\n\n  // THEN\n  expect(stackParams.hasChanges({ Foo: 'NonStandard' })).toEqual(true);\n  expect(stackParams.hasChanges({ Foo: 'Foo' })).toEqual(false);\n});",
            "file": "util/cloudformation.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "no banner on empty msg list",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 33
            },
            "line": 5,
            "code": "test('no banner on empty msg list', () =>\n  expect(formatAsBanner([])).toEqual([]));",
            "file": "util/console-formatters.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "banner works as expected",
            "suites": [],
            "updatePoint": {
                "line": 8,
                "column": 30
            },
            "line": 8,
            "code": "test('banner works as expected', () =>\n  expect(formatAsBanner(['msg1', 'msg2'])).toEqual([\n    '************',\n    '*** msg1 ***',\n    '*** msg2 ***',\n    '************',\n  ]));",
            "file": "util/console-formatters.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "banner works for formatted msgs",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 37
            },
            "line": 16,
            "code": "test('banner works for formatted msgs', () =>\n  expect(formatAsBanner([\n    'hello msg1',\n    chalk.yellow('hello msg2'),\n    chalk.bold('hello msg3'),\n  ])).toEqual([\n    '******************',\n    '*** hello msg1 ***',\n    `*** ${chalk.yellow('hello msg2')} ***`,\n    `*** ${chalk.bold('hello msg3')} ***`,\n    '******************',\n  ]));",
            "file": "util/console-formatters.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepSet can set deeply",
            "suites": [],
            "updatePoint": {
                "line": 5,
                "column": 28
            },
            "line": 5,
            "code": "test('deepSet can set deeply', () => {\n  const obj = {};\n  deepSet(obj, ['a', 'b'], 3);\n  expect(obj).toEqual({ a: { b: 3 } });\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepGet can get deeply",
            "suites": [],
            "updatePoint": {
                "line": 11,
                "column": 28
            },
            "line": 11,
            "code": "test('deepGet can get deeply', () => {\n  const obj = { a: { b: 3 } };\n  expect(deepGet(obj, ['a', 'b'])).toBe(3);\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepGet can return an array",
            "suites": [],
            "updatePoint": {
                "line": 16,
                "column": 33
            },
            "line": 16,
            "code": "test('deepGet can return an array', () => {\n  const obj = { a: [1, 2, 3] };\n  expect(deepGet(obj, ['a'])).toEqual([1, 2, 3]);\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "changing deepClones copy leaves the original intact",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 57
            },
            "line": 21,
            "code": "test('changing deepClones copy leaves the original intact', () => {\n  const original = { a: [{ b: 3 }] };\n  const copy = deepClone(original);\n  copy.a[0].c = 5;\n\n  expect(original).toEqual({ a: [{ b: 3 }] });\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepMerge merges objects",
            "suites": [],
            "updatePoint": {
                "line": 29,
                "column": 30
            },
            "line": 29,
            "code": "test('deepMerge merges objects', () => {\n  const original = { a: { b: 3 } };\n  deepMerge(original, { a: { c: 4 } });\n\n  expect(original).toEqual({ a: { b: 3, c: 4 } });\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepMerge overwrites non-objects",
            "suites": [],
            "updatePoint": {
                "line": 36,
                "column": 38
            },
            "line": 36,
            "code": "test('deepMerge overwrites non-objects', () => {\n  const original = { a: [] };\n  deepMerge(original, { a: { b: 3 } });\n\n  expect(original).toEqual({ a: { b: 3 } });\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "deepMerge does not overwrite if rightmost is \"undefined\"",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 62
            },
            "line": 43,
            "code": "test('deepMerge does not overwrite if rightmost is \"undefined\"', () => {\n  const original = { a: 1 };\n  deepMerge(original, { a: undefined });\n\n  expect(original).toEqual({ a: 1 });\n});",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "objects are split at the right place",
            "suites": [
                "splitBySize"
            ],
            "updatePoint": {
                "line": 51,
                "column": 44
            },
            "line": 51,
            "code": "  test('objects are split at the right place', () => {\n    fc.assert(\n      fc.property(fc.object(), fc.integer({ min: 2 }), (data, size) => {\n        const [first, second] = splitBySize(data, size);\n\n        expect(Buffer.from(JSON.stringify(first)).length).toBeLessThanOrEqual(size);\n        expect(merge(first, second)).toEqual(data);\n      }),\n    );\n\n    function merge(fst: any, snd: any) {\n      return { ...(fst ?? {}), ...(snd ?? {}) };\n    }\n  });",
            "file": "util/objects.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "continue to the next page if it exists",
            "suites": [],
            "updatePoint": {
                "line": 13,
                "column": 44
            },
            "line": 13,
            "code": "test('continue to the next page if it exists', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      expect(request.NextToken).toBe('some-token');\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n  ]);\n\n  // Printer sees them in chronological order\n  expect(printer.eventIds).toEqual(['101', '102']);\n});",
            "file": "util/stack-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not page further if we already saw the last event",
            "suites": [],
            "updatePoint": {
                "line": 34,
                "column": 58
            },
            "line": 34,
            "code": "test('do not page further if we already saw the last event', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102), event(101)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      // Did not use the token\n      expect(request.NextToken).toBeUndefined();\n      return {};\n    },\n  ]);\n\n  // Seen in chronological order\n  expect(printer.eventIds).toEqual(['101', '102']);\n});",
            "file": "util/stack-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not page further if the last event is too old",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 54
            },
            "line": 60,
            "code": "test('do not page further if the last event is too old', async () => {\n  await testMonitorWithEventCalls([\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101), event(95)],\n        NextToken: 'some-token',\n      };\n    },\n    (request) => {\n      // Start again from the top\n      expect(request.NextToken).toBeUndefined();\n      return {};\n    },\n  ]);\n\n  // Seen only the new one\n  expect(printer.eventIds).toEqual(['101']);\n});",
            "file": "util/stack-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do a final request after the monitor is stopped",
            "suites": [],
            "updatePoint": {
                "line": 80,
                "column": 53
            },
            "line": 80,
            "code": "test('do a final request after the monitor is stopped', async () => {\n  await testMonitorWithEventCalls([\n    // Before stop\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(101)],\n      };\n    },\n  ],\n  // After stop\n  [\n    (request) => {\n      expect(request.NextToken).toBeUndefined();\n      return {\n        StackEvents: [event(102), event(101)],\n      };\n    },\n  ]);\n\n  // Seen both\n  expect(printer.eventIds).toEqual(['101', '102']);\n});",
            "file": "util/stack-monitor.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "empty string",
            "suites": [
                "validate sns arns"
            ],
            "updatePoint": {
                "line": 5,
                "column": 20
            },
            "line": 5,
            "code": "  test('empty string', () => {\n    const arn = '';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });",
            "file": "util/validate-notification-arn.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "colon in topic name",
            "suites": [
                "validate sns arns"
            ],
            "updatePoint": {
                "line": 10,
                "column": 27
            },
            "line": 10,
            "code": "  test('colon in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:abc:foo';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });",
            "file": "util/validate-notification-arn.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "missing :aws: in arn",
            "suites": [
                "validate sns arns"
            ],
            "updatePoint": {
                "line": 15,
                "column": 28
            },
            "line": 15,
            "code": "  test('missing :aws: in arn', () => {\n    const arn = 'arn:sns:eu-west-1:foobar';\n    expect(validateSnsTopicArn(arn)).toEqual(false);\n  });",
            "file": "util/validate-notification-arn.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "dash in topic name",
            "suites": [
                "validate sns arns"
            ],
            "updatePoint": {
                "line": 20,
                "column": 26
            },
            "line": 20,
            "code": "  test('dash in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:123456789876:foo-bar';\n    expect(validateSnsTopicArn(arn)).toEqual(true);\n  });",
            "file": "util/validate-notification-arn.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "underscore in topic name",
            "suites": [
                "validate sns arns"
            ],
            "updatePoint": {
                "line": 25,
                "column": 32
            },
            "line": 25,
            "code": "  test('underscore in topic name', () => {\n    const arn = 'arn:aws:sns:eu-west-1:123456789876:foo-bar_baz';\n    expect(validateSnsTopicArn(arn)).toEqual(true);\n  });",
            "file": "util/validate-notification-arn.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "valid",
            "suites": [
                "rangeFromSemver",
                "bracket"
            ],
            "updatePoint": {
                "line": 6,
                "column": 15
            },
            "line": 6,
            "code": "    test('valid', () => {\n      expect(rangeFromSemver('1.2.3', 'bracket')).toEqual('1.2.3');\n      expect(rangeFromSemver('^1.2.3', 'bracket')).toEqual('[1.2.3,2.0.0)');\n    });",
            "file": "util/version-range.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "valid",
            "suites": [
                "rangeFromSemver",
                "pep"
            ],
            "updatePoint": {
                "line": 13,
                "column": 15
            },
            "line": 13,
            "code": "    test('valid', () => {\n      expect(rangeFromSemver('1.2.3', 'pep')).toEqual('==1.2.3');\n      expect(rangeFromSemver('^1.2.3', 'pep')).toEqual('>=1.2.3,<2.0.0');\n    });",
            "file": "util/version-range.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "invalid",
            "suites": [
                "rangeFromSemver",
                "pep"
            ],
            "updatePoint": {
                "line": 19,
                "column": 15
            },
            "line": 19,
            "code": "  test('invalid', () => {\n    expect(() => rangeFromSemver('1.2', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('~1.2.3', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('1.2.3-1.4.5', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('>2.4.5', 'bracket')).toThrow();\n    expect(() => rangeFromSemver('2.*', 'bracket')).toThrow();\n  });",
            "file": "util/version-range.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "initialization fails on unwritable directory",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 50
            },
            "line": 24,
            "code": "test('initialization fails on unwritable directory', () => {\n  const cacheFile = tmpfile();\n  sinon.stub(fs, 'mkdirsSync').withArgs(path.dirname(cacheFile)).throws('Cannot make directory');\n  expect(() => new VersionCheckTTL(cacheFile)).toThrow(/not writable/);\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cache file responds correctly when file is not present",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 60
            },
            "line": 30,
            "code": "test('cache file responds correctly when file is not present', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 1);\n  expect(await cache.hasExpired()).toBeTruthy();\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "cache file honours the specified TTL",
            "suites": [],
            "updatePoint": {
                "line": 35,
                "column": 42
            },
            "line": 35,
            "code": "test('cache file honours the specified TTL', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 1);\n  await cache.update();\n  expect(await cache.hasExpired()).toBeFalsy();\n  await setTimeout(1001); // Just above 1 sec in ms\n  expect(await cache.hasExpired()).toBeTruthy();\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Skip version check if cache has not expired",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 49
            },
            "line": 43,
            "code": "test('Skip version check if cache has not expired', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  await cache.update();\n  expect(await latestVersionIfHigher('0.0.0', cache)).toBeNull();\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Return later version when exists & skip recent re-check",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 61
            },
            "line": 49,
            "code": "test('Return later version when exists & skip recent re-check', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  const result = await latestVersionIfHigher('0.0.0', cache);\n  expect(result).not.toBeNull();\n  expect((result as string).length).toBeGreaterThan(0);\n\n  const result2 = await latestVersionIfHigher('0.0.0', cache);\n  expect(result2).toBeNull();\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Return null if version is higher than npm",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 47
            },
            "line": 59,
            "code": "test('Return null if version is higher than npm', async () => {\n  const cache = new VersionCheckTTL(tmpfile(), 100);\n  const result = await latestVersionIfHigher('100.100.100', cache);\n  expect(result).toBeNull();\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Version specified is stored in the TTL file",
            "suites": [],
            "updatePoint": {
                "line": 65,
                "column": 49
            },
            "line": 65,
            "code": "test('Version specified is stored in the TTL file', async () => {\n  const cacheFile = tmpfile();\n  const cache = new VersionCheckTTL(cacheFile, 1);\n  await cache.update('1.1.1');\n  const storedVersion = fs.readFileSync(cacheFile, 'utf8');\n  expect(storedVersion).toBe('1.1.1');\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "No Version specified for storage in the TTL file",
            "suites": [],
            "updatePoint": {
                "line": 73,
                "column": 54
            },
            "line": 73,
            "code": "test('No Version specified for storage in the TTL file', async () => {\n  const cacheFile = tmpfile();\n  const cache = new VersionCheckTTL(cacheFile, 1);\n  await cache.update();\n  const storedVersion = fs.readFileSync(cacheFile, 'utf8');\n  expect(storedVersion).toBe('');\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Skip version check if environment variable is set",
            "suites": [],
            "updatePoint": {
                "line": 81,
                "column": 55
            },
            "line": 81,
            "code": "test('Skip version check if environment variable is set', async () => {\n  sinon.stub(process, 'stdout').value({ ...process.stdout, isTTY: true });\n  sinon.stub(process, 'env').value({ ...process.env, CDK_DISABLE_VERSION_CHECK: '1' });\n  const printStub = sinon.stub(logging, 'print');\n  await displayVersionMessage();\n  expect(printStub.called).toEqual(false);\n});",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Prints a message when a new version is available",
            "suites": [
                "version message"
            ],
            "updatePoint": {
                "line": 99,
                "column": 56
            },
            "line": 99,
            "code": "  test('Prints a message when a new version is available', async () => {\n    // Given the current version is 1.0.0 and the latest version is 1.1.0\n    const currentVersion = '1.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('1.1.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then the new version message is printed to stdout\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('1.1.0'));\n  });",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Includes major upgrade documentation when available",
            "suites": [
                "version message"
            ],
            "updatePoint": {
                "line": 112,
                "column": 59
            },
            "line": 112,
            "code": "  test('Includes major upgrade documentation when available', async() => {\n    // Given the current version is 1.0.0 and the latest version is 2.0.0\n    const currentVersion = '1.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('2.0.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then the V1 -> V2 documentation is printed\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('Information about upgrading from version 1.x to version 2.x is available here: https://docs.aws.amazon.com/cdk/v2/guide/migrating-v2.html'));\n  });",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "Does not include major upgrade documentation when unavailable",
            "suites": [
                "version message"
            ],
            "updatePoint": {
                "line": 125,
                "column": 69
            },
            "line": 125,
            "code": "  test('Does not include major upgrade documentation when unavailable', async() => {\n    // Given current version is 99.0.0 and the latest version is 100.0.0\n    const currentVersion = '99.0.0';\n    jest.spyOn(npm, 'getLatestVersionFromNpm').mockResolvedValue('100.0.0');\n    const printSpy = jest.spyOn(logging, 'print');\n\n    // When displayVersionMessage is called\n    await displayVersionMessage(currentVersion, new VersionCheckTTL(tmpfile(), 0));\n\n    // Then no upgrade documentation is printed\n    expect(printSpy).toHaveBeenCalledWith(expect.stringContaining('100.0.0'));\n    expect(printSpy).not.toHaveBeenCalledWith(expect.stringContaining('Information about upgrading from 99.x to 100.x'));\n  });",
            "file": "version.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "quote the word \"ON\"",
            "suites": [],
            "updatePoint": {
                "line": 7,
                "column": 25
            },
            "line": 7,
            "code": "test('quote the word \"ON\"', () => {\n  // NON NEGOTIABLE! If not quoted, will be interpreted as the boolean TRUE\n\n  // eslint-disable-next-line no-console\n  const output = toYAML({\n    notABoolean: 'ON',\n  });\n\n  expect(output.trim()).toEqual(`notABoolean: ${q}ON${q}`);\n});",
            "file": "yaml.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "quote number-like strings with a leading 0",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 48
            },
            "line": 18,
            "code": "test('quote number-like strings with a leading 0', () => {\n  const output = toYAML({\n    leadingZero: '012345',\n  });\n\n  expect(output.trim()).toEqual(`leadingZero: ${q}012345${q}`);\n});",
            "file": "yaml.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "do not quote octal numbers that arent really octal",
            "suites": [],
            "updatePoint": {
                "line": 26,
                "column": 56
            },
            "line": 26,
            "code": "test('do not quote octal numbers that arent really octal', () => {\n  // This is a contentious one, and something that might have changed in YAML1.2 vs YAML1.1\n  //\n  // One could make the argument that a sequence of characters that couldn't ever\n  // be an octal value doesn't need to be quoted, and pyyaml parses it correctly.\n  //\n  // However, CloudFormation's parser interprets it as a decimal number (eating the\n  // leading 0) if it's unquoted, so that's the behavior we're testing for.\n\n  const output = toYAML({\n    leadingZero: '0123456789',\n  });\n\n  expect(output.trim()).toEqual(`leadingZero: ${q}0123456789${q}`);\n});",
            "file": "yaml.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validate that our YAML correctly emits quoted colons in a list",
            "suites": [],
            "updatePoint": {
                "line": 42,
                "column": 68
            },
            "line": 42,
            "code": "test('validate that our YAML correctly emits quoted colons in a list', () => {\n  // Must be quoted otherwise it's not valid YAML.\n  //\n  // 'yaml' fails this.\n\n  const output = toYAML({\n    colons: ['arn', ':', 'aws'],\n  });\n\n  expect(output.trim()).toEqual([\n    'colons:',\n    '  - arn',\n    `  - ${q}:${q}`,\n    '  - aws',\n  ].join('\\n'));\n});",
            "file": "yaml.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "validate emission of very long lines",
            "suites": [],
            "updatePoint": {
                "line": 59,
                "column": 42
            },
            "line": 59,
            "code": "test('validate emission of very long lines', () => {\n  const template = {\n    Field: ' very long line that starts with a space. very long line that starts with a space. start on a new line',\n  };\n\n  const output = toYAML(template);\n\n  const parsed = deserializeStructure(output);\n\n  expect(template).toEqual(parsed);\n});",
            "file": "yaml.test.ts",
            "skipped": false,
            "dir": "packages/aws-cdk/test"
        },
        {
            "name": "zipDirectory can take a directory and produce a zip from it",
            "suites": [],
            "updatePoint": {
                "line": 18,
                "column": 65
            },
            "line": 18,
            "code": "test('zipDirectory can take a directory and produce a zip from it', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.extract'));\n  try {\n    const zipFile = path.join(stagingDir, 'output.zip');\n    const originalDir = path.join(__dirname, 'test-archive');\n    await zipDirectory(originalDir, zipFile, logger);\n\n    // unzip and verify that the resulting tree is the same\n    await exec(`unzip ${zipFile}`, { cwd: extractDir });\n\n    await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeTruthy();\n\n    // inspect the zip file to check that dates are reset\n    const zip = await fs.readFile(zipFile);\n    const zipData = await jszip.loadAsync(zip);\n    const dates = Object.values(zipData.files).map(file => file.date.toISOString());\n    expect(dates[0]).toBe('1980-01-01T00:00:00.000Z');\n    expect(new Set(dates).size).toBe(1);\n\n    // check that mode is preserved\n    const stat = await fs.stat(path.join(extractDir, 'executable.txt'));\n    // eslint-disable-next-line no-bitwise\n    const isExec = (stat.mode & constants.S_IXUSR) || (stat.mode & constants.S_IXGRP) || (stat.mode & constants.S_IXOTH);\n    expect(isExec).toBeTruthy();\n  } finally {\n    rmRfSync(stagingDir);\n    rmRfSync(extractDir);\n  }\n});",
            "file": "archive.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "md5 hash of a zip stays consistent across invocations",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 59
            },
            "line": 49,
            "code": "test('md5 hash of a zip stays consistent across invocations', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const zipFile1 = path.join(stagingDir, 'output.zip');\n  const zipFile2 = path.join(stagingDir, 'output.zip');\n  const originalDir = path.join(__dirname, 'test-archive');\n  await zipDirectory(originalDir, zipFile1, logger);\n  await new Promise(ok => setTimeout(ok, 2000)); // wait 2s\n  await zipDirectory(originalDir, zipFile2, logger);\n\n  const hash1 = contentHash(await fs.readFile(zipFile1));\n  const hash2 = contentHash(await fs.readFile(zipFile2));\n\n  expect(hash1).toEqual(hash2);\n});",
            "file": "archive.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "zipDirectory follows symlinks",
            "suites": [],
            "updatePoint": {
                "line": 64,
                "column": 35
            },
            "line": 64,
            "code": "test('zipDirectory follows symlinks', async () => {\n  const stagingDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive'));\n  const extractDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test.archive.follow'));\n  try {\n    // First MAKE the symlink we're going to follow. We can't check it into git, because\n    // CodeBuild/CodePipeline (I forget which) is going to replace symlinks with a textual\n    // representation of its target upon checkout, for security reasons. So, to make sure\n    // the symlink exists, we need to create it at build time.\n    const symlinkPath = path.join(__dirname, 'test-archive-follow', 'data', 'linked');\n    const symlinkTarget = '../linked';\n\n    if (await pathExists(symlinkPath)) {\n      await fs.unlink(symlinkPath);\n    }\n    await fs.symlink(symlinkTarget, symlinkPath, 'dir');\n\n    const originalDir = path.join(__dirname, 'test-archive-follow', 'data');\n    const zipFile = path.join(stagingDir, 'output.zip');\n\n    await expect(zipDirectory(originalDir, zipFile, logger)).resolves.toBeUndefined();\n    await expect(exec(`unzip ${zipFile}`, { cwd: extractDir })).resolves.toBeDefined();\n    await expect(exec(`diff -bur ${originalDir} ${extractDir}`)).resolves.toBeDefined();\n  } finally {\n    rmRfSync(stagingDir);\n    rmRfSync(extractDir);\n  }\n});",
            "file": "archive.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "pass destination properties to AWS client",
            "suites": [],
            "updatePoint": {
                "line": 219,
                "column": 47
            },
            "line": 219,
            "code": "test('pass destination properties to AWS client', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n\n  await pub.publish();\n\n  expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'us-north-50',\n    assumeRoleArn: 'arn:aws:role',\n  }));\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Do nothing if docker image already exists",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 236,
                "column": 49
            },
            "line": 236,
            "code": "  test('Do nothing if docker image already exists', async () => {\n    aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n\n    await pub.publish();\n\n    expect(aws.mockEcr.describeImages).toHaveBeenCalledWith(expect.objectContaining({\n      imageIds: [{ imageTag: 'abcdef' }],\n      repositoryName: 'repo',\n    }));\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Displays an error if the ECR repository cannot be found",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 247,
                "column": 63
            },
            "line": 247,
            "code": "  test('Displays an error if the ECR repository cannot be found', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('RepositoryNotFoundException', 'Repository not Found');\n\n    await expect(pub.publish()).rejects.toThrow('Error building and publishing: Repository not Found');\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "successful run does not need to query account ID",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 253,
                "column": 56
            },
            "line": 253,
            "code": "  test('successful run does not need to query account ID', async () => {\n    aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n    await pub.publish();\n    expect(aws.discoverCurrentAccount).not.toHaveBeenCalled();\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload docker image if not uploaded yet but exists locally",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 259,
                "column": 66
            },
            "line": 259,
            "code": "  test('upload docker image if not uploaded yet but exists locally', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'] },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build and upload docker image if not exists anywhere",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 280,
                "column": 60
            },
            "line": 280,
            "code": "  test('build and upload docker image if not exists anywhere', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build with networkMode option",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 302,
                "column": 37
            },
            "line": 302,
            "code": "  test('build with networkMode option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/default-network/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/default-network/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--network', 'default', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build with platform option",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 326,
                "column": 34
            },
            "line": 326,
            "code": "  test('build with platform option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/platform-arm64/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/platform-arm64/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--platform', 'linux/arm64', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build with cache option",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 350,
                "column": 31
            },
            "line": 350,
            "code": "  test('build with cache option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--cache-from', 'type=registry,ref=abcdef', '--cache-to', 'type=inline', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build with multiple cache from option",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 374,
                "column": 45
            },
            "line": 374,
            "code": "  test('build with multiple cache from option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache-from-multiple/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache-from-multiple/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      {\n        commandLine: [\n          'docker', 'build', '--tag', 'cdkasset-theasset', '--cache-from', 'type=registry,ref=cache:ref', '--cache-from', 'type=registry,ref=cache:main', '--cache-from', 'type=gha', '.',\n        ],\n        cwd: defaultNetworkDockerpath,\n      },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "build with cache to complex option",
            "suites": [
                "with a complete manifest"
            ],
            "updatePoint": {
                "line": 403,
                "column": 42
            },
            "line": 403,
            "code": "  test('build with cache to complex option', async () => {\n    pub = new AssetPublishing(AssetManifest.fromPath('/cache-to-complex/cdk.out'), { aws });\n    const defaultNetworkDockerpath = '/cache-to-complex/cdk.out/dockerdir';\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['docker', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n      { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '--cache-to', 'type=registry,ref=cache:main,mode=max,compression=zstd', '.'], cwd: defaultNetworkDockerpath },\n      { commandLine: ['docker', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:nopqr'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:nopqr'] },\n    );\n\n    await pub.publish();\n\n    expectAllSpawns();\n    expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload externally generated Docker image",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 435,
                "column": 48
            },
            "line": 435,
            "code": "  test('upload externally generated Docker image', async () => {\n    aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n    aws.mockEcr.getAuthorizationToken = mockedApiResult({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n      ],\n    });\n\n    const expectAllSpawns = mockSpawn(\n      { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n      { commandLine: ['sometool'], stdout: externalTag, cwd: '/external/cdk.out' },\n      { commandLine: ['docker', 'tag', externalTag, '12345.amazonaws.com/repo:ghijkl'] },\n      { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:ghijkl'] },\n    );\n\n    await pub.publish();\n\n    expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n      region: 'us-north-50',\n      assumeRoleArn: 'arn:aws:role',\n    }));\n    expectAllSpawns();\n  });",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "correctly identify Docker directory if path is absolute",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 460,
                "column": 61
            },
            "line": 460,
            "code": "test('correctly identify Docker directory if path is absolute', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/abs/cdk.out'), { aws });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    // Only care about the 'build' command line\n    { commandLine: ['docker', 'login'], prefix: true },\n    { commandLine: ['docker', 'inspect'], exitCode: 1, prefix: true },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n    { commandLine: ['docker', 'tag'], prefix: true },\n    { commandLine: ['docker', 'push'], prefix: true },\n  );\n\n  await pub.publish();\n\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n  expectAllSpawns();\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "when external credentials are present, explicit Docker config directories are used",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 485,
                "column": 88
            },
            "line": 485,
            "code": "test('when external credentials are present, explicit Docker config directories are used', async () => {\n  // Setup -- Mock that we have CDK credentials, and mock fs operations.\n  jest.spyOn(dockercreds, 'cdkCredentialsConfig').mockReturnValue({ version: '0.1', domainCredentials: {} });\n  jest.spyOn(fs, 'mkdtempSync').mockImplementationOnce(() => '/tmp/mockedTempDir');\n  jest.spyOn(fs, 'writeFileSync').mockImplementation(jest.fn());\n\n  let pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    // Initally use the first created directory with the CDK credentials\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'inspect', 'cdkasset-theasset'], exitCode: 1 },\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'build', '--tag', 'cdkasset-theasset', '.'], cwd: absoluteDockerPath },\n    { commandLine: ['docker', '--config', '/tmp/mockedTempDir', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n    // Prior to push, revert to the default config directory\n    { commandLine: ['docker', 'login'], prefix: true },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:abcdef'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "logging in only once for two assets",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 514,
                "column": 41
            },
            "line": 514,
            "code": "test('logging in only once for two assets', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), { aws, throwOnError: false });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12345.amazonaws.com/repo:theAsset2'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/repo:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "logging in twice for two repository domains (containing account id & region)",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 541,
                "column": 82
            },
            "line": 541,
            "code": "test('logging in twice for two repository domains (containing account id & region)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), { aws, throwOnError: false });\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n\n  let repoIdx = 12345;\n  aws.mockEcr.describeRepositories = jest.fn().mockReturnValue({\n    promise: jest.fn().mockImplementation(() => Promise.resolve({\n      repositories: [\n        // Usually looks like: 012345678910.dkr.ecr.us-west-2.amazonaws.com/aws-cdk/assets\n        { repositoryUri: `${repoIdx++}.amazonaws.com/aws-cdk/assets` },\n      ],\n    })),\n  });\n\n  let proxyIdx = 12345;\n  aws.mockEcr.getAuthorizationToken = jest.fn().mockReturnValue({\n    promise: jest.fn().mockImplementation(() => Promise.resolve({\n      authorizationData: [\n        { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: `https://${proxyIdx++}.proxy.com/` },\n      ],\n    })),\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://12345.proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://12346.proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12346.amazonaws.com/aws-cdk/assets:theAsset2'] },\n    { commandLine: ['docker', 'push', '12346.amazonaws.com/aws-cdk/assets:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "building only",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 583,
                "column": 19
            },
            "line": 583,
            "code": "test('building only', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), {\n    aws,\n    throwOnError: false,\n    buildAssets: true,\n    publishAssets: false,\n  });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset1'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset1', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset1', '12345.amazonaws.com/repo:theAsset1'] },\n    { commandLine: ['docker', 'inspect', 'cdkasset-theasset2'], exitCode: 1 },\n    { commandLine: ['docker', 'build', '--tag', 'cdkasset-theasset2', '.'], cwd: '/multi/cdk.out/dockerdir' },\n    { commandLine: ['docker', 'tag', 'cdkasset-theasset2', '12345.amazonaws.com/repo:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "publishing only",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 614,
                "column": 21
            },
            "line": 614,
            "code": "test('publishing only', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/multi/cdk.out'), {\n    aws,\n    throwOnError: false,\n    buildAssets: false,\n    publishAssets: true,\n  });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['docker', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset1'] },\n    { commandLine: ['docker', 'push', '12345.amazonaws.com/aws-cdk/assets:theAsset2'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "overriding the docker command",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 641,
                "column": 35
            },
            "line": 641,
            "code": "test('overriding the docker command', async () => {\n  process.env.CDK_DOCKER = 'custom';\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n\n  aws.mockEcr.describeImages = mockedApiFailure('ImageNotFoundException', 'File does not exist');\n  aws.mockEcr.getAuthorizationToken = mockedApiResult({\n    authorizationData: [\n      { authorizationToken: 'dXNlcjpwYXNz', proxyEndpoint: 'https://proxy.com/' },\n    ],\n  });\n\n  const expectAllSpawns = mockSpawn(\n    { commandLine: ['custom', 'login', '--username', 'user', '--password-stdin', 'https://proxy.com/'] },\n    { commandLine: ['custom', 'inspect', 'cdkasset-theasset'] },\n    { commandLine: ['custom', 'tag', 'cdkasset-theasset', '12345.amazonaws.com/repo:abcdef'] },\n    { commandLine: ['custom', 'push', '12345.amazonaws.com/repo:abcdef'] },\n  );\n\n  await pub.publish();\n\n  expectAllSpawns();\n  expect(true).toBeTruthy(); // Expect no exception, satisfy linter\n});",
            "file": "docker-images.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "pass destination properties to AWS client",
            "suites": [],
            "updatePoint": {
                "line": 100,
                "column": 47
            },
            "line": 100,
            "code": "test('pass destination properties to AWS client', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, throwOnError: false });\n  aws.mockS3.listObjectsV2 = mockedApiResult({});\n\n  await pub.publish();\n\n  expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'us-north-50',\n    assumeRoleArn: 'arn:aws:role',\n  }));\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Do nothing if file already exists",
            "suites": [],
            "updatePoint": {
                "line": 112,
                "column": 39
            },
            "line": 112,
            "code": "test('Do nothing if file already exists', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key' }] });\n  aws.mockS3.upload = mockUpload();\n  await pub.publish();\n\n  expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Prefix: 'some_key',\n    MaxKeys: 1,\n  }));\n  expect(aws.mockS3.upload).not.toHaveBeenCalled();\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "tiny file does not count as cache hit",
            "suites": [],
            "updatePoint": {
                "line": 127,
                "column": 43
            },
            "line": 127,
            "code": "test('tiny file does not count as cache hit', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key', Size: 5 }] });\n  aws.mockS3.upload = mockUpload();\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalled();\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload file if new (list returns other key)",
            "suites": [],
            "updatePoint": {
                "line": 139,
                "column": 49
            },
            "line": 139,
            "code": "test('upload file if new (list returns other key)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n  }));\n\n  // We'll just have to assume the contents are correct\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload with server side encryption AES256 header",
            "suites": [],
            "updatePoint": {
                "line": 156,
                "column": 54
            },
            "line": 156,
            "code": "test('upload with server side encryption AES256 header', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.getBucketEncryption = mockedApiResult({\n    ServerSideEncryptionConfiguration: {\n      Rules: [\n        {\n          ApplyServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'AES256',\n          },\n          BucketKeyEnabled: false,\n        },\n      ],\n    },\n  });\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n    ServerSideEncryption: 'AES256',\n  }));\n\n  // We'll just have to assume the contents are correct\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload with server side encryption aws:kms header and key id",
            "suites": [],
            "updatePoint": {
                "line": 186,
                "column": 66
            },
            "line": 186,
            "code": "test('upload with server side encryption aws:kms header and key id', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.getBucketEncryption = mockedApiResult({\n    ServerSideEncryptionConfiguration: {\n      Rules: [\n        {\n          ApplyServerSideEncryptionByDefault: {\n            SSEAlgorithm: 'aws:kms',\n            KMSMasterKeyID: 'the-key-id',\n          },\n          BucketKeyEnabled: false,\n        },\n      ],\n    },\n  });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/octet-stream',\n    ServerSideEncryption: 'aws:kms',\n    SSEKMSKeyId: 'the-key-id',\n  }));\n\n  // We'll just have to assume the contents are correct\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "will only read bucketEncryption once even for multiple assets",
            "suites": [],
            "updatePoint": {
                "line": 219,
                "column": 67
            },
            "line": 219,
            "code": "test('will only read bucketEncryption once even for multiple assets', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/types/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledTimes(2);\n  expect(aws.mockS3.getBucketEncryption).toHaveBeenCalledTimes(1);\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "no server side encryption header if access denied for bucket encryption",
            "suites": [],
            "updatePoint": {
                "line": 231,
                "column": 77
            },
            "line": 231,
            "code": "test('no server side encryption header if access denied for bucket encryption', async () => {\n  const progressListener = new FakeListener();\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n\n  aws.mockS3.getBucketEncryption = mockedApiFailure('AccessDenied', 'Access Denied');\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.not.objectContaining({\n    ServerSideEncryption: 'aws:kms',\n  }));\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.not.objectContaining({\n    ServerSideEncryption: 'AES256',\n  }));\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "correctly looks up content type",
            "suites": [],
            "updatePoint": {
                "line": 251,
                "column": 37
            },
            "line": 251,
            "code": "test('correctly looks up content type', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/types/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key.but_not_the_one' }] });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key.txt',\n    ContentType: 'text/plain',\n  }));\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key.png',\n    ContentType: 'image/png',\n  }));\n\n  // We'll just have to assume the contents are correct\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload file if new (list returns no key)",
            "suites": [],
            "updatePoint": {
                "line": 274,
                "column": 46
            },
            "line": 274,
            "code": "test('upload file if new (list returns no key)', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n  }));\n\n  // We'll just have to assume the contents are correct\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "successful run does not need to query account ID",
            "suites": [],
            "updatePoint": {
                "line": 290,
                "column": 54
            },
            "line": 290,
            "code": "test('successful run does not need to query account ID', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(aws.discoverCurrentAccount).not.toHaveBeenCalled();\n  expect(aws.discoverTargetAccount).not.toHaveBeenCalled();\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "correctly identify asset path if path is absolute",
            "suites": [],
            "updatePoint": {
                "line": 302,
                "column": 55
            },
            "line": 302,
            "code": "test('correctly identify asset path if path is absolute', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/abs/cdk.out'), { aws });\n\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n  aws.mockS3.upload = mockUpload('FILE_CONTENTS');\n\n  await pub.publish();\n\n  expect(true).toBeTruthy(); // No exception, satisfy linter\n});",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "do nothing if file exists already",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 319,
                "column": 41
            },
            "line": 319,
            "code": "  test('do nothing if file exists already', async () => {\n    aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key' }] });\n\n    await pub.publish();\n\n    expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n      Bucket: 'some_external_bucket',\n      Prefix: 'some_key',\n      MaxKeys: 1,\n    }));\n  });",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "upload external asset correctly",
            "suites": [
                "external assets"
            ],
            "updatePoint": {
                "line": 331,
                "column": 39
            },
            "line": 331,
            "code": "  test('upload external asset correctly', async () => {\n    aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: undefined });\n    aws.mockS3.upload = mockUpload('ZIP_FILE_THAT_IS_DEFINITELY_NOT_EMPTY');\n    const expectAllSpawns = mockSpawn({ commandLine: ['sometool'], stdout: ABS_PATH });\n\n    await pub.publish();\n\n    expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n      region: 'us-north-50',\n      assumeRoleArn: 'arn:aws:role',\n    }));\n\n    expectAllSpawns();\n  });",
            "file": "files.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Can list manifest",
            "suites": [],
            "updatePoint": {
                "line": 37,
                "column": 23
            },
            "line": 37,
            "code": "test('Can list manifest', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n  expect(manifest.list().join('\\n')).toEqual(`\nasset1 file {\\\"path\\\":\\\"S1\\\"}\n  ├ asset1:dest1 {\\\"bucketName\\\":\\\"D1\\\",\\\"objectKey\\\":\\\"X\\\"}\n  └ asset1:dest2 {\\\"bucketName\\\":\\\"D2\\\",\\\"objectKey\\\":\\\"X\\\"}\nasset2 docker-image {\\\"directory\\\":\\\"S2\\\"}\n  ├ asset2:dest1 {\\\"repositoryName\\\":\\\"D3\\\",\\\"imageTag\\\":\\\"X\\\"}\n  └ asset2:dest2 {\\\"repositoryName\\\":\\\"D4\\\",\\\"imageTag\\\":\\\"X\\\"}\n`.trim());\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": ".entries() iterates over all destinations",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 47
            },
            "line": 49,
            "code": "test('.entries() iterates over all destinations', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  expect(manifest.entries).toEqual([\n    new FileManifestEntry(new DestinationIdentifier('asset1', 'dest1'), { path: 'S1' }, { bucketName: 'D1', objectKey: 'X' }),\n    new FileManifestEntry(new DestinationIdentifier('asset1', 'dest2'), { path: 'S1' }, { bucketName: 'D2', objectKey: 'X' }),\n    new DockerImageManifestEntry(new DestinationIdentifier('asset2', 'dest1'), { directory: 'S2' }, { repositoryName: 'D3', imageTag: 'X' }),\n    new DockerImageManifestEntry(new DestinationIdentifier('asset2', 'dest2'), { directory: 'S2' }, { repositoryName: 'D4', imageTag: 'X' }),\n  ]);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "can select by asset ID",
            "suites": [],
            "updatePoint": {
                "line": 60,
                "column": 28
            },
            "line": 60,
            "code": "test('can select by asset ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([DestinationPattern.parse('asset2')]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName'))).toEqual(['D3', 'D4']);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "can select by asset ID + destination ID",
            "suites": [],
            "updatePoint": {
                "line": 68,
                "column": 45
            },
            "line": 68,
            "code": "test('can select by asset ID + destination ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([\n    DestinationPattern.parse('asset1:dest1'),\n    DestinationPattern.parse('asset2:dest2'),\n  ]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName', 'bucketName'))).toEqual(['D1', 'D4']);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "can select by destination ID",
            "suites": [],
            "updatePoint": {
                "line": 79,
                "column": 34
            },
            "line": 79,
            "code": "test('can select by destination ID', () => {\n  const manifest = AssetManifest.fromPath('/simple/cdk.out');\n\n  const subset = manifest.select([\n    DestinationPattern.parse(':dest1'),\n  ]);\n\n  expect(subset.entries.map(e => f(e.genericDestination, 'repositoryName', 'bucketName'))).toEqual(['D1', 'D3']);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "empty string is not a valid pattern",
            "suites": [],
            "updatePoint": {
                "line": 89,
                "column": 41
            },
            "line": 89,
            "code": "test('empty string is not a valid pattern', () => {\n  expect(() => {\n    DestinationPattern.parse('');\n  }).toThrow(/Empty string is not a valid destination identifier/);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "pattern must have two components",
            "suites": [],
            "updatePoint": {
                "line": 95,
                "column": 38
            },
            "line": 95,
            "code": "test('pattern must have two components', () => {\n  expect(() => {\n    DestinationPattern.parse('a:b:c');\n  }).toThrow(/Asset identifier must contain at most 2/);\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "parse ASSET:* the same as ASSET and ASSET:",
            "suites": [],
            "updatePoint": {
                "line": 101,
                "column": 48
            },
            "line": 101,
            "code": "test('parse ASSET:* the same as ASSET and ASSET:', () => {\n  expect(DestinationPattern.parse('a:*')).toEqual(DestinationPattern.parse('a'));\n  expect(DestinationPattern.parse('a:*')).toEqual(DestinationPattern.parse('a:'));\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "parse *:DEST the same as :DEST",
            "suites": [],
            "updatePoint": {
                "line": 106,
                "column": 36
            },
            "line": 106,
            "code": "test('parse *:DEST the same as :DEST', () => {\n  expect(DestinationPattern.parse('*:a')).toEqual(DestinationPattern.parse(':a'));\n});",
            "file": "manifest.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "check that placeholders are replaced",
            "suites": [],
            "updatePoint": {
                "line": 55,
                "column": 42
            },
            "line": 55,
            "code": "test('check that placeholders are replaced', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws });\n  aws.mockS3.getBucketLocation = mockedApiResult({});\n  aws.mockS3.listObjectsV2 = mockedApiResult({ Contents: [{ Key: 'some_key-current_account-current_region' }] });\n  aws.mockEcr.describeImages = mockedApiResult({ /* No error == image exists */ });\n\n  await pub.publish();\n\n  expect(aws.s3Client).toHaveBeenCalledWith(expect.objectContaining({\n    assumeRoleArn: 'arn:aws:role-current_account',\n  }));\n\n  expect(aws.ecrClient).toHaveBeenCalledWith(expect.objectContaining({\n    region: 'explicit_region',\n    assumeRoleArn: 'arn:aws:role-current_account',\n  }));\n\n  expect(aws.mockS3.listObjectsV2).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket-current_account-current_region',\n    Prefix: 'some_key-current_account-current_region',\n    MaxKeys: 1,\n  }));\n\n  expect(aws.mockEcr.describeImages).toHaveBeenCalledWith(expect.objectContaining({\n    imageIds: [{ imageTag: 'abcdef' }],\n    repositoryName: 'repo-current_account-explicit_region',\n  }));\n});",
            "file": "placeholders.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Can be overridden by CDK_DOCKER_CREDS_FILE",
            "suites": [
                "cdkCredentialsConfigFile"
            ],
            "updatePoint": {
                "line": 25,
                "column": 50
            },
            "line": 25,
            "code": "  test('Can be overridden by CDK_DOCKER_CREDS_FILE', () => {\n    const credsFile = '/tmp/insertfilenamehere_cdk_config.json';\n    process.env.CDK_DOCKER_CREDS_FILE = credsFile;\n\n    expect(cdkCredentialsConfigFile()).toEqual(credsFile);\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Uses homedir if no process env is set",
            "suites": [
                "cdkCredentialsConfigFile"
            ],
            "updatePoint": {
                "line": 32,
                "column": 45
            },
            "line": 32,
            "code": "  test('Uses homedir if no process env is set', () => {\n    expect(cdkCredentialsConfigFile()).toEqual(path.join(os.userInfo().homedir, '.cdk', 'cdk-docker-creds.json'));\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns undefined if no config exists",
            "suites": [
                "cdkCredentialsConfig"
            ],
            "updatePoint": {
                "line": 41,
                "column": 45
            },
            "line": 41,
            "code": "  test('returns undefined if no config exists', () => {\n    expect(cdkCredentialsConfig()).toBeUndefined();\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns parsed config if it exists",
            "suites": [
                "cdkCredentialsConfig"
            ],
            "updatePoint": {
                "line": 45,
                "column": 42
            },
            "line": 45,
            "code": "  test('returns parsed config if it exists', () => {\n    mockfs({\n      [credsFile]: JSON.stringify({\n        version: '0.1',\n        domainCredentials: {\n          'test1.example.com': { secretsManagerSecretId: 'mySecret' },\n          'test2.example.com': { ecrRepository: 'arn:aws:ecr:bar' },\n        },\n      }),\n    });\n\n    const config = cdkCredentialsConfig();\n    expect(config).toBeDefined();\n    expect(config?.version).toEqual('0.1');\n    expect(config?.domainCredentials['test1.example.com']?.secretsManagerSecretId).toEqual('mySecret');\n    expect(config?.domainCredentials['test2.example.com']?.ecrRepository).toEqual('arn:aws:ecr:bar');\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws on unknown domain",
            "suites": [
                "fetchDockerLoginCredentials"
            ],
            "updatePoint": {
                "line": 92,
                "column": 32
            },
            "line": 92,
            "code": "  test('throws on unknown domain', async () => {\n    await expect(fetchDockerLoginCredentials(aws, config, 'unknowndomain.example.com')).rejects.toThrow(/unknown domain/);\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws on misconfigured domain (no ECR or SM)",
            "suites": [
                "fetchDockerLoginCredentials"
            ],
            "updatePoint": {
                "line": 96,
                "column": 53
            },
            "line": 96,
            "code": "  test('throws on misconfigured domain (no ECR or SM)', async () => {\n    await expect(fetchDockerLoginCredentials(aws, config, 'misconfigured.example.com')).rejects.toThrow(/unknown credential type/);\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "does not throw on correctly configured raw domain",
            "suites": [
                "fetchDockerLoginCredentials"
            ],
            "updatePoint": {
                "line": 100,
                "column": 57
            },
            "line": 100,
            "code": "  test('does not throw on correctly configured raw domain', async () => {\n    mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n    await expect(fetchDockerLoginCredentials(aws, config, 'https://secret.example.com/v1/')).resolves.toBeTruthy();\n  });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns the credentials sucessfully if configured correctly - domain",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 107,
                "column": 78
            },
            "line": 107,
            "code": "    test('returns the credentials sucessfully if configured correctly - domain', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secret.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns the credentials successfully if configured correctly - raw domain",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 115,
                "column": 83
            },
            "line": 115,
            "code": "    test('returns the credentials successfully if configured correctly - raw domain', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'https://secret.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws when SecretsManager returns an error",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 123,
                "column": 53
            },
            "line": 123,
            "code": "    test('throws when SecretsManager returns an error', async () => {\n      const errMessage = \"Secrets Manager can't find the specified secret.\";\n      aws.mockSecretsManager.getSecretValue = mockedApiFailure('ResourceNotFoundException', errMessage);\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(errMessage);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "supports assuming a role",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 130,
                "column": 34
            },
            "line": 130,
            "code": "    test('supports assuming a role', async () => {\n      mockSecretWithSecretString({ username: 'secretUser', secret: 'secretPass' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secretwithrole.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: 'secretPass' });\n      expect(aws.secretsManagerClient).toHaveBeenCalledWith({ assumeRoleArn: 'arn:aws:iam::0123456789012:role/my-role' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "supports configuring the secret fields",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 139,
                "column": 48
            },
            "line": 139,
            "code": "    test('supports configuring the secret fields', async () => {\n      mockSecretWithSecretString({ name: 'secretUser', apiKey: '01234567' });\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'secretwithcustomfields.example.com');\n\n      expect(creds).toEqual({ Username: 'secretUser', Secret: '01234567' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws when secret does not have the correct fields - key/value",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 147,
                "column": 73
            },
            "line": 147,
            "code": "    test('throws when secret does not have the correct fields - key/value', async () => {\n      mockSecretWithSecretString({ principal: 'foo', credential: 'bar' });\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(/malformed secret string/);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws when secret does not have the correct fields - plaintext",
            "suites": [
                "fetchDockerLoginCredentials",
                "SecretsManager"
            ],
            "updatePoint": {
                "line": 153,
                "column": 73
            },
            "line": 153,
            "code": "    test('throws when secret does not have the correct fields - plaintext', async () => {\n      mockSecretWithSecretString('myAPIKey');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'secret.example.com')).rejects.toThrow(/malformed secret string/);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns the credentials successfully",
            "suites": [
                "fetchDockerLoginCredentials",
                "ECR getAuthorizationToken"
            ],
            "updatePoint": {
                "line": 161,
                "column": 46
            },
            "line": 161,
            "code": "    test('returns the credentials successfully', async () => {\n      mockEcrAuthorizationData(Buffer.from('myFoo:myBar', 'utf-8').toString('base64'));\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'ecr.example.com');\n\n      expect(creds).toEqual({ Username: 'myFoo', Secret: 'myBar' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws if ECR errors",
            "suites": [
                "fetchDockerLoginCredentials",
                "ECR getAuthorizationToken"
            ],
            "updatePoint": {
                "line": 169,
                "column": 30
            },
            "line": 169,
            "code": "    test('throws if ECR errors', async () => {\n      aws.mockEcr.getAuthorizationToken = mockedApiFailure('ServerException', 'uhoh');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/uhoh/);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "supports assuming a role",
            "suites": [
                "fetchDockerLoginCredentials",
                "ECR getAuthorizationToken"
            ],
            "updatePoint": {
                "line": 175,
                "column": 34
            },
            "line": 175,
            "code": "    test('supports assuming a role', async () => {\n      mockEcrAuthorizationData(Buffer.from('myFoo:myBar', 'utf-8').toString('base64'));\n\n      const creds = await fetchDockerLoginCredentials(aws, config, 'ecrwithrole.example.com');\n\n      expect(creds).toEqual({ Username: 'myFoo', Secret: 'myBar' });\n      expect(aws.ecrClient).toHaveBeenCalledWith({ assumeRoleArn: 'arn:aws:iam::0123456789012:role/my-role' });\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws if ECR returns no authData",
            "suites": [
                "fetchDockerLoginCredentials",
                "ECR getAuthorizationToken"
            ],
            "updatePoint": {
                "line": 184,
                "column": 43
            },
            "line": 184,
            "code": "    test('throws if ECR returns no authData', async () => {\n      aws.mockEcr.getAuthorizationToken = mockedApiResult({ authorizationData: [] });\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/No authorization data received from ECR/);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws if ECR authData is in an incorrect format",
            "suites": [
                "fetchDockerLoginCredentials",
                "ECR getAuthorizationToken"
            ],
            "updatePoint": {
                "line": 190,
                "column": 58
            },
            "line": 190,
            "code": "    test('throws if ECR authData is in an incorrect format', async () => {\n      mockEcrAuthorizationData('notabase64encodedstring');\n\n      await expect(fetchDockerLoginCredentials(aws, config, 'ecr.example.com')).rejects.toThrow(/unexpected ECR authData format/);\n    });",
            "file": "private/docker-credentials.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns true when image inspect command does not throw",
            "suites": [
                "Docker",
                "exists"
            ],
            "updatePoint": {
                "line": 25,
                "column": 64
            },
            "line": 25,
            "code": "    test('returns true when image inspect command does not throw', async () => {\n      const spy = makeShellExecuteMock(() => undefined);\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(true);\n      expect(spy.mock.calls[0][0]).toEqual(['inspect', 'foo']);\n    });",
            "file": "private/docker.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws when an arbitrary error is caught",
            "suites": [
                "Docker",
                "exists"
            ],
            "updatePoint": {
                "line": 34,
                "column": 50
            },
            "line": 34,
            "code": "    test('throws when an arbitrary error is caught', async () => {\n      makeShellExecuteMock(() => {\n        throw new Error();\n      });\n\n      await expect(docker.exists('foo')).rejects.toThrow();\n    });",
            "file": "private/docker.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "throws when the error is a shell failure but the exit code is unrecognized",
            "suites": [
                "Docker",
                "exists"
            ],
            "updatePoint": {
                "line": 42,
                "column": 84
            },
            "line": 42,
            "code": "    test('throws when the error is a shell failure but the exit code is unrecognized', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 47\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      await expect(docker.exists('foo')).rejects.toThrow();\n    });",
            "file": "private/docker.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns false when the error is a shell failure and the exit code is 1 (Docker)",
            "suites": [
                "Docker",
                "exists"
            ],
            "updatePoint": {
                "line": 58,
                "column": 89
            },
            "line": 58,
            "code": "    test('returns false when the error is a shell failure and the exit code is 1 (Docker)', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 1\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(false);\n    });",
            "file": "private/docker.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "returns false when the error is a shell failure and the exit code is 125 (Podman)",
            "suites": [
                "Docker",
                "exists"
            ],
            "updatePoint": {
                "line": 76,
                "column": 91
            },
            "line": 76,
            "code": "    test('returns false when the error is a shell failure and the exit code is 125 (Podman)', async () => {\n      makeShellExecuteMock(() => {\n        throw new (class extends Error implements ProcessFailedError {\n          public readonly code = 'PROCESS_FAILED'\n          public readonly exitCode = 125\n          public readonly signal = null\n\n          constructor() {\n            super('foo');\n          }\n        });\n      });\n\n      const imageExists = await docker.exists('foo');\n\n      expect(imageExists).toBe(false);\n    });",
            "file": "private/docker.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "test listener",
            "suites": [],
            "updatePoint": {
                "line": 49,
                "column": 19
            },
            "line": 49,
            "code": "test('test listener', async () => {\n  const progressListener = new FakeListener();\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // Log mentions asset/destination ids\n  expect(allMessages).toContain('theAsset:theDestination1');\n  expect(allMessages).toContain('theAsset:theDestination2');\n});",
            "file": "progress.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "test publishing in parallel",
            "suites": [],
            "updatePoint": {
                "line": 62,
                "column": 33
            },
            "line": 62,
            "code": "test('test publishing in parallel', async () => {\n  const progressListener = new FakeListener();\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener, publishInParallel: true });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // Log mentions asset/destination ids\n  expect(allMessages).toContain('theAsset:theDestination1');\n  expect(allMessages).toContain('theAsset:theDestination2');\n});",
            "file": "progress.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "test abort",
            "suites": [],
            "updatePoint": {
                "line": 75,
                "column": 16
            },
            "line": 75,
            "code": "test('test abort', async () => {\n  const progressListener = new FakeListener(true);\n\n  const pub = new AssetPublishing(AssetManifest.fromPath('/simple/cdk.out'), { aws, progressListener });\n  await pub.publish();\n\n  const allMessages = progressListener.messages.join('\\n');\n\n  // We never get to asset 2\n  expect(allMessages).not.toContain('theAsset:theDestination2');\n});",
            "file": "progress.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "critical section",
            "suites": [],
            "updatePoint": {
                "line": 3,
                "column": 22
            },
            "line": 3,
            "code": "test('critical section', async () => {\n  // GIVEN\n  const criticalSection = createCriticalSection();\n\n  // WHEN\n  const arr = new Array<string>();\n  void criticalSection(async () => {\n    await new Promise(res => setTimeout(res, 500));\n    arr.push('first');\n  });\n  await criticalSection(async () => {\n    arr.push('second');\n  });\n\n  // THEN\n  expect(arr).toEqual([\n    'first',\n    'second',\n  ]);\n});",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "exceptions in critical sections",
            "suites": [],
            "updatePoint": {
                "line": 24,
                "column": 37
            },
            "line": 24,
            "code": "test('exceptions in critical sections', async () => {\n  // GIVEN\n  const criticalSection = createCriticalSection();\n\n  // WHEN/THEN\n  await expect(() => criticalSection(async () => {\n    throw new Error('Thrown');\n  })).rejects.toThrow('Thrown');\n});",
            "file": "util.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "Take a zipped upload",
            "suites": [],
            "updatePoint": {
                "line": 43,
                "column": 26
            },
            "line": 43,
            "code": "test('Take a zipped upload', async () => {\n  const pub = new AssetPublishing(AssetManifest.fromPath(bockfs.path('/simple/cdk.out')), { aws });\n\n  await pub.publish();\n\n  expect(aws.mockS3.upload).toHaveBeenCalledWith(expect.objectContaining({\n    Bucket: 'some_bucket',\n    Key: 'some_key',\n    ContentType: 'application/zip',\n  }));\n});",
            "file": "zipping.test.ts",
            "skipped": false,
            "dir": "packages/cdk-assets/test"
        },
        {
            "name": "skips bump if skip.bump is set",
            "suites": [],
            "updatePoint": {
                "line": 12,
                "column": 36
            },
            "line": 12,
            "code": "test('skips bump if skip.bump is set', async () => {\n  const currentVersion = { stableVersion: '1.1.1', alphaVersion: '1.1.1-alpha.0' };\n  const bumpedVersion = await bump({ releaseAs: 'major', versionFile: 'version.json', skip: { bump: true } }, currentVersion);\n\n  expect(bumpedVersion).toEqual(currentVersion);\n});",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "does a prerelease bump with provided tag if given",
            "suites": [
                "stable versions"
            ],
            "updatePoint": {
                "line": 21,
                "column": 57
            },
            "line": 21,
            "code": "  test('does a prerelease bump with provided tag if given', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion.stableVersion).toEqual('1.3.0-rc.0');\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "does a normal bump if no prerelease tag is given",
            "suites": [
                "stable versions"
            ],
            "updatePoint": {
                "line": 28,
                "column": 56
            },
            "line": 28,
            "code": "  test('does a normal bump if no prerelease tag is given', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    expect(bumpedVersion.stableVersion).toEqual('1.3.0');\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "writes output to version file",
            "suites": [
                "stable versions"
            ],
            "updatePoint": {
                "line": 35,
                "column": 37
            },
            "line": 35,
            "code": "  test('writes output to version file', async () => {\n    const currentVersion = { stableVersion: '1.2.3' };\n    await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    const versionPath = path.join(process.cwd(), 'version.json');\n    const version = '{\\n  \"version\": \"1.3.0\"\\n}';\n    expect(mockWriteFile).toBeCalledWith(expect.any(Object), versionPath, version);\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "long-running prerelease: bumps existing alpha counter as a prerelease",
            "suites": [
                "alpha versions"
            ],
            "updatePoint": {
                "line": 48,
                "column": 77
            },
            "line": 48,
            "code": "  test('long-running prerelease: bumps existing alpha counter as a prerelease', async () => {\n    const currentVersion = { stableVersion: '1.2.0-rc.4', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.2.0-rc.5',\n      alphaVersion: '1.2.0-alpha.1',\n    });\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "one-off prerelease: alpha is a prerelease of stable release with crazy alpha tag",
            "suites": [
                "alpha versions"
            ],
            "updatePoint": {
                "line": 58,
                "column": 88
            },
            "line": 58,
            "code": "  test('one-off prerelease: alpha is a prerelease of stable release with crazy alpha tag', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json', prerelease: 'rc' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.3.0-rc.0',\n      alphaVersion: '1.3.0-alpha.999',\n    });\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "normal release: alpha is a prerelease of stable release with realistic alpha tag",
            "suites": [
                "alpha versions"
            ],
            "updatePoint": {
                "line": 68,
                "column": 88
            },
            "line": 68,
            "code": "  test('normal release: alpha is a prerelease of stable release with realistic alpha tag', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.2.0-alpha.0' };\n    const bumpedVersion = await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    expect(bumpedVersion).toEqual({\n      stableVersion: '1.3.0',\n      alphaVersion: '1.3.0-alpha.0',\n    });\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "writes output to version file",
            "suites": [
                "alpha versions"
            ],
            "updatePoint": {
                "line": 78,
                "column": 37
            },
            "line": 78,
            "code": "  test('writes output to version file', async () => {\n    const currentVersion = { stableVersion: '1.2.0', alphaVersion: '1.1.0-alpha.0' };\n    await bump({ releaseAs: 'minor', versionFile: 'version.json' }, currentVersion);\n\n    const versionPath = path.join(process.cwd(), 'version.json');\n    const version = '{\\n  \"version\": \"1.3.0\",\\n  \"alphaVersion\": \"1.3.0-alpha.0\"\\n}';\n    expect(mockWriteFile).toBeCalledWith(expect.any(Object), versionPath, version);\n  });",
            "file": "bump.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "does nothing if skip.changelog is set",
            "suites": [
                "writeChangelogs"
            ],
            "updatePoint": {
                "line": 34,
                "column": 45
            },
            "line": 34,
            "code": "  test('does nothing if skip.changelog is set', async () => {\n    const changelogResult = await writeChangelogs({ ...defaultWriteChangelogOpts, skip: { changelog: true } });\n\n    expect(changelogResult).toEqual([]);\n  });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "defaults experimentalChangesTreatment to \"include\"",
            "suites": [
                "writeChangelogs"
            ],
            "updatePoint": {
                "line": 40,
                "column": 58
            },
            "line": 40,
            "code": "  test('defaults experimentalChangesTreatment to \"include\"', async () => {\n    const changelogResultDefault = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: undefined,\n    });\n    const changelogResultInclude = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.INCLUDE,\n    });\n\n    expect(changelogResultDefault).toEqual(changelogResultInclude);\n  });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "if experimentalChangesTreatment is \"include\", includes experimental changes",
            "suites": [
                "writeChangelogs"
            ],
            "updatePoint": {
                "line": 51,
                "column": 83
            },
            "line": 51,
            "code": "  test('if experimentalChangesTreatment is \"include\", includes experimental changes', async () => {\n    const changelogResult = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.INCLUDE,\n    });\n\n    expect(changelogResult.length).toEqual(1);\n    expect(changelogResult[0].filePath).toEqual('CHANGELOG.md');\n    expect(changelogResult[0].fileContents.trim()).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-experimental:** new experimental feat\n* **aws-stable:** new stable feat`);\n  });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "if changelogExperimentalChanges is \"strip\", excludes experimental changes",
            "suites": [
                "writeChangelogs"
            ],
            "updatePoint": {
                "line": 67,
                "column": 81
            },
            "line": 67,
            "code": "  test('if changelogExperimentalChanges is \"strip\", excludes experimental changes', async () => {\n    const changelogResult = await writeChangelogs({\n      ...defaultWriteChangelogOpts, experimentalChangesTreatment: ExperimentalChangesTreatment.STRIP,\n    });\n\n    expect(changelogResult.length).toEqual(1);\n    expect(changelogResult[0].filePath).toEqual('CHANGELOG.md');\n    expect(changelogResult[0].fileContents.trim()).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-stable:** new stable feat`);\n  });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "throws if alpha versions are not present",
            "suites": [
                "writeChangelogs",
                "experimentalChangesTreatment is SEPARATE"
            ],
            "updatePoint": {
                "line": 92,
                "column": 50
            },
            "line": 92,
            "code": "    test('throws if alpha versions are not present', async () => {\n      await expect(writeChangelogs({\n        ...defaultSeparateChangelogOpts,\n        currentVersion: { stableVersion: '1.23.0' },\n        newVersion: { stableVersion: '1.24.0' },\n      }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, newVersion: { stableVersion: '1.24.0' } }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, currentVersion: { stableVersion: '1.23.0' } }))\n        .rejects\n        .toThrow(/without alpha package versions/);\n    });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "throws if alpha changelog file is not present",
            "suites": [
                "writeChangelogs",
                "experimentalChangesTreatment is SEPARATE"
            ],
            "updatePoint": {
                "line": 110,
                "column": 55
            },
            "line": 110,
            "code": "    test('throws if alpha changelog file is not present', async () => {\n      await expect(writeChangelogs({ ...defaultSeparateChangelogOpts, alphaChangelogFile: undefined }))\n        .rejects\n        .toThrow(/alphaChangelogFile must be specified/);\n    });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "excludes experimental changes and writes to the alpha changelog",
            "suites": [
                "writeChangelogs",
                "experimentalChangesTreatment is SEPARATE"
            ],
            "updatePoint": {
                "line": 116,
                "column": 73
            },
            "line": 116,
            "code": "    test('excludes experimental changes and writes to the alpha changelog', async () => {\n      const changelogResult = await writeChangelogs(defaultSeparateChangelogOpts);\n\n      const mainResult = changelogResult.find(r => r.filePath === 'CHANGELOG.md');\n      const alphaResult = changelogResult.find(r => r.filePath === 'CHANGELOG.alpha.md');\n      expect(mainResult?.fileContents.trim()).toBe(\n        `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### Features\n\n* **aws-stable:** new stable feat`);\n      expect(alphaResult?.fileContents.trim()).toBe(\n        `## [1.24.0-alpha.0](https://github.com/aws/aws-cdk/compare/v1.23.0-alpha.0...v1.24.0-alpha.0)\n\n### Features\n\n* **aws-experimental:** new experimental feat`);\n    });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "correctly handles 'BREAKING CHANGES'",
            "suites": [
                "changelog"
            ],
            "updatePoint": {
                "line": 138,
                "column": 44
            },
            "line": 138,
            "code": "  test(\"correctly handles 'BREAKING CHANGES'\", async () => {\n    const commits: ConventionalCommit[] = [\n      buildCommit({\n        type: 'feat',\n        subject: 'super important feature',\n        notes: [\n          {\n            title: 'BREAKING CHANGE',\n            text: 'this is a breaking change',\n          },\n        ],\n      }),\n      buildCommit({\n        type: 'fix',\n        scope: 'scope',\n        subject: 'hairy bugfix',\n      }),\n      buildCommit({\n        type: 'chore',\n        subject: 'this commit should not be rendered in the Changelog',\n      }),\n    ];\n\n    const changelogContents = await invokeChangelogFrom1_23_0to1_24_0(args, commits);\n\n    expect(changelogContents).toBe(\n      `## [1.24.0](https://github.com/aws/aws-cdk/compare/v1.23.0...v1.24.0)\n\n### ⚠ BREAKING CHANGES TO EXPERIMENTAL FEATURES\n\n* this is a breaking change\n\n### Features\n\n* super important feature\n\n\n### Bug Fixes\n\n* **scope:** hairy bugfix\n\n`);\n  });",
            "file": "changelog.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "makes it so that no Git commits are queried if Changelog generation is skipped",
            "suites": [
                "getConventionalCommitsFromGitHistory"
            ],
            "updatePoint": {
                "line": 26,
                "column": 86
            },
            "line": 26,
            "code": "  test('makes it so that no Git commits are queried if Changelog generation is skipped', async () => {\n    const commits = await getConventionalCommitsFromGitHistory({ ...args, skip: { changelog: true } }, '3.9.2');\n\n    expect(commits).toHaveLength(0);\n    expect(gitRawCommits).not.toHaveBeenCalled();\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "skips commits without types",
            "suites": [
                "getConventionalCommitsFromGitHistory"
            ],
            "updatePoint": {
                "line": 33,
                "column": 35
            },
            "line": 33,
            "code": "  test('skips commits without types', async () => {\n    const commitMessages = ['some commit without a type', 'chore(cdk-release): do trivial stuff'];\n    gitRawCommits.mockImplementation(() => mockGitCommits(commitMessages));\n\n    const commits = await getConventionalCommitsFromGitHistory(args, '3.9.2');\n\n    expect(commits).toHaveLength(1);\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "if no options are provided, returns all commits",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 50,
                "column": 55
            },
            "line": 50,
            "code": "  test('if no options are provided, returns all commits', () => {\n    const filteredCommits = filterCommits(commits);\n\n    expect(filteredCommits).toEqual(commits);\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "excludePackages removes commits matching scope",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 56,
                "column": 54
            },
            "line": 56,
            "code": "  test('excludePackages removes commits matching scope', () => {\n    const filteredCommits = filterCommits(commits, { excludePackages: ['@aws-cdk/aws-experimental'] });\n\n    expect(filteredCommits.length).toEqual(2);\n    expect(filteredCommits.map(c => c.scope)).not.toContain('aws-experimental');\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "excludePackages removes commits matching specific variants of the scope",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 63,
                "column": 79
            },
            "line": 63,
            "code": "  test('excludePackages removes commits matching specific variants of the scope', () => {\n    const experimentalCommits = [\n      commitWithScope('aws-experimental'),\n      commitWithScope('awsexperimental'),\n      commitWithScope('experimental'),\n      commitWithScope('aws.experimental'),\n    ];\n\n    const filteredCommits = filterCommits(experimentalCommits, { excludePackages: ['@aws-cdk/aws-experimental'] });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws.experimental');\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "includePackages only includes commits matching scope",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 77,
                "column": 60
            },
            "line": 77,
            "code": "  test('includePackages only includes commits matching scope', () => {\n    const filteredCommits = filterCommits(commits, { includePackages: ['@aws-cdk/aws-stable'] });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws-stable');\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "includePackages includes commits matching variants of the scope",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 84,
                "column": 71
            },
            "line": 84,
            "code": "  test('includePackages includes commits matching variants of the scope', () => {\n    const stableCommits = [\n      commitWithScope('aws-stable'),\n      commitWithScope('awsstable'),\n      commitWithScope('stable'),\n      commitWithScope('notstable'),\n    ];\n\n    const filteredCommits = filterCommits(stableCommits, { includePackages: ['@aws-cdk/aws-stable'] });\n\n    expect(filteredCommits.length).toEqual(3);\n    expect(filteredCommits.map(c => c.scope)).not.toContain('notstable');\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "excludes criteria are run after includes",
            "suites": [
                "filterCommits"
            ],
            "updatePoint": {
                "line": 98,
                "column": 48
            },
            "line": 98,
            "code": "  test('excludes criteria are run after includes', () => {\n    const filteredCommits = filterCommits(commits, {\n      includePackages: ['@aws-cdk/aws-stable', '@aws-cdk/aws-experimental'],\n      excludePackages: ['@aws-cdk/aws-experimental'],\n    });\n\n    expect(filteredCommits.length).toEqual(1);\n    expect(filteredCommits[0].scope).toEqual('aws-stable');\n  });",
            "file": "conventional-commits.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "without alpha releases, only the stable changelog is returned",
            "suites": [],
            "updatePoint": {
                "line": 21,
                "column": 67
            },
            "line": 21,
            "code": "test('without alpha releases, only the stable changelog is returned', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3' }; });\n  mockChangelogOnceForVersion('1.2.3', 'foo');\n\n  await createReleaseNotes(DEFAULT_OPTS);\n\n  expectReleaseNotes('foo');\n});",
            "file": "release-notes.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "with alpha releases the contents of both are returned as separate sections",
            "suites": [],
            "updatePoint": {
                "line": 30,
                "column": 80
            },
            "line": 30,
            "code": "test('with alpha releases the contents of both are returned as separate sections', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3', alphaVersion: '1.2.3-alpha' }; });\n  mockChangelogOnceForVersion('1.2.3', 'foo'); // stable\n  mockChangelogOnceForVersion('1.2.3-alpha', 'bar'); // alpha\n\n  await createReleaseNotes({ ...DEFAULT_OPTS, alphaChangelogFile: 'CHANGELOG.alpha.md' });\n\n  expectReleaseNotes([\n    'foo',\n    '---',\n    '## Alpha modules (1.2.3-alpha)',\n    'bar',\n  ]);\n});",
            "file": "release-notes.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "throws if no matching version is found in the changelog",
            "suites": [],
            "updatePoint": {
                "line": 45,
                "column": 61
            },
            "line": 45,
            "code": "test('throws if no matching version is found in the changelog', async () => {\n  mockReadVersion.mockImplementation((_) => { return { stableVersion: '1.2.3' }; });\n  mockChangelogOnceForVersion('4.5.6', 'foo');\n\n  await expect(createReleaseNotes(DEFAULT_OPTS))\n    .rejects\n    .toThrow(/No changelog entry found for version 1.2.3 in CHANGELOG.md/);\n});",
            "file": "release-notes.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/cdk-release/test"
        },
        {
            "name": "base case",
            "suites": [
                "createModuleDefinitionFromCfnNamespace"
            ],
            "updatePoint": {
                "line": 6,
                "column": 17
            },
            "line": 6,
            "code": "  test('base case', () => {\n    const module = createModuleDefinitionFromCfnNamespace('AWS::EC2');\n\n    expect(module).toEqual({\n      namespace: 'AWS::EC2',\n      moduleName: 'aws-ec2',\n      moduleFamily: 'AWS',\n      moduleBaseName: 'EC2',\n      packageName: '@aws-cdk/aws-ec2',\n      dotnetPackage: 'Amazon.CDK.AWS.EC2',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'services.ec2',\n      javaArtifactId: 'ec2',\n      pythonDistName: 'aws-cdk.aws-ec2',\n      pythonModuleName: 'aws_cdk.aws_ec2',\n      submoduleName: 'aws_ec2',\n    });\n  });",
            "file": "libary-creation.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "Serverless is special-cased to SAM",
            "suites": [
                "createModuleDefinitionFromCfnNamespace"
            ],
            "updatePoint": {
                "line": 25,
                "column": 42
            },
            "line": 25,
            "code": "  test('Serverless is special-cased to SAM', () => {\n    const module = createModuleDefinitionFromCfnNamespace('AWS::Serverless');\n\n    expect(module).toEqual({\n      namespace: 'AWS::Serverless',\n      moduleName: 'aws-sam',\n      moduleFamily: 'AWS',\n      moduleBaseName: 'SAM',\n      packageName: '@aws-cdk/aws-sam',\n      dotnetPackage: 'Amazon.CDK.AWS.SAM',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'services.sam',\n      javaArtifactId: 'sam',\n      pythonDistName: 'aws-cdk.aws-sam',\n      pythonModuleName: 'aws_cdk.aws_sam',\n      submoduleName: 'aws_sam',\n    });\n  });",
            "file": "libary-creation.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "Java artifacts use different package/artifact when module family is not AWS",
            "suites": [
                "createModuleDefinitionFromCfnNamespace"
            ],
            "updatePoint": {
                "line": 44,
                "column": 83
            },
            "line": 44,
            "code": "  test('Java artifacts use different package/artifact when module family is not AWS', () => {\n    const module = createModuleDefinitionFromCfnNamespace('Alexa::ASK');\n\n    expect(module).toEqual({\n      namespace: 'Alexa::ASK',\n      moduleName: 'alexa-ask',\n      moduleFamily: 'Alexa',\n      moduleBaseName: 'ASK',\n      packageName: '@aws-cdk/alexa-ask',\n      dotnetPackage: 'Amazon.CDK.Alexa.ASK',\n      javaGroupId: 'software.amazon.awscdk',\n      javaPackage: 'alexa.ask',\n      javaArtifactId: 'alexa-ask',\n      pythonDistName: 'aws-cdk.alexa-ask',\n      pythonModuleName: 'aws_cdk.alexa_ask',\n      submoduleName: 'alexa_ask',\n    });\n  });",
            "file": "libary-creation.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "library name is valid",
            "suites": [
                "createLibraryReadme"
            ],
            "updatePoint": {
                "line": 78,
                "column": 29
            },
            "line": 78,
            "code": "  test('library name is valid', async () => {\n    tempDir = fs.mkdtempSync(path.join(__dirname, 'temp'));\n    const readmePath = path.join(tempDir, 'README.md');\n    await createLibraryReadme('Alexa::ASK', readmePath);\n\n    const readme = fs.readFileSync(readmePath, { encoding: 'utf8' });\n    expect(readme).toContain(\"import * as alexa_ask from '@aws-cdk/alexa-ask';\");\n  });",
            "file": "libary-creation.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "feature table is rendered",
            "suites": [
                "FeatureStabilityRule"
            ],
            "updatePoint": {
                "line": 20,
                "column": 33
            },
            "line": 20,
            "code": "  test('feature table is rendered', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n            { name: 'Stable Feature', stability: 'Stable' },\n            { name: 'Dev Preview Feature', stability: 'Developer Preview' },\n            { name: 'Not Implemented Feature', stability: 'Not Implemented' },\n          ],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    pkgJson.applyFixes();\n    const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n    expect(fixedContents).toMatch(/Experimental Feature\\s* \\| \\!\\[Experimental\\]/);\n    expect(fixedContents).toMatch(/Dev Preview Feature\\s* \\| \\!\\[Developer Preview\\]/);\n    expect(fixedContents).toMatch(/Stable Feature\\s* \\| \\!\\[Stable\\]/);\n    expect(fixedContents).toMatch(/Not Implemented Feature\\s* \\| \\!\\[Not Implemented\\]/);\n    expect(fixedContents).not.toMatch(/CFN Resources/);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "CFN Resources is rendered",
            "suites": [
                "FeatureStabilityRule"
            ],
            "updatePoint": {
                "line": 50,
                "column": 33
            },
            "line": 50,
            "code": "  test('CFN Resources is rendered', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          'cdk-build': { cloudformation: 'Foo::Bar' },\n          'features': [],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.FeatureStabilityRule();\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n    expect(pkgJson.hasReports).toBe(true);\n    pkgJson.applyFixes();\n    const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n\n    expect(fixedContents).toMatch(/CFN Resources | \\!\\[Stable\\]/);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "CFN Resources",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 73,
                "column": 23
            },
            "line": 73,
            "code": "    test('CFN Resources', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            'cdk-build': { cloudformation: 'Foo::Bar' },\n            'features': [],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*CFN Resources:\\*\\*/);\n    });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "experimental",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 94,
                "column": 22
            },
            "line": 94,
            "code": "    test('experimental', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Experimental' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Stable:\\*\\*/);\n    });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "developer preview",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 118,
                "column": 27
            },
            "line": 118,
            "code": "    test('developer preview', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Developer Preview' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Stable:\\*\\*/);\n    });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "stable",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 142,
                "column": 16
            },
            "line": 142,
            "code": "    test('stable', async () => {\n      fakeModule = new FakeModule({\n        files: {\n          'package.json': {\n            features: [\n              { name: 'Feature', stability: 'Stable' },\n            ],\n          },\n          'README.md': '',\n        },\n      });\n      const dirPath = await fakeModule.tmpdir();\n      const rule = new rules.FeatureStabilityRule();\n\n      const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n      rule.validate(pkgJson);\n      pkgJson.applyFixes();\n\n      const fixedContents = await fs.readFile(path.join(dirPath, 'README.md'), { encoding: 'utf8' });\n      expect(fixedContents).toMatch(/> \\*\\*Stable:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Experimental:\\*\\*/);\n      expect(fixedContents).not.toMatch(/> \\*\\*Developer Preview:\\*\\*/);\n    });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "skip if package private",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 167,
                "column": 31
            },
            "line": 167,
            "code": "  test('skip if package private', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          private: true,\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n          ],\n        },\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "skip if features is not specified",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 188,
                "column": 41
            },
            "line": 188,
            "code": "  test('skip if features is not specified', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {},\n        'README.md': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "skip if README.md is missing",
            "suites": [
                "FeatureStabilityRule",
                "banner notices"
            ],
            "updatePoint": {
                "line": 204,
                "column": 36
            },
            "line": 204,
            "code": "  test('skip if README.md is missing', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          features: [\n            { name: 'Experimental Feature', stability: 'Experimental' },\n          ],\n        },\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n    const rule = new rules.FeatureStabilityRule();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "errors when attribution missing for bundled dependencies",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 237,
                "column": 64
            },
            "line": 237,
            "code": "  test('errors when attribution missing for bundled dependencies', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(2);\n    for (const report of pkgJson.reports) {\n      expect(report.ruleName).toEqual('license/3p-attributions');\n      expect(report.message).toContain('Missing attribution');\n    }\n    expect(pkgJson.reports[0].message).toContain('dep1');\n    expect(pkgJson.reports[1].message).toContain('dep2');\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "errors when there are excessive attributions",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 265,
                "column": 52
            },
            "line": 265,
            "code": "  test('errors when there are excessive attributions', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n          '** dep3-rev - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(2);\n    for (const report of pkgJson.reports) {\n      expect(report.ruleName).toEqual('license/3p-attributions');\n      expect(report.message).toContain('Unnecessary attribution');\n    }\n    expect(pkgJson.reports[0].message).toContain('dep2');\n    expect(pkgJson.reports[1].message).toContain('dep3-rev');\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "passes when attribution is present",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 296,
                "column": 42
            },
            "line": 296,
            "code": "  test('passes when attribution is present', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "passes when attribution for transitive bundled deps are present",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 320,
                "column": 71
            },
            "line": 320,
            "code": "  test('passes when attribution for transitive bundled deps are present', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {\n          dependencies: { dep2: '1.2.3' },\n        },\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n          '** dep2 - https://link-elsewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "fails when attribution for transitive bundled deps are missing",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 346,
                "column": 70
            },
            "line": 346,
            "code": "  test('fails when attribution for transitive bundled deps are missing', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          bundledDependencies: ['dep1'],\n        },\n        'node_modules/dep1/package.json': {\n          dependencies: { dep2: '1.2.3' },\n        },\n        'node_modules/dep2/package.json': {},\n        'NOTICE': [\n          '** dep1 - https://link-somewhere',\n        ].join('\\n'),\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(true);\n    expect(pkgJson.reports.length).toEqual(1);\n    expect(pkgJson.reports[0].ruleName).toEqual('license/3p-attributions');\n    expect(pkgJson.reports[0].message).toContain('Missing attribution');\n    expect(pkgJson.reports[0].message).toContain('dep2');\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "skipped when no bundled dependencies",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 375,
                "column": 44
            },
            "line": 375,
            "code": "  test('skipped when no bundled dependencies', async() => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n        },\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        },
        {
            "name": "skipped for private packages",
            "suites": [
                "ThirdPartyAttributions"
            ],
            "updatePoint": {
                "line": 393,
                "column": 36
            },
            "line": 393,
            "code": "  test('skipped for private packages', async () => {\n    fakeModule = new FakeModule({\n      files: {\n        'package.json': {\n          private: true,\n          bundledDependencies: ['dep1', 'dep2'],\n        },\n        'node_modules/dep1/package.json': {},\n        'node_modules/dep2/package.json': {},\n        'NOTICE': '',\n      },\n    });\n    const dirPath = await fakeModule.tmpdir();\n\n    const rule = new rules.ThirdPartyAttributions();\n\n    const pkgJson = new PackageJson(path.join(dirPath, 'package.json'));\n    rule.validate(pkgJson);\n\n    expect(pkgJson.hasReports).toBe(false);\n  });",
            "file": "rules.test.ts",
            "skipped": false,
            "dir": "tools/@aws-cdk/pkglint/test"
        }
    ],
    "error": "Exclusive tests detected. `.only` call found in lint.test.ts:145\nRemove `.only` to restore test checks"
}