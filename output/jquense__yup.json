{"repo":"jquense/yup","url":"https://github.com/jquense/yup","branch":"master","configs":[{"package":"yup","lang":"ts","dir":"test","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should parse json strings","suites":["Array types","casting"],"updatePoint":{"line":5,"column":33},"line":5,"code":"    it('should parse json strings', () => {\n      expect(array().json().cast('[2,3,5,6]')).toEqual([2, 3, 5, 6]);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should failed casts return input","suites":["Array types","casting"],"updatePoint":{"line":9,"column":40},"line":9,"code":"    it('should failed casts return input', () => {\n      expect(array().cast('asfasf', { assert: false })).toEqual('asfasf');\n\n      expect(array().cast('{}', { assert: false })).toEqual('{}');\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should recursively cast fields","suites":["Array types","casting"],"updatePoint":{"line":15,"column":38},"line":15,"code":"    it('should recursively cast fields', () => {\n      expect(array().of(number()).cast(['4', '5'])).toEqual([4, 5]);\n\n      expect(array().of(string()).cast(['4', 5, false])).toEqual([\n        '4',\n        '5',\n        'false',\n      ]);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should handle DEFAULT","suites":["Array types","casting"],"updatePoint":{"line":26,"column":27},"line":26,"code":"  it('should handle DEFAULT', () => {\n    expect(array().getDefault()).toBeUndefined();\n\n    expect(\n      array()\n        .default(() => [1, 2, 3])\n        .getDefault(),\n    ).toEqual([1, 2, 3]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["Array types","casting"],"updatePoint":{"line":36,"column":23},"line":36,"code":"  it('should type check', () => {\n    let inst = array();\n\n    expect(inst.isType([])).toBe(true);\n    expect(inst.isType({})).toBe(false);\n    expect(inst.isType('true')).toBe(false);\n    expect(inst.isType(NaN)).toBe(false);\n    expect(inst.isType(34545)).toBe(false);\n\n    expect(inst.isType(null)).toBe(false);\n\n    expect(inst.nullable().isType(null)).toBe(true);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should cast children","suites":["Array types","casting"],"updatePoint":{"line":50,"column":26},"line":50,"code":"  it('should cast children', () => {\n    expect(array().of(number()).cast(['1', '3'])).toEqual([1, 3]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should concat subType correctly","suites":["Array types","casting"],"updatePoint":{"line":54,"column":37},"line":54,"code":"  it('should concat subType correctly', async () => {\n    expect(array(number()).concat(array()).innerType).toBeDefined();\n\n    let merged = array(number()).concat(array(number().required()));\n\n    expect((merged.innerType as AnySchema).type).toBe('number');\n\n    await expect(merged.validateAt('[0]', undefined)).rejects.toThrowError();\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should pass options to children","suites":["Array types","casting"],"updatePoint":{"line":64,"column":37},"line":64,"code":"  it('should pass options to children', () => {\n    expect(\n      array(object({ name: string() })).cast([{ id: 1, name: 'john' }], {\n        stripUnknown: true,\n      }),\n    ).toEqual([{ name: 'john' }]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"Basic validations fail: %s %p","suites":["Array types","validation"],"line":73,"code":"    test.each([\n      ['required', undefined, array().required()],\n      ['required', null, array().required()],\n      ['null', null, array()],\n      ['length', [1, 2, 3], array().length(2)],\n    ])('Basic validations fail: %s %p', async (_, value, schema) => {\n      expect(await schema.isValid(value)).toBe(false);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"Basic validations pass: %s %p","suites":["Array types","validation"],"line":82,"code":"    test.each([\n      ['required', [], array().required()],\n      ['nullable', null, array().nullable()],\n      ['length', [1, 2, 3], array().length(3)],\n    ])('Basic validations pass: %s %p', async (_, value, schema) => {\n      expect(await schema.isValid(value)).toBe(true);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should allow undefined","suites":["Array types","validation"],"updatePoint":{"line":90,"column":30},"line":90,"code":"    it('should allow undefined', async () => {\n      await expect(\n        array().of(number().max(5)).isValid(undefined),\n      ).resolves.toBe(true);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"max should replace earlier tests","suites":["Array types","validation"],"updatePoint":{"line":96,"column":40},"line":96,"code":"    it('max should replace earlier tests', async () => {\n      expect(await array().max(4).max(10).isValid(Array(5).fill(0))).toBe(true);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"min should replace earlier tests","suites":["Array types","validation"],"updatePoint":{"line":100,"column":40},"line":100,"code":"    it('min should replace earlier tests', async () => {\n      expect(await array().min(10).min(4).isValid(Array(5).fill(0))).toBe(true);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should respect subtype validations","suites":["Array types","validation"],"updatePoint":{"line":104,"column":42},"line":104,"code":"    it('should respect subtype validations', async () => {\n      let inst = array().of(number().max(5));\n\n      await expect(inst.isValid(['gg', 3])).resolves.toBe(false);\n      await expect(inst.isValid([7, 3])).resolves.toBe(false);\n\n      let value = await inst.validate(['4', 3]);\n\n      expect(value).toEqual([4, 3]);\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should prevent recursive casting","suites":["Array types","validation"],"updatePoint":{"line":115,"column":40},"line":115,"code":"    it('should prevent recursive casting', async () => {\n      // @ts-ignore\n      let castSpy = jest.spyOn(StringSchema.prototype, '_cast');\n\n      let value = await array(string()).defined().validate([5]);\n\n      expect(value[0]).toBe('5');\n\n      expect(castSpy).toHaveBeenCalledTimes(1);\n      castSpy.mockRestore();\n    });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should respect abortEarly","suites":["Array types","validation"],"updatePoint":{"line":128,"column":31},"line":128,"code":"  it('should respect abortEarly', async () => {\n    let inst = array()\n      .of(object({ str: string().required() }))\n      .test('name', 'oops', () => false);\n\n    await expect(inst.validate([{ str: '' }])).rejects.toEqual(\n      expect.objectContaining({\n        value: [{ str: '' }],\n        errors: ['oops'],\n      }),\n    );\n\n    await expect(\n      inst.validate([{ str: '' }], { abortEarly: false }),\n    ).rejects.toEqual(\n      expect.objectContaining({\n        value: [{ str: '' }],\n        errors: ['[0].str is a required field', 'oops'],\n      }),\n    );\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should compact arrays","suites":["Array types","validation"],"updatePoint":{"line":150,"column":27},"line":150,"code":"  it('should compact arrays', () => {\n    let arr = ['', 1, 0, 4, false, null],\n      inst = array();\n\n    expect(inst.compact().cast(arr)).toEqual([1, 4]);\n\n    expect(inst.compact((v) => v == null).cast(arr)).toEqual([\n      '',\n      1,\n      0,\n      4,\n      false,\n    ]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should ensure arrays","suites":["Array types","validation"],"updatePoint":{"line":165,"column":26},"line":165,"code":"  it('should ensure arrays', () => {\n    let inst = array().ensure();\n\n    const a = [1, 4];\n    expect(inst.cast(a)).toBe(a);\n\n    expect(inst.cast(null)).toEqual([]);\n    // nullable is redundant since this should always produce an array\n    // but we want to ensure that null is actually turned into an array\n    expect(inst.nullable().cast(null)).toEqual([]);\n\n    expect(inst.cast(1)).toEqual([1]);\n    expect(inst.nullable().cast(1)).toEqual([1]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should pass resolved path to descendants","suites":["Array types","validation"],"updatePoint":{"line":180,"column":46},"line":180,"code":"  it('should pass resolved path to descendants', async () => {\n    let value = ['2', '3'];\n    let expectedPaths = ['[0]', '[1]'];\n\n    let itemSchema = string().when([], function (_, _s, opts: any) {\n      let path = opts.path;\n      expect(expectedPaths).toContain(path);\n      return string().required();\n    });\n\n    await array().of(itemSchema).validate(value);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should maintain array sparseness through validation","suites":["Array types","validation"],"updatePoint":{"line":193,"column":57},"line":193,"code":"  it('should maintain array sparseness through validation', async () => {\n    let sparseArray = new Array(2);\n    sparseArray[1] = 1;\n    let value = await array().of(number()).validate(sparseArray);\n    expect(0 in sparseArray).toBe(false);\n    expect(0 in value!).toBe(false);\n\n    // eslint-disable-next-line no-sparse-arrays\n    expect(value).toEqual([, 1]);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should validate empty slots in sparse array","suites":["Array types","validation"],"updatePoint":{"line":204,"column":49},"line":204,"code":"  it('should validate empty slots in sparse array', async () => {\n    let sparseArray = new Array(2);\n    sparseArray[1] = 1;\n    await expect(\n      array().of(number().required()).isValid(sparseArray),\n    ).resolves.toEqual(false);\n  });","file":"array.ts","skipped":false,"dir":"test"},{"name":"should CAST correctly","suites":["Boolean types"],"updatePoint":{"line":5,"column":27},"line":5,"code":"  it('should CAST correctly', () => {\n    let inst = bool();\n\n    expect(inst.cast('true')).toBe(true);\n    expect(inst.cast('True')).toBe(true);\n    expect(inst.cast('false')).toBe(false);\n    expect(inst.cast('False')).toBe(false);\n    expect(inst.cast(1)).toBe(true);\n    expect(inst.cast(0)).toBe(false);\n\n    TestHelpers.castAndShouldFail(inst, 'foo');\n\n    TestHelpers.castAndShouldFail(inst, 'bar1');\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"should handle DEFAULT","suites":["Boolean types"],"updatePoint":{"line":20,"column":27},"line":20,"code":"  it('should handle DEFAULT', () => {\n    let inst = bool();\n\n    expect(inst.getDefault()).toBeUndefined();\n    expect(inst.default(true).required().getDefault()).toBe(true);\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["Boolean types"],"updatePoint":{"line":27,"column":23},"line":27,"code":"  it('should type check', () => {\n    let inst = bool();\n\n    expect(inst.isType(1)).toBe(false);\n    expect(inst.isType(false)).toBe(true);\n    expect(inst.isType('true')).toBe(false);\n    expect(inst.isType(NaN)).toBe(false);\n    expect(inst.isType(new Number('foooo'))).toBe(false);\n\n    expect(inst.isType(34545)).toBe(false);\n    expect(inst.isType(new Boolean(false))).toBe(true);\n\n    expect(inst.isType(null)).toBe(false);\n\n    expect(inst.nullable().isType(null)).toBe(true);\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"bool should VALIDATE correctly","suites":["Boolean types"],"updatePoint":{"line":44,"column":36},"line":44,"code":"  it('bool should VALIDATE correctly', () => {\n    let inst = bool().required();\n\n    return Promise.all([\n      expect(bool().isValid('1')).resolves.toBe(true),\n      expect(bool().strict().isValid(null)).resolves.toBe(false),\n      expect(bool().nullable().isValid(null)).resolves.toBe(true),\n      expect(inst.validate(undefined)).rejects.toEqual(\n        expect.objectContaining({\n          errors: ['this is a required field'],\n        }),\n      ),\n    ]);\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"should check isTrue correctly","suites":["Boolean types"],"updatePoint":{"line":59,"column":35},"line":59,"code":"  it('should check isTrue correctly', () => {\n    return Promise.all([\n      expect(bool().isTrue().isValid(true)).resolves.toBe(true),\n      expect(bool().isTrue().isValid(false)).resolves.toBe(false),\n    ]);\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"should check isFalse correctly","suites":["Boolean types"],"updatePoint":{"line":66,"column":36},"line":66,"code":"  it('should check isFalse correctly', () => {\n    return Promise.all([\n      expect(bool().isFalse().isValid(false)).resolves.toBe(true),\n      expect(bool().isFalse().isValid(true)).resolves.toBe(false),\n    ]);\n  });","file":"bool.ts","skipped":false,"dir":"test"},{"name":"should CAST correctly","suites":["Date types"],"updatePoint":{"line":8,"column":27},"line":8,"code":"  it('should CAST correctly', () => {\n    let inst = date();\n\n    expect(inst.cast(new Date())).toBeInstanceOf(Date);\n    expect(inst.cast('jan 15 2014')).toEqual(new Date(2014, 0, 15));\n    expect(inst.cast('2014-09-23T19:25:25Z')).toEqual(new Date(1411500325000));\n    // Leading-zero milliseconds\n    expect(inst.cast('2016-08-10T11:32:19.012Z')).toEqual(\n      new Date(1470828739012),\n    );\n    // Microsecond precision\n    expect(inst.cast('2016-08-10T11:32:19.2125Z')).toEqual(\n      new Date(1470828739212),\n    );\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should return invalid date for failed casts","suites":["Date types"],"updatePoint":{"line":24,"column":49},"line":24,"code":"  it('should return invalid date for failed casts', function () {\n    let inst = date();\n\n    expect(isValidDate(inst.cast(null, { assert: false }))).toBe(false);\n    expect(isValidDate(inst.cast('', { assert: false }))).toBe(false);\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["Date types"],"updatePoint":{"line":31,"column":23},"line":31,"code":"  it('should type check', () => {\n    let inst = date();\n\n    expect(inst.isType(new Date())).toBe(true);\n    expect(inst.isType(false)).toBe(false);\n    expect(inst.isType(null)).toBe(false);\n    expect(inst.isType(NaN)).toBe(false);\n    expect(inst.nullable().isType(new Date())).toBe(true);\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should VALIDATE correctly","suites":["Date types"],"updatePoint":{"line":41,"column":31},"line":41,"code":"  it('should VALIDATE correctly', () => {\n    let inst = date().required().max(new Date(2014, 5, 15));\n\n    return Promise.all([\n      expect(date().isValid(null)).resolves.toBe(false),\n      expect(date().nullable().isValid(null)).resolves.toBe(true),\n\n      expect(inst.isValid(new Date(2014, 0, 15))).resolves.toBe(true),\n      expect(inst.isValid(new Date(2014, 7, 15))).resolves.toBe(false),\n      expect(inst.isValid('5')).resolves.toBe(true),\n\n      expect(inst.validate(undefined)).rejects.toEqual(\n        expect.objectContaining({\n          errors: ['this is a required field'],\n        }),\n      ),\n    ]);\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should check MIN correctly","suites":["Date types"],"updatePoint":{"line":60,"column":32},"line":60,"code":"  it('should check MIN correctly', () => {\n    let min = new Date(2014, 3, 15),\n      invalid = new Date(2014, 1, 15),\n      valid = new Date(2014, 5, 15);\n    expect(function () {\n      date().max('hello');\n    }).toThrowError(TypeError);\n    expect(function () {\n      date().max(ref('$foo'));\n    }).not.toThrowError();\n\n    return Promise.all([\n      expect(date().min(min).isValid(valid)).resolves.toBe(true),\n      expect(date().min(min).isValid(invalid)).resolves.toBe(false),\n      expect(date().min(min).isValid(null)).resolves.toBe(false),\n\n      expect(\n        date()\n          .min(ref('$foo'))\n          .isValid(valid, { context: { foo: min } }),\n      ).resolves.toBe(true),\n      expect(\n        date()\n          .min(ref('$foo'))\n          .isValid(invalid, { context: { foo: min } }),\n      ).resolves.toBe(false),\n    ]);\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should check MAX correctly","suites":["Date types"],"updatePoint":{"line":89,"column":32},"line":89,"code":"  it('should check MAX correctly', () => {\n    let max = new Date(2014, 7, 15),\n      invalid = new Date(2014, 9, 15),\n      valid = new Date(2014, 5, 15);\n    expect(function () {\n      date().max('hello');\n    }).toThrowError(TypeError);\n    expect(function () {\n      date().max(ref('$foo'));\n    }).not.toThrowError();\n\n    return Promise.all([\n      expect(date().max(max).isValid(valid)).resolves.toBe(true),\n      expect(date().max(max).isValid(invalid)).resolves.toBe(false),\n      expect(date().max(max).nullable().isValid(null)).resolves.toBe(true),\n\n      expect(\n        date()\n          .max(ref('$foo'))\n          .isValid(valid, { context: { foo: max } }),\n      ).resolves.toBe(true),\n      expect(\n        date()\n          .max(ref('$foo'))\n          .isValid(invalid, { context: { foo: max } }),\n      ).resolves.toBe(false),\n    ]);\n  });","file":"date.ts","skipped":false,"dir":"test"},{"name":"should cast  to ","suites":[],"updatePoint":{"line":17,"column":65},"line":17,"code":"    it(`should cast ${printValue(value)} to ${printValue(result)}`, () => {\n      expect(schema.cast(value)).toBe(result);\n    });","file":"helpers.ts","skipped":false,"dir":"test"},{"name":"should not cast ","suites":[],"updatePoint":{"line":23,"column":44},"line":23,"code":"    it(`should not cast ${printValue(value)}`, () => {\n      castAndShouldFail(inst, value);\n    });","file":"helpers.ts","skipped":false,"dir":"test"},{"name":"","suites":["invalid:"],"updatePoint":{"line":49,"column":60},"line":49,"code":"      it(`${printValue(value)}${message && `  (${message})`}`, async () => {\n        await expect((schema as any).isValid(value)).resolves.toEqual(isValid);\n      });","file":"helpers.ts","skipped":false,"dir":"test"},{"name":"should throw on a non-schema value","suites":["lazy"],"updatePoint":{"line":4,"column":40},"line":4,"code":"  it('should throw on a non-schema value', () => {\n    // @ts-expect-error testing incorrect usage\n    expect(() => lazy(() => undefined).validate(undefined)).toThrowError();\n  });","file":"lazy.ts","skipped":false,"dir":"test"},{"name":"should call with value","suites":["lazy","mapper"],"updatePoint":{"line":17,"column":30},"line":17,"code":"    it('should call with value', () => {\n      lazy(mapper).validate(value);\n      expect(mapper).toHaveBeenCalledWith(value, expect.any(Object));\n    });","file":"lazy.ts","skipped":false,"dir":"test"},{"name":"should call with context","suites":["lazy","mapper"],"updatePoint":{"line":22,"column":32},"line":22,"code":"    it('should call with context', () => {\n      const context = {\n        a: 1,\n      };\n      let options = { context };\n      lazy(mapper).validate(value, options);\n      expect(mapper).toHaveBeenCalledWith(value, options);\n    });","file":"lazy.ts","skipped":false,"dir":"test"},{"name":"should allow meta","suites":["lazy","mapper"],"updatePoint":{"line":31,"column":25},"line":31,"code":"    it('should allow meta', () => {\n      const meta = { a: 1 };\n      const schema = lazy(mapper).meta(meta);\n\n      expect(schema.meta()).toEqual(meta);\n\n      expect(schema.meta({ added: true })).not.toEqual(schema.meta());\n\n      expect(schema.meta({ added: true }).meta()).toEqual({\n        a: 1,\n        added: true,\n      });\n    });","file":"lazy.ts","skipped":false,"dir":"test"},{"name":"[internal] normal methods should be running in sync Mode","suites":[],"updatePoint":{"line":21,"column":62},"line":21,"code":"  it('[internal] normal methods should be running in sync Mode', async () => {\n    let schema = number();\n\n    // test negative ensure case\n    await expect(ensureSync(() => Promise.resolve())).rejects.toThrowError(\n      'Did not execute synchronously',\n    );\n\n    // test positive case\n    await expect(ensureSync(() => schema.isValid(1))).resolves.toBe(true);\n\n    // ensure it fails with the correct message in sync mode\n    await expect(\n      ensureSync(() => schema.validate('john')),\n    ).rejects.toThrowError(\n      /the final value was: `NaN`.+cast from the value `\"john\"`/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"cast should return a default when undefined","suites":["Mixed Types "],"updatePoint":{"line":41,"column":49},"line":41,"code":"  it('cast should return a default when undefined', () => {\n    let inst = mixed().default('hello');\n\n    expect(inst.cast(undefined)).toBe('hello');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"getDefault should return the default value","suites":["Mixed Types "],"updatePoint":{"line":47,"column":48},"line":47,"code":"  it('getDefault should return the default value', function () {\n    let inst = string().default('hi');\n    expect(inst.getDefault({})).toBe('hi');\n    expect(inst.getDefault()).toBe('hi');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"getDefault should return the default value using context","suites":["Mixed Types "],"updatePoint":{"line":53,"column":62},"line":53,"code":"  it('getDefault should return the default value using context', function () {\n    let inst = string().when('$foo', {\n      is: 'greet',\n      then: (s) => s.default('hi'),\n    });\n    expect(inst.getDefault({ context: { foo: 'greet' } })).toBe('hi');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should use provided check","suites":["Mixed Types "],"updatePoint":{"line":61,"column":31},"line":61,"code":"  it('should use provided check', async () => {\n    let schema = mixed((v): v is string => typeof v === 'string');\n\n    // @ts-expect-error narrowed type\n    schema.default(1);\n\n    expect(schema.isType(1)).toBe(false);\n    expect(schema.isType('foo')).toBe(true);\n\n    await expect(schema.validate(1)).rejects.toThrowError(\n      /this must match the configured type\\. The validated value was: `1`/,\n    );\n\n    schema = mixed({\n      type: 'string',\n      check: (v): v is string => typeof v === 'string',\n    });\n\n    // @ts-expect-error narrowed type\n    schema.default(1);\n\n    expect(schema.isType(1)).toBe(false);\n    expect(schema.isType('foo')).toBe(true);\n\n    await expect(schema.validate(1)).rejects.toThrowError(\n      /this must be a `string` type/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should allow missing values with the \"ignore-optionality\" option","suites":["Mixed Types "],"updatePoint":{"line":90,"column":70},"line":90,"code":"  it('should allow missing values with the \"ignore-optionality\" option', () => {\n    expect(\n      string().required().cast(null, { assert: 'ignore-optionality' }),\n    ).toBe(null);\n\n    expect(\n      string().required().cast(undefined, { assert: 'ignore-optionality' }),\n    ).toBe(undefined);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should warn about null types","suites":["Mixed Types "],"updatePoint":{"line":100,"column":34},"line":100,"code":"  it('should warn about null types', async () => {\n    await expect(string().strict().validate(null)).rejects.toThrowError(\n      /this cannot be null/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should validateAt","suites":["Mixed Types "],"updatePoint":{"line":106,"column":23},"line":106,"code":"  it('should validateAt', async () => {\n    const schema = object({\n      foo: array().of(\n        object({\n          loose: bool(),\n          bar: string().when('loose', {\n            is: true,\n            otherwise: (s) => s.strict(),\n          }),\n        }),\n      ),\n    });\n    const value = {\n      foo: [{ bar: 1 }, { bar: 1, loose: true }],\n    };\n\n    await expect(schema.validateAt('foo[1].bar', value)).resolves.toBeDefined();\n\n    await expect(schema.validateAt('foo[0].bar', value)).rejects.toThrowError(\n      /bar must be a `string` type/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should print the original value","suites":["Mixed Types "],"updatePoint":{"line":147,"column":37},"line":147,"code":"  it('should print the original value', async () => {\n    await expect(number().validate('john')).rejects.toThrowError(\n      /the final value was: `NaN`.+cast from the value `\"john\"`/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should allow function messages","suites":["Mixed Types "],"updatePoint":{"line":153,"column":36},"line":153,"code":"  it('should allow function messages', async () => {\n    await expect(\n      string()\n        .label('My string')\n        .required((d) => `${d.label} is required`)\n        .validate(undefined),\n    ).rejects.toThrowError(/My string is required/);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should check types","suites":["Mixed Types "],"updatePoint":{"line":162,"column":24},"line":162,"code":"  it('should check types', async () => {\n    let inst = string().strict().typeError('must be a ${type}!');\n\n    await expect(inst.validate(5)).rejects.toEqual(\n      expect.objectContaining({\n        type: 'typeError',\n        message: 'must be a string!',\n        inner: [],\n      }),\n    );\n\n    await expect(inst.validate(5, { abortEarly: false })).rejects.toEqual(\n      expect.objectContaining({\n        type: undefined,\n        message: 'must be a string!',\n        inner: [expect.any(ValidationError)],\n      }),\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should limit values","suites":["Mixed Types "],"updatePoint":{"line":182,"column":25},"line":182,"code":"  it('should limit values', async () => {\n    let inst = mixed().oneOf([5, 'hello']);\n\n    await expect(inst.isValid(5)).resolves.toBe(true);\n    await expect(inst.isValid('hello')).resolves.toBe(true);\n\n    await expect(inst.validate(6)).rejects.toThrowError(\n      'this must be one of the following values: 5, hello',\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should limit values with a ref","suites":["Mixed Types "],"updatePoint":{"line":193,"column":36},"line":193,"code":"  it('should limit values with a ref', async () => {\n    let someValues = [1, 2, 3];\n    let context = { someValues };\n    let inst = mixed().oneOf([\n      ref('$someValues[0]'),\n      ref('$someValues[1]'),\n      ref('$someValues[2]'),\n    ]);\n    await expect(inst.validate(1, { context })).resolves.toBe(1);\n\n    await expect(inst.validate(4, { context })).rejects.toEqual(\n      expect.objectContaining({\n        type: 'oneOf',\n        params: expect.objectContaining({ resolved: someValues }),\n      }),\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should not require field when notRequired was set","suites":["Mixed Types "],"updatePoint":{"line":211,"column":55},"line":211,"code":"  it('should not require field when notRequired was set', async () => {\n    let inst = mixed().required();\n\n    await expect(inst.isValid('test')).resolves.toBe(true);\n    await expect(inst.isValid(1)).resolves.toBe(true);\n\n    await expect(inst.validate(undefined)).rejects.toThrowError(\n      'this is a required field',\n    );\n\n    inst = inst.notRequired();\n\n    await expect(inst.isValid(undefined)).resolves.toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should validate synchronously","suites":["Mixed Types ","synchronous methods"],"updatePoint":{"line":229,"column":39},"line":229,"code":"      it('should validate synchronously', async () => {\n        let schema = number();\n\n        expect(schema.isValidSync('john')).toBe(false);\n\n        expect(() => schema.validateSync('john')).toThrowError(\n          /the final value was: `NaN`.+cast from the value `\"john\"`/,\n        );\n      });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should isValid synchronously","suites":["Mixed Types ","synchronous methods"],"updatePoint":{"line":239,"column":38},"line":239,"code":"      it('should isValid synchronously', async () => {\n        let schema = number();\n\n        expect(schema.isValidSync('john')).toBe(false);\n      });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should throw on async test","suites":["Mixed Types ","synchronous methods"],"updatePoint":{"line":245,"column":36},"line":245,"code":"      it('should throw on async test', async () => {\n        let schema = mixed().test('test', 'foo', () => Promise.resolve(true));\n\n        await expect(\n          ensureSync(() => schema.validate('john')),\n        ).rejects.toThrowError(/Validation test of type: \"test\"/);\n      });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should work with refs","suites":["Mixed Types ","oneOf"],"updatePoint":{"line":267,"column":29},"line":267,"code":"    it('should work with refs', async () => {\n      let inst = object({\n        foo: string(),\n        bar: string().oneOf([ref('foo'), 'b']),\n      });\n\n      await expect(\n        inst.validate({ foo: 'a', bar: 'a' }),\n      ).resolves.toBeDefined();\n\n      await expect(\n        inst.validate({ foo: 'foo', bar: 'bar' }),\n      ).rejects.toThrowError();\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should throw the correct error","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":291,"column":38},"line":291,"code":"    it('should throw the correct error', async () => {\n      await expect(inst.validate(5)).rejects.toThrowError(\n        'this must not be one of the following values: 5, hello',\n      );\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should run subset of validations first","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":298,"column":44},"line":298,"code":"  it('should run subset of validations first', async () => {\n    let called = false;\n    let inst = string()\n      .strict()\n      .test('test', 'boom', () => (called = true));\n\n    await expect(inst.validate(25)).rejects.toThrowError();\n\n    expect(called).toBe(false);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should respect strict","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":309,"column":27},"line":309,"code":"  it('should respect strict', () => {\n    let inst = string().equals(['hello', '5']);\n\n    return Promise.all([\n      expect(inst.isValid(5)).resolves.toBe(true),\n      expect(inst.strict().isValid(5)).resolves.toBe(false),\n    ]);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should respect abortEarly","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":318,"column":31},"line":318,"code":"  it('should respect abortEarly', () => {\n    let inst = string().trim().min(10);\n\n    return Promise.all([\n      expect(inst.strict().validate(' hi ')).rejects.toThrowError(\n        /must be a trimmed string/,\n      ),\n\n      expect(\n        inst.strict().validate(' hi ', { abortEarly: false }),\n      ).rejects.toThrowError(/2 errors/),\n    ]);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should overload test()","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":332,"column":28},"line":332,"code":"  it('should overload test()', () => {\n    let inst = mixed().test('test', noop);\n\n    expect(inst.tests).toHaveLength(1);\n    expect(inst.tests[0]!.OPTIONS!.test).toBe(noop);\n    expect(inst.tests[0]!.OPTIONS!.message).toBe('${path} is invalid');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should fallback to default message","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":340,"column":40},"line":340,"code":"  it('should fallback to default message', async () => {\n    let inst = mixed().test(() => false);\n\n    await expect(inst.validate('foo')).rejects.toThrowError('this is invalid');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should allow non string messages","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":346,"column":38},"line":346,"code":"  it('should allow non string messages', async () => {\n    let message = { key: 'foo' };\n    let inst = mixed().test('test', message, () => false);\n\n    expect(inst.tests).toHaveLength(1);\n    expect(inst.tests[0]!.OPTIONS!.message).toBe(message);\n\n    let err = await inst.validate('foo').catch((err) => err);\n    expect(err.message).toEqual(message);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should dedupe tests with the same test function","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":357,"column":53},"line":357,"code":"  it('should dedupe tests with the same test function', () => {\n    let inst = mixed().test('test', ' ', noop).test('test', 'asdasd', noop);\n\n    expect(inst.tests).toHaveLength(1);\n    expect(inst.tests[0]!.OPTIONS!.message).toBe('asdasd');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should not dedupe tests with the same test function and different type","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":364,"column":76},"line":364,"code":"  it('should not dedupe tests with the same test function and different type', () => {\n    let inst = mixed().test('test', ' ', noop).test('test-two', 'asdasd', noop);\n\n    expect(inst.tests).toHaveLength(2);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should respect exclusive validation","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":370,"column":41},"line":370,"code":"  it('should respect exclusive validation', () => {\n    let inst = mixed().test({\n      message: 'invalid',\n      exclusive: true,\n      name: 'test',\n      test: () => {},\n    });\n\n    //.test({ message: 'also invalid', name: 'test', test: () => {} });\n\n    expect(inst.tests).toHaveLength(1);\n\n    inst = mixed()\n      .test({ message: 'invalid', name: 'test', test: () => {} })\n      .test({ message: 'also invalid', name: 'test', test: () => {} });\n\n    expect(inst.tests).toHaveLength(2);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should non-exclusive tests should stack","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":389,"column":45},"line":389,"code":"  it('should non-exclusive tests should stack', () => {\n    let inst = mixed()\n      .test({ name: 'test', message: ' ', test: () => {} })\n      .test({ name: 'test', message: ' ', test: () => {} });\n\n    expect(inst.tests).toHaveLength(2);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should replace existing tests, with exclusive test ","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":397,"column":57},"line":397,"code":"  it('should replace existing tests, with exclusive test ', () => {\n    let inst = mixed()\n      .test({ name: 'test', message: ' ', test: noop })\n      .test({ name: 'test', exclusive: true, message: ' ', test: noop });\n\n    expect(inst.tests).toHaveLength(1);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should replace existing exclusive tests, with non-exclusive","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":405,"column":65},"line":405,"code":"  it('should replace existing exclusive tests, with non-exclusive', () => {\n    let inst = mixed()\n      .test({ name: 'test', exclusive: true, message: ' ', test: () => {} })\n      .test({ name: 'test', message: ' ', test: () => {} })\n      .test({ name: 'test', message: ' ', test: () => {} });\n\n    expect(inst.tests).toHaveLength(2);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"exclusive tests should throw without a name","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":414,"column":49},"line":414,"code":"  it('exclusive tests should throw without a name', () => {\n    expect(() => {\n      mixed().test({ message: 'invalid', exclusive: true, test: noop });\n    }).toThrowError();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"exclusive tests should replace previous ones","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":420,"column":50},"line":420,"code":"  it('exclusive tests should replace previous ones', async () => {\n    let inst = mixed().test({\n      message: 'invalid',\n      exclusive: true,\n      name: 'max',\n      test: (v) => v < 5,\n    });\n\n    expect(await inst.isValid(8)).toBe(false);\n\n    expect(\n      await inst\n        .test({\n          message: 'invalid',\n          exclusive: true,\n          name: 'max',\n          test: (v) => v < 10,\n        })\n        .isValid(8),\n    ).toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"tests should be called with the correct `this`","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":442,"column":52},"line":442,"code":"  it('tests should be called with the correct `this`', async () => {\n    let called = false;\n    let inst = object({\n      other: mixed(),\n      test: mixed().test({\n        message: 'invalid',\n        exclusive: true,\n        name: 'max',\n        test() {\n          expect(this.path).toBe('test');\n          expect(this.parent).toEqual({ other: 5, test: 'hi' });\n          expect(this.options.context).toEqual({ user: 'jason' });\n          called = true;\n          return true;\n        },\n      }),\n    });\n\n    await inst.validate(\n      { other: 5, test: 'hi' },\n      { context: { user: 'jason' } },\n    );\n\n    expect(called).toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"tests should be able to access nested parent","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":468,"column":50},"line":468,"code":"  it('tests should be able to access nested parent', async () => {\n    let finalFrom: any, finalOptions: any;\n    let testFixture = {\n      firstField: 'test',\n      second: [\n        {\n          thirdField: 'test3',\n        },\n        {\n          thirdField: 'test4',\n        },\n      ],\n    };\n\n    let third = object({\n      thirdField: mixed().test({\n        test() {\n          finalFrom = this.from!;\n          finalOptions = this.options;\n          return true;\n        },\n      }),\n    });\n\n    let second = array().of(third);\n\n    let first = object({\n      firstField: mixed(),\n      second,\n    });\n\n    await first.validate(testFixture);\n    // console.log(finalFrom);\n    expect(finalFrom[0].value).toEqual(testFixture.second[finalOptions.index]);\n    expect(finalFrom[0].schema).toBe(third);\n    expect(finalFrom[1].value).toBe(testFixture);\n    expect(finalFrom[1].schema).toBe(first);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"tests can return an error","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":507,"column":31},"line":507,"code":"  it('tests can return an error', () => {\n    let inst = mixed().test({\n      message: 'invalid ${path}',\n      name: 'max',\n      test() {\n        return this.createError({ path: 'my.path' });\n      },\n    });\n\n    return expect(inst.validate('')).rejects.toEqual(\n      expect.objectContaining({\n        path: 'my.path',\n        errors: ['invalid my.path'],\n      }),\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should use returned error path and message","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":524,"column":48},"line":524,"code":"  it('should use returned error path and message', () => {\n    let inst = mixed().test({\n      message: 'invalid ${path}',\n      name: 'max',\n      test: function () {\n        return this.createError({ message: '${path} nope!', path: 'my.path' });\n      },\n    });\n\n    return expect(inst.validate({ other: 5, test: 'hi' })).rejects.toEqual(\n      expect.objectContaining({\n        path: 'my.path',\n        errors: ['my.path nope!'],\n      }),\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should allow custom validation","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":541,"column":36},"line":541,"code":"  it('should allow custom validation', async () => {\n    let inst = string().test('name', 'test a', (val) => val === 'jim');\n\n    return expect(inst.validate('joe')).rejects.toThrowError('test a');\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should fail when the test function returns a rejected Promise","suites":["Mixed Types ","should exclude values"],"updatePoint":{"line":549,"column":69},"line":549,"code":"    it('should fail when the test function returns a rejected Promise', async () => {\n      let inst = string().test(() => {\n        return Promise.reject(new Error('oops an error occurred'));\n      });\n\n      return expect(inst.validate('joe')).rejects.toThrowError(\n        'oops an error occurred',\n      );\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should pass the same instance to a provided function","suites":["Mixed Types ","withMutation"],"updatePoint":{"line":560,"column":60},"line":560,"code":"    it('should pass the same instance to a provided function', () => {\n      let inst = mixed();\n      let func = jest.fn();\n\n      inst.withMutation(func);\n\n      expect(func).toHaveBeenCalledWith(inst);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should temporarily make mutable","suites":["Mixed Types ","withMutation"],"updatePoint":{"line":569,"column":39},"line":569,"code":"    it('should temporarily make mutable', () => {\n      let inst = mixed();\n\n      expect(inst.tests).toHaveLength(0);\n\n      inst.withMutation((inst) => {\n        inst.test('a', () => true);\n      });\n\n      expect(inst.tests).toHaveLength(1);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should return immutability","suites":["Mixed Types ","withMutation"],"updatePoint":{"line":581,"column":34},"line":581,"code":"    it('should return immutability', () => {\n      let inst = mixed();\n      inst.withMutation(() => {});\n\n      expect(inst.tests).toHaveLength(0);\n\n      inst.test('a', () => true);\n\n      expect(inst.tests).toHaveLength(0);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should work with nesting","suites":["Mixed Types ","withMutation"],"updatePoint":{"line":592,"column":32},"line":592,"code":"    it('should work with nesting', () => {\n      let inst = mixed();\n\n      expect(inst.tests).toHaveLength(0);\n\n      inst.withMutation((inst) => {\n        inst.withMutation((inst) => {\n          inst.test('a', () => true);\n        });\n        inst.test('b', () => true);\n      });\n\n      expect(inst.tests).toHaveLength(2);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should have the correct number of tests","suites":["Mixed Types ","concat"],"updatePoint":{"line":629,"column":47},"line":629,"code":"    it('should have the correct number of tests', () => {\n      expect(reach(next, 'str').tests).toHaveLength(2);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should have the tests in the correct order","suites":["Mixed Types ","concat"],"updatePoint":{"line":633,"column":50},"line":633,"code":"    it('should have the tests in the correct order', () => {\n      expect(reach(next, 'str').tests[0].OPTIONS.name).toBe('required');\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should validate correctly","suites":["Mixed Types ","concat"],"updatePoint":{"line":637,"column":33},"line":637,"code":"    it('should validate correctly', async () => {\n      await expect(\n        inst.isValid({ str: 'hi', str2: 'hi', obj: {} }),\n      ).resolves.toBe(true);\n\n      await expect(\n        next.validate({ str: ' hi  ', str2: 'hi', obj: { str: 'hi' } }),\n      ).resolves.toEqual({\n        str: 'hi',\n        str2: 'hi',\n        obj: { str: 'hi' },\n      });\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should throw the correct validation errors","suites":["Mixed Types ","concat"],"updatePoint":{"line":651,"column":50},"line":651,"code":"    it('should throw the correct validation errors', async () => {\n      await expect(\n        next.validate({ str: 'hi', str2: 'hi', obj: {} }),\n      ).rejects.toThrowError('obj.str is a required field');\n\n      await expect(\n        next.validate({ str2: 'hi', obj: { str: 'hi' } }),\n      ).rejects.toThrowError('str is a required field');\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should carry over transforms","suites":["Mixed Types ","concat"],"updatePoint":{"line":662,"column":41},"line":662,"code":"  it('concat should carry over transforms', async () => {\n    let inst = string().trim();\n\n    await expect(inst.concat(string().min(4)).cast(' hello  ')).toBe('hello');\n\n    await expect(inst.concat(string().min(4)).isValid(' he  ')).resolves.toBe(\n      false,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should fail on different types","suites":["Mixed Types ","concat"],"updatePoint":{"line":672,"column":43},"line":672,"code":"  it('concat should fail on different types', function () {\n    let inst = string().default('hi');\n\n    expect(function () {\n      // @ts-expect-error invalid combo\n      inst.concat(object());\n    }).toThrowError(TypeError);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should not overwrite label and meta with undefined","suites":["Mixed Types ","concat"],"updatePoint":{"line":681,"column":63},"line":681,"code":"  it('concat should not overwrite label and meta with undefined', function () {\n    const testLabel = 'Test Label';\n    const testMeta = {\n      testField: 'test field',\n    };\n    let baseSchema = mixed().label(testLabel).meta(testMeta);\n    const otherSchema = mixed();\n\n    baseSchema = baseSchema.concat(otherSchema);\n    expect(baseSchema.spec.label).toBe(testLabel);\n    expect(baseSchema.spec.meta.testField).toBe(testMeta.testField);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should allow mixed and other type","suites":["Mixed Types ","concat"],"updatePoint":{"line":694,"column":46},"line":694,"code":"  it('concat should allow mixed and other type', function () {\n    let inst = mixed().default('hi');\n\n    expect(function () {\n      expect(inst.concat(string()).type).toBe('string');\n    }).not.toThrowError(TypeError);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should validate with mixed and other type","suites":["Mixed Types ","concat"],"updatePoint":{"line":702,"column":54},"line":702,"code":"  it('concat should validate with mixed and other type', async function () {\n    let inst = mixed().concat(number());\n\n    await expect(inst.validate([])).rejects.toThrowError(\n      /must be a `number` type/,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should maintain undefined defaults","suites":["Mixed Types ","concat"],"updatePoint":{"line":710,"column":47},"line":710,"code":"  it('concat should maintain undefined defaults', function () {\n    let inst = string().default('hi');\n\n    expect(\n      inst.concat(string().default(undefined)).getDefault(),\n    ).toBeUndefined();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should preserve oneOf","suites":["Mixed Types ","concat"],"updatePoint":{"line":718,"column":34},"line":718,"code":"  it('concat should preserve oneOf', async function () {\n    let inst = string().oneOf(['a']).concat(string().default('hi'));\n\n    await expect(inst.isValid('a')).resolves.toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concat should override presence","suites":["Mixed Types ","concat"],"updatePoint":{"line":724,"column":37},"line":724,"code":"  it('concat should override presence', async function () {\n    let inst = string().required().concat(string().nullable());\n\n    await expect(inst.isValid(undefined)).resolves.toBe(true);\n    await expect(inst.isValid(null)).resolves.toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"gives whitelist precedence to second in concat","suites":["Mixed Types ","concat"],"updatePoint":{"line":731,"column":52},"line":731,"code":"  it('gives whitelist precedence to second in concat', async function () {\n    let inst = string()\n      .oneOf(['a', 'b', 'c'])\n      .concat(string().notOneOf(['b']));\n\n    await expect(inst.isValid('a')).resolves.toBe(true);\n    await expect(inst.isValid('b')).resolves.toBe(false);\n    await expect(inst.isValid('c')).resolves.toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"gives blacklist precedence to second in concat","suites":["Mixed Types ","concat"],"updatePoint":{"line":741,"column":52},"line":741,"code":"  it('gives blacklist precedence to second in concat', async function () {\n    let inst = string()\n      .notOneOf(['a', 'b', 'c'])\n      .concat(string().oneOf(['b', 'c']));\n\n    await expect(inst.isValid('a')).resolves.toBe(false);\n    await expect(inst.isValid('b')).resolves.toBe(true);\n    await expect(inst.isValid('c')).resolves.toBe(true);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"concats whitelist with refs","suites":["Mixed Types ","concat"],"updatePoint":{"line":751,"column":33},"line":751,"code":"  it('concats whitelist with refs', async function () {\n    let inst = object({\n      x: string().required(),\n      y: string()\n        .oneOf([ref('$x'), 'b', 'c'])\n        .concat(string().notOneOf(['c', ref('$x')])),\n    });\n\n    await expect(inst.isValid({ x: 'a', y: 'a' })).resolves.toBe(false);\n    await expect(inst.isValid({ x: 'a', y: 'b' })).resolves.toBe(true);\n    await expect(inst.isValid({ x: 'a', y: 'c' })).resolves.toBe(false);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"defaults should be validated but not transformed","suites":["Mixed Types ","concat"],"updatePoint":{"line":764,"column":54},"line":764,"code":"  it('defaults should be validated but not transformed', function () {\n    let inst = string().trim().default('  hi  ');\n\n    return expect(inst.validate(undefined)).rejects.toThrowError(\n      'this must be a trimmed string',\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should handle conditionals","suites":["Mixed Types ","concat"],"updatePoint":{"line":772,"column":32},"line":772,"code":"  it('should handle conditionals', async function () {\n    let inst = mixed().when('prop', {\n      is: 5,\n      then: (s) => s.required('from parent'),\n    });\n\n    await expect(\n      inst.validate(undefined, { parent: { prop: 5 } } as any),\n    ).rejects.toThrowError();\n    await expect(\n      inst.validate(undefined, { parent: { prop: 1 } } as any),\n    ).resolves.toBeUndefined();\n    await expect(\n      inst.validate('hello', { parent: { prop: 5 } } as any),\n    ).resolves.toBeDefined();\n\n    inst = string().when('prop', {\n      is: 5,\n      then: (s) => s.required(),\n      otherwise: (s) => s.min(4),\n    });\n\n    await expect(\n      inst.validate(undefined, { parent: { prop: 5 } } as any),\n    ).rejects.toThrowError();\n    await expect(\n      inst.validate('hello', { parent: { prop: 1 } } as any),\n    ).resolves.toBeDefined();\n    await expect(\n      inst.validate('hel', { parent: { prop: 1 } } as any),\n    ).rejects.toThrowError();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should handle multiple conditionals","suites":["Mixed Types ","concat"],"updatePoint":{"line":805,"column":41},"line":805,"code":"  it('should handle multiple conditionals', function () {\n    let called = false;\n    let inst = mixed().when(['$prop', '$other'], ([prop, other], schema) => {\n      expect(other).toBe(true);\n      expect(prop).toBe(1);\n      called = true;\n\n      return schema;\n    });\n\n    inst.cast({}, { context: { prop: 1, other: true } });\n    expect(called).toBe(true);\n\n    inst = mixed().when(['$prop', '$other'], {\n      is: 5,\n      then: (s) => s.required(),\n    });\n\n    return expect(\n      inst.isValid(undefined, { context: { prop: 5, other: 5 } }),\n    ).resolves.toBe(false);\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should require context when needed","suites":["Mixed Types ","concat"],"updatePoint":{"line":828,"column":40},"line":828,"code":"  it('should require context when needed', async function () {\n    let inst = mixed().when('$prop', {\n      is: 5,\n      then: (s) => s.required('from context'),\n    });\n\n    await expect(\n      inst.validate(undefined, { context: { prop: 5 } }),\n    ).rejects.toThrowError();\n    await expect(\n      inst.validate(undefined, { context: { prop: 1 } }),\n    ).resolves.toBeUndefined();\n    await expect(\n      inst.validate('hello', { context: { prop: 5 } }),\n    ).resolves.toBeDefined();\n\n    inst = string().when('$prop', {\n      is: (val: any) => val === 5,\n      then: (s) => s.required(),\n      otherwise: (s) => s.min(4),\n    });\n\n    await expect(\n      inst.validate(undefined, { context: { prop: 5 } }),\n    ).rejects.toThrowError();\n    await expect(\n      inst.validate('hello', { context: { prop: 1 } }),\n    ).resolves.toBeDefined();\n    await expect(\n      inst.validate('hel', { context: { prop: 1 } }),\n    ).rejects.toThrowError();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should not use context refs in object calculations","suites":["Mixed Types ","concat"],"updatePoint":{"line":861,"column":56},"line":861,"code":"  it('should not use context refs in object calculations', function () {\n    let inst = object({\n      prop: string().when('$prop', {\n        is: 5,\n        then: (s) => s.required('from context'),\n      }),\n    });\n\n    expect(inst.getDefault()).toEqual({ prop: undefined });\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should support self references in conditions","suites":["Mixed Types ","concat"],"updatePoint":{"line":872,"column":50},"line":872,"code":"  it('should support self references in conditions', async function () {\n    let inst = number().when('.', {\n      is: (value: number) => value > 0,\n      then: (s) => s.min(5),\n    });\n\n    await expect(inst.validate(4)).rejects.toThrowError(/must be greater/);\n\n    await expect(inst.validate(5)).resolves.toBeDefined();\n\n    await expect(inst.validate(-1)).resolves.toBeDefined();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should support conditional single argument as options shortcut","suites":["Mixed Types ","concat"],"updatePoint":{"line":885,"column":68},"line":885,"code":"  it('should support conditional single argument as options shortcut', async function () {\n    let inst = number().when({\n      is: (value: number) => value > 0,\n      then: (s) => s.min(5),\n    });\n\n    await expect(inst.validate(4)).rejects.toThrowError(/must be greater/);\n\n    await expect(inst.validate(5)).resolves.toBeDefined();\n\n    await expect(inst.validate(-1)).resolves.toBeDefined();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should allow nested conditions and lazies","suites":["Mixed Types ","concat"],"updatePoint":{"line":898,"column":47},"line":898,"code":"  it('should allow nested conditions and lazies', async function () {\n    let inst = string().when('$check', {\n      is: (value: any) => typeof value === 'string',\n      then: (s) =>\n        s.when('$check', {\n          is: (value: any) => /hello/.test(value),\n          then: () => lazy(() => string().min(6)),\n        }),\n    });\n\n    await expect(\n      inst.validate('pass', { context: { check: false } }),\n    ).resolves.toBeDefined();\n\n    await expect(\n      inst.validate('pass', { context: { check: 'hello' } }),\n    ).rejects.toThrowError(/must be at least/);\n\n    await expect(\n      inst.validate('passes', { context: { check: 'hello' } }),\n    ).resolves.toBeDefined();\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should use label in error message","suites":["Mixed Types ","concat"],"updatePoint":{"line":921,"column":39},"line":921,"code":"  it('should use label in error message', async function () {\n    let label = 'Label';\n    let inst = object({\n      prop: string().required().label(label),\n    });\n\n    await expect(inst.validate({})).rejects.toThrowError(\n      `${label} is a required field`,\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should add meta() data","suites":["Mixed Types ","concat"],"updatePoint":{"line":932,"column":28},"line":932,"code":"  it('should add meta() data', () => {\n    expect(string().meta({ input: 'foo' }).meta({ foo: 'bar' }).meta()).toEqual(\n      {\n        input: 'foo',\n        foo: 'bar',\n      },\n    );\n  });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should describe","suites":["Mixed Types ","schema.describe()"],"updatePoint":{"line":960,"column":23},"line":960,"code":"    it('should describe', () => {\n      expect(schema.describe()).toEqual({\n        type: 'object',\n        meta: undefined,\n        label: undefined,\n        nullable: false,\n        optional: true,\n        tests: [],\n        oneOf: [],\n        notOneOf: [],\n        fields: {\n          lazy: {\n            type: 'lazy',\n            meta: undefined,\n            label: undefined,\n          },\n          foo: {\n            type: 'array',\n            meta: undefined,\n            label: undefined,\n            nullable: false,\n            optional: false,\n            tests: [],\n            oneOf: [],\n            notOneOf: [],\n            innerType: {\n              type: 'number',\n              meta: undefined,\n              label: undefined,\n              nullable: false,\n              optional: true,\n              oneOf: [],\n              notOneOf: [],\n              tests: [\n                {\n                  name: 'integer',\n                  params: undefined,\n                },\n              ],\n            },\n          },\n          bar: {\n            type: 'string',\n            label: 'str!',\n            tests: [{ name: 'max', params: { max: 2 } }],\n            meta: {\n              input: 'foo',\n            },\n            nullable: false,\n            optional: true,\n            oneOf: ['a', 'b'],\n            notOneOf: [\n              {\n                type: 'ref',\n                key: 'foo',\n              },\n            ],\n          },\n        },\n      });\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should describe with options","suites":["Mixed Types ","schema.describe()"],"updatePoint":{"line":1022,"column":36},"line":1022,"code":"    it('should describe with options', () => {\n      expect(schema.describe({ value: { lazy: 'entered' } })).toEqual({\n        type: 'object',\n        meta: undefined,\n        label: undefined,\n        nullable: false,\n        optional: true,\n        tests: [],\n        oneOf: [],\n        notOneOf: [],\n        fields: {\n          lazy: {\n            type: 'string',\n            meta: undefined,\n            label: undefined,\n            nullable: true,\n            optional: true,\n            oneOf: [],\n            notOneOf: [],\n            tests: [],\n          },\n          foo: {\n            type: 'array',\n            meta: undefined,\n            label: undefined,\n            nullable: false,\n            optional: false,\n            tests: [],\n            oneOf: [],\n            notOneOf: [],\n            innerType: {\n              type: 'number',\n              meta: undefined,\n              label: undefined,\n              nullable: false,\n              optional: true,\n              oneOf: [],\n              notOneOf: [],\n              tests: [\n                {\n                  name: 'integer',\n                  params: undefined,\n                },\n              ],\n            },\n          },\n          bar: {\n            type: 'string',\n            label: 'str!',\n            tests: [{ name: 'max', params: { max: 2 } }],\n            meta: {\n              input: 'foo',\n            },\n            nullable: false,\n            optional: false,\n            oneOf: ['a', 'b'],\n            notOneOf: [\n              {\n                type: 'ref',\n                key: 'foo',\n              },\n            ],\n          },\n        },\n      });\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should fail when value is undefined","suites":["Mixed Types ","defined"],"updatePoint":{"line":1091,"column":43},"line":1091,"code":"    it('should fail when value is undefined', async () => {\n      let inst = object({\n        prop: string().defined(),\n      });\n\n      await expect(inst.validate({})).rejects.toThrowError(\n        'prop must be defined',\n      );\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should pass when value is null","suites":["Mixed Types ","defined"],"updatePoint":{"line":1101,"column":38},"line":1101,"code":"    it('should pass when value is null', async () => {\n      let inst = object({\n        prop: string().nullable().defined(),\n      });\n\n      await expect(inst.isValid({ prop: null })).resolves.toBe(true);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"should pass when value is not undefined","suites":["Mixed Types ","defined"],"updatePoint":{"line":1109,"column":47},"line":1109,"code":"    it('should pass when value is not undefined', async () => {\n      let inst = object({\n        prop: string().defined(),\n      });\n\n      await expect(inst.isValid({ prop: 'prop value' })).resolves.toBe(true);\n    });","file":"mixed.ts","skipped":false,"dir":"test"},{"name":"is extensible","suites":["Number types"],"updatePoint":{"line":6,"column":19},"line":6,"code":"  it('is extensible', () => {\n    class MyNumber extends NumberSchema {\n      foo() {\n        return this;\n      }\n    }\n\n    new MyNumber().foo().integer().required();\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should round","suites":["Number types","casting"],"updatePoint":{"line":29,"column":20},"line":29,"code":"    it('should round', () => {\n      // @ts-expect-error stricter type than accepted\n      expect(schema.round('ceIl').cast(45.1111)).toBe(46);\n\n      expect(schema.round().cast(45.444444)).toBe(45);\n\n      expect(schema.nullable().integer().round().cast(null)).toBeNull();\n      expect(function () {\n        // @ts-expect-error testing incorrectness\n        schema.round('fasf');\n      }).toThrowError(TypeError);\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should truncate","suites":["Number types","casting"],"updatePoint":{"line":42,"column":23},"line":42,"code":"    it('should truncate', () => {\n      expect(schema.truncate().cast(45.55)).toBe(45);\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should return NaN for failed casts","suites":["Number types","casting"],"updatePoint":{"line":46,"column":42},"line":46,"code":"    it('should return NaN for failed casts', () => {\n      expect(number().cast('asfasf', { assert: false })).toEqual(NaN);\n\n      expect(number().cast(null, { assert: false })).toEqual(NaN);\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should handle DEFAULT","suites":["Number types","casting"],"updatePoint":{"line":53,"column":27},"line":53,"code":"  it('should handle DEFAULT', function () {\n    let inst = number().default(0);\n\n    expect(inst.getDefault()).toBe(0);\n    expect(inst.default(5).required().getDefault()).toBe(5);\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["Number types","casting"],"updatePoint":{"line":60,"column":23},"line":60,"code":"  it('should type check', function () {\n    let inst = number();\n\n    expect(inst.isType(5)).toBe(true);\n    expect(inst.isType(new Number(5))).toBe(true);\n    expect(inst.isType(new Number('foo'))).toBe(false);\n    expect(inst.isType(false)).toBe(false);\n    expect(inst.isType(null)).toBe(false);\n    expect(inst.isType(NaN)).toBe(false);\n    expect(inst.nullable().isType(null)).toBe(true);\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should VALIDATE correctly","suites":["Number types","casting"],"updatePoint":{"line":72,"column":31},"line":72,"code":"  it('should VALIDATE correctly', function () {\n    let inst = number().required().min(4);\n\n    return Promise.all([\n      expect(number().isValid(null)).resolves.toBe(false),\n      expect(number().nullable().isValid(null)).resolves.toBe(true),\n      expect(number().isValid(' ')).resolves.toBe(false),\n      expect(number().isValid('12abc')).resolves.toBe(false),\n      expect(number().isValid(0xff)).resolves.toBe(true),\n      expect(number().isValid('0xff')).resolves.toBe(true),\n\n      expect(inst.isValid(5)).resolves.toBe(true),\n      expect(inst.isValid(2)).resolves.toBe(false),\n\n      expect(inst.validate(undefined)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages(\n          expect.stringContaining('required'),\n        ),\n      ),\n    ]);\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should return default message","suites":["Number types","lessThan"],"updatePoint":{"line":120,"column":37},"line":120,"code":"    it('should return default message', async () => {\n      await expect(schema.validate(6)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages('this must be less than 5'),\n      );\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should return default message","suites":["Number types","moreThan"],"updatePoint":{"line":135,"column":37},"line":135,"code":"    it('should return default message', async () => {\n      await expect(schema.validate(4)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages(\n          expect.stringContaining('this must be greater than 5'),\n        ),\n      );\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should return default message","suites":["Number types","integer"],"updatePoint":{"line":152,"column":37},"line":152,"code":"    it('should return default message', async () => {\n      await expect(schema.validate(10.53)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages('this must be an integer'),\n      );\n    });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should check POSITIVE correctly","suites":["Number types","integer"],"updatePoint":{"line":159,"column":37},"line":159,"code":"  it('should check POSITIVE correctly', function () {\n    let v = number().positive();\n\n    return Promise.all([\n      expect(v.isValid(7)).resolves.toBe(true),\n\n      expect(v.isValid(0)).resolves.toBe(false),\n\n      expect(v.validate(0)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages(\n          'this must be a positive number',\n        ),\n      ),\n    ]);\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should check NEGATIVE correctly","suites":["Number types","integer"],"updatePoint":{"line":175,"column":37},"line":175,"code":"  it('should check NEGATIVE correctly', function () {\n    let v = number().negative();\n\n    return Promise.all([\n      expect(v.isValid(-4)).resolves.toBe(true),\n\n      expect(v.isValid(0)).resolves.toBe(false),\n\n      expect(v.validate(10)).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages(\n          'this must be a negative number',\n        ),\n      ),\n    ]);\n  });","file":"number.ts","skipped":false,"dir":"test"},{"name":"should parse json strings","suites":["Object types","casting"],"updatePoint":{"line":38,"column":33},"line":38,"code":"    it('should parse json strings', () => {\n      expect(\n        object({ hello: number() }).json().cast('{ \"hello\": \"5\" }'),\n      ).toEqual({\n        hello: 5,\n      });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should return input for failed casts","suites":["Object types","casting"],"updatePoint":{"line":46,"column":44},"line":46,"code":"    it('should return input for failed casts', () => {\n      expect(object().cast('dfhdfh', { assert: false })).toBe('dfhdfh');\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should recursively cast fields","suites":["Object types","casting"],"updatePoint":{"line":50,"column":38},"line":50,"code":"    it('should recursively cast fields', () => {\n      let obj = {\n        num: '5',\n        str: 'hello',\n        arr: ['4', 5],\n        dte: '2014-09-23T19:25:25Z',\n        nested: { str: 5 },\n        arrNested: [{ num: 5 }, { num: '5' }],\n      };\n\n      const cast = inst.cast(obj);\n\n      expect(cast).toEqual({\n        num: 5,\n        str: 'hello',\n        arr: [4, 5],\n        dte: new Date(1411500325000),\n        nested: { str: '5' },\n        arrNested: [{ num: 5 }, { num: 5 }],\n      });\n\n      expect(cast.arrNested![0]).toBe(obj.arrNested[0]);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should return the same object if all props are already cast","suites":["Object types","casting"],"updatePoint":{"line":74,"column":67},"line":74,"code":"    it('should return the same object if all props are already cast', () => {\n      let obj = {\n        num: 5,\n        str: 'hello',\n        arr: [4, 5],\n        dte: new Date(1411500325000),\n        nested: { str: '5' },\n        arrNested: [{ num: 5 }, { num: 5 }],\n      };\n\n      expect(inst.cast(obj)).toBe(obj);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should run validations recursively","suites":["Object types","validation"],"updatePoint":{"line":89,"column":42},"line":89,"code":"    it('should run validations recursively', async () => {\n      let inst = object({\n        num: number(),\n        str: string(),\n        arr: array().of(number()),\n        dte: date(),\n        nested: object().shape({ str: string().strict() }),\n        arrNested: array().of(object().shape({ num: number() })),\n        stripped: string().strip(),\n      });\n\n      let obj: AnyObject = {\n        num: '4',\n        str: 'hello',\n        arr: ['4', 5, 6],\n        dte: '2014-09-23T19:25:25Z',\n        nested: { str: 5 },\n        arrNested: [{ num: 5 }, { num: '2' }],\n      };\n\n      await expect(inst.isValid(undefined)).resolves.toBe(true);\n\n      await expect(inst.validate(obj)).rejects.toEqual(\n        validationErrorWithMessages(expect.stringContaining('nested.str')),\n      );\n\n      obj.nested.str = 'hello';\n      obj.arrNested[1] = 8;\n\n      await expect(inst.validate(obj)).rejects.toEqual(\n        validationErrorWithMessages(expect.stringContaining('arrNested[1]')),\n      );\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should prevent recursive casting","suites":["Object types","validation"],"updatePoint":{"line":123,"column":40},"line":123,"code":"    it('should prevent recursive casting', async () => {\n      let castSpy = jest.spyOn(StringSchema.prototype, '_cast' as any);\n\n      let inst = object({\n        field: string(),\n      });\n\n      let value = await inst.validate({ field: 5 });\n\n      expect(value.field).toBe('5');\n\n      expect(castSpy).toHaveBeenCalledTimes(1);\n\n      castSpy.mockRestore();\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should respect strict for nested values","suites":["Object types","validation"],"updatePoint":{"line":139,"column":47},"line":139,"code":"    it('should respect strict for nested values', async () => {\n      let inst = object({\n        field: string(),\n      }).strict();\n\n      await expect(inst.validate({ field: 5 })).rejects.toThrowError(\n        /must be a `string` type/,\n      );\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should respect strict for nested object values","suites":["Object types","validation"],"updatePoint":{"line":149,"column":54},"line":149,"code":"    it('should respect strict for nested object values', async () => {\n      let inst = object({\n        obj: object({\n          field: string().strict(),\n        }),\n      });\n\n      await expect(inst.validate({ obj: { field: 5 } })).rejects.toThrowError(\n        /must be a `string` type/,\n      );\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should respect child schema with strict()","suites":["Object types","validation"],"updatePoint":{"line":161,"column":49},"line":161,"code":"    it('should respect child schema with strict()', async () => {\n      let inst = object({\n        field: number().strict(),\n      });\n\n      await expect(inst.validate({ field: '5' })).rejects.toThrowError(\n        /must be a `number` type/,\n      );\n\n      expect(inst.cast({ field: '5' })).toEqual({ field: 5 });\n\n      await expect(\n        object({\n          port: number().strict().integer(),\n        }).validate({ port: 'asdad' }),\n      ).rejects.toThrowError();\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle custom validation","suites":["Object types","validation"],"updatePoint":{"line":179,"column":39},"line":179,"code":"    it('should handle custom validation', async () => {\n      let inst = object()\n        .shape({\n          prop: mixed(),\n          other: mixed(),\n        })\n        .test('test', '${path} oops', () => false);\n\n      await expect(inst.validate({})).rejects.toThrowError('this oops');\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should not clone during validating","suites":["Object types","validation"],"updatePoint":{"line":190,"column":42},"line":190,"code":"    it('should not clone during validating', async function () {\n      let inst = object({\n        num: number(),\n        str: string(),\n        arr: array().of(number()),\n        dte: date(),\n        nested: object().shape({ str: string() }),\n        arrNested: array().of(object().shape({ num: number() })),\n        stripped: string().strip(),\n      });\n\n      let base = MixedSchema.prototype.clone;\n\n      MixedSchema.prototype.clone = function (...args) {\n        // @ts-expect-error private property\n        if (!this._mutate) throw new Error('should not call clone');\n\n        return base.apply(this, args);\n      };\n\n      try {\n        await inst.validate({\n          nested: { str: 'jimmm' },\n          arrNested: [{ num: 5 }, { num: '2' }],\n        });\n        await inst.validate({\n          nested: { str: 5 },\n          arrNested: [{ num: 5 }, { num: '2' }],\n        });\n      } catch (err) {\n        /* ignore */\n      } finally {\n        //eslint-disable-line\n        MixedSchema.prototype.clone = base;\n      }\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should pass options to children","suites":["Object types","validation"],"updatePoint":{"line":228,"column":37},"line":228,"code":"  it('should pass options to children', function () {\n    expect(\n      object({\n        names: object({\n          first: string(),\n        }),\n      }).cast(\n        {\n          extra: true,\n          names: { first: 'john', extra: true },\n        },\n        { stripUnknown: true },\n      ),\n    ).toEqual({\n      names: {\n        first: 'john',\n      },\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should call shape with constructed with an arg","suites":["Object types","validation"],"updatePoint":{"line":248,"column":52},"line":248,"code":"  it('should call shape with constructed with an arg', () => {\n    let inst = object({\n      prop: mixed(),\n    });\n\n    expect(inst.fields.prop).toBeDefined();\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should expand objects by default","suites":["Object types","object defaults"],"updatePoint":{"line":270,"column":40},"line":270,"code":"    it('should expand objects by default', () => {\n      expect(objSchema.getDefault()).toEqual({\n        nest: { str: 'hi' },\n      });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should accept a user provided default","suites":["Object types","object defaults"],"updatePoint":{"line":276,"column":45},"line":276,"code":"    it('should accept a user provided default', () => {\n      let schema = objSchema.default({ boom: 'hi' });\n\n      expect(schema.getDefault()).toEqual({\n        boom: 'hi',\n      });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should add empty keys when sub schema has no default","suites":["Object types","object defaults"],"updatePoint":{"line":284,"column":60},"line":284,"code":"    it('should add empty keys when sub schema has no default', () => {\n      expect(\n        object({\n          str: string(),\n          nest: object({ str: string() }),\n        }).getDefault(),\n      ).toEqual({\n        nest: { str: undefined },\n        str: undefined,\n      });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should create defaults for missing object fields","suites":["Object types","object defaults"],"updatePoint":{"line":296,"column":56},"line":296,"code":"    it('should create defaults for missing object fields', () => {\n      expect(\n        object({\n          prop: mixed(),\n          other: object({\n            x: object({ b: string() }),\n          }),\n        }).cast({ prop: 'foo' }),\n      ).toEqual({\n        prop: 'foo',\n        other: { x: { b: undefined } },\n      });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle empty keys","suites":["Object types","object defaults"],"updatePoint":{"line":311,"column":30},"line":311,"code":"  it('should handle empty keys', () => {\n    let inst = object().shape({\n      prop: mixed(),\n    });\n\n    return Promise.all([\n      expect(inst.isValid({})).resolves.toBe(true),\n\n      expect(\n        inst.shape({ prop: mixed().required() }).isValid({}),\n      ).resolves.toBe(false),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should work with noUnknown","suites":["Object types","object defaults"],"updatePoint":{"line":325,"column":32},"line":325,"code":"  it('should work with noUnknown', () => {\n    let inst = object().shape({\n      prop: mixed(),\n      other: mixed(),\n    });\n\n    return Promise.all([\n      expect(\n        inst.noUnknown('hi').validate({ extra: 'field' }, { strict: true }),\n      ).rejects.toThrowError('hi'),\n\n      expect(\n        inst.noUnknown().validate({ extra: 'field' }, { strict: true }),\n      ).rejects.toThrowError(/extra/),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should work with noUnknown override","suites":["Object types","object defaults"],"updatePoint":{"line":342,"column":41},"line":342,"code":"  it('should work with noUnknown override', async () => {\n    let inst = object()\n      .shape({\n        prop: mixed(),\n      })\n      .noUnknown()\n      .noUnknown(false);\n\n    await expect(inst.validate({ extra: 'field' })).resolves.toEqual({\n      extra: 'field',\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should strip specific fields","suites":["Object types","object defaults"],"updatePoint":{"line":355,"column":34},"line":355,"code":"  it('should strip specific fields', () => {\n    let inst = object().shape({\n      prop: mixed().strip(false),\n      other: mixed().strip(),\n    });\n\n    expect(inst.cast({ other: 'boo', prop: 'bar' })).toEqual({\n      prop: 'bar',\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle field striping with `when`","suites":["Object types","object defaults"],"updatePoint":{"line":366,"column":46},"line":366,"code":"  it('should handle field striping with `when`', () => {\n    let inst = object().shape({\n      other: bool(),\n      prop: mixed().when('other', {\n        is: true,\n        then: (s) => s.strip(),\n      }),\n    });\n\n    expect(inst.cast({ other: true, prop: 'bar' })).toEqual({\n      other: true,\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should allow refs","suites":["Object types","object defaults"],"updatePoint":{"line":380,"column":23},"line":380,"code":"  it('should allow refs', async function () {\n    let schema = object({\n      quz: ref('baz'),\n      baz: ref('foo.bar'),\n      foo: object({\n        bar: string(),\n      }),\n      x: ref('$x'),\n    });\n\n    let value = await schema.validate(\n      {\n        foo: { bar: 'boom' },\n      },\n      { context: { x: 5 } },\n    );\n\n    //console.log(value)\n    expect(value).toEqual({\n      foo: {\n        bar: 'boom',\n      },\n      baz: 'boom',\n      quz: 'boom',\n      x: 5,\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should allow refs with abortEarly false","suites":["Object types","object defaults"],"updatePoint":{"line":408,"column":45},"line":408,"code":"  it('should allow refs with abortEarly false', async () => {\n    let schema = object().shape({\n      field: string(),\n      dupField: ref('field'),\n    });\n\n    await expect(\n      schema.validate(\n        {\n          field: 'test',\n        },\n        { abortEarly: false },\n      ),\n    ).resolves.toEqual({ field: 'test', dupField: 'test' });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should be cast-able","suites":["Object types","lazy evaluation"],"updatePoint":{"line":430,"column":27},"line":430,"code":"    it('should be cast-able', () => {\n      let inst = lazy(() => number());\n\n      expect(inst.cast).toBeInstanceOf(Function);\n      expect(inst.cast('4')).toBe(4);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should be validatable","suites":["Object types","lazy evaluation"],"updatePoint":{"line":437,"column":29},"line":437,"code":"    it('should be validatable', async () => {\n      let inst = lazy(() => string().trim('trim me!').strict());\n\n      expect(inst.validate).toBeInstanceOf(Function);\n\n      try {\n        await inst.validate('  john  ');\n      } catch (err: any) {\n        expect(err.message).toBe('trim me!');\n      }\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should resolve to schema","suites":["Object types","lazy evaluation"],"updatePoint":{"line":449,"column":32},"line":449,"code":"    it('should resolve to schema', () => {\n      type Nested = {\n        nested: Nested;\n        x: {\n          y: Nested;\n        };\n      };\n      let inst: ObjectSchema<Nested> = object({\n        nested: lazy(() => inst),\n        x: object({\n          y: lazy(() => inst),\n        }),\n      });\n\n      expect(reach(inst, 'nested').resolve({})).toBe(inst);\n      expect(reach(inst, 'x.y').resolve({})).toBe(inst);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should be passed the value","suites":["Object types","lazy evaluation"],"updatePoint":{"line":467,"column":34},"line":467,"code":"    it('should be passed the value', (done) => {\n      let inst = object({\n        nested: lazy((value) => {\n          expect(value).toBe('foo');\n          done();\n          return string();\n        }),\n      });\n\n      inst.cast({ nested: 'foo' });\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should be passed the options","suites":["Object types","lazy evaluation"],"updatePoint":{"line":479,"column":36},"line":479,"code":"    it('should be passed the options', (done) => {\n      let opts = {};\n      let inst = lazy((_, options) => {\n        expect(options).toBe(opts);\n        done();\n        return object();\n      });\n\n      inst.cast({ nested: 'foo' }, opts);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should always return a schema","suites":["Object types","lazy evaluation"],"updatePoint":{"line":490,"column":37},"line":490,"code":"    it('should always return a schema', () => {\n      // @ts-expect-error Incorrect usage\n      expect(() => lazy(() => {}).cast()).toThrowError(\n        /must return a valid schema/,\n      );\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should set the correct path","suites":["Object types","lazy evaluation"],"updatePoint":{"line":497,"column":35},"line":497,"code":"    it('should set the correct path', async () => {\n      type Nested = {\n        str: string | null;\n        nested: Nested;\n      };\n\n      let inst: ObjectSchema<Nested> = object({\n        str: string().required().nullable(),\n        nested: lazy(() => inst.default(undefined)),\n      });\n\n      let value = {\n        nested: { str: null },\n        str: 'foo',\n      };\n\n      try {\n        await inst.validate(value, { strict: true });\n      } catch (err: any) {\n        expect(err.path).toBe('nested.str');\n        expect(err.message).toMatch(/required/);\n      }\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should set the correct path with dotted keys","suites":["Object types","lazy evaluation"],"updatePoint":{"line":521,"column":52},"line":521,"code":"    it('should set the correct path with dotted keys', async () => {\n      let inst: ObjectSchema<any> = object({\n        'dotted.str': string().required().nullable(),\n        nested: lazy(() => inst.default(undefined)),\n      });\n\n      let value = {\n        nested: { 'dotted.str': null },\n        'dotted.str': 'foo',\n      };\n\n      try {\n        await inst.validate(value, { strict: true });\n      } catch (err: any) {\n        expect(err.path).toBe('nested[\"dotted.str\"]');\n        expect(err.message).toMatch(/required/);\n      }\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should resolve array sub types","suites":["Object types","lazy evaluation"],"updatePoint":{"line":540,"column":38},"line":540,"code":"    it('should resolve array sub types', async () => {\n      let inst: ObjectSchema<any> = object({\n        str: string().required().nullable(),\n        nested: array().of(lazy(() => inst.default(undefined))),\n      });\n\n      let value = {\n        nested: [{ str: null }],\n        str: 'foo',\n      };\n\n      try {\n        await inst.validate(value, { strict: true });\n      } catch (err: any) {\n        expect(err.path).toBe('nested[0].str');\n        expect(err.message).toMatch(/required/);\n      }\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should resolve for each array item","suites":["Object types","lazy evaluation"],"updatePoint":{"line":559,"column":42},"line":559,"code":"    it('should resolve for each array item', async () => {\n      let inst = array().of(\n        lazy((value: string | number) => (types as any)[typeof value]),\n      );\n\n      let val = await inst.validate(['john', 4], { strict: true });\n\n      expect(val).toEqual(['john', 4]);\n    });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should respect abortEarly","suites":["Object types","lazy evaluation"],"updatePoint":{"line":570,"column":31},"line":570,"code":"  it('should respect abortEarly', async () => {\n    let inst = object({\n      nest: object({\n        str: string().required(),\n      }).test('name', 'oops', () => false),\n    });\n\n    return Promise.all([\n      expect(inst.validate({ nest: { str: '' } })).rejects.toEqual(\n        expect.objectContaining({\n          value: { nest: { str: '' } },\n          // path: 'nest',\n          errors: ['oops'],\n        }),\n      ),\n\n      expect(\n        inst.validate({ nest: { str: '' } }, { abortEarly: false }),\n      ).rejects.toEqual(\n        expect.objectContaining({\n          value: { nest: { str: '' } },\n          errors: ['nest.str is a required field', 'oops'],\n        }),\n      ),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should flatten validation errors with abortEarly=false","suites":["Object types","lazy evaluation"],"updatePoint":{"line":597,"column":60},"line":597,"code":"  it('should flatten validation errors with abortEarly=false', async () => {\n    let inst = object({\n      str: string().required(),\n      nest: object({\n        innerStr: string().required(),\n        num: number().moreThan(5),\n        other: number().test('nested', 'invalid', () => {\n          string().email().min(3).validateSync('f', { abortEarly: false });\n          return true;\n        }),\n      }).test('name', 'oops', () => false),\n    });\n\n    const error = await inst\n      .validate(\n        { str: null, nest: { num: 2, str: undefined } },\n        { abortEarly: false },\n      )\n      .catch((e) => e);\n\n    expect(error.inner).toMatchInlineSnapshot(`\n      Array [\n        [ValidationError: str is a required field],\n        [ValidationError: nest.innerStr is a required field],\n        [ValidationError: nest.num must be greater than 5],\n        [ValidationError: oops],\n        [ValidationError: this must be a valid email],\n        [ValidationError: this must be at least 3 characters],\n      ]\n    `);\n\n    expect(error.errors).toEqual([\n      'str is a required field',\n      'nest.innerStr is a required field',\n      'nest.num must be greater than 5',\n      'oops',\n      'this must be a valid email',\n      'this must be at least 3 characters',\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should sort errors by insertion order","suites":["Object types","lazy evaluation"],"updatePoint":{"line":638,"column":43},"line":638,"code":"  it('should sort errors by insertion order', async () => {\n    let inst = object({\n      // use `when` to make sure it is validated second\n      foo: string().when('bar', () => string().min(5)),\n      bar: string().required(),\n    });\n\n    await expect(\n      inst.validate({ foo: 'foo' }, { abortEarly: false }),\n    ).rejects.toEqual(\n      validationErrorWithMessages(\n        'foo must be at least 5 characters',\n        'bar is a required field',\n      ),\n    );\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should respect recursive","suites":["Object types","lazy evaluation"],"updatePoint":{"line":655,"column":30},"line":655,"code":"  it('should respect recursive', () => {\n    let inst = object({\n      nest: object({\n        str: string().required(),\n      }),\n    }).test('name', 'oops', () => false);\n\n    let val = { nest: { str: null } };\n\n    return Promise.all([\n      expect(inst.validate(val, { abortEarly: false })).rejects.toEqual(\n        validationErrorWithMessages(expect.any(String), expect.any(String)),\n      ),\n\n      expect(\n        inst.validate(val, { abortEarly: false, recursive: false }),\n      ).rejects.toEqual(validationErrorWithMessages('oops')),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"partial() should work","suites":["Object types","lazy evaluation"],"updatePoint":{"line":675,"column":27},"line":675,"code":"  it('partial() should work', async () => {\n    let inst = object({\n      age: number().required(),\n      name: string().required(),\n    });\n\n    await expect(inst.isValid({ age: null, name: '' })).resolves.toEqual(false);\n\n    await expect(inst.partial().isValid({})).resolves.toEqual(true);\n\n    await expect(inst.partial().isValid({ age: null })).resolves.toEqual(false);\n    await expect(inst.partial().isValid({ name: '' })).resolves.toEqual(false);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"deepPartial() should work","suites":["Object types","lazy evaluation"],"updatePoint":{"line":689,"column":31},"line":689,"code":"  it('deepPartial() should work', async () => {\n    let inst = object({\n      age: number().required(),\n      name: string().required(),\n      contacts: array(\n        object({\n          name: string().required(),\n          age: number().required(),\n          lazy: lazy(() => number().required()),\n        }),\n      ).defined(),\n    });\n\n    await expect(inst.isValid({ age: 2, name: 'fs' })).resolves.toEqual(false);\n    await expect(\n      inst.isValid({ age: 2, name: 'fs', contacts: [{}] }),\n    ).resolves.toEqual(false);\n\n    const instPartial = inst.deepPartial();\n\n    await expect(\n      inst.validate({ age: 1, name: 'f', contacts: [{ name: 'f', age: 1 }] }),\n    ).rejects.toThrowError('contacts[0].lazy is a required field');\n\n    await expect(instPartial.isValid({})).resolves.toEqual(true);\n\n    await expect(instPartial.isValid({ contacts: [{}] })).resolves.toEqual(\n      true,\n    );\n\n    await expect(\n      instPartial.isValid({ contacts: [{ age: null }] }),\n    ).resolves.toEqual(false);\n\n    await expect(\n      instPartial.isValid({ contacts: [{ lazy: null }] }),\n    ).resolves.toEqual(false);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should alias or move keys","suites":["Object types","lazy evaluation"],"updatePoint":{"line":728,"column":31},"line":728,"code":"  it('should alias or move keys', () => {\n    let inst = object()\n      .shape({\n        myProp: mixed(),\n        Other: mixed(),\n      })\n      .from('prop', 'myProp')\n      .from('other', 'Other', true);\n\n    expect(inst.cast({ prop: 5, other: 6 })).toEqual({\n      myProp: 5,\n      other: 6,\n      Other: 6,\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should alias nested keys","suites":["Object types","lazy evaluation"],"updatePoint":{"line":744,"column":30},"line":744,"code":"  it('should alias nested keys', () => {\n    let inst = object({\n      foo: object({\n        bar: string(),\n      }),\n      // @ts-expect-error FIXME\n    }).from('foo.bar', 'foobar', true);\n\n    expect(inst.cast({ foo: { bar: 'quz' } })).toEqual({\n      foobar: 'quz',\n      foo: { bar: 'quz' },\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should not move keys when it does not exist","suites":["Object types","lazy evaluation"],"updatePoint":{"line":758,"column":49},"line":758,"code":"  it('should not move keys when it does not exist', () => {\n    let inst = object()\n      .shape({\n        myProp: mixed(),\n      })\n      .from('prop', 'myProp');\n\n    expect(inst.cast({ myProp: 5 })).toEqual({ myProp: 5 });\n\n    expect(inst.cast({ myProp: 5, prop: 7 })).toEqual({ myProp: 7 });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle conditionals","suites":["Object types","lazy evaluation"],"updatePoint":{"line":770,"column":32},"line":770,"code":"  it('should handle conditionals', () => {\n    let inst = object().shape({\n      noteDate: number()\n        .when('stats.isBig', {\n          is: true,\n          then: (s) => s.min(5),\n        })\n        .when('other', ([v], schema) => (v === 4 ? schema.max(6) : schema)),\n      stats: object({ isBig: bool() }),\n      other: number()\n        .min(1)\n        .when('stats', { is: 5, then: (s) => s }),\n    });\n\n    return Promise.all([\n      expect(\n        // other makes noteDate too large\n        inst.isValid({\n          stats: { isBig: true },\n          rand: 5,\n          noteDate: 7,\n          other: 4,\n        }),\n      ).resolves.toBe(false),\n      expect(\n        inst.isValid({ stats: { isBig: true }, noteDate: 1, other: 4 }),\n      ).resolves.toBe(false),\n\n      expect(\n        inst.isValid({ stats: { isBig: true }, noteDate: 7, other: 6 }),\n      ).resolves.toBe(true),\n      expect(\n        inst.isValid({ stats: { isBig: true }, noteDate: 7, other: 4 }),\n      ).resolves.toBe(false),\n\n      expect(\n        inst.isValid({ stats: { isBig: false }, noteDate: 4, other: 4 }),\n      ).resolves.toBe(true),\n\n      expect(\n        inst.isValid({ stats: { isBig: true }, noteDate: 1, other: 4 }),\n      ).resolves.toBe(false),\n      expect(\n        inst.isValid({ stats: { isBig: true }, noteDate: 6, other: 4 }),\n      ).resolves.toBe(true),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle conditionals with unknown dependencies","suites":["Object types","lazy evaluation"],"updatePoint":{"line":818,"column":58},"line":818,"code":"  it('should handle conditionals with unknown dependencies', () => {\n    let inst = object().shape({\n      value: number().when('isRequired', {\n        is: true,\n        then: (s) => s.required(),\n      }),\n    });\n\n    return Promise.all([\n      expect(\n        inst.isValid({\n          isRequired: true,\n          value: 1234,\n        }),\n      ).resolves.toBe(true),\n      expect(\n        inst.isValid({\n          isRequired: true,\n        }),\n      ).resolves.toBe(false),\n\n      expect(\n        inst.isValid({\n          isRequired: false,\n          value: 1234,\n        }),\n      ).resolves.toBe(true),\n      expect(\n        inst.isValid({\n          value: 1234,\n        }),\n      ).resolves.toBe(true),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle conditionals synchronously","suites":["Object types","lazy evaluation"],"updatePoint":{"line":853,"column":46},"line":853,"code":"  it('should handle conditionals synchronously', () => {\n    let inst = object().shape({\n      knownDependency: bool(),\n      value: number().when(['unknownDependency', 'knownDependency'], {\n        is: true,\n        then: (s) => s.required(),\n      }),\n    });\n\n    // expect(() =>\n    //   inst.validateSync({\n    //     unknownDependency: true,\n    //     knownDependency: true,\n    //     value: 1234,\n    //   }),\n    // ).not.throw();\n\n    expect(() =>\n      inst.validateSync({\n        unknownDependency: true,\n        knownDependency: true,\n      }),\n    ).toThrowError(/required/);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should allow opt out of topo sort on specific edges","suites":["Object types","lazy evaluation"],"updatePoint":{"line":878,"column":57},"line":878,"code":"  it('should allow opt out of topo sort on specific edges', () => {\n    expect(() => {\n      object().shape({\n        orgID: number().when('location', ([v], schema) => {\n          return v == null ? schema.required() : schema;\n        }),\n        location: string().when('orgID', (v, schema) => {\n          return v == null ? schema.required() : schema;\n        }),\n      });\n    }).toThrowError('Cyclic dependency, node was:\"location\"');\n\n    expect(() => {\n      object().shape(\n        {\n          orgID: number().when('location', ([v], schema) => {\n            return v == null ? schema.required() : schema;\n          }),\n          location: string().when('orgID', ([v], schema) => {\n            return v == null ? schema.required() : schema;\n          }),\n        },\n        [['location', 'orgID']],\n      );\n    }).not.toThrowError();\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should use correct default when concating","suites":["Object types","lazy evaluation"],"updatePoint":{"line":905,"column":47},"line":905,"code":"  it('should use correct default when concating', () => {\n    let inst = object({\n      other: bool(),\n    }).default(undefined);\n\n    expect(inst.concat(object()).getDefault()).toBeUndefined();\n\n    expect(inst.concat(object().default({})).getDefault()).toEqual({});\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should maintain excluded edges when concating","suites":["Object types","lazy evaluation"],"updatePoint":{"line":915,"column":51},"line":915,"code":"  it('should maintain excluded edges when concating', async () => {\n    const schema = object().shape(\n      {\n        a1: string().when('a2', {\n          is: undefined,\n          then: (s) => s.required(),\n        }),\n        a2: string().when('a1', {\n          is: undefined,\n          then: (s) => s.required(),\n        }),\n      },\n      [['a1', 'a2']],\n    );\n\n    await expect(\n      schema.concat(object()).isValid({ a1: null }),\n    ).resolves.toEqual(false);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should handle nested conditionals","suites":["Object types","lazy evaluation"],"updatePoint":{"line":935,"column":39},"line":935,"code":"  it('should handle nested conditionals', () => {\n    let countSchema = number().when('isBig', {\n      is: true,\n      then: (s) => s.min(5),\n    });\n    let inst = object({\n      other: bool(),\n      stats: object({\n        isBig: bool(),\n        count: countSchema,\n      })\n        .default(undefined)\n        .when('other', { is: true, then: (s) => s.required() }),\n    });\n\n    return Promise.all([\n      expect(inst.validate({ stats: undefined, other: true })).rejects.toEqual(\n        validationErrorWithMessages(expect.stringContaining('required')),\n      ),\n      expect(\n        inst.validate({ stats: { isBig: true, count: 3 }, other: true }),\n      ).rejects.toEqual(\n        validationErrorWithMessages(\n          'stats.count must be greater than or equal to 5',\n        ),\n      ),\n      expect(\n        inst.validate({ stats: { isBig: true, count: 10 }, other: true }),\n      ).resolves.toEqual({\n        stats: { isBig: true, count: 10 },\n        other: true,\n      }),\n\n      expect(\n        countSchema.validate(10, { context: { isBig: true } }),\n      ).resolves.toEqual(10),\n    ]);\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should camelCase keys","suites":["Object types","lazy evaluation"],"updatePoint":{"line":974,"column":27},"line":974,"code":"  it('should camelCase keys', () => {\n    let inst = object()\n      .shape({\n        conStat: number(),\n        caseStatus: number(),\n        hiJohn: number(),\n      })\n      .camelCase();\n\n    expect(inst.cast({ CON_STAT: 5, CaseStatus: 6, 'hi john': 4 })).toEqual({\n      conStat: 5,\n      caseStatus: 6,\n      hiJohn: 4,\n    });\n\n    expect(inst.nullable().cast(null)).toBeNull();\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should CONSTANT_CASE keys","suites":["Object types","lazy evaluation"],"updatePoint":{"line":992,"column":31},"line":992,"code":"  it('should CONSTANT_CASE keys', () => {\n    let inst = object()\n      .shape({\n        CON_STAT: number(),\n        CASE_STATUS: number(),\n        HI_JOHN: number(),\n      })\n      .constantCase();\n\n    expect(inst.cast({ conStat: 5, CaseStatus: 6, 'hi john': 4 })).toEqual({\n      CON_STAT: 5,\n      CASE_STATUS: 6,\n      HI_JOHN: 4,\n    });\n\n    expect(inst.nullable().cast(null)).toBeNull();\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should pick","suites":["Object types","lazy evaluation"],"updatePoint":{"line":1010,"column":17},"line":1010,"code":"  it('should pick', async () => {\n    let inst = object({\n      age: number().default(30).required(),\n      name: string().default('pat').required(),\n      color: string().default('red').required(),\n    });\n\n    expect(inst.pick(['age', 'name']).getDefault()).toEqual({\n      age: 30,\n      name: 'pat',\n    });\n\n    expect(\n      await inst.pick(['age', 'name']).validate({ age: 24, name: 'Bill' }),\n    ).toEqual({\n      age: 24,\n      name: 'Bill',\n    });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should omit","suites":["Object types","lazy evaluation"],"updatePoint":{"line":1030,"column":17},"line":1030,"code":"  it('should omit', async () => {\n    let inst = object({\n      age: number().default(30).required(),\n      name: string().default('pat').required(),\n      color: string().default('red').required(),\n    });\n\n    expect(inst.omit(['age', 'name']).getDefault()).toEqual({\n      color: 'red',\n    });\n\n    expect(\n      await inst.omit(['age', 'name']).validate({ color: 'mauve' }),\n    ).toEqual({ color: 'mauve' });\n  });","file":"object.ts","skipped":false,"dir":"test"},{"name":"should get default locale","suites":["Custom locale"],"updatePoint":{"line":5,"column":31},"line":5,"code":"  it('should get default locale', () => {\n    const locale = require('../src/locale').default;\n    expect(locale.string.email).toBe('${path} must be a valid email');\n  });","file":"setLocale.ts","skipped":false,"dir":"test"},{"name":"should set a new locale","suites":["Custom locale"],"updatePoint":{"line":10,"column":29},"line":10,"code":"  it('should set a new locale', () => {\n    const locale = require('../src/locale').default;\n    const dict = {\n      string: {\n        email: 'Invalid email',\n      },\n    };\n\n    setLocale(dict);\n\n    expect(locale.string.email).toBe(dict.string.email);\n  });","file":"setLocale.ts","skipped":false,"dir":"test"},{"name":"should update the main locale","suites":["Custom locale"],"updatePoint":{"line":23,"column":35},"line":23,"code":"  it('should update the main locale', () => {\n    const locale = require('../src/locale').default;\n    expect(locale.string.email).toBe('Invalid email');\n  });","file":"setLocale.ts","skipped":false,"dir":"test"},{"name":"should not allow prototype pollution","suites":["Custom locale"],"updatePoint":{"line":28,"column":42},"line":28,"code":"  it('should not allow prototype pollution', () => {\n    const payload = JSON.parse(\n      '{\"__proto__\":{\"polluted\":\"Yes! Its Polluted\"}}',\n    );\n\n    expect(() => setLocale(payload)).toThrowError();\n\n    expect(payload).not.toHaveProperty('polluted');\n  });","file":"setLocale.ts","skipped":false,"dir":"test"},{"name":"should not pollute Object.prototype builtins","suites":["Custom locale"],"updatePoint":{"line":38,"column":50},"line":38,"code":"  it('should not pollute Object.prototype builtins', () => {\n    const payload: any = { toString: { polluted: 'oh no' } };\n\n    expect(() => setLocale(payload)).toThrowError();\n\n    expect(Object.prototype.toString).not.toHaveProperty('polluted');\n  });","file":"setLocale.ts","skipped":false,"dir":"test"},{"name":"should trim","suites":["String types","casting","ensure"],"updatePoint":{"line":44,"column":19},"line":44,"code":"    it('should trim', () => {\n      expect(schema.trim().cast(' 3  ')).toBe('3');\n    });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should transform to lowercase","suites":["String types","casting","ensure"],"updatePoint":{"line":48,"column":37},"line":48,"code":"    it('should transform to lowercase', () => {\n      expect(schema.lowercase().cast('HellO JohN')).toBe('hello john');\n    });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should transform to uppercase","suites":["String types","casting","ensure"],"updatePoint":{"line":52,"column":37},"line":52,"code":"    it('should transform to uppercase', () => {\n      expect(schema.uppercase().cast('HellO JohN')).toBe('HELLO JOHN');\n    });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should handle nulls","suites":["String types","casting","ensure"],"updatePoint":{"line":56,"column":27},"line":56,"code":"    it('should handle nulls', () => {\n      expect(\n        schema.nullable().trim().lowercase().uppercase().cast(null),\n      ).toBeNull();\n    });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should handle DEFAULT","suites":["String types","casting","ensure"],"updatePoint":{"line":63,"column":27},"line":63,"code":"  it('should handle DEFAULT', function () {\n    let inst = string();\n\n    expect(inst.default('my_value').required().getDefault()).toBe('my_value');\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["String types","casting","ensure"],"updatePoint":{"line":69,"column":23},"line":69,"code":"  it('should type check', function () {\n    let inst = string();\n\n    expect(inst.isType('5')).toBe(true);\n    expect(inst.isType(new String('5'))).toBe(true);\n    expect(inst.isType(false)).toBe(false);\n    expect(inst.isType(null)).toBe(false);\n    expect(inst.nullable().isType(null)).toBe(true);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should VALIDATE correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":79,"column":31},"line":79,"code":"  it('should VALIDATE correctly', function () {\n    let inst = string().required().min(4).strict();\n\n    return Promise.all([\n      expect(string().strict().isValid(null)).resolves.toBe(false),\n\n      expect(string().strict().nullable().isValid(null)).resolves.toBe(true),\n\n      expect(inst.isValid('hello')).resolves.toBe(true),\n\n      expect(inst.isValid('hel')).resolves.toBe(false),\n\n      expect(inst.validate('')).rejects.toEqual(\n        TestHelpers.validationErrorWithMessages(expect.any(String)),\n      ),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check MATCHES correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":97,"column":36},"line":97,"code":"  it('should check MATCHES correctly', function () {\n    let v = string().matches(/(hi|bye)/, 'A message');\n\n    return Promise.all([\n      expect(v.isValid('hi')).resolves.toBe(true),\n      expect(v.isValid('nope')).resolves.toBe(false),\n      expect(v.isValid('bye')).resolves.toBe(true),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check MATCHES correctly with global and sticky flags","suites":["String types","casting","ensure"],"updatePoint":{"line":107,"column":65},"line":107,"code":"  it('should check MATCHES correctly with global and sticky flags', function () {\n    let v = string().matches(/hi/gy);\n\n    return Promise.all([\n      expect(v.isValid('hi')).resolves.toBe(true),\n      expect(v.isValid('hi')).resolves.toBe(true),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"MATCHES should include empty strings","suites":["String types","casting","ensure"],"updatePoint":{"line":116,"column":42},"line":116,"code":"  it('MATCHES should include empty strings', () => {\n    let v = string().matches(/(hi|bye)/);\n\n    return expect(v.isValid('')).resolves.toBe(false);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"MATCHES should exclude empty strings","suites":["String types","casting","ensure"],"updatePoint":{"line":122,"column":42},"line":122,"code":"  it('MATCHES should exclude empty strings', () => {\n    let v = string().matches(/(hi|bye)/, { excludeEmptyString: true });\n\n    return expect(v.isValid('')).resolves.toBe(true);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"EMAIL should exclude empty strings","suites":["String types","casting","ensure"],"updatePoint":{"line":128,"column":40},"line":128,"code":"  it('EMAIL should exclude empty strings', () => {\n    let v = string().email();\n\n    return expect(v.isValid('')).resolves.toBe(true);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check MIN correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":134,"column":32},"line":134,"code":"  it('should check MIN correctly', function () {\n    let v = string().min(5);\n    let obj = object({\n      len: number(),\n      name: string().min(ref('len')),\n    });\n\n    return Promise.all([\n      expect(v.isValid('hiiofff')).resolves.toBe(true),\n      expect(v.isValid('big')).resolves.toBe(false),\n      expect(v.isValid('noffasfasfasf saf')).resolves.toBe(true),\n\n      expect(v.isValid(null)).resolves.toBe(false),\n      expect(v.nullable().isValid(null)).resolves.toBe(true),\n\n      expect(obj.isValid({ len: 10, name: 'john' })).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check MAX correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":153,"column":32},"line":153,"code":"  it('should check MAX correctly', function () {\n    let v = string().max(5);\n    let obj = object({\n      len: number(),\n      name: string().max(ref('len')),\n    });\n    return Promise.all([\n      expect(v.isValid('adgf')).resolves.toBe(true),\n      expect(v.isValid('bigdfdsfsdf')).resolves.toBe(false),\n      expect(v.isValid('no')).resolves.toBe(true),\n\n      expect(v.isValid(null)).resolves.toBe(false),\n\n      expect(v.nullable().isValid(null)).resolves.toBe(true),\n\n      expect(obj.isValid({ len: 3, name: 'john' })).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check LENGTH correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":172,"column":35},"line":172,"code":"  it('should check LENGTH correctly', function () {\n    let v = string().length(5);\n    let obj = object({\n      len: number(),\n      name: string().length(ref('len')),\n    });\n\n    return Promise.all([\n      expect(v.isValid('exact')).resolves.toBe(true),\n      expect(v.isValid('sml')).resolves.toBe(false),\n      expect(v.isValid('biiiig')).resolves.toBe(false),\n\n      expect(v.isValid(null)).resolves.toBe(false),\n      expect(v.nullable().isValid(null)).resolves.toBe(true),\n\n      expect(obj.isValid({ len: 5, name: 'foo' })).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check url correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":191,"column":32},"line":191,"code":"  it('should check url correctly', function () {\n    let v = string().url();\n\n    return Promise.all([\n      expect(v.isValid('//www.github.com/')).resolves.toBe(true),\n      expect(v.isValid('https://www.github.com/')).resolves.toBe(true),\n      expect(v.isValid('this is not a url')).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should check UUID correctly","suites":["String types","casting","ensure"],"updatePoint":{"line":201,"column":33},"line":201,"code":"  it('should check UUID correctly', function () {\n    let v = string().uuid();\n\n    return Promise.all([\n      expect(v.isValid('0c40428c-d88d-4ff0-a5dc-a6755cb4f4d1')).resolves.toBe(\n        true,\n      ),\n      expect(v.isValid('42c4a747-3e3e-42be-af30-469cfb9c1913')).resolves.toBe(\n        true,\n      ),\n      expect(v.isValid('42c4a747-3e3e-zzzz-af30-469cfb9c1913')).resolves.toBe(\n        false,\n      ),\n      expect(v.isValid('this is not a uuid')).resolves.toBe(false),\n      expect(v.isValid('')).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should validate transforms","suites":["String types","casting","ensure"],"updatePoint":{"line":249,"column":32},"line":249,"code":"  it('should validate transforms', function () {\n    return Promise.all([\n      expect(string().trim().isValid(' 3  ')).resolves.toBe(true),\n\n      expect(string().lowercase().isValid('HellO JohN')).resolves.toBe(true),\n\n      expect(string().uppercase().isValid('HellO JohN')).resolves.toBe(true),\n\n      expect(string().trim().isValid(' 3  ', { strict: true })).resolves.toBe(\n        false,\n      ),\n\n      expect(\n        string().lowercase().isValid('HellO JohN', { strict: true }),\n      ).resolves.toBe(false),\n\n      expect(\n        string().uppercase().isValid('HellO JohN', { strict: true }),\n      ).resolves.toBe(false),\n    ]);\n  });","file":"string.ts","skipped":false,"dir":"test"},{"name":"should failed casts return input","suites":["Array types","casting"],"updatePoint":{"line":5,"column":40},"line":5,"code":"    it('should failed casts return input', () => {\n      expect(\n        tuple([number(), number()]).cast('asfasf', { assert: false }),\n      ).toEqual('asfasf');\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should recursively cast fields","suites":["Array types","casting"],"updatePoint":{"line":11,"column":38},"line":11,"code":"    it('should recursively cast fields', () => {\n      expect(tuple([number(), number()]).cast(['4', '5'])).toEqual([4, 5]);\n\n      expect(\n        tuple([string(), string(), string()]).cast(['4', 5, false]),\n      ).toEqual(['4', '5', 'false']);\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should handle DEFAULT","suites":["Array types","casting"],"updatePoint":{"line":20,"column":27},"line":20,"code":"  it('should handle DEFAULT', () => {\n    expect(tuple([number(), number(), number()]).getDefault()).toBeUndefined();\n\n    expect(\n      tuple([number(), number(), number()])\n        .default(() => [1, 2, 3])\n        .getDefault(),\n    ).toEqual([1, 2, 3]);\n  });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should type check","suites":["Array types","casting"],"updatePoint":{"line":30,"column":23},"line":30,"code":"  it('should type check', () => {\n    let inst = tuple([number()]);\n\n    expect(inst.isType([1])).toBe(true);\n    expect(inst.isType({})).toBe(false);\n    expect(inst.isType('true')).toBe(false);\n    expect(inst.isType(NaN)).toBe(false);\n    expect(inst.isType(34545)).toBe(false);\n\n    expect(inst.isType(null)).toBe(false);\n\n    expect(inst.nullable().isType(null)).toBe(true);\n  });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should pass options to children","suites":["Array types","casting"],"updatePoint":{"line":44,"column":37},"line":44,"code":"  it('should pass options to children', () => {\n    expect(\n      tuple([object({ name: string() })]).cast([{ id: 1, name: 'john' }], {\n        stripUnknown: true,\n      }),\n    ).toEqual([{ name: 'john' }]);\n  });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"Basic validations fail: %s %p","suites":["Array types","validation"],"line":53,"code":"    test.each([\n      ['required', undefined, tuple([mixed()]).required()],\n      ['required', null, tuple([mixed()]).required()],\n      ['null', null, tuple([mixed()])],\n    ])('Basic validations fail: %s %p', async (_, value, schema) => {\n      expect(await schema.isValid(value)).toBe(false);\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"Basic validations pass: %s %p","suites":["Array types","validation"],"line":61,"code":"    test.each([\n      ['required', ['any'], tuple([mixed()]).required()],\n      ['nullable', null, tuple([mixed()]).nullable()],\n    ])('Basic validations pass: %s %p', async (_, value, schema) => {\n      expect(await schema.isValid(value)).toBe(true);\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should allow undefined","suites":["Array types","validation"],"updatePoint":{"line":68,"column":30},"line":68,"code":"    it('should allow undefined', async () => {\n      await expect(\n        tuple([number().defined()]).isValid(undefined),\n      ).resolves.toBe(true);\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should respect subtype validations","suites":["Array types","validation"],"updatePoint":{"line":74,"column":42},"line":74,"code":"    it('should respect subtype validations', async () => {\n      let inst = tuple([number().max(5), string()]);\n\n      await expect(inst.isValid(['gg', 'any'])).resolves.toBe(false);\n      await expect(inst.isValid([7, 3])).resolves.toBe(false);\n\n      expect(await inst.validate(['4', 3])).toEqual([4, '3']);\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should use labels","suites":["Array types","validation"],"updatePoint":{"line":83,"column":25},"line":83,"code":"    it('should use labels', async () => {\n      let schema = tuple([\n        string().label('name'),\n        number().positive().integer().label('age'),\n      ]);\n\n      await expect(schema.validate(['James', -24.55])).rejects.toThrow(\n        'age must be a positive number',\n      );\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should throw useful type error for lenght","suites":["Array types","validation"],"updatePoint":{"line":94,"column":49},"line":94,"code":"    it('should throw useful type error for lenght', async () => {\n      let schema = tuple([string().label('name'), number().label('age')]);\n\n      // expect(() => schema.cast(['James'])).toThrowError(\n      //   'this tuple value has too few items, expected a length of 2 but got 1 for value',\n      // );\n      await expect(schema.validate(['James'])).rejects.toThrowError(\n        'this tuple value has too few items, expected a length of 2 but got 1 for value',\n      );\n\n      await expect(schema.validate(['James', 2, 4])).rejects.toThrowError(\n        'this tuple value has too many items, expected a length of 2 but got 3 for value',\n      );\n      // expect(() => schema.validate(['James', 2, 4])).rejects.toThrowError(\n      //   'this tuple value has too many items, expected a length of 2 but got 3 for value',\n      // );\n    });","file":"tuple.ts","skipped":false,"dir":"test"},{"name":"should insert the params into the message","suites":["ValidationError","formatError"],"updatePoint":{"line":5,"column":49},"line":5,"code":"    it('should insert the params into the message', () => {\n      const str = ValidationError.formatError('Some message ${param}', {\n        param: 'here',\n      });\n      expect(str).toContain('here');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should auto include any param named 'label' or 'path' as the 'path' param","suites":["ValidationError","formatError"],"updatePoint":{"line":12,"column":81},"line":12,"code":"    it(`should auto include any param named 'label' or 'path' as the 'path' param`, () => {\n      const str = ValidationError.formatError('${path} goes here', {\n        label: 'label',\n      });\n      expect(str).toContain('label');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should use 'this' if a 'label' or 'path' param is not provided","suites":["ValidationError","formatError"],"updatePoint":{"line":19,"column":70},"line":19,"code":"    it(`should use 'this' if a 'label' or 'path' param is not provided`, () => {\n      const str = ValidationError.formatError('${path} goes here', {});\n      expect(str).toContain('this');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should include \"undefined\" in the message if undefined is provided as a param","suites":["ValidationError","formatError"],"updatePoint":{"line":24,"column":85},"line":24,"code":"    it(`should include \"undefined\" in the message if undefined is provided as a param`, () => {\n      const str = ValidationError.formatError('${path} value is ${min}', {\n        min: undefined,\n      });\n      expect(str).toContain('undefined');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should include \"null\" in the message if null is provided as a param","suites":["ValidationError","formatError"],"updatePoint":{"line":31,"column":75},"line":31,"code":"    it(`should include \"null\" in the message if null is provided as a param`, () => {\n      const str = ValidationError.formatError('${path} value is ${min}', {\n        min: null,\n      });\n      expect(str).toContain('null');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should include \"NaN\" in the message if null is provided as a param","suites":["ValidationError","formatError"],"updatePoint":{"line":38,"column":74},"line":38,"code":"    it(`should include \"NaN\" in the message if null is provided as a param`, () => {\n      const str = ValidationError.formatError('${path} value is ${min}', {\n        min: NaN,\n      });\n      expect(str).toContain('NaN');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"should include 0 in the message if 0 is provided as a param","suites":["ValidationError","formatError"],"updatePoint":{"line":45,"column":67},"line":45,"code":"    it(`should include 0 in the message if 0 is provided as a param`, () => {\n      const str = ValidationError.formatError('${path} value is ${min}', {\n        min: 0,\n      });\n      expect(str).toContain('0');\n    });","file":"ValidationError.ts","skipped":false,"dir":"test"},{"name":"cast should not assert on undefined","suites":["Yup"],"updatePoint":{"line":25,"column":41},"line":25,"code":"  it('cast should not assert on undefined', () => {\n    expect(() => string().cast(undefined)).not.toThrowError();\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"cast should assert on undefined cast results","suites":["Yup"],"updatePoint":{"line":29,"column":50},"line":29,"code":"  it('cast should assert on undefined cast results', () => {\n    expect(() =>\n      string()\n        .defined()\n        .transform(() => undefined)\n        .cast('foo'),\n    ).toThrowError(\n      'The value of field could not be cast to a value that satisfies the schema type: \"string\".',\n    );\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"cast should respect assert option","suites":["Yup"],"updatePoint":{"line":40,"column":39},"line":40,"code":"  it('cast should respect assert option', () => {\n    expect(() => string().cast(null)).toThrowError();\n\n    expect(() => string().cast(null, { assert: false })).not.toThrowError();\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should getIn correctly","suites":["Yup"],"updatePoint":{"line":46,"column":28},"line":46,"code":"  it('should getIn correctly', async () => {\n    let num = number();\n    let shape = object({ 'num-1': num });\n    let inst = object({\n      num: number().max(4),\n\n      nested: object({\n        arr: array().of(shape),\n      }),\n    });\n\n    const value = { nested: { arr: [{}, { 'num-1': 2 }] } };\n    let { schema, parent, parentPath } = getIn(\n      inst,\n      'nested.arr[1].num-1',\n      value,\n    );\n\n    expect(schema).toBe(num);\n    expect(parentPath).toBe('num-1');\n    expect(parent).toBe(value.nested.arr[1]);\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should getIn array correctly","suites":["Yup"],"updatePoint":{"line":69,"column":34},"line":69,"code":"  it('should getIn array correctly', async () => {\n    let num = number();\n    let shape = object({ 'num-1': num });\n    let inst = object({\n      num: number().max(4),\n\n      nested: object({\n        arr: array().of(shape),\n      }),\n    });\n\n    const value = {\n      nested: {\n        arr: [{}, { 'num-1': 2 }],\n      },\n    };\n\n    const { schema, parent, parentPath } = getIn(inst, 'nested.arr[1]', value);\n\n    expect(schema).toBe(shape);\n    expect(parentPath).toBe('1');\n    expect(parent).toBe(value.nested.arr);\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should REACH correctly","suites":["Yup"],"updatePoint":{"line":93,"column":28},"line":93,"code":"  it('should REACH correctly', async () => {\n    let num = number();\n    let shape = object({ num });\n\n    let inst = object({\n      num: number().max(4),\n\n      nested: tuple([\n        string(),\n        object({\n          arr: array().of(shape),\n        }),\n      ]),\n    });\n\n    expect(reach(inst, '')).toBe(inst);\n\n    expect(reach(inst, 'nested[1].arr[0].num')).toBe(num);\n    expect(reach(inst, 'nested[1].arr[].num')).toBe(num);\n    expect(reach(inst, 'nested[1].arr.num')).toBe(num);\n    expect(reach(inst, 'nested[1].arr[1].num')).toBe(num);\n    expect(reach(inst, 'nested[1].arr[1]')).toBe(shape);\n\n    expect(() => reach(inst, 'nested.arr[1].num')).toThrowError(\n      'Yup.reach cannot implicitly index into a tuple type. the path part \".nested\" must contain an index to the tuple element, e.g. \".nested[0]\"',\n    );\n\n    expect(reach(inst, 'nested[1].arr[0].num').isValid(5)).resolves.toBe(true);\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should REACH conditionally correctly","suites":["Yup"],"updatePoint":{"line":123,"column":42},"line":123,"code":"  it('should REACH conditionally correctly', async function () {\n    let num = number().oneOf([4]),\n      inst = object().shape({\n        num: number().max(4),\n        nested: object().shape({\n          arr: array().when('$bar', function ([bar]) {\n            return bar !== 3\n              ? array().of(number())\n              : array().of(\n                  object().shape({\n                    foo: number(),\n                    num: number().when('foo', ([foo]) => {\n                      if (foo === 5) return num;\n                    }),\n                  }),\n                );\n          }),\n        }),\n      });\n\n    let context = { bar: 3 };\n    let value = {\n      bar: 3,\n      nested: {\n        arr: [{ foo: 5 }, { foo: 3 }],\n      },\n    };\n\n    let options = {};\n    options.parent = value.nested.arr[0];\n    options.value = options.parent.num;\n    expect(reach(inst, 'nested.arr.num', value).resolve(options)).toBe(num);\n    expect(reach(inst, 'nested.arr[].num', value).resolve(options)).toBe(num);\n\n    options.context = context;\n    expect(reach(inst, 'nested.arr.num', value, context).resolve(options)).toBe(\n      num,\n    );\n    expect(\n      reach(inst, 'nested.arr[].num', value, context).resolve(options),\n    ).toBe(num);\n    expect(\n      reach(inst, 'nested.arr[0].num', value, context).resolve(options),\n    ).toBe(num);\n\n    // // should fail b/c item[1] is used to resolve the schema\n    options.parent = value.nested.arr[1];\n    options.value = options.parent.num;\n    expect(\n      reach(inst, 'nested[\"arr\"][1].num', value, context).resolve(options),\n    ).not.toBe(num);\n\n    let reached = reach(inst, 'nested.arr[].num', value, context);\n\n    await expect(\n      reached.validate(5, { context, parent: { foo: 4 } }),\n    ).resolves.toBeDefined();\n\n    await expect(\n      reached.validate(5, { context, parent: { foo: 5 } }),\n    ).rejects.toThrowError(/one of the following/);\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should reach through lazy","suites":["Yup"],"updatePoint":{"line":186,"column":31},"line":186,"code":"  it('should reach through lazy', async () => {\n    let types = {\n      1: object({ foo: string() }),\n      2: object({ foo: number() }),\n    };\n\n    await expect(\n      object({\n        x: array(lazy((val) => types[val.type])),\n      })\n        .strict()\n        .validate({\n          x: [\n            { type: 1, foo: '4' },\n            { type: 2, foo: '5' },\n          ],\n        }),\n    ).rejects.toThrowError(/must be a `number` type/);\n  });","file":"yup.js","skipped":false,"dir":"test"},{"name":"extending Schema should make method accessible everywhere","suites":["Yup","addMethod"],"updatePoint":{"line":207,"column":65},"line":207,"code":"    it('extending Schema should make method accessible everywhere', () => {\n      addMethod(Schema, 'foo', () => 'here');\n\n      expect(string().foo()).toBe('here');\n    });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should work with factories: %s","suites":["Yup","addMethod"],"line":213,"code":"    test.each([\n      ['mixed', mixed],\n      ['object', object],\n      ['array', array],\n      ['string', string],\n      ['number', number],\n      ['boolean', boolean],\n      ['date', date],\n    ])('should work with factories: %s', (_msg, factory) => {\n      addMethod(factory, 'foo', () => 'here');\n\n      expect(factory().foo()).toBe('here');\n    });","file":"yup.js","skipped":false,"dir":"test"},{"name":"should work with classes: %s","suites":["Yup","addMethod"],"line":227,"code":"    test.each([\n      ['mixed', MixedSchema],\n      ['object', ObjectSchema],\n      ['array', ArraySchema],\n      ['string', StringSchema],\n      ['number', NumberSchema],\n      ['boolean', BooleanSchema],\n      ['date', DateSchema],\n    ])('should work with classes: %s', (_msg, ctor) => {\n      addMethod(ctor, 'foo', () => 'here');\n\n      expect(new ctor().foo()).toBe('here');\n    });","file":"yup.js","skipped":false,"dir":"test"}]}