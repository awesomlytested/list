{"repo":"ReactiveX/rxjs","url":"https://github.com/ReactiveX/rxjs","branch":"master","configs":[{"package":"rxjs.dev","lang":"js","dir":"docs_app/tests","framework":"jasmine","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"rxjs","lang":"ts","dir":"spec","framework":"mocha","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"shows the landing page","suites":["RxJS Docs"],"line":7,"updatePoint":{"line":7,"column":28,"index":174},"code":"  it('shows the landing page', () => {\n    eyes.open(browser, 'Landing Page', 'RxJS Docs');\n    browser.get('');\n    eyes.checkWindow('Landing page!');\n    eyes.close();\n  });","file":"e2e/visual-testing.e2e-spec.ts","skipped":false,"dir":"docs_app/tests"},{"name":"shows the overview page","suites":["RxJS Docs"],"line":13,"updatePoint":{"line":13,"column":29,"index":351},"code":"  it('shows the overview page', () => {\n    eyes.open(browser, 'Overview Page', 'RxJS Docs');\n    browser.get('/guide/overview');\n    eyes.checkWindow('Overview page!');\n    eyes.close();\n  });","file":"e2e/visual-testing.e2e-spec.ts","skipped":false,"dir":"docs_app/tests"},{"name":"shows the API page","suites":["RxJS Docs"],"line":19,"updatePoint":{"line":19,"column":24,"index":540},"code":"  it('shows the API page', () => {\n    eyes.open(browser, 'API Page', 'RxJS Docs');\n    browser.get('/api');\n    eyes.checkWindow('API page!');\n    eyes.close();\n  });","file":"e2e/visual-testing.e2e-spec.ts","skipped":false,"dir":"docs_app/tests"},{"name":"shows the migration page","suites":["RxJS Docs"],"line":25,"updatePoint":{"line":25,"column":30,"index":714},"code":"  it('shows the migration page', () => {\n    eyes.open(browser, 'Migration Page', 'RxJS Docs');\n    browser.get('/guide/v6/migration');\n    eyes.checkWindow('Migration page!');\n    eyes.close();\n  });","file":"e2e/visual-testing.e2e-spec.ts","skipped":false,"dir":"docs_app/tests"},{"name":"shows the team page","suites":["RxJS Docs"],"line":31,"updatePoint":{"line":31,"column":25,"index":910},"code":"  it('shows the team page', () => {\n    eyes.open(browser, 'Team Page', 'RxJS Docs');\n    browser.get('/team');\n    eyes.checkWindow('Team page!');\n    eyes.close();\n  });","file":"e2e/visual-testing.e2e-spec.ts","skipped":false,"dir":"docs_app/tests"},{"name":"should export static ajax observable creator functions","suites":["index"],"updatePoint":{"line":5,"column":60},"line":5,"code":"  it('should export static ajax observable creator functions', () => {\n    expect(index.ajax).to.exist;\n  });","file":"ajax/index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export Ajax data classes","suites":["index"],"updatePoint":{"line":9,"column":37},"line":9,"code":"  it('should export Ajax data classes', () => {\n    expect(index.AjaxResponse).to.exist;\n    expect(index.AjaxError).to.exist;\n    expect(index.AjaxTimeoutError).to.exist;\n    // Interfaces can be checked by creating a variable of that type\n    let ajaxRequest: index.AjaxRequest;\n  });","file":"ajax/index-spec.ts","skipped":false,"dir":"spec"},{"name":"should have a Promise property that defaults to nothing","suites":["config"],"updatePoint":{"line":9,"column":61},"line":9,"code":"  it('should have a Promise property that defaults to nothing', () => {\n    expect(config).to.have.property('Promise');\n    expect(config.Promise).to.be.undefined;\n  });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should default to null","suites":["config","onUnhandledError"],"updatePoint":{"line":19,"column":30},"line":19,"code":"    it('should default to null', () => {\n      expect(config.onUnhandledError).to.be.null;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should call asynchronously if an error is emitted and not handled by the consumer observer","suites":["config","onUnhandledError"],"updatePoint":{"line":23,"column":98},"line":23,"code":"    it('should call asynchronously if an error is emitted and not handled by the consumer observer', (done) => {\n      let called = false;\n      const results: any[] = [];\n\n      config.onUnhandledError = (err) => {\n        called = true;\n        expect(err).to.equal('bad');\n        done();\n      };\n\n      const source = new Observable<number>((subscriber) => {\n        subscriber.next(1);\n        subscriber.error('bad');\n      });\n\n      source.subscribe({\n        next: (value) => results.push(value),\n      });\n      expect(called).to.be.false;\n      expect(results).to.deep.equal([1]);\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should call asynchronously if an error is emitted and not handled by the consumer next callback","suites":["config","onUnhandledError"],"updatePoint":{"line":45,"column":103},"line":45,"code":"    it('should call asynchronously if an error is emitted and not handled by the consumer next callback', (done) => {\n      let called = false;\n      const results: any[] = [];\n\n      config.onUnhandledError = (err) => {\n        called = true;\n        expect(err).to.equal('bad');\n        done();\n      };\n\n      const source = new Observable<number>((subscriber) => {\n        subscriber.next(1);\n        subscriber.error('bad');\n      });\n\n      source.subscribe((value) => results.push(value));\n      expect(called).to.be.false;\n      expect(results).to.deep.equal([1]);\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should call asynchronously if an error is emitted and not handled by the consumer in the empty case","suites":["config","onUnhandledError"],"updatePoint":{"line":65,"column":107},"line":65,"code":"    it('should call asynchronously if an error is emitted and not handled by the consumer in the empty case', (done) => {\n      let called = false;\n      config.onUnhandledError = (err) => {\n        called = true;\n        expect(err).to.equal('bad');\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.error('bad');\n      });\n\n      source.subscribe();\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be called if two errors are sent to the subscriber","suites":["config","onUnhandledError"],"updatePoint":{"line":89,"column":69},"line":89,"code":"    it('should not be called if two errors are sent to the subscriber', (done) => {\n      let called = false;\n      config.onUnhandledError = () => {\n        called = true;\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.error('handled');\n        subscriber.error('swallowed');\n      });\n\n      let syncSentError: any;\n      source.subscribe({\n        error: (err) => {\n          syncSentError = err;\n        },\n      });\n\n      expect(syncSentError).to.equal('handled');\n      // When called, onUnhandledError is called on a timeout, so delay the\n      // the assertion of the expectation until after the point at which\n      // onUnhandledError would have been called.\n      timeoutProvider.setTimeout(() => {\n        expect(called).to.be.false;\n        done();\n      });\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should default to null","suites":["config","onStoppedNotification"],"updatePoint":{"line":123,"column":30},"line":123,"code":"    it('should default to null', () => {\n      expect(config.onStoppedNotification).to.be.null;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be called asynchronously if a subscription setup errors after the subscription is closed by an error","suites":["config","onStoppedNotification"],"updatePoint":{"line":127,"column":115},"line":127,"code":"    it('should be called asynchronously if a subscription setup errors after the subscription is closed by an error', (done) => {\n      let called = false;\n      config.onStoppedNotification = (notification) => {\n        called = true;\n        expect(notification.kind).to.equal('E');\n        expect(notification).to.have.property('error', 'bad');\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.error('handled');\n        throw 'bad';\n      });\n\n      let syncSentError: any;\n      source.subscribe({\n        error: (err) => {\n          syncSentError = err;\n        },\n      });\n\n      expect(syncSentError).to.equal('handled');\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be called asynchronously if a subscription setup errors after the subscription is closed by a completion","suites":["config","onStoppedNotification"],"updatePoint":{"line":152,"column":119},"line":152,"code":"    it('should be called asynchronously if a subscription setup errors after the subscription is closed by a completion', (done) => {\n      let called = false;\n      let completed = false;\n      config.onStoppedNotification = (notification) => {\n        called = true;\n        expect(notification.kind).to.equal('E');\n        expect(notification).to.have.property('error', 'bad');\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.complete();\n        throw 'bad';\n      });\n\n      source.subscribe({\n        error: () => {\n          throw 'should not be called';\n        },\n        complete: () => {\n          completed = true;\n        },\n      });\n\n      expect(completed).to.be.true;\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be called if a next is sent to the stopped subscriber","suites":["config","onStoppedNotification"],"updatePoint":{"line":180,"column":68},"line":180,"code":"    it('should be called if a next is sent to the stopped subscriber', (done) => {\n      let called = false;\n      config.onStoppedNotification = (notification) => {\n        called = true;\n        expect(notification.kind).to.equal('N');\n        expect(notification).to.have.property('value', 2);\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.next(1);\n        subscriber.complete();\n        subscriber.next(2);\n      });\n\n      let syncSentValue: any;\n      source.subscribe({\n        next: (value) => {\n          syncSentValue = value;\n        },\n      });\n\n      expect(syncSentValue).to.equal(1);\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be called if two errors are sent to the subscriber","suites":["config","onStoppedNotification"],"updatePoint":{"line":206,"column":65},"line":206,"code":"    it('should be called if two errors are sent to the subscriber', (done) => {\n      let called = false;\n      config.onStoppedNotification = (notification) => {\n        called = true;\n        expect(notification.kind).to.equal('E');\n        expect(notification).to.have.property('error', 'swallowed');\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.error('handled');\n        subscriber.error('swallowed');\n      });\n\n      let syncSentError: any;\n      source.subscribe({\n        error: (err) => {\n          syncSentError = err;\n        },\n      });\n\n      expect(syncSentError).to.equal('handled');\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be called if two completes are sent to the subscriber","suites":["config","onStoppedNotification"],"updatePoint":{"line":231,"column":68},"line":231,"code":"    it('should be called if two completes are sent to the subscriber', (done) => {\n      let called = false;\n      config.onStoppedNotification = (notification) => {\n        called = true;\n        expect(notification.kind).to.equal('C');\n        done();\n      };\n\n      const source = new Observable((subscriber) => {\n        subscriber.complete();\n        subscriber.complete();\n      });\n\n      source.subscribe();\n\n      expect(called).to.be.false;\n    });","file":"config-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources","suites":["multicasting equivalent tests"],"updatePoint":{"line":89,"column":58},"line":89,"code":"    it(`should be equivalent for ${name} for async sources`, () => {\n      rxTest.run(({ cold, expectObservable }) => {\n        const source = cold('----a---b---c----d---e----|');\n        const old = oldExpression(source);\n        const updated = updatedExpression(source);\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources that repeat","suites":["multicasting equivalent tests"],"updatePoint":{"line":98,"column":70},"line":98,"code":"    it(`should be equivalent for ${name} for async sources that repeat`, () => {\n      rxTest.run(({ cold, expectObservable }) => {\n        const source = cold('----a---b---c----d---e----|');\n        const old = oldExpression(source).pipe(repeat(3));\n        const updated = updatedExpression(source).pipe(repeat(3));\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources that retry","suites":["multicasting equivalent tests"],"updatePoint":{"line":107,"column":69},"line":107,"code":"    it(`should be equivalent for ${name} for async sources that retry`, () => {\n      rxTest.run(({ cold, expectObservable }) => {\n        const source = cold('----a---b---c----d---e----#');\n        const old = oldExpression(source).pipe(retry(3));\n        const updated = updatedExpression(source).pipe(retry(3));\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources","suites":["multicasting equivalent tests"],"updatePoint":{"line":116,"column":58},"line":116,"code":"    it(`should be equivalent for ${name} for async sources`, () => {\n      rxTest.run(({ expectObservable }) => {\n        const source = of('a', 'b', 'c');\n        const old = oldExpression(source);\n        const updated = updatedExpression(source);\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources that repeat","suites":["multicasting equivalent tests"],"updatePoint":{"line":125,"column":70},"line":125,"code":"    it(`should be equivalent for ${name} for async sources that repeat`, () => {\n      rxTest.run(({ expectObservable }) => {\n        const source = of('a', 'b', 'c');\n        const old = oldExpression(source).pipe(repeat(3));\n        const updated = updatedExpression(source).pipe(repeat(3));\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for  for async sources that retry","suites":["multicasting equivalent tests"],"updatePoint":{"line":134,"column":69},"line":134,"code":"    it(`should be equivalent for ${name} for async sources that retry`, () => {\n      rxTest.run(({ expectObservable }) => {\n        const source = of('a', 'b', 'c');\n        const old = oldExpression(source).pipe(retry(3));\n        const updated = updatedExpression(source).pipe(retry(3));\n        expectObservable(updated).toEqual(old);\n      });\n    });","file":"deprecation-equivalents/multicasting-deprecations-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the first value as a promise","suites":["firstValueFrom"],"updatePoint":{"line":6,"column":46},"line":6,"code":"  it('should emit the first value as a promise', async () => {\n    let finalized = false;\n    const source = interval(10).pipe(finalize(() => (finalized = true)));\n    const result = await firstValueFrom(source);\n    expect(result).to.equal(0);\n    expect(finalized).to.be.true;\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a default value","suites":["firstValueFrom"],"updatePoint":{"line":14,"column":36},"line":14,"code":"  it('should support a default value', async () => {\n    const source = EMPTY;\n    const result = await firstValueFrom(source, { defaultValue: 0 });\n    expect(result).to.equal(0);\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should support an undefined config","suites":["firstValueFrom"],"updatePoint":{"line":20,"column":40},"line":20,"code":"  it('should support an undefined config', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await firstValueFrom(source, undefined as any);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for empty observables","suites":["firstValueFrom"],"updatePoint":{"line":31,"column":40},"line":31,"code":"  it('should error for empty observables', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await firstValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for errored observables","suites":["firstValueFrom"],"updatePoint":{"line":42,"column":42},"line":42,"code":"  it('should error for errored observables', async () => {\n    const source = throwError(() => new Error('blorp!'));\n    let error: any = null;\n    try {\n      await firstValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(Error);\n    expect(error.message).to.equal('blorp!');\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with a synchronous observable","suites":["firstValueFrom"],"updatePoint":{"line":54,"column":47},"line":54,"code":"  it('should work with a synchronous observable', async () => {\n    let finalized = false;\n    const source = of('apples', 'bananas').pipe(finalize(() => (finalized = true)));\n    const result = await firstValueFrom(source);\n    expect(result).to.equal('apples');\n    expect(finalized).to.be.true;\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when resolved","suites":["firstValueFrom"],"updatePoint":{"line":62,"column":69},"line":62,"code":"  it('should stop listening to a synchronous observable when resolved', async () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    const result = await firstValueFrom(synchronousObservable);\n    expect(sideEffects).to.deep.equal([0]);\n  });","file":"firstValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should simulate interop observables","suites":["interop helper"],"updatePoint":{"line":7,"column":41},"line":7,"code":"  it('should simulate interop observables', () => {\n    const observable: any = asInteropObservable(of(42));\n    expect(observable).to.not.be.instanceOf(Observable);\n    expect(observable[symbolObservable]).to.be.a('function');\n  });","file":"helpers/interop-helper-spec.ts","skipped":false,"dir":"spec"},{"name":"should simulate interop subscribers","suites":["interop helper"],"updatePoint":{"line":13,"column":41},"line":13,"code":"  it('should simulate interop subscribers', () => {\n    const subscriber: any = asInteropSubscriber(new Subscriber());\n    expect(subscriber).to.not.be.instanceOf(Subscriber);\n  });","file":"helpers/interop-helper-spec.ts","skipped":false,"dir":"spec"},{"name":"should export Observable","suites":["index"],"updatePoint":{"line":6,"column":30},"line":6,"code":"  it('should export Observable', () => {\n    expect(index.Observable).to.exist;\n    expect(index.ConnectableObservable).to.exist;\n    // Interfaces can be checked by creating a variable of that type\n    let operator: index.Operator<any, any>;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export the Subject types","suites":["index"],"updatePoint":{"line":13,"column":37},"line":13,"code":"  it('should export the Subject types', () => {\n    expect(index.Subject).to.exist;\n    expect(index.BehaviorSubject).to.exist;\n    expect(index.ReplaySubject).to.exist;\n    expect(index.AsyncSubject).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export the schedulers","suites":["index"],"updatePoint":{"line":20,"column":34},"line":20,"code":"  it('should export the schedulers', () => {\n    expect(index.asapScheduler).to.exist;\n    expect(index.asyncScheduler).to.exist;\n    expect(index.queueScheduler).to.exist;\n    expect(index.animationFrameScheduler).to.exist;\n    expect(index.VirtualTimeScheduler).to.exist;\n    expect(index.VirtualAction).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export Subscription","suites":["index"],"updatePoint":{"line":29,"column":32},"line":29,"code":"  it('should export Subscription', () => {\n    expect(index.Subscription).to.exist;\n    expect(index.Subscriber).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export Notification","suites":["index"],"updatePoint":{"line":34,"column":32},"line":34,"code":"  it('should export Notification', () => {\n    expect(index.Notification).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export the appropriate utilities","suites":["index"],"updatePoint":{"line":38,"column":45},"line":38,"code":"  it('should export the appropriate utilities', () => {\n    expect(index.pipe).to.exist;\n    expect(index.noop).to.exist;\n    expect(index.identity).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export error types","suites":["index"],"updatePoint":{"line":44,"column":31},"line":44,"code":"  it('should export error types', () => {\n    expect(index.ArgumentOutOfRangeError).to.exist;\n    expect(index.EmptyError).to.exist;\n    expect(index.ObjectUnsubscribedError).to.exist;\n    expect(index.UnsubscriptionError).to.exist;\n    expect(index.TimeoutError).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export constants","suites":["index"],"updatePoint":{"line":52,"column":29},"line":52,"code":"  it('should export constants', () => {\n    expect(index.EMPTY).to.exist;\n    expect(index.NEVER).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export static observable creator functions","suites":["index"],"updatePoint":{"line":57,"column":55},"line":57,"code":"  it('should export static observable creator functions', () => {\n    expect(index.bindCallback).to.exist;\n    expect(index.bindNodeCallback).to.exist;\n    expect(index.combineLatest).to.exist;\n    expect(index.concat).to.exist;\n    expect(index.defer).to.exist;\n    expect(index.empty).to.exist;\n    expect(index.forkJoin).to.exist;\n    expect(index.from).to.exist;\n    expect(index.fromEvent).to.exist;\n    expect(index.fromEventPattern).to.exist;\n    expect(index.generate).to.exist;\n    expect(index.iif).to.exist;\n    expect(index.interval).to.exist;\n    expect(index.merge).to.exist;\n    expect(index.of).to.exist;\n    expect(index.onErrorResumeNext).to.exist;\n    expect(index.pairs).to.exist;\n    expect(index.race).to.exist;\n    expect(index.range).to.exist;\n    expect(index.throwError).to.exist;\n    expect(index.timer).to.exist;\n    expect(index.using).to.exist;\n    expect(index.zip).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should export all of the operators","suites":["index"],"updatePoint":{"line":83,"column":40},"line":83,"code":"  it('should export all of the operators', () => {\n    expect(index.audit).to.exist;\n    expect(index.auditTime).to.exist;\n    expect(index.buffer).to.exist;\n    expect(index.bufferCount).to.exist;\n    expect(index.bufferTime).to.exist;\n    expect(index.bufferToggle).to.exist;\n    expect(index.bufferWhen).to.exist;\n    expect(index.catchError).to.exist;\n    expect(index.combineAll).to.exist;\n    expect(index.combineLatestAll).to.exist;\n    expect(index.combineLatestWith).to.exist;\n    expect(index.concatAll).to.exist;\n    expect(index.concatMap).to.exist;\n    expect(index.concatMapTo).to.exist;\n    expect(index.concatWith).to.exist;\n    expect(index.connect).to.exist;\n    expect(index.count).to.exist;\n    expect(index.debounce).to.exist;\n    expect(index.debounceTime).to.exist;\n    expect(index.defaultIfEmpty).to.exist;\n    expect(index.delay).to.exist;\n    expect(index.delayWhen).to.exist;\n    expect(index.dematerialize).to.exist;\n    expect(index.distinct).to.exist;\n    expect(index.distinctUntilChanged).to.exist;\n    expect(index.distinctUntilKeyChanged).to.exist;\n    expect(index.elementAt).to.exist;\n    expect(index.endWith).to.exist;\n    expect(index.every).to.exist;\n    expect(index.exhaust).to.exist;\n    expect(index.exhaustAll).to.exist;\n    expect(index.exhaustMap).to.exist;\n    expect(index.expand).to.exist;\n    expect(index.filter).to.exist;\n    expect(index.finalize).to.exist;\n    expect(index.find).to.exist;\n    expect(index.findIndex).to.exist;\n    expect(index.first).to.exist;\n    expect(index.groupBy).to.exist;\n    expect(index.ignoreElements).to.exist;\n    expect(index.isEmpty).to.exist;\n    expect(index.last).to.exist;\n    expect(index.map).to.exist;\n    expect(index.mapTo).to.exist;\n    expect(index.materialize).to.exist;\n    expect(index.max).to.exist;\n    expect(index.mergeAll).to.exist;\n    expect(index.flatMap).to.exist;\n    expect(index.mergeMap).to.exist;\n    expect(index.mergeMapTo).to.exist;\n    expect(index.mergeScan).to.exist;\n    expect(index.mergeWith).to.exist;\n    expect(index.min).to.exist;\n    expect(index.multicast).to.exist;\n    expect(index.observeOn).to.exist;\n    expect(index.pairwise).to.exist;\n    expect(index.pluck).to.exist;\n    expect(index.publish).to.exist;\n    expect(index.publishBehavior).to.exist;\n    expect(index.publishLast).to.exist;\n    expect(index.publishReplay).to.exist;\n    expect(index.raceWith).to.exist;\n    expect(index.reduce).to.exist;\n    expect(index.repeat).to.exist;\n    expect(index.repeatWhen).to.exist;\n    expect(index.retry).to.exist;\n    expect(index.retryWhen).to.exist;\n    expect(index.refCount).to.exist;\n    expect(index.sample).to.exist;\n    expect(index.sampleTime).to.exist;\n    expect(index.scan).to.exist;\n    expect(index.sequenceEqual).to.exist;\n    expect(index.share).to.exist;\n    expect(index.shareReplay).to.exist;\n    expect(index.single).to.exist;\n    expect(index.skip).to.exist;\n    expect(index.skipLast).to.exist;\n    expect(index.skipUntil).to.exist;\n    expect(index.skipWhile).to.exist;\n    expect(index.startWith).to.exist;\n    expect(index.subscribeOn).to.exist;\n    expect(index.switchAll).to.exist;\n    expect(index.switchMap).to.exist;\n    expect(index.switchMapTo).to.exist;\n    expect(index.switchScan).to.exist;\n    expect(index.take).to.exist;\n    expect(index.takeLast).to.exist;\n    expect(index.takeUntil).to.exist;\n    expect(index.takeWhile).to.exist;\n    expect(index.tap).to.exist;\n    expect(index.throttle).to.exist;\n    expect(index.throttleTime).to.exist;\n    expect(index.throwIfEmpty).to.exist;\n    expect(index.timeInterval).to.exist;\n    expect(index.timeout).to.exist;\n    expect(index.timeoutWith).to.exist;\n    expect(index.timestamp).to.exist;\n    expect(index.toArray).to.exist;\n    expect(index.window).to.exist;\n    expect(index.windowCount).to.exist;\n    expect(index.windowTime).to.exist;\n    expect(index.windowToggle).to.exist;\n    expect(index.windowWhen).to.exist;\n    expect(index.withLatestFrom).to.exist;\n    expect(index.zipAll).to.exist;\n    expect(index.zipWith).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should expose configuration","suites":["index"],"updatePoint":{"line":192,"column":33},"line":192,"code":"  it('should expose configuration', () => {\n    expect(index.config).to.exist;\n  });","file":"index-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last value as a promise","suites":["lastValueFrom"],"updatePoint":{"line":6,"column":45},"line":6,"code":"  it('should emit the last value as a promise', async () => {\n    let finalized = false;\n    const source = interval(2).pipe(\n      take(10),\n      finalize(() => (finalized = true))\n    );\n    const result = await lastValueFrom(source);\n    expect(result).to.equal(9);\n    expect(finalized).to.be.true;\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a default value","suites":["lastValueFrom"],"updatePoint":{"line":17,"column":36},"line":17,"code":"  it('should support a default value', async () => {\n    const source = EMPTY;\n    const result = await lastValueFrom(source, { defaultValue: 0 });\n    expect(result).to.equal(0);\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should support an undefined config","suites":["lastValueFrom"],"updatePoint":{"line":23,"column":40},"line":23,"code":"  it('should support an undefined config', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await lastValueFrom(source, undefined as any);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for empty observables","suites":["lastValueFrom"],"updatePoint":{"line":34,"column":40},"line":34,"code":"  it('should error for empty observables', async () => {\n    const source = EMPTY;\n    let error: any = null;\n    try {\n      await lastValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(EmptyError);\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for errored observables","suites":["lastValueFrom"],"updatePoint":{"line":45,"column":42},"line":45,"code":"  it('should error for errored observables', async () => {\n    const source = throwError(() => new Error('blorp!'));\n    let error: any = null;\n    try {\n      await lastValueFrom(source);\n    } catch (err) {\n      error = err;\n    }\n    expect(error).to.be.an.instanceOf(Error);\n    expect(error.message).to.equal('blorp!');\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with a synchronous observable","suites":["lastValueFrom"],"updatePoint":{"line":57,"column":47},"line":57,"code":"  it('should work with a synchronous observable', async () => {\n    let finalized = false;\n    const source = of('apples', 'bananas').pipe(finalize(() => (finalized = true)));\n    const result = await lastValueFrom(source);\n    expect(result).to.equal('bananas');\n    expect(finalized).to.be.true;\n  });","file":"lastValueFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["Notification"],"updatePoint":{"line":13,"column":18},"line":13,"code":"  it('should exist', () => {\n    expect(Notification).exist;\n    expect(Notification).to.be.a('function');\n  });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should not allow convert to observable if given kind is unknown","suites":["Notification"],"updatePoint":{"line":18,"column":69},"line":18,"code":"  it('should not allow convert to observable if given kind is unknown', () => {\n    const n = new Notification('x' as any);\n    expect(() => n.toObservable()).to.throw();\n  });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a Notification","suites":["Notification","createNext"],"updatePoint":{"line":24,"column":36},"line":24,"code":"    it('should return a Notification', () => {\n      const n = Notification.createNext('test');\n      expect(n instanceof Notification).to.be.true;\n      expect(n.value).to.equal('test');\n      expect(n.kind).to.equal('N');\n      expect(n.error).to.be.a('undefined');\n      expect(n.hasValue).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a Notification","suites":["Notification","createError"],"updatePoint":{"line":35,"column":36},"line":35,"code":"    it('should return a Notification', () => {\n      const n = Notification.createError('test');\n      expect(n instanceof Notification).to.be.true;\n      expect(n.value).to.be.a('undefined');\n      expect(n.kind).to.equal('E');\n      expect(n.error).to.equal('test');\n      expect(n.hasValue).to.be.false;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a Notification","suites":["Notification","createComplete"],"updatePoint":{"line":46,"column":36},"line":46,"code":"    it('should return a Notification', () => {\n      const n = Notification.createComplete();\n      expect(n instanceof Notification).to.be.true;\n      expect(n.value).to.be.a('undefined');\n      expect(n.kind).to.equal('C');\n      expect(n.error).to.be.a('undefined');\n      expect(n.hasValue).to.be.false;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should create observable from a next Notification","suites":["Notification","toObservable"],"updatePoint":{"line":57,"column":57},"line":57,"code":"    it('should create observable from a next Notification', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const value = 'a';\n        const next = Notification.createNext(value);\n        expectObservable(next.toObservable()).toBe('(a|)');\n      });\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should create observable from a complete Notification","suites":["Notification","toObservable"],"updatePoint":{"line":65,"column":61},"line":65,"code":"    it('should create observable from a complete Notification', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const complete = Notification.createComplete();\n        expectObservable(complete.toObservable()).toBe('|');\n      });\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should create observable from a error Notification","suites":["Notification","toObservable"],"updatePoint":{"line":72,"column":58},"line":72,"code":"    it('should create observable from a error Notification', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const error = Notification.createError('error');\n        expectObservable(error.toObservable()).toBe('#');\n      });\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should create new next Notification with value","suites":["Notification","static reference"],"updatePoint":{"line":81,"column":54},"line":81,"code":"    it('should create new next Notification with value', () => {\n      const value = 'a';\n      const first = Notification.createNext(value);\n      const second = Notification.createNext(value);\n\n      expect(first).not.to.equal(second);\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should create new error Notification","suites":["Notification","static reference"],"updatePoint":{"line":89,"column":44},"line":89,"code":"    it('should create new error Notification', () => {\n      const first = Notification.createError();\n      const second = Notification.createError();\n\n      expect(first).not.to.equal(second);\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should return static complete Notification reference","suites":["Notification","static reference"],"updatePoint":{"line":96,"column":60},"line":96,"code":"    it('should return static complete Notification reference', () => {\n      const first = Notification.createComplete();\n      const second = Notification.createComplete();\n\n      expect(first).to.equal(second);\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke on next","suites":["Notification","do"],"updatePoint":{"line":105,"column":29},"line":105,"code":"    it('should invoke on next', () => {\n      const n = Notification.createNext('a');\n      let invoked = false;\n      n.do(\n        () => {\n          invoked = true;\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      expect(invoked).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke on error","suites":["Notification","do"],"updatePoint":{"line":123,"column":30},"line":123,"code":"    it('should invoke on error', () => {\n      const n = Notification.createError();\n      let invoked = false;\n      n.do(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          invoked = true;\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      expect(invoked).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke on complete","suites":["Notification","do"],"updatePoint":{"line":141,"column":33},"line":141,"code":"    it('should invoke on complete', () => {\n      const n = Notification.createComplete();\n      let invoked = false;\n      n.do(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          invoked = true;\n        }\n      );\n\n      expect(invoked).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept observer for next Notification","suites":["Notification","accept"],"updatePoint":{"line":161,"column":52},"line":161,"code":"    it('should accept observer for next Notification', () => {\n      const value = 'a';\n      let observed = false;\n      const n = Notification.createNext(value);\n      const observer = Subscriber.create(\n        (x?: string) => {\n          expect(x).to.equal(value);\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      n.accept(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept observer for error Notification","suites":["Notification","accept"],"updatePoint":{"line":182,"column":53},"line":182,"code":"    it('should accept observer for error Notification', () => {\n      let observed = false;\n      const n = Notification.createError();\n      const observer = Subscriber.create(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      n.accept(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept observer for complete Notification","suites":["Notification","accept"],"updatePoint":{"line":201,"column":56},"line":201,"code":"    it('should accept observer for complete Notification', () => {\n      let observed = false;\n      const n = Notification.createComplete();\n      const observer = Subscriber.create(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          observed = true;\n        }\n      );\n\n      n.accept(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept function for next Notification","suites":["Notification","accept"],"updatePoint":{"line":220,"column":52},"line":220,"code":"    it('should accept function for next Notification', () => {\n      const value = 'a';\n      let observed = false;\n      const n = Notification.createNext(value);\n\n      n.accept(\n        (x: string) => {\n          expect(x).to.equal(value);\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept function for error Notification","suites":["Notification","accept"],"updatePoint":{"line":240,"column":53},"line":240,"code":"    it('should accept function for error Notification', () => {\n      let observed = false;\n      const error = 'error';\n      const n = Notification.createError(error);\n\n      n.accept(\n        () => {\n          throw 'should not be called';\n        },\n        (err: any) => {\n          expect(err).to.equal(error);\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept function for complete Notification","suites":["Notification","accept"],"updatePoint":{"line":260,"column":56},"line":260,"code":"    it('should accept function for complete Notification', () => {\n      let observed = false;\n      const n = Notification.createComplete();\n\n      n.accept(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          observed = true;\n        }\n      );\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe for next Notification","suites":["Notification","observe"],"updatePoint":{"line":280,"column":44},"line":280,"code":"    it('should observe for next Notification', () => {\n      const value = 'a';\n      let observed = false;\n      const n = Notification.createNext(value);\n      const observer = Subscriber.create(\n        (x?: string) => {\n          expect(x).to.equal(value);\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      n.observe(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe for error Notification","suites":["Notification","observe"],"updatePoint":{"line":301,"column":45},"line":301,"code":"    it('should observe for error Notification', () => {\n      let observed = false;\n      const n = Notification.createError();\n      const observer = Subscriber.create(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          observed = true;\n        },\n        () => {\n          throw 'should not be called';\n        }\n      );\n\n      n.observe(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe for complete Notification","suites":["Notification","observe"],"updatePoint":{"line":320,"column":48},"line":320,"code":"    it('should observe for complete Notification', () => {\n      let observed = false;\n      const n = Notification.createComplete();\n      const observer = Subscriber.create(\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          throw 'should not be called';\n        },\n        () => {\n          observed = true;\n        }\n      );\n\n      n.observe(observer);\n      expect(observed).to.be.true;\n    });","file":"Notification-spec.ts","skipped":false,"dir":"spec"},{"name":"should be constructed with a subscriber function","suites":["Observable"],"updatePoint":{"line":25,"column":54},"line":25,"code":"  it('should be constructed with a subscriber function', (done) => {\n    const source = new Observable<number>(function (observer) {\n      expectFullObserver(observer);\n      observer.next(1);\n      observer.complete();\n    });\n\n    source.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(1);\n      }, complete: done }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should send errors thrown in the constructor down the error path","suites":["Observable"],"updatePoint":{"line":39,"column":70},"line":39,"code":"  it('should send errors thrown in the constructor down the error path', (done) => {\n    new Observable<number>(() => {\n      throw new Error('this should be handled');\n    }).subscribe({\n      error(err) {\n        expect(err).to.exist.and.be.instanceof(Error).and.have.property('message', 'this should be handled');\n        done();\n      },\n    });\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow empty ctor, which is effectively a never-observable","suites":["Observable"],"updatePoint":{"line":50,"column":70},"line":50,"code":"  it('should allow empty ctor, which is effectively a never-observable', () => {\n    rxTestScheduler.run(({ expectObservable }) => {\n      const result = new Observable<any>();\n      expectObservable(result).toBe('-');\n    });\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should iterate and return a Promise","suites":["Observable","forEach"],"updatePoint":{"line":58,"column":43},"line":58,"code":"    it('should iterate and return a Promise', (done) => {\n      const expected = [1, 2, 3];\n      const result = of(1, 2, 3)\n        .forEach(function (x) {\n          expect(x).to.equal(expected.shift());\n        }, Promise)\n        .then(() => {\n          done();\n        });\n\n      expect(result.then).to.be.a('function');\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should reject promise when in error","suites":["Observable","forEach"],"updatePoint":{"line":71,"column":43},"line":71,"code":"    it('should reject promise when in error', (done) => {\n      throwError(() => ('bad'))\n        .forEach(() => {\n          done(new Error('should not be called'));\n        }, Promise)\n        .then(\n          () => {\n            done(new Error('should not complete'));\n          },\n          (err) => {\n            expect(err).to.equal('bad');\n            done();\n          }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow Promise to be globally configured","suites":["Observable","forEach"],"updatePoint":{"line":87,"column":54},"line":87,"code":"    it('should allow Promise to be globally configured', async () => {\n      try {\n        let wasCalled = false;\n\n        config.Promise = function MyPromise(callback: any) {\n          wasCalled = true;\n          return new Promise<number>(callback);\n        } as any;\n\n        await of(42).forEach((x) => {\n          expect(x).to.equal(42);\n        })\n\n        expect(wasCalled).to.be.true;\n      } finally {\n        config.Promise = undefined;\n      }\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should reject promise if nextHandler throws","suites":["Observable","forEach"],"updatePoint":{"line":106,"column":51},"line":106,"code":"    it('should reject promise if nextHandler throws', (done) => {\n      const results: number[] = [];\n\n      of(1, 2, 3)\n        .forEach((x) => {\n          if (x === 3) {\n            throw new Error('NO THREES!');\n          }\n          results.push(x);\n        }, Promise)\n        .then(\n          () => {\n            done(new Error('should not be called'));\n          },\n          (err) => {\n            expect(err).to.be.an('error', 'NO THREES!');\n            expect(results).to.deep.equal([1, 2]);\n          }\n        )\n        .then(() => {\n          done();\n        });\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous throw from the next handler","suites":["Observable","forEach"],"updatePoint":{"line":130,"column":63},"line":130,"code":"    it('should handle a synchronous throw from the next handler', () => {\n      const expected = new Error('I told, you Bobby Boucher, threes are the debil!');\n      const syncObservable = new Observable<number>((observer) => {\n        observer.next(1);\n        observer.next(2);\n        observer.next(3);\n        observer.next(4);\n      });\n\n      const results: Array<number | Error> = [];\n\n      return syncObservable\n        .forEach((x) => {\n          results.push(x);\n          if (x === 3) {\n            throw expected;\n          }\n        })\n        .then(\n          () => {\n            throw new Error('should not be called');\n          },\n          (err) => {\n            results.push(err);\n            // The error should unsubscribe from the source, meaning we \n            // should not see the number 4.\n            expect(results).to.deep.equal([1, 2, 3, expected]);\n          }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an asynchronous throw from the next handler and tear down","suites":["Observable","forEach"],"updatePoint":{"line":161,"column":79},"line":161,"code":"    it('should handle an asynchronous throw from the next handler and tear down', () => {\n      const expected = new Error('I told, you Bobby Boucher, twos are the debil!');\n      const asyncObservable = new Observable<number>((observer) => {\n        let i = 1;\n        const id = setInterval(() => observer.next(i++), 1);\n\n        return () => {\n          clearInterval(id);\n        };\n      });\n\n      const results: Array<number | Error> = [];\n\n      return asyncObservable\n        .forEach((x) => {\n          results.push(x);\n          if (x === 2) {\n            throw expected;\n          }\n        })\n        .then(\n          () => {\n            throw new Error('should not be called');\n          },\n          (err) => {\n            results.push(err);\n            expect(results).to.deep.equal([1, 2, expected]);\n          }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with handlers with hacked bind methods","suites":["Observable","subscribe"],"updatePoint":{"line":194,"column":58},"line":194,"code":"    it('should work with handlers with hacked bind methods', () => {\n      const source = of('Hi');\n      const results: any[] = [];\n      const next = function (value: string) {\n        results.push(value);\n      }\n      next.bind = () => { /* lol */};\n      \n      const complete = function () {\n        results.push('done');\n      }\n      complete.bind = () => { /* lol */};\n\n      source.subscribe({ next, complete });\n      expect(results).to.deep.equal(['Hi', 'done']);\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with handlers with hacked bind methods, in the error case","suites":["Observable","subscribe"],"updatePoint":{"line":211,"column":77},"line":211,"code":"    it('should work with handlers with hacked bind methods, in the error case', () => {\n      const source = throwError(() => 'an error');\n      const results: any[] = [];\n      const error = function (value: string) {\n        results.push(value);\n      }\n\n      source.subscribe({ error });\n      expect(results).to.deep.equal(['an error']);\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should be synchronous","suites":["Observable","subscribe"],"updatePoint":{"line":222,"column":29},"line":222,"code":"    it('should be synchronous', () => {\n      let subscribed = false;\n      let nexted: string;\n      let completed: boolean;\n      const source = new Observable<string>((observer) => {\n        subscribed = true;\n        observer.next('wee');\n        expect(nexted).to.equal('wee');\n        observer.complete();\n        expect(completed).to.be.true;\n      });\n\n      expect(subscribed).to.be.false;\n\n      let mutatedByNext = false;\n      let mutatedByComplete = false;\n\n      source.subscribe(\n        { next: (x) => {\n          nexted = x;\n          mutatedByNext = true;\n        }, complete: () => {\n          completed = true;\n          mutatedByComplete = true;\n        } }\n      );\n\n      expect(mutatedByNext).to.be.true;\n      expect(mutatedByComplete).to.be.true;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should work when subscribe is called with no arguments","suites":["Observable","subscribe"],"updatePoint":{"line":253,"column":62},"line":253,"code":"    it('should work when subscribe is called with no arguments', () => {\n      const source = new Observable<string>((subscriber) => {\n        subscriber.next('foo');\n        subscriber.complete();\n      });\n\n      source.subscribe();\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be unsubscribed when other empty subscription completes","suites":["Observable","subscribe"],"updatePoint":{"line":262,"column":74},"line":262,"code":"    it('should not be unsubscribed when other empty subscription completes', () => {\n      let unsubscribeCalled = false;\n      const source = new Observable<number>(() => {\n        return () => {\n          unsubscribeCalled = true;\n        };\n      });\n\n      source.subscribe();\n\n      expect(unsubscribeCalled).to.be.false;\n\n      empty().subscribe();\n\n      expect(unsubscribeCalled).to.be.false;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be unsubscribed when other subscription with same observer completes","suites":["Observable","subscribe"],"updatePoint":{"line":279,"column":87},"line":279,"code":"    it('should not be unsubscribed when other subscription with same observer completes', () => {\n      let unsubscribeCalled = false;\n      const source = new Observable<number>(() => {\n        return () => {\n          unsubscribeCalled = true;\n        };\n      });\n\n      let observer = {\n        next: function () {\n          /*noop*/\n        },\n      };\n\n      source.subscribe(observer);\n\n      expect(unsubscribeCalled).to.be.false;\n\n      empty().subscribe(observer);\n\n      expect(unsubscribeCalled).to.be.false;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should run unsubscription logic when an error is sent asynchronously and subscribe is called with no arguments","suites":["Observable","subscribe"],"updatePoint":{"line":302,"column":118},"line":302,"code":"    it('should run unsubscription logic when an error is sent asynchronously and subscribe is called with no arguments', (done) => {\n      const sandbox = sinon.createSandbox();\n      const fakeTimer = sandbox.useFakeTimers();\n\n      let unsubscribeCalled = false;\n      const source = new Observable<number>((observer) => {\n        const id = setInterval(() => {\n          observer.error(0);\n        }, 1);\n        return () => {\n          clearInterval(id);\n          unsubscribeCalled = true;\n        };\n      });\n\n      source.subscribe({\n        error() {\n          /* noop: expected error */\n        },\n      });\n\n      setTimeout(() => {\n        let err;\n        let errHappened = false;\n        try {\n          expect(unsubscribeCalled).to.be.true;\n        } catch (e) {\n          err = e;\n          errHappened = true;\n        } finally {\n          if (!errHappened) {\n            done();\n          } else {\n            done(err);\n          }\n        }\n      }, 100);\n\n      fakeTimer.tick(110);\n      sandbox.restore();\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a Subscription that calls the unsubscribe function returned by the subscriber","suites":["Observable","subscribe"],"updatePoint":{"line":344,"column":99},"line":344,"code":"    it('should return a Subscription that calls the unsubscribe function returned by the subscriber', () => {\n      let unsubscribeCalled = false;\n\n      const source = new Observable<number>(() => {\n        return () => {\n          unsubscribeCalled = true;\n        };\n      });\n\n      const sub = source.subscribe(() => {\n        //noop\n      });\n      expect(sub instanceof Subscription).to.be.true;\n      expect(unsubscribeCalled).to.be.false;\n      expect(sub.unsubscribe).to.be.a('function');\n\n      sub.unsubscribe();\n      expect(unsubscribeCalled).to.be.true;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore next messages after unsubscription","suites":["Observable","subscribe"],"updatePoint":{"line":364,"column":56},"line":364,"code":"    it('should ignore next messages after unsubscription', (done) => {\n      let times = 0;\n\n      const subscription = new Observable<number>((observer) => {\n        let i = 0;\n        const id = setInterval(() => {\n          observer.next(i++);\n        });\n\n        return () => {\n          clearInterval(id);\n          expect(times).to.equal(2);\n          done();\n        };\n      })\n        .pipe(tap(() => (times += 1)))\n        .subscribe(function () {\n          if (times === 2) {\n            subscription.unsubscribe();\n          }\n        });\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore error messages after unsubscription","suites":["Observable","subscribe"],"updatePoint":{"line":387,"column":57},"line":387,"code":"    it('should ignore error messages after unsubscription', (done) => {\n      let times = 0;\n      let errorCalled = false;\n\n      const subscription = new Observable<number>((observer) => {\n        let i = 0;\n        const id = setInterval(() => {\n          observer.next(i++);\n          if (i === 3) {\n            observer.error(new Error());\n          }\n        });\n\n        return () => {\n          clearInterval(id);\n          expect(times).to.equal(2);\n          expect(errorCalled).to.be.false;\n          done();\n        };\n      })\n        .pipe(tap(() => (times += 1)))\n        .subscribe(\n          { next: function () {\n            if (times === 2) {\n              subscription.unsubscribe();\n            }\n          }, error: function () {\n            errorCalled = true;\n          } }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore complete messages after unsubscription","suites":["Observable","subscribe"],"updatePoint":{"line":419,"column":60},"line":419,"code":"    it('should ignore complete messages after unsubscription', (done) => {\n      let times = 0;\n      let completeCalled = false;\n\n      const subscription = new Observable<number>((observer) => {\n        let i = 0;\n        const id = setInterval(() => {\n          observer.next(i++);\n          if (i === 3) {\n            observer.complete();\n          }\n        });\n\n        return () => {\n          clearInterval(id);\n          expect(times).to.equal(2);\n          expect(completeCalled).to.be.false;\n          done();\n        };\n      })\n        .pipe(tap(() => (times += 1)))\n        .subscribe(\n          { next: function () {\n            if (times === 2) {\n              subscription.unsubscribe();\n            }\n          }, complete: function () {\n            completeCalled = true;\n          } }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept an anonymous observer with no functions at all","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":505,"column":70},"line":505,"code":"      it('should accept an anonymous observer with no functions at all', () => {\n        expect(() => {\n          empty().subscribe(<any>{});\n        }).not.to.throw();\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore next messages after unsubscription","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":511,"column":58},"line":511,"code":"      it('should ignore next messages after unsubscription', (done) => {\n        let times = 0;\n\n        const subscription = new Observable<number>((observer) => {\n          let i = 0;\n          const id = setInterval(() => {\n            observer.next(i++);\n          });\n\n          return () => {\n            clearInterval(id);\n            expect(times).to.equal(2);\n            done();\n          };\n        })\n          .pipe(tap(() => (times += 1)))\n          .subscribe({\n            next() {\n              if (times === 2) {\n                subscription.unsubscribe();\n              }\n            },\n          });\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore error messages after unsubscription","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":536,"column":59},"line":536,"code":"      it('should ignore error messages after unsubscription', (done) => {\n        let times = 0;\n        let errorCalled = false;\n\n        const subscription = new Observable<number>((observer) => {\n          let i = 0;\n          const id = setInterval(() => {\n            observer.next(i++);\n            if (i === 3) {\n              observer.error(new Error());\n            }\n          });\n          return () => {\n            clearInterval(id);\n            expect(times).to.equal(2);\n            expect(errorCalled).to.be.false;\n            done();\n          };\n        })\n          .pipe(tap(() => (times += 1)))\n          .subscribe({\n            next() {\n              if (times === 2) {\n                subscription.unsubscribe();\n              }\n            },\n            error() {\n              errorCalled = true;\n            },\n          });\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore complete messages after unsubscription","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":568,"column":62},"line":568,"code":"      it('should ignore complete messages after unsubscription', (done) => {\n        let times = 0;\n        let completeCalled = false;\n\n        const subscription = new Observable<number>((observer) => {\n          let i = 0;\n          const id = setInterval(() => {\n            observer.next(i++);\n            if (i === 3) {\n              observer.complete();\n            }\n          });\n\n          return () => {\n            clearInterval(id);\n            expect(times).to.equal(2);\n            expect(completeCalled).to.be.false;\n            done();\n          };\n        })\n          .pipe(tap(() => (times += 1)))\n          .subscribe({\n            next() {\n              if (times === 2) {\n                subscription.unsubscribe();\n              }\n            },\n            complete() {\n              completeCalled = true;\n            },\n          });\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize even with a synchronous thrown error","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":602,"column":60},"line":602,"code":"    it('should finalize even with a synchronous thrown error', () => {\n      let called = false;\n      const badObservable = new Observable((subscriber) => {\n        subscriber.add(() => {\n          called = true;\n        });\n\n        throw new Error('bad');\n      });\n\n      badObservable.subscribe({\n        error: () => { /* do nothing */ }\n      });\n\n      expect(called).to.be.true;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty string sync errors","suites":["Observable","subscribe","when called with an anonymous observer"],"updatePoint":{"line":620,"column":46},"line":620,"code":"    it('should handle empty string sync errors', () => {\n      const badObservable = new Observable(() => {\n        throw '';\n      });\n\n      let caught = false;\n      badObservable.subscribe({\n        error: (err) => {\n          caught = true;\n          expect(err).to.equal('');\n        }\n      });\n      expect(caught).to.be.true;\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw synchronously","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":641,"column":36},"line":641,"code":"      it('should throw synchronously', () => {\n        expect(() => throwError(() => new Error('thrown error')).subscribe()).to.throw(Error, 'thrown error');\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should rethrow if next handler throws","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":645,"column":47},"line":645,"code":"      it('should rethrow if next handler throws', () => {\n        const observable = new Observable((observer) => {\n          observer.next(1);\n        });\n\n        const sink = Subscriber.create(() => {\n          throw 'error!';\n        });\n\n        expect(() => {\n          observable.subscribe(sink);\n        }).to.throw('error!');\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should still rethrow synchronous errors from next handlers on synchronous observables","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":661,"column":95},"line":661,"code":"      it('should still rethrow synchronous errors from next handlers on synchronous observables', () => {\n        expect(() => {\n          of('test').pipe(\n            // Any operators here\n            map(x => x + '!!!'),\n            map(x => x + x),\n            map(x => x + x),\n            map(x => x + x),\n          ).subscribe({\n            next: () => {\n              throw new Error(\n                'hi there!'\n              )\n            }\n          })\n        }).to.throw('hi there!');\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should rethrow synchronous errors from flattened observables","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":679,"column":70},"line":679,"code":"      it('should rethrow synchronous errors from flattened observables', () => {\n        expect(() => {\n          of(1)\n            .pipe(concatMap(() => throwError(() => new Error('Ahoy! An error!'))))\n            .subscribe(console.log);\n        }).to.throw('Ahoy! An error!');\n\n        expect(() => {\n          of(1)\n            .pipe(switchMap(() => throwError(() => new Error('Avast! Thar be a new error!'))))\n            .subscribe(console.log);\n        }).to.throw('Avast! Thar be a new error!');\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize even with a synchronous error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":693,"column":55},"line":693,"code":"      it('should finalize even with a synchronous error', () => {\n        let called = false;\n        const badObservable = new Observable((subscriber) => {\n          subscriber.add(() => {\n            called = true;\n          });\n\n          subscriber.error(new Error('bad'));\n        });\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize even with a synchronous thrown error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":711,"column":62},"line":711,"code":"      it('should finalize even with a synchronous thrown error', () => {\n        let called = false;\n        const badObservable = new Observable((subscriber) => {\n          subscriber.add(() => {\n            called = true;\n          });\n\n          throw new Error('bad');\n        });\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty string sync errors","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":730,"column":48},"line":730,"code":"      it('should handle empty string sync errors', () => {\n        const badObservable = new Observable(() => {\n          throw '';\n        });\n\n        let caught = false;\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          caught = true;\n          expect(err).to.equal('');\n        }\n        expect(caught).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalizer even with a sync error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":745,"column":57},"line":745,"code":"      it('should execute finalizer even with a sync error', () => {\n        let called = false;\n        const badObservable = new Observable((subscriber) => {\n          subscriber.error(new Error('bad'));\n        }).pipe(\n          finalize(() => {\n            called = true;\n          })\n        );\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalize even with a sync thrown error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":763,"column":63},"line":763,"code":"      it('should execute finalize even with a sync thrown error', () => {\n        let called = false;\n        const badObservable = new Observable(() => {\n          throw new Error('bad');\n        }).pipe(\n          finalize(() => {\n            called = true;\n          })\n        );\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalizer in order even with a sync error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":781,"column":66},"line":781,"code":"      it('should execute finalizer in order even with a sync error', () => {\n        const results: any[] = [];\n        const badObservable = new Observable((subscriber) => {\n          subscriber.error(new Error('bad'));\n        }).pipe(\n          finalize(() => {\n            results.push(1);\n          }),\n          finalize(() => {\n            results.push(2)\n          })\n        );\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(results).to.deep.equal([1, 2]);\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalizer in order even with a sync thrown error","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":802,"column":73},"line":802,"code":"      it('should execute finalizer in order even with a sync thrown error', () => {\n        const results: any[] = [];\n        const badObservable = new Observable(() => {\n          throw new Error('bad');\n        }).pipe(\n          finalize(() => {\n            results.push(1);\n          }),\n          finalize(() => {\n            results.push(2)\n          })\n        );\n\n        try {\n          badObservable.subscribe();\n        } catch (err) {\n          // do nothing\n        }\n        expect(results).to.deep.equal([1, 2]);\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should not have a run-time error if no errors are thrown and there are operators","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":824,"column":90},"line":824,"code":"      it('should not have a run-time error if no errors are thrown and there are operators', () => {\n        expect(() => {\n          of(1, 2, 3).pipe(\n            map(x => x + x),\n            map(x => Math.log(x))\n          )\n          .subscribe();\n        }).not.to.throw();\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize if sync unsubscribed","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":834,"column":51},"line":834,"code":"      it('should call finalize if sync unsubscribed', () => {\n        let called = false;\n        const observable = new Observable(() => () => (called = true));\n        const subscription = observable.subscribe();\n        subscription.unsubscribe();\n\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should call registered finalizer if sync unsubscribed","suites":["Observable","subscribe","if config.useDeprecatedSynchronousErrorHandling === true"],"updatePoint":{"line":843,"column":63},"line":843,"code":"      it('should call registered finalizer if sync unsubscribed', () => {\n        let called = false;\n        const observable = new Observable((subscriber) => subscriber.add(() => called = true));\n        const subscription = observable.subscribe();\n        subscription.unsubscribe();\n\n        expect(called).to.be.true;\n      });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["Observable","pipe"],"updatePoint":{"line":859,"column":20},"line":859,"code":"    it('should exist', () => {\n      const source = of('test');\n      expect(source.pipe).to.be.a('function');\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should pipe multiple operations","suites":["Observable","pipe"],"updatePoint":{"line":864,"column":39},"line":864,"code":"    it('should pipe multiple operations', (done) => {\n      of('test')\n        .pipe(\n          map((x) => x + x),\n          map((x) => x + '!!!')\n        )\n        .subscribe(\n          { next: (x) => {\n            expect(x).to.equal('testtest!!!');\n          }, complete: done }\n        );\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the same observable if there are no arguments","suites":["Observable","pipe"],"updatePoint":{"line":877,"column":67},"line":877,"code":"    it('should return the same observable if there are no arguments', () => {\n      const source = of('test');\n      const result = source.pipe();\n      expect(result).to.equal(source);\n    });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should not swallow internal errors","suites":["Observable","pipe"],"updatePoint":{"line":884,"column":40},"line":884,"code":"  it('should not swallow internal errors', (done) => {\n    config.onStoppedNotification = (notification) => {\n      expect(notification.kind).to.equal('E');\n      expect(notification).to.have.property('error', 'bad');\n      config.onStoppedNotification = null;\n      done();\n    };\n\n    new Observable(subscriber => {\n      subscriber.error('test');\n      throw 'bad';\n    }).subscribe({\n      error: err => {\n        expect(err).to.equal('test');\n      }\n    });\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle sync errors within a test scheduler","suites":["Observable","pipe"],"line":903,"code":"  it.skip('should handle sync errors within a test scheduler', () => {","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should emit an error for unhandled synchronous exceptions from something like a stack overflow","suites":["Observable","pipe"],"updatePoint":{"line":920,"column":100},"line":920,"code":"  it('should emit an error for unhandled synchronous exceptions from something like a stack overflow', () => {\n    const source = new Observable(() => {\n      const boom = (): unknown => boom();\n      boom();\n    });\n\n    let thrownError: any = undefined;\n    source.subscribe({\n      error: err => thrownError = err\n    });\n\n    expect(thrownError).to.be.an.instanceOf(RangeError);\n    expect(thrownError.message).to.equal('Maximum call stack size exceeded');\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an Observable","suites":["Observable.create"],"updatePoint":{"line":938,"column":33},"line":938,"code":"  it('should create an Observable', () => {\n    const result = Observable.create(() => {\n      //noop\n    });\n    expect(result instanceof Observable).to.be.true;\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should provide an observer to the function","suites":["Observable.create"],"updatePoint":{"line":945,"column":48},"line":945,"code":"  it('should provide an observer to the function', () => {\n    let called = false;\n    const result = Observable.create((observer: Observer<any>) => {\n      called = true;\n      expectFullObserver(observer);\n      observer.complete();\n    });\n\n    expect(called).to.be.false;\n    result.subscribe(() => {\n      //noop\n    });\n    expect(called).to.be.true;\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should send errors thrown in the passed function down the error path","suites":["Observable.create"],"updatePoint":{"line":960,"column":74},"line":960,"code":"  it('should send errors thrown in the passed function down the error path', (done) => {\n    Observable.create(() => {\n      throw new Error('this should be handled');\n    }).subscribe({\n      error(err: Error) {\n        expect(err).to.exist.and.be.instanceof(Error).and.have.property('message', 'this should be handled');\n        done();\n      },\n    });\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return Observable which calls FinalizationLogic of operator on unsubscription","suites":["Observable.lift"],"updatePoint":{"line":994,"column":90},"line":994,"code":"  it('should return Observable which calls FinalizationLogic of operator on unsubscription', (done) => {\n    const myOperator: Operator<any, any> = {\n      call: (subscriber: Subscriber<any>, source: any) => {\n        const subscription = source.subscribe((x: any) => subscriber.next(x));\n        return () => {\n          subscription.unsubscribe();\n          done();\n        };\n      },\n    };\n\n    (NEVER as any).lift(myOperator)\n      .subscribe()\n      .unsubscribe();\n\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should be overrideable in a custom Observable type that composes","suites":["Observable.lift"],"updatePoint":{"line":1011,"column":70},"line":1011,"code":"  it('should be overrideable in a custom Observable type that composes', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      map((x) => {\n        return 10 * x;\n      })\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [10, 20, 30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose through multicast and refCount","suites":["Observable.lift"],"updatePoint":{"line":1038,"column":51},"line":1038,"code":"  it('should compose through multicast and refCount', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      multicast(() => new Subject<number>()),\n      refCount(),\n      map((x) => 10 * x)\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [10, 20, 30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose through publish and refCount","suites":["Observable.lift"],"updatePoint":{"line":1066,"column":49},"line":1066,"code":"  it('should compose through publish and refCount', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      publish(),\n      refCount(),\n      map((x) => 10 * x)\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [10, 20, 30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose through publishLast and refCount","suites":["Observable.lift"],"updatePoint":{"line":1094,"column":53},"line":1094,"code":"  it('should compose through publishLast and refCount', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      publishLast(),\n      refCount(),\n      map((x) => 10 * x)\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose through publishBehavior and refCount","suites":["Observable.lift"],"updatePoint":{"line":1121,"column":57},"line":1121,"code":"  it('should compose through publishBehavior and refCount', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      publishBehavior(0),\n      refCount(),\n      map((x) => 10 * x)\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [0, 10, 20, 30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should composes Subjects in the simple case","suites":["Observable.lift"],"updatePoint":{"line":1148,"column":49},"line":1148,"code":"  it('should composes Subjects in the simple case', () => {\n    const subject = new Subject<number>();\n\n    const result = subject.pipe(\n      map((x) => 10 * x)\n    ) as any as Subject<number>; // Yes, this is correct. (but you're advised not to do this)\n\n    expect(result instanceof Subject).to.be.true;\n\n    const emitted: any[] = [];\n    result.subscribe(value => emitted.push(value));\n\n    result.next(10);\n    result.next(20);\n    result.next(30);\n\n    expect(emitted).to.deep.equal([100, 200, 300]);\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should demonstrate the horrors of sharing and lifting the Subject through","suites":["Observable.lift"],"updatePoint":{"line":1171,"column":79},"line":1171,"code":"  it('should demonstrate the horrors of sharing and lifting the Subject through', () => {\n    const subject = new Subject<number>();\n\n    const shared = subject.pipe(\n      share()\n    );\n\n    const result1 = shared.pipe(\n      map(x => x * 10)\n    ) as any as Subject<number>; // Yes, this is correct.\n\n    const result2 = shared.pipe(\n      map(x => x - 10)\n    ) as any as Subject<number>; // Yes, this is correct.\n    expect(result1 instanceof Subject).to.be.true;\n\n    const emitted1: any[] = [];\n    result1.subscribe(value => emitted1.push(value));\n\n    const emitted2: any[] = [];\n    result2.subscribe(value => emitted2.push(value));\n\n    // THIS IS HORRIBLE DON'T DO THIS.\n    result1.next(10);\n    result2.next(20); // Yuck\n    result1.next(30);\n\n    expect(emitted1).to.deep.equal([100, 200, 300]);\n    expect(emitted2).to.deep.equal([0, 10, 20]);\n  });","file":"Observable-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose through multicast and refCount, even if it is a Subject","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1216,"column":78},"line":1216,"code":"    it('should compose through multicast and refCount, even if it is a Subject', () => {\n      const subject = new Subject<number>();\n\n      const result = subject.pipe(\n        multicast(() => new Subject<number>()),\n        refCount(),\n        map((x) => 10 * x)\n      ) as any as Subject<number>; // Yes, this is correct.\n\n      expect(result instanceof Subject).to.be.true;\n\n      const emitted: any[] = [];\n      result.subscribe(value => emitted.push(value));\n\n      result.next(10);\n      result.next(20);\n      result.next(30);\n\n      expect(emitted).to.deep.equal([100, 200, 300]);\n    });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through publish and refCount, even if it is a Subject","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1237,"column":76},"line":1237,"code":"    it('should compose through publish and refCount, even if it is a Subject', () => {\n      const subject = new Subject<number>();\n\n      const result = subject.pipe(\n        publish(),\n        refCount(),\n        map((x) => 10 * x)\n      ) as any as Subject<number>; // Yes, this is correct.\n\n      expect(result instanceof Subject).to.be.true;\n\n      const emitted: any[] = [];\n      result.subscribe(value => emitted.push(value));\n\n      result.next(10);\n      result.next(20);\n      result.next(30);\n\n      expect(emitted).to.deep.equal([100, 200, 300]);\n    });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through publishLast and refCount, even if it is a Subject","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1259,"column":80},"line":1259,"code":"    it('should compose through publishLast and refCount, even if it is a Subject', () => {\n      const subject = new Subject<number>();\n\n      const result = subject.pipe(\n        publishLast(),\n        refCount(),\n        map((x) => 10 * x)\n      ) as any as Subject<number>; // Yes, this is correct.\n\n      expect(result instanceof Subject).to.be.true;\n\n      const emitted: any[] = [];\n      result.subscribe(value => emitted.push(value));\n\n      result.next(10);\n      result.next(20);\n      result.next(30);\n\n      expect(emitted).to.deep.equal([100, 200, 300]);\n    });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through publishBehavior and refCount, even if it is a Subject","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1280,"column":84},"line":1280,"code":"    it('should compose through publishBehavior and refCount, even if it is a Subject', () => {\n      const subject = new Subject<number>();\n\n      const result = subject.pipe(\n        publishBehavior(0),\n        refCount(),\n        map((x) => 10 * x)\n      ) as any as Subject<number>; // Yes, this is correct.\n\n      expect(result instanceof Subject).to.be.true;\n\n      const emitted: any[] = [];\n      result.subscribe(value => emitted.push(value));\n\n      result.next(10);\n      result.next(20);\n      result.next(30);\n\n      expect(emitted).to.deep.equal([0, 100, 200, 300]);\n    });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through multicast with selector function","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1302,"column":61},"line":1302,"code":"  it('should compose through multicast with selector function', (done) => {\n    const result = new MyCustomObservable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      multicast(\n        () => new Subject<number>(),\n        (shared) => shared.pipe(map((x) => 10 * x))\n      )\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [10, 20, 30];\n\n    result.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through combineLatest","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1330,"column":42},"line":1330,"code":"  it('should compose through combineLatest', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' -a--b-----c-d-e-|');\n      const e2 = cold(' --1--2-3-4---|   ');\n      const expected = '--A-BC-D-EF-G-H-|';\n\n      const result = MyCustomObservable.from(e1).pipe(combineLatest(e2, (a, b) => String(a) + String(b)));\n\n      expect(result instanceof MyCustomObservable).to.be.true;\n\n      expectObservable(result).toBe(expected, {\n        A: 'a1',\n        B: 'b1',\n        C: 'b2',\n        D: 'b3',\n        E: 'b4',\n        F: 'c4',\n        G: 'd4',\n        H: 'e4',\n      });\n    });\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through concat","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1353,"column":35},"line":1353,"code":"  it('should compose through concat', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' --a--b-|');\n      const e2 = cold(' --x---y--|');\n      const expected = '--a--b---x---y--|';\n\n      const result = MyCustomObservable.from(e1).pipe(concat(e2, rxTestScheduler));\n\n      expect(result instanceof MyCustomObservable).to.be.true;\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through merge","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1366,"column":34},"line":1366,"code":"  it('should compose through merge', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' -a--b-| ');\n      const e2 = cold(' --x--y-|');\n      const expected = '-ax-by-|';\n\n      const result = MyCustomObservable.from(e1).pipe(merge(e2, rxTestScheduler));\n\n      expect(result instanceof MyCustomObservable).to.be.true;\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through race","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1380,"column":33},"line":1380,"code":"  it('should compose through race', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|');\n      const e1subs = '  ^-------------------!';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!';\n      const expected = '---a-----b-----c----|';\n\n      const result = MyCustomObservable.from<string>(e1).pipe(\n        race(e2)\n      );\n\n      expect(result instanceof MyCustomObservable).to.be.true;\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should compose through zip","suites":["Observable.lift","The lift through Connectable gaff"],"updatePoint":{"line":1400,"column":32},"line":1400,"code":"  it('should compose through zip', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' -a--b-----c-d-e-|');\n      const e2 = cold(' --1--2-3-4---|   ');\n      const expected = '--A--B----C-D|   ';\n\n      const result = MyCustomObservable.from(e1).pipe(zip(e2, (a, b) => String(a) + String(b)));\n\n      expect(result instanceof MyCustomObservable).to.be.true;\n\n      expectObservable(result).toBe(expected, {\n        A: 'a1',\n        B: 'b2',\n        C: 'c3',\n        D: 'd4',\n      });\n    });\n  });","file":"Observable-spec.ts","skipped":true,"dir":"spec"},{"name":"should emit undefined from a callback without arguments","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":11,"column":63},"line":11,"code":"    it('should emit undefined from a callback without arguments', () => {\n      function callback(cb: Function) {\n        cb();\n      }\n      const boundCallback = bindCallback(callback);\n      const results: Array<string|number> = [];\n\n      boundCallback()\n        .subscribe({ next: (x: any) => {\n          results.push(typeof x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal(['undefined', 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a resultSelector","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":28,"column":39},"line":28,"code":"    it('should support a resultSelector', () => {\n      function callback(datum: number, cb: Function) {\n        cb(datum);\n      }\n\n      const boundCallback = bindCallback(\n        callback,\n        (datum: any) => datum + 1,\n      );\n\n      const results: Array<string|number> = [];\n\n      boundCallback(42)\n        .subscribe({\n          next(value) { results.push(value); },\n          complete() { results.push('done'); },\n        });\n\n      expect(results).to.deep.equal([43, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a resultSelector if its void","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":49,"column":51},"line":49,"code":"    it('should support a resultSelector if its void', () => {\n      function callback(datum: number, cb: Function) {\n        cb(datum);\n      }\n\n      const boundCallback = bindCallback(\n        callback,\n        void 0,\n      );\n\n      const results: Array<string|number> = [];\n\n      boundCallback(42)\n        .subscribe({\n          next(value: any) { results.push(value); },\n          complete() { results.push('done'); },\n        });\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value from a callback","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":70,"column":45},"line":70,"code":"    it('should emit one value from a callback', () => {\n      function callback(datum: number, cb: (result: number) => void) {\n        cb(datum);\n      }\n      const boundCallback = bindCallback(callback);\n      const results: Array<string|number> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should set callback function context to context of returned function","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":87,"column":76},"line":87,"code":"    it('should set callback function context to context of returned function', () => {\n      function callback(this: any, cb: (arg: number) => void) {\n        cb(this.datum);\n      }\n\n      const boundCallback = bindCallback(callback);\n      const results: Array<string|number> = [];\n\n      boundCallback.apply({datum: 5})\n        .subscribe(\n          { next: (x: number) => results.push(x), complete: () => results.push('done') }\n        );\n\n      expect(results).to.deep.equal([5, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit, throw or complete if immediately unsubscribed","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":103,"column":70},"line":103,"code":"    it('should not emit, throw or complete if immediately unsubscribed', (done) => {\n      const nextSpy = sinon.spy();\n      const throwSpy = sinon.spy();\n      const completeSpy = sinon.spy();\n      let timeout: ReturnType<typeof setTimeout>;\n      function callback(datum: number, cb: Function) {\n        // Need to cb async in order for the unsub to trigger\n        timeout = setTimeout(() => {\n          cb(datum);\n        }, 0);\n      }\n      const subscription = bindCallback(callback)(42)\n        .subscribe({ next: nextSpy, error: throwSpy, complete: completeSpy });\n      subscription.unsubscribe();\n\n      setTimeout(() => {\n        expect(nextSpy).not.have.been.called;\n        expect(throwSpy).not.have.been.called;\n        expect(completeSpy).not.have.been.called;\n\n        clearTimeout(timeout);\n        done();\n      });\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a separate internal subject for each call","suites":["bindCallback","when not scheduled"],"updatePoint":{"line":128,"column":63},"line":128,"code":"    it('should create a separate internal subject for each call', () => {\n      function callback(datum: number, cb: (result: number) => void) {\n        cb(datum);\n      }\n      const boundCallback = bindCallback(callback);\n      const results: Array<string|number> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n      boundCallback(54)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal([42, 'done', 54, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit undefined from a callback without arguments","suites":["bindCallback","when scheduled"],"updatePoint":{"line":153,"column":63},"line":153,"code":"    it('should emit undefined from a callback without arguments', () => {\n      function callback(cb: Function) {\n        cb();\n      }\n      const boundCallback = bindCallback(callback, rxTestScheduler);\n      const results: Array<string|number> = [];\n\n      boundCallback()\n        .subscribe({ next: x => {\n          results.push(typeof x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal(['undefined', 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value from a callback","suites":["bindCallback","when scheduled"],"updatePoint":{"line":172,"column":45},"line":172,"code":"    it('should emit one value from a callback', () => {\n      function callback(datum: number, cb: (result: number) => void) {\n        cb(datum);\n      }\n      const boundCallback = bindCallback(callback, rxTestScheduler);\n      const results: Array<string|number> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should set callback function context to context of returned function","suites":["bindCallback","when scheduled"],"updatePoint":{"line":191,"column":76},"line":191,"code":"    it('should set callback function context to context of returned function', () => {\n      function callback(this: { datum: number }, cb: (num: number) => void) {\n        cb(this.datum);\n      }\n\n      const boundCallback = bindCallback(callback, rxTestScheduler);\n      const results: Array<string|number> = [];\n\n      boundCallback.apply({ datum: 5 })\n        .subscribe(\n          { next: (x: number) => results.push(x), complete: () => results.push('done') }\n        );\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal([5, 'done']);\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if callback throws","suites":["bindCallback","when scheduled"],"updatePoint":{"line":209,"column":39},"line":209,"code":"    it('should error if callback throws', () => {\n      const expected = new Error('haha no callback for you');\n      function callback(datum: number, cb: Function): never {\n        throw expected;\n      }\n      const boundCallback = bindCallback(callback, rxTestScheduler);\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          throw new Error('should not next');\n        }, error: (err: any) => {\n          expect(err).to.equal(expected);\n        }, complete: () => {\n          throw new Error('should not complete');\n        } });\n\n      rxTestScheduler.flush();\n    });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass multiple inner arguments as an array","suites":["bindCallback","when scheduled"],"updatePoint":{"line":228,"column":54},"line":228,"code":"  it('should pass multiple inner arguments as an array', () => {\n    function callback(datum: number, cb: (a: number, b: number, c: number, d: number) => void) {\n      cb(datum, 1, 2, 3);\n    }\n    const boundCallback = bindCallback(callback, rxTestScheduler);\n    const results: Array<string|number[]> = [];\n\n    boundCallback(42)\n      .subscribe({ next: x => {\n        results.push(x);\n      }, complete: () => {\n        results.push('done');\n      } });\n\n    rxTestScheduler.flush();\n\n    expect(results).to.deep.equal([[42, 1, 2, 3], 'done']);\n  });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should cache value for next subscription and not call callbackFunc again","suites":["bindCallback","when scheduled"],"updatePoint":{"line":247,"column":78},"line":247,"code":"  it('should cache value for next subscription and not call callbackFunc again', () => {\n    let calls = 0;\n    function callback(datum: number, cb: (x: number) => void) {\n      calls++;\n      cb(datum);\n    }\n    const boundCallback = bindCallback(callback, rxTestScheduler);\n    const results1: Array<number|string> = [];\n    const results2: Array<number|string> = [];\n\n    const source = boundCallback(42);\n\n    source.subscribe({ next: x => {\n      results1.push(x);\n    }, complete: () => {\n      results1.push('done');\n    } });\n\n    source.subscribe({ next: x => {\n      results2.push(x);\n    }, complete: () => {\n      results2.push('done');\n    } });\n\n    rxTestScheduler.flush();\n\n    expect(calls).to.equal(1);\n    expect(results1).to.deep.equal([42, 'done']);\n    expect(results2).to.deep.equal([42, 'done']);\n  });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should not even call the callbackFn if scheduled and immediately unsubscribed","suites":["bindCallback","when scheduled"],"updatePoint":{"line":278,"column":83},"line":278,"code":"  it('should not even call the callbackFn if scheduled and immediately unsubscribed', () => {\n    let calls = 0;\n    function callback(datum: number, cb: Function) {\n      calls++;\n      cb(datum);\n    }\n    const boundCallback = bindCallback(callback, rxTestScheduler);\n    const results1: Array<number|string> = [];\n\n    const source = boundCallback(42);\n\n    const subscription = source.subscribe({ next: (x: any) => {\n      results1.push(x);\n    }, complete: () => {\n      results1.push('done');\n    } });\n\n    subscription.unsubscribe();\n\n    rxTestScheduler.flush();\n\n    expect(calls).to.equal(0);\n  });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit post-callback errors","suites":["bindCallback","when scheduled"],"updatePoint":{"line":303,"column":38},"line":303,"code":"  it('should emit post-callback errors', () => {\n    function badFunction(callback: (answer: number) => void): void {\n      callback(42);\n      throw 'kaboom';\n    }\n    let receivedError: any;\n\n    bindCallback(badFunction)().subscribe({\n      error: err => receivedError = err\n    });\n\n    expect(receivedError).to.equal('kaboom');\n  });","file":"observables/bindCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit undefined when callback is called without success arguments","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":11,"column":79},"line":11,"code":"    it('should emit undefined when callback is called without success arguments', () => {\n      function callback(cb: Function) {\n        cb(null);\n      }\n\n      const boundCallback = bindNodeCallback(callback);\n      const results: Array<number | string> = [];\n\n      boundCallback()\n        .subscribe({ next: (x: any) => {\n          results.push(typeof x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal(['undefined', 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should a resultSelector","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":29,"column":31},"line":29,"code":"    it('should a resultSelector', () => {\n      function callback(cb: (err: any, n: number) => any) {\n        cb(null, 42);\n      }\n\n      const boundCallback = bindNodeCallback(callback, (x: number) => x + 1);\n      const results: Array<number | string> = [];\n\n      boundCallback()\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal([43, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value from a callback","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":47,"column":45},"line":47,"code":"    it('should emit one value from a callback', () => {\n      function callback(datum: number, cb: (err: any, n: number) => void) {\n        cb(null, datum);\n      }\n      const boundCallback = bindNodeCallback(callback);\n      const results: Array<number | string> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should set context of callback to context of boundCallback","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":64,"column":66},"line":64,"code":"    it('should set context of callback to context of boundCallback', () => {\n      function callback(this: { datum: number }, cb: (err: any, n: number) => void) {\n        cb(null, this.datum);\n      }\n      const boundCallback = bindNodeCallback(callback);\n      const results: Array<number | string> = [];\n\n      boundCallback.call({datum: 42})\n        .subscribe(\n          { next: (x: number) => results.push(x), complete: () => results.push('done') }\n        );\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from callback","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":79,"column":40},"line":79,"code":"    it('should raise error from callback', () => {\n      const error = new Error();\n\n      function callback(cb: Function) {\n        cb(error);\n      }\n\n      const boundCallback = bindNodeCallback(callback);\n      const results: Array<number | string> = [];\n\n      boundCallback()\n        .subscribe({ next: () => {\n          throw new Error('should not next');\n        }, error: (err: any) => {\n          results.push(err);\n        }, complete: () => {\n          throw new Error('should not complete');\n        } });\n\n      expect(results).to.deep.equal([error]);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit, throw or complete if immediately unsubscribed","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":101,"column":70},"line":101,"code":"    it('should not emit, throw or complete if immediately unsubscribed', (done) => {\n      const nextSpy = sinon.spy();\n      const throwSpy = sinon.spy();\n      const completeSpy = sinon.spy();\n      let timeout: ReturnType<typeof setTimeout>;\n      function callback(datum: number, cb: (err: any, n: number) => void) {\n        // Need to cb async in order for the unsub to trigger\n        timeout = setTimeout(() => {\n          cb(null, datum);\n        }, 0);\n      }\n      const subscription = bindNodeCallback(callback)(42)\n        .subscribe({ next: nextSpy, error: throwSpy, complete: completeSpy });\n      subscription.unsubscribe();\n\n      setTimeout(() => {\n        expect(nextSpy).not.have.been.called;\n        expect(throwSpy).not.have.been.called;\n        expect(completeSpy).not.have.been.called;\n\n        clearTimeout(timeout);\n        done();\n      });\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a separate internal subject for each call","suites":["bindNodeCallback","when not scheduled"],"updatePoint":{"line":126,"column":63},"line":126,"code":"    it('should create a separate internal subject for each call', () => {\n      function callback(datum: number, cb: (err: any, n: number) => void) {\n        cb(null, datum);\n      }\n      const boundCallback = bindNodeCallback(callback);\n      const results: Array<number | string> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n      boundCallback(54)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      expect(results).to.deep.equal([42, 'done', 54, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit undefined when callback is called without success arguments","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":151,"column":79},"line":151,"code":"    it('should emit undefined when callback is called without success arguments', () => {\n      function callback(cb: Function) {\n        cb(null);\n      }\n\n      const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n      const results: Array<number | string> = [];\n\n      boundCallback()\n        .subscribe({ next: (x: any) => {\n          results.push(typeof x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal(['undefined', 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value from a callback","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":171,"column":45},"line":171,"code":"    it('should emit one value from a callback', () => {\n      function callback(datum: number, cb: (err: any, n: number) => void) {\n        cb(null, datum);\n      }\n      const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n      const results: Array<number | string> = [];\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          results.push(x);\n        }, complete: () => {\n          results.push('done');\n        } });\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should set context of callback to context of boundCallback","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":190,"column":66},"line":190,"code":"    it('should set context of callback to context of boundCallback', () => {\n      function callback(this: { datum: number }, cb: (err: any, n: number) => void) {\n        cb(null, this.datum);\n      }\n      const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n      const results: Array<number | string> = [];\n\n      boundCallback.call({datum: 42})\n        .subscribe(\n          { next: (x: number) => results.push(x), complete: () => results.push('done') }\n        );\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if callback throws","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":207,"column":39},"line":207,"code":"    it('should error if callback throws', () => {\n      const expected = new Error('haha no callback for you');\n      function callback(datum: number, cb: (err: any, n: number) => void) {\n        throw expected;\n      }\n      const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n\n      boundCallback(42)\n        .subscribe({ next: x => {\n          throw new Error('should not next');\n        }, error: (err: any) => {\n          expect(err).to.equal(expected);\n        }, complete: () => {\n          throw new Error('should not complete');\n        } });\n\n      rxTestScheduler.flush();\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from callback","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":226,"column":40},"line":226,"code":"    it('should raise error from callback', () => {\n      const error = new Error();\n\n      function callback(cb: Function) {\n        cb(error);\n      }\n\n      const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n      const results: Array<number | string> = [];\n\n      boundCallback()\n        .subscribe({ next: () => {\n          throw new Error('should not next');\n        }, error: (err: any) => {\n          results.push(err);\n        }, complete: () => {\n          throw new Error('should not complete');\n        } });\n\n      rxTestScheduler.flush();\n\n      expect(results).to.deep.equal([error]);\n    });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass multiple inner arguments as an array","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":251,"column":54},"line":251,"code":"  it('should pass multiple inner arguments as an array', () => {\n    function callback(datum: number, cb: (err: any, a: number, b: number, c: number, d: number) => void) {\n      cb(null, datum, 1, 2, 3);\n    }\n    const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n    const results: Array<number[] | string> = [];\n\n    boundCallback(42)\n      .subscribe({ next: x => {\n        results.push(x);\n      }, complete: () => {\n        results.push('done');\n      } });\n\n    rxTestScheduler.flush();\n\n    expect(results).to.deep.equal([[42, 1, 2, 3], 'done']);\n  });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should cache value for next subscription and not call callbackFunc again","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":270,"column":78},"line":270,"code":"  it('should cache value for next subscription and not call callbackFunc again', () => {\n    let calls = 0;\n    function callback(datum: number, cb: (err: any, n: number) => void) {\n      calls++;\n      cb(null, datum);\n    }\n    const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n    const results1: Array<number | string> = [];\n    const results2: Array<number | string> = [];\n\n    const source = boundCallback(42);\n\n    source.subscribe({ next: x => {\n      results1.push(x);\n    }, complete: () => {\n      results1.push('done');\n    } });\n\n    source.subscribe({ next: x => {\n      results2.push(x);\n    }, complete: () => {\n      results2.push('done');\n    } });\n\n    rxTestScheduler.flush();\n\n    expect(calls).to.equal(1);\n    expect(results1).to.deep.equal([42, 'done']);\n    expect(results2).to.deep.equal([42, 'done']);\n  });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit post callback errors","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":301,"column":38},"line":301,"code":"  it('should emit post callback errors', () => {\n    function badFunction(callback: (error: Error, answer: number) => void): void {\n      callback(null as any, 42);\n      throw 'kaboom';\n    }\n    let receivedError: any;\n    bindNodeCallback(badFunction)().subscribe({\n      error: err => receivedError = err\n    });\n\n    expect(receivedError).to.equal('kaboom');\n  });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should not call the function if subscribed twice in a row before it resolves","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":314,"column":82},"line":314,"code":"  it('should not call the function if subscribed twice in a row before it resolves', () => {\n    let executeCallback: any;\n    let calls = 0;\n    function myFunc(callback: (error: any, result: any) => void) {\n      calls++;\n      if (calls > 1) {\n        throw new Error('too many calls to myFunc');\n      }\n      executeCallback = callback;\n    }\n\n    const source$ = bindNodeCallback(myFunc)();\n\n    let result1: any;\n    let result2: any;\n    source$.subscribe(value => result1 = value);\n    source$.subscribe(value => result2 = value);\n\n    expect(calls).to.equal(1);\n    executeCallback(null, 'test');\n    expect(result1).to.equal('test');\n    expect(result2).to.equal('test');\n    expect(calls).to.equal(1);\n  });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should not even call the callbackFn if scheduled and immediately unsubscribed","suites":["bindNodeCallback","when scheduled"],"updatePoint":{"line":339,"column":83},"line":339,"code":"  it('should not even call the callbackFn if scheduled and immediately unsubscribed', () => {\n    let calls = 0;\n    function callback(datum: number, cb: Function) {\n      calls++;\n      cb(null, datum);\n    }\n    const boundCallback = bindNodeCallback(callback, rxTestScheduler);\n    const results1: Array<number|string> = [];\n\n    const source = boundCallback(42);\n\n    const subscription = source.subscribe({ next: (x: any) => {\n      results1.push(x);\n    }, complete: () => {\n      results1.push('done');\n    } });\n\n    subscription.unsubscribe();\n\n    rxTestScheduler.flush();\n\n    expect(calls).to.equal(0);\n  });","file":"observables/bindNodeCallback-spec.ts","skipped":false,"dir":"spec"},{"name":"should return EMPTY if passed an empty array as the only argument","suites":["static combineLatest"],"updatePoint":{"line":17,"column":71},"line":17,"code":"  it('should return EMPTY if passed an empty array as the only argument', () => {\n    const results: string[] = [];\n    combineLatest([]).subscribe({\n      next: () => {\n        throw new Error('should not emit')\n      },\n      complete: () => {\n        results.push('done');\n      }\n    });\n\n    expect(results).to.deep.equal(['done']);\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should return EMPTY if passed an empty POJO as the only argument","suites":["static combineLatest"],"updatePoint":{"line":31,"column":70},"line":31,"code":"  it('should return EMPTY if passed an empty POJO as the only argument', () => {\n    const results: string[] = [];\n    combineLatest({}).subscribe({\n      next: () => {\n        throw new Error('should not emit')\n      },\n      complete: () => {\n        results.push('done');\n      }\n    });\n\n    expect(results).to.deep.equal(['done']);\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should return EMPTY if passed an empty array and scheduler as the only argument","suites":["static combineLatest"],"updatePoint":{"line":45,"column":85},"line":45,"code":"  it('should return EMPTY if passed an empty array and scheduler as the only argument', () => {\n    const results: string[] = [];\n    combineLatest([], rxTestScheduler).subscribe({\n      next: () => {\n        throw new Error('should not emit')\n      },\n      complete: () => {\n        results.push('done');\n      }\n    });\n\n    expect(results).to.deep.equal([]);\n    rxTestScheduler.flush();\n    expect(results).to.deep.equal(['done']);\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should combineLatest the provided observables","suites":["static combineLatest"],"updatePoint":{"line":61,"column":51},"line":61,"code":"  it('should combineLatest the provided observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable }) => {\n      const firstSource = hot(' ----a----b----c----|');\n      const secondSource = hot('--d--e--f--g--|');\n      const expected = '        ----uv--wx-y--z----|';\n\n      const combined = combineLatest(firstSource, secondSource, (a, b) => '' + a + b);\n\n      expectObservable(combined).toBe(expected, { u: 'ad', v: 'ae', w: 'af', x: 'bf', y: 'bg', z: 'cg' });\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine an immediately-scheduled source with an immediately-scheduled second","suites":["static combineLatest"],"updatePoint":{"line":73,"column":89},"line":73,"code":"  it('should combine an immediately-scheduled source with an immediately-scheduled second', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [\n      [1, 4],\n      [2, 4],\n      [2, 5],\n      [3, 5],\n      [3, 6],\n      [3, 7],\n      [3, 8],\n    ];\n\n    const actual: [number, number][] = [];\n    //type definition need to be updated\n    combineLatest(a, b, queueScheduler).subscribe(\n      { next: (vals) => {\n        actual.push(vals);\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(actual).to.deep.equal(r);\n        done();\n      } }\n    );\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observables","suites":["static combineLatest"],"updatePoint":{"line":100,"column":40},"line":100,"code":"  it('should accept array of observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable }) => {\n      const firstSource = hot(' ----a----b----c----|');\n      const secondSource = hot('--d--e--f--g--|');\n      const expected = '        ----uv--wx-y--z----|';\n\n      const combined = combineLatest([firstSource, secondSource], (a: string, b: string) => '' + a + b);\n\n      expectObservable(combined).toBe(expected, { u: 'ad', v: 'ae', w: 'af', x: 'bf', y: 'bg', z: 'cg' });\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a dictionary of observables","suites":["static combineLatest"],"updatePoint":{"line":112,"column":47},"line":112,"code":"  it('should accept a dictionary of observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable }) => {\n      const firstSource =  hot('----a----b----c----|');\n      const secondSource = hot('--d--e--f--g--|');\n      const expected = '        ----uv--wx-y--z----|';\n\n      const combined = combineLatest({a: firstSource, b: secondSource}).pipe(\n        map(({a, b}) => '' + a + b)\n      );  \n\n      expectObservable(combined).toBe(expected, {u: 'ad', v: 'ae', w: 'af', x: 'bf', y: 'bg', z: 'cg'});\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["static combineLatest"],"updatePoint":{"line":126,"column":33},"line":126,"code":"  it('should work with two nevers', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["static combineLatest"],"updatePoint":{"line":142,"column":38},"line":142,"code":"  it('should work with never and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '-';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["static combineLatest"],"updatePoint":{"line":158,"column":38},"line":158,"code":"  it('should work with empty and never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["static combineLatest"],"updatePoint":{"line":174,"column":38},"line":174,"code":"  it('should work with empty and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '|';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-empty and hot-single","suites":["static combineLatest"],"updatePoint":{"line":190,"column":47},"line":190,"code":"  it('should work with hot-empty and hot-single', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 2,\n        c: 3,\n        r: 1 + 3, //a + c\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and hot-empty","suites":["static combineLatest"],"updatePoint":{"line":212,"column":47},"line":212,"code":"  it('should work with hot-single and hot-empty', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 2,\n        c: 3,\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = combineLatest(e2, e1, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and never","suites":["static combineLatest"],"updatePoint":{"line":233,"column":43},"line":233,"code":"  it('should work with hot-single and never', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('------', values); //never\n      const e2subs = '   ^  ';\n      const expected = ' -'; //never\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and hot-single","suites":["static combineLatest"],"updatePoint":{"line":252,"column":43},"line":252,"code":"  it('should work with never and hot-single', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 2,\n      };\n      const e1 = hot('--------', values); //never\n      const e1subs = '   ^----';\n      const e2 = hot('-a-^-b-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' -----'; //never\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and hot","suites":["static combineLatest"],"updatePoint":{"line":272,"column":34},"line":272,"code":"  it('should work with hot and hot', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|', { e: 'e', f: 'f', g: 'g' });\n      const e2subs = '     ^---------!';\n      const expected = '   ----x-yz--|';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { x: 'bf', y: 'cf', z: 'cg' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["static combineLatest"],"updatePoint":{"line":288,"column":38},"line":288,"code":"  it('should work with empty and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----------|'); //empty\n      const e1subs = '  ^-----!';\n      const e2 = hot('  ------#', undefined, 'shazbot!'); //error\n      const e2subs = '  ^-----!';\n      const expected = '------#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'shazbot!');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["static combineLatest"],"updatePoint":{"line":304,"column":38},"line":304,"code":"  it('should work with error and empty', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--^---#', undefined, 'too bad, honk'); //error\n      const e1subs = '  ^---!';\n      const e2 = hot('--^--------|'); //empty\n      const e2subs = '  ^---!';\n      const expected = '----#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'too bad, honk');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and throw","suites":["static combineLatest"],"updatePoint":{"line":320,"column":36},"line":320,"code":"  it('should work with hot and throw', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3 });\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and hot","suites":["static combineLatest"],"updatePoint":{"line":336,"column":36},"line":336,"code":"  it('should work with throw and hot', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'bazinga');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3 });\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and throw","suites":["static combineLatest"],"updatePoint":{"line":352,"column":38},"line":352,"code":"  it('should work with throw and throw', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'jenga');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and throw","suites":["static combineLatest"],"updatePoint":{"line":368,"column":38},"line":368,"code":"  it('should work with error and throw', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'flurp');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and error","suites":["static combineLatest"],"updatePoint":{"line":384,"column":38},"line":384,"code":"  it('should work with throw and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'flurp');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and throw","suites":["static combineLatest"],"updatePoint":{"line":400,"column":38},"line":400,"code":"  it('should work with never and throw', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-----------');\n      const e1subs = '   ^-----!';\n      const e2 = hot('---^-----#', undefined, 'wokka wokka');\n      const e2subs = '   ^-----!';\n      const expected = ' ------#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and never","suites":["static combineLatest"],"updatePoint":{"line":416,"column":38},"line":416,"code":"  it('should work with throw and never', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'wokka wokka');\n      const e1subs = '   ^----!';\n      const e2 = hot('---^-----------');\n      const e2subs = '   ^----!';\n      const expected = ' -----#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some and throw","suites":["static combineLatest"],"updatePoint":{"line":432,"column":37},"line":432,"code":"  it('should work with some and throw', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----a---b--|', { a: 1, b: 2 });\n      const e1subs = '   ^--!';\n      const e2 = hot('---^--#', undefined, 'wokka wokka');\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2 }, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and some","suites":["static combineLatest"],"updatePoint":{"line":448,"column":37},"line":448,"code":"  it('should work with throw and some', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--#', undefined, 'wokka wokka');\n      const e1subs = '   ^--!';\n      const e2 = hot('---^----a---b--|', { a: 1, b: 2 });\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2 }, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete left","suites":["static combineLatest"],"updatePoint":{"line":464,"column":45},"line":464,"code":"  it('should handle throw after complete left', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b---|', { a: 1, b: 2 });\n      const leftSubs = '      ^------!';\n      const right = hot('-----^--------#', undefined, 'bad things');\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = combineLatest(left, right, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete right","suites":["static combineLatest"],"updatePoint":{"line":480,"column":46},"line":480,"code":"  it('should handle throw after complete right', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' -----^--------#', undefined, 'bad things');\n      const leftSubs = '      ^--------!';\n      const right = hot('--a--^--b---|', { a: 1, b: 2 });\n      const rightSubs = '     ^------!';\n      const expected = '      ---------#';\n\n      const result = combineLatest(left, right, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle interleaved with tail","suites":["static combineLatest"],"updatePoint":{"line":496,"column":41},"line":496,"code":"  it('should handle interleaved with tail', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a--^--b---c---|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '    ^----------!';\n      const e2 = hot('--d-^----e---f--|', { d: 'd', e: 'e', f: 'f' });\n      const e2subs = '    ^-----------!';\n      const expected = '  -----x-y-z--|';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { x: 'be', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables","suites":["static combineLatest"],"updatePoint":{"line":512,"column":51},"line":512,"code":"  it('should handle two consecutive hot observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const e2subs = '     ^-------------------!';\n      const expected = '   -----------x--y--z--|';\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error left","suites":["static combineLatest"],"updatePoint":{"line":528,"column":67},"line":528,"code":"  it('should handle two consecutive hot observables with error left', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--#', { a: 'a', b: 'b', c: 'c' }, 'jenga');\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = combineLatest(left, right, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, null, 'jenga');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error right","suites":["static combineLatest"],"updatePoint":{"line":544,"column":68},"line":544,"code":"  it('should handle two consecutive hot observables with error right', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--#', { d: 'd', e: 'e', f: 'f' }, 'dun dun dun');\n      const rightSubs = '     ^-------------------!';\n      const expected = '      -----------x--y--z--#';\n\n      const result = combineLatest(left, right, (x, y) => x + y);\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' }, 'dun dun dun');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle selector throwing","suites":["static combineLatest"],"updatePoint":{"line":560,"column":37},"line":560,"code":"  it('should handle selector throwing', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--|', { a: 1, b: 2 });\n      const e1subs = '     ^--!';\n      const e2 = hot('--c--^--d--|', { c: 3, d: 4 });\n      const e2subs = '     ^--!';\n      const expected = '   ---#';\n\n      const result = combineLatest(e1, e2, (x, y) => {\n        throw 'ha ha ' + x + ', ' + y;\n      });\n\n      expectObservable(result).toBe(expected, null, 'ha ha 2, 4');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["static combineLatest"],"updatePoint":{"line":578,"column":53},"line":578,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = combineLatest(e1, e2, (x, y) => x + y);\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["static combineLatest"],"updatePoint":{"line":596,"column":73},"line":596,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = combineLatest(e1.pipe(mergeMap((x) => of(x))), e2.pipe(mergeMap((x) => of(x))), (x, y) => x + y).pipe(\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements from multiple sources","suites":["static concat"],"updatePoint":{"line":17,"column":48},"line":17,"code":"  it('should emit elements from multiple sources', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -a-b-c-|');\n      const e1subs = '  ^------!';\n      const e2 = cold('        -0-1-|');\n      const e2subs = '  -------^----!';\n      const e3 = cold('             -w-x-y-z-|');\n      const e3subs = '  ------------^--------!';\n      const expected = '-a-b-c--0-1--w-x-y-z-|';\n\n      expectObservable(concat(e1, e2, e3)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat the same cold observable multiple times","suites":["static concat"],"updatePoint":{"line":34,"column":59},"line":34,"code":"  it('should concat the same cold observable multiple times', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inner = cold('--i-j-k-l-|');\n      const innersubs = [\n        '                 ^---------!                              ',\n        '                 ----------^---------!                    ',\n        '                 --------------------^---------!          ',\n        '                 ------------------------------^---------!',\n      ];\n      const expected = '  --i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l-|';\n\n      const result = concat(inner, inner, inner, inner);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat the same cold observable multiple times, but the result is unsubscribed early","suites":["static concat"],"updatePoint":{"line":52,"column":97},"line":52,"code":"  it('should concat the same cold observable multiple times, but the result is unsubscribed early', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const innersubs: string[] = [];\n      const inner = cold('--i-j-k-l-|     ');\n      const unsub = '     ---------------!';\n      innersubs[0] = '    ^---------!     ';\n      innersubs[1] = '    ----------^----!';\n      const expected = '  --i-j-k-l---i-j-';\n\n      const result = concat(inner, inner, inner, inner);\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["static concat"],"updatePoint":{"line":68,"column":83},"line":68,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const innersubs: string[] = [];\n      const inner = cold('--i-j-k-l-|');\n      innersubs[0] = '    ^---------!';\n      innersubs[1] = '    ----------^----!';\n      const expected = '  --i-j-k-l---i-j-';\n      const unsub = '     ---------------!';\n\n      const innerWrapped = inner.pipe(mergeMap((x) => of(x)));\n      const result = concat(innerWrapped, innerWrapped, innerWrapped, innerWrapped).pipe(mergeMap((x) => of(x)));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without emit if both sources are empty","suites":["static concat"],"updatePoint":{"line":85,"column":60},"line":85,"code":"  it('should complete without emit if both sources are empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold(' ----|');\n      const e2subs = '  --^---!';\n      const expected = '------|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not completes","suites":["static concat"],"updatePoint":{"line":99,"column":60},"line":99,"code":"  it('should not complete if first source does not completes', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' --|');\n      const e2subs = '  -';\n      const expected = '-';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if second source does not completes","suites":["static concat"],"updatePoint":{"line":113,"column":61},"line":113,"code":"  it('should not complete if second source does not completes', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold(' ---');\n      const e2subs = '  --^';\n      const expected = '---';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if both sources do not complete","suites":["static concat"],"updatePoint":{"line":127,"column":57},"line":127,"code":"  it('should not complete if both sources do not complete', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' -');\n      const e2subs = '  -';\n      const expected = '-';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source is empty, second source raises error","suites":["static concat"],"updatePoint":{"line":141,"column":79},"line":141,"code":"  it('should raise error when first source is empty, second source raises error', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold(' ----#');\n      const e2subs = '  --^---!';\n      const expected = '------#';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source raises error, second source is empty","suites":["static concat"],"updatePoint":{"line":155,"column":79},"line":155,"code":"  it('should raise error when first source raises error, second source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#');\n      const e1subs = '  ^--!';\n      const e2 = cold(' ----|');\n      const e2subs = '     -';\n      const expected = '---#';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise first error when both source raise error","suites":["static concat"],"updatePoint":{"line":169,"column":59},"line":169,"code":"  it('should raise first error when both source raise error', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#');\n      const e1subs = '  ^--!';\n      const e2 = cold(' ------#');\n      const e2subs = '     -';\n      const expected = '---#';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source emits once, second source is empty","suites":["static concat"],"updatePoint":{"line":183,"column":70},"line":183,"code":"  it('should concat if first source emits once, second source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--|');\n      const e1subs = '  ^----!';\n      const e2 = cold(' --------|');\n      const e2subs = '  -----^-------!';\n      const expected = '--a----------|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source is empty, second source emits once","suites":["static concat"],"updatePoint":{"line":197,"column":70},"line":197,"code":"  it('should concat if first source is empty, second source emits once', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold(' --a--|');\n      const e2subs = '  --^----!';\n      const expected = '----a--|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not complete","suites":["static concat"],"updatePoint":{"line":225,"column":59},"line":225,"code":"  it('should not complete if first source does not complete', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' --a--|');\n      const e2subs = '  -';\n      const expected = '-';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements from each source when source emit once","suites":["static concat"],"updatePoint":{"line":239,"column":65},"line":239,"code":"  it('should emit elements from each source when source emit once', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a|');\n      const e1subs = '  ^---!';\n      const e2 = cold('     -----b--|');\n      const e2subs = '  ----^-------!';\n      const expected = '---a-----b--|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe to inner source if outer is unsubscribed early","suites":["static concat"],"updatePoint":{"line":253,"column":71},"line":253,"code":"  it('should unsubscribe to inner source if outer is unsubscribed early', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-a--a|            ');\n      const e1subs = '  ^--------!            ';\n      const e2 = cold('          -----b-b--b-|');\n      const e2subs = '  ---------^-------!    ';\n      const unsub = '   -----------------!    ';\n      const expected = '---a-a--a-----b-b-    ';\n\n      expectObservable(concat(e1, e2), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from first source and does not emit from second source","suites":["static concat"],"updatePoint":{"line":268,"column":79},"line":268,"code":"  it('should raise error from first source and does not emit from second source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --#');\n      const e1subs = '  ^-!';\n      const e2 = cold(' ----a--|');\n      const e2subs = '  -';\n      const expected = '--#';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit element from first source then raise error from second source","suites":["static concat"],"updatePoint":{"line":282,"column":79},"line":282,"code":"  it('should emit element from first source then raise error from second source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--|');\n      const e1subs = '  ^----!';\n      const e2 = cold(' -------#');\n      const e2subs = '  -----^------!';\n      const expected = '--a---------#';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit collapsing element from second source","suites":["static concat"],"updatePoint":{"line":324,"column":59},"line":324,"code":"  it('should not emit collapsing element from second source', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const e2 = hot('  --------x--y--z--|');\n      const e2subs = '  -----------^-----!';\n      const expected = '--a--b--c--y--z--|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should return empty if concatenating an empty source","suites":["static concat"],"updatePoint":{"line":338,"column":58},"line":338,"code":"  it('should return empty if concatenating an empty source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('|');\n      const e1subs = ['(^!)', '(^!)'];\n      const expected = '|';\n\n      const result = concat(e1, e1);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should error immediately if given a just-throw source","suites":["static concat"],"updatePoint":{"line":351,"column":59},"line":351,"code":"  it('should error immediately if given a just-throw source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      const result = concat(e1, e1);\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit collapsing element from second source","suites":["static concat"],"updatePoint":{"line":378,"column":59},"line":378,"code":"  it('should not emit collapsing element from second source', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const e2 = hot('  --------x--y--z--|');\n      const e2subs = '  -----------^-----!';\n      const expected = '--a--b--c--y--z--|';\n\n      expectObservable(concat(e1, e2)).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat an immediately-scheduled source with an immediately-scheduled second","suites":["static concat"],"updatePoint":{"line":392,"column":88},"line":392,"code":"  it('should concat an immediately-scheduled source with an immediately-scheduled second', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [1, 2, 3, 4, 5, 6, 7, 8];\n\n    concat(a, b, queueScheduler).subscribe({\n      next: (vals) => {\n        expect(vals).to.equal(r.shift());\n      },\n      complete: done,\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the scheduler even when one Observable is concat'd","suites":["static concat"],"updatePoint":{"line":405,"column":67},"line":405,"code":"  it(\"should use the scheduler even when one Observable is concat'd\", (done) => {\n    let e1Subscribed = false;\n    const e1 = defer(() => {\n      e1Subscribed = true;\n      return of('a');\n    });\n\n    concat(e1, asyncScheduler).subscribe({\n      error: done,\n      complete: () => {\n        expect(e1Subscribed).to.be.true;\n        done();\n      },\n    });\n\n    expect(e1Subscribed).to.be.false;\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should return passed observable if no scheduler was passed","suites":["static concat"],"updatePoint":{"line":423,"column":64},"line":423,"code":"  it('should return passed observable if no scheduler was passed', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const source = cold('--a---b----c---|');\n      const expected = '   --a---b----c---|';\n      const result = concat(source);\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should return RxJS Observable when single lowerCaseO was passed","suites":["static concat"],"updatePoint":{"line":433,"column":69},"line":433,"code":"  it('should return RxJS Observable when single lowerCaseO was passed', () => {\n    rxTestScheduler.run(({ expectObservable }) => {\n      const source = lowerCaseO('a', 'b', 'c');\n      const result = concat(source);\n\n      expect(result).to.be.an.instanceof(Observable);\n      expectObservable(result).toBe('(abc|)');\n    });\n  });","file":"observables/concat-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["connectable"],"updatePoint":{"line":14,"column":46},"line":14,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs = ' ^--------------!';\n      const expected = '   --1-2---3-4--5-|';\n\n      const obs = connectable(source);\n\n      expectObservable(obs).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      obs.connect();\n    });\n  });","file":"observables/connectable-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if connect is not called, despite subscriptions","suites":["connectable"],"updatePoint":{"line":29,"column":71},"line":29,"code":"  it('should do nothing if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs: string[] = [];\n      const expected = '   -';\n\n      const obs = connectable(source);\n\n      expectObservable(obs).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/connectable-spec.ts","skipped":false,"dir":"spec"},{"name":"should support resetOnDisconnect = true","suites":["connectable"],"updatePoint":{"line":42,"column":45},"line":42,"code":"  it('should support resetOnDisconnect = true', () => {\n    const values: number[] = [];\n    const source = of(1, 2, 3);\n    const obs = connectable(source, {\n      connector: () => new ReplaySubject(1),\n      resetOnDisconnect: true,\n    });\n\n    obs.subscribe((value) => values.push(value));\n    const connection = obs.connect();\n    expect(values).to.deep.equal([1, 2, 3]);\n\n    connection.unsubscribe();\n\n    obs.subscribe((value) => values.push(value));\n    obs.connect();\n    expect(values).to.deep.equal([1, 2, 3, 1, 2, 3]);\n  });","file":"observables/connectable-spec.ts","skipped":false,"dir":"spec"},{"name":"should support resetOnDisconnect = false","suites":["connectable"],"updatePoint":{"line":61,"column":46},"line":61,"code":"  it('should support resetOnDisconnect = false', () => {\n    const values: number[] = [];\n    const source = of(1, 2, 3);\n    const obs = connectable(source, {\n      connector: () => new ReplaySubject(1),\n      resetOnDisconnect: false,\n    });\n\n    obs.subscribe((value) => values.push(value));\n    const connection = obs.connect();\n    expect(values).to.deep.equal([1, 2, 3]);\n\n    connection.unsubscribe();\n\n    obs.subscribe((value) => values.push(value));\n    obs.connect();\n    expect(values).to.deep.equal([1, 2, 3, 3]);\n  });","file":"observables/connectable-spec.ts","skipped":false,"dir":"spec"},{"name":"should defer the creation of a simple Observable","suites":["defer"],"updatePoint":{"line":16,"column":54},"line":16,"code":"  it('should defer the creation of a simple Observable', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const expected = '-a--b--c--|';\n      const e1 = defer(() => cold('-a--b--c--|'));\n      expectObservable(e1).toBe(expected);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from the provided observable factory","suites":["defer"],"updatePoint":{"line":24,"column":70},"line":24,"code":"  it('should create an observable from the provided observable factory', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--|');\n      const sourceSubs = '^----------!';\n      const expected = '  --a--b--c--|';\n\n      const e1 = defer(() => source);\n\n      expectObservable(e1).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from completed","suites":["defer"],"updatePoint":{"line":37,"column":48},"line":37,"code":"  it('should create an observable from completed', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('|');\n      const sourceSubs = '(^!)';\n      const expected = '  |';\n\n      const e1 = defer(() => source);\n\n      expectObservable(e1).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept factory returns promise resolves","suites":["defer"],"updatePoint":{"line":50,"column":52},"line":50,"code":"  it('should accept factory returns promise resolves', (done) => {\n    const expected = 42;\n    const e1 = defer(() => {\n      return new Promise<number>((resolve: any) => {\n        resolve(expected);\n      });\n    });\n\n    e1.subscribe({\n      next: (x: number) => {\n        expect(x).to.equal(expected);\n        done();\n      },\n      error: (x: any) => {\n        done(new Error('should not be called'));\n      },\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept factory returns promise rejects","suites":["defer"],"updatePoint":{"line":69,"column":51},"line":69,"code":"  it('should accept factory returns promise rejects', (done) => {\n    const expected = 42;\n    const e1 = defer(() => {\n      return new Promise<number>((resolve: any, reject: any) => {\n        reject(expected);\n      });\n    });\n\n    e1.subscribe({\n      next: (x: number) => {\n        done(new Error('should not be called'));\n      },\n      error: (x: any) => {\n        expect(x).to.equal(expected);\n        done();\n      },\n      complete: () => {\n        done(new Error('should not be called'));\n      },\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from error","suites":["defer"],"updatePoint":{"line":91,"column":44},"line":91,"code":"  it('should create an observable from error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('#');\n      const sourceSubs = '(^!)';\n      const expected = '  #';\n\n      const e1 = defer(() => source);\n\n      expectObservable(e1).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable when factory does not throw","suites":["defer"],"updatePoint":{"line":104,"column":61},"line":104,"code":"  it('should create an observable when factory does not throw', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = defer(() => {\n        if (1 !== Infinity) {\n          throw 'error';\n        }\n        return of();\n      });\n      const expected = '#';\n\n      expectObservable(e1).toBe(expected);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should error when factory throws","suites":["defer"],"updatePoint":{"line":118,"column":38},"line":118,"code":"  it('should error when factory throws', (done) => {\n    const e1 = defer(() => {\n      if (1 + 2 === 3) {\n        throw 'error';\n      }\n      return of();\n    });\n    e1.subscribe({\n      error: () => done(),\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["defer"],"updatePoint":{"line":130,"column":53},"line":130,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--|');\n      const sourceSubs = '^-----!     ';\n      const expected = '  --a--b-     ';\n      const unsub = '     ------!     ';\n\n      const e1 = defer(() => source);\n\n      expectObservable(e1, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["defer"],"updatePoint":{"line":144,"column":83},"line":144,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--|');\n      const sourceSubs = '^-----!     ';\n      const expected = '  --a--b-     ';\n      const unsub = '     ------!     ';\n\n      const e1 = defer(() =>\n        source.pipe(\n          mergeMap((x: string) => of(x)),\n          mergeMap((x: string) => of(x))\n        )\n      );\n\n      expectObservable(e1, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"observables/defer-spec.ts","skipped":false,"dir":"spec"},{"name":"should create default XMLHttpRequest for non CORS","suites":["ajax"],"updatePoint":{"line":36,"column":55},"line":36,"code":"  it('should create default XMLHttpRequest for non CORS', () => {\n    const obj: AjaxConfig = {\n      url: '/',\n      method: '',\n    };\n\n    ajax(obj).subscribe();\n    expect(MockXMLHttpRequest.mostRecent.withCredentials).to.be.false;\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise an error if not able to create XMLHttpRequest","suites":["ajax"],"updatePoint":{"line":46,"column":64},"line":46,"code":"  it('should raise an error if not able to create XMLHttpRequest', () => {\n    root.XMLHttpRequest = null;\n    root.ActiveXObject = null;\n\n    const obj: AjaxConfig = {\n      url: '/',\n      method: '',\n    };\n\n    ajax(obj).subscribe({ error: (err) => expect(err).to.exist });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should create XMLHttpRequest for CORS","suites":["ajax"],"updatePoint":{"line":58,"column":43},"line":58,"code":"  it('should create XMLHttpRequest for CORS', () => {\n    const obj: AjaxConfig = {\n      url: '/',\n      method: '',\n      crossDomain: true,\n      withCredentials: true,\n    };\n\n    ajax(obj).subscribe();\n    expect(MockXMLHttpRequest.mostRecent.withCredentials).to.be.true;\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise an error if not able to create CORS request","suites":["ajax"],"updatePoint":{"line":70,"column":62},"line":70,"code":"  it('should raise an error if not able to create CORS request', () => {\n    root.XMLHttpRequest = null;\n    root.XDomainRequest = null;\n\n    const obj: AjaxConfig = {\n      url: '/',\n      method: '',\n      crossDomain: true,\n      withCredentials: true,\n    };\n\n    ajax(obj).subscribe({\n      error: (err) => expect(err).to.exist,\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should set headers","suites":["ajax"],"updatePoint":{"line":86,"column":24},"line":86,"code":"  it('should set headers', () => {\n    const obj: AjaxConfig = {\n      url: '/talk-to-me-goose',\n      headers: {\n        'Content-Type': 'kenny/loggins',\n        'Fly-Into-The': 'Dangah Zone!',\n        'Take-A-Ride-Into-The': 'Danger ZoooOoone!',\n      },\n      method: '',\n    };\n\n    ajax(obj).subscribe();\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.url).to.equal('/talk-to-me-goose');\n    expect(request.requestHeaders).to.deep.equal({\n      'content-type': 'kenny/loggins',\n      'fly-into-the': 'Dangah Zone!',\n      'take-a-ride-into-the': 'Danger ZoooOoone!',\n      'x-requested-with': 'XMLHttpRequest',\n    });\n    // Did not mutate the headers passed\n    expect(obj.headers).to.deep.equal({\n      'Content-Type': 'kenny/loggins',\n      'Fly-Into-The': 'Dangah Zone!',\n      'Take-A-Ride-Into-The': 'Danger ZoooOoone!',\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should send the cookie with a custom header to the same domain","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":127,"column":70},"line":127,"code":"    it('should send the cookie with a custom header to the same domain', () => {\n      const obj: AjaxConfig = {\n        url: '/some/path',\n        xsrfCookieName: 'foo',\n        xsrfHeaderName: 'Custom-Header-Name',\n      };\n\n      ajax(obj).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('/some/path');\n      expect(request.requestHeaders).to.deep.equal({\n        'Custom-Header-Name': 'bar',\n        'x-requested-with': 'XMLHttpRequest',\n      });\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should send the cookie cross-domain with a custom header when withCredentials is set","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":145,"column":92},"line":145,"code":"    it('should send the cookie cross-domain with a custom header when withCredentials is set', () => {\n      const obj: AjaxConfig = {\n        url: 'https://some.subresouce.net/some/page',\n        xsrfCookieName: 'foo',\n        xsrfHeaderName: 'Custom-Header-Name',\n        crossDomain: true,\n        withCredentials: true,\n      };\n\n      ajax(obj).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('https://some.subresouce.net/some/page');\n      expect(request.requestHeaders).to.deep.equal({\n        'Custom-Header-Name': 'bar',\n      });\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not send the cookie cross-domain with a custom header when withCredentials is not set","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":164,"column":100},"line":164,"code":"    it('should not send the cookie cross-domain with a custom header when withCredentials is not set', () => {\n      const obj: AjaxConfig = {\n        url: 'https://some.subresouce.net/some/page',\n        xsrfCookieName: 'foo',\n        xsrfHeaderName: 'Custom-Header-Name',\n        crossDomain: true,\n      };\n\n      ajax(obj).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('https://some.subresouce.net/some/page');\n      expect(request.requestHeaders).to.deep.equal({});\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not send the cookie if there is no xsrfHeaderName option","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":180,"column":71},"line":180,"code":"    it('should not send the cookie if there is no xsrfHeaderName option', () => {\n      const obj: AjaxConfig = {\n        url: '/some/page',\n        xsrfCookieName: 'foo',\n      };\n\n      ajax(obj).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('/some/page');\n      expect(request.requestHeaders).to.deep.equal({\n        'x-requested-with': 'XMLHttpRequest',\n      });\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should set the X-Requested-With if crossDomain is false","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":197,"column":61},"line":197,"code":"  it('should set the X-Requested-With if crossDomain is false', () => {\n    ajax({\n      url: '/test/monkey',\n      method: 'GET',\n      crossDomain: false,\n    }).subscribe();\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.requestHeaders).to.deep.equal({\n      'x-requested-with': 'XMLHttpRequest',\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT set the X-Requested-With if crossDomain is true","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":211,"column":64},"line":211,"code":"  it('should NOT set the X-Requested-With if crossDomain is true', () => {\n    ajax({\n      url: '/test/monkey',\n      method: 'GET',\n      crossDomain: true,\n    }).subscribe();\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.requestHeaders).to.not.have.key('x-requested-with');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not alter user-provided X-Requested-With header, even if crossDomain is true","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":223,"column":89},"line":223,"code":"  it('should not alter user-provided X-Requested-With header, even if crossDomain is true', () => {\n    ajax({\n      url: '/test/monkey',\n      method: 'GET',\n      crossDomain: true,\n      headers: {\n        'x-requested-with': 'Custom-XMLHttpRequest',\n      },\n    }).subscribe();\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.requestHeaders['x-requested-with']).to.equal('Custom-XMLHttpRequest');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not set default Content-Type header when no body is sent","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":238,"column":69},"line":238,"code":"  it('should not set default Content-Type header when no body is sent', () => {\n    const obj: AjaxConfig = {\n      url: '/talk-to-me-goose',\n      method: 'GET',\n    };\n\n    ajax(obj).subscribe();\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.url).to.equal('/talk-to-me-goose');\n    expect(request.requestHeaders).to.not.have.keys('Content-Type');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if createXHR throws","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":252,"column":38},"line":252,"code":"  it('should error if createXHR throws', () => {\n    let error;\n\n    ajax({\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      createXHR: () => {\n        throw new Error('wokka wokka');\n      },\n    }).subscribe({\n      next: () => {\n        throw new Error('should not next');\n      },\n      error: (err: any) => {\n        error = err;\n      },\n      complete: () => {\n        throw new Error('should not complete');\n      },\n    });\n\n    expect(error).to.be.an('error', 'wokka wokka');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if send request throws","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":276,"column":41},"line":276,"code":"  it('should error if send request throws', (done) => {\n    const expected = new Error('xhr send failure');\n\n    ajax({\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      method: '',\n      createXHR: () => {\n        const ret = new MockXMLHttpRequest();\n        ret.send = () => {\n          throw expected;\n        };\n        return ret as any;\n      },\n    }).subscribe({\n      next: () => {\n        done(new Error('should not be called'));\n      },\n      error: (e: Error) => {\n        expect(e).to.be.equal(expected);\n        done();\n      },\n      complete: () => {\n        done(new Error('should not be called'));\n      },\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 200","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":304,"column":27},"line":304,"code":"  it('should succeed on 200', () => {\n    const expected = { foo: 'bar' };\n    let result: AjaxResponse<any>;\n    let complete = false;\n\n    ajax({\n      url: '/flibbertyJibbet',\n      method: '',\n    }).subscribe({\n      next: (x: any) => {\n        result = x;\n      },\n      complete: () => {\n        complete = true;\n      },\n    });\n\n    expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 200,\n      responseText: JSON.stringify(expected),\n    });\n\n    expect(result!.xhr).exist;\n    expect(result!.response).to.deep.equal({ foo: 'bar' });\n    expect(complete).to.be.true;\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should fail if fails to parse response in older IE","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":333,"column":56},"line":333,"code":"  it('should fail if fails to parse response in older IE', () => {\n    let error: any;\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      method: '',\n    };\n\n    // No `response` property on the object (for older IE).\n    MockXMLHttpRequest.noResponseProp = true;\n\n    ajax(obj).subscribe({\n      next: () => {\n        throw new Error('should not next');\n      },\n      error: (err: any) => {\n        error = err;\n      },\n      complete: () => {\n        throw new Error('should not complete');\n      },\n    });\n\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 207,\n      responseText: 'Wee! I am text, but should be valid JSON!',\n    });\n\n    expect(error instanceof SyntaxError).to.be.true;\n    expect(error.message).to.equal('Unexpected token W in JSON at position 0');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should fail on 404","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":364,"column":24},"line":364,"code":"  it('should fail on 404', () => {\n    let error: any;\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      method: '',\n    };\n\n    ajax(obj).subscribe({\n      next: () => {\n        throw new Error('should not next');\n      },\n      error: (err: any) => {\n        error = err;\n      },\n      complete: () => {\n        throw new Error('should not complete');\n      },\n    });\n\n    expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 404,\n      responseText: 'Wee! I am text!',\n    });\n\n    expect(error instanceof AjaxError).to.be.true;\n    expect(error.name).to.equal('AjaxError');\n    expect(error.message).to.equal('ajax error 404');\n    expect(error.status).to.equal(404);\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 300","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":397,"column":27},"line":397,"code":"  it('should succeed on 300', () => {\n    let result: AjaxResponse<any>;\n    let complete = false;\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      method: '',\n    };\n\n    ajax(obj).subscribe({\n      next: (x: any) => {\n        result = x;\n      },\n      complete: () => {\n        complete = true;\n      },\n    });\n\n    expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 300,\n      responseText: 'Wee! I am text!',\n    });\n\n    expect(result!.xhr).exist;\n    expect(result!.response).to.deep.equal('Wee! I am text!');\n    expect(complete).to.be.true;\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not fail if fails to parse error response","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":427,"column":54},"line":427,"code":"  it('should not fail if fails to parse error response', () => {\n    let error: any;\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'json',\n      method: '',\n    };\n\n    ajax(obj).subscribe({\n      next: () => {\n        throw new Error('should not next');\n      },\n      error: (err: any) => {\n        error = err;\n      },\n      complete: () => {\n        throw new Error('should not complete');\n      },\n    });\n\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 404,\n      responseText: 'Unparsable as json',\n    });\n\n    expect(error instanceof AjaxError).to.be.true;\n    // The default behavior of XHR if you get something back that you can't\n    // parse as JSON, but you have a requestType of \"json\" is to\n    // have `response` set to `null`.\n    expect(error.response).to.be.null;\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed no settings","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":459,"column":32},"line":459,"code":"  it('should succeed no settings', () => {\n    const expected = JSON.stringify({ foo: 'bar' });\n\n    ajax('/flibbertyJibbet').subscribe({\n      next: (x: any) => {\n        expect(x.status).to.equal(200);\n        expect(x.xhr.method).to.equal('GET');\n        expect(x.xhr.responseText).to.equal(expected);\n      },\n      error: () => {\n        throw 'should not have been called';\n      },\n    });\n\n    expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 200,\n      responseText: expected,\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should fail no settings","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":480,"column":29},"line":480,"code":"  it('should fail no settings', () => {\n    const expected = JSON.stringify({ foo: 'bar' });\n\n    ajax('/flibbertyJibbet').subscribe({\n      next: () => {\n        throw 'should not have been called';\n      },\n      error: (x: any) => {\n        expect(x.status).to.equal(500);\n        expect(x.xhr.method).to.equal('GET');\n        expect(x.xhr.responseText).to.equal(expected);\n      },\n      complete: () => {\n        throw 'should not have been called';\n      },\n    });\n\n    expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n    MockXMLHttpRequest.mostRecent.respondWith({\n      status: 500,\n      responseText: expected,\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an asynchronous request","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":504,"column":43},"line":504,"code":"  it('should create an asynchronous request', () => {\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      timeout: 10,\n    };\n\n    ajax(obj).subscribe({\n      next: (x: any) => {\n        expect(x.status).to.equal(200);\n        expect(x.xhr.method).to.equal('GET');\n        expect(x.xhr.async).to.equal(true);\n        expect(x.xhr.timeout).to.equal(10);\n        expect(x.xhr.responseType).to.equal('text');\n      },\n      error: () => {\n        throw 'should not have been called';\n      },\n    });\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.url).to.equal('/flibbertyJibbet');\n\n    request.respondWith({\n      status: 200,\n      responseText: 'Wee! I am text!',\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on timeout of asynchronous request","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":534,"column":53},"line":534,"code":"  it('should error on timeout of asynchronous request', () => {\n    const rxTestScheduler = new TestScheduler(noop);\n\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      timeout: 10,\n    };\n\n    ajax(obj).subscribe({\n      next: () => {\n        throw 'should not have been called';\n      },\n      error: (e) => {\n        expect(e.status).to.equal(0);\n        expect(e.xhr.method).to.equal('GET');\n        expect(e.xhr.async).to.equal(true);\n        expect(e.xhr.timeout).to.equal(10);\n        expect(e.xhr.responseType).to.equal('text');\n      },\n    });\n\n    const request = MockXMLHttpRequest.mostRecent;\n\n    expect(request.url).to.equal('/flibbertyJibbet');\n\n    rxTestScheduler.schedule(() => {\n      request.respondWith({\n        status: 200,\n        responseText: 'Wee! I am text!',\n      });\n    }, 1000);\n\n    rxTestScheduler.flush();\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a synchronous request","suites":["ajax","ajax XSRF cookie in custom header"],"updatePoint":{"line":570,"column":41},"line":570,"code":"  it('should create a synchronous request', () => {\n    const obj: AjaxConfig = {\n      url: '/flibbertyJibbet',\n      responseType: 'text',\n      timeout: 10,\n      async: false,\n    };\n\n    ajax(obj).subscribe();\n\n    const mockXHR = MockXMLHttpRequest.mostRecent;\n\n    expect(mockXHR.url).to.equal('/flibbertyJibbet');\n    // Open was called with async `false`.\n    expect(mockXHR.async).to.be.false;\n\n    mockXHR.respondWith({\n      status: 200,\n      responseText: 'Wee! I am text!',\n    });\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"can take string body","suites":["ajax","ajax request body"],"updatePoint":{"line":593,"column":28},"line":593,"code":"    it('can take string body', () => {\n      const obj = {\n        url: '/flibbertyJibbet',\n        method: 'POST',\n        body: 'foobar',\n      };\n\n      ajax(obj).subscribe();\n\n      expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n      expect(MockXMLHttpRequest.mostRecent.data).to.equal('foobar');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"can take FormData body","suites":["ajax","ajax request body"],"updatePoint":{"line":606,"column":30},"line":606,"code":"    it('can take FormData body', () => {\n      const body = new root.FormData();\n      const obj = {\n        url: '/flibbertyJibbet',\n        method: 'POST',\n        body: body,\n      };\n\n      ajax(obj).subscribe();\n\n      expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n      expect(MockXMLHttpRequest.mostRecent.data).to.equal(body);\n      expect(MockXMLHttpRequest.mostRecent.requestHeaders).to.deep.equal({\n        'x-requested-with': 'XMLHttpRequest',\n      });\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should send the URLSearchParams straight through to the body","suites":["ajax","ajax request body"],"updatePoint":{"line":623,"column":68},"line":623,"code":"    it('should send the URLSearchParams straight through to the body', () => {\n      const body = new URLSearchParams({\n        '': '',\n      });\n      const obj = {\n        url: '/flibbertyJibbet',\n        method: 'POST',\n        body: body,\n      };\n\n      ajax(obj).subscribe();\n\n      expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n      expect(MockXMLHttpRequest.mostRecent.data).to.equal(body);\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should send by JSON","suites":["ajax","ajax request body"],"updatePoint":{"line":639,"column":27},"line":639,"code":"    it('should send by JSON', () => {\n      const body = {\n        '': '',\n      };\n      const obj = {\n        url: '/flibbertyJibbet',\n        method: 'POST',\n        body: body,\n      };\n\n      ajax(obj).subscribe();\n\n      expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n      expect(MockXMLHttpRequest.mostRecent.data).to.equal('{\"\":\"\"}');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should send json body not mattered on case-sensitivity of HTTP headers","suites":["ajax","ajax request body"],"updatePoint":{"line":655,"column":78},"line":655,"code":"    it('should send json body not mattered on case-sensitivity of HTTP headers', () => {\n      const body = {\n        hello: 'world',\n      };\n\n      const requestObj = {\n        url: '/flibbertyJibbet',\n        method: '',\n        body: body,\n        headers: {\n          'cOnTeNt-TyPe': 'application/json;charset=UTF-8',\n        },\n      };\n\n      ajax(requestObj).subscribe();\n\n      expect(MockXMLHttpRequest.mostRecent.url).to.equal('/flibbertyJibbet');\n      expect(MockXMLHttpRequest.mostRecent.data).to.equal('{\"hello\":\"world\"}');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if send request throws","suites":["ajax","ajax request body"],"updatePoint":{"line":675,"column":43},"line":675,"code":"    it('should error if send request throws', (done) => {\n      const expected = new Error('xhr send failure');\n\n      const obj: AjaxConfig = {\n        url: '/flibbertyJibbet',\n        responseType: 'text',\n        method: '',\n        body: 'foobar',\n        createXHR: () => {\n          const ret = new MockXMLHttpRequest();\n          ret.send = () => {\n            throw expected;\n          };\n          return ret as any;\n        },\n      };\n\n      ajax(obj).subscribe({\n        next: () => {\n          done(new Error('should not be called'));\n        },\n        error: (e: Error) => {\n          expect(e).to.be.equal(expected);\n          done();\n        },\n        complete: () => {\n          done(new Error('should not be called'));\n        },\n      });\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 200","suites":["ajax","ajax.get"],"updatePoint":{"line":708,"column":29},"line":708,"code":"    it('should succeed on 200', () => {\n      const expected = { foo: 'bar' };\n      let result;\n      let complete = false;\n\n      ajax.get('/flibbertyJibbet').subscribe({\n        next: (x) => {\n          result = x.response;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('/flibbertyJibbet');\n\n      request.respondWith({\n        status: 200,\n        responseText: JSON.stringify(expected),\n      });\n\n      expect(result).to.deep.equal(expected);\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 204 No Content","suites":["ajax","ajax.get"],"updatePoint":{"line":735,"column":40},"line":735,"code":"    it('should succeed on 204 No Content', () => {\n      let result;\n      let complete = false;\n\n      ajax.get('/flibbertyJibbet').subscribe({\n        next: (x) => {\n          result = x.response;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('/flibbertyJibbet');\n\n      request.respondWith({\n        status: 204,\n        responseText: '',\n      });\n\n      // Response will get set to null by the browser XHR\n      // This is sort of arbitrarily determined by our test harness\n      // but we want to be as accurate as possible.\n      expect(result).to.be.null;\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should able to select json response via getJSON","suites":["ajax","ajax.get"],"updatePoint":{"line":764,"column":55},"line":764,"code":"    it('should able to select json response via getJSON', () => {\n      const expected = { foo: 'bar' };\n      let result;\n      let complete = false;\n\n      ajax.getJSON('/flibbertyJibbet').subscribe({\n        next: (x) => {\n          result = x;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.url).to.equal('/flibbertyJibbet');\n\n      request.respondWith({\n        status: 200,\n        responseText: JSON.stringify(expected),\n      });\n\n      expect(result).to.deep.equal(expected);\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 200","suites":["ajax","ajax.post"],"updatePoint":{"line":793,"column":29},"line":793,"code":"    it('should succeed on 200', () => {\n      const expected = { foo: 'bar', hi: 'there you' };\n      let result: AjaxResponse<any>;\n      let complete = false;\n\n      ajax.post('/flibbertyJibbet', expected).subscribe({\n        next: (x) => {\n          result = x;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.method).to.equal('POST');\n      expect(request.url).to.equal('/flibbertyJibbet');\n      expect(request.requestHeaders).to.deep.equal({\n        'content-type': 'application/json;charset=utf-8',\n        'x-requested-with': 'XMLHttpRequest',\n      });\n\n      request.respondWith({\n        status: 200,\n        responseText: JSON.stringify(expected),\n      });\n\n      expect(request.data).to.equal(JSON.stringify(expected));\n      expect(result!.response).to.deep.equal(expected);\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should succeed on 204 No Content","suites":["ajax","ajax.post"],"updatePoint":{"line":826,"column":40},"line":826,"code":"    it('should succeed on 204 No Content', () => {\n      let result: AjaxResponse<any>;\n      let complete = false;\n\n      ajax.post('/flibbertyJibbet', undefined).subscribe({\n        next: (x) => {\n          result = x;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.method).to.equal('POST');\n      expect(request.url).to.equal('/flibbertyJibbet');\n      expect(request.requestHeaders).to.deep.equal({\n        'x-requested-with': 'XMLHttpRequest',\n      });\n\n      request.respondWith({\n        status: 204,\n        responseText: '',\n      });\n\n      // Since the default setting for `responseType` is \"json\",\n      // and our `responseText` is an empty string (which isn't parsable as JSON),\n      // response should be `null` here.\n      expect(result!.response).to.be.null;\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow partial progressSubscriber ","suites":["ajax","ajax.post"],"updatePoint":{"line":859,"column":48},"line":859,"code":"    it('should allow partial progressSubscriber ', function () {\n      const spy = sinon.spy();\n      const progressSubscriber: any = {\n        next: spy,\n      };\n\n      ajax({\n        url: '/flibbertyJibbet',\n        progressSubscriber,\n      }).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      request.respondWith(\n        {\n          status: 200,\n          responseText: JSON.stringify({}),\n        },\n        { uploadProgressTimes: 3 }\n      );\n\n      expect(spy).to.be.called.callCount(4);\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit progress event when progressSubscriber is specified","suites":["ajax","ajax.post"],"updatePoint":{"line":883,"column":71},"line":883,"code":"    it('should emit progress event when progressSubscriber is specified', function () {\n      const spy = sinon.spy();\n      const progressSubscriber = <any>{\n        next: spy,\n        error: () => {\n          // noop\n        },\n        complete: () => {\n          // noop\n        },\n      };\n\n      ajax({\n        url: '/flibbertyJibbet',\n        progressSubscriber,\n      }).subscribe();\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      request.respondWith(\n        {\n          status: 200,\n          responseText: JSON.stringify({}),\n        },\n        { uploadProgressTimes: 3 }\n      );\n\n      expect(spy).to.be.called.callCount(4);\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an AjaxObservable with correct options","suites":["ajax","ajax.patch"],"updatePoint":{"line":915,"column":60},"line":915,"code":"    it('should create an AjaxObservable with correct options', () => {\n      const expected = { foo: 'bar', hi: 'there you' };\n      let result: AjaxResponse<any>;\n      let complete = false;\n\n      ajax.patch('/flibbertyJibbet', expected).subscribe({\n        next: (x) => {\n          result = x;\n        },\n        complete: () => {\n          complete = true;\n        },\n      });\n\n      const request = MockXMLHttpRequest.mostRecent;\n\n      expect(request.method).to.equal('PATCH');\n      expect(request.url).to.equal('/flibbertyJibbet');\n      expect(request.requestHeaders).to.deep.equal({\n        'content-type': 'application/json;charset=utf-8',\n        'x-requested-with': 'XMLHttpRequest',\n      });\n\n      request.respondWith({\n        status: 200,\n        responseText: JSON.stringify(expected),\n      });\n\n      expect(request.data).to.equal(JSON.stringify(expected));\n      expect(result!.response).to.deep.equal(expected);\n      expect(complete).to.be.true;\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should extend Error class","suites":["ajax","ajax error classes","AjaxError"],"updatePoint":{"line":951,"column":35},"line":951,"code":"      it('should extend Error class', () => {\n        const error = new AjaxError('Test error', new XMLHttpRequest(), {\n          url: '/',\n          method: 'GET',\n          responseType: 'json',\n          headers: {},\n          withCredentials: false,\n          async: true,\n          timeout: 0,\n          crossDomain: false,\n        });\n        expect(error).to.be.an.instanceOf(Error);\n      });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should extend Error class","suites":["ajax","ajax error classes","AjaxTimeoutError"],"updatePoint":{"line":967,"column":35},"line":967,"code":"      it('should extend Error class', () => {\n        const error = new AjaxTimeoutError(new XMLHttpRequest(), {\n          url: '/',\n          method: 'GET',\n          responseType: 'json',\n          headers: {},\n          withCredentials: false,\n          async: true,\n          timeout: 0,\n          crossDomain: false,\n        });\n        expect(error).to.be.an.instanceOf(Error);\n      });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should extend AjaxError class","suites":["ajax","ajax error classes","AjaxTimeoutError"],"updatePoint":{"line":981,"column":39},"line":981,"code":"      it('should extend AjaxError class', () => {\n        const error = new AjaxTimeoutError(new XMLHttpRequest(), {\n          url: '/',\n          method: 'GET',\n          responseType: 'json',\n          headers: {},\n          withCredentials: false,\n          async: true,\n          timeout: 0,\n          crossDomain: false,\n        });\n        expect(error).to.be.an.instanceOf(AjaxError);\n      });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if aborted early","suites":["ajax","ajax error classes","AjaxTimeoutError"],"updatePoint":{"line":997,"column":35},"line":997,"code":"  it('should error if aborted early', () => {\n    let thrown: any = null;\n\n    ajax({\n      method: 'GET',\n      url: '/flibbertyJibbett',\n    }).subscribe({\n      next: () => {\n        throw new Error('should not be called');\n      },\n      error: (err) => {\n        thrown = err;\n      },\n    });\n\n    const mockXHR = MockXMLHttpRequest.mostRecent;\n    expect(thrown).to.be.null;\n\n    mockXHR.triggerEvent('abort', { type: 'abort' });\n    expect(thrown).to.be.an.instanceOf(AjaxError);\n    expect(thrown.message).to.equal('aborted');\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit download progress","suites":["ajax","with includeDownloadProgress"],"updatePoint":{"line":1021,"column":37},"line":1021,"code":"    it('should emit download progress', () => {\n      const results: any[] = [];\n\n      ajax({\n        method: 'GET',\n        url: '/flibbertyJibbett',\n        includeDownloadProgress: true,\n      }).subscribe({\n        next: (value) => results.push(value),\n        complete: () => results.push('done'),\n      });\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n      mockXHR.respondWith(\n        {\n          status: 200,\n          total: 5,\n          loaded: 5,\n          responseText: JSON.stringify({ boo: 'I am a ghost' }),\n        },\n        { uploadProgressTimes: 5, downloadProgressTimes: 5 }\n      );\n\n      const request = {\n        async: true,\n        body: undefined,\n        crossDomain: false,\n        headers: {\n          'x-requested-with': 'XMLHttpRequest',\n        },\n        includeDownloadProgress: true,\n        method: 'GET',\n        responseType: 'json',\n        timeout: 0,\n        url: '/flibbertyJibbett',\n        withCredentials: false,\n      };\n\n      expect(results).to.deep.equal([\n        {\n          type: 'download_loadstart',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 0,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'loadstart', loaded: 0, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 1,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 1, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 2,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 2, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 3,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 3, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 4,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 4, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 5,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 5, total: 5 },\n        },\n        {\n          type: 'download_load',\n          loaded: 5,\n          total: 5,\n          request,\n          originalEvent: { type: 'load', loaded: 5, total: 5 },\n          xhr: mockXHR,\n          response: { boo: 'I am a ghost' },\n          responseHeaders: {},\n          responseType: 'json',\n          status: 200,\n        },\n        'done', // from completion.\n      ]);\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit upload and download progress","suites":["ajax","with includeDownloadProgress"],"updatePoint":{"line":1148,"column":48},"line":1148,"code":"    it('should emit upload and download progress', () => {\n      const results: any[] = [];\n\n      ajax({\n        method: 'GET',\n        url: '/flibbertyJibbett',\n        includeUploadProgress: true,\n        includeDownloadProgress: true,\n      }).subscribe({\n        next: (value) => results.push(value),\n        complete: () => results.push('done'),\n      });\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n      mockXHR.respondWith(\n        {\n          status: 200,\n          total: 5,\n          loaded: 5,\n          responseText: JSON.stringify({ boo: 'I am a ghost' }),\n        },\n        { uploadProgressTimes: 5, downloadProgressTimes: 5 }\n      );\n\n      const request = {\n        async: true,\n        body: undefined,\n        crossDomain: false,\n        headers: {\n          'x-requested-with': 'XMLHttpRequest',\n        },\n        includeUploadProgress: true,\n        includeDownloadProgress: true,\n        method: 'GET',\n        responseType: 'json',\n        timeout: 0,\n        url: '/flibbertyJibbett',\n        withCredentials: false,\n      };\n\n      expect(results).to.deep.equal([\n        {\n          type: 'upload_loadstart',\n          loaded: 0,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'loadstart', loaded: 0, total: 5 },\n        },\n        {\n          type: 'upload_progress',\n          loaded: 1,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 1, total: 5 },\n        },\n        {\n          type: 'upload_progress',\n          loaded: 2,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 2, total: 5 },\n        },\n        {\n          type: 'upload_progress',\n          loaded: 3,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 3, total: 5 },\n        },\n        {\n          type: 'upload_progress',\n          loaded: 4,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 4, total: 5 },\n        },\n        {\n          type: 'upload_progress',\n          loaded: 5,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 5, total: 5 },\n        },\n        {\n          type: 'upload_load',\n          loaded: 5,\n          total: 5,\n          request,\n          status: 0,\n          response: undefined,\n          responseHeaders: {},\n          responseType: 'json',\n          xhr: mockXHR,\n          originalEvent: { type: 'load', loaded: 5, total: 5 },\n        },\n        {\n          type: 'download_loadstart',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 0,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'loadstart', loaded: 0, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 1,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 1, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 2,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 2, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 3,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 3, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 4,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 4, total: 5 },\n        },\n        {\n          type: 'download_progress',\n          responseHeaders: {},\n          responseType: 'json',\n          response: undefined,\n          loaded: 5,\n          total: 5,\n          request,\n          status: 0,\n          xhr: mockXHR,\n          originalEvent: { type: 'progress', loaded: 5, total: 5 },\n        },\n        {\n          type: 'download_load',\n          loaded: 5,\n          total: 5,\n          request,\n          originalEvent: { type: 'load', loaded: 5, total: 5 },\n          xhr: mockXHR,\n          response: { boo: 'I am a ghost' },\n          responseHeaders: {},\n          responseType: 'json',\n          status: 200,\n        },\n        'done', // from completion.\n      ]);\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should return an object that allows access to response headers","suites":["ajax","with includeDownloadProgress"],"updatePoint":{"line":1362,"column":68},"line":1362,"code":"  it('should return an object that allows access to response headers', () => {\n    const sentResponseHeaders = {\n      'content-type': 'application/json',\n      'x-custom-header': 'test',\n      'x-headers-are-fun': '<whatever/> {\"weird\": \"things\"}',\n    };\n\n    ajax({\n      method: 'GET',\n      url: '/whatever',\n    }).subscribe((response) => {\n      expect(response.responseHeaders).to.deep.equal(sentResponseHeaders);\n    });\n\n    const mockXHR = MockXMLHttpRequest.mostRecent;\n\n    mockXHR.respondWith({\n      status: 200,\n      headers: sentResponseHeaders,\n      responseText: JSON.stringify({ iam: 'tired', and: 'should go to bed', but: 'I am doing open source for no good reason' }),\n    });\n\n    expect(mockXHR.getAllResponseHeaders()).to.equal(`content-type: application/json\nx-custom-header: test\nx-headers-are-fun: <whatever/> {\"weird\": \"things\"}`);\n  });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow passing of search queryParams as a dictionary","suites":["ajax","with queryParams"],"updatePoint":{"line":1390,"column":66},"line":1390,"code":"    it('should allow passing of search queryParams as a dictionary', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: { foo: 'bar', whatever: '123' },\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?foo=bar&whatever=123');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow passing of search queryParams as an entries array","suites":["ajax","with queryParams"],"updatePoint":{"line":1407,"column":70},"line":1407,"code":"    it('should allow passing of search queryParams as an entries array', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: [\n          ['foo', 'bar'],\n          ['whatever', '123'],\n        ],\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?foo=bar&whatever=123');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow passing of search queryParams as a string","suites":["ajax","with queryParams"],"updatePoint":{"line":1427,"column":62},"line":1427,"code":"    it('should allow passing of search queryParams as a string', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: '?foo=bar&whatever=123',\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?foo=bar&whatever=123');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow passing of search queryParams as a URLSearchParams object","suites":["ajax","with queryParams"],"updatePoint":{"line":1444,"column":78},"line":1444,"code":"    it('should allow passing of search queryParams as a URLSearchParams object', () => {\n      const queryParams = new URLSearchParams();\n      queryParams.set('foo', 'bar');\n      queryParams.set('whatever', '123');\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams,\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?foo=bar&whatever=123');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should not screw things up if there is an existing search string in the url passed","suites":["ajax","with queryParams"],"updatePoint":{"line":1464,"column":90},"line":1464,"code":"    it('should not screw things up if there is an existing search string in the url passed', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever?jays_face=is+a+param&lol=haha',\n        queryParams: { foo: 'bar', whatever: '123' },\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?jays_face=is+a+param&lol=haha&foo=bar&whatever=123');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should overwrite existing args from existing search strings in the url passed","suites":["ajax","with queryParams"],"updatePoint":{"line":1481,"column":85},"line":1481,"code":"    it('should overwrite existing args from existing search strings in the url passed', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever?terminator=2&uncle_bob=huh',\n        queryParams: { uncle_bob: '...okayyyyyyy', movie_quote: 'yes' },\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?terminator=2&uncle_bob=...okayyyyyyy&movie_quote=yes');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should properly encode values","suites":["ajax","with queryParams"],"updatePoint":{"line":1498,"column":37},"line":1498,"code":"    it('should properly encode values', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: { 'this is a weird param name': '?#* value here rofl !!!' },\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?this+is+a+weird+param+name=%3F%23*+value+here+rofl+%21%21%21');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle dictionaries that have numbers, booleans, and arrays of numbers, strings or booleans","suites":["ajax","with queryParams"],"updatePoint":{"line":1515,"column":106},"line":1515,"code":"    it('should handle dictionaries that have numbers, booleans, and arrays of numbers, strings or booleans', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: { a: 123, b: true, c: ['one', 'two', 'three'], d: [1, 3, 3, 7], e: [true, false, true] },\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?a=123&b=true&c=one%2Ctwo%2Cthree&d=1%2C3%2C3%2C7&e=true%2Cfalse%2Ctrue');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle entries that have numbers, booleans, and arrays of numbers, strings or booleans","suites":["ajax","with queryParams"],"updatePoint":{"line":1532,"column":101},"line":1532,"code":"    it('should handle entries that have numbers, booleans, and arrays of numbers, strings or booleans', () => {\n      ajax({\n        method: 'GET',\n        url: '/whatever',\n        queryParams: [\n          ['a', 123],\n          ['b', true],\n          ['c', ['one', 'two', 'three']],\n          ['d', [1, 3, 3, 7]],\n          ['e', [true, false, true]],\n        ],\n      }).subscribe();\n\n      const mockXHR = MockXMLHttpRequest.mostRecent;\n\n      mockXHR.respondWith({\n        status: 200,\n        responseText: JSON.stringify({ whatever: 'I want' }),\n      });\n\n      expect(mockXHR.url).to.equal('/whatever?a=123&b=true&c=one%2Ctwo%2Cthree&d=1%2C3%2C3%2C7&e=true%2Cfalse%2Ctrue');\n    });","file":"observables/dom/ajax-spec.ts","skipped":false,"dir":"spec"},{"name":"should animate","suites":["animationFrames"],"updatePoint":{"line":17,"column":20},"line":17,"code":"  it('should animate', function () {\n    testScheduler.run(({ animate, cold, expectObservable, time }) => {\n      animate('            ---x---x---x');\n      const mapped = cold('-m          ');\n      const tm = time('    -|          ');\n      const ta = time('    ---|        ');\n      const tb = time('    -------|    ');\n      const tc = time('    -----------|');\n      const expected = '   ---a---b---c';\n      const subs = '       ^----------!';\n\n      const result = mapped.pipe(mergeMapTo(animationFrames()));\n      expectObservable(result, subs).toBe(expected, {\n        a: { elapsed: ta - tm, timestamp: ta },\n        b: { elapsed: tb - tm, timestamp: tb },\n        c: { elapsed: tc - tm, timestamp: tc },\n      });\n    });\n  });","file":"observables/dom/animationFrames-spec.ts","skipped":false,"dir":"spec"},{"name":"should use any passed timestampProvider","suites":["animationFrames"],"updatePoint":{"line":37,"column":45},"line":37,"code":"  it('should use any passed timestampProvider', () => {\n    let i = 0;\n    const timestampProvider = {\n      now: sinon.stub().callsFake(() => {\n        return [50, 100, 200, 300][i++];\n      }),\n    };\n\n    testScheduler.run(({ animate, cold, expectObservable }) => {\n      animate('            ---x---x---x');\n      const mapped = cold('-m          ');\n      const expected = '   ---a---b---c';\n      const subs = '       ^----------!';\n\n      const result = mapped.pipe(mergeMapTo(animationFrames(timestampProvider)));\n      expectObservable(result, subs).toBe(expected, {\n        a: { elapsed: 50, timestamp: 100 },\n        b: { elapsed: 150, timestamp: 200 },\n        c: { elapsed: 250, timestamp: 300 },\n      });\n    });\n  });","file":"observables/dom/animationFrames-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose with take","suites":["animationFrames"],"updatePoint":{"line":60,"column":30},"line":60,"code":"  it('should compose with take', () => {\n    testScheduler.run(({ animate, cold, expectObservable, time }) => {\n      const requestSpy = sinon.spy(animationFrameProvider.delegate!, 'requestAnimationFrame');\n      const cancelSpy = sinon.spy(animationFrameProvider.delegate!, 'cancelAnimationFrame');\n\n      animate('            ---x---x---x');\n      const mapped = cold('-m          ');\n      const tm = time('    -|          ');\n      const ta = time('    ---|        ');\n      const tb = time('    -------|    ');\n      const expected = '   ---a---b    ';\n\n      const result = mapped.pipe(mergeMapTo(animationFrames().pipe(take(2))));\n      expectObservable(result).toBe(expected, {\n        a: { elapsed: ta - tm, timestamp: ta },\n        b: { elapsed: tb - tm, timestamp: tb },\n      });\n\n      testScheduler.flush();\n      // Requests are made at times tm and ta\n      expect(requestSpy.callCount).to.equal(2);\n      // No request cancellation is effected, as unsubscription occurs before rescheduling\n      expect(cancelSpy.callCount).to.equal(0);\n    });\n  });","file":"observables/dom/animationFrames-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose with takeUntil","suites":["animationFrames"],"updatePoint":{"line":86,"column":35},"line":86,"code":"  it('should compose with takeUntil', () => {\n    testScheduler.run(({ animate, cold, expectObservable, hot, time }) => {\n      const requestSpy = sinon.spy(animationFrameProvider.delegate!, 'requestAnimationFrame');\n      const cancelSpy = sinon.spy(animationFrameProvider.delegate!, 'cancelAnimationFrame');\n\n      animate('            ---x---x---x');\n      const mapped = cold('-m          ');\n      const tm = time('    -|          ');\n      const ta = time('    ---|        ');\n      const tb = time('    -------|    ');\n      const signal = hot(' ^--------s--');\n      const expected = '   ---a---b    ';\n\n      const result = mapped.pipe(mergeMapTo(animationFrames().pipe(takeUntil(signal))));\n      expectObservable(result).toBe(expected, {\n        a: { elapsed: ta - tm, timestamp: ta },\n        b: { elapsed: tb - tm, timestamp: tb },\n      });\n\n      testScheduler.flush();\n      // Requests are made at times tm and ta and tb\n      expect(requestSpy.callCount).to.equal(3);\n      // Unsubscription effects request cancellation when signalled\n      expect(cancelSpy.callCount).to.equal(1);\n    });\n  });","file":"observables/dom/animationFrames-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["fromFetch"],"updatePoint":{"line":113,"column":18},"line":113,"code":"  it('should exist', () => {\n    expect(fromFetch).to.be.a('function');\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should fetch","suites":["fromFetch"],"updatePoint":{"line":117,"column":18},"line":117,"code":"  it('should fetch', (done) => {\n    const fetch$ = fromFetch('/foo');\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n\n    fetch$.subscribe({\n      next: response => {\n        expect(response).to.equal(OK_RESPONSE);\n      },\n      error: done,\n      complete: () => {\n        // Wait until the complete and the subsequent unsubscribe are finished\n        // before testing these expectations:\n        setTimeout(() => {\n          expect(MockAbortController.created).to.equal(1);\n          expect(mockFetch.calls.length).to.equal(1);\n          expect(mockFetch.calls[0].input).to.equal('/foo');\n          expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n          expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n          done();\n        }, 0);\n      }\n    });\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle Response that is not `ok`","suites":["fromFetch"],"updatePoint":{"line":142,"column":45},"line":142,"code":"  it('should handle Response that is not `ok`', (done) => {\n    mockFetch.respondWith = {\n      ok: false,\n      status: 400,\n      body: 'Bad stuff here'\n    } as any as Response;\n\n    const fetch$ = fromFetch('/foo');\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n\n    fetch$.subscribe({\n      next: response => {\n        expect(response).to.equal(mockFetch.respondWith);\n      },\n      complete: done,\n      error: done\n    });\n\n    expect(MockAbortController.created).to.equal(1);\n    expect(mockFetch.calls.length).to.equal(1);\n    expect(mockFetch.calls[0].input).to.equal('/foo');\n    expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should abort when unsubscribed","suites":["fromFetch"],"updatePoint":{"line":168,"column":36},"line":168,"code":"  it('should abort when unsubscribed', () => {\n    const fetch$ = fromFetch('/foo');\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n    const subscription = fetch$.subscribe();\n\n    expect(MockAbortController.created).to.equal(1);\n    expect(mockFetch.calls.length).to.equal(1);\n    expect(mockFetch.calls[0].input).to.equal('/foo');\n    expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n\n    subscription.unsubscribe();\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.true;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should not immediately abort repeat subscribers","suites":["fromFetch"],"updatePoint":{"line":184,"column":53},"line":184,"code":"  it('should not immediately abort repeat subscribers', () => {\n    const fetch$ = fromFetch('/foo');\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n    let subscription = fetch$.subscribe();\n    expect(MockAbortController.created).to.equal(1);\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n\n    subscription.unsubscribe();\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.true;\n\n    subscription = fetch$.subscribe();\n    expect(MockAbortController.created).to.equal(2);\n    expect(mockFetch.calls[1].init!.signal!.aborted).to.be.false;\n\n    subscription.unsubscribe();\n    expect(mockFetch.calls[1].init!.signal!.aborted).to.be.true;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow passing of init object","suites":["fromFetch"],"updatePoint":{"line":203,"column":41},"line":203,"code":"  it('should allow passing of init object', (done) => {\n    const fetch$ = fromFetch('/foo', {method: 'HEAD'});\n    fetch$.subscribe({\n      error: done,\n      complete: done,\n    });\n    expect(mockFetch.calls[0].init!.method).to.equal('HEAD');\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should add a signal to internal init object without mutating the passed init object","suites":["fromFetch"],"updatePoint":{"line":212,"column":89},"line":212,"code":"  it('should add a signal to internal init object without mutating the passed init object', (done) => {\n    const myInit = {method: 'DELETE'};\n    const fetch$ = fromFetch('/bar', myInit);\n    fetch$.subscribe({\n      error: done,\n      complete: done,\n    });\n    expect(mockFetch.calls[0].init!.method).to.equal(myInit.method);\n    expect(mockFetch.calls[0].init).not.to.equal(myInit);\n    expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should treat passed signals as a cancellation token which triggers an error","suites":["fromFetch"],"updatePoint":{"line":224,"column":81},"line":224,"code":"  it('should treat passed signals as a cancellation token which triggers an error', (done) => {\n    const controller = new MockAbortController();\n    const signal = controller.signal as any;\n    const fetch$ = fromFetch('/foo', { signal });\n    const subscription = fetch$.subscribe({\n      error: err => {\n        expect(err).to.be.instanceof(MockDOMException);\n        done();\n      }\n    });\n    controller.abort();\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.true;\n    // The subscription will not be closed until the error fires when the promise resolves.\n    expect(subscription.closed).to.be.false;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should treat passed already aborted signals as a cancellation token which triggers an error","suites":["fromFetch"],"updatePoint":{"line":240,"column":97},"line":240,"code":"  it('should treat passed already aborted signals as a cancellation token which triggers an error', (done) => {\n    const controller = new MockAbortController();\n    controller.abort();\n    const signal = controller.signal as any;\n    const fetch$ = fromFetch('/foo', { signal });\n    const subscription = fetch$.subscribe({\n      error: err => {\n        expect(err).to.be.instanceof(MockDOMException);\n        done();\n      }\n    });\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.true;\n    // The subscription will not be closed until the error fires when the promise resolves.\n    expect(subscription.closed).to.be.false;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should not leak listeners added to the passed in signal","suites":["fromFetch"],"updatePoint":{"line":256,"column":61},"line":256,"code":"  it('should not leak listeners added to the passed in signal', (done) => {\n    const controller = new MockAbortController();\n    const signal = controller.signal as any;\n    const fetch$ = fromFetch('/foo', { signal });\n    const subscription = fetch$.subscribe();\n    subscription.add(() => {\n      try {\n        expect(signal._listeners).to.be.empty;\n        done();\n      } catch (error) {\n        done(error);\n      }\n    });\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a selector","suites":["fromFetch"],"updatePoint":{"line":271,"column":31},"line":271,"code":"  it('should support a selector', (done) => {\n    mockFetch.respondWith = {\n      ...OK_RESPONSE,\n      text: () => Promise.resolve('bar')\n    };\n    const fetch$ = fromFetch('/foo', {\n      selector: response => response.text()\n    });\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n\n    fetch$.subscribe({\n      next: text => {\n        expect(text).to.equal('bar');\n      },\n      error: done,\n      complete: () => {\n        // Wait until the complete and the subsequent unsubscribe are finished\n        // before testing these expectations:\n        setTimeout(() => {\n          expect(MockAbortController.created).to.equal(1);\n          expect(mockFetch.calls.length).to.equal(1);\n          expect(mockFetch.calls[0].input).to.equal('/foo');\n          expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n          expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n          done();\n        }, 0);\n      }\n    });\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should abort when unsubscribed and a selector is specified","suites":["fromFetch"],"updatePoint":{"line":302,"column":64},"line":302,"code":"  it('should abort when unsubscribed and a selector is specified', () => {\n    mockFetch.respondWith = {\n      ...OK_RESPONSE,\n      text: () => Promise.resolve('bar')\n    };\n    const fetch$ = fromFetch('/foo', {\n      selector: response => response.text()\n    });\n    expect(mockFetch.calls.length).to.equal(0);\n    expect(MockAbortController.created).to.equal(0);\n    const subscription = fetch$.subscribe();\n\n    expect(MockAbortController.created).to.equal(1);\n    expect(mockFetch.calls.length).to.equal(1);\n    expect(mockFetch.calls[0].input).to.equal('/foo');\n    expect(mockFetch.calls[0].init!.signal).not.to.be.undefined;\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.false;\n\n    subscription.unsubscribe();\n    expect(mockFetch.calls[0].init!.signal!.aborted).to.be.true;\n  });","file":"observables/dom/fetch-spec.ts","skipped":false,"dir":"spec"},{"name":"should send and receive messages","suites":["webSocket","basic behavior"],"updatePoint":{"line":40,"column":40},"line":40,"code":"    it('should send and receive messages', () => {\n      let messageReceived = false;\n      const subject = webSocket<string>('ws://mysocket');\n\n      subject.next('ping');\n\n      subject.subscribe(x => {\n        expect(x).to.equal('pong');\n        messageReceived = true;\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      expect(socket.url).to.equal('ws://mysocket');\n\n      socket.open();\n      expect(socket.lastMessageSent).to.equal(JSON.stringify('ping'));\n\n      socket.triggerMessage(JSON.stringify('pong'));\n      expect(messageReceived).to.be.true;\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow use of operators and subscribe","suites":["webSocket","basic behavior"],"updatePoint":{"line":63,"column":51},"line":63,"code":"    it('should allow use of operators and subscribe', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      const results: any[] = [];\n\n      subject.pipe(\n        map(x => x + '!'),\n      )\n      .subscribe(x => results.push(x));\n\n      MockWebSocket.lastSocket.triggerMessage(JSON.stringify('ngconf 2018 bug'));\n\n      expect(results).to.deep.equal(['ngconf 2018 bug!']);\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"receive multiple messages","suites":["webSocket","basic behavior"],"updatePoint":{"line":77,"column":33},"line":77,"code":"    it('receive multiple messages', () => {\n      const expected = ['what', 'do', 'you', 'do', 'with', 'a', 'drunken', 'sailor?'];\n      const results: string[] = [];\n      const subject = webSocket<string>('ws://mysocket');\n\n      subject.subscribe(x => {\n        results.push(x);\n      });\n\n      const socket = MockWebSocket.lastSocket;\n\n      socket.open();\n\n      expected.forEach(x => {\n        socket.triggerMessage(JSON.stringify(x));\n      });\n\n      expect(results).to.deep.equal(expected);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should queue messages prior to subscription","suites":["webSocket","basic behavior"],"updatePoint":{"line":99,"column":51},"line":99,"code":"    it('should queue messages prior to subscription', () => {\n      const expected = ['make', 'him', 'walk', 'the', 'plank'];\n      const subject = webSocket<string>('ws://mysocket');\n\n      expected.forEach(x => {\n        subject.next(x);\n      });\n\n      let socket = MockWebSocket.lastSocket;\n      expect(socket).not.exist;\n\n      subject.subscribe();\n\n      socket = MockWebSocket.lastSocket;\n      expect(socket.sent.length).to.equal(0);\n\n      socket.open();\n      expect(socket.sent.length).to.equal(expected.length);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should send messages immediately if already open","suites":["webSocket","basic behavior"],"updatePoint":{"line":121,"column":56},"line":121,"code":"    it('should send messages immediately if already open', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      subject.next('avast!');\n      expect(socket.lastMessageSent).to.equal(JSON.stringify('avast!'));\n      subject.next('ye swab!');\n      expect(socket.lastMessageSent).to.equal(JSON.stringify('ye swab!'));\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket when completed","suites":["webSocket","basic behavior"],"updatePoint":{"line":135,"column":46},"line":135,"code":"    it('should close the socket when completed', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(socket.readyState).to.equal(WebSocketState.OPEN);\n\n      sinon.spy(socket, 'close');\n\n      expect(socket.close).not.have.been.called;\n\n      subject.complete();\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      socket.triggerClose({ wasClean: true });\n      expect(socket.readyState).to.equal(WebSocketState.CLOSED);\n\n      subject.unsubscribe();\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket when unsubscribed before socket open","suites":["webSocket","basic behavior"],"updatePoint":{"line":158,"column":68},"line":158,"code":"    it('should close the socket when unsubscribed before socket open', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      subject.unsubscribe();\n      const socket = MockWebSocket.lastSocket;\n      sinon.spy(socket, 'close');\n      socket.open();\n\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket when subscription is cancelled before socket open","suites":["webSocket","basic behavior"],"updatePoint":{"line":172,"column":81},"line":172,"code":"    it('should close the socket when subscription is cancelled before socket open', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      const subscription = subject.subscribe();\n      subscription.unsubscribe();\n      const socket = MockWebSocket.lastSocket;\n      sinon.spy(socket, 'close');\n      socket.open();\n\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket when unsubscribed while connecting","suites":["webSocket","basic behavior"],"updatePoint":{"line":186,"column":66},"line":186,"code":"    it('should close the socket when unsubscribed while connecting', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      sinon.spy(socket, 'close');\n      subject.unsubscribe();\n\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket when subscription is cancelled while connecting","suites":["webSocket","basic behavior"],"updatePoint":{"line":199,"column":79},"line":199,"code":"    it('should close the socket when subscription is cancelled while connecting', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      const subscription = subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      sinon.spy(socket, 'close');\n      subscription.unsubscribe();\n\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close a socket that opens before the previous socket has closed","suites":["webSocket","basic behavior"],"updatePoint":{"line":212,"column":78},"line":212,"code":"    it('should close a socket that opens before the previous socket has closed', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      const subscription = subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      sinon.spy(socket, 'close');\n      subscription.unsubscribe();\n\n      expect(socket.close).have.been.called;\n      expect(socket.readyState).to.equal(WebSocketState.CLOSING);\n\n      const subscription2 = subject.subscribe();\n      const socket2 = MockWebSocket.lastSocket;\n      sinon.spy(socket2, 'close');\n\n      // Close socket after socket2 has opened\n      socket2.open();\n      expect(socket2.readyState).to.equal(WebSocketState.OPEN);\n      socket.triggerClose({wasClean: true});\n\n      expect(socket.readyState).to.equal(WebSocketState.CLOSED);\n      expect(socket2.close).have.not.been.called;\n\n      subscription2.unsubscribe();\n      expect(socket2.close).have.been.called;\n      expect(socket2.readyState).to.equal(WebSocketState.CLOSING);\n\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should close the socket with a code and a reason when errored","suites":["webSocket","basic behavior"],"updatePoint":{"line":241,"column":69},"line":241,"code":"    it('should close the socket with a code and a reason when errored', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      sinon.spy(socket, 'close');\n      expect(socket.close).not.have.been.called;\n\n      subject.error({ code: 1337, reason: 'Too bad, so sad :('});\n      expect(socket.close).have.been.calledWith(1337, 'Too bad, so sad :(');\n\n      subject.unsubscribe();\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow resubscription after closure via complete","suites":["webSocket","basic behavior"],"updatePoint":{"line":257,"column":62},"line":257,"code":"    it('should allow resubscription after closure via complete', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket1 = MockWebSocket.lastSocket;\n      socket1.open();\n      subject.complete();\n\n      subject.next('a mariner yer not. yarrr.');\n      subject.subscribe();\n      const socket2 = MockWebSocket.lastSocket;\n      socket2.open();\n\n      expect(socket2).not.to.equal(socket1);\n      expect(socket2.lastMessageSent).to.equal(JSON.stringify('a mariner yer not. yarrr.'));\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow resubscription after closure via error","suites":["webSocket","basic behavior"],"updatePoint":{"line":275,"column":59},"line":275,"code":"    it('should allow resubscription after closure via error', () => {\n      const subject = webSocket<string>('ws://mysocket');\n      subject.subscribe();\n      const socket1 = MockWebSocket.lastSocket;\n      socket1.open();\n      subject.error({ code: 1337 });\n\n      subject.next('yo-ho! yo-ho!');\n      subject.subscribe();\n      const socket2 = MockWebSocket.lastSocket;\n      socket2.open();\n\n      expect(socket2).not.to.equal(socket1);\n      expect(socket2.lastMessageSent).to.equal(JSON.stringify('yo-ho! yo-ho!'));\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should have a default resultSelector that parses message data as JSON","suites":["webSocket","basic behavior"],"updatePoint":{"line":293,"column":77},"line":293,"code":"    it('should have a default resultSelector that parses message data as JSON', () => {\n      let result;\n      const expected = { mork: 'shazbot!' };\n      const subject = webSocket<string>('ws://mysocket');\n\n      subject.subscribe((x: any) => {\n        result = x;\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n      socket.triggerMessage(JSON.stringify(expected));\n\n      expect(result).to.deep.equal(expected);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should send and receive messages","suites":["webSocket","with a config object"],"updatePoint":{"line":322,"column":40},"line":322,"code":"    it('should send and receive messages', () => {\n      let messageReceived = false;\n      const subject = webSocket<string>({ url: 'ws://mysocket' });\n\n      subject.next('ping');\n\n      subject.subscribe(x => {\n        expect(x).to.equal('pong');\n        messageReceived = true;\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      expect(socket.url).to.equal('ws://mysocket');\n\n      socket.open();\n      expect(socket.lastMessageSent).to.equal(JSON.stringify('ping'));\n\n      socket.triggerMessage(JSON.stringify('pong'));\n      expect(messageReceived).to.be.true;\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a protocol and set it properly on the web socket","suites":["webSocket","with a config object"],"updatePoint":{"line":345,"column":68},"line":345,"code":"    it('should take a protocol and set it properly on the web socket', () => {\n      const subject = webSocket<string>({\n        url: 'ws://mysocket',\n        protocol: 'someprotocol'\n      });\n\n      subject.subscribe();\n\n      const socket = MockWebSocket.lastSocket;\n      expect(socket.protocol).to.equal('someprotocol');\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a binaryType and set it properly on the web socket","suites":["webSocket","with a config object"],"updatePoint":{"line":359,"column":70},"line":359,"code":"    it('should take a binaryType and set it properly on the web socket', () => {\n      const subject = webSocket<string>({\n        url: 'ws://mysocket',\n        binaryType: 'blob'\n      });\n\n      subject.subscribe();\n\n      const socket = MockWebSocket.lastSocket;\n      expect(socket.binaryType).to.equal('blob');\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a deserializer","suites":["webSocket","with a config object"],"updatePoint":{"line":373,"column":34},"line":373,"code":"    it('should take a deserializer', () => {\n      const results = [] as string[];\n\n      const subject = webSocket<string>({\n        url: 'ws://mysocket',\n        deserializer: (e: any) => {\n          return e.data + '!';\n        }\n      });\n\n      subject.subscribe((x: any) => {\n        results.push(x);\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n      ['ahoy', 'yarr', 'shove off'].forEach((x: any) => {\n        socket.triggerMessage(x);\n      });\n\n      expect(results).to.deep.equal(['ahoy!', 'yarr!', 'shove off!']);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"if the deserializer fails it should go down the error path","suites":["webSocket","with a config object"],"updatePoint":{"line":398,"column":66},"line":398,"code":"    it('if the deserializer fails it should go down the error path', () => {\n      const subject = webSocket<string>({\n        url: 'ws://mysocket',\n        deserializer: (e: any) => {\n          throw new Error('I am a bad error');\n        }\n      });\n\n      subject.subscribe({ next: (x: any) => {\n        expect(x).to.equal('this should not happen');\n      }, error: (err: any) => {\n        expect(err).to.be.an('error', 'I am a bad error');\n      } });\n\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n      socket.triggerMessage('weee!');\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a closingObserver","suites":["webSocket","with a config object"],"updatePoint":{"line":419,"column":39},"line":419,"code":"    it('should accept a closingObserver', () => {\n      let calls = 0;\n      const subject = webSocket<string>(<any>{\n        url: 'ws://mysocket',\n        closingObserver: {\n          next(x: any) {\n            calls++;\n            expect(x).to.be.an('undefined');\n          }\n        }\n      });\n\n      subject.subscribe();\n      let socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(calls).to.equal(0);\n\n      subject.complete();\n      expect(calls).to.equal(1);\n\n      subject.subscribe();\n      socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      subject.error({ code: 1337 });\n      expect(calls).to.equal(2);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a closeObserver","suites":["webSocket","with a config object"],"updatePoint":{"line":450,"column":37},"line":450,"code":"    it('should accept a closeObserver', () => {\n      const expected = [{ wasClean: true }, { wasClean: false }];\n      const closes = [] as any[];\n      const subject = webSocket<string>(<any>{\n        url: 'ws://mysocket',\n        closeObserver: {\n          next(e: any) {\n            closes.push(e);\n          }\n        }\n      });\n\n      subject.subscribe();\n      let socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(closes.length).to.equal(0);\n\n      socket.triggerClose(expected[0]);\n      expect(closes.length).to.equal(1);\n\n      subject.subscribe({ error: function (err) {\n        expect(err).to.equal(expected[1]);\n      } });\n\n      socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      socket.triggerClose(expected[1]);\n      expect(closes.length).to.equal(2);\n\n      expect(closes[0]).to.equal(expected[0]);\n      expect(closes[1]).to.equal(expected[1]);\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle constructor errors","suites":["webSocket","with a config object"],"updatePoint":{"line":487,"column":40},"line":487,"code":"    it('should handle constructor errors', () => {\n      const subject = webSocket<string>(<any>{\n        url: 'bad_url',\n        WebSocketCtor: (url: string, protocol?: string | string[]): WebSocket => {\n          throw new Error(`connection refused`);\n        }\n      });\n\n      subject.subscribe({ next: (x: any) => {\n        expect(x).to.equal('this should not happen');\n      }, error: (err: any) => {\n        expect(err).to.be.an('error', 'connection refused');\n      } });\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable","suites":["webSocket","multiplex"],"updatePoint":{"line":515,"column":27},"line":515,"code":"    it('should be retryable', () => {\n      const results = [] as string[];\n      const subject = webSocket<{ name: string, value: string }>('ws://websocket');\n      const source = subject.multiplex(\n        () => ({ sub: 'foo' }),\n        () => ({ unsub: 'foo' }),\n        value => value.name === 'foo'\n      );\n\n      source.pipe(\n        retry(1),\n        map(x => x.value),\n        take(2),\n      ).subscribe(x => {\n        results.push(x);\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(socket.lastMessageSent).to.deep.equal(JSON.stringify({ sub: 'foo' }));\n      socket.triggerClose({ wasClean: false }); // Bad connection\n\n      const socket2 = MockWebSocket.lastSocket;\n      expect(socket2).not.to.equal(socket);\n\n      socket2.open();\n      expect(socket2.lastMessageSent).to.deep.equal(JSON.stringify({ sub: 'foo' }));\n\n      socket2.triggerMessage(JSON.stringify({ name: 'foo', value: 'test' }));\n      socket2.triggerMessage(JSON.stringify({ name: 'foo', value: 'this' }));\n\n      expect(results).to.deep.equal(['test', 'this']);\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable","suites":["webSocket","multiplex"],"updatePoint":{"line":550,"column":28},"line":550,"code":"    it('should be repeatable', () => {\n      const results = [] as string[];\n      const subject = webSocket<{ name: string, value: string }>('ws://websocket');\n      const source = subject.multiplex(\n        () => ({ sub: 'foo' }),\n        () => ({ unsub: 'foo' }),\n        value => value.name === 'foo'\n      );\n\n      source\n        .pipe(\n          repeat(2),\n          map(x => x.value)\n        )\n        .subscribe(x => {\n          results.push(x);\n        });\n\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(socket.lastMessageSent).to.deep.equal(JSON.stringify({ sub: 'foo' }), 'first multiplexed sub');\n      socket.triggerMessage(JSON.stringify({ name: 'foo', value: 'test' }));\n      socket.triggerMessage(JSON.stringify({ name: 'foo', value: 'this' }));\n      socket.triggerClose({ wasClean: true });\n\n      const socket2 = MockWebSocket.lastSocket;\n      expect(socket2).not.to.equal(socket, 'a new socket was not created');\n\n      socket2.open();\n      expect(socket2.lastMessageSent).to.deep.equal(JSON.stringify({ sub: 'foo' }), 'second multiplexed sub');\n      socket2.triggerMessage(JSON.stringify({ name: 'foo', value: 'test' }));\n      socket2.triggerMessage(JSON.stringify({ name: 'foo', value: 'this' }));\n      socket2.triggerClose({ wasClean: true });\n\n      expect(results).to.deep.equal(['test', 'this', 'test', 'this'], 'results were not equal');\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should multiplex over the webSocket","suites":["webSocket","multiplex"],"updatePoint":{"line":588,"column":43},"line":588,"code":"    it('should multiplex over the webSocket', () => {\n      const results = [] as Array<{ value: number, name: string }>;\n      const subject = webSocket<{ value: number, name: string }>('ws://websocket');\n      const source = subject.multiplex(\n        () => ({ sub: 'foo'}),\n        () => ({ unsub: 'foo' }),\n        value => value.name === 'foo'\n      );\n\n      const sub = source.subscribe(function (x: any) {\n        results.push(x.value);\n      });\n      const socket = MockWebSocket.lastSocket;\n      socket.open();\n\n      expect(socket.lastMessageSent).to.deep.equal(JSON.stringify({ sub: 'foo' }));\n\n      [1, 2, 3, 4, 5].map((x: number) => {\n        return {\n          name: x % 3 === 0 ? 'bar' : 'foo',\n          value: x\n        };\n      }).forEach((x: any) => {\n        socket.triggerMessage(JSON.stringify(x));\n      });\n\n      expect(results).to.deep.equal([1, 2, 4, 5]);\n\n      sinon.spy(socket, 'close');\n      sub.unsubscribe();\n      expect(socket.lastMessageSent).to.deep.equal(JSON.stringify({ unsub: 'foo' }));\n\n      expect(socket.close).have.been.called;\n      (<any>socket.close).restore();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should keep the same socket for multiple multiplex subscriptions","suites":["webSocket","multiplex"],"updatePoint":{"line":624,"column":72},"line":624,"code":"    it('should keep the same socket for multiple multiplex subscriptions', () => {\n      const socketSubject = webSocket<string>({url: 'ws://mysocket'});\n      const results = [] as string[];\n      const socketMessages = [\n        {id: 'A'},\n        {id: 'B'},\n        {id: 'A'},\n        {id: 'B'},\n        {id: 'B'},\n      ];\n\n      const sub1 = socketSubject.multiplex(\n        () => 'no-op',\n        () => results.push('A unsub'),\n        (req: any) => req.id === 'A'\n      ).pipe(\n        takeWhile((req: any) => !req.complete)\n      )\n      .subscribe(\n        { next: () => results.push('A next'), error: (e) => results.push('A error ' + e), complete: () => results.push('A complete') }\n      );\n\n      socketSubject.multiplex(\n        () => 'no-op',\n        () => results.push('B unsub'),\n        (req: any) => req.id === 'B')\n        .subscribe(\n          { next: () => results.push('B next'), error: (e) => results.push('B error ' + e), complete: () => results.push('B complete') }\n        );\n\n      // Setup socket and send messages\n      let socket = MockWebSocket.lastSocket;\n      socket.open();\n      socketMessages.forEach((msg, i) => {\n        if (i === 1) {\n          sub1.unsubscribe();\n          expect((socketSubject as any)._socket).to.equal(socket);\n        }\n        socket.triggerMessage(JSON.stringify(msg));\n      });\n      socket.triggerClose({ wasClean: true });\n\n      expect(results).to.deep.equal([\n        'A next',\n        'A unsub',\n        'B next',\n        'B next',\n        'B next',\n        'B complete',\n        'B unsub',\n      ]);\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should not close the socket until all subscriptions complete","suites":["webSocket","multiplex"],"updatePoint":{"line":677,"column":68},"line":677,"code":"    it('should not close the socket until all subscriptions complete', () => {\n      const socketSubject = webSocket<{ id: string, complete: boolean }>({url: 'ws://mysocket'});\n      const results = [] as string[];\n      const socketMessages = [\n        {id: 'A'},\n        {id: 'B'},\n        {id: 'A', complete: true},\n        {id: 'B'},\n        {id: 'B', complete: true},\n      ];\n\n      socketSubject.multiplex(\n        () => 'no-op',\n        () => results.push('A unsub'),\n        req => req.id === 'A'\n      ).pipe(\n        takeWhile(req => !req.complete)\n      ).subscribe(\n        { next: () => results.push('A next'), error: (e) => results.push('A error ' + e), complete: () => results.push('A complete') }\n      );\n\n      socketSubject.multiplex(\n        () => 'no-op',\n        () => results.push('B unsub'),\n        req => req.id === 'B'\n      ).pipe(\n        takeWhile(req => !req.complete)\n      ).subscribe(\n        { next: () => results.push('B next'), error: (e) => results.push('B error ' + e), complete: () => results.push('B complete') }\n      );\n\n      // Setup socket and send messages\n      let socket = MockWebSocket.lastSocket;\n      socket.open();\n      socketMessages.forEach((msg) => {\n        socket.triggerMessage(JSON.stringify(msg));\n      });\n\n      expect(results).to.deep.equal([\n        'A next',\n        'B next',\n        'A complete',\n        'A unsub',\n        'B next',\n        'B complete',\n        'B unsub',\n      ]);\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should send and receive messages","suites":["webSocket","node constructor"],"updatePoint":{"line":728,"column":40},"line":728,"code":"    it('should send and receive messages', () => {\n      let messageReceived = false;\n      const subject = webSocket<string>(<any>{\n        url: 'ws://mysocket',\n        WebSocketCtor: MockWebSocket\n      });\n\n      subject.next('ping');\n\n      subject.subscribe(x => {\n        expect(x).to.equal('pong');\n        messageReceived = true;\n      });\n\n      const socket = MockWebSocket.lastSocket;\n      expect(socket.url).to.equal('ws://mysocket');\n\n      socket.open();\n      expect(socket.lastMessageSent).to.equal(JSON.stringify('ping'));\n\n      socket.triggerMessage(JSON.stringify('pong'));\n      expect(messageReceived).to.be.true;\n\n      subject.unsubscribe();\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle constructor errors if no WebSocketCtor","suites":["webSocket","node constructor"],"updatePoint":{"line":754,"column":60},"line":754,"code":"    it('should handle constructor errors if no WebSocketCtor', () => {\n\n      expect(() => {\n        const subject = webSocket<string>(<any>{\n          url: 'ws://mysocket'\n        });\n      }).to.throw('no WebSocket constructor can be found');\n\n    });","file":"observables/dom/webSocket-spec.ts","skipped":false,"dir":"spec"},{"name":"should return EMPTY","suites":["empty"],"updatePoint":{"line":15,"column":25},"line":15,"code":"  it('should return EMPTY', () => {\n    expect(empty()).to.equal(EMPTY);\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable with only complete","suites":["empty"],"updatePoint":{"line":19,"column":56},"line":19,"code":"  it('should create a cold observable with only complete', () => {\n    rxTestScheduler.run(({ expectObservable }) => {\n      const expected = '|';\n      const e1 = empty();\n      expectObservable(e1).toBe(expected);\n    });\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the same instance EMPTY","suites":["empty"],"updatePoint":{"line":27,"column":43},"line":27,"code":"  it('should return the same instance EMPTY', () => {\n    const s1 = empty();\n    const s2 = empty();\n    expect(s1).to.equal(s2);\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should be synchronous by default","suites":["empty"],"updatePoint":{"line":33,"column":38},"line":33,"code":"  it('should be synchronous by default', () => {\n    const source = empty();\n    let hit = false;\n    source.subscribe({\n      complete() {\n        hit = true;\n      },\n    });\n    expect(hit).to.be.true;\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should equal EMPTY","suites":["empty"],"updatePoint":{"line":44,"column":24},"line":44,"code":"  it('should equal EMPTY', () => {\n    expect(empty()).to.equal(EMPTY);\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a scheduler","suites":["empty"],"updatePoint":{"line":48,"column":29},"line":48,"code":"  it('should take a scheduler', () => {\n    const source = empty(rxTestScheduler);\n    let hit = false;\n    source.subscribe({\n      complete() {\n        hit = true;\n      },\n    });\n    expect(hit).to.be.false;\n    rxTestScheduler.flush();\n    expect(hit).to.be.true;\n  });","file":"observables/empty-spec.ts","skipped":false,"dir":"spec"},{"name":"should join the last values of the provided observables into an array","suites":["forkJoin"],"updatePoint":{"line":16,"column":75},"line":16,"code":"  it('should join the last values of the provided observables into an array', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable }) => {\n      const s1 = hot('  -a--b-----c-d-e-|');\n      const s2 = hot('  --------f--g-h-i--j-|');\n      const s3 = cold(' --1--2-3-4---|');\n      const e1 = forkJoin([s1, s2, s3]);\n      const expected = '--------------------(x|)';\n\n      expectObservable(e1).toBe(expected, { x: ['e', 'j', '4'] });\n    });\n  });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a resultSelector with an Array of ObservableInputs","suites":["forkJoin"],"updatePoint":{"line":28,"column":71},"line":28,"code":"  it('should support a resultSelector with an Array of ObservableInputs', () => {\n    const results: Array<number | string> = [];\n    forkJoin([of(1, 2, 3), of(4, 5, 6), of(7, 8, 9)], (a: number, b: number, c: number) => a + b + c).subscribe({\n      next(value) {\n        results.push(value);\n      },\n      error(err) {\n        throw err;\n      },\n      complete() {\n        results.push('done');\n      },\n    });\n\n    expect(results).to.deep.equal([18, 'done']);\n  });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a resultSelector with a spread of ObservableInputs","suites":["forkJoin"],"updatePoint":{"line":45,"column":71},"line":45,"code":"  it('should support a resultSelector with a spread of ObservableInputs', () => {\n    const results: Array<number | string> = [];\n    forkJoin(of(1, 2, 3), of(4, 5, 6), of(7, 8, 9), (a: number, b: number, c: number) => a + b + c).subscribe({\n      next(value) {\n        results.push(value);\n      },\n      error(err) {\n        throw err;\n      },\n      complete() {\n        results.push('done');\n      },\n    });\n\n    expect(results).to.deep.equal([18, 'done']);\n  });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept single observable","suites":["forkJoin"],"updatePoint":{"line":62,"column":37},"line":62,"code":"  it('should accept single observable', () => {\n    rxTestScheduler.run(({ hot, expectObservable }) => {\n      const e1 = forkJoin(hot('--a--b--c--d--|'));\n      const expected = '       --------------(x|)';\n\n      expectObservable(e1).toBe(expected, { x: ['d'] });\n    });\n  });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should join the last values of the provided observables into an array","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":72,"column":77},"line":72,"code":"    it('should join the last values of the provided observables into an array', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = hot('  --1--2--3--|');\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: ['d', 'b', '3'] });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow emit null or undefined","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":84,"column":43},"line":84,"code":"    it('should allow emit null or undefined', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e2 = forkJoin([\n          hot('            --a--b--c--d--|', { d: null }),\n          hot('            (b|)'),\n          hot('            --1--2--3--|'),\n          hot('            -----r--t--u--|', { u: undefined }),\n        ]);\n        const expected2 = '--------------(x|)';\n\n        expectObservable(e2).toBe(expected2, { x: [null, 'b', '3', undefined] });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observable contains single","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":98,"column":57},"line":98,"code":"    it('should accept array of observable contains single', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const e1 = forkJoin([s1]);\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: ['d'] });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept lowercase-o observables","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":108,"column":45},"line":108,"code":"    it('should accept lowercase-o observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = lowerCaseO('1', '2', '3');\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: ['d', 'b', '3'] });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept empty lowercase-o observables","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":120,"column":51},"line":120,"code":"    it('should accept empty lowercase-o observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = lowerCaseO();\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept promise","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":132,"column":29},"line":132,"code":"    it('should accept promise', (done) => {\n      rxTestScheduler.run(() => {\n        const e1 = forkJoin([of(1), Promise.resolve(2)]);\n\n        e1.subscribe({\n          next: (x) => expect(x).to.deep.equal([1, 2]),\n          complete: done,\n        });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observables","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":143,"column":42},"line":143,"code":"    it('should accept array of observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = hot('  --1--2--3--|');\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: ['d', 'b', '3'] });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit if any of source observable is empty","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":155,"column":60},"line":155,"code":"    it('should not emit if any of source observable is empty', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = hot('  ------------------|');\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '------------------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete early if any of source is empty and completes before than others","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":167,"column":88},"line":167,"code":"    it('should complete early if any of source is empty and completes before than others', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --a--b--c--d--|');\n        const s2 = hot('  (b|)');\n        const s3 = hot('  ---------|');\n        const e1 = forkJoin([s1, s2, s3]);\n        const expected = '---------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when all sources are empty","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":179,"column":50},"line":179,"code":"    it('should complete when all sources are empty', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --------------|');\n        const s2 = hot('  ---------|');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '---------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when only source never completes","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":190,"column":60},"line":190,"code":"    it('should not complete when only source never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin([hot('--------------')]);\n        const expected = '        --------------';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when one of the sources never completes","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":199,"column":67},"line":199,"code":"    it('should not complete when one of the sources never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('--------------');\n        const s2 = hot('-a---b--c--|');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '-';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when one of the sources never completes but other completes without values","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":210,"column":98},"line":210,"code":"    it('should complete when one of the sources never completes but other completes without values', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  --------------');\n        const s2 = hot('  ------|');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source is not provided","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":221,"column":49},"line":221,"code":"    it('should complete if source is not provided', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const e1 = forkJoin();\n        const expected = '|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if sources list is empty","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":230,"column":48},"line":230,"code":"    it('should complete if sources list is empty', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const e1 = forkJoin([]);\n        const expected = '|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when any of source raises error with empty observable","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":239,"column":80},"line":239,"code":"    it('should raise error when any of source raises error with empty observable', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  ------#');\n        const s2 = hot('  ---------|');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when any of source raises error with source that never completes","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":250,"column":91},"line":250,"code":"    it('should raise error when any of source raises error with source that never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  ------#');\n        const s2 = hot('  ----------');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":261,"column":51},"line":261,"code":"    it('should raise error when source raises error', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const s1 = hot('  ------#');\n        const s2 = hot('  ---a-----|');\n        const e1 = forkJoin([s1, s2]);\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":272,"column":55},"line":272,"code":"    it('should allow unsubscribing early and explicitly', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('--a--^--b--c---d-| ');\n        const e1subs = '     ^--------!    ';\n        const e2 = hot('---e-^---f--g---h-|');\n        const e2subs = '     ^--------!    ';\n        const expected = '   ----------    ';\n        const unsub = '      ---------!    ';\n\n        const result = forkJoin([e1, e2]);\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe other Observables, when one of them errors","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":289,"column":69},"line":289,"code":"    it('should unsubscribe other Observables, when one of them errors', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('--a--^--b--c---d-| ');\n        const e1subs = '     ^--------!    ';\n        const e2 = hot('---e-^---f--g-#');\n        const e2subs = '     ^--------!    ';\n        const expected = '   ---------#    ';\n\n        const result = forkJoin([e1, e2]);\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize in the proper order","suites":["forkJoin","forkJoin([input1, input2, input3])"],"updatePoint":{"line":306,"column":41},"line":306,"code":"  it('should finalize in the proper order', () => {\n    const results: any[] = [];\n    const source = forkJoin(\n      [1, 2, 3, 4].map((n) =>\n        timer(100, rxTestScheduler).pipe(\n          map(() => n),\n          finalize(() => results.push(`finalized ${n}`))\n        )\n      )\n    );\n\n    source.subscribe((value) => results.push(value));\n    rxTestScheduler.flush();\n    expect(results).to.deep.equal(['finalized 1', 'finalized 2', 'finalized 3', 'finalized 4', [1, 2, 3, 4]]);\n  });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should join the last values of the provided observables into an array","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":323,"column":77},"line":323,"code":"    it('should join the last values of the provided observables into an array', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: hot('      --1--2--3--|'),\n        });\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: { foo: 'd', bar: 'b', baz: '3' } });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow emit null or undefined","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":336,"column":43},"line":336,"code":"    it('should allow emit null or undefined', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e2 = forkJoin({\n          foo: hot('       --a--b--c--d--|', { d: null }),\n          bar: hot('       (b|)'),\n          baz: hot('       --1--2--3--|'),\n          qux: hot('       -----r--t--u--|', { u: undefined }),\n        });\n        const expected2 = '--------------(x|)';\n\n        expectObservable(e2).toBe(expected2, { x: { foo: null, bar: 'b', baz: '3', qux: undefined } });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observable contains single","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":350,"column":57},"line":350,"code":"    it('should accept array of observable contains single', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n        });\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: { foo: 'd' } });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept lowercase-o observables","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":361,"column":45},"line":361,"code":"    it('should accept lowercase-o observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: lowerCaseO('1', '2', '3'),\n        });\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: { foo: 'd', bar: 'b', baz: '3' } });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept empty lowercase-o observables","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":374,"column":51},"line":374,"code":"    it('should accept empty lowercase-o observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: lowerCaseO(),\n        });\n        const expected = '|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept promise","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":387,"column":29},"line":387,"code":"    it('should accept promise', (done) => {\n      const e1 = forkJoin({\n        foo: of(1),\n        bar: Promise.resolve(2),\n      });\n\n      e1.subscribe({\n        next: (x) => expect(x).to.deep.equal({ foo: 1, bar: 2 }),\n        complete: done,\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept an object of observables","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":399,"column":46},"line":399,"code":"    it('should accept an object of observables', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: hot('      --1--2--3--|'),\n        });\n        const expected = '--------------(x|)';\n\n        expectObservable(e1).toBe(expected, { x: { foo: 'd', bar: 'b', baz: '3' } });\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit if any of source observable is empty","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":412,"column":60},"line":412,"code":"    it('should not emit if any of source observable is empty', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: hot('      ------------------|'),\n        });\n        const expected = '------------------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete early if any of source is empty and completes before than others","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":426,"column":88},"line":426,"code":"    it('should complete early if any of source is empty and completes before than others', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --a--b--c--d--|'),\n          bar: hot('      (b|)'),\n          baz: hot('      ---------|'),\n        });\n        const expected = '---------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when all sources are empty","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":439,"column":50},"line":439,"code":"    it('should complete when all sources are empty', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --------------|'),\n          bar: hot('      ---------|'),\n        });\n        const expected = '---------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when only source never completes","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":451,"column":60},"line":451,"code":"    it('should not complete when only source never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --------------'),\n        });\n        const expected = '--------------';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when one of the sources never completes","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":462,"column":67},"line":462,"code":"    it('should not complete when one of the sources never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --------------'),\n          bar: hot('      -a---b--c--|'),\n        });\n        const expected = '--------------';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when one of the sources never completes but other completes without values","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":474,"column":98},"line":474,"code":"    it('should complete when one of the sources never completes but other completes without values', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          foo: hot('      --------------'),\n          bar: hot('      ------|'),\n        });\n        const expected = '------|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should have same v5/v6 throwing behavior full argument of null","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":487,"column":70},"line":487,"code":"    it('should have same v5/v6 throwing behavior full argument of null', (done) => {\n      rxTestScheduler.run(() => {\n        // It doesn't throw when you pass null\n        expect(() => forkJoin(null as any)).not.to.throw();\n\n        // It doesn't even throw if you subscribe to forkJoin(null).\n        expect(() =>\n          forkJoin(null as any).subscribe({\n            // It sends the error to the subscription.\n            error: () => done(),\n          })\n        ).not.to.throw();\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if sources object is empty","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":502,"column":50},"line":502,"code":"    it('should complete if sources object is empty', () => {\n      rxTestScheduler.run(({ expectObservable }) => {\n        const e1 = forkJoin({});\n        const expected = '|';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when any of source raises error with empty observable","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":511,"column":80},"line":511,"code":"    it('should raise error when any of source raises error with empty observable', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          lol: hot('      ------#'),\n          wut: hot('      ---------|'),\n        });\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when any of source raises error with source that never completes","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":523,"column":91},"line":523,"code":"    it('should raise error when any of source raises error with source that never completes', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          lol: hot('      ------#'),\n          wut: hot('      ----------'),\n        });\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":535,"column":51},"line":535,"code":"    it('should raise error when source raises error', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const e1 = forkJoin({\n          lol: hot('      ------#'),\n          foo: hot('      ---a-----|'),\n        });\n        const expected = '------#';\n\n        expectObservable(e1).toBe(expected);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":547,"column":55},"line":547,"code":"    it('should allow unsubscribing early and explicitly', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('--a--^--b--c---d-| ');\n        const e1subs = '     ^--------!    ';\n        const e2 = hot('---e-^---f--g---h-|');\n        const e2subs = '     ^--------!    ';\n        const expected = '   ----------    ';\n        const unsub = '      ---------!    ';\n\n        const result = forkJoin({\n          e1,\n          e2,\n        });\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe other Observables, when one of them errors","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":567,"column":69},"line":567,"code":"    it('should unsubscribe other Observables, when one of them errors', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  --a--^--b--c---d-| ');\n        const e1subs = '       ^--------!    ';\n        const e2 = hot('  ---e-^---f--g-#');\n        const e2subs = '       ^--------!    ';\n        const expected = '     ---------#    ';\n\n        const result = forkJoin({\n          e1,\n          e2,\n        });\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept promise as the first arg","suites":["forkJoin","forkJoin({ foo, bar, baz })"],"updatePoint":{"line":586,"column":46},"line":586,"code":"    it('should accept promise as the first arg', (done) => {\n      const e1 = forkJoin(Promise.resolve(1));\n      const values: number[][] = [];\n\n      e1.subscribe({\n        next: (x) => values.push(x),\n        complete: () => {\n          expect(values).to.deep.equal([[1]]);\n          done();\n        },\n      });\n    });","file":"observables/forkJoin-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value from a resolved promise","suites":["from (fromPromise)"],"updatePoint":{"line":9,"column":51},"line":9,"code":"  it('should emit one value from a resolved promise', (done) => {\n    const promise = Promise.resolve(42);\n    from(promise)\n      .subscribe(\n        { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n          done(new Error('should not be called'));\n        }, complete: () => {\n          done();\n        } });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from a rejected promise","suites":["from (fromPromise)"],"updatePoint":{"line":20,"column":48},"line":20,"code":"  it('should raise error from a rejected promise', (done) => {\n    const promise = Promise.reject('bad');\n    from(promise)\n      .subscribe({ next: (x) => {\n          done(new Error('should not be called'));\n        }, error: (e) => {\n          expect(e).to.equal('bad');\n          done();\n        }, complete: () => {\n         done(new Error('should not be called'));\n       } });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should share the underlying promise with multiple subscribers","suites":["from (fromPromise)"],"updatePoint":{"line":33,"column":67},"line":33,"code":"  it('should share the underlying promise with multiple subscribers', (done) => {\n    const promise = Promise.resolve(42);\n    const observable = from(promise);\n\n    observable\n      .subscribe(\n        { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n          done(new Error('should not be called'));\n        } });\n    setTimeout(() => {\n      observable\n        .subscribe(\n          { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n            done(new Error('should not be called'));\n          }, complete: () => {\n            done();\n          } });\n    });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept already-resolved Promise","suites":["from (fromPromise)"],"updatePoint":{"line":53,"column":44},"line":53,"code":"  it('should accept already-resolved Promise', (done) => {\n    const promise = Promise.resolve(42);\n    promise.then((x) => {\n      expect(x).to.equal(42);\n      from(promise)\n        .subscribe(\n          { next: (y) => { expect(y).to.equal(42); }, error: (x) => {\n            done(new Error('should not be called'));\n          }, complete: () => {\n            done();\n          } });\n    }, () => {\n      done(new Error('should not be called'));\n    });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept PromiseLike object for interoperability","suites":["from (fromPromise)"],"updatePoint":{"line":69,"column":59},"line":69,"code":"  it('should accept PromiseLike object for interoperability', (done) => {\n    class CustomPromise<T> implements PromiseLike<T> {\n      constructor(private promise: PromiseLike<T>) {\n      }\n      then<TResult1 = T, TResult2 = T>(\n        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): PromiseLike<TResult1 | TResult2> {\n        return new CustomPromise(this.promise.then(onFulfilled, onRejected));\n      }\n    }\n    const promise = new CustomPromise(Promise.resolve(42));\n    from(promise)\n      .subscribe(\n        { next: (x) => { expect(x).to.equal(42); }, error: () => {\n          done(new Error('should not be called'));\n        }, complete: () => {\n          done();\n        } });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit a value from a resolved promise on a separate scheduler","suites":["from (fromPromise)"],"updatePoint":{"line":89,"column":73},"line":89,"code":"  it('should emit a value from a resolved promise on a separate scheduler', (done) => {\n    const promise = Promise.resolve(42);\n    from(promise, asapScheduler)\n      .subscribe(\n        { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n          done(new Error('should not be called'));\n        }, complete: () => {\n          done();\n        } });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from a rejected promise on a separate scheduler","suites":["from (fromPromise)"],"updatePoint":{"line":100,"column":72},"line":100,"code":"  it('should raise error from a rejected promise on a separate scheduler', (done) => {\n    const promise = Promise.reject('bad');\n    from(promise, asapScheduler)\n      .subscribe(\n        { next: (x) => { done(new Error('should not be called')); }, error: (e) => {\n          expect(e).to.equal('bad');\n          done();\n        }, complete: () => {\n          done(new Error('should not be called'));\n        } });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should share the underlying promise with multiple subscribers on a separate scheduler","suites":["from (fromPromise)"],"updatePoint":{"line":112,"column":91},"line":112,"code":"  it('should share the underlying promise with multiple subscribers on a separate scheduler', (done) => {\n    const promise = Promise.resolve(42);\n    const observable = from(promise, asapScheduler);\n\n    observable\n      .subscribe(\n        { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n          done(new Error('should not be called'));\n        } });\n    setTimeout(() => {\n      observable\n        .subscribe(\n          { next: (x) => { expect(x).to.equal(42); }, error: (x) => {\n            done(new Error('should not be called'));\n          }, complete: () => {\n            done();\n          } });\n    });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit, throw or complete if immediately unsubscribed","suites":["from (fromPromise)"],"updatePoint":{"line":132,"column":68},"line":132,"code":"  it('should not emit, throw or complete if immediately unsubscribed', (done) => {\n    const nextSpy = sinon.spy();\n    const throwSpy = sinon.spy();\n    const completeSpy = sinon.spy();\n    const promise = Promise.resolve(42);\n    const subscription = from(promise)\n      .subscribe({ next: nextSpy, error: throwSpy, complete: completeSpy });\n    subscription.unsubscribe();\n\n    setTimeout(() => {\n      expect(nextSpy).not.have.been.called;\n      expect(throwSpy).not.have.been.called;\n      expect(completeSpy).not.have.been.called;\n      done();\n    });\n  });","file":"observables/from-promise-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from an array","suites":["from"],"updatePoint":{"line":18,"column":47},"line":18,"code":"  it('should create an observable from an array', () => {\n    const e1 = from([10, 20, 30]).pipe(\n      // for the purpose of making a nice diagram, spread out the synchronous emissions\n      concatMap((x, i) => of(x).pipe(\n        delay(i === 0 ? 0 : 20, rxTestScheduler))\n      )\n    );\n    const expected = 'x-y-(z|)';\n    expectObservable(e1).toBe(expected, {x: 10, y: 20, z: 30});\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw for non observable object","suites":["from"],"updatePoint":{"line":29,"column":44},"line":29,"code":"  it('should throw for non observable object', () => {\n    const r = () => {\n      // tslint:disable-next-line:no-any needed for the test\n      from({} as any).subscribe();\n    };\n\n    expect(r).to.throw();\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize an AsyncGenerator","suites":["from"],"updatePoint":{"line":38,"column":39},"line":38,"code":"  it('should finalize an AsyncGenerator', (done) => {\n    const results: any[] = [];\n    const sideEffects: any[] = [];\n\n    async function* gen() {\n      try {\n        let i = 0;\n        while (true) {\n          sideEffects.push(i);\n          yield await i++;\n        }\n      } finally {\n        results.push('finalized generator');\n      }\n    }\n\n    const source = from(gen()).pipe(\n      take(3),\n    );\n\n\n    source.subscribe({\n      next: value => results.push(value),\n      complete: () => {\n        results.push('done');\n        setTimeout(() => {\n          expect(sideEffects).to.deep.equal([0, 1, 2]);\n          expect(results).to.deep.equal([0, 1, 2, 'done', 'finalized generator']);\n          done();\n        });\n      }\n    });\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize an AsyncGenerator on error","suites":["from"],"updatePoint":{"line":72,"column":48},"line":72,"code":"  it('should finalize an AsyncGenerator on error', (done) => {\n    const results: any[] = [];\n    const sideEffects: any[] = [];\n\n    async function* gen() {\n      try {\n        let i = 0;\n        while (true) {\n          sideEffects.push(i);\n          yield await i++;\n        }\n      } finally {\n        results.push('finalized generator');\n      }\n    }\n\n    const source = from(gen()).pipe(\n      tap({\n        next: value => {\n          if (value === 2) {\n            throw new Error('weee');\n          }\n        }\n      }),\n    );\n\n\n    source.subscribe({\n      next: value => results.push(value),\n      error: () => {\n        results.push('in error');\n        setTimeout(() => {\n          expect(sideEffects).to.deep.equal([0, 1, 2]);\n          expect(results).to.deep.equal([0, 1, 'in error', 'finalized generator']);\n          done();\n        });\n      }\n    });\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize an AsyncGenerator on unsubscribe","suites":["from"],"updatePoint":{"line":112,"column":54},"line":112,"code":"  it('should finalize an AsyncGenerator on unsubscribe', (done) => {\n    const results: any[] = [];\n    const sideEffects: any[] = [];\n    let subscription: Subscription;\n\n    async function* gen() {\n      try {\n        let i = 0;\n        while (true) {\n          sideEffects.push(i);\n          yield await i++;\n          if (i === 2) {\n            subscription.unsubscribe();\n          }\n        }\n      } finally {\n        results.push('finalized generator');\n        expect(sideEffects).to.deep.equal([0, 1, 2]);\n        expect(results).to.deep.equal([0, 1, 'finalized generator']);\n        done();\n      }\n    }\n\n    const source = from(gen());\n\n    subscription = source.subscribe(value => results.push(value));\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize a generator","suites":["from"],"updatePoint":{"line":141,"column":33},"line":141,"code":"  it('should finalize a generator', () => {\n    const results: any[] = [];\n\n    function* gen() {\n      try {\n        let i = 0;\n        while (true) {\n          yield i++;\n        }\n      } finally {\n        results.push('finalized generator');\n      }\n    }\n\n    const source = from(gen()).pipe(\n      take(3),\n    );\n\n\n    source.subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('done')\n    });\n\n    expect(results).to.deep.equal([0, 1, 2, 'done', 'finalized generator']);\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept ","suites":["from"],"updatePoint":{"line":256,"column":36},"line":256,"code":"    it(`should accept ${source.name}`, (done) => {\n      let nextInvoked = false;\n      from(source.createValue())\n        .subscribe(\n          { next: (x) => {\n            nextInvoked = true;\n            expect(x).to.equal('x');\n          }, error: (x) => {\n            done(new Error('should not be called'));\n          }, complete: () => {\n            expect(nextInvoked).to.equal(true);\n            done();\n          } }\n        );\n    });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept  and scheduler","suites":["from"],"updatePoint":{"line":271,"column":50},"line":271,"code":"    it(`should accept ${source.name} and scheduler`, (done) => {\n      let nextInvoked = false;\n      from(source.createValue(), asyncScheduler)\n        .subscribe(\n          { next: (x) => {\n            nextInvoked = true;\n            expect(x).to.equal('x');\n          }, error: (x) => {\n            done(new Error('should not be called'));\n          }, complete: () => {\n            expect(nextInvoked).to.equal(true);\n            done();\n          } }\n        );\n      expect(nextInvoked).to.equal(false);\n    });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a function that implements [Symbol.observable]","suites":["from"],"updatePoint":{"line":288,"column":68},"line":288,"code":"    it(`should accept a function that implements [Symbol.observable]`, (done) => {\n      const subject = new Subject<any>();\n      const handler: any = (arg: any) => subject.next(arg);\n      handler[observable] = () => subject;\n      let nextInvoked = false;\n\n      from((handler as any)).pipe(first()).subscribe(\n        { next: (x) => {\n          nextInvoked = true;\n          expect(x).to.equal('x');\n        }, error: (x) => {\n          done(new Error('should not be called'));\n        }, complete: () => {\n          expect(nextInvoked).to.equal(true);\n          done();\n        } }\n      );\n      handler('x');\n    });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a thennable that happens to have a subscribe method","suites":["from"],"updatePoint":{"line":308,"column":73},"line":308,"code":"    it('should accept a thennable that happens to have a subscribe method', (done) => {\n      // There was an issue with our old `isPromise` check that caused this to fail\n      const input = Promise.resolve('test');\n      (input as any).subscribe = noop;\n      from(input).subscribe({\n        next: x => {\n          expect(x).to.equal('test');\n          done();\n        }\n      })\n    })","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should appropriately handle errors from an iterator","suites":["from"],"updatePoint":{"line":321,"column":57},"line":321,"code":"  it('should appropriately handle errors from an iterator', () => {\n    const erroringIterator = (function* () {\n      for (let i = 0; i < 5; i++) {\n        if (i === 3) {\n          throw new Error('bad');\n        }\n        yield i;\n      }\n    })();\n\n    const results: any[] = [];\n\n    from(erroringIterator).subscribe({\n      next: x => results.push(x),\n      error: err => results.push(err.message)\n    });\n\n    expect(results).to.deep.equal([0, 1, 2, 'bad']);\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute the finally block of a generator","suites":["from"],"updatePoint":{"line":341,"column":53},"line":341,"code":"  it('should execute the finally block of a generator', () => {\n    let finallyExecuted = false;\n    const generator = (function* () {\n      try {\n        yield 'hi';\n      } finally {\n        finallyExecuted = true;\n      }\n    })();\n\n    from(generator).subscribe();\n\n    expect(finallyExecuted).to.be.true;\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should support ReadableStream-like objects","suites":["from"],"updatePoint":{"line":356,"column":48},"line":356,"code":"  it('should support ReadableStream-like objects', (done) => {\n    const input = [0, 1, 2];\n    const output: number[] = [];\n\n    const readableStream = new ReadableStream({\n      pull(controller) {\n        if (input.length > 0) {\n          controller.enqueue(input.shift());\n\n          if (input.length === 0) {\n            controller.close();\n          }\n        }\n      },\n    });\n\n    from(readableStream).subscribe({\n      next: value => {\n        output.push(value);\n        expect(readableStream.locked).to.equal(true);\n      },\n      complete: () => {\n        expect(output).to.deep.equal([0, 1, 2]);\n        expect(readableStream.locked).to.equal(false);\n        done();\n      }\n    });\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should lock and release ReadableStream-like objects","suites":["from"],"updatePoint":{"line":385,"column":57},"line":385,"code":"  it('should lock and release ReadableStream-like objects', (done) => {\n    const input = [0, 1, 2];\n    const output: number[] = [];\n\n    const readableStream = new ReadableStream({\n      pull(controller) {\n        if (input.length > 0) {\n          controller.enqueue(input.shift());\n\n          if (input.length === 0) {\n            controller.close();\n          }\n        }\n      },\n    });\n\n    from(readableStream).subscribe({\n      next: value => {\n        output.push(value);\n        expect(readableStream.locked).to.equal(true);\n      },\n      complete: () => {\n        expect(output).to.deep.equal([0, 1, 2]);\n        expect(readableStream.locked).to.equal(false);\n        done();\n      }\n    });\n  });","file":"observables/from-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable of click on the element","suites":["fromEvent"],"updatePoint":{"line":11,"column":57},"line":11,"code":"  it('should create an observable of click on the element', () => {\n    const target = {\n      addEventListener: (eventType: any, listener: any) => {\n        timer(50, 20, rxTestScheduler)\n          .pipe(\n            mapTo('ev'),\n            take(2),\n            concat(NEVER)\n          )\n          .subscribe(listener);\n      },\n      removeEventListener: (): void => void 0,\n      dispatchEvent: (): void => void 0,\n    };\n    const e1 = fromEvent(target as any, 'click');\n    const expected = '-----x-x---';\n    expectObservable(e1).toBe(expected, {x: 'ev'});\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should setup an event observable on objects with \"on\" and \"off\" ","suites":["fromEvent"],"updatePoint":{"line":30,"column":70},"line":30,"code":"  it('should setup an event observable on objects with \"on\" and \"off\" ', () => {\n    let onEventName;\n    let onHandler;\n    let offEventName;\n    let offHandler;\n\n    const obj = {\n      on: (a: string, b: Function) => {\n        onEventName = a;\n        onHandler = b;\n      },\n      off: (a: string, b: Function) => {\n        offEventName = a;\n        offHandler = b;\n      }\n    };\n\n    const subscription = fromEvent(obj, 'click')\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onEventName).to.equal('click');\n    expect(typeof onHandler).to.equal('function');\n    expect(offEventName).to.equal(onEventName);\n    expect(offHandler).to.equal(onHandler);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should setup an event observable on objects with \"addEventListener\" and \"removeEventListener\" ","suites":["fromEvent"],"updatePoint":{"line":60,"column":100},"line":60,"code":"  it('should setup an event observable on objects with \"addEventListener\" and \"removeEventListener\" ', () => {\n    let onEventName;\n    let onHandler;\n    let offEventName;\n    let offHandler;\n\n    const obj = {\n      addEventListener: (a: string, b: EventListenerOrEventListenerObject, useCapture?: boolean) => {\n        onEventName = a;\n        onHandler = b;\n      },\n      removeEventListener: (a: string, b: EventListenerOrEventListenerObject, useCapture?: boolean) => {\n        offEventName = a;\n        offHandler = b;\n      }\n    };\n\n    const subscription = fromEvent(<any>obj, 'click')\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onEventName).to.equal('click');\n    expect(typeof onHandler).to.equal('function');\n    expect(offEventName).to.equal(onEventName);\n    expect(offHandler).to.equal(onHandler);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should setup an event observable on objects with \"addListener\" and \"removeListener\" returning event emitter","suites":["fromEvent"],"updatePoint":{"line":90,"column":113},"line":90,"code":"  it('should setup an event observable on objects with \"addListener\" and \"removeListener\" returning event emitter', () => {\n    let onEventName;\n    let onHandler;\n    let offEventName;\n    let offHandler;\n\n    const obj = {\n      addListener(a: string | symbol, b: (...args: any[]) => void) {\n        onEventName = a;\n        onHandler = b;\n        return this;\n      },\n      removeListener(a: string | symbol, b: (...args: any[]) => void) {\n        offEventName = a;\n        offHandler = b;\n        return this;\n      }\n    };\n\n    const subscription = fromEvent(obj, 'click')\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onEventName).to.equal('click');\n    expect(typeof onHandler).to.equal('function');\n    expect(offEventName).to.equal(onEventName);\n    expect(offHandler).to.equal(onHandler);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should setup an event observable on objects with \"addListener\" and \"removeListener\" returning nothing","suites":["fromEvent"],"updatePoint":{"line":122,"column":107},"line":122,"code":"  it('should setup an event observable on objects with \"addListener\" and \"removeListener\" returning nothing', () => {\n    let onEventName;\n    let onHandler;\n    let offEventName;\n    let offHandler;\n\n    const obj = {\n      addListener(a: string, b: (...args: any[]) => any, context?: any): { context: any } {\n        onEventName = a;\n        onHandler = b;\n        return { context: '' };\n      },\n      removeListener(a: string, b: (...args: any[]) => void) {\n        offEventName = a;\n        offHandler = b;\n      }\n    };\n\n    const subscription = fromEvent(obj, 'click')\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onEventName).to.equal('click');\n    expect(typeof onHandler).to.equal('function');\n    expect(offEventName).to.equal(onEventName);\n    expect(offHandler).to.equal(onHandler);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should setup an event observable on objects with \"addListener\" and \"removeListener\" and \"length\" ","suites":["fromEvent"],"updatePoint":{"line":153,"column":103},"line":153,"code":"  it('should setup an event observable on objects with \"addListener\" and \"removeListener\" and \"length\" ', () => {\n    let onEventName;\n    let onHandler;\n    let offEventName;\n    let offHandler;\n\n    const obj = {\n      addListener: (a: string, b: Function) => {\n        onEventName = a;\n        onHandler = b;\n      },\n      removeListener: (a: string, b: Function) => {\n        offEventName = a;\n        offHandler = b;\n      },\n      length: 1\n    };\n\n    const subscription = fromEvent(obj, 'click')\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onEventName).to.equal('click');\n    expect(typeof onHandler).to.equal('function');\n    expect(offEventName).to.equal(onEventName);\n    expect(offHandler).to.equal(onHandler);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if passed an invalid event target","suites":["fromEvent"],"updatePoint":{"line":184,"column":52},"line":184,"code":"  it('should throw if passed an invalid event target', () => {\n    const obj = {\n      addListener: () => {\n        //noop\n      }\n    };\n    expect(() => {\n      fromEvent(obj as any, 'click');\n    }).to.throw(/Invalid event target/)\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass through options to addEventListener and removeEventListener","suites":["fromEvent"],"updatePoint":{"line":195,"column":77},"line":195,"code":"  it('should pass through options to addEventListener and removeEventListener', () => {\n    let onOptions;\n    let offOptions;\n    const expectedOptions = { capture: true, passive: true };\n\n    const obj = {\n      addEventListener: (a: string, b: EventListenerOrEventListenerObject, c?: any) => {\n        onOptions = c;\n      },\n      removeEventListener: (a: string, b: EventListenerOrEventListenerObject, c?: any) => {\n        offOptions = c;\n      }\n    };\n\n    const subscription = fromEvent(<any>obj, 'click', expectedOptions)\n      .subscribe(() => {\n        //noop\n       });\n\n    subscription.unsubscribe();\n\n    expect(onOptions).to.equal(expectedOptions);\n    expect(offOptions).to.equal(expectedOptions);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass through events that occur","suites":["fromEvent"],"updatePoint":{"line":220,"column":43},"line":220,"code":"  it('should pass through events that occur', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    fromEvent(obj, 'click').pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).to.equal('test');\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send('test');\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass through events that occur and use the selector if provided","suites":["fromEvent"],"updatePoint":{"line":243,"column":76},"line":243,"code":"  it('should pass through events that occur and use the selector if provided', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    function selector(x: string) {\n      return x + '!';\n    }\n\n    fromEvent(obj, 'click', selector).pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).to.equal('test!');\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send('test');\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should not fail if no event arguments are passed and the selector does not return","suites":["fromEvent"],"updatePoint":{"line":270,"column":87},"line":270,"code":"  it('should not fail if no event arguments are passed and the selector does not return', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    function selector() {\n      //noop\n    }\n\n    fromEvent(obj, 'click', selector).pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).not.exist;\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send();\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a value from the selector if no event arguments are passed","suites":["fromEvent"],"updatePoint":{"line":297,"column":78},"line":297,"code":"  it('should return a value from the selector if no event arguments are passed', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    function selector() {\n      return 'no arguments';\n    }\n\n    fromEvent(obj, 'click', selector).pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).to.equal('no arguments');\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send();\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass multiple arguments to selector from event emitter","suites":["fromEvent"],"updatePoint":{"line":324,"column":67},"line":324,"code":"  it('should pass multiple arguments to selector from event emitter', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    function selector(x: number, y: number, z: number) {\n      return [].slice.call(arguments);\n    }\n\n    fromEvent(obj, 'click', selector).pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).to.deep.equal([1, 2, 3]);\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send(1, 2, 3);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit multiple arguments from event as an array","suites":["fromEvent"],"updatePoint":{"line":351,"column":59},"line":351,"code":"  it('should emit multiple arguments from event as an array', (done) => {\n    let send: any;\n    const obj = {\n      on: (name: string, handler: Function) => {\n        send = handler;\n      },\n      off: () => {\n        //noop\n      }\n    };\n\n    fromEvent(obj, 'click').pipe(take(1))\n      .subscribe({ next: (e: any) => {\n        expect(e).to.deep.equal([1, 2, 3]);\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    send(1, 2, 3);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should not throw an exception calling toString on obj with a null prototype","suites":["fromEvent"],"updatePoint":{"line":374,"column":81},"line":374,"code":"  it('should not throw an exception calling toString on obj with a null prototype', (done) => {\n    // NOTE: Can not test with Object.create(null) or `class Foo extends null`\n    // due to TypeScript bug. https://github.com/Microsoft/TypeScript/issues/1108\n    class NullProtoEventTarget {\n      on() { /*noop*/ }\n      off() { /*noop*/ }\n    }\n    NullProtoEventTarget.prototype.toString = null!;\n    const obj: NullProtoEventTarget = new NullProtoEventTarget();\n\n    expect(() => {\n      fromEvent(obj, 'foo').subscribe();\n      done();\n    }).to.not.throw(TypeError);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle adding events to an arraylike of targets","suites":["fromEvent"],"updatePoint":{"line":390,"column":60},"line":390,"code":"  it('should handle adding events to an arraylike of targets', () => {\n    const nodeList = {\n      [0]: {\n        addEventListener(...args: any[]) {\n          this._addEventListenerArgs = args;\n        },\n        removeEventListener(...args: any[]) {\n          this._removeEventListenerArgs = args;\n        },\n        _addEventListenerArgs: null as any,\n        _removeEventListenerArgs: null as any,\n      },\n      [1]: {\n        addEventListener(...args: any[]) {\n          this._addEventListenerArgs = args;\n        },\n        removeEventListener(...args: any[]) {\n          this._removeEventListenerArgs = args;\n        },\n        _addEventListenerArgs: null as any,\n        _removeEventListenerArgs: null as any,\n      },\n      length: 2\n    };\n\n    const options = {};\n\n    const subscription = fromEvent(nodeList, 'click', options).subscribe();\n\n    expect(nodeList[0]._addEventListenerArgs[0]).to.equal('click');\n    expect(nodeList[0]._addEventListenerArgs[1]).to.be.a('function');\n    expect(nodeList[0]._addEventListenerArgs[2]).to.equal(options);\n    \n    expect(nodeList[1]._addEventListenerArgs[0]).to.equal('click');\n    expect(nodeList[1]._addEventListenerArgs[1]).to.be.a('function');\n    expect(nodeList[1]._addEventListenerArgs[2]).to.equal(options);\n\n    expect(nodeList[0]._removeEventListenerArgs).to.be.null;\n    expect(nodeList[1]._removeEventListenerArgs).to.be.null;\n\n    subscription.unsubscribe();\n    \n    expect(nodeList[0]._removeEventListenerArgs).to.deep.equal(nodeList[0]._addEventListenerArgs);\n    expect(nodeList[1]._removeEventListenerArgs).to.deep.equal(nodeList[1]._addEventListenerArgs);\n  });","file":"observables/fromEvent-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from the handler API","suites":["fromEventPattern"],"updatePoint":{"line":13,"column":54},"line":13,"code":"  it('should create an observable from the handler API', () => {\n    function addHandler(h: any) {\n      timer(50, 20, rxTestScheduler).pipe(\n        mapTo('ev'),\n        take(2),\n        concat(NEVER)\n      ).subscribe(h);\n    }\n    const e1 = fromEventPattern(addHandler);\n    const expected = '-----x-x---';\n    expectObservable(e1).toBe(expected, {x: 'ev'});\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should call addHandler on subscription","suites":["fromEventPattern"],"updatePoint":{"line":26,"column":44},"line":26,"code":"  it('should call addHandler on subscription', () => {\n    const addHandler = sinon.spy();\n    fromEventPattern(addHandler, noop).subscribe(noop);\n\n    const call = addHandler.getCall(0);\n    expect(addHandler).calledOnce;\n    expect(call.args[0]).to.be.a('function');\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should call removeHandler on unsubscription","suites":["fromEventPattern"],"updatePoint":{"line":35,"column":49},"line":35,"code":"  it('should call removeHandler on unsubscription', () => {\n    const removeHandler = sinon.spy();\n\n    fromEventPattern(noop, removeHandler).subscribe(noop).unsubscribe();\n\n    const call = removeHandler.getCall(0);\n    expect(removeHandler).calledOnce;\n    expect(call.args[0]).to.be.a('function');\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should work without optional removeHandler","suites":["fromEventPattern"],"updatePoint":{"line":45,"column":48},"line":45,"code":"  it('should work without optional removeHandler', () => {\n    const addHandler: (h: Function) => any = sinon.spy();\n    fromEventPattern(addHandler).subscribe(noop);\n\n    expect(addHandler).calledOnce;\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should deliver return value of addHandler to removeHandler as signal","suites":["fromEventPattern"],"updatePoint":{"line":52,"column":74},"line":52,"code":"  it('should deliver return value of addHandler to removeHandler as signal', () => {\n    const expected = { signal: true};\n    const addHandler = () => expected;\n    const removeHandler = sinon.spy();\n    fromEventPattern(addHandler, removeHandler).subscribe(noop).unsubscribe();\n\n    const call = removeHandler.getCall(0);\n    expect(call).calledWith(sinon.match.any, expected);\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should send errors in addHandler down the error path","suites":["fromEventPattern"],"updatePoint":{"line":62,"column":58},"line":62,"code":"  it('should send errors in addHandler down the error path', (done) => {\n    fromEventPattern((h: any) => {\n      throw 'bad';\n    }, noop).subscribe(\n      { next: () => done(new Error('should not be called')), error: (err: any) => {\n        expect(err).to.equal('bad');\n        done();\n      }, complete: () => done(new Error('should not be called')) });\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a selector that maps outgoing values","suites":["fromEventPattern"],"updatePoint":{"line":72,"column":56},"line":72,"code":"  it('should accept a selector that maps outgoing values', (done) => {\n    let target: any;\n    const trigger = function (...args: any[]) {\n      if (target) {\n        target.apply(null, arguments);\n      }\n    };\n\n    const addHandler = (handler: any) => {\n      target = handler;\n    };\n    const removeHandler = (handler: any) => {\n      target = null;\n    };\n    const selector = (a: any, b: any) => {\n      return a + b + '!';\n    };\n\n    fromEventPattern(addHandler, removeHandler, selector).pipe(take(1))\n      .subscribe({ next: (x: any) => {\n        expect(x).to.equal('testme!');\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n\n    trigger('test', 'me');\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should send errors in the selector down the error path","suites":["fromEventPattern"],"updatePoint":{"line":102,"column":60},"line":102,"code":"  it('should send errors in the selector down the error path', (done) => {\n    let target: any;\n    const trigger = (value: any) => {\n      if (target) {\n        target(value);\n      }\n    };\n\n    const addHandler = (handler: any) => {\n      target = handler;\n    };\n    const removeHandler = (handler: any) => {\n      target = null;\n    };\n    const selector = (x: any) => {\n      throw 'bad';\n    };\n\n    fromEventPattern(addHandler, removeHandler, selector)\n      .subscribe({ next: (x: any) => {\n        done(new Error('should not be called'));\n      }, error: (err: any) => {\n        expect(err).to.equal('bad');\n        done();\n      }, complete: () => {\n        done(new Error('should not be called'));\n      } });\n\n    trigger('test');\n  });","file":"observables/fromEventPattern-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if condition does not meet","suites":["generate"],"updatePoint":{"line":15,"column":48},"line":15,"code":"  it('should complete if condition does not meet', () => {\n    const source = generate(1, x => false, x => x + 1);\n    const expected = '|';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should produce first value immediately","suites":["generate"],"updatePoint":{"line":22,"column":44},"line":22,"code":"  it('should produce first value immediately', () => {\n    const source = generate(1, x => x == 1, x => x + 1);\n    const expected = '(1|)';\n\n    expectObservable(source).toBe(expected, { '1': 1 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should produce all values synchronously","suites":["generate"],"updatePoint":{"line":29,"column":45},"line":29,"code":"  it('should produce all values synchronously', () => {\n    const source = generate(1, x => x < 3, x => x + 1);\n    const expected = '(12|)';\n\n    expectObservable(source).toBe(expected, { '1': 1, '2': 2 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should use result selector","suites":["generate"],"updatePoint":{"line":36,"column":32},"line":36,"code":"  it('should use result selector', () => {\n    const source = generate(1, x => x < 3, x => x + 1, x => (x + 1).toString());\n    const expected = '(23|)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow omit condition","suites":["generate"],"updatePoint":{"line":43,"column":33},"line":43,"code":"  it('should allow omit condition', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x + 1,\n      resultSelector: (x: number) => x.toString()\n    }).pipe(\n      take(5)\n    );\n    const expected = '(12345|)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop producing when unsubscribed","suites":["generate"],"updatePoint":{"line":56,"column":45},"line":56,"code":"  it('should stop producing when unsubscribed', () => {\n    const source = generate(1, x => x < 4, x => x + 1);\n    let count = 0;\n    const subscriber = new SafeSubscriber<number>(\n      x => {\n        count++;\n        if (x == 2) {\n          subscriber.unsubscribe();\n        }\n      }\n    );\n    source.subscribe(subscriber);\n    expect(count).to.be.equal(2);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a scheduler","suites":["generate"],"updatePoint":{"line":71,"column":31},"line":71,"code":"  it('should accept a scheduler', () => {\n    const source = generate({\n      initialState: 1,\n      condition: x => x < 4,\n      iterate: x => x + 1,\n      resultSelector: (x: number) => x,\n      scheduler: rxTestScheduler\n    });\n    const expected = '(123|)';\n\n    let count = 0;\n    source.subscribe(x => count++);\n\n    expect(count).to.be.equal(0);\n    rxTestScheduler.flush();\n    expect(count).to.be.equal(3);\n\n    expectObservable(source).toBe(expected, { '1': 1, '2': 2, '3': 3 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow minimal possible options","suites":["generate"],"updatePoint":{"line":91,"column":43},"line":91,"code":"  it('should allow minimal possible options', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x * 2\n    }).pipe(\n      take(3)\n    );\n    const expected = '(124|)';\n\n    expectObservable(source).toBe(expected, { '1': 1, '2': 2, '4': 4 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error if result selector throws","suites":["generate"],"updatePoint":{"line":103,"column":49},"line":103,"code":"  it('should emit error if result selector throws', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x * 2,\n      resultSelector: err\n    });\n    const expected = '(#)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error if result selector throws on scheduler","suites":["generate"],"updatePoint":{"line":114,"column":62},"line":114,"code":"  it('should emit error if result selector throws on scheduler', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x * 2,\n      resultSelector: err,\n      scheduler: rxTestScheduler\n    });\n    const expected = '(#)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error after first value if iterate function throws","suites":["generate"],"updatePoint":{"line":126,"column":68},"line":126,"code":"  it('should emit error after first value if iterate function throws', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: err\n    });\n    const expected = '(1#)';\n\n    expectObservable(source).toBe(expected, { '1': 1 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error after first value if iterate function throws on scheduler","suites":["generate"],"updatePoint":{"line":136,"column":81},"line":136,"code":"  it('should emit error after first value if iterate function throws on scheduler', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: err,\n      scheduler: rxTestScheduler\n    });\n    const expected = '(1#)';\n\n    expectObservable(source).toBe(expected, { '1': 1 });\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error if condition function throws","suites":["generate"],"updatePoint":{"line":147,"column":52},"line":147,"code":"  it('should emit error if condition function throws', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x + 1,\n      condition: err\n    });\n    const expected = '(#)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error if condition function throws on scheduler","suites":["generate"],"updatePoint":{"line":158,"column":65},"line":158,"code":"  it('should emit error if condition function throws on scheduler', () => {\n    const source = generate({\n      initialState: 1,\n      iterate: x => x + 1,\n      condition: err,\n      scheduler: rxTestScheduler\n    });\n    const expected = '(#)';\n\n    expectObservable(source).toBe(expected);\n  });","file":"observables/generate-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe to thenSource when the conditional returns true","suites":["iif"],"updatePoint":{"line":6,"column":70},"line":6,"code":"  it('should subscribe to thenSource when the conditional returns true', () => {\n    const e1 = iif(() => true, of('a'), of());\n    const expected = '(a|)';\n\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe to elseSource when the conditional returns false","suites":["iif"],"updatePoint":{"line":13,"column":71},"line":13,"code":"  it('should subscribe to elseSource when the conditional returns false', () => {\n    const e1 = iif(() => false, of('a'), of('b'));\n    const expected = '(b|)';\n\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without an elseSource when the conditional returns false","suites":["iif"],"updatePoint":{"line":20,"column":78},"line":20,"code":"  it('should complete without an elseSource when the conditional returns false', () => {\n    const e1 = iif(() => false, of('a'), of());\n    const expected = '|';\n\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when conditional throws","suites":["iif"],"updatePoint":{"line":27,"column":48},"line":27,"code":"  it('should raise error when conditional throws', () => {\n    const e1 = iif(((): boolean => {\n      throw 'error';\n    }), of('a'), of());\n\n    const expected = '#';\n\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept resolved promise as thenSource","suites":["iif"],"updatePoint":{"line":37,"column":50},"line":37,"code":"  it('should accept resolved promise as thenSource', (done) => {\n    const expected = 42;\n    const e1 = iif(() => true, new Promise((resolve: any) => { resolve(expected); }), of());\n\n    e1.subscribe({ next: x => {\n      expect(x).to.equal(expected);\n    }, error: (x) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept resolved promise as elseSource","suites":["iif"],"updatePoint":{"line":50,"column":50},"line":50,"code":"  it('should accept resolved promise as elseSource', (done) => {\n    const expected = 42;\n    const e1 = iif(() => false,\n      of('a'),\n      new Promise((resolve: any) => { resolve(expected); }));\n\n    e1.subscribe({ next: x => {\n      expect(x).to.equal(expected);\n    }, error: (x) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept rejected promise as elseSource","suites":["iif"],"updatePoint":{"line":65,"column":50},"line":65,"code":"  it('should accept rejected promise as elseSource', (done) => {\n    const expected = 42;\n    const e1 = iif(() => false,\n      of('a'),\n      new Promise((resolve: any, reject: any) => { reject(expected); }));\n\n    e1.subscribe({ next: x => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(expected);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept rejected promise as thenSource","suites":["iif"],"updatePoint":{"line":81,"column":50},"line":81,"code":"  it('should accept rejected promise as thenSource', (done) => {\n    const expected = 42;\n    const e1 = iif(() => true, new Promise((resolve: any, reject: any) => { reject(expected); }), of());\n\n    e1.subscribe({ next: x => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(expected);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/if-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emitting periodically","suites":["interval"],"updatePoint":{"line":12,"column":55},"line":12,"code":"  it('should create an observable emitting periodically', () => {\n    const e1 = interval(20, rxTestScheduler).pipe(\n      take(6), // make it actually finite, so it can be rendered\n      concat(NEVER) // but pretend it's infinite by not completing\n    );\n    const expected = '--a-b-c-d-e-f-';\n    const values = {\n      a: 0,\n      b: 1,\n      c: 2,\n      d: 3,\n      e: 4,\n      f: 5,\n    };\n    expectObservable(e1).toBe(expected, values);\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should set up an interval","suites":["interval"],"updatePoint":{"line":29,"column":31},"line":29,"code":"  it('should set up an interval', () => {\n    const expected = '----------0---------1---------2---------3---------4---------5---------6-----';\n    expectObservable(interval(100, rxTestScheduler)).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit when relative interval set to zero","suites":["interval"],"updatePoint":{"line":34,"column":52},"line":34,"code":"  it('should emit when relative interval set to zero', () => {\n    const e1 = interval(0, rxTestScheduler).pipe(take(7));\n    const expected = '(0123456|)';\n    expectObservable(e1).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should consider negative interval as zero","suites":["interval"],"updatePoint":{"line":40,"column":47},"line":40,"code":"  it('should consider negative interval as zero', () => {\n    const e1 = interval(-1, rxTestScheduler).pipe(take(7));\n    const expected = '(0123456|)';\n    expectObservable(e1).toBe(expected, [0, 1, 2, 3, 4, 5, 6]);\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit values until unsubscribed","suites":["interval"],"updatePoint":{"line":46,"column":43},"line":46,"code":"  it('should emit values until unsubscribed', (done) => {\n    const values: number[] = [];\n    const expected = [0, 1, 2, 3, 4, 5, 6];\n    const e1 = interval(5);\n    const subscription = e1.subscribe({ next: (x: number) => {\n      values.push(x);\n      if (x === 6) {\n        subscription.unsubscribe();\n        expect(values).to.deep.equal(expected);\n        done();\n      }\n    }, error: (err: any) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emitting periodically with the AsapScheduler","suites":["interval"],"updatePoint":{"line":64,"column":78},"line":64,"code":"  it('should create an observable emitting periodically with the AsapScheduler', (done) => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    const period = 10;\n    const events = [0, 1, 2, 3, 4, 5];\n    const source = interval(period, asapScheduler).pipe(take(6));\n    source.subscribe({\n      next(x) {\n        expect(x).to.equal(events.shift());\n      },\n      error(e) {\n        sandbox.restore();\n        done(e);\n      },\n      complete() {\n        expect(asapScheduler.actions.length).to.equal(0);\n        expect(asapScheduler._scheduled).to.equal(undefined);\n        sandbox.restore();\n        done();\n      }\n    });\n    let i = -1, n = events.length;\n    while (++i < n) {\n      fakeTimer.tick(period);\n    }\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emitting periodically with the QueueScheduler","suites":["interval"],"updatePoint":{"line":91,"column":79},"line":91,"code":"  it('should create an observable emitting periodically with the QueueScheduler', (done) => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    const period = 10;\n    const events = [0, 1, 2, 3, 4, 5];\n    const source = interval(period, queueScheduler).pipe(take(6));\n    source.subscribe({\n      next(x) {\n        expect(x).to.equal(events.shift());\n      },\n      error(e) {\n        sandbox.restore();\n        done(e);\n      },\n      complete() {\n        expect(queueScheduler.actions.length).to.equal(0);\n        expect(queueScheduler._scheduled).to.equal(undefined);\n        sandbox.restore();\n        done();\n      }\n    });\n    let i = -1, n = events.length;\n    while (++i < n) {\n      fakeTimer.tick(period);\n    }\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emitting periodically with the AnimationFrameScheduler","suites":["interval"],"updatePoint":{"line":118,"column":88},"line":118,"code":"  it('should create an observable emitting periodically with the AnimationFrameScheduler', (done) => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    const period = 10;\n    const events = [0, 1, 2, 3, 4, 5];\n    const source = interval(period, animationFrameScheduler).pipe(take(6));\n    source.subscribe({\n      next(x) {\n        expect(x).to.equal(events.shift());\n      },\n      error(e) {\n        sandbox.restore();\n        done(e);\n      },\n      complete() {\n        expect(animationFrameScheduler.actions.length).to.equal(0);\n        expect(animationFrameScheduler._scheduled).to.equal(undefined);\n        sandbox.restore();\n        done();\n      }\n    });\n    let i = -1, n = events.length;\n    while (++i < n) {\n      fakeTimer.tick(period);\n    }\n  });","file":"observables/interval-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge cold and cold","suites":["static merge(...observables)"],"updatePoint":{"line":12,"column":32},"line":12,"code":"  it('should merge cold and cold', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const e2 =  cold('------x-----y-----z----|');\n    const e2subs =   '^                      !';\n    const expected = '---a--x--b--y--c--z----|';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should return itself when try to merge single observable","suites":["static merge(...observables)"],"updatePoint":{"line":26,"column":62},"line":26,"code":"  it('should return itself when try to merge single observable', () => {\n    const e1 = of('a');\n    const result = merge(e1);\n\n    expect(e1).to.equal(result);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and hot","suites":["static merge(...observables)"],"updatePoint":{"line":33,"column":30},"line":33,"code":"  it('should merge hot and hot', () => {\n    const e1 =  hot('---a---^-b-----c----|');\n    const e1subs =         '^            !';\n    const e2 =  hot('-----x-^----y-----z----|');\n    const e2subs =         '^               !';\n    const expected =       '--b--y--c--z----|';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and cold","suites":["static merge(...observables)"],"updatePoint":{"line":47,"column":31},"line":47,"code":"  it('should merge hot and cold', () => {\n    const e1 =  hot('---a-^---b-----c----|');\n    const e1subs =       '^              !';\n    const e2 =  cold(    '--x-----y-----z----|');\n    const e2subs =       '^                  !';\n    const expected =     '--x-b---y-c---z----|';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge parallel emissions","suites":["static merge(...observables)"],"updatePoint":{"line":61,"column":37},"line":61,"code":"  it('should merge parallel emissions', () => {\n    const e1 =   hot('---a----b----c----|');\n    const e1subs =   '^                 !';\n    const e2 =   hot('---x----y----z----|');\n    const e2subs =   '^                 !';\n    const expected = '---(ax)-(by)-(cz)-|';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and empty","suites":["static merge(...observables)"],"updatePoint":{"line":75,"column":34},"line":75,"code":"  it('should merge empty and empty', () => {\n    const e1 = cold('|');\n    const e1subs = '(^!)';\n    const e2 = cold('|');\n    const e2subs = '(^!)';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('|');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge three empties","suites":["static merge(...observables)"],"updatePoint":{"line":88,"column":32},"line":88,"code":"  it('should merge three empties', () => {\n    const e1 = cold('|');\n    const e1subs = '(^!)';\n    const e2 = cold('|');\n    const e2subs = '(^!)';\n    const e3 = cold('|');\n    const e3subs = '(^!)';\n\n    const result = merge(e1, e2, e3);\n\n    expectObservable(result).toBe('|');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    expectSubscriptions(e3.subscriptions).toBe(e3subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and empty","suites":["static merge(...observables)"],"updatePoint":{"line":104,"column":34},"line":104,"code":"  it('should merge never and empty', () => {\n    const e1 = cold('-');\n    const e1subs =  '^';\n    const e2 = cold('|');\n    const e2subs =  '(^!)';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('-');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and never","suites":["static merge(...observables)"],"updatePoint":{"line":117,"column":34},"line":117,"code":"  it('should merge never and never', () => {\n    const e1 = cold('-');\n    const e1subs =  '^';\n    const e2 = cold('-');\n    const e2subs =  '^';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('-');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and throw","suites":["static merge(...observables)"],"updatePoint":{"line":130,"column":34},"line":130,"code":"  it('should merge empty and throw', () => {\n    const e1 = cold('|');\n    const e1subs =  '(^!)';\n    const e2 = cold('#');\n    const e2subs =  '(^!)';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('#');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and throw","suites":["static merge(...observables)"],"updatePoint":{"line":143,"column":32},"line":143,"code":"  it('should merge hot and throw', () => {\n    const e1 = hot('--a--b--c--|');\n    const e1subs = '(^!)';\n    const e2 = cold('#');\n    const e2subs =  '(^!)';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('#');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and throw","suites":["static merge(...observables)"],"updatePoint":{"line":156,"column":34},"line":156,"code":"  it('should merge never and throw', () => {\n    const e1 = cold('-');\n    const e1subs =  '(^!)';\n    const e2 = cold('#');\n    const e2subs =  '(^!)';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe('#');\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and eventual error","suites":["static merge(...observables)"],"updatePoint":{"line":169,"column":43},"line":169,"code":"  it('should merge empty and eventual error', () => {\n    const e1 = cold('|');\n    const e1subs =  '(^!)';\n    const e2 =    hot('-------#');\n    const e2subs =    '^------!';\n    const expected =  '-------#';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and error","suites":["static merge(...observables)"],"updatePoint":{"line":183,"column":32},"line":183,"code":"  it('should merge hot and error', () => {\n    const e1 =   hot('--a--b--c--|');\n    const e1subs =   '^      !    ';\n    const e2 =   hot('-------#    ');\n    const e2subs =   '^      !    ';\n    const expected = '--a--b-#    ';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and error","suites":["static merge(...observables)"],"updatePoint":{"line":197,"column":34},"line":197,"code":"  it('should merge never and error', () => {\n    const e1 = hot(   '-');\n    const e1subs =    '^      !';\n    const e2 =    hot('-------#');\n    const e2subs =    '^      !';\n    const expected =  '-------#';\n\n    const result = merge(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge single lowerCaseO into RxJS Observable","suites":["static merge(...observables)"],"updatePoint":{"line":211,"column":57},"line":211,"code":"  it('should merge single lowerCaseO into RxJS Observable', () => {\n    const e1 = lowerCaseO('a', 'b', 'c');\n\n    const result = merge(e1);\n\n    expect(result).to.be.instanceof(Observable);\n    expectObservable(result).toBe('(abc|)');\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two lowerCaseO into RxJS Observable","suites":["static merge(...observables)"],"updatePoint":{"line":220,"column":54},"line":220,"code":"  it('should merge two lowerCaseO into RxJS Observable', () => {\n    const e1 = lowerCaseO('a', 'b', 'c');\n    const e2 = lowerCaseO('d', 'e', 'f');\n\n    const result = merge(e1, e2);\n\n    expect(result).to.be.instanceof(Observable);\n    expectObservable(result).toBe('(abcdef|)');\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge single lowerCaseO into RxJS Observable","suites":["merge(...observables, Scheduler)"],"updatePoint":{"line":232,"column":57},"line":232,"code":"  it('should merge single lowerCaseO into RxJS Observable', () => {\n    const e1 = lowerCaseO('a', 'b', 'c');\n\n    const result = merge(e1, rxTestScheduler);\n\n    expect(result).to.be.instanceof(Observable);\n    expectObservable(result).toBe('(abc|)');\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle concurrency limits","suites":["merge(...observables, Scheduler, number)"],"updatePoint":{"line":243,"column":38},"line":243,"code":"  it('should handle concurrency limits', () => {\n    const e1 =  cold('---a---b---c---|');\n    const e2 =  cold('-d---e---f--|');\n    const e3 =  cold(            '---x---y---z---|');\n    const expected = '-d-a-e-b-f-c---x---y---z---|';\n    expectObservable(merge(e1, e2, e3, 2)).toBe(expected);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle scheduler","suites":["merge(...observables, Scheduler, number)"],"updatePoint":{"line":251,"column":29},"line":251,"code":"  it('should handle scheduler', () => {\n    const e1 =  of('a');\n    const e2 =  of('b').pipe(delay(20, rxTestScheduler));\n    const expected = 'a-(b|)';\n\n    expectObservable(merge(e1, e2, rxTestScheduler)).toBe(expected);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle scheduler with concurrency limits","suites":["merge(...observables, Scheduler, number)"],"updatePoint":{"line":259,"column":53},"line":259,"code":"  it('should handle scheduler with concurrency limits', () => {\n    const e1 =  cold('---a---b---c---|');\n    const e2 =  cold('-d---e---f--|');\n    const e3 =  cold(            '---x---y---z---|');\n    const expected = '-d-a-e-b-f-c---x---y---z---|';\n    expectObservable(merge(e1, e2, e3, 2, rxTestScheduler)).toBe(expected);\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the scheduler even when one Observable is merged","suites":["merge(...observables, Scheduler, number)"],"updatePoint":{"line":267,"column":65},"line":267,"code":"  it('should use the scheduler even when one Observable is merged', (done) => {\n    let e1Subscribed = false;\n    const e1 = defer(() => {\n      e1Subscribed = true;\n      return of('a');\n    });\n\n    merge(e1, asyncScheduler)\n      .subscribe({\n        error: done,\n        complete: () => {\n          expect(e1Subscribed).to.be.true;\n          done();\n        }\n      });\n\n    expect(e1Subscribed).to.be.false;\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should deem a single array argument to be an ObservableInput","suites":["merge(...observables, Scheduler, number)"],"updatePoint":{"line":286,"column":66},"line":286,"code":"  it('should deem a single array argument to be an ObservableInput', () => {\n    const array = ['foo', 'bar'];\n    const expected = '(fb|)';\n    expectObservable(merge(array)).toBe(expected, { f: 'foo', b: 'bar' });\n  });","file":"observables/merge-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable that never emits","suites":["NEVER"],"updatePoint":{"line":7,"column":54},"line":7,"code":"  it('should create a cold observable that never emits', () => {\n    const expected = '-';\n    const e1 = NEVER;\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/never-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the same instance every time","suites":["NEVER"],"updatePoint":{"line":13,"column":48},"line":13,"code":"  it('should return the same instance every time', () => {\n    expect(NEVER).to.equal(NEVER);\n  });","file":"observables/never-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable that emits 1, 2, 3","suites":["of"],"updatePoint":{"line":11,"column":56},"line":11,"code":"  it('should create a cold observable that emits 1, 2, 3', () => {\n    const e1 = of(1, 2, 3).pipe(\n      // for the purpose of making a nice diagram, spread out the synchronous emissions\n      concatMap((x, i) => of(x).pipe(delay(i === 0 ? 0 : 20, rxTestScheduler)))\n    );\n    const expected = 'x-y-(z|)';\n    expectObservable(e1).toBe(expected, {x: 1, y: 2, z: 3});\n  });","file":"observables/of-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable from the provided values","suites":["of"],"updatePoint":{"line":20,"column":58},"line":20,"code":"  it('should create an observable from the provided values', (done) => {\n    const x = { foo: 'bar' };\n    const expected = [1, 'a', x];\n    let i = 0;\n\n   of(1, 'a', x)\n      .subscribe({ next: (y: any) => {\n        expect(y).to.equal(expected[i++]);\n      }, error: (x) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } });\n  });","file":"observables/of-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value","suites":["of"],"updatePoint":{"line":35,"column":27},"line":35,"code":"  it('should emit one value', (done) => {\n    let calls = 0;\n\n    of(42).subscribe({ next: (x: number) => {\n      expect(++calls).to.equal(1);\n      expect(x).to.equal(42);\n  }, error: (err: any) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"observables/of-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an Observable as the only value","suites":["of"],"updatePoint":{"line":48,"column":51},"line":48,"code":"  it('should handle an Observable as the only value', () => {\n    const source = of(\n     of('a', 'b', 'c', rxTestScheduler),\n      rxTestScheduler\n    );\n    const result = source.pipe(concatAll());\n    expectObservable(result).toBe('(abc|)');\n  });","file":"observables/of-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle many Observable as the given values","suites":["of"],"updatePoint":{"line":57,"column":55},"line":57,"code":"  it('should handle many Observable as the given values', () => {\n    const source = of(\n     of('a', 'b', 'c', rxTestScheduler),\n     of('d', 'e', 'f', rxTestScheduler),\n      rxTestScheduler\n    );\n\n    const result = source.pipe(concatAll());\n    expectObservable(result).toBe('(abcdef|)');\n  });","file":"observables/of-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue with observables","suites":["onErrorResumeNext"],"updatePoint":{"line":8,"column":38},"line":8,"code":"  it('should continue with observables', () => {\n    const s1 =   hot('--a--b--#');\n    const s2  =  cold(       '--c--d--#');\n    const s3  =  cold(               '--e--#');\n    const s4  =  cold(                    '--f--g--|');\n    const subs1 =    '^       !';\n    const subs2 =    '        ^       !';\n    const subs3 =    '                ^    !';\n    const subs4 =    '                     ^       !';\n    const expected = '--a--b----c--d----e----f--g--|';\n\n    expectObservable(onErrorResumeNext(s1, s2, s3, s4)).toBe(expected);\n    expectSubscriptions(s1.subscriptions).toBe(subs1);\n    expectSubscriptions(s2.subscriptions).toBe(subs2);\n    expectSubscriptions(s3.subscriptions).toBe(subs3);\n    expectSubscriptions(s4.subscriptions).toBe(subs4);\n  });","file":"observables/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue array of observables","suites":["onErrorResumeNext"],"updatePoint":{"line":26,"column":42},"line":26,"code":"  it('should continue array of observables', () => {\n    const s1 =   hot('--a--b--#');\n    const s2  =  cold(       '--c--d--#');\n    const s3  =  cold(               '--e--#');\n    const s4  =  cold(                    '--f--g--|');\n    const subs1 =    '^       !';\n    const subs2 =    '        ^       !';\n    const subs3 =    '                ^    !';\n    const subs4 =    '                     ^       !';\n    const expected = '--a--b----c--d----e----f--g--|';\n\n    expectObservable(onErrorResumeNext([s1, s2, s3, s4])).toBe(expected);\n    expectSubscriptions(s1.subscriptions).toBe(subs1);\n    expectSubscriptions(s2.subscriptions).toBe(subs2);\n    expectSubscriptions(s3.subscriptions).toBe(subs3);\n    expectSubscriptions(s4.subscriptions).toBe(subs4);\n  });","file":"observables/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete single observable throws","suites":["onErrorResumeNext"],"updatePoint":{"line":44,"column":46},"line":44,"code":"  it('should complete single observable throws', () => {\n    const source =   hot('#');\n    const subs =         '(^!)';\n    const expected =     '|';\n\n    expectObservable(onErrorResumeNext(source)).toBe(expected);\n    expectSubscriptions(source.subscriptions).toBe(subs);\n  });","file":"observables/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip invalid sources and move on","suites":["onErrorResumeNext"],"updatePoint":{"line":54,"column":45},"line":54,"code":"  it('should skip invalid sources and move on', () => {\n    const results: any[] = [];\n\n    onErrorResumeNext(\n      of(1),\n      [2, 3, 4],\n      { notValid: 'LOL' } as any,\n      of(5, 6),\n    )\n    .subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('complete')\n    });\n\n    expect(results).to.deep.equal([1, 2, 3, 4, 5, 6, 'complete']);\n  });","file":"observables/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize after each sync observable","suites":["onErrorResumeNext"],"updatePoint":{"line":71,"column":53},"line":71,"code":"  it('should call finalize after each sync observable', () => {\n    let results: any[] = []\n    \n    onErrorResumeNext(\n      of(1).pipe(\n        finalize(() => results.push('finalize 1'))\n      ),\n      of(2).pipe(\n        finalize(() => results.push('finalize 2'))\n      ), of(3).pipe(\n        finalize(() => results.push('finalize 3'))\n      ), of(4).pipe(\n        finalize(() => results.push('finalize 4'))\n      )\n    ).subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('complete')\n    });\n\n    expect(results).to.deep.equal([\n      1, 'finalize 1',\n      2, 'finalize 2',\n      3, 'finalize 3',\n      4, 'finalize 4',\n      'complete'\n    ]);\n  });","file":"observables/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emits key-value pair","suites":["pairs"],"updatePoint":{"line":9,"column":54},"line":9,"code":"  it('should create an observable emits key-value pair', () => {\n    const e1 = pairs({a: 1, b: 2}, rxTestScheduler);\n    const expected = '(ab|)';\n    const values = {\n      a: ['a', 1],\n      b: ['b', 2]\n    };\n\n    expectObservable(e1).toBe(expected, values);\n  });","file":"observables/pairs-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable without scheduler","suites":["pairs"],"updatePoint":{"line":20,"column":51},"line":20,"code":"  it('should create an observable without scheduler', (done) => {\n    let expected = [\n      ['a', 1],\n      ['b', 2],\n      ['c', 3]\n    ];\n\n    pairs({a: 1, b: 2, c: 3}).subscribe({ next: x => {\n      expect(x).to.deep.equal(expected.shift());\n    }, error: x => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      expect(expected).to.be.empty;\n      done();\n    } });\n  });","file":"observables/pairs-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty object","suites":["pairs"],"updatePoint":{"line":37,"column":35},"line":37,"code":"  it('should work with empty object', () => {\n    const e1 = pairs({}, rxTestScheduler);\n    const expected = '|';\n\n    expectObservable(e1).toBe(expected);\n  });","file":"observables/pairs-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition an observable into two using a predicate","suites":["Observable.prototype.partition"],"updatePoint":{"line":27,"column":63},"line":27,"code":"  it('should partition an observable into two using a predicate', () => {\n    const e1 =    hot('--a-b---a------d--a---c--|');\n    const e1subs =    '^                        !';\n    const expected = ['--a-----a---------a------|',\n                    '----b----------d------c--|'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition an observable into two using a predicate that takes an index","suites":["Observable.prototype.partition"],"updatePoint":{"line":41,"column":83},"line":41,"code":"  it('should partition an observable into two using a predicate that takes an index', () => {\n    const e1 =    hot('--a-b---a------d--e---c--|');\n    const e1subs =    '^                        !';\n    const expected = ['--a-----a---------e------|',\n                      '----b----------d------c--|'];\n\n    function predicate(value: string, index: number) {\n      return index % 2 === 0;\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition an observable into two using a predicate and thisArg","suites":["Observable.prototype.partition"],"updatePoint":{"line":55,"column":75},"line":55,"code":"  it('should partition an observable into two using a predicate and thisArg', () => {\n    const e1 =    hot('--a-b---a------d--a---c--|');\n    const e1subs =    '^                        !';\n    const expected = ['--a-----a---------a------|',\n                    '----b----------d------c--|'];\n\n    function predicate(this: any, x: string) {\n      return x === this.value;\n    }\n\n    expectObservableArray(partition(e1, predicate, {value: 'a'}), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass errors to both returned observables","suites":["Observable.prototype.partition"],"updatePoint":{"line":69,"column":53},"line":69,"code":"  it('should pass errors to both returned observables', () => {\n    const e1 =    hot('--a-b---#');\n    const e1subs =    '^       !';\n    const expected = ['--a-----#',\n                    '----b---#'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass errors to both returned observables if source throws","suites":["Observable.prototype.partition"],"updatePoint":{"line":83,"column":70},"line":83,"code":"  it('should pass errors to both returned observables if source throws', () => {\n    const e1 =   cold('#');\n    const e1subs =    '(^!)';\n    const expected = ['#',\n                    '#'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass errors to both returned observables if predicate throws","suites":["Observable.prototype.partition"],"updatePoint":{"line":97,"column":73},"line":97,"code":"  it('should pass errors to both returned observables if predicate throws', () => {\n    const e1 =    hot('--a-b--a--|');\n    const e1subs =    '^      !   ';\n    const expected = ['--a----#   ',\n                    '----b--#   '];\n\n    let index = 0;\n    const error = 'error';\n    function predicate(x: string) {\n      const match = x === 'a';\n      if (match && index++ > 1) {\n        throw error;\n      }\n      return match;\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition empty observable if source does not emits","suites":["Observable.prototype.partition"],"updatePoint":{"line":117,"column":64},"line":117,"code":"  it('should partition empty observable if source does not emits', () => {\n    const e1 =    hot('----|');\n    const e1subs =    '^   !';\n    const expected = ['----|',\n                    '----|'];\n\n    function predicate(x: string) {\n      return x === 'x';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition empty observable if source is empty","suites":["Observable.prototype.partition"],"updatePoint":{"line":131,"column":58},"line":131,"code":"  it('should partition empty observable if source is empty', () => {\n    const e1 =   cold('|');\n    const e1subs =    '(^!)';\n    const expected = ['|',\n                    '|'];\n\n    function predicate(x: string) {\n      return x === 'x';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition if source emits single elements","suites":["Observable.prototype.partition"],"updatePoint":{"line":145,"column":54},"line":145,"code":"  it('should partition if source emits single elements', () => {\n    const e1 =    hot('--a--|');\n    const e1subs =    '^    !';\n    const expected = ['--a--|',\n                    '-----|'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition if predicate matches all of source elements","suites":["Observable.prototype.partition"],"updatePoint":{"line":159,"column":66},"line":159,"code":"  it('should partition if predicate matches all of source elements', () => {\n    const e1 =    hot('--a--a--a--a--a--a--a--|');\n    const e1subs =    '^                      !';\n    const expected = ['--a--a--a--a--a--a--a--|',\n                    '-----------------------|'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition if predicate does not match all of source elements","suites":["Observable.prototype.partition"],"updatePoint":{"line":173,"column":73},"line":173,"code":"  it('should partition if predicate does not match all of source elements', () => {\n    const e1 =    hot('--b--b--b--b--b--b--b--|');\n    const e1subs =    '^                      !';\n    const expected = ['-----------------------|',\n                    '--b--b--b--b--b--b--b--|'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition to infinite observable if source does not completes","suites":["Observable.prototype.partition"],"updatePoint":{"line":187,"column":74},"line":187,"code":"  it('should partition to infinite observable if source does not completes', () => {\n    const e1 =    hot('--a-b---a------d----');\n    const e1subs =    '^                   ';\n    const expected = ['--a-----a-----------',\n                    '----b----------d----'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition to infinite observable if source never completes","suites":["Observable.prototype.partition"],"updatePoint":{"line":201,"column":71},"line":201,"code":"  it('should partition to infinite observable if source never completes', () => {\n    const e1 =   cold('-');\n    const e1subs =    '^';\n    const expected = ['-',\n                    '-'];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n\n    expectObservableArray(partition(e1, predicate), expected);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should partition into two observable with early unsubscription","suites":["Observable.prototype.partition"],"updatePoint":{"line":215,"column":68},"line":215,"code":"  it('should partition into two observable with early unsubscription', () => {\n    const e1 =    hot('--a-b---a------d-|');\n    const unsub =     '       !          ';\n    const e1subs =    '^      !          ';\n    const expected = ['--a-----          ',\n                    '----b---          '];\n\n    function predicate(x: string) {\n      return x === 'a';\n    }\n    const result = partition(e1, predicate);\n\n    for (let idx = 0; idx < result.length; idx++ ) {\n      expectObservable(result[idx], unsub).toBe(expected[idx]);\n    }\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["Observable.prototype.partition"],"updatePoint":{"line":233,"column":83},"line":233,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    const e1 =    hot('--a-b---a------d-|');\n    const e1subs =    '^      !          ';\n    const expected = ['--a-----          ',\n                    '----b---          '];\n    const unsub =     '       !          ';\n\n    const e1Pipe = e1.pipe(\n      mergeMap((x: string) => of(x))\n    );\n    const result = partition(e1Pipe, (x: string) => x === 'a');\n\n    expectObservable(result[0], unsub).toBe(expected[0]);\n    expectObservable(result[1], unsub).toBe(expected[1]);\n    expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept thisArg","suites":["Observable.prototype.partition"],"updatePoint":{"line":250,"column":27},"line":250,"code":"  it('should accept thisArg', () => {\n    const thisArg = {};\n\n    partition(of(1), function (this: any, value: number) {\n      expect(this).to.deep.equal(thisArg);\n      return true;\n    }, thisArg)\n      .forEach((observable: Observable<number>) => observable.subscribe());\n  });","file":"observables/partition-spec.ts","skipped":false,"dir":"spec"},{"name":"should race a single observable","suites":["static race"],"updatePoint":{"line":8,"column":37},"line":8,"code":"  it('should race a single observable', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race(e1);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race cold and cold","suites":["static race"],"updatePoint":{"line":19,"column":31},"line":19,"code":"  it('should race cold and cold', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const e2 =  cold('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race with array of observable","suites":["static race"],"updatePoint":{"line":33,"column":42},"line":33,"code":"  it('should race with array of observable', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const e2 =  cold('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race([e1, e2]);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and hot","suites":["static race"],"updatePoint":{"line":47,"column":29},"line":47,"code":"  it('should race hot and hot', () => {\n    const e1 =   hot('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const e2 =   hot('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and cold","suites":["static race"],"updatePoint":{"line":61,"column":30},"line":61,"code":"  it('should race hot and cold', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^                   !';\n    const e2 =   hot('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race 2nd and 1st","suites":["static race"],"updatePoint":{"line":75,"column":29},"line":75,"code":"  it('should race 2nd and 1st', () => {\n    const e1 =  cold('------x-----y-----z----|');\n    const e1subs =   '^  !';\n    const e2 =  cold('---a-----b-----c----|');\n    const e2subs =   '^                   !';\n    const expected = '---a-----b-----c----|';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should race emit and complete","suites":["static race"],"updatePoint":{"line":89,"column":35},"line":89,"code":"  it('should race emit and complete', () => {\n    const e1 =  cold('-----|');\n    const e1subs =   '^    !';\n    const e2 =   hot('------x-----y-----z----|');\n    const e2subs =   '^    !';\n    const expected = '-----|';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["static race"],"updatePoint":{"line":103,"column":53},"line":103,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    const e1 =  cold('---a-----b-----c----|');\n    const e1subs =   '^           !';\n    const e2 =   hot('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----b---';\n    const unsub =    '            !';\n\n    const result = race(e1, e2);\n\n    expectObservable(result, unsub).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["static race"],"updatePoint":{"line":118,"column":73},"line":118,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    const e1 =   hot('--a--^--b--c---d-| ');\n    const e1subs =        '^        !    ';\n    const e2 =   hot('---e-^---f--g---h-|');\n    const e2subs =        '^  !    ';\n    const expected =      '---b--c---    ';\n    const unsub =         '         !    ';\n\n    const result = race(\n        e1.pipe(mergeMap((x: string) => of(x))),\n        e2.pipe(mergeMap((x: string) => of(x)))\n    ).pipe(mergeMap((x: any) => of(x)));\n\n    expectObservable(result, unsub).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should never emit when given non emitting sources","suites":["static race"],"updatePoint":{"line":136,"column":55},"line":136,"code":"  it('should never emit when given non emitting sources', () => {\n    const e1 =  cold('---|');\n    const e2 =  cold('---|');\n    const e1subs =   '^  !';\n    const expected = '---|';\n\n    const source = race(e1, e2);\n\n    expectObservable(source).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs mid stream","suites":["static race"],"updatePoint":{"line":148,"column":47},"line":148,"code":"  it('should throw when error occurs mid stream', () => {\n    const e1 =  cold('---a-----#');\n    const e1subs =   '^        !';\n    const e2 =  cold('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---a-----#';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs before a winner is found","suites":["static race"],"updatePoint":{"line":162,"column":61},"line":162,"code":"  it('should throw when error occurs before a winner is found', () => {\n    const e1 =  cold('---#');\n    const e1subs =   '^  !';\n    const e2 =  cold('------x-----y-----z----|');\n    const e2subs =   '^  !';\n    const expected = '---#';\n\n    const result = race(e1, e2);\n\n    expectObservable(result).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"handle empty","suites":["static race"],"updatePoint":{"line":176,"column":18},"line":176,"code":"  it('handle empty', () => {\n    const e1 =  cold('|');\n    const e1subs =   '(^!)';\n    const expected = '|';\n\n    const source = race(e1);\n\n    expectObservable(source).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"handle never","suites":["static race"],"updatePoint":{"line":187,"column":18},"line":187,"code":"  it('handle never', () => {\n    const e1 =  cold('-');\n    const e1subs =   '^';\n    const expected = '-';\n\n    const source = race(e1);\n\n    expectObservable(source).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"handle throw","suites":["static race"],"updatePoint":{"line":198,"column":18},"line":198,"code":"  it('handle throw', () => {\n    const e1 =  cold('#');\n    const e1subs =   '(^!)';\n    const expected = '#';\n\n    const source = race(e1);\n\n    expectObservable(source).toBe(expected);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a single ObservableInput argument","suites":["static race"],"updatePoint":{"line":209,"column":54},"line":209,"code":"  it('should support a single ObservableInput argument', (done) => {\n    const source = race(Promise.resolve(42));\n    source.subscribe({ next: value => {\n      expect(value).to.equal(42);\n    }, error: done, complete: done });\n  });","file":"observables/race-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable with numbers 1 to 10","suites":["range"],"updatePoint":{"line":12,"column":54},"line":12,"code":"  it('should create an observable with numbers 1 to 10', () => {\n    const e1 = range(1, 10)\n      // for the purpose of making a nice diagram, spread out the synchronous emissions\n      .pipe(concatMap((x, i) => of(x).pipe(delay(i === 0 ? 0 : 20, rxTestScheduler))));\n    const expected = 'a-b-c-d-e-f-g-h-i-(j|)';\n    const values = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5,\n      f: 6,\n      g: 7,\n      h: 8,\n      i: 9,\n      j: 10,\n    };\n    expectObservable(e1).toBe(expected, values);\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for two subscribers","suites":["range"],"updatePoint":{"line":32,"column":37},"line":32,"code":"  it('should work for two subscribers', () => {\n    const e1 = range(1, 5)\n      .pipe(concatMap((x, i) => of(x).pipe(delay(i === 0 ? 0 : 20, rxTestScheduler))));\n    const expected = 'a-b-c-d-(e|)';\n    const values = {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: 5\n    };\n    expectObservable(e1).toBe(expected, values);\n    expectObservable(e1).toBe(expected, values);\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should synchronously create a range of values by default","suites":["range"],"updatePoint":{"line":47,"column":62},"line":47,"code":"  it('should synchronously create a range of values by default', () => {\n    const results = [] as any[];\n    range(12, 4).subscribe(function (x) {\n      results.push(x);\n    });\n    expect(results).to.deep.equal([12, 13, 14, 15]);\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a scheduler","suites":["range"],"updatePoint":{"line":55,"column":31},"line":55,"code":"  it('should accept a scheduler', (done) => {\n    const expected = [12, 13, 14, 15];\n    sinon.spy(asap, 'schedule');\n\n    const source = range(12, 4, asap);\n\n    source.subscribe({ next: function (x) {\n      expect(asap.schedule).have.been.called;\n      const exp = expected.shift();\n      expect(x).to.equal(exp);\n    }, error: function (x) {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      (<any>asap.schedule).restore();\n      done();\n    } });\n\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept only one argument where count is argument and start is zero","suites":["range"],"updatePoint":{"line":74,"column":79},"line":74,"code":"  it('should accept only one argument where count is argument and start is zero', () => {\n    const e1 = range(5)\n      .pipe(concatMap((x, i) => of(x).pipe(delay(i === 0 ? 0 : 20, rxTestScheduler))));\n    const expected = 'a-b-c-d-(e|)';\n    const values = {\n      a: 0,\n      b: 1,\n      c: 2,\n      d: 3,\n      e: 4\n    };\n    expectObservable(e1).toBe(expected, values);\n    expectObservable(e1).toBe(expected, values);\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should return empty for range(0)","suites":["range"],"updatePoint":{"line":89,"column":38},"line":89,"code":"  it('should return empty for range(0)', () => {\n    const results: any[] = [];\n    range(0).subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('done')\n    })\n    expect(results).to.deep.equal(['done'])\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should return empty for range with a negative count","suites":["range"],"updatePoint":{"line":98,"column":57},"line":98,"code":"  it('should return empty for range with a negative count', () => {\n    const results: any[] = [];\n    range(5, -5).subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('done')\n    })\n    expect(results).to.deep.equal(['done'])\n  });","file":"observables/range-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable that just emits an error","suites":["throwError"],"updatePoint":{"line":15,"column":62},"line":15,"code":"  it('should create a cold observable that just emits an error', () => {\n    rxTest.run(({ expectObservable }) => {\n      const expected = '#';\n      const e1 = throwError(() => 'error');\n      expectObservable(e1).toBe(expected);\n    });\n  });","file":"observables/throwError-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit one value","suites":["throwError"],"updatePoint":{"line":23,"column":27},"line":23,"code":"  it('should emit one value', (done) => {\n    let calls = 0;\n    throwError(() => 'bad').subscribe({\n      next: () => {\n        done(new Error('should not be called'));\n      },\n      error: (err) => {\n        expect(++calls).to.equal(1);\n        expect(err).to.equal('bad');\n        done();\n      },\n    });\n  });","file":"observables/throwError-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler","suites":["throwError"],"updatePoint":{"line":37,"column":29},"line":37,"code":"  it('should accept scheduler', () => {\n    rxTest.run(({ expectObservable }) => {\n      const e = throwError('error', rxTest);\n\n      expectObservable(e).toBe('#');\n    });\n  });","file":"observables/throwError-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a factory function","suites":["throwError"],"updatePoint":{"line":45,"column":38},"line":45,"code":"  it('should accept a factory function', () => {\n    let calls = 0;\n    let errors: any[] = [];\n\n    const source = throwError(() => ({\n      call: ++calls,\n      message: 'LOL',\n    }));\n\n    source.subscribe({\n      next: () => {\n        throw new Error('this should not happen');\n      },\n      error: (err) => {\n        errors.push(err);\n      },\n    });\n\n    source.subscribe({\n      next: () => {\n        throw new Error('this should not happen');\n      },\n      error: (err) => {\n        errors.push(err);\n      },\n    });\n\n    expect(errors).to.deep.equal([\n      {\n        call: 1,\n        message: 'LOL',\n      },\n      {\n        call: 2,\n        message: 'LOL',\n      },\n    ]);\n  });","file":"observables/throwError-spec.ts","skipped":false,"dir":"spec"},{"name":"should create an observable emitting periodically","suites":["timer"],"updatePoint":{"line":14,"column":55},"line":14,"code":"  it('should create an observable emitting periodically', () => {\n    rxTest.run(({ expectObservable }) => {\n      const e1 = timer(6, 2, rxTest).pipe(\n        take(4), // make it actually finite, so it can be rendered\n        concat(NEVER) // but pretend it's infinite by not completing\n      );\n      const expected = '------a-b-c-d-';\n      const values = {\n        a: 0,\n        b: 1,\n        c: 2,\n        d: 3,\n      };\n      expectObservable(e1).toBe(expected, values);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule a value of 0 then complete","suites":["timer"],"updatePoint":{"line":31,"column":48},"line":31,"code":"  it('should schedule a value of 0 then complete', () => {\n    rxTest.run(({ expectObservable }) => {\n      const dueTime = 5; // -----|\n      const expected = '    -----(x|)';\n\n      const source = timer(dueTime, undefined, rxTest);\n      expectObservable(source).toBe(expected, { x: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit a single value immediately","suites":["timer"],"updatePoint":{"line":41,"column":44},"line":41,"code":"  it('should emit a single value immediately', () => {\n    rxTest.run(({ expectObservable }) => {\n      const dueTime = 0;\n      const expected = '(x|)';\n\n      const source = timer(dueTime, rxTest);\n      expectObservable(source).toBe(expected, { x: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should start after delay and periodically emit values","suites":["timer"],"updatePoint":{"line":51,"column":59},"line":51,"code":"  it('should start after delay and periodically emit values', () => {\n    rxTest.run(({ expectObservable }) => {\n      const dueTime = 4; // ----|\n      const period = 2; //       -|-|-|-|\n      const expected = '    ----a-b-c-d-(e|)';\n\n      const source = timer(dueTime, period, rxTest).pipe(take(5));\n      const values = { a: 0, b: 1, c: 2, d: 3, e: 4 };\n      expectObservable(source).toBe(expected, values);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should start immediately and periodically emit values","suites":["timer"],"updatePoint":{"line":63,"column":59},"line":63,"code":"  it('should start immediately and periodically emit values', () => {\n    rxTest.run(({ expectObservable }) => {\n      const dueTime = 0; //|\n      const period = 3; //  --|--|--|--|\n      const expected = '   a--b--c--d--(e|)';\n\n      const source = timer(dueTime, period, rxTest).pipe(take(5));\n      const values = { a: 0, b: 1, c: 2, d: 3, e: 4 };\n      expectObservable(source).toBe(expected, values);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop emiting values when subscription is done","suites":["timer"],"updatePoint":{"line":75,"column":58},"line":75,"code":"  it('should stop emiting values when subscription is done', () => {\n    rxTest.run(({ expectObservable }) => {\n      const dueTime = 0; //|\n      const period = 3; //  --|--|--|--|\n      const expected = '   a--b--c--d--e';\n      const unsub = '      ^------------!';\n\n      const source = timer(dueTime, period, rxTest);\n      const values = { a: 0, b: 1, c: 2, d: 3, e: 4 };\n      expectObservable(source, unsub).toBe(expected, values);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule a value at a specified Date","suites":["timer"],"updatePoint":{"line":88,"column":49},"line":88,"code":"  it('should schedule a value at a specified Date', () => {\n    rxTest.run(({ expectObservable }) => {\n      const offset = 4; // ----|\n      const expected = '   ----(a|)';\n\n      const dueTime = new Date(rxTest.now() + offset);\n      const source = timer(dueTime, undefined, rxTest);\n      expectObservable(source).toBe(expected, { a: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should start after delay and periodically emit values","suites":["timer"],"updatePoint":{"line":99,"column":59},"line":99,"code":"  it('should start after delay and periodically emit values', () => {\n    rxTest.run(({ expectObservable }) => {\n      const offset = 4; // ----|\n      const period = 2; //      -|-|-|-|\n      const expected = '   ----a-b-c-d-(e|)';\n\n      const dueTime = new Date(rxTest.now() + offset);\n      const source = timer(dueTime, period, rxTest).pipe(take(5));\n      const values = { a: 0, b: 1, c: 2, d: 3, e: 4 };\n      expectObservable(source).toBe(expected, values);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept Infinity as the first argument","suites":["timer"],"updatePoint":{"line":128,"column":50},"line":128,"code":"  it('should accept Infinity as the first argument', () => {\n    rxTest.run(({ expectObservable }) => {\n      const source = timer(Infinity, undefined, rxTest);\n      const expected = '------';\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept Infinity as the second argument","suites":["timer"],"updatePoint":{"line":136,"column":51},"line":136,"code":"  it('should accept Infinity as the second argument', () => {\n    rxTest.run(({ expectObservable }) => {\n      rxTest.maxFrames = 20;\n      const source = timer(4, Infinity, rxTest);\n      const expected = '----a-';\n      expectObservable(source).toBe(expected, { a: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept negative numbers as the second argument, which should cause immediate completion","suites":["timer"],"updatePoint":{"line":145,"column":100},"line":145,"code":"  it('should accept negative numbers as the second argument, which should cause immediate completion', () => {\n    rxTest.run(({ expectObservable }) => {\n      const source = timer(4, -4, rxTest);\n      const expected = '----(a|)';\n      expectObservable(source).toBe(expected, { a: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept 0 as the second argument","suites":["timer"],"updatePoint":{"line":153,"column":44},"line":153,"code":"  it('should accept 0 as the second argument', () => {\n    rxTest.run(({ expectObservable }) => {\n      const source = timer(4, 0, rxTest).pipe(take(5));\n      const expected = '----(abcde|)';\n      expectObservable(source).toBe(expected, { a: 0, b: 1, c: 2, d: 3, e: 4 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit after a delay of 0 for Date objects in the past","suites":["timer"],"updatePoint":{"line":161,"column":65},"line":161,"code":"  it('should emit after a delay of 0 for Date objects in the past', () => {\n    rxTest.run(({ expectObservable }) => {\n      const expected = '(a|)';\n      const threeSecondsInThePast = new Date(rxTest.now() - 3000);\n      const source = timer(threeSecondsInThePast, undefined, rxTest);\n      expectObservable(source).toBe(expected, { a: 0 });\n    });\n  });","file":"observables/timer-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose of the resource when the subscription is disposed","suites":["using"],"updatePoint":{"line":6,"column":70},"line":6,"code":"  it('should dispose of the resource when the subscription is disposed', (done) => {\n    let disposed = false;\n    const source = using(\n      () => new Subscription(() => disposed = true),\n      (resource) => range(0, 3)\n    )\n    .pipe(take(2));\n\n    source.subscribe();\n\n    if (disposed) {\n      done();\n    } else {\n      done(new Error('disposed should be true but was false'));\n    }\n  });","file":"observables/using-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept factory returns promise resolves","suites":["using"],"updatePoint":{"line":23,"column":52},"line":23,"code":"  it('should accept factory returns promise resolves', (done) => {\n    const expected = 42;\n\n    let disposed = false;\n    const e1 = using(\n      () => new Subscription(() => disposed = true),\n      (resource) => new Promise((resolve: any) => { resolve(expected); }));\n\n    e1.subscribe({ next: x => {\n      expect(x).to.equal(expected);\n    }, error: (x) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"observables/using-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept factory returns promise rejects","suites":["using"],"updatePoint":{"line":40,"column":51},"line":40,"code":"  it('should accept factory returns promise rejects', (done) => {\n    const expected = 42;\n\n    let disposed = false;\n    const e1 = using(\n      () => new Subscription(() => disposed = true),\n      (resource) => new Promise((resolve: any, reject: any) => { reject(expected); }));\n\n    e1.subscribe({ next: x => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(expected);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/using-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when resource factory throws","suites":["using"],"updatePoint":{"line":58,"column":53},"line":58,"code":"  it('should raise error when resource factory throws', (done) => {\n    const expectedError = 'expected';\n    const error = 'error';\n\n    const source = using(\n      () => {\n        throw expectedError;\n      },\n      (resource) => {\n        throw error;\n      }\n    );\n\n    source.subscribe({ next: (x) => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(expectedError);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/using-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when observable factory throws","suites":["using"],"updatePoint":{"line":81,"column":55},"line":81,"code":"  it('should raise error when observable factory throws', (done) => {\n    const error = 'error';\n    let disposed = false;\n\n    const source = using(\n      () => new Subscription(() => disposed = true),\n      (resource) => {\n        throw error;\n      }\n    );\n\n    source.subscribe({ next: (x) => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(error);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"observables/using-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine a source with a second","suites":["static zip"],"updatePoint":{"line":9,"column":43},"line":9,"code":"  it('should combine a source with a second', () => {\n    const a =    hot('---1---2---3---');\n    const asubs =    '^';\n    const b =    hot('--4--5--6--7--8--');\n    const bsubs =    '^';\n    const expected = '---x---y---z';\n\n    expectObservable(zip(a, b))\n      .toBe(expected, { x: ['1', '4'], y: ['2', '5'], z: ['3', '6'] });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip the provided observables","suites":["static zip"],"updatePoint":{"line":22,"column":41},"line":22,"code":"  it('should zip the provided observables', (done) => {\n    const expected = ['a1', 'b2', 'c3'];\n    let i = 0;\n\n    zip(\n      from(['a', 'b', 'c']),\n      from([1, 2, 3]), (a: string, b: number) => a + b)\n        .subscribe({ next: (x: string) => {\n          expect(x).to.equal(expected[i++]);\n        }, complete: done });\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should end once one observable completes and its buffer is empty","suites":["static zip"],"updatePoint":{"line":34,"column":70},"line":34,"code":"  it('should end once one observable completes and its buffer is empty', () => {\n    const e1 =   hot('---a--b--c--|               ');\n    const e1subs =   '^           !               ';\n    const e2 =   hot('------d----e----f--------|  ');\n    const e2subs =   '^                 !         ';\n    const e3 =   hot('--------h----i----j---------'); // doesn't complete\n    const e3subs =   '^                 !         ';\n    const expected = '--------x----y----(z|)      '; // e1 complete and buffer empty\n    const values = {\n      x: ['a', 'd', 'h'],\n      y: ['b', 'e', 'i'],\n      z: ['c', 'f', 'j']\n    };\n\n    expectObservable(zip(e1, e2, e3)).toBe(expected, values);\n    expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    expectSubscriptions(e3.subscriptions).toBe(e3subs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip them with values","suites":["static zip","with iterables"],"updatePoint":{"line":76,"column":35},"line":76,"code":"    it('should zip them with values', () => {\n      const myIterator = (function *() {\n        for (let i = 0; i < 4; i++) {\n          yield i;\n        }\n      })();\n\n      const e1 =   hot('---a---b---c---d---|');\n      const e1subs =   '^              !';\n      const expected = '---w---x---y---(z|)';\n\n      const values = {\n        w: ['a', 0],\n        x: ['b', 1],\n        y: ['c', 2],\n        z: ['d', 3]\n      };\n\n      expectObservable(zip(e1, myIterator)).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":98,"column":60},"line":98,"code":"    it('should work with empty observable and empty iterable', () => {\n      const a = cold('|');\n      const asubs = '(^!)';\n      const b: number[] = [];\n      const expected = '|';\n\n      expectObservable(zip(a, b)).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and non-empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":108,"column":64},"line":108,"code":"    it('should work with empty observable and non-empty iterable', () => {\n      const a = cold('|');\n      const asubs = '(^!)';\n      const b = [1];\n      const expected = '|';\n\n      expectObservable(zip(a, b)).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete instantly if given an empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":118,"column":60},"line":118,"code":"    it('should complete instantly if given an empty iterable', () => {\n      const a = hot('---^----a--|');\n      const asubs =    '(^!)';\n      const b: number[] = [];\n      const expected = '|';\n\n      expectObservable(zip(a, b)).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never observable and non-empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":128,"column":64},"line":128,"code":"    it('should work with never observable and non-empty iterable', () => {\n      const a = cold('-');\n      const asubs = '^';\n      const b = [1];\n      const expected = '-';\n\n      expectObservable(zip(a, b)).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":138,"column":68},"line":138,"code":"    it('should work with non-empty observable and non-empty iterable', () => {\n      const a = hot('---^----1--|');\n      const asubs =    '^    !   ';\n      const b = [2];\n      const expected = '-----(x|)';\n\n      expectObservable(zip(a, b)).toBe(expected, { x: ['1', 2] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with observable which raises error and non-empty iterable","suites":["static zip","with iterables"],"updatePoint":{"line":148,"column":77},"line":148,"code":"    it('should work with observable which raises error and non-empty iterable', () => {\n      const a = hot('---^----#');\n      const asubs =    '^    !';\n      const b = [1];\n      const expected = '-----#';\n\n      expectObservable(zip(a, b)).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty many observable and non-empty many iterable","suites":["static zip","with iterables"],"updatePoint":{"line":158,"column":78},"line":158,"code":"    it('should work with non-empty many observable and non-empty many iterable', () => {\n      const a = hot('---^--1--2--3--|');\n      const asubs =    '^        !   ';\n      const b = [4, 5, 6];\n      const expected = '---x--y--(z|)';\n\n      expectObservable(zip(a, b)).toBe(expected,\n        { x: ['1', 4], y: ['2', 5], z: ['3', 6] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable selector that throws","suites":["static zip","with iterables"],"updatePoint":{"line":169,"column":89},"line":169,"code":"    it('should work with non-empty observable and non-empty iterable selector that throws', () => {\n      const a = hot('---^--1--2--3--|');\n      const asubs =    '^     !';\n      const b = [4, 5, 6];\n      const expected = '---x--#';\n\n      const selector = (x: string, y: number) => {\n        if (y === 5) {\n          throw new Error('too bad');\n        } else {\n          return x + y;\n        }};\n      expectObservable(zip(a, b, selector)).toBe(expected,\n        { x: '14' }, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two observables and selector","suites":["static zip","with iterables"],"updatePoint":{"line":187,"column":49},"line":187,"code":"  it('should combine two observables and selector', () => {\n    const a =    hot('---1---2---3---');\n    const asubs =    '^';\n    const b =    hot('--4--5--6--7--8--');\n    const bsubs =    '^';\n    const expected = '---x---y---z';\n\n    expectObservable(zip(a, b, (e1: string, e2: string) => e1 + e2))\n      .toBe(expected, { x: '14', y: '25', z: '36' });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric","suites":["static zip","with iterables"],"updatePoint":{"line":200,"column":38},"line":200,"code":"  it('should work with n-ary symmetric', () => {\n    const a = hot('---1-^-1----4----|');\n    const asubs =      '^         !  ';\n    const b = hot('---1-^--2--5----| ');\n    const bsubs =      '^         !  ';\n    const c = hot('---1-^---3---6-|  ');\n    const expected =   '----x---y-|  ';\n\n    expectObservable(zip(a, b, c)).toBe(expected,\n      { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric selector","suites":["static zip","with iterables"],"updatePoint":{"line":214,"column":47},"line":214,"code":"  it('should work with n-ary symmetric selector', () => {\n    const a = hot('---1-^-1----4----|');\n    const asubs =      '^         !  ';\n    const b = hot('---1-^--2--5----| ');\n    const bsubs =      '^         !  ';\n    const c = hot('---1-^---3---6-|  ');\n    const expected =   '----x---y-|  ';\n\n    const observable = zip(a, b, c,\n      (r0: string, r1: string, r2: string) => [r0, r1, r2]);\n    expectObservable(observable).toBe(expected,\n      { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric array selector","suites":["static zip","with iterables"],"updatePoint":{"line":230,"column":53},"line":230,"code":"  it('should work with n-ary symmetric array selector', () => {\n    const a = hot('---1-^-1----4----|');\n    const asubs =      '^         !  ';\n    const b = hot('---1-^--2--5----| ');\n    const bsubs =      '^         !  ';\n    const c = hot('---1-^---3---6-|  ');\n    const expected =   '----x---y-|  ';\n\n    const observable = zip(a, b, c,\n      (r0: string, r1: string, r2: string) => [r0, r1, r2]);\n    expectObservable(observable).toBe(expected,\n      { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 1","suites":["static zip","with iterables"],"updatePoint":{"line":246,"column":45},"line":246,"code":"  it('should work with some data asymmetric 1', () => {\n    const a = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n    const asubs =      '^                 !    ';\n    const b = hot('---1-^--2--4--6--8--0--|    ');\n    const bsubs =      '^                 !    ';\n    const expected =   '---a--b--c--d--e--|    ';\n\n    expectObservable(zip(a, b, (r1: string, r2: string) => r1 + r2))\n      .toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 2","suites":["static zip","with iterables"],"updatePoint":{"line":259,"column":45},"line":259,"code":"  it('should work with some data asymmetric 2', () => {\n    const a = hot('---1-^--2--4--6--8--0--|    ');\n    const asubs =      '^                 !    ';\n    const b = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n    const bsubs =      '^                 !    ';\n    const expected =   '---a--b--c--d--e--|    ';\n\n    expectObservable(zip(a, b, (r1: string, r2: string) => r1 + r2))\n      .toBe(expected, { a: '21', b: '43', c: '65', d: '87', e: '09' });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data symmetric","suites":["static zip","with iterables"],"updatePoint":{"line":272,"column":42},"line":272,"code":"  it('should work with some data symmetric', () => {\n    const a = hot('---1-^-1-3-5-7-9------| ');\n    const asubs =      '^                ! ';\n    const b = hot('---1-^--2--4--6--8--0--|');\n    const bsubs =      '^                ! ';\n    const expected =   '---a--b--c--d--e-| ';\n\n    expectObservable(zip(a, b, (r1: string, r2: string) => r1 + r2))\n      .toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with selector throws","suites":["static zip","with iterables"],"updatePoint":{"line":285,"column":38},"line":285,"code":"  it('should work with selector throws', () => {\n    const a = hot('---1-^-2---4----|  ');\n    const asubs =      '^       !     ';\n    const b = hot('---1-^--3----5----|');\n    const bsubs =      '^       !     ';\n    const expected =   '---x----#     ';\n\n    const selector = (x: string, y: string) => {\n      if (y === '5') {\n        throw new Error('too bad');\n      } else {\n        return x + y;\n      }};\n    const observable = zip(a, b, selector);\n    expectObservable(observable).toBe(expected,\n      { x: '23' }, new Error('too bad'));\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with right completes first","suites":["static zip","with iterables"],"updatePoint":{"line":305,"column":44},"line":305,"code":"  it('should work with right completes first', () => {\n    const a = hot('---1-^-2-----|');\n    const asubs =      '^     !';\n    const b = hot('---1-^--3--|');\n    const bsubs =      '^     !';\n    const expected =   '---x--|';\n\n    expectObservable(zip(a, b)).toBe(expected, { x: ['2', '3'] });\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["static zip","with iterables"],"updatePoint":{"line":317,"column":33},"line":317,"code":"  it('should work with two nevers', () => {\n    const a = cold(  '-');\n    const asubs =    '^';\n    const b = cold(  '-');\n    const bsubs =    '^';\n    const expected = '-';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["static zip","with iterables"],"updatePoint":{"line":329,"column":38},"line":329,"code":"  it('should work with never and empty', () => {\n    const a = cold(  '-');\n    const asubs =    '(^!)';\n    const b = cold(  '|');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["static zip","with iterables"],"updatePoint":{"line":341,"column":38},"line":341,"code":"  it('should work with empty and never', () => {\n    const a = cold(  '|');\n    const asubs =    '(^!)';\n    const b = cold(  '-');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["static zip","with iterables"],"updatePoint":{"line":353,"column":38},"line":353,"code":"  it('should work with empty and empty', () => {\n    const a = cold(  '|');\n    const asubs =    '(^!)';\n    const b = cold(  '|');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and non-empty","suites":["static zip","with iterables"],"updatePoint":{"line":365,"column":42},"line":365,"code":"  it('should work with empty and non-empty', () => {\n    const a = cold(  '|');\n    const asubs =    '(^!)';\n    const b = hot(   '---1--|');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and empty","suites":["static zip","with iterables"],"updatePoint":{"line":377,"column":42},"line":377,"code":"  it('should work with non-empty and empty', () => {\n    const a = hot(   '---1--|');\n    const asubs =    '(^!)';\n    const b = cold(  '|');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and non-empty","suites":["static zip","with iterables"],"updatePoint":{"line":389,"column":42},"line":389,"code":"  it('should work with never and non-empty', () => {\n    const a = cold(  '-');\n    const asubs =    '^';\n    const b = hot(   '---1--|');\n    const bsubs =    '^     !';\n    const expected = '-';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and never","suites":["static zip","with iterables"],"updatePoint":{"line":401,"column":42},"line":401,"code":"  it('should work with non-empty and never', () => {\n    const a = hot(   '---1--|');\n    const asubs =    '^     !';\n    const b = cold(  '-');\n    const bsubs =    '^';\n    const expected = '-';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["static zip","with iterables"],"updatePoint":{"line":413,"column":38},"line":413,"code":"  it('should work with empty and error', () => {\n    const a = cold(  '|');\n    const asubs =    '(^!)';\n    const b = hot(   '------#', undefined, 'too bad');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["static zip","with iterables"],"updatePoint":{"line":425,"column":38},"line":425,"code":"  it('should work with error and empty', () => {\n    const a = hot(   '------#', undefined, 'too bad');\n    const asubs =    '(^!)';\n    const b = cold(  '|');\n    const bsubs =    '(^!)';\n    const expected = '|';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["static zip","with iterables"],"updatePoint":{"line":437,"column":28},"line":437,"code":"  it('should work with error', () => {\n    const a =    hot('----------|');\n    const asubs =    '^     !    ';\n    const b =    hot('------#    ');\n    const bsubs =    '^     !    ';\n    const expected = '------#    ';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and error","suites":["static zip","with iterables"],"updatePoint":{"line":449,"column":38},"line":449,"code":"  it('should work with never and error', () => {\n    const a = cold(  '-');\n    const asubs =    '^     !';\n    const b =    hot('------#');\n    const bsubs =    '^     !';\n    const expected = '------#';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and never","suites":["static zip","with iterables"],"updatePoint":{"line":461,"column":38},"line":461,"code":"  it('should work with error and never', () => {\n    const a =    hot('------#');\n    const asubs =    '^     !';\n    const b = cold(  '-');\n    const bsubs =    '^     !';\n    const expected = '------#';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and error","suites":["static zip","with iterables"],"updatePoint":{"line":473,"column":38},"line":473,"code":"  it('should work with error and error', () => {\n    const a =    hot('------#', undefined, 'too bad');\n    const asubs =    '^     !';\n    const b =    hot('----------#', undefined, 'too bad 2');\n    const bsubs =    '^     !';\n    const expected = '------#';\n\n    expectObservable(zip(a, b)).toBe(expected, null, 'too bad');\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors","suites":["static zip","with iterables"],"updatePoint":{"line":485,"column":63},"line":485,"code":"  it('should work with two sources that eventually raise errors', () => {\n    const a =    hot('--w-----#----', { w: 1 }, 'too bad');\n    const asubs =    '^       !';\n    const b =    hot('-----z-----#-', { z: 2 }, 'too bad 2');\n    const bsubs =    '^       !';\n    const expected = '-----x--#';\n\n    expectObservable(zip(a, b)).toBe(expected, { x: [1, 2] }, 'too bad');\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors (swapped)","suites":["static zip","with iterables"],"updatePoint":{"line":497,"column":73},"line":497,"code":"  it('should work with two sources that eventually raise errors (swapped)', () => {\n    const a =    hot('-----z-----#-', { z: 2 }, 'too bad 2');\n    const asubs =    '^       !';\n    const b =    hot('--w-----#----', { w: 1 }, 'too bad');\n    const bsubs =    '^       !';\n    const expected = '-----x--#';\n\n    expectObservable(zip(a, b)).toBe(expected, { x: [2, 1] }, 'too bad');\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and some","suites":["static zip","with iterables"],"updatePoint":{"line":509,"column":37},"line":509,"code":"  it('should work with error and some', () => {\n    const a = cold(  '#');\n    const asubs =    '(^!)';\n    const b = hot(   '--1--2--3--');\n    const bsubs =    '(^!)';\n    const expected = '#';\n\n    expectObservable(zip(a, b)).toBe(expected);\n    expectSubscriptions(a.subscriptions).toBe(asubs);\n    expectSubscriptions(b.subscriptions).toBe(bsubs);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine an immediately-scheduled source with an immediately-scheduled second","suites":["static zip","with iterables"],"updatePoint":{"line":521,"column":89},"line":521,"code":"  it('should combine an immediately-scheduled source with an immediately-scheduled second', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [[1, 4], [2, 5], [3, 6]];\n    let i = 0;\n\n    zip(a, b).subscribe({ next: (vals: Array<number>) => {\n      expect(vals).to.deep.equal(r[i++]);\n    }, complete: done });\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to zip all iterables","suites":["static zip","with iterables"],"updatePoint":{"line":532,"column":41},"line":532,"code":"  it('should be able to zip all iterables', () => {\n    const results: any[] = [];\n    zip('abc', '123', 'xyz').subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('complete')\n    });\n    expect(results).to.deep.equal([\n      ['a','1','x'],\n      ['b','2','y'],\n      ['c','3','z'],\n      'complete'\n    ]);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should return EMPTY if passed an empty array as the only argument","suites":["static zip","with iterables"],"updatePoint":{"line":546,"column":71},"line":546,"code":"  it('should return EMPTY if passed an empty array as the only argument', () => {\n    const results: string[] = [];\n    zip([]).subscribe({\n      next: () => {\n        throw new Error('should not emit')\n      },\n      complete: () => {\n        results.push('done');\n      }\n    });\n\n    expect(results).to.deep.equal(['done']);\n  });","file":"observables/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last value in each time window","suites":["audit operator"],"updatePoint":{"line":15,"column":52},"line":15,"code":"  it('should emit the last value in each time window', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-xy-----b--x--cxyz-|');\n      const e1subs = '  ^--------------------!';\n      const e2 = cold('  ----i                ');\n      //                          ----i\n      //                                ----i\n      const e2subs = [\n        '               -^---!                ',\n        '               ----------^---!       ',\n        '               ----------------^---! ',\n      ];\n      const expected = '-----y--------x-----z|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay the source if values are not emitted often enough","suites":["audit operator"],"updatePoint":{"line":37,"column":68},"line":37,"code":"  it('should delay the source if values are not emitted often enough', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--------b-----c----|');\n      const e1subs = '  ^--------------------!';\n      const e2 = cold('  ----x                ');\n      const e2subs = [\n        '               -^---!                ',\n        '               ----------^---!       ',\n        '               ----------------^---! '\n      ];\n      const expected = '-----a--------b-----c|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should audit with duration Observable using next to close the duration","suites":["audit operator"],"updatePoint":{"line":57,"column":76},"line":57,"code":"  it('should audit with duration Observable using next to close the duration', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   -a-xy-----b--x--cxxx-|');\n      const e1subs = '   ^--------------------!';\n      const e2 = cold('   ----x-y-z            ');\n      const e2subs = [\n        '                -^---!                ',\n        '                ----------^---!       ',\n        '                ----------------^---! '\n      ];\n      const expected = ' -----y--------x-----x|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should interrupt source and duration when result is unsubscribed early","suites":["audit operator"],"updatePoint":{"line":77,"column":76},"line":77,"code":"  it('should interrupt source and duration when result is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-x-y-z-xyz-x-y-z----b--x-x-|');\n      const unsub = '   --------------!               ';\n      const e1subs = '  ^-------------!               ';\n      const e2 = cold('  -----x------------|          ');\n      const e2subs = [\n        '               -^----!                       ',\n        '               -------^----!                 ',\n        '               -------------^!               '\n      ];\n      const expected = '------y-----z--               ';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["audit operator"],"updatePoint":{"line":98,"column":83},"line":98,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-x-y-z-xyz-x-y-z----b--x-x-|');\n      const e1subs = '  ^-------------!               ';\n      const e2 = cold('  -----x------------|          ');\n      const e2subs = [\n        '               -^----!                       ',\n        '               -------^----!                 ',\n        '               -------------^!               '\n      ];\n      const expected = '------y-----z--               ';\n      const unsub = '   --------------!               ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        audit(() => e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a busy producer emitting a regular repeating sequence","suites":["audit operator"],"updatePoint":{"line":123,"column":73},"line":123,"code":"  it('should handle a busy producer emitting a regular repeating sequence', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|    ');\n      const e1subs = '  ^------------------------!    ';\n      const e2 = cold(' -----x                        ');\n      const e2subs = [\n        '               ^----!                        ',\n        '               ------^----!                  ',\n        '               ------------^----!            ',\n        '               ------------------^----!      ',\n        '               ------------------------^----!'\n      ];\n      const expected = '-----f-----f-----f-----f-----(a|)';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror source if durations are immediate","suites":["audit operator"],"updatePoint":{"line":145,"column":53},"line":145,"code":"  it('should mirror source if durations are immediate', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const e2 = cold(' x');\n      const expected = 'abcdefabcdefabcdefabcdefa|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit no values if durations are EMPTY","suites":["audit operator"],"updatePoint":{"line":159,"column":50},"line":159,"code":"  it('should emit no values if durations are EMPTY', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 =   hot('abcdefabcdefabcdefabcdefa|');\n      const e1subs =   '^------------------------!';\n      const e2 =  EMPTY;\n      const expected = '-------------------------|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit no values and never complete if duration is a never","suites":["audit operator"],"updatePoint":{"line":173,"column":69},"line":173,"code":"  it('should emit no values and never complete if duration is a never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^----------------------------!';\n      const e2 = cold(' -');\n      const e2subs = '  ----^-------------------------';\n      const expected = '------------------------------';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe duration Observable when source raise error","suites":["audit operator"],"updatePoint":{"line":189,"column":68},"line":189,"code":"  it('should unsubscribe duration Observable when source raise error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa#');\n      const e1subs = '  ^----------------------------!';\n      const e2 = cold(' -');\n      const e2subs = '  ----^------------------------!';\n      const expected = '-----------------------------#';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror source if durations are synchronous observables","suites":["audit operator"],"updatePoint":{"line":205,"column":67},"line":205,"code":"  it('should mirror source if durations are synchronous observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const e2 = of('one single value');\n      const expected = 'abcdefabcdefabcdefabcdefa|';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error as soon as just-throw duration is used","suites":["audit operator"],"updatePoint":{"line":219,"column":63},"line":219,"code":"  it('should raise error as soon as just-throw duration is used', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^---!                         ';\n      const e2 = cold(' #');\n      const e2subs = '  ----(^!)                      ';\n      const expected = '----(-#)                      ';\n\n      const result = e1.pipe(audit(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should audit using durations of varying lengths","suites":["audit operator"],"updatePoint":{"line":235,"column":53},"line":235,"code":"  it('should audit using durations of varying lengths', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdabcdefghabca|     ');\n      const e1subs = '  ^---------------------!     ';\n      const e2 = [\n        cold('          -----x                      '),\n        cold('              ---x                    '),\n        cold('                  -------x            '),\n        cold('                        --x           '),\n        cold('                           ----x      ')\n      ];\n      const e2subs =  [\n        '               ^----!                      ',\n        '               ------^--!                  ',\n        '               ----------^------!          ',\n        '               ------------------^-!       ',\n        '               ---------------------^---!  '\n      ];\n      const expected = '-----f---d-------h--c----(a|)';\n\n      let i = 0;\n      const result = e1.pipe(audit(() => e2[i++]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let j = 0; j < e2.length; j++) {\n        expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j]);\n      }\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from duration Observable","suites":["audit operator"],"updatePoint":{"line":266,"column":53},"line":266,"code":"  it('should propagate error from duration Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdabcdefghabca|');\n      const e1subs = '  ^----------------!     ';\n      const e2 = [\n        cold('          -----x                 '),\n        cold('              ---x               '),\n        cold('                  -------#       ')\n      ];\n      const e2subs = [\n        '               ^----!                 ',\n        '               ------^--!             ',\n        '               ----------^------!     '\n      ];\n      const expected = '-----f---d-------#     ';\n\n      let i = 0;\n      const result = e1.pipe(audit(() => e2[i++]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let j = 0; j < e2.length; j++) {\n        expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j]);\n      }\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from durationSelector function","suites":["audit operator"],"updatePoint":{"line":293,"column":66},"line":293,"code":"  it('should propagate error thrown from durationSelector function', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 =   hot('abcdefabcdabcdefghabca|   ');\n      const e1subs =   '^---------!               ';\n      const e2 = [\n        cold('          -----x                    '),\n        cold('              ---x                  '),\n        cold('                  -------x          ')\n      ];\n      const e2subs = [\n        '               ^----!                     ',\n        '               ------^--!                 '\n      ];\n      const expected = '-----f---d#                ';\n\n      let i = 0;\n      const result = e1.pipe(\n        audit(() => {\n          if (i === 2) {\n            throw 'error';\n          }\n          return e2[i++];\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let j = 0; j < e2subs.length; j++) {\n        expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j]);\n      }\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["audit operator"],"updatePoint":{"line":326,"column":47},"line":326,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const subs = '    ^----!';\n      const expected = '-----|';\n      function durationSelector() { return cold('-----|'); }\n\n      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["audit operator"],"updatePoint":{"line":338,"column":67},"line":338,"code":"  it('should raise error when source does not emit and raises error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----#');\n      const subs = '    ^----!';\n      const expected = '-----#';\n      function durationSelector() {\n        return cold('   -----|');\n      }\n\n      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["audit operator"],"updatePoint":{"line":352,"column":35},"line":352,"code":"  it('should handle an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const subs = '    (^!)';\n      const expected = '|';\n      function durationSelector() {\n        return cold('   -----|');\n      }\n\n      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["audit operator"],"updatePoint":{"line":366,"column":34},"line":366,"code":"  it('should handle a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const subs = '    ^';\n      const expected = '-';\n      function durationSelector() {\n        return cold('   -----|');\n      }\n\n      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a throw source","suites":["audit operator"],"updatePoint":{"line":380,"column":34},"line":380,"code":"  it('should handle a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const subs = '    (^!)';\n      const expected = '#';\n      function durationSelector() {\n        return cold('   -----|');\n      }\n\n      expectObservable(e1.pipe(audit(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should audit by promise resolves","suites":["audit operator"],"updatePoint":{"line":394,"column":38},"line":394,"code":"  it('should audit by promise resolves', (done) => {\n    const e1 = interval(10).pipe(take(5));\n    const expected = [0, 1, 2, 3, 4];\n\n    e1.pipe(\n      audit(() => Promise.resolve(42))\n    ).subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expected.shift()); }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(expected.length).to.equal(0);\n        done();\n      } }\n    );\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when promise rejects","suites":["audit operator"],"updatePoint":{"line":411,"column":45},"line":411,"code":"  it('should raise error when promise rejects', (done) => {\n    const e1 = interval(10).pipe(take(10));\n    const expected = [0, 1, 2];\n    const error = new Error('error');\n\n    e1.pipe(\n      audit((x: number) => {\n        if (x === 3) {\n          return new Promise((resolve: any, reject: any) => { reject(error); });\n        } else {\n          return new Promise((resolve: any) => { resolve(42); });\n        }\n      })\n    ).subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expected.shift()); }, error: (err: any) => {\n        expect(err).to.be.an('error', 'error');\n        expect(expected.length).to.equal(0);\n        done();\n      }, complete: () => {\n        done(new Error('should not be called'));\n      } }\n    );\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["audit operator"],"updatePoint":{"line":436,"column":73},"line":436,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      audit(() => of(0)),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit last value after duration completes if source completes first","suites":["audit operator"],"updatePoint":{"line":455,"column":79},"line":455,"code":"  it('should emit last value after duration completes if source completes first', () =>  {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 =   hot('-a--------xy|  ');\n      const e1subs = '  ^-----------!  ';\n      const e2 =  cold(' ----x         ');\n      const e2subs =  [\n        '               -^---!         ',\n        '               ----------^---!'\n      ];\n      const expected = '-----a--------(y|)';\n\n      const result = e1.pipe(audit(() =>  e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/audit-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last value in each time window","suites":["auditTime"],"updatePoint":{"line":16,"column":52},"line":16,"code":"  it('should emit the last value in each time window', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-x-y----b---x-cx---|');\n      const e1subs = '  ^--------------------!';\n      const t = time('   -----|               ');\n      //                          -----|\n      //                                -----|\n      const expected = '------y--------x-----(x|)';\n\n      const result = e1.pipe(auditTime(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should auditTime events by 5 time units","suites":["auditTime"],"updatePoint":{"line":32,"column":45},"line":32,"code":"  it('should auditTime events by 5 time units', (done) => {\n    const expected = 3;\n    of(1, 2, 3)\n      .pipe(auditTime(5))\n      .subscribe((x: number) => {\n        expect(x).to.equal(expected);\n        done();\n      });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should auditTime events multiple times","suites":["auditTime"],"updatePoint":{"line":42,"column":44},"line":42,"code":"  it('should auditTime events multiple times', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -012-----01234---|');\n      const e1subs = '  ^----------------!';\n      const t = time('   -----|           ');\n      //                         -----|\n      const expected = '------2-------4--|';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay the source if values are not emitted often enough","suites":["auditTime"],"updatePoint":{"line":55,"column":68},"line":55,"code":"  it('should delay the source if values are not emitted often enough', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--------b-----c----|');\n      const e1subs = '  ^--------------------!';\n      const t = time('   -----|               ');\n      //                          -----|\n      //                                -----|\n      const expected = '------a--------b-----(c|)';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a busy producer emitting a regular repeating sequence","suites":["auditTime"],"updatePoint":{"line":69,"column":73},"line":69,"code":"  it('should handle a busy producer emitting a regular repeating sequence', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const t = time('  -----|                    ');\n      //                      -----|\n      //                            -----|\n      //                                  -----|\n      //                                        -----|\n      const expected = '-----f-----f-----f-----f-----(a|)';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["auditTime"],"updatePoint":{"line":85,"column":47},"line":85,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const e1subs = '  ^----!';\n      const t = time('  --|   ');\n      const expected = '-----|';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["auditTime"],"updatePoint":{"line":97,"column":67},"line":97,"code":"  it('should raise error when source does not emit and raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----#');\n      const e1subs = '  ^----!';\n      const t = time('  --|   ');\n      const expected = '-----#';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["auditTime"],"updatePoint":{"line":109,"column":35},"line":109,"code":"  it('should handle an empty source', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const t = time('  ---|');\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["auditTime"],"updatePoint":{"line":121,"column":34},"line":121,"code":"  it('should handle a never source', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -  ');\n      const e1subs = '  ^  ';\n      const t = time('  --|');\n      const expected = '-  ';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a throw source","suites":["auditTime"],"updatePoint":{"line":133,"column":34},"line":133,"code":"  it('should handle a throw source', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const t = time('  ---|');\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source does not complete","suites":["auditTime"],"updatePoint":{"line":145,"column":55},"line":145,"code":"  it('should not complete when source does not complete', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--(bc)-------d----------------');\n      const e1subs = '  ^------------------------------!';\n      const t = time('   -----|                         ');\n      //                               -----|\n      const expected = '------c-------------d-----------';\n      const unsub = '   -------------------------------!';\n\n      expectObservable(e1.pipe(auditTime(t)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["auditTime"],"updatePoint":{"line":159,"column":83},"line":159,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--(bc)-------d----------------');\n      const e1subs = '  ^------------------------------!';\n      const t = time('   -----|                         ');\n      //                               -----|\n      const expected = '------c-------------d-----------';\n      const unsub = '   -------------------------------!';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        auditTime(t),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should auditTime values until source raises error","suites":["auditTime"],"updatePoint":{"line":179,"column":55},"line":179,"code":"  it('should auditTime values until source raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--(bc)-------d---------------#');\n      const e1subs = '  ^------------------------------!';\n      const t = time('   -----|                         ');\n      //                               -----|\n      const expected = '------c-------------d----------#';\n\n      expectObservable(e1.pipe(auditTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/auditTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers that close and reopen","suites":["Observable.prototype.buffer"],"updatePoint":{"line":16,"column":47},"line":16,"code":"  it('should emit buffers that close and reopen', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('   -a-b-c-d-e-f-g-h-i-|');\n      const b = hot('   -----B-----B-----B-|');\n      const expected = '-----x-----y-----z-(F|)';\n      const expectedValues = {\n        x: ['a', 'b', 'c'],\n        y: ['d', 'e', 'f'],\n        z: ['g', 'h', 'i'],\n        F: [],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit a final buffer if the closingNotifier is already complete","suites":["Observable.prototype.buffer"],"updatePoint":{"line":31,"column":75},"line":31,"code":"  it('should emit a final buffer if the closingNotifier is already complete', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('   -a-b-c-d-e-f-g-h-i-|');\n      const b = hot('   -----B-----B--|');\n      const expected = '-----x-----y-------(F|)';\n      const expectedValues = {\n        x: ['a', 'b', 'c'],\n        y: ['d', 'e', 'f'],\n        F: ['g', 'h', 'i'],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit all buffered values if the source completes before the closingNotifier does","suites":["Observable.prototype.buffer"],"updatePoint":{"line":45,"column":93},"line":45,"code":"  it('should emit all buffered values if the source completes before the closingNotifier does', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('---^---a---b---c---d---e--f----|');\n      const sourceSubs = '   ^---------------------------!';\n      const closer = hot('---^-------------B----------------');\n      const closerSubs = '   ^---------------------------!';\n      const expected = '     --------------x-------------(F|)';\n\n      const result = source.pipe(buffer(closer));\n\n      const expectedValues = {\n        x: ['a', 'b', 'c'],\n        F: ['d', 'e', 'f'],\n      };\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closer.subscriptions).toBe(closerSubs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":66,"column":47},"line":66,"code":"  it('should work with empty and empty selector', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const a = EMPTY;\n      const b = EMPTY;\n      const expected = '(F|)';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] });\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and non-empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":75,"column":51},"line":75,"code":"  it('should work with empty and non-empty selector', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = EMPTY;\n      const b = hot('-----a-----');\n      const expected = '(F|)';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] });\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":84,"column":51},"line":84,"code":"  it('should work with non-empty and empty selector', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const b = EMPTY;\n      const expected = '     --------------------------------(F|)';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, {\n        F: ['3', '4', '5', '6', '7', '8', '9', '0'],\n      });\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and never selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":95,"column":47},"line":95,"code":"  it('should work with never and never selector', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const a = NEVER;\n      const b = NEVER;\n      const expected = '-';\n      expectObservable(a.pipe(buffer(b))).toBe(expected);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":104,"column":47},"line":104,"code":"  it('should work with never and empty selector', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const a = NEVER;\n      const b = EMPTY;\n      const expected = '-';\n      expectObservable(a.pipe(buffer(b))).toBe(expected);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":113,"column":47},"line":113,"code":"  it('should work with empty and never selector', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const a = EMPTY;\n      const b = NEVER;\n      const expected = '(F|)';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, { F: [] });\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and throw selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":122,"column":51},"line":122,"code":"  it('should work with non-empty and throw selector', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('---^--a--');\n      const b = throwError(() => new Error('too bad'));\n      const expected = '#';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, null, new Error('too bad'));\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and non-empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":131,"column":51},"line":131,"code":"  it('should work with throw and non-empty selector', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = throwError(() => new Error('too bad'));\n      const b = hot('---^--a--');\n      const expected = '#';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, null, new Error('too bad'));\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["Observable.prototype.buffer"],"updatePoint":{"line":140,"column":28},"line":140,"code":"  it('should work with error', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('---^-------#', undefined, new Error('too bad'));\n      const b = hot('---^--------');\n      const expected = '--------#';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, null, new Error('too bad'));\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and non-empty selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":149,"column":51},"line":149,"code":"  it('should work with error and non-empty selector', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('---^-------#', undefined, new Error('too bad'));\n      const b = hot('---^---a----');\n      const expected = '----a---#';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, { a: [] }, new Error('too bad'));\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with selector","suites":["Observable.prototype.buffer"],"updatePoint":{"line":158,"column":31},"line":158,"code":"  it('should work with selector', () => {\n    // Buffer Boundaries Simple (RxJS 4)\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const b = hot('--------^--a-------b---cd---------e---f---|');\n      const expected = '     ---a-------b---cd---------e---f-(F|)';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n        c: ['6'],\n        d: [] as string[],\n        e: ['7', '8', '9'],\n        f: ['0'],\n        F: [],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with selector completed","suites":["Observable.prototype.buffer"],"updatePoint":{"line":177,"column":41},"line":177,"code":"  it('should work with selector completed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const subs = '         ^-------------------------------!';\n      const b = hot('--------^--a-------b---cd|               ');\n      const expected = '     ---a-------b---cd---------------(F|)';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n        c: ['6'],\n        d: [] as string[],\n        F: ['7', '8', '9', '0'],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues);\n      expectSubscriptions(a.subscriptions).toBe(subs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing the result Observable early","suites":["Observable.prototype.buffer"],"updatePoint":{"line":195,"column":60},"line":195,"code":"  it('should allow unsubscribing the result Observable early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const unsub = '        --------------!                  ';\n      const subs = '         ^-------------!                  ';\n      const b = hot('--------^--a-------b---cd|               ');\n      const expected = '     ---a-------b---                  ';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n      };\n      expectObservable(a.pipe(buffer(b)), unsub).toBe(expected, expectedValues);\n      expectSubscriptions(a.subscriptions).toBe(subs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["Observable.prototype.buffer"],"updatePoint":{"line":211,"column":73},"line":211,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const subs = '         ^-------------!                  ';\n      const b = hot('--------^--a-------b---cd|               ');\n      const expected = '     ---a-------b---                  ';\n      const unsub = '        --------------!                  ';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n      };\n\n      const result = a.pipe(\n        mergeMap((x: any) => of(x)),\n        buffer(b),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(a.subscriptions).toBe(subs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and selector error","suites":["Observable.prototype.buffer"],"updatePoint":{"line":234,"column":51},"line":234,"code":"  it('should work with non-empty and selector error', () => {\n    // Buffer Boundaries onErrorSource (RxJS 4)\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('--1--2--^--3-----#', { '3': 3 }, new Error('too bad'));\n      const subs = '         ^--------!';\n      const b = hot('--------^--a--b---');\n      const expected = '     ---a--b--#';\n      const expectedValues = {\n        a: [3],\n        b: [] as string[],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(subs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and empty selector error","suites":["Observable.prototype.buffer"],"updatePoint":{"line":250,"column":57},"line":250,"code":"  it('should work with non-empty and empty selector error', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const b = hot('--------^----------------#', undefined, new Error('too bad'));\n      const expected = '     -----------------#';\n      expectObservable(a.pipe(buffer(b))).toBe(expected, null, new Error('too bad'));\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and selector error","suites":["Observable.prototype.buffer"],"updatePoint":{"line":259,"column":51},"line":259,"code":"  it('should work with non-empty and selector error', () => {\n    // Buffer Boundaries onErrorBoundaries (RxJS 4)\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const obj = { a: true, b: true, c: true };\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const subs = '         ^----------------!';\n      const b = hot('--------^--a-------b---c-#', obj, new Error('too bad'));\n      const expected = '     ---a-------b---c-#';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n        c: ['6'],\n      };\n      expectObservable(a.pipe(buffer(b))).toBe(expected, expectedValues, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(subs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe notifier when source unsubscribed","suites":["Observable.prototype.buffer"],"updatePoint":{"line":277,"column":58},"line":277,"code":"  it('should unsubscribe notifier when source unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('--1--2--^--3--4--5---6----7--8--9---0---|');\n      const unsub = '        --------------!                  ';\n      const subs = '         ^-------------!                  ';\n      const b = hot('--------^--a-------b---cd|               ');\n      const bsubs = '        ^-------------!                  ';\n      const expected = '     ---a-------b---                  ';\n      const expectedValues = {\n        a: ['3'],\n        b: ['4', '5'],\n      };\n\n      expectObservable(a.pipe(buffer(b)), unsub).toBe(expected, expectedValues);\n      expectSubscriptions(a.subscriptions).toBe(subs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe notifier when source unsubscribed","suites":["Observable.prototype.buffer"],"updatePoint":{"line":296,"column":58},"line":296,"code":"  it('should unsubscribe notifier when source unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   -a-b-c-d-e-f-g-h-i-|');\n      const b = hot('   -----1-----2-----3-|');\n      const bsubs = '   ^----!';\n      const expected = '-----(x|)';\n      const expectedValues = {\n        x: ['a', 'b', 'c'],\n      };\n\n      expectObservable(a.pipe(buffer(b), take(1))).toBe(expected, expectedValues);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit properly with an observable using itself as a notifier","suites":["Observable.prototype.buffer"],"updatePoint":{"line":311,"column":72},"line":311,"code":"  it('should emit properly with an observable using itself as a notifier', () => {\n    const results: any[] = [];\n    const subject = new Subject<number>();\n\n    subject.pipe(buffer(subject)).subscribe({\n      next: (value) => results.push(value),\n      complete: () => results.push('complete'),\n    });\n\n    subject.next(1);\n    expect(results).to.deep.equal([[1]]);\n    subject.next(2);\n    expect(results).to.deep.equal([[1], [2]]);\n    subject.complete();\n    expect(results).to.deep.equal([[1], [2], [], 'complete']);\n  });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should be equivalent for case ","suites":["Observable.prototype.buffer","equivalence with the window operator"],"updatePoint":{"line":348,"column":48},"line":348,"code":"      it(`should be equivalent for case ${index}`, () => {\n        testScheduler.run(({ hot, expectObservable }) => {\n          const a = hot(source);\n          const b = hot(notifier);\n          expectObservable(a.pipe(buffer(b))).toEqual(\n            a.pipe(\n              window(b),\n              mergeMap((w) => w.pipe(toArray()))\n            )\n          );\n        });\n      });","file":"operators/buffer-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals","suites":["bufferCount operator"],"updatePoint":{"line":15,"column":38},"line":15,"code":"  it('should emit buffers at intervals', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const values = {\n        v: ['a', 'b', 'c'],\n        w: ['c', 'd', 'e'],\n        x: ['e', 'f', 'g'],\n        y: ['g', 'h', 'i'],\n        z: ['i']\n      };\n      const e1 = hot('  --a--b--c--d--e--f--g--h--i--|');\n      const expected = '--------v-----w-----x-----y--(z|)';\n\n      expectObservable(e1.pipe(bufferCount(3, 2))).toBe(expected, values);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at buffersize of intervals if not specified","suites":["bufferCount operator"],"updatePoint":{"line":31,"column":69},"line":31,"code":"  it('should emit buffers at buffersize of intervals if not specified', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n        const values = {\n        x: ['a', 'b'],\n        y: ['c', 'd'],\n        z: ['e', 'f']\n      };\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const expected = '-----x-----y-----z--|';\n\n      expectObservable(e1.pipe(bufferCount(2))).toBe(expected, values);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should buffer properly (issue #2062)","suites":["bufferCount operator"],"updatePoint":{"line":45,"column":42},"line":45,"code":"  it('should buffer properly (issue #2062)', () => {\n    const item$ = new Subject<number>();\n    const results: any[] = [];\n    item$.pipe(\n      bufferCount(3, 1)\n    ).subscribe(value => {\n        results.push(value);\n\n        if (value.join() === '1,2,3') {\n          item$.next(4);\n        }\n      });\n\n    item$.next(1);\n    item$.next(2);\n    item$.next(3);\n\n    expect(results).to.deep.equal([[1, 2, 3], [2, 3, 4]]);\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit partial buffers if source completes before reaching specified buffer count","suites":["bufferCount operator"],"updatePoint":{"line":65,"column":92},"line":65,"code":"  it('should emit partial buffers if source completes before reaching specified buffer count', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const expected = '--------------(x|)';\n\n      expectObservable(e1.pipe(bufferCount(5))).toBe(expected, {x: ['a', 'b', 'c', 'd']});\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit full buffer then last partial buffer if source completes","suites":["bufferCount operator"],"updatePoint":{"line":74,"column":74},"line":74,"code":"  it('should emit full buffer then last partial buffer if source completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a^-b--c--d--e--|');\n      const e1subs = '     ^-------------!';\n      const expected = '   --------y-----(z|)';\n\n      expectObservable(e1.pipe(bufferCount(3))).toBe(expected, {y: ['b', 'c', 'd'], z: ['e']});\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals, but stop when result is unsubscribed early","suites":["bufferCount operator"],"updatePoint":{"line":85,"column":82},"line":85,"code":"  it('should emit buffers at intervals, but stop when result is unsubscribed early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        v: ['a', 'b', 'c'],\n        w: ['c', 'd', 'e']\n      };\n      const e1 = hot('  --a--b--c--d--e--f--g--h--i--|');\n      const unsub = '   ------------------!           ';\n      const subs = '    ^-----------------!           ';\n      const expected = '--------v-----w----           ';\n\n      expectObservable(e1.pipe(bufferCount(3, 2)), unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["bufferCount operator"],"updatePoint":{"line":101,"column":83},"line":101,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        v: ['a', 'b', 'c'],\n        w: ['c', 'd', 'e']\n      };\n      const e1 = hot('  --a--b--c--d--e--f--g--h--i--|');\n      const subs = '    ^-----------------!           ';\n      const expected = '--------v-----w----           ';\n      const unsub = '   ------------------!           ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        bufferCount(3, 2),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raise error before reaching specified buffer count","suites":["bufferCount operator"],"updatePoint":{"line":123,"column":85},"line":123,"code":"  it('should raise error if source raise error before reaching specified buffer count', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--#');\n      const e1subs = '  ^-------------!';\n      const expected = '--------------#';\n\n      expectObservable(e1.pipe(bufferCount(5))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers with specified skip count when skip count is less than window count","suites":["bufferCount operator"],"updatePoint":{"line":134,"column":93},"line":134,"code":"  it('should emit buffers with specified skip count when skip count is less than window count', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        v: ['a', 'b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['c', 'd', 'e'],\n        y: ['d', 'e'],\n        z: ['e']\n      };\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^----------------!';\n      const expected = '--------v--w--x--(yz|)';\n\n      expectObservable(e1.pipe(bufferCount(3, 1))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers with specified skip count when skip count is more than window count","suites":["bufferCount operator"],"updatePoint":{"line":152,"column":93},"line":152,"code":"  it('should emit buffers with specified skip count when skip count is more than window count', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n    const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^----------------!';\n      const expected = '-----y--------z--|';\n      const values = {\n        y: ['a', 'b'],\n        z: ['d', 'e']\n      };\n\n      expectObservable(e1.pipe(bufferCount(2, 3))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["bufferCount operator"],"updatePoint":{"line":167,"column":73},"line":167,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      bufferCount(1),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/bufferCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals","suites":["bufferTime operator"],"updatePoint":{"line":15,"column":38},"line":15,"code":"  it('should emit buffers at intervals', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---d---e---f---g-----|   ');\n      const subs = '    ^--------------------------------!   ';\n      const t = time('  ----------|                          ');\n      const expected = '----------w---------x---------y--(z|)';\n      const values = {\n        w: ['a', 'b'],\n        x: ['c', 'd', 'e'],\n        y: ['f', 'g'],\n        z: [] as string[]\n      };\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals test 2","suites":["bufferTime operator"],"updatePoint":{"line":35,"column":45},"line":35,"code":"  it('should emit buffers at intervals test 2', () => {\n    testScheduler.run(({ hot, time, expectObservable }) => {\n      const e1 = hot('  ---------a---------b---------c---------d---------e---------g--------|   ');\n      const t = time('  --------------------------------|                                       ');\n      const expected = '--------------------------------x-------------------------------y---(z|)';\n      const values = {\n        x: ['a', 'b', 'c'],\n        y: ['d', 'e', 'g'],\n        z: [] as string[]\n      };\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals or when the buffer is full","suites":["bufferTime operator"],"updatePoint":{"line":52,"column":65},"line":52,"code":"  it('should emit buffers at intervals or when the buffer is full', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---d---e---f---g-----|   ');\n      const subs = '    ^--------------------------------!   ';\n      const t = time('  ----------|                          ');\n      //                       ----------|\n      //                               ----------|\n      //                                       ----------|\n      const expected = '-------w-------x-------y---------(z|)';\n      const values = {\n        w: ['a', 'b'],\n        x: ['c', 'd'],\n        y: ['e', 'f'],\n        z: ['g']\n      };\n\n      const result = e1.pipe(bufferTime(t, null, 2, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle situations with a creation interval of zero","suites":["bufferTime operator"],"updatePoint":{"line":75,"column":63},"line":75,"code":"  it('should handle situations with a creation interval of zero', (done) => {\n    // This is an odd scenario, and I can't imagine who is weird enough to want this, but here\n    // it is. Someone scheduling buffers to open and close on microtasks, with values emitted on microtasks\n    // NOTE: Trying this with a completely synchronous scheduler (like queueScheduler, which is\n    // async relative to what it is scheduling, but synchronous relative to its container) will\n    // cause your thread to lock up. Don't be weird. This test is just to prove behavior.\n    const source = scheduled([0, 1, 2, 3, 4], asapScheduler);\n    const results: any[] = [];\n    source.pipe(\n      bufferTime(0, 0, asapScheduler),\n    )\n    .subscribe({\n      next: value => results.push(value),\n      complete: () => {\n        expect(results).to.deep.equal([\n          // It opens one on 0 and closes it on 0\n          [],\n          // It opens one on 0, emits on 0, and closes on 0 (x 5)\n          [0],\n          [1],\n          [2],\n          [3],\n          [4],\n          // It opens one on 0, and then completes on 0, leaving us with an empty array.\n          []\n        ]);\n        done();\n      }\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers at intervals or when the buffer is full test 2","suites":["bufferTime operator"],"updatePoint":{"line":106,"column":72},"line":106,"code":"  it('should emit buffers at intervals or when the buffer is full test 2', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---d---e---f---g-----|   ');\n      const subs = '    ^--------------------------------!   ';\n      const t = time('  ----------|                          ');\n      //                          ---------|---------|---------|\n      const expected = '----------w--------x---------y---(z|)';\n      const values = {\n        w: ['a', 'b'],\n        x: ['c', 'd', 'e'],\n        y: ['f', 'g'],\n        z: [] as string[]\n      };\n\n      const result = e1.pipe(bufferTime(t, null, 3, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers that have been created at intervals and close after the specified delay","suites":["bufferTime operator"],"updatePoint":{"line":127,"column":97},"line":127,"code":"  it('should emit buffers that have been created at intervals and close after the specified delay', () => {\n    testScheduler.run(({ hot, time, expectObservable }) => {\n      const e1 = hot('       ---a---b---c----d----e----f----g----h----i----(k|)');\n      //                     --------------------*--------------------*----  start interval\n      //                     ---------------------|                          timespans\n      //                                         ---------------------|\n      //                                                              -----|\n      const t = time('       ---------------------|                            ');\n      const interval = time('--------------------|                             ');\n      const expected = '     ---------------------x-------------------y----(z|)';\n      const values = {\n        x: ['a', 'b', 'c', 'd', 'e'],\n        y: ['e', 'f', 'g', 'h', 'i'],\n        z: ['i', 'k']\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers that have been created at intervals and close after the specified delay or when the buffer is full","suites":["bufferTime operator"],"updatePoint":{"line":149,"column":124},"line":149,"code":"  it('should emit buffers that have been created at intervals and close after the specified delay or when the buffer is full', () => {\n    testScheduler.run(({ hot, time, expectObservable }) => {\n      const e1 = hot('  ---a---b---c----d----e----f----g----h----i----(k|)');\n      //                --------------------*--------------------*----  start interval\n      //                ---------------------|                          timespans\n      //                                    ---------------------|\n      //                                                         -----|\n      const t = time('  ---------------------|                            ');\n      const interval = time('                --------------------|        ');\n      const expected = '----------------x-------------------y---------(z|)';\n      const values = {\n        x: ['a', 'b', 'c', 'd'],\n        y: ['e', 'f', 'g', 'h'],\n        z: ['i', 'k']\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, 4, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers with timeSpan 10 and creationInterval 7","suites":["bufferTime operator"],"updatePoint":{"line":171,"column":65},"line":171,"code":"  it('should emit buffers with timeSpan 10 and creationInterval 7', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--1--^2--3---4---5--6--7---8----9------------|   ');\n      //                   -------*------*------*------*------*----- creation interval\n      //                   ----------|                               timespans\n      //                          ----------|\n      //                                 ----------|\n      //                                        ----------|\n      //                                               ----------|\n      //                                                      ----------|\n      const e1subs = '     ^---------------------------------------!   ';\n      const t = time('     ----------|');\n      const interval = time('        -------|');\n      const expected = '   ----------a------b------c------d------e-(f|)';\n      const values = {\n        a: ['2', '3', '4'],\n        b: ['4', '5', '6'],\n        c: ['6', '7', '8'],\n        d: ['8', '9'],\n        e: [] as string[],\n        f: [] as string[]\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers but handle source ending with an error","suites":["bufferTime operator"],"updatePoint":{"line":201,"column":64},"line":201,"code":"  it('should emit buffers but handle source ending with an error', () => {\n    testScheduler.run(({ hot, time, expectObservable }) => {\n      const e1 = hot('--1--^2--3---4---5--6--7---8----9------------#');\n      //                   -------*------*------*------*------*----- creation interval\n      //                   ----------|                               timespans\n      //                          ----------|\n      //                                 ----------|\n      //                                        ----------|\n      //                                               ----------|\n      //                                                      ----------|\n      const t = time('     ----------|');\n      const interval = time('        -------|');\n      const expected = '   ----------a------b------c------d------e-#';\n      const values = {\n        a: ['2', '3', '4'],\n        b: ['4', '5', '6'],\n        c: ['6', '7', '8'],\n        d: ['8', '9'],\n        e: [] as string[]\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers and allow result to unsubscribed early","suites":["bufferTime operator"],"updatePoint":{"line":228,"column":64},"line":228,"code":"  it('should emit buffers and allow result to unsubscribed early', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--1--^2--3---4---5--6--7---8----9------------|');\n      const unsub = '      -----------------!                       ';\n      const subs = '       ^----------------!                       ';\n      //                   -------*------*------*------*------*----- creation interval\n      //                   ----------|                               timespans\n      //                          ----------|\n      //                                 ----------|\n      const t = time('     ----------|                              ');\n      const interval = time('        -------|                       ');\n      const expected = '   ----------a------                        ';\n      const values = {\n        a: ['2', '3', '4']\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["bufferTime operator"],"updatePoint":{"line":251,"column":83},"line":251,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--1--^2--3---4---5--6--7---8----9------------|');\n      const subs = '       ^---------------!                        ';\n      //                   -------*------*------*------*------*----- creation interval\n      //                   ----------|                               timespans\n      //                          ----------|\n      //                                 ----------|\n      const t = time('     ----------|');\n      const interval = time('        -------|');\n      const expected = '   ----------a------                        ';\n      const unsub = '      ----------------!                        ';\n      const values = {\n        a: ['2', '3', '4']\n      };\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        bufferTime(t, interval, Infinity, testScheduler),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["bufferTime operator"],"updatePoint":{"line":278,"column":25},"line":278,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '(b|)';\n      const values = { b: [] as string[] };\n      const t = time('----------|');\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["bufferTime operator"],"updatePoint":{"line":293,"column":25},"line":293,"code":"  it('should handle never', () => {\n    testScheduler.run(({ cold, time, expectObservable }) => {\n      const e1 = cold('-');\n      const unsub = '   --------------------------------------------!';\n      const t = time('  ----------|                                  ');\n      const expected = '----------a---------a---------a---------a----';\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result, unsub).toBe(expected, { a: [] });\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["bufferTime operator"],"updatePoint":{"line":306,"column":25},"line":306,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ time, expectObservable }) => {\n      const e1 = throwError(() => new Error('haha'));\n      const expected = '#';\n      const t = time('----------|');\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, undefined, new Error('haha'));\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["bufferTime operator"],"updatePoint":{"line":318,"column":26},"line":318,"code":"  it('should handle errors', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---#');\n      const e1subs = '  ^--------------!';\n      const t = time('  ----------|');\n      const expected = '----------w----#';\n      const values = {\n        w: ['a', 'b']\n      };\n\n      const result = e1.pipe(bufferTime(t, null, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers that have been created at intervals and close after the specified delay with errors","suites":["bufferTime operator"],"updatePoint":{"line":335,"column":109},"line":335,"code":"  it('should emit buffers that have been created at intervals and close after the specified delay with errors', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       ---a---b---c----d----e----f----g----h----i--#');\n      //                     --------------------|-------------------|-------------------| interval\n      //                     ---------------------|\n      //                                         ---------------------|\n      //                                                             ---------------------| timespan\n      const e1subs = '       ^-------------------------------------------!';\n      const t = time('       ---------------------|                       ');\n      const interval = time('                --------------------|   ');\n      const expected = '     ---------------------x-------------------y--#';\n      const values = {\n        x: ['a', 'b', 'c', 'd', 'e'],\n        y: ['e', 'f', 'g', 'h', 'i']\n      };\n\n      const result = e1.pipe(bufferTime(t, interval, Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not throw when subscription synchronously unsubscribed after emit","suites":["bufferTime operator"],"updatePoint":{"line":358,"column":78},"line":358,"code":"  it('should not throw when subscription synchronously unsubscribed after emit', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---d---e---f---g-----|');\n      const subs = '    ^-------------------!             ';\n      const t = time('  ----------|                       ');\n      const expected = '----------w---------(x|)          ';\n      const values = {\n        w: ['a', 'b'],\n        x: ['c', 'd', 'e']\n      };\n\n      const result = e1.pipe(\n        bufferTime(t, null, Infinity, testScheduler),\n        take(2)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not have errors when take follows and maxBufferSize is provided","suites":["bufferTime operator"],"updatePoint":{"line":379,"column":76},"line":379,"code":"  it('should not have errors when take follows and maxBufferSize is provided', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const tick = 1;\n      const buffTime = 5;\n      const expected = '-----a----b----c----d----(e|)';\n      const values = {\n        a: [0, 1, 2, 3],\n        b: [4, 5, 6, 7, 8],\n        c: [9, 10, 11, 12, 13],\n        d: [14, 15, 16, 17, 18],\n        e: [19, 20, 21, 22, 23]\n      };\n\n      const source = interval(tick, testScheduler).pipe(\n        bufferTime(buffTime, null, 10, testScheduler),\n        take(5)\n      );\n\n      expectObservable(source).toBe(expected, values);\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not mutate the buffer on reentrant next","suites":["bufferTime operator"],"updatePoint":{"line":401,"column":52},"line":401,"code":"  it('should not mutate the buffer on reentrant next', () => {\n    testScheduler.run(({ expectObservable, time }) => {\n      const subject = new Subject<number>();\n      const t1 = time(' -|');\n      const t2 = time(' --|');\n      const expected = '--(a|)';\n      const result = subject.pipe(\n        bufferTime(t2),\n        tap(() => subject.next(2)),\n        take(1)\n      );\n      testScheduler.schedule(() => subject.next(1), t1);\n      expectObservable(result).toBe(expected, { a: [1] });\n    });\n  });","file":"operators/bufferTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using hot openings and hot closings","suites":["bufferToggle operator"],"updatePoint":{"line":15,"column":61},"line":15,"code":"  it('should emit buffers using hot openings and hot closings', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  ---a---b---c---d---e---f---g---|');\n      const e2 = hot('  --o------------------o---------|');\n      const e3 = hot('  ---------c---------------c-----|');\n      const expected = '---------x---------------y-----|';\n      const values = {\n        x: ['a', 'b'],\n        y: ['f'],\n      };\n\n      const result = e1.pipe(bufferToggle(e2, (x: any) => e3));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying cold closings","suites":["bufferToggle operator"],"updatePoint":{"line":59,"column":53},"line":59,"code":"  it('should emit buffers using varying cold closings', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const subs = '       ^----------------------------------!      ';\n      const closings = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)')\n      ];\n      const closeSubs = [\n        '                 --^--------------!                         ',\n        '                 --------------^---!                        ',\n        '                 -----------------------^-----------!       '\n      ];\n      const expected = '  -----------------ij----------------(k|)    ';\n      const values = {\n        i: ['b', 'c', 'd', 'e'],\n        j: ['e'],\n        k: ['g', 'h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying hot closings","suites":["bufferToggle operator"],"updatePoint":{"line":92,"column":52},"line":92,"code":"  it('should emit buffers using varying hot closings', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|   ');\n      const e2 = cold('    --x-----------y--------z---|           ');\n      const subs = '       ^----------------------------------!   ';\n      const closings = [\n        {\n          obs: hot('   -1--^----------------s-|                   '),\n          sub: '           --^--------------!                     '\n        },\n        {\n          obs: hot('       -----3----4-------(s|)                 '),\n          sub: '           --------------^---!                    '\n        },\n        {\n          obs: hot('       -------3----4-------5----------------s|'),\n          sub: '           -----------------------^-----------!   '\n        }\n      ];\n\n      const expected = '   -----------------ij----------------(k|)';\n      const values = {\n        i: ['b', 'c', 'd', 'e'],\n        j: ['e'],\n        k: ['g', 'h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++].obs));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      for (let j = 0; j < closings.length; j++) {\n        expectSubscriptions(closings[j].obs.subscriptions).toBe(closings[j].sub);\n      }\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying empty delayed closings","suites":["bufferToggle operator"],"updatePoint":{"line":130,"column":62},"line":130,"code":"  it('should emit buffers using varying empty delayed closings', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|     ');\n      const e2 = cold('    --x-----------y--------z---|             ');\n      const subs = '       ^----------------------------------!     ';\n      const closings = [\n        cold('               ---------------|                       '),\n        cold('                           ----|                      '),\n        cold('                                    ---------------|  ')\n      ];\n      const expected = '   -----------------------------------(ijk|)';\n      const values = {\n        i: ['b', 'c', 'd', 'e', 'f', 'g', 'h'],\n        j: ['e', 'f', 'g', 'h'],\n        k: ['g', 'h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying cold closings, outer unsubscribed early","suites":["bufferToggle operator"],"updatePoint":{"line":155,"column":79},"line":155,"code":"  it('should emit buffers using varying cold closings, outer unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const subs = '       ^---------!                               ';\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const closings = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)')\n      ];\n      const csub0 = '      --^-------!                               ';\n      const expected = '   -----------                               ';\n      const unsub = '      ----------!                               ';\n      const values = {\n        i: ['b', 'c', 'd', 'e']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(csub0);\n      expectSubscriptions(closings[1].subscriptions).toBe([]);\n      expectSubscriptions(closings[2].subscriptions).toBe([]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["bufferToggle operator"],"updatePoint":{"line":183,"column":83},"line":183,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const subs = '       ^-----------------!                       ';\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const closings = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)')\n      ];\n      const expected = '   -----------------i-                       ';\n      const unsub = '      ------------------!                       ';\n      const values = {\n        i: ['b', 'c', 'd', 'e']\n      };\n\n      let i = 0;\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        bufferToggle(e2, () => closings[i++]),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from closingSelector","suites":["bufferToggle operator"],"updatePoint":{"line":211,"column":56},"line":211,"code":"  it('should propagate error thrown from closingSelector', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const subs = '       ^-------------!                           ';\n      const closings = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)')\n      ];\n      const closeSubs0 = ' --^-----------!                           ';\n      const expected = '   --------------#                           ';\n\n      let i = 0;\n      const result = e1.pipe(\n        bufferToggle(e2, () => {\n          if (i === 1) {\n            throw 'error';\n          }\n          return closings[i++];\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs0);\n      expectSubscriptions(closings[1].subscriptions).toBe([]);\n      expectSubscriptions(closings[2].subscriptions).toBe([]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted from a closing","suites":["bufferToggle operator"],"updatePoint":{"line":242,"column":51},"line":242,"code":"  it('should propagate error emitted from a closing', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e2 = cold('    --x-----------y--------z---|        ');\n      const subs = '       ^-------------!                     ';\n      const closings = [\n        cold('               ---------------s--|               '),\n        cold('                           #                     ')\n      ];\n      const closeSubs = [\n        '                  --^-----------!                     ',\n        '                  --------------(^!)                  '\n      ];\n      const expected = '   --------------#                     ';\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted late from a closing","suites":["bufferToggle operator"],"updatePoint":{"line":267,"column":56},"line":267,"code":"  it('should propagate error emitted late from a closing', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e2 = cold('    --x-----------y--------z---|        ');\n      const subs = '       ^------------------!                ';\n      const closings = [\n        cold('               ---------------s--|               '),\n        cold('                           -----#                ')\n      ];\n      const closeSubs = [\n        '                  --^--------------!                  ',\n        '                  --------------^----!                '\n      ];\n      const expected = '   -----------------i-#                ';\n      const values = {\n        i: ['b', 'c', 'd', 'e']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["bufferToggle operator"],"updatePoint":{"line":295,"column":26},"line":295,"code":"  it('should handle errors', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e--#        ');\n      const e2 = cold('    --x-----------y--------z---|');\n      const subs = '       ^------------------!        ';\n      const closings = [\n        cold('               ---------------s--|       '),\n        cold('                           -------s|     ')\n      ];\n      const closeSubs = [\n        '                  --^--------------!          ',\n        '                  --------------^----!        '\n      ];\n      const expected = '   -----------------i-#        ';\n      const values = {\n        i: ['b', 'c', 'd', 'e']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty source","suites":["bufferToggle operator"],"updatePoint":{"line":323,"column":32},"line":323,"code":"  it('should handle empty source', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' |');\n      const e2 = cold(' --o-----|');\n      const e3 = cold('   -----c--|');\n      const expected = '|';\n      const values = { x: [] as string[] };\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["bufferToggle operator"],"updatePoint":{"line":337,"column":25},"line":337,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' #');\n      const e2 = cold(' --o-----|');\n      const e3 = cold('   -----c--|');\n      const expected = '#';\n      const values = { x: [] as string[] };\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["bufferToggle operator"],"updatePoint":{"line":351,"column":25},"line":351,"code":"  it('should handle never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e2 = cold(' --o-----o------o-----o---o-----|');\n      const e3 = cold('   --c-|');\n      //                        --c-|\n      //                               --c-|\n      //                                     --c-|\n      //                                         --c-|\n      const unsub = '   --------------------------------------------!';\n      const subs = '    ^-------------------------------------------!';\n      const expected = '----x-----x------x-----x---x-----------------';\n      const values = { x: [] as string[] };\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never opening Observable","suites":["bufferToggle operator"],"updatePoint":{"line":372,"column":46},"line":372,"code":"  it('should handle a never opening Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e2 = cold('    -');\n      const e3 =  cold('   --c-|');\n      const expected = '   -----------------------------------|';\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never closing Observable","suites":["bufferToggle operator"],"updatePoint":{"line":385,"column":46},"line":385,"code":"  it('should handle a never closing Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|    ');\n      const e2 = cold('    ---o---------------o-----------|        ');\n      const e3 = cold('    -');\n      const expected = '   -----------------------------------(xy|)';\n      const values = {\n        x: ['b', 'c', 'd', 'e', 'f', 'g', 'h'],\n        y: ['f', 'g', 'h']\n      };\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle opening Observable that just throws","suites":["bufferToggle operator"],"updatePoint":{"line":402,"column":55},"line":402,"code":"  it('should handle opening Observable that just throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     (^!)';\n      const e2 = cold('    #');\n      const e2subs = '     (^!)';\n      const e3 = cold('    --c-|');\n      const expected = '   #';\n\n      const result = e1.pipe(bufferToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept openings resolved promise","suites":["bufferToggle operator"],"updatePoint":{"line":419,"column":45},"line":419,"code":"  it('should accept openings resolved promise', (done) => {\n    const e1 = concat(\n      timer(10).pipe(mapTo(1)),\n      timer(100).pipe(mapTo(2)),\n      timer(150).pipe(mapTo(3)),\n      timer(200).pipe(mapTo(4))\n    );\n\n    const expected = [[1]];\n\n    e1.pipe(\n      bufferToggle(new Promise((resolve: any) => { resolve(42); }), () => {\n        return timer(50);\n      })\n    ).subscribe({ next: (x) => {\n      expect(x).to.deep.equal(expected.shift());\n    }, error: (x) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      expect(expected.length).to.be.equal(0);\n      done();\n    } });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept openings rejected promise","suites":["bufferToggle operator"],"updatePoint":{"line":443,"column":45},"line":443,"code":"  it('should accept openings rejected promise', (done) => {\n    const e1 = concat(of(1),\n      timer(10).pipe(mapTo(2)),\n      timer(10).pipe(mapTo(3)),\n      timer(100).pipe(mapTo(4))\n    );\n\n    const expected = 42;\n\n    e1.pipe(\n      bufferToggle(new Promise((resolve: any, reject: any) => { reject(expected); }), () => {\n        return timer(50);\n      })\n    ).subscribe({ next: (x) => {\n      done(new Error('should not be called'));\n    }, error: (x) => {\n      expect(x).to.equal(expected);\n      done();\n    }, complete: () => {\n      done(new Error('should not be called'));\n    } });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept closing selector that returns a resolved promise","suites":["bufferToggle operator"],"updatePoint":{"line":466,"column":68},"line":466,"code":"  it('should accept closing selector that returns a resolved promise', (done) => {\n    const e1 = concat(of(1),\n      timer(10).pipe(mapTo(2)),\n      timer(10).pipe(mapTo(3)),\n      timer(100).pipe(mapTo(4))\n    );\n    const expected = [[1]];\n\n    e1.pipe(bufferToggle(of(10), () => new Promise((resolve: any) => { resolve(42); })))\n      .subscribe({ next: (x) => {\n        expect(x).to.deep.equal(expected.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(expected.length).to.be.equal(0);\n        done();\n      } });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept closing selector that returns a rejected promise","suites":["bufferToggle operator"],"updatePoint":{"line":485,"column":68},"line":485,"code":"  it('should accept closing selector that returns a rejected promise', (done) => {\n    const e1 = concat(of(1),\n      timer(10).pipe(mapTo(2)),\n      timer(10).pipe(mapTo(3)),\n      timer(100).pipe(mapTo(4))\n      );\n\n    const expected = 42;\n\n    e1.pipe(bufferToggle(of(10), () => new Promise((resolve: any, reject: any) => { reject(expected); })))\n      .subscribe({ next: (x) => {\n        done(new Error('should not be called'));\n      }, error: (x) => {\n        expect(x).to.equal(expected);\n        done();\n      }, complete: () => {\n        done(new Error('should not be called'));\n      } });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty closing observable","suites":["bufferToggle operator"],"updatePoint":{"line":505,"column":44},"line":505,"code":"  it('should handle empty closing observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|     ');\n      const subs = '       ^----------------------------------!     ';\n      const e2 = cold('    --x-----------y--------z---|             ');\n      const expected = '   -----------------------------------(ijk|)';\n      const values = {\n        i: ['b', 'c', 'd', 'e', 'f', 'g', 'h'],\n        j: ['e', 'f', 'g', 'h'],\n        k: ['g', 'h']\n      };\n\n      const result = e1.pipe(bufferToggle(e2, () => EMPTY));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers that close and reopen","suites":["bufferWhen operator"],"updatePoint":{"line":15,"column":47},"line":15,"code":"  it('should emit buffers that close and reopen', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---------|   ');\n      const e2 = cold('    --------------(s|)                    ');\n      //                                 --------------(s |)\n      const expected = '   --------------x-------------y-----(z|)';\n      const values = {\n        x: ['b', 'c', 'd'],\n        y: ['e', 'f', 'g'],\n        z: [] as string[]\n      };\n\n      expectObservable(e1.pipe(bufferWhen(() => e2))).toBe(expected, values);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying cold closings","suites":["bufferWhen operator"],"updatePoint":{"line":31,"column":53},"line":31,"code":"  it('should emit buffers using varying cold closings', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const subs = '       ^----------------------------------!      ';\n      const closings = [\n        cold('             ---------------s--|                       '),\n        cold('                            ----------(s|)             '),\n        cold('                                      -------------(s|)')];\n      const expected = '   ---------------x---------y---------(z|)   ';\n      const values = {\n        x: ['b', 'c', 'd'],\n        y: ['e', 'f', 'g'],\n        z: ['h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying hot closings","suites":["bufferWhen operator"],"updatePoint":{"line":54,"column":52},"line":54,"code":"  it('should emit buffers using varying hot closings', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|   ');\n      const subs = '       ^----------------------------------!   ';\n      const closings = [\n        {\n          obs: hot('   -1--^--------------s---|                   '),\n          sub: '           ^--------------!                       '\n        },\n        {\n          obs: hot('   --1-^----3--------4----------s-|           '),\n          sub: '           ---------------^---------!             '\n        },\n        {\n          obs: hot('   1-2-^------3----4-------5--6-----------s--|'),\n          sub: '           -------------------------^---------!   '\n        }\n      ];\n      const expected = '   ---------------x---------y---------(z|)';\n      const values = {\n        x: ['b', 'c', 'd'],\n        y: ['e', 'f', 'g'],\n        z: ['h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++].obs));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      for (let j = 0; j < closings.length; j++) {\n        expectSubscriptions(closings[j].obs.subscriptions).toBe(closings[j].sub);\n      }\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit buffers using varying empty delayed closings","suites":["bufferWhen operator"],"updatePoint":{"line":90,"column":66},"line":90,"code":"  it('should not emit buffers using varying empty delayed closings', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|   ');\n      const subs = '       ^----------------------------------!   ';\n      const closings = [\n        cold('             ---------------|                       '),\n        cold('                            ----------|             '),\n        cold('                                      -------------|')\n      ];\n      const closeSubs =  [\n        '                  ^--------------!                       ',\n        '                                                         ',\n        '                                                         ',\n      ];\n      const expected = '   -----------------------------------(x|)';\n      const values = {\n        x: ['b', 'c', 'd', 'e', 'f', 'g', 'h']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit buffers using varying cold closings, outer unsubscribed early","suites":["bufferWhen operator"],"updatePoint":{"line":120,"column":79},"line":120,"code":"  it('should emit buffers using varying cold closings, outer unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const unsub = '      ------------------!                       ';\n      const subs = '       ^-----------------!                       ';\n      const closings = [\n        cold('             ---------------(s|)                       '),\n        cold('                            ----------(s|)             '),\n        cold('                                      -------------(s|)')\n      ];\n      const closeSubs =  [\n        '                  ^--------------!                          ',\n        '                  ---------------^--!                       '\n      ];\n      const expected = '   ---------------x---                       ';\n      const values = {\n        x: ['b', 'c', 'd']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe([]);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["bufferWhen operator"],"updatePoint":{"line":150,"column":83},"line":150,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const subs = '       ^-----------------!                       ';\n      const closings = [\n        cold('             ---------------(s|)                       '),\n        cold('                            ----------(s|)             '),\n        cold('                                      -------------(s|)')\n      ];\n      const closeSubs = [\n        '                  ^--------------!                          ',\n        '                  ---------------^--!                       '\n      ];\n      const expected = '   ---------------x---                       ';\n      const unsub = '      ------------------!                       ';\n      const values = {\n        x: ['b', 'c', 'd']\n      };\n\n      let i = 0;\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        bufferWhen(() => closings[i++]),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe([]);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from closingSelector","suites":["bufferWhen operator"],"updatePoint":{"line":184,"column":56},"line":184,"code":"  it('should propagate error thrown from closingSelector', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const subs = '       ^--------------!                          ';\n      const closings = [\n        cold('             ---------------s--|                       '),\n        cold('                            ----------(s|)             '),\n        cold('                                      -------------(s|)')\n      ];\n      const closeSubs0 = ' ^--------------!                          ';\n      const expected = '   ---------------(x#)                       ';\n      const values = { x: ['b', 'c', 'd'] };\n\n      let i = 0;\n      const result = e1.pipe(\n        bufferWhen(() => {\n          if (i === 1) {\n            throw 'error';\n          }\n          return closings[i++];\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs0);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted from a closing","suites":["bufferWhen operator"],"updatePoint":{"line":213,"column":51},"line":213,"code":"  it('should propagate error emitted from a closing', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const subs = '       ^--------------!                    ';\n      const closings = [\n        cold('             ---------------s--|                 '),\n        cold('                            #                    ')\n      ];\n      const closeSubs =  [\n        '                  ^--------------!                    ',\n        '                  ---------------(^!)                 '\n      ];\n      const expected = '   ---------------(x#)                 ';\n      const values = {\n        x: ['b', 'c', 'd']\n      };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted late from a closing","suites":["bufferWhen operator"],"updatePoint":{"line":240,"column":56},"line":240,"code":"  it('should propagate error emitted late from a closing', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const subs = '       ^--------------------!              ';\n      const closings = [\n        cold('             ---------------s--|                 '),\n        cold('                            ------#              ')\n      ];\n      const closeSubs = [\n        '                  ^--------------!                    ',\n        '                  ---------------^-----!              '\n      ];\n      const expected =    '---------------x-----#              ';\n      const values = { x: ['b', 'c', 'd'] };\n\n      let i = 0;\n      const result = e1.pipe(bufferWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["bufferWhen operator"],"updatePoint":{"line":265,"column":26},"line":265,"code":"  it('should handle errors', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---#');\n      const e2 = cold('    ---------------(s|)      ');\n      //                                ---------------(s|)\n      const e2subs = [\n        '                  ^--------------!         ',\n        '                  ---------------^--------!'\n      ];\n      const expected = '   ---------------x--------#';\n      const values = {\n        x: ['b', 'c', 'd']\n      };\n\n      const result = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["bufferWhen operator"],"updatePoint":{"line":286,"column":25},"line":286,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e2 = cold(' --------(s|)');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n      const values = {\n        x: [] as string[]\n      };\n\n      const result = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["bufferWhen operator"],"updatePoint":{"line":303,"column":25},"line":303,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e2 = cold(' --------(s|)');\n      const e1subs = '  (^!)';\n      const expected = '#';\n      const values = {\n        x: [] as string[]\n      };\n\n      const result = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["bufferWhen operator"],"updatePoint":{"line":320,"column":25},"line":320,"code":"  it('should handle never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const unsub = '   --------------------------------------------!';\n      const e1subs = '  ^-------------------------------------------!';\n      const e2 = cold(' --------(s|)                                 ');\n      const e2subs = [\n        '               ^-------!                                    ',\n        '               --------^-------!                            ',\n        '               ----------------^-------!                    ',\n        '               ------------------------^-------!            ',\n        '               --------------------------------^-------!    ',\n        '               ----------------------------------------^---!'\n      ];\n      const expected = '--------x-------x-------x-------x-------x----';\n      const values = {\n        x: [] as string[]\n      };\n\n      const source = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(source, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an inner never","suites":["bufferWhen operator"],"updatePoint":{"line":347,"column":34},"line":347,"code":"  it('should handle an inner never', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e2 = cold('-');\n      const expected = '   -----------------------------------(x|)';\n      const values = {\n        x: ['b', 'c', 'd', 'e', 'f', 'g', 'h']\n      };\n\n      expectObservable(e1.pipe(bufferWhen(() => e2))).toBe(expected, values);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT handle synchronous inner","suites":["bufferWhen operator"],"updatePoint":{"line":364,"column":41},"line":364,"code":"  it('should NOT handle synchronous inner', (done) => {\n    const source = of(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    const closing = of(1);\n    const TOO_MANY_INVOCATIONS = 30;\n\n    source.pipe(\n      bufferWhen(() => closing),\n      takeWhile((val: any, index: number) => index < TOO_MANY_INVOCATIONS)\n    ).subscribe({ next: (val: any) => {\n      expect(Array.isArray(val)).to.be.true;\n      expect(val.length).to.equal(0);\n    }, error: (err: any) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle inner throw","suites":["bufferWhen operator"],"updatePoint":{"line":382,"column":31},"line":382,"code":"  it('should handle inner throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     (^!)';\n      const e2 = cold('    #');\n      const e2subs = '     (^!)';\n      const expected = '   #';\n      const values = {\n        x: ['b', 'c', 'd', 'e', 'f', 'g', 'h']\n      };\n\n      const result = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle disposing of source","suites":["bufferWhen operator"],"updatePoint":{"line":401,"column":39},"line":401,"code":"  it('should handle disposing of source', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const subs = '       ^-------------------!';\n      const unsub = '      --------------------!';\n      const e2 = cold('    ---------------(s|)');\n      //                                  ---------------(s|)\n      const expected = '   ---------------x-----';\n      const values = {\n        x: ['b', 'c', 'd'],\n        y: ['e', 'f', 'g', 'h'],\n        z: [] as string[]\n      };\n\n      const source = e1.pipe(bufferWhen(() => e2));\n\n      expectObservable(source, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/bufferWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch error and replace with a cold Observable","suites":["catchError operator"],"updatePoint":{"line":18,"column":59},"line":18,"code":"  it('should catch error and replace with a cold Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const e1 = hot('  --a--b--#       ');\n      const e2 = cold('         -1-2-3-|');\n      const expected = '--a--b---1-2-3-|';\n\n      const result = e1.pipe(catchError((err: any) => e2));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch error and replace it with Observable.of()","suites":["catchError operator"],"updatePoint":{"line":30,"column":60},"line":30,"code":"  it('should catch error and replace it with Observable.of()', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--------|');\n      const subs = '    ^-------!';\n      const expected = '--a--b--(XYZ|)';\n\n      const result = e1.pipe(\n        map((n: string) => {\n          if (n === 'c') {\n            throw 'bad';\n          }\n          return n;\n        }),\n        catchError((err: any) => {\n          return of('X', 'Y', 'Z');\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch error and replace it with a cold Observable","suites":["catchError operator"],"updatePoint":{"line":53,"column":62},"line":53,"code":"  it('should catch error and replace it with a cold Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#          ');\n      const e1subs = '  ^-------!          ';\n      const e2 = cold('         1-2-3-4-5-|');\n      const e2subs = '  --------^---------!';\n      const expected = '--a--b--1-2-3-4-5-|';\n\n      const result = e1.pipe(catchError((err: any) => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["catchError operator"],"updatePoint":{"line":69,"column":53},"line":69,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1-2-3-4-5-6---#');\n      const e1subs = '  ^------!         ';\n      const expected = '--1-2-3-         ';\n      const unsub = '   -------!         ';\n\n      const result = e1.pipe(\n        catchError(() => {\n          return of('X', 'Y', 'Z');\n        })\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["catchError operator"],"updatePoint":{"line":87,"column":72},"line":87,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1-2-3-4-5-6---#');\n      const e1subs = '  ^------!         ';\n      const expected = '--1-2-3-         ';\n      const unsub = '   -------!         ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        catchError(() => {\n          return of('X', 'Y', 'Z');\n        }),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from a caught hot caught observable when unsubscribed explicitly","suites":["catchError operator"],"updatePoint":{"line":107,"column":89},"line":107,"code":"  it('should unsubscribe from a caught hot caught observable when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -1-2-3-#          ');\n      const e1subs = '  ^------!          ';\n      const e2 = hot('  ---3-4-5-6-7-8-9-|');\n      const e2subs = '  -------^----!     ';\n      const expected = '-1-2-3-5-6-7-     ';\n      const unsub = '   ------------!     ';\n\n      const result = e1.pipe(catchError(() => e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from a caught cold caught observable when unsubscribed explicitly","suites":["catchError operator"],"updatePoint":{"line":124,"column":90},"line":124,"code":"  it('should unsubscribe from a caught cold caught observable when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -1-2-3-#          ');\n      const e1subs = '  ^------!          ';\n      const e2 =  cold('       5-6-7-8-9-|');\n      const e2subs = '  -------^----!     ';\n      const expected = '-1-2-3-5-6-7-     ';\n      const unsub = '   ------------!     ';\n\n      const result = e1.pipe(catchError(() => e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from a caught cold caught interop observable when unsubscribed explicitly","suites":["catchError operator"],"updatePoint":{"line":141,"column":98},"line":141,"code":"  it('should unsubscribe from a caught cold caught interop observable when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -1-2-3-#          ');\n      const e1subs = '  ^------!          ';\n      const e2 =  cold('       5-6-7-8-9-|');\n      const e2subs = '  -------^----!     ';\n      const expected = '-1-2-3-5-6-7-     ';\n      const unsub = '   ------------!     ';\n\n      // This test is the same as the previous test, but the observable is\n      // manipulated to make it look like an interop observable - an observable\n      // from a foreign library. Interop subscribers are treated differently:\n      // they are wrapped in a safe subscriber. This test ensures that\n      // unsubscriptions are chained all the way to the interop subscriber.\n\n      const result = e1.pipe(catchError(() => asInteropObservable(e2)));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["catchError operator"],"updatePoint":{"line":164,"column":73},"line":164,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n\n    throwError(() => new Error('Some error')).pipe(\n      catchError(() => synchronousObservable),\n      takeWhile((x) => x != 2) // unsubscribe at the second side-effect\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([1, 2]);\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch error and replace it with a hot Observable","suites":["catchError operator"],"updatePoint":{"line":189,"column":61},"line":189,"code":"  it('should catch error and replace it with a hot Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#          ');\n      const e1subs = '  ^-------!          ';\n      const e2 = hot('  1-2-3-4-5-6-7-8-9-|');\n      const e2subs = '  --------^---------!';\n      const expected = '--a--b--5-6-7-8-9-|';\n\n      const result = e1.pipe(catchError((err: any) => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch and replace a Observable.throw() as the source","suites":["catchError operator"],"updatePoint":{"line":267,"column":65},"line":267,"code":"  it('should catch and replace a Observable.throw() as the source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const subs = '    (^!)';\n      const expected = '(abc|)';\n\n      const result = e1.pipe(catchError((err: any) => of('a', 'b', 'c')));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror the source if it does not raise errors","suites":["catchError operator"],"updatePoint":{"line":280,"column":58},"line":280,"code":"  it('should mirror the source if it does not raise errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--c--|');\n      const subs = '    ^----------!';\n      const expected = '--a--b--c--|';\n\n      const result = e1.pipe(catchError((err: any) => of('x', 'y', 'z')));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if you return Observable.empty()","suites":["catchError operator"],"updatePoint":{"line":293,"column":54},"line":293,"code":"  it('should complete if you return Observable.empty()', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const e2 = cold('         |');\n      const e2subs = '  --------(^!)';\n      const expected = '--a--b--|';\n\n      const result = e1.pipe(catchError(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if you return Observable.throw()","suites":["catchError operator"],"updatePoint":{"line":309,"column":57},"line":309,"code":"  it('should raise error if you return Observable.throw()', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const e2 = cold('         #');\n      const e2subs = '  --------(^!)';\n      const expected = '--a--b--#';\n\n      const result = e1.pipe(catchError(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should never terminate if you return NEVER","suites":["catchError operator"],"updatePoint":{"line":325,"column":48},"line":325,"code":"  it('should never terminate if you return NEVER', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const e2 = cold('         -');\n      const e2subs = '  --------^';\n      const expected = '--a--b---';\n\n      const result = e1.pipe(catchError(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass the error as the first argument","suites":["catchError operator"],"updatePoint":{"line":341,"column":49},"line":341,"code":"  it('should pass the error as the first argument', (done) => {\n    throwError(() => ('bad')).pipe(\n      catchError((err: any) => {\n        expect(err).to.equal('bad');\n        return EMPTY;\n      })\n    ).subscribe({ next: () => {\n    //noop\n    }, error: (err: any) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept selector returns any ObservableInput","suites":["catchError operator"],"updatePoint":{"line":356,"column":56},"line":356,"code":"  it('should accept selector returns any ObservableInput', (done) => {\n    const input$ = createObservableInputs(42);\n\n    input$.pipe(\n      mergeMap(input =>\n        throwError(() => ('bad')).pipe(catchError(err => input))\n      )\n    ).subscribe({ next: x => {\n      expect(x).to.be.equal(42);\n    }, error: (err: any) => {\n      done(new Error('should not be called'));\n    }, complete: () => {\n      done();\n    } });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should catch errors throw from within the constructor","suites":["catchError operator"],"updatePoint":{"line":372,"column":59},"line":372,"code":"  it('should catch errors throw from within the constructor', () => {\n    // See https://github.com/ReactiveX/rxjs/issues/3740\n    testScheduler.run(({ expectObservable }) => {\n      const source = concat(\n        new Observable<string>(o => {\n          o.next('a');\n          throw 'kaboom';\n        }).pipe(\n          catchError(_ => of('b'))\n        ),\n        of('c')\n      );\n      const expected = '(abc|)';\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should chain a throw from a promise using Observable.throw","suites":["catchError operator","fromPromise"],"updatePoint":{"line":406,"column":66},"line":406,"code":"    it('should chain a throw from a promise using Observable.throw', (done) => {\n      const subscribeSpy = sinon.spy();\n      const errorSpy = sinon.spy();\n      const thrownError = new Error('BROKEN THROW');\n      const testError = new Error('BROKEN PROMISE');\n      from(Promise.reject(testError)).pipe(\n        catchError(err =>\n          throwError(() => (thrownError))\n        )\n      ).subscribe({ next: subscribeSpy, error: errorSpy });\n\n      trueSetTimeout(() => {\n        try {\n          timers.tick(1);\n        } catch (e) {\n          return done(new Error('This should not have thrown an error'));\n        }\n        expect(subscribeSpy).not.to.be.called;\n        expect(errorSpy).to.have.been.called;\n        expect(errorSpy).to.have.been.calledWith(thrownError);\n        done();\n      }, 0);\n    });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"Properly handle async handled result if source is synchronous","suites":["catchError operator","fromPromise"],"updatePoint":{"line":435,"column":67},"line":435,"code":"  it('Properly handle async handled result if source is synchronous', (done) => {\n    const source = new Observable<string>(observer => {\n      observer.error(new Error('kaboom!'));\n      observer.complete();\n    });\n\n    const sourceWithDelay = new Observable<string>(observer => {\n      observer.next('delayed');\n      observer.complete();\n    }).pipe(delay(0));\n\n    const values: string[] = [];\n    source.pipe(\n      catchError(err => sourceWithDelay)\n    )\n    .subscribe(\n      { next: value => values.push(value), error: err => done(err), complete: () => {\n        expect(values).to.deep.equal(['delayed']);\n        done();\n      } }\n    );\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["catchError operator","fromPromise"],"updatePoint":{"line":458,"column":73},"line":458,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      catchError(() => EMPTY),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/catchError-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine events from two cold observables","suites":["combineLatest"],"updatePoint":{"line":14,"column":53},"line":14,"code":"  it('should combine events from two cold observables', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' -a--b-----c-d-e-|');\n      const e2 = cold(' --1--2-3-4---|   ');\n      const expected = '--A-BC-D-EF-G-H-|';\n\n      const result = e1.pipe(combineLatest(e2, (a, b) => String(a) + String(b)));\n\n      expectObservable(result).toBe(expected, {\n        A: 'a1', B: 'b1', C: 'b2', D: 'b3', E: 'b4', F: 'c4', G: 'd4', H: 'e4'\n      });\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["combineLatest"],"updatePoint":{"line":28,"column":33},"line":28,"code":"  it('should work with two nevers', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["combineLatest"],"updatePoint":{"line":44,"column":38},"line":44,"code":"  it('should work with never and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["combineLatest"],"updatePoint":{"line":60,"column":38},"line":60,"code":"  it('should work with empty and never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["combineLatest"],"updatePoint":{"line":76,"column":38},"line":76,"code":"  it('should work with empty and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '|';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-empty and hot-single","suites":["combineLatest"],"updatePoint":{"line":92,"column":47},"line":92,"code":"  it('should work with hot-empty and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 2,\n        c: 3,\n        r: 1 + 3 //a + c\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and hot-empty","suites":["combineLatest"],"updatePoint":{"line":114,"column":47},"line":114,"code":"  it('should work with hot-single and hot-empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1, b: 2, c: 3\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = e2.pipe(combineLatest(e1, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and never","suites":["combineLatest"],"updatePoint":{"line":133,"column":43},"line":133,"code":"  it('should work with hot-single and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('------', values); //never\n      const e2subs = '   ^--';\n      const expected = ' ---'; //never\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and hot-single","suites":["combineLatest"],"updatePoint":{"line":152,"column":43},"line":152,"code":"  it('should work with never and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1, b: 2\n      };\n      const e1 = hot('--------', values); //never\n      const e1subs = '   ^    ';\n      const e2 = hot('-a-^-b-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' -----'; //never\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and hot","suites":["combineLatest"],"updatePoint":{"line":171,"column":34},"line":171,"code":"  it('should work with hot and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|', { e: 'e', f: 'f', g: 'g' });\n      const e2subs = '     ^---------!';\n      const expected = '   ----x-yz--|';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'bf', y: 'cf', z: 'cg' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observables","suites":["combineLatest"],"updatePoint":{"line":187,"column":40},"line":187,"code":"  it('should accept array of observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|');\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|');\n      const e2subs = '     ^---------!';\n      const e3 = hot('---h-^----i--j-|');\n      const e3subs = '     ^---------!';\n      const expected = '   -----wxyz-|';\n\n      const result = e1.pipe(combineLatest([e2, e3], (x: string, y: string, z: string) => x + y + z));\n\n      expectObservable(result).toBe(expected, { w: 'bfi', x: 'cfi', y: 'cgi', z: 'cgj' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["combineLatest"],"updatePoint":{"line":206,"column":38},"line":206,"code":"  it('should work with empty and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----------|'); //empty\n      const e1subs = '  ^-----!';\n      const e2 = hot('  ------#', undefined, 'shazbot!'); //error\n      const e2subs = '  ^-----!';\n      const expected = '------#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'shazbot!');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["combineLatest"],"updatePoint":{"line":222,"column":38},"line":222,"code":"  it('should work with error and empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--^---#', undefined, 'too bad, honk'); //error\n      const e1subs = '  ^---!';\n      const e2 = hot('--^--------|'); //empty\n      const e2subs = '  ^---!';\n      const expected = '----#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'too bad, honk');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and throw","suites":["combineLatest"],"updatePoint":{"line":238,"column":36},"line":238,"code":"  it('should work with hot and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3});\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and hot","suites":["combineLatest"],"updatePoint":{"line":254,"column":36},"line":254,"code":"  it('should work with throw and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'bazinga');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3});\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and throw","suites":["combineLatest"],"updatePoint":{"line":270,"column":38},"line":270,"code":"  it('should work with throw and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'jenga');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and throw","suites":["combineLatest"],"updatePoint":{"line":286,"column":38},"line":286,"code":"  it('should work with error and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'flurp');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and error","suites":["combineLatest"],"updatePoint":{"line":302,"column":38},"line":302,"code":"  it('should work with throw and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'flurp');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and throw","suites":["combineLatest"],"updatePoint":{"line":318,"column":38},"line":318,"code":"  it('should work with never and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-----------');\n      const e1subs = '   ^-----!';\n      const e2 = hot('---^-----#', undefined, 'wokka wokka');\n      const e2subs = '   ^-----!';\n      const expected = ' ------#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and never","suites":["combineLatest"],"updatePoint":{"line":334,"column":38},"line":334,"code":"  it('should work with throw and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'wokka wokka');\n      const e1subs = '   ^----!';\n      const e2 = hot('---^-----------');\n      const e2subs = '   ^----!';\n      const expected = ' -----#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some and throw","suites":["combineLatest"],"updatePoint":{"line":350,"column":37},"line":350,"code":"  it('should work with some and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   ---^----a---b--|', { a: 1, b: 2 });\n      const e1subs = '      ^--!';\n      const e2 = hot('   ---^--#', undefined, 'wokka wokka');\n      const e2subs = '      ^--!';\n      const expected = '    ---#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2}, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and some","suites":["combineLatest"],"updatePoint":{"line":366,"column":37},"line":366,"code":"  it('should work with throw and some', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--#', undefined, 'wokka wokka');\n      const e1subs = '   ^--!';\n      const e2 = hot('---^----a---b--|', { a: 1, b: 2 });\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2}, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete left","suites":["combineLatest"],"updatePoint":{"line":382,"column":45},"line":382,"code":"  it('should handle throw after complete left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b---|', { a: 1, b: 2 });\n      const leftSubs = '      ^------!';\n      const right = hot('-----^--------#', undefined, 'bad things');\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = left.pipe(combineLatest(right, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete right","suites":["combineLatest"],"updatePoint":{"line":398,"column":46},"line":398,"code":"  it('should handle throw after complete right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot('  -----^--------#', undefined, 'bad things');\n      const leftSubs = '       ^--------!';\n      const right = hot(' --a--^--b---|', { a: 1, b: 2 });\n      const rightSubs = '      ^------!';\n      const expected = '       ---------#';\n\n      const result = left.pipe(combineLatest(right, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle interleaved with tail","suites":["combineLatest"],"updatePoint":{"line":414,"column":41},"line":414,"code":"  it('should handle interleaved with tail', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a--^--b---c---|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '    ^----------!';\n      const e2 = hot('--d-^----e---f--|', { d: 'd', e: 'e', f: 'f'});\n      const e2subs = '    ^-----------!';\n      const expected = '  -----x-y-z--|';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'be', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables","suites":["combineLatest"],"updatePoint":{"line":430,"column":51},"line":430,"code":"  it('should handle two consecutive hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const e2subs = '     ^-------------------!';\n      const expected = '   -----------x--y--z--|';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error left","suites":["combineLatest"],"updatePoint":{"line":446,"column":67},"line":446,"code":"  it('should handle two consecutive hot observables with error left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--#', { a: 'a', b: 'b', c: 'c' }, 'jenga');\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = left.pipe(combineLatest(right, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'jenga');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error right","suites":["combineLatest"],"updatePoint":{"line":462,"column":68},"line":462,"code":"  it('should handle two consecutive hot observables with error right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--#', { d: 'd', e: 'e', f: 'f' }, 'dun dun dun');\n      const rightSubs = '     ^-------------------!';\n      const expected = '      -----------x--y--z--#';\n\n      const result = left.pipe(combineLatest(right, (x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' }, 'dun dun dun');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle selector throwing","suites":["combineLatest"],"updatePoint":{"line":478,"column":37},"line":478,"code":"  it('should handle selector throwing', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--|', { a: 1, b: 2});\n      const e1subs = '     ^--!';\n      const e2 = hot('--c--^--d--|', { c: 3, d: 4});\n      const e2subs = '     ^--!';\n      const expected = '   ---#';\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => { throw 'ha ha ' + x + ', ' + y; }));\n\n      expectObservable(result).toBe(expected, null, 'ha ha 2, 4');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["combineLatest"],"updatePoint":{"line":494,"column":53},"line":494,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = e1.pipe(combineLatest(e2, (x, y) => x + y));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["combineLatest"],"updatePoint":{"line":512,"column":73},"line":512,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        combineLatest(e2, (x, y) => x + y),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit unique array instances with the default projection","suites":["combineLatest"],"updatePoint":{"line":534,"column":68},"line":534,"code":"  it('should emit unique array instances with the default projection', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  -a--b--|');\n      const e2 = hot('  --1--2-|');\n      const expected = '-------(c|)';\n\n      const result = e1.pipe(\n        combineLatest(e2),\n        distinct(),\n        count()\n      );\n\n      expectObservable(result).toBe(expected, { c: 3 });\n    });\n  });","file":"operators/combineLatest-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept array of observables","suites":["combineLatest"],"updatePoint":{"line":13,"column":40},"line":13,"code":"  it('should accept array of observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|');\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|');\n      const e2subs = '     ^---------!';\n      const e3 = hot('---h-^----i--j-|');\n      const e3subs = '     ^---------!';\n      const expected = '   -----wxyz-|';\n\n      const result = e1.pipe(combineLatest([e2, e3], (x: string, y: string, z: string) => x + y + z));\n\n      expectObservable(result).toBe(expected, { w: 'bfi', x: 'cfi', y: 'cgi', z: 'cgj' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/combineLatest-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine events from two observables","suites":["combineLatestAll operator"],"updatePoint":{"line":15,"column":48},"line":15,"code":"  it('should combine events from two observables', () => {\n    testScheduler.run(({ hot, cold, expectObservable }) => {\n      const x = cold('                  -a-----b---|');\n      const y = cold('                  --1-2-|     ');\n      const outer = hot('-x----y--------|           ', { x: x, y: y });\n      const expected = ' -----------------A-B--C---|';\n\n      const result = outer.pipe(combineLatestAll((a, b) => String(a) + String(b)));\n\n      expectObservable(result).toBe(expected, { A: 'a1', B: 'a2', C: 'b2' });\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["combineLatestAll operator"],"updatePoint":{"line":28,"column":33},"line":28,"code":"  it('should work with two nevers', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["combineLatestAll operator"],"updatePoint":{"line":44,"column":38},"line":44,"code":"  it('should work with never and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '-';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["combineLatestAll operator"],"updatePoint":{"line":60,"column":38},"line":60,"code":"  it('should work with empty and never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["combineLatestAll operator"],"updatePoint":{"line":76,"column":38},"line":76,"code":"  it('should work with empty and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '|';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-empty and hot-single","suites":["combineLatestAll operator"],"updatePoint":{"line":92,"column":47},"line":92,"code":"  it('should work with hot-empty and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-|');\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|');\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and hot-empty","suites":["combineLatestAll operator"],"updatePoint":{"line":108,"column":47},"line":108,"code":"  it('should work with hot-single and hot-empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-|');\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|');\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = of(e2, e1).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and never","suites":["combineLatestAll operator"],"updatePoint":{"line":124,"column":43},"line":124,"code":"  it('should work with hot-single and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-|');\n      const e1subs = '   ^-!';\n      const e2 = hot('------'); //never\n      const e2subs = '   ^--';\n      const expected = ' ---'; //never\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and hot-single","suites":["combineLatestAll operator"],"updatePoint":{"line":140,"column":43},"line":140,"code":"  it('should work with never and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--------'); //never\n      const e1subs = '   ^----';\n      const e2 = hot('-a-^-b-|');\n      const e2subs = '   ^---!';\n      const expected = ' -----'; //never\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and hot","suites":["combineLatestAll operator"],"updatePoint":{"line":156,"column":34},"line":156,"code":"  it('should work with hot and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|');\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|');\n      const e2subs = '     ^---------!';\n      const expected = '   ----x-yz--|';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'bf', y: 'cf', z: 'cg' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["combineLatestAll operator"],"updatePoint":{"line":172,"column":53},"line":172,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["combineLatestAll operator"],"updatePoint":{"line":190,"column":73},"line":190,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--^--b--c---d-| ');\n      const e1subs = '       ^--------!    ';\n      const e2 = hot('  ---e-^---f--g---h-|');\n      const e2subs = '       ^--------!    ';\n      const expected = '     ----x-yz--    ';\n      const unsub = '        ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = of(e1, e2).pipe(\n        mergeMap((x) => of(x)),\n        combineLatestAll((x, y) => x + y),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine 3 observables","suites":["combineLatestAll operator"],"updatePoint":{"line":212,"column":34},"line":212,"code":"  it('should combine 3 observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|');\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|');\n      const e2subs = '     ^---------!';\n      const e3 = hot('---h-^----i--j-|');\n      const e3subs = '     ^---------!';\n      const expected = '   -----wxyz-|';\n\n      const result = of(e1, e2, e3).pipe(combineLatestAll((x, y, z) => x + y + z));\n\n      expectObservable(result).toBe(expected, { w: 'bfi', x: 'cfi', y: 'cgi', z: 'cgj' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["combineLatestAll operator"],"updatePoint":{"line":231,"column":38},"line":231,"code":"  it('should work with empty and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----------|'); //empty\n      const e1subs = '  ^-----!';\n      const e2 = hot('  ------#', undefined, 'shazbot!'); //error\n      const e2subs = '  ^-----!';\n      const expected = '------#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'shazbot!');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["combineLatestAll operator"],"updatePoint":{"line":247,"column":38},"line":247,"code":"  it('should work with error and empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--^---#', undefined, 'too bad, honk'); //error\n      const e1subs = '  ^---!';\n      const e2 = hot('--^--------|'); //empty\n      const e2subs = '  ^---!';\n      const expected = '----#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'too bad, honk');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and throw","suites":["combineLatestAll operator"],"updatePoint":{"line":263,"column":36},"line":263,"code":"  it('should work with hot and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--c--|');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and hot","suites":["combineLatestAll operator"],"updatePoint":{"line":279,"column":36},"line":279,"code":"  it('should work with throw and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'bazinga');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--c--|');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and throw","suites":["combineLatestAll operator"],"updatePoint":{"line":295,"column":38},"line":295,"code":"  it('should work with throw and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'jenga');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and throw","suites":["combineLatestAll operator"],"updatePoint":{"line":311,"column":38},"line":311,"code":"  it('should work with error and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--#', undefined, 'wokka wokka');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'flurp');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and error","suites":["combineLatestAll operator"],"updatePoint":{"line":327,"column":38},"line":327,"code":"  it('should work with throw and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'flurp');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--#', undefined, 'wokka wokka');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and throw","suites":["combineLatestAll operator"],"updatePoint":{"line":343,"column":38},"line":343,"code":"  it('should work with never and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-----------');\n      const e1subs = '   ^-----!';\n      const e2 = hot('---^-----#', undefined, 'wokka wokka');\n      const e2subs = '   ^-----!';\n      const expected = ' ------#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and never","suites":["combineLatestAll operator"],"updatePoint":{"line":359,"column":38},"line":359,"code":"  it('should work with throw and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   ---^----#', undefined, 'wokka wokka');\n      const e1subs = '      ^----!';\n      const e2 = hot('   ---^-----------');\n      const e2subs = '      ^----!';\n      const expected = '    -----#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some and throw","suites":["combineLatestAll operator"],"updatePoint":{"line":375,"column":37},"line":375,"code":"  it('should work with some and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----a---b--|');\n      const e1subs = '   ^--!';\n      const e2 = hot('---^--#', undefined, 'wokka wokka');\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2}, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and some","suites":["combineLatestAll operator"],"updatePoint":{"line":391,"column":37},"line":391,"code":"  it('should work with throw and some', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--#', undefined, 'wokka wokka');\n      const e1subs = '   ^--!';\n      const e2 = hot('---^----a---b--|');\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete left","suites":["combineLatestAll operator"],"updatePoint":{"line":407,"column":45},"line":407,"code":"  it('should handle throw after complete left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b---|');\n      const leftSubs = '      ^------!';\n      const right = hot('-----^--------#', undefined, 'bad things');\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete right","suites":["combineLatestAll operator"],"updatePoint":{"line":423,"column":46},"line":423,"code":"  it('should handle throw after complete right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot('  -----^--------#', undefined, 'bad things');\n      const leftSubs = '       ^--------!';\n      const right =  hot('--a--^--b---|');\n      const rightSubs = '      ^------!';\n      const expected = '       ---------#';\n\n      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle interleaved with tail","suites":["combineLatestAll operator"],"updatePoint":{"line":439,"column":41},"line":439,"code":"  it('should handle interleaved with tail', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a--^--b---c---|');\n      const e1subs = '    ^----------!';\n      const e2 = hot('--d-^----e---f--|');\n      const e2subs = '    ^-----------!';\n      const expected = '  -----x-y-z--|';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'be', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables","suites":["combineLatestAll operator"],"updatePoint":{"line":455,"column":51},"line":455,"code":"  it('should handle two consecutive hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|');\n      const e1subs = '     ^--------!';\n      const e2 = hot('-----^----------d--e--f--|');\n      const e2subs = '     ^-------------------!';\n      const expected = '   -----------x--y--z--|';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error left","suites":["combineLatestAll operator"],"updatePoint":{"line":471,"column":67},"line":471,"code":"  it('should handle two consecutive hot observables with error left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--#', undefined, 'jenga');\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--|');\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'jenga');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error right","suites":["combineLatestAll operator"],"updatePoint":{"line":487,"column":68},"line":487,"code":"  it('should handle two consecutive hot observables with error right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--|');\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--#', undefined, 'dun dun dun');\n      const rightSubs = '     ^-------------------!';\n      const expected = '      -----------x--y--z--#';\n\n      const result = of(left, right).pipe(combineLatestAll((x, y) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' }, 'dun dun dun');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle selector throwing","suites":["combineLatestAll operator"],"updatePoint":{"line":503,"column":37},"line":503,"code":"  it('should handle selector throwing', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--|');\n      const e1subs = '     ^--!';\n      const e2 = hot('--c--^--d--|');\n      const e2subs = '     ^--!';\n      const expected = '   ---#';\n\n      const result = of(e1, e2).pipe(combineLatestAll((x, y) => { throw 'ha ha ' + x + ', ' + y; }));\n\n      expectObservable(result).toBe(expected, null, 'ha ha b, d');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two observables","suites":["combineLatestAll operator"],"updatePoint":{"line":519,"column":36},"line":519,"code":"  it('should combine two observables', (done) => {\n    const a = of(1, 2, 3);\n    const b = of(4, 5, 6, 7, 8);\n    const expected = [[3, 4], [3, 5], [3, 6], [3, 7], [3, 8]];\n    of(a, b).pipe(combineLatestAll()).subscribe({ next: (vals) => {\n      expect(vals).to.deep.equal(expected.shift());\n    }, complete: () => {\n      expect(expected.length).to.equal(0);\n      done();\n    } });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two immediately-scheduled observables","suites":["combineLatestAll operator"],"updatePoint":{"line":531,"column":58},"line":531,"code":"  it('should combine two immediately-scheduled observables', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [[1, 4], [2, 4], [2, 5], [3, 5], [3, 6], [3, 7], [3, 8]];\n\n    of(a, b, queueScheduler).pipe(combineLatestAll())\n      .subscribe({ next: (vals) => {\n        expect(vals).to.deep.equal(r.shift());\n    }, complete: () => {\n      expect(r.length).to.equal(0);\n      done();\n    } });\n  });","file":"operators/combineLatestAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine events from two cold observables","suites":["combineLatestWith"],"updatePoint":{"line":14,"column":53},"line":14,"code":"  it('should combine events from two cold observables', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold(' -a--b-----c-d-e-|');\n      const e2 = cold(' --1--2-3-4---|   ');\n      const expected = '--A-BC-D-EF-G-H-|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([a, b]) => a + b));\n\n      expectObservable(result).toBe(expected, {\n        A: 'a1', B: 'b1', C: 'b2', D: 'b3', E: 'b4', F: 'c4', G: 'd4', H: 'e4'\n      });\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["combineLatestWith"],"updatePoint":{"line":28,"column":33},"line":28,"code":"  it('should work with two nevers', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["combineLatestWith"],"updatePoint":{"line":44,"column":38},"line":44,"code":"  it('should work with never and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["combineLatestWith"],"updatePoint":{"line":60,"column":38},"line":60,"code":"  it('should work with empty and never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["combineLatestWith"],"updatePoint":{"line":76,"column":38},"line":76,"code":"  it('should work with empty and empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const e2 = cold(' |');\n      const e2subs = '  (^!)';\n      const expected = '|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-empty and hot-single","suites":["combineLatestWith"],"updatePoint":{"line":92,"column":47},"line":92,"code":"  it('should work with hot-empty and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 2,\n        c: 3,\n        r: 1 + 3 //a + c\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and hot-empty","suites":["combineLatestWith"],"updatePoint":{"line":114,"column":47},"line":114,"code":"  it('should work with hot-single and hot-empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1, b: 2, c: 3\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('-b-^-c-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' ----|';\n\n      const result = e2.pipe(combineLatestWith(e1), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot-single and never","suites":["combineLatestWith"],"updatePoint":{"line":133,"column":43},"line":133,"code":"  it('should work with hot-single and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1\n      };\n      const e1 = hot('-a-^-|', values);\n      const e1subs = '   ^-!';\n      const e2 = hot('------', values); //never\n      const e2subs = '   ^--';\n      const expected = ' ---'; //never\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and hot-single","suites":["combineLatestWith"],"updatePoint":{"line":152,"column":43},"line":152,"code":"  it('should work with never and hot-single', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1, b: 2\n      };\n      const e1 = hot('--------', values); //never\n      const e1subs = '   ^    ';\n      const e2 = hot('-a-^-b-|', values);\n      const e2subs = '   ^---!';\n      const expected = ' -----'; //never\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and hot","suites":["combineLatestWith"],"updatePoint":{"line":171,"column":34},"line":171,"code":"  it('should work with hot and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('---e-^---f--g--|', { e: 'e', f: 'f', g: 'g' });\n      const e2subs = '     ^---------!';\n      const expected = '   ----x-yz--|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'bf', y: 'cf', z: 'cg' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["combineLatestWith"],"updatePoint":{"line":187,"column":38},"line":187,"code":"  it('should work with empty and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----------|'); //empty\n      const e1subs = '  ^-----!';\n      const e2 = hot('  ------#', undefined, 'shazbot!'); //error\n      const e2subs = '  ^-----!';\n      const expected = '------#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'shazbot!');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["combineLatestWith"],"updatePoint":{"line":203,"column":38},"line":203,"code":"  it('should work with error and empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--^---#', undefined, 'too bad, honk'); //error\n      const e1subs = '  ^---!';\n      const e2 = hot('--^--------|'); //empty\n      const e2subs = '  ^---!';\n      const expected = '----#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'too bad, honk');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with hot and throw","suites":["combineLatestWith"],"updatePoint":{"line":219,"column":36},"line":219,"code":"  it('should work with hot and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3});\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and hot","suites":["combineLatestWith"],"updatePoint":{"line":235,"column":36},"line":235,"code":"  it('should work with throw and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'bazinga');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--c--|', { a: 1, b: 2, c: 3});\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and throw","suites":["combineLatestWith"],"updatePoint":{"line":251,"column":38},"line":251,"code":"  it('should work with throw and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'jenga');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'bazinga');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bazinga');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and throw","suites":["combineLatestWith"],"updatePoint":{"line":267,"column":38},"line":267,"code":"  it('should work with error and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e1subs = '   ^-!';\n      const e2 = hot('---^-#', undefined, 'flurp');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and error","suites":["combineLatestWith"],"updatePoint":{"line":283,"column":38},"line":283,"code":"  it('should work with throw and error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-#', undefined, 'flurp');\n      const e1subs = '   ^-!';\n      const e2 = hot('-a-^--b--#', { a: 1, b: 2 }, 'wokka wokka');\n      const e2subs = '   ^-!';\n      const expected = ' --#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'flurp');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and throw","suites":["combineLatestWith"],"updatePoint":{"line":299,"column":38},"line":299,"code":"  it('should work with never and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^-----------');\n      const e1subs = '   ^-----!';\n      const e2 = hot('---^-----#', undefined, 'wokka wokka');\n      const e2subs = '   ^-----!';\n      const expected = ' ------#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and never","suites":["combineLatestWith"],"updatePoint":{"line":315,"column":38},"line":315,"code":"  it('should work with throw and never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^----#', undefined, 'wokka wokka');\n      const e1subs = '   ^----!';\n      const e2 = hot('---^-----------');\n      const e2subs = '   ^----!';\n      const expected = ' -----#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some and throw","suites":["combineLatestWith"],"updatePoint":{"line":331,"column":37},"line":331,"code":"  it('should work with some and throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   ---^----a---b--|', { a: 1, b: 2 });\n      const e1subs = '      ^--!';\n      const e2 = hot('   ---^--#', undefined, 'wokka wokka');\n      const e2subs = '      ^--!';\n      const expected = '    ---#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2}, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw and some","suites":["combineLatestWith"],"updatePoint":{"line":347,"column":37},"line":347,"code":"  it('should work with throw and some', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--#', undefined, 'wokka wokka');\n      const e1subs = '   ^--!';\n      const e2 = hot('---^----a---b--|', { a: 1, b: 2 });\n      const e2subs = '   ^--!';\n      const expected = ' ---#';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { a: 1, b: 2}, 'wokka wokka');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete left","suites":["combineLatestWith"],"updatePoint":{"line":363,"column":45},"line":363,"code":"  it('should handle throw after complete left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b---|', { a: 1, b: 2 });\n      const leftSubs = '      ^------!';\n      const right = hot('-----^--------#', undefined, 'bad things');\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = left.pipe(combineLatestWith(right), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw after complete right","suites":["combineLatestWith"],"updatePoint":{"line":379,"column":46},"line":379,"code":"  it('should handle throw after complete right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot('  -----^--------#', undefined, 'bad things');\n      const leftSubs = '       ^--------!';\n      const right = hot(' --a--^--b---|', { a: 1, b: 2 });\n      const rightSubs = '      ^------!';\n      const expected = '       ---------#';\n\n      const result = left.pipe(combineLatestWith(right), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'bad things');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle interleaved with tail","suites":["combineLatestWith"],"updatePoint":{"line":395,"column":41},"line":395,"code":"  it('should handle interleaved with tail', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a--^--b---c---|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '    ^----------!';\n      const e2 = hot('--d-^----e---f--|', { d: 'd', e: 'e', f: 'f'});\n      const e2subs = '    ^-----------!';\n      const expected = '  -----x-y-z--|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'be', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables","suites":["combineLatestWith"],"updatePoint":{"line":411,"column":51},"line":411,"code":"  it('should handle two consecutive hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const e1subs = '     ^--------!';\n      const e2 = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const e2subs = '     ^-------------------!';\n      const expected = '   -----------x--y--z--|';\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error left","suites":["combineLatestWith"],"updatePoint":{"line":427,"column":67},"line":427,"code":"  it('should handle two consecutive hot observables with error left', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--#', { a: 'a', b: 'b', c: 'c' }, 'jenga');\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--|', { d: 'd', e: 'e', f: 'f' });\n      const rightSubs = '     ^--------!';\n      const expected = '      ---------#';\n\n      const result = left.pipe(combineLatestWith(right), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, null, 'jenga');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle two consecutive hot observables with error right","suites":["combineLatestWith"],"updatePoint":{"line":443,"column":68},"line":443,"code":"  it('should handle two consecutive hot observables with error right', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const left = hot(' --a--^--b--c--|', { a: 'a', b: 'b', c: 'c' });\n      const leftSubs = '      ^--------!';\n      const right = hot('-----^----------d--e--f--#', { d: 'd', e: 'e', f: 'f' }, 'dun dun dun');\n      const rightSubs = '     ^-------------------!';\n      const expected = '      -----------x--y--z--#';\n\n      const result = left.pipe(combineLatestWith(right), map(([x, y]) => x + y));\n\n      expectObservable(result).toBe(expected, { x: 'cd', y: 'ce', z: 'cf' }, 'dun dun dun');\n      expectSubscriptions(left.subscriptions).toBe(leftSubs);\n      expectSubscriptions(right.subscriptions).toBe(rightSubs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["combineLatestWith"],"updatePoint":{"line":459,"column":53},"line":459,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = e1.pipe(combineLatestWith(e2), map(([x, y]) => x + y));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["combineLatestWith"],"updatePoint":{"line":477,"column":73},"line":477,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c---d-| ');\n      const e1subs = '     ^--------!    ';\n      const e2 = hot('---e-^---f--g---h-|');\n      const e2subs = '     ^--------!    ';\n      const expected = '   ----x-yz--    ';\n      const unsub = '      ---------!    ';\n      const values = { x: 'bf', y: 'cf', z: 'cg' };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        combineLatestWith(e2), map(([x, y]) => x + y),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit unique array instances with the default projection","suites":["combineLatestWith"],"updatePoint":{"line":499,"column":68},"line":499,"code":"  it('should emit unique array instances with the default projection', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  -a--b--|');\n      const e2 = hot('  --1--2-|');\n      const expected = '-------(c|)';\n\n      const result = e1.pipe(\n        combineLatestWith(e2),\n        distinct(),\n        count()\n      );\n\n      expectObservable(result).toBe(expected, { c: 3 });\n    });\n  });","file":"operators/combineLatestWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatenate two cold observables","suites":["concat operator"],"updatePoint":{"line":15,"column":45},"line":15,"code":"  it('should concatenate two cold observables', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const e1 = cold('  --a--b-|');\n      const e2 = cold('         --x---y--|');\n      const expected = ' --a--b---x---y--|';\n\n      expectObservable(e1.pipe(concat(e2, testScheduler))).toBe(expected);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work properly with scalar observables","suites":["concat operator"],"updatePoint":{"line":25,"column":50},"line":25,"code":"  it('should work properly with scalar observables', (done) => {\n    const results: string[] = [];\n\n    const s1 = new Observable<number>(observer => {\n      setTimeout(() => {\n        observer.next(1);\n        observer.complete();\n      });\n    }).pipe(concat(of(2)));\n\n    s1.subscribe(\n      { next: x => {\n        results.push('Next: ' + x);\n      }, error: x => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        results.push('Completed');\n        expect(results).to.deep.equal(['Next: 1', 'Next: 2', 'Completed']);\n        done();\n      } }\n    );\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without emit if both sources are empty","suites":["concat operator"],"updatePoint":{"line":48,"column":60},"line":48,"code":"  it('should complete without emit if both sources are empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    ----|');\n      const e2subs = '   --^---!';\n      const expected = ' ------|';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not complete","suites":["concat operator"],"updatePoint":{"line":62,"column":59},"line":62,"code":"  it('should not complete if first source does not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  --|');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if second source does not complete","suites":["concat operator"],"updatePoint":{"line":76,"column":60},"line":76,"code":"  it('should not complete if second source does not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('  ---');\n      const e2subs = '   --^';\n      const expected = ' ---';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if both sources do not complete","suites":["concat operator"],"updatePoint":{"line":90,"column":57},"line":90,"code":"  it('should not complete if both sources do not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  -');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source is empty, second source raises error","suites":["concat operator"],"updatePoint":{"line":104,"column":79},"line":104,"code":"  it('should raise error when first source is empty, second source raises error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    ----#');\n      const e2subs = '   --^---!';\n      const expected = ' ------#';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source raises error, second source is empty","suites":["concat operator"],"updatePoint":{"line":118,"column":79},"line":118,"code":"  it('should raise error when first source raises error, second source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---#');\n      const e1subs = '   ^--!';\n      const e2 = cold('  ----|');\n      const e2subs: string[] = [];\n      const expected = ' ---#';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise first error when both source raise error","suites":["concat operator"],"updatePoint":{"line":132,"column":59},"line":132,"code":"  it('should raise first error when both source raise error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---#');\n      const e1subs = '   ^--!';\n      const e2 = cold('  ------#');\n      const e2subs: string[] = [];\n      const expected = ' ---#';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source emits once, second source is empty","suites":["concat operator"],"updatePoint":{"line":146,"column":70},"line":146,"code":"  it('should concat if first source emits once, second source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a--|');\n      const e1subs = '   ^----!';\n      const e2 = cold('       --------|');\n      const e2subs = '   -----^-------!';\n      const expected = ' --a----------|';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source is empty, second source emits once","suites":["concat operator"],"updatePoint":{"line":160,"column":70},"line":160,"code":"  it('should concat if first source is empty, second source emits once', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    --a--|');\n      const e2subs = '   --^----!';\n      const expected = ' ----a--|';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not complete","suites":["concat operator"],"updatePoint":{"line":192,"column":59},"line":192,"code":"  it('should not complete if first source does not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  --a--|');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements from each source when source emit once","suites":["concat operator"],"updatePoint":{"line":206,"column":65},"line":206,"code":"  it('should emit elements from each source when source emit once', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a|');\n      const e1subs = '   ^---!';\n      const e2 = cold('      -----b--|');\n      const e2subs = '   ----^-------!';\n      const expected = ' ---a-----b--|';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe to inner source if outer is unsubscribed early","suites":["concat operator"],"updatePoint":{"line":220,"column":71},"line":220,"code":"  it('should unsubscribe to inner source if outer is unsubscribed early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-a--a|            ');\n      const e1subs = '   ^--------!            ';\n      const e2 = cold('           -----b-b--b-|');\n      const e2subs = '   ---------^-------!    ';\n      const unsub = '    -----------------!    ';\n      const expected = ' ---a-a--a-----b-b     ';\n\n      expectObservable(e1.pipe(concat(e2)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["concat operator"],"updatePoint":{"line":235,"column":83},"line":235,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-a--a|            ');\n      const e1subs = '   ^--------!            ';\n      const e2 = cold('           -----b-b--b-|');\n      const e2subs = '   ---------^-------!    ';\n      const expected = ' ---a-a--a-----b-b-    ';\n      const unsub = '    -----------------!    ';\n\n      const result = e1.pipe(\n        mergeMap(x => of(x)),\n        concat(e2),\n        mergeMap(x => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from first source and does not emit from second source","suites":["concat operator"],"updatePoint":{"line":256,"column":79},"line":256,"code":"  it('should raise error from first source and does not emit from second source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --#');\n      const e1subs = '   ^-!';\n      const e2 = cold('  ----a--|');\n      const e2subs: string[] = [];\n      const expected = ' --#';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit element from first source then raise error from second source","suites":["concat operator"],"updatePoint":{"line":270,"column":79},"line":270,"code":"  it('should emit element from first source then raise error from second source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a--|');\n      const e1subs = '   ^----!';\n      const e2 = cold('       -------#');\n      const e2subs = '   -----^------!';\n      const expected = ' --a---------#';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit collapsing element from second source","suites":["concat operator"],"updatePoint":{"line":322,"column":59},"line":322,"code":"  it('should not emit collapsing element from second source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const e2 = hot('  --------x--y--z--|');\n      const e2subs = '  -----------^-----!';\n      const expected = '--a--b--c--y--z--|';\n\n      expectObservable(e1.pipe(concat(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler with multiple observables","suites":["concat operator"],"updatePoint":{"line":336,"column":55},"line":336,"code":"  it('should accept scheduler with multiple observables', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a|');\n      const e1subs = '   ^---!';\n      const e2 = cold('      ---b--|');\n      const e2subs = '   ----^-----!';\n      const e3 = cold('            ---c--|');\n      const e3subs = '   ----------^-----!';\n      const expected = ' ---a---b-----c--|';\n\n      expectObservable(e1.pipe(concat(e2, e3, testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler without observable parameters","suites":["concat operator"],"updatePoint":{"line":353,"column":59},"line":353,"code":"  it('should accept scheduler without observable parameters', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-|');\n      const e1subs = '   ^----!';\n      const expected = ' ---a-|';\n\n      expectObservable(e1.pipe(concat(testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit self without parameters","suites":["concat operator"],"updatePoint":{"line":364,"column":41},"line":364,"code":"  it('should emit self without parameters', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-|');\n      const e1subs = '   ^----!';\n      const expected = ' ---a-|';\n\n      expectObservable(e1.pipe(concat())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concat-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat an observable of observables","suites":["concatAll operator"],"updatePoint":{"line":15,"column":48},"line":15,"code":"  it('should concat an observable of observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const x = cold('    ----a------b------|                 ');\n      const y = cold('                      ---c-d---|        ');\n      const z = cold('                               ---e--f-|');\n      const outer = hot('-x---y----z------|', { x: x, y: y, z: z });\n      const expected = ' -----a------b---------c-d------e--f-|';\n\n      const result = outer.pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat sources from promise","suites":["concatAll operator"],"updatePoint":{"line":29,"column":40},"line":29,"code":"  it('should concat sources from promise', function(done) {\n    this.timeout(2000);\n    const sources = from([\n      new Promise<number>(res => {\n        res(0);\n      }),\n      new Promise<number>(res => {\n        res(1);\n      }),\n      new Promise<number>(res => {\n        res(2);\n      }),\n      new Promise<number>(res => {\n        res(3);\n      })\n    ]).pipe(take(10));\n\n    const res: number[] = [];\n    sources.pipe(concatAll()).subscribe(\n      { next: x => {\n        res.push(x);\n      }, error: err => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(res).to.deep.equal([0, 1, 2, 3]);\n        done();\n      } }\n    );\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize before moving to the next observable","suites":["concatAll operator"],"updatePoint":{"line":59,"column":60},"line":59,"code":"    it('should finalize before moving to the next observable', () => {\n      const results: any[] = [];\n\n      const create = (n: number) => defer(() => {\n        results.push(`init ${n}`);\n        return of(`next ${n}`).pipe(\n          delay(100, testScheduler),\n          finalize(() => {\n            results.push(`finalized ${n}`)\n          })\n        );\n      });\n\n      of(create(1), create(2), create(3)).pipe(\n        concatAll()\n      ).subscribe({\n        next: value => results.push(value),\n      });\n\n      testScheduler.flush();\n\n      expect(results).to.deep.equal([\n        'init 1',\n        'next 1',\n        'finalized 1',\n        'init 2',\n        'next 2',\n        'finalized 2',\n        'init 3',\n        'next 3',\n        'finalized 3'\n      ]);\n    });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat and raise error from promise","suites":["concatAll operator"],"updatePoint":{"line":93,"column":48},"line":93,"code":"  it('should concat and raise error from promise', function(done) {\n    this.timeout(2000);\n\n    const sources = from([\n      new Promise<number>(res => {\n        res(0);\n      }),\n      new Promise<number>((res, rej) => {\n        rej(1);\n      }),\n      new Promise<number>(res => {\n        res(2);\n      }),\n      new Promise<number>(res => {\n        res(3);\n      })\n    ]).pipe(take(10));\n\n    const res: number[] = [];\n    sources.pipe(concatAll()).subscribe(\n      { next: x => {\n        res.push(x);\n      }, error: err => {\n        expect(res.length).to.equal(1);\n        expect(err).to.equal(1);\n        done();\n      }, complete: () => {\n        done(new Error('should not be called'));\n      } }\n    );\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat all observables in an observable","suites":["concatAll operator"],"updatePoint":{"line":125,"column":52},"line":125,"code":"  it('should concat all observables in an observable', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = from([of('a'), of('b'), of('c')]).pipe(take(10));\n      const expected = '(abc|)';\n\n      expectObservable(e1.pipe(concatAll())).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if any child observable throws","suites":["concatAll operator"],"updatePoint":{"line":134,"column":49},"line":134,"code":"  it('should throw if any child observable throws', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = from([of('a'), throwError(() => ('error')), of('c')]).pipe(take(10));\n      const expected = '(a#)';\n\n      expectObservable(e1.pipe(concatAll())).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat merging a hot observable of non-overlapped observables","suites":["concatAll operator"],"updatePoint":{"line":143,"column":74},"line":143,"code":"  it('should concat merging a hot observable of non-overlapped observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const values = {\n        x: cold('       a-b---------|'),\n        y: cold('                 c-d-e-f-|'),\n        z: cold('                          g-h-i-j-k-|')\n      };\n\n      const e1 = hot('  --x---------y--------z--------|', values);\n      const expected = '--a-b---------c-d-e-f-g-h-i-j-k-|';\n\n      expectObservable(e1.pipe(concatAll())).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if inner observable raises error","suites":["concatAll operator"],"updatePoint":{"line":158,"column":57},"line":158,"code":"  it('should raise error if inner observable raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const values = {\n        x: cold('       a-b---------|'),\n        y: cold('                 c-d-e-f-#'),\n        z: cold('                         g-h-i-j-k-|')\n      };\n      const e1 = hot('  --x---------y--------z--------|', values);\n      const expected = '--a-b---------c-d-e-f-#';\n\n      expectObservable(e1.pipe(concatAll())).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if outer observable raises error","suites":["concatAll operator"],"updatePoint":{"line":172,"column":57},"line":172,"code":"  it('should raise error if outer observable raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const values = {\n        y: cold('       a-b---------|'),\n        z: cold('                 c-d-e-f-|')\n      };\n      const e1 = hot('  --y---------z---#    ', values);\n      const expected = '--a-b---------c-#';\n\n      expectObservable(e1.pipe(concatAll())).toBe(expected);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without emit if both sources are empty","suites":["concatAll operator"],"updatePoint":{"line":185,"column":60},"line":185,"code":"  it('should complete without emit if both sources are empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    ----|');\n      const e2subs = '   --^---!';\n      const expected = ' ------|';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not completes","suites":["concatAll operator"],"updatePoint":{"line":201,"column":60},"line":201,"code":"  it('should not complete if first source does not completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  --|');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if second source does not completes","suites":["concatAll operator"],"updatePoint":{"line":217,"column":61},"line":217,"code":"  it('should not complete if second source does not completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('  ---');\n      const e2subs = '   --^';\n      const expected = ' ---';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if both sources do not complete","suites":["concatAll operator"],"updatePoint":{"line":233,"column":57},"line":233,"code":"  it('should not complete if both sources do not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  -');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source is empty, second source raises error","suites":["concatAll operator"],"updatePoint":{"line":249,"column":79},"line":249,"code":"  it('should raise error when first source is empty, second source raises error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    ----#');\n      const e2subs = '   --^---!';\n      const expected = ' ------#';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source raises error, second source is empty","suites":["concatAll operator"],"updatePoint":{"line":265,"column":79},"line":265,"code":"  it('should raise error when first source raises error, second source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---#');\n      const e1subs = '   ^--!';\n      const e2 = cold('  ----|');\n      const e2subs: string[] = [];\n      const expected = ' ---#';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise first error when both source raise error","suites":["concatAll operator"],"updatePoint":{"line":281,"column":59},"line":281,"code":"  it('should raise first error when both source raise error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---#');\n      const e1subs = '   ^--!';\n      const e2 = cold('  ------#');\n      const e2subs: string[] = [];\n      const expected = ' ---#';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source emits once, second source is empty","suites":["concatAll operator"],"updatePoint":{"line":297,"column":70},"line":297,"code":"  it('should concat if first source emits once, second source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a--|');\n      const e1subs = '   ^----!';\n      const e2 = cold('       --------|');\n      const e2subs = '   -----^-------!';\n      const expected = ' --a----------|';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source is empty, second source emits once","suites":["concatAll operator"],"updatePoint":{"line":313,"column":70},"line":313,"code":"  it('should concat if first source is empty, second source emits once', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --|');\n      const e1subs = '   ^-!';\n      const e2 = cold('    --a--|');\n      const e2subs = '   --^----!';\n      const expected = ' ----a--|';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not complete","suites":["concatAll operator"],"updatePoint":{"line":349,"column":59},"line":349,"code":"  it('should not complete if first source does not complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  -');\n      const e1subs = '   ^';\n      const e2 = cold('  --a--|');\n      const e2subs: string[] = [];\n      const expected = ' -';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements from each source when source emit once","suites":["concatAll operator"],"updatePoint":{"line":365,"column":65},"line":365,"code":"  it('should emit elements from each source when source emit once', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a|');\n      const e1subs = '   ^---!';\n      const e2 = cold('      -----b--|');\n      const e2subs = '   ----^-------!';\n      const expected = ' ---a-----b--|';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe to inner source if outer is unsubscribed early","suites":["concatAll operator"],"updatePoint":{"line":381,"column":71},"line":381,"code":"  it('should unsubscribe to inner source if outer is unsubscribed early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-a--a|            ');\n      const e1subs = '   ^--------!            ';\n      const e2 = cold('           -----b-b--b-|');\n      const e2subs = '   ---------^-------!    ';\n      const unsub = '    -----------------!    ';\n      const expected = ' ---a-a--a-----b-b     ';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["concatAll operator"],"updatePoint":{"line":398,"column":83},"line":398,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-a--a|            ');\n      const e1subs = '   ^--------!            ';\n      const e2 = cold('           -----b-b--b-|');\n      const e2subs = '   ---------^-------!    ';\n      const expected = ' ---a-a--a-----b-b-    ';\n      const unsub = '    -----------------!    ';\n\n      const result = of(e1, e2).pipe(\n        mergeMap(x => of(x)),\n        concatAll(),\n        mergeMap(x => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from first source and does not emit from second source","suites":["concatAll operator"],"updatePoint":{"line":419,"column":79},"line":419,"code":"  it('should raise error from first source and does not emit from second source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --#');\n      const e1subs = '   ^-!';\n      const e2 = cold('  ----a--|');\n      const e2subs: string[] = [];\n      const expected = ' --#';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit element from first source then raise error from second source","suites":["concatAll operator"],"updatePoint":{"line":435,"column":79},"line":435,"code":"  it('should emit element from first source then raise error from second source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a--|');\n      const e1subs = '   ^----!';\n      const e2 = cold('       -------#');\n      const e2subs = '   -----^------!';\n      const expected = ' --a---------#';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit collapsing element from second source","suites":["concatAll operator"],"updatePoint":{"line":493,"column":59},"line":493,"code":"  it('should not emit collapsing element from second source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const e2 = hot('  --------x--y--z--|');\n      const e2subs = '  -----------^-----!';\n      const expected = '--a--b--c--y--z--|';\n\n      const result = of(e1, e2).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to work on a different scheduler","suites":["concatAll operator"],"updatePoint":{"line":509,"column":53},"line":509,"code":"  it('should be able to work on a different scheduler', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a|');\n      const e1subs = '   ^---!';\n      const e2 = cold('      ---b--|');\n      const e2subs = '   ----^-----!';\n      const e3 = cold('            ---c--|');\n      const e3subs = '   ----------^-----!';\n      const expected = ' ---a---b-----c--|';\n\n      const result = of(e1, e2, e3, testScheduler).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatAll a nested observable with a single inner observable","suites":["concatAll operator"],"updatePoint":{"line":528,"column":73},"line":528,"code":"  it('should concatAll a nested observable with a single inner observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-|');\n      const e1subs = '   ^----!';\n      const expected = ' ---a-|';\n\n      const result = of(e1).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatAll a nested observable with a single inner observable, and a scheduler","suites":["concatAll operator"],"updatePoint":{"line":541,"column":90},"line":541,"code":"  it('should concatAll a nested observable with a single inner observable, and a scheduler', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-|');\n      const e1subs = '   ^----!';\n      const expected = ' ---a-|';\n\n      const result = of(e1, testScheduler).pipe(concatAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["concatAll operator"],"updatePoint":{"line":554,"column":73},"line":554,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    of(synchronousObservable).pipe(\n      concatAll(),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/concatAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":15,"column":55},"line":15,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   --1-----3--5-------|');\n      const e1subs = '   ^------------------!';\n      const e2 = cold('  x-x-x|              ', { x: 10 });\n      const expected = ' --x-x-x-y-y-yz-z-z-|';\n      const values = { x: 10, y: 30, z: 50 };\n\n      const result = e1.pipe(concatMap(x => e2.pipe(map(i => i * parseInt(x)))));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":30,"column":50},"line":30,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(\n        concatMap(\n          x => of(x, x + 1, x + 2),\n          (a, b, i, ii) => [a, b, i, ii]\n        )\n      )\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 1, 0, 0],\n            [1, 2, 0, 1],\n            [1, 3, 0, 2],\n            [2, 2, 1, 0],\n            [2, 3, 1, 1],\n            [2, 4, 1, 2],\n            [3, 3, 2, 0],\n            [3, 4, 2, 1],\n            [3, 5, 2, 2]\n          ]);\n        }\n      });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":63,"column":61},"line":63,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(concatMap(x => of(x, x + 1, x + 2), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5]);\n        }\n      });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatenate many regular interval inners","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":81,"column":53},"line":81,"code":"  it('should concatenate many regular interval inners', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  --a-a-a-(a|)                            ');\n      const asubs = '   ^-------!                               ';\n      const b = cold('          ----b--b--(b|)                  ');\n      const bsubs = '   --------^---------!                     ';\n      const c = cold('                           -c-c-(c|)      ');\n      const csubs = '   -------------------------^----!         ';\n      const d = cold('                                ------(d|)');\n      const dsubs = '   ------------------------------^-----!   ';\n      const e1 = hot('  a---b--------------------c-d----|       ');\n      const e1subs = '  ^-------------------------------!       ';\n      const expected = '--a-a-a-a---b--b--b-------c-c-c-----(d|)';\n\n      const observableLookup = { a: a, b: b, c: c, d: d };\n      const source = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer values to many inner values","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":107,"column":61},"line":107,"code":"  it('should concatMap many outer values to many inner values', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|                        ');\n      const e1subs = '    ^----------------!                        ';\n      const inner = cold(' --i-j-k-l-|                              ', values);\n      const innersubs = [\n        '                 -^---------!                              ',\n        '                 -----------^---------!                    ',\n        '                 ---------------------^---------!          ',\n        '                 -------------------------------^---------!'\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l-|';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":129,"column":35},"line":129,"code":"  it('should handle an empty source', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   |');\n      const e1subs = '    (^!)';\n      const inner = cold('-1-2-3|');\n      const innersubs: string[] = [];\n      const expected = '  |';\n\n      const result = e1.pipe(concatMap(() => inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":145,"column":34},"line":145,"code":"  it('should handle a never source', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   -');\n      const e1subs = '    ^';\n      const inner = cold('-1-2-3|');\n      const innersubs: string[] = [];\n      const expected = '  -';\n\n      const result = e1.pipe(\n        concatMap(() => {\n          return inner;\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should error immediately if given a just-throw source","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":165,"column":59},"line":165,"code":"  it('should error immediately if given a just-throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   #');\n      const e1subs = '    (^!)';\n      const inner = cold('-1-2-3|');\n      const innersubs: string[] = [];\n      const expected = '  #';\n\n      const result = e1.pipe(\n        concatMap(() => {\n          return inner;\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a silenced version of the source if the mapped inner is empty","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":185,"column":81},"line":185,"code":"  it('should return a silenced version of the source if the mapped inner is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   --a-b--c-| ');\n      const e1subs = '    ^--------! ';\n      const inner = cold('  |');\n      const innersubs = [\n        '                 --(^!)     ',\n        '                 ----(^!)   ',\n        '                 -------(^!)'\n      ];\n      const expected = '  ---------| ';\n\n      const result = e1.pipe(\n        concatMap(() => {\n          return inner;\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a never if the mapped inner is never","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":209,"column":56},"line":209,"code":"  it('should return a never if the mapped inner is never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a-b--c-|');\n      const e1subs = '   ^--------!';\n      const inner = cold(' -');\n      const innersubs = '--^-------';\n      const expected = ' ----------';\n\n      const result = e1.pipe(\n        concatMap(() => {\n          return inner;\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors if the mapped inner is a just-throw Observable","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":229,"column":76},"line":229,"code":"  it('should propagate errors if the mapped inner is a just-throw Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  --a-b--c-|');\n      const e1subs = '   ^-!       ';\n      const inner = cold(' #');\n      const innersubs = '--(^!)    ';\n      const expected = ' --#       ';\n\n      const result = e1.pipe(\n        concatMap(() => {\n          return inner;\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, complete late","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":249,"column":62},"line":249,"code":"  it('should concatMap many outer to many inner, complete late', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d----------------------------------|');\n      const e1subs = '    ^-----------------------------------------------!';\n      const inner = cold(' --i-j-k-l-|                                     ', values);\n      const innersubs = [\n        '                 -^---------!                                     ',\n        '                 -----------^---------!                           ',\n        '                 ---------------------^---------!                 ',\n        '                 -------------------------------^---------!       '\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l--------|';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, outer never completes","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":271,"column":70},"line":271,"code":"  it('should concatMap many outer to many inner, outer never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d-----------------------------------');\n      const e1subs = '    ^------------------------------------------------';\n      const inner = cold(' --i-j-k-l-|                                     ', values);\n      const innersubs = [\n        '                 -^---------!                                     ',\n        '                 -----------^---------!                           ',\n        '                 ---------------------^---------!                 ',\n        '                 -------------------------------^---------!       '\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l---------';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, inner never completes","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":293,"column":70},"line":293,"code":"  it('should concatMap many outer to many inner, inner never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|');\n      const e1subs = '    ^----------------!';\n      const inner = cold(' --i-j-k-l-       ', values);\n      const innersubs = ' -^----------------';\n      const expected = '  ---i-j-k-l--------';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, and inner throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":310,"column":65},"line":310,"code":"  it('should concatMap many outer to many inner, and inner throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|');\n      const e1subs = '    ^----------!      ';\n      const inner = cold(' --i-j-k-l-#      ', values);\n      const innersubs = ' -^---------!      ';\n      const expected = '  ---i-j-k-l-#      ';\n\n      const result = e1.pipe(concatMap(() => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, and outer throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":327,"column":65},"line":327,"code":"  it('should concatMap many outer to many inner, and outer throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---#');\n      const e1subs = '    ^----------------!';\n      const inner = cold(' --i-j-k-l-|      ', values);\n      const innersubs = [\n        '                 -^---------!      ',\n        '                 -----------^-----!'\n      ];\n      const expected = '  ---i-j-k-l---i-j-#';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to many inner, both inner and outer throw","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":347,"column":75},"line":347,"code":"  it('should concatMap many outer to many inner, both inner and outer throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---#');\n      const e1subs = '    ^----------!      ';\n      const inner = cold(' --i-j-k-l-#      ', values);\n      const innersubs = ' -^---------!      ';\n      const expected = '  ---i-j-k-l-#      ';\n\n      const result = e1.pipe(concatMap(value => inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(inner.subscriptions).toBe(innersubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, where all inners are finite","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":364,"column":64},"line":364,"code":"  it('should concatMap many complex, where all inners are finite', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs = '         ---------------------------^------------------!        ';\n      const f = cold('                                                      --|      ');\n      const fsubs = '         ----------------------------------------------^-!      ';\n      const g = cold('                                                        ---1-2|');\n      const gsubs = '         ------------------------------------------------^-----!';\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^--------------------------------------!               ';\n      const expected = '      ---2--3--4--5----6-----2--3-1------2--3-4-5--------1-2|';\n      const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, all inners finite except one","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":399,"column":65},"line":399,"code":"  it('should concatMap many complex, all inners finite except one', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3-                           ');\n      const dsubs = '         -------------------^-----------------------------------';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs: string[] = [];\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^--------------------------------------!               ';\n      const expected = '      ---2--3--4--5----6-----2--3----------------------------';\n      const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, inners finite, outer does not complete","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":434,"column":75},"line":434,"code":"  it('should concatMap many complex, inners finite, outer does not complete', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs = '         ---------------------------^------------------!        ';\n      const f = cold('                                                      --|      ');\n      const fsubs = '         ----------------------------------------------^-!      ';\n      const g = cold('                                                        ---1-2|');\n      const gsubs = '         ------------------------------------------------^-----!';\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g---             ');\n      const e1subs = '        ^                                                      ';\n      const expected = '      ---2--3--4--5----6-----2--3-1------2--3-4-5--------1-2-';\n      const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, all inners finite, and outer throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":469,"column":72},"line":469,"code":"  it('should concatMap many complex, all inners finite, and outer throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs = '         ---------------------------^-----------!               ';\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g#               ');\n      const e1subs = '        ^--------------------------------------!               ';\n      const expected = '      ---2--3--4--5----6-----2--3-1------2--3#               ';\n      const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, all inners complete except one throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":504,"column":74},"line":504,"code":"  it('should concatMap many complex, all inners complete except one throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-#                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs: string[] = [];\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs: string[] = [];\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^------------------!                                   ';\n      const expected = '      ---2--3--4--5----6-#                                   ';\n      const observableLookup = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value as keyof typeof observableLookup]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, all inners finite, outer is unsubscribed early","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":539,"column":83},"line":539,"code":"  it('should concatMap many complex, all inners finite, outer is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs = '         ---------------------------^--!                        ';\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^-----------------------------!                        ';\n      const unsub = '         ^-----------------------------!                        ';\n      const expected = '      ---2--3--4--5----6-----2--3-1--                        ';\n      const observableLookup: Record<string, Observable<string>> = {\n        a: a,\n        b: b,\n        c: c,\n        d: d,\n        e: e,\n        f: f,\n        g: g\n      };\n\n      const result = e1.pipe(concatMap(value => observableLookup[value]));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":583,"column":83},"line":583,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                          ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs = '         ---------------------------^--!                        ';\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^-----------------------------!                        ';\n      const unsub = '         ^-----------------------------!                        ';\n      const expected = '      ---2--3--4--5----6-----2--3-1--                        ';\n      const observableLookup: Record<string, Observable<string>> = {\n        a: a,\n        b: b,\n        c: c,\n        d: d,\n        e: e,\n        f: f,\n        g: g\n      };\n\n      const result = e1.pipe(\n        mergeMap(x => of(x)),\n        concatMap(value => observableLookup[value]),\n        mergeMap(x => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many complex, all inners finite, project throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":631,"column":70},"line":631,"code":"  it('should concatMap many complex, all inners finite, project throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('   -#                                                          ');\n      const asubs: string[] = [];\n      const b = cold('     -#                                                        ');\n      const bsubs: string[] = [];\n      const c = cold('          -2--3--4--5----6-|                                   ');\n      const csubs = '         --^----------------!                                   ';\n      const d = cold('                           ----2--3|                           ');\n      const dsubs = '         -------------------^-------!                           ';\n      const e = cold('                                   -1------2--3-4-5---|        ');\n      const esubs: string[] = [];\n      const f = cold('                                                      --|      ');\n      const fsubs: string[] = [];\n      const g = cold('                                                        ---1-2|');\n      const gsubs: string[] = [];\n      const e1 = hot('  -a-b--^-c-----d------e----------------f-----g|               ');\n      const e1subs = '        ^--------------------------!                           ';\n      const expected = '      ---2--3--4--5----6-----2--3#                           ';\n      const observableLookup: Record<string, Observable<string>> = {\n        a: a,\n        b: b,\n        c: c,\n        d: d,\n        e: e,\n        f: f,\n        g: g\n      };\n\n      const result = e1.pipe(\n        concatMap(value => {\n          if (value === 'e') {\n            throw 'error';\n          }\n          return observableLookup[value];\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize before moving to the next observable","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":681,"column":58},"line":681,"code":"  it('should finalize before moving to the next observable', () => {\n    const results: any[] = [];\n\n    const create = (n: number) => defer(() => {\n      results.push(`init ${n}`);\n      return of(`next ${n}`).pipe(\n        delay(100, testScheduler),\n        finalize(() => {\n          results.push(`finalized ${n}`)\n        })\n      );\n    });\n\n    of(1, 2, 3).pipe(\n      concatMap(n => create(n))\n    ).subscribe({\n      next: value => results.push(value),\n    });\n\n    testScheduler.flush();\n\n    expect(results).to.deep.equal([\n      'init 1',\n      'next 1',\n      'finalized 1',\n      'init 2',\n      'next 2',\n      'finalized 2',\n      'init 3',\n      'next 3',\n      'finalized 3'\n    ]);\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to an array for each value","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":723,"column":60},"line":723,"code":"  it('should concatMap many outer to an array for each value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^-------------------------------!';\n      const expected = '(22)--(4444)---(333)----(22)----|';\n\n      const result = e1.pipe(concatMap(value => arrayRepeat(value, +value)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to inner arrays, outer unsubscribed early","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":736,"column":75},"line":736,"code":"  it('should concatMap many outer to inner arrays, outer unsubscribed early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^------------!                   ';\n      const unsub = '   ^------------!                   ';\n      const expected = '(22)--(4444)--                   ';\n\n      const result = e1.pipe(concatMap(value => arrayRepeat(value, +value)));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMap many outer to inner arrays, project throws","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":750,"column":65},"line":750,"code":"  it('should concatMap many outer to inner arrays, project throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^--------------!                 ';\n      const expected = '(22)--(4444)---#                 ';\n\n      let invoked = 0;\n      const result = e1.pipe(\n        concatMap(value => {\n          invoked++;\n          if (invoked === 3) {\n            throw 'error';\n          }\n          return arrayRepeat(value, +value);\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant resolved promises and concatenate","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":772,"column":69},"line":772,"code":"  it('should map values to constant resolved promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: number) => from(Promise.resolve(42));\n\n    const results: number[] = [];\n    source.pipe(concatMap(project)).subscribe(\n      { next: x => {\n        results.push(x);\n      }, error: err => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      }, complete: () => {\n        expect(results).to.deep.equal([42, 42, 42, 42]);\n        done();\n      } }\n    );\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant rejected promises and concatenate","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":789,"column":69},"line":789,"code":"  it('should map values to constant rejected promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: any) => from(Promise.reject(42));\n\n    source.pipe(concatMap(project)).subscribe(\n      { next: x => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      }, error: err => {\n        expect(err).to.deep.equal(42);\n        done();\n      }, complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      } }\n    );\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to resolved promises and concatenate","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":805,"column":60},"line":805,"code":"  it('should map values to resolved promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: number, index: number) => from(Promise.resolve(value + index));\n\n    const results: number[] = [];\n    source.pipe(concatMap(project)).subscribe(\n      { next: x => {\n        results.push(x);\n      }, error: err => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      }, complete: () => {\n        expect(results).to.deep.equal([4, 4, 4, 4]);\n        done();\n      } }\n    );\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to rejected promises and concatenate","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":822,"column":60},"line":822,"code":"  it('should map values to rejected promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: number, index: number) => from(Promise.reject('' + value + '-' + index));\n\n    source.pipe(concatMap(project)).subscribe(\n      { next: x => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      }, error: err => {\n        expect(err).to.deep.equal('4-0');\n        done();\n      }, complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      } }\n    );\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["Observable.prototype.concatMap"],"updatePoint":{"line":838,"column":73},"line":838,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      concatMap(value => of(value)),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/concatMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["concatMapTo"],"updatePoint":{"line":15,"column":55},"line":15,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1-----3--5-------|');\n      const e1subs = '  ^------------------!';\n      const e2 = cold(' x-x-x|              ', { x: 10 });\n      const expected = '--x-x-x-x-x-xx-x-x-|';\n      const values = { x: 10 };\n\n      const result = e1.pipe(concatMapTo(e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["concatMapTo"],"updatePoint":{"line":30,"column":50},"line":30,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3).pipe(\n      concatMapTo(\n        of(4, 5, 6),\n        (a, b, i, ii) => [a, b, i, ii]\n      )\n    )\n    .subscribe({\n      next (value) {\n        results.push(value);\n      },\n      error(err) {\n        throw err;\n      },\n      complete() {\n        expect(results).to.deep.equal([\n          [1, 4, 0, 0],\n          [1, 5, 0, 1],\n          [1, 6, 0, 2],\n          [2, 4, 1, 0],\n          [2, 5, 1, 1],\n          [2, 6, 1, 2],\n          [3, 4, 2, 0],\n          [3, 5, 2, 1],\n          [3, 6, 2, 2],\n        ]);\n      }\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["concatMapTo"],"updatePoint":{"line":62,"column":61},"line":62,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3).pipe(\n      concatMapTo(\n        of(4, 5, 6),\n        void 0\n      )\n    )\n    .subscribe({\n      next (value) {\n        results.push(value);\n      },\n      error(err) {\n        throw err;\n      },\n      complete() {\n        expect(results).to.deep.equal([\n          4, 5, 6, 4, 5, 6, 4, 5, 6\n        ]);\n      }\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer values to many inner values","suites":["concatMapTo"],"updatePoint":{"line":86,"column":63},"line":86,"code":"  it('should concatMapTo many outer values to many inner values', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|                        ');\n      const e1subs = '    ^----------------!                        ';\n      const inner = cold('--i-j-k-l-|                               ', values);\n      const innerSubs = [\n        '                 -^---------!                              ',\n        '                 -----------^---------!                    ',\n        '                 ---------------------^---------!          ',\n        '                 -------------------------------^---------!'\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l-|';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["concatMapTo"],"updatePoint":{"line":108,"column":35},"line":108,"code":"  it('should handle an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const inner = cold('-1-2-3|');\n      const innerSubs: string[] = [];\n      const expected = '|';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["concatMapTo"],"updatePoint":{"line":124,"column":34},"line":124,"code":"  it('should handle a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const inner = cold('-1-2-3|');\n      const innerSubs: string[] = [];\n      const expected = '-';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should error immediately if given a just-throw source","suites":["concatMapTo"],"updatePoint":{"line":140,"column":59},"line":140,"code":"  it('should error immediately if given a just-throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const inner = cold('-1-2-3|');\n      const innerSubs: string[] = [];\n      const expected = '#';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a silenced version of the source if the mapped inner is empty","suites":["concatMapTo"],"updatePoint":{"line":156,"column":81},"line":156,"code":"  it('should return a silenced version of the source if the mapped inner is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   --a-b--c-|');\n      const e1subs = '    ^--------!';\n      const inner = cold('|');\n      const innerSubs = [\n        '                 --(^!)     ',\n        '                 ----(^!)   ',\n        '                 -------(^!)'\n      ];\n      const expected = '  ---------|';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a never if the mapped inner is never","suites":["concatMapTo"],"updatePoint":{"line":176,"column":56},"line":176,"code":"  it('should return a never if the mapped inner is never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   --a-b--c-|');\n      const e1subs = '    ^--------!';\n      const inner = cold('-');\n      const innerSubs = ' --^       ';\n      const expected = '  ----------';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors if the mapped inner is a just-throw Observable","suites":["concatMapTo"],"updatePoint":{"line":192,"column":76},"line":192,"code":"  it('should propagate errors if the mapped inner is a just-throw Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('   --a-b--c-|');\n      const e1subs = '    ^-!       ';\n      const inner = cold('#');\n      const innerSubs = ' --(^!)    ';\n      const expected = '  --#';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, complete late","suites":["concatMapTo"],"updatePoint":{"line":208,"column":64},"line":208,"code":"  it('should concatMapTo many outer to many inner, complete late', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d----------------------------------|');\n      const e1subs = '    ^-----------------------------------------------!';\n      const inner = cold('--i-j-k-l-|                                      ', values);\n      const innerSubs = [\n        '                 -^---------!                                     ',\n        '                 -----------^---------!                           ',\n        '                 ---------------------^---------!                 ',\n        '                 -------------------------------^---------!       '\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l--------|';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, outer never completes","suites":["concatMapTo"],"updatePoint":{"line":230,"column":72},"line":230,"code":"  it('should concatMapTo many outer to many inner, outer never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d-----------------------------------');\n      const e1subs = '    ^------------------------------------------------';\n      const inner = cold('--i-j-k-l-|                                      ', values);\n      const innerSubs = [\n        '                 -^---------!                                     ',\n        '                 -----------^---------!                           ',\n        '                 ---------------------^---------!                 ',\n        '                 -------------------------------^---------!       ',\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-l---i-j-k-l---i-j-k-l---------';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["concatMapTo"],"updatePoint":{"line":252,"column":83},"line":252,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---| ');\n      const e1subs = '    ^----------------! ';\n      const inner = cold('--i-j-k-l-|        ', values);\n      const innerSubs = [\n        '                 -^---------!       ',\n        '                 -----------^------!'\n      ];\n      const expected = '  ---i-j-k-l---i-j-k-';\n      const unsub = '     ------------------!';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        concatMapTo(inner),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, inner never completes","suites":["concatMapTo"],"updatePoint":{"line":277,"column":72},"line":277,"code":"  it('should concatMapTo many outer to many inner, inner never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|');\n      const e1subs = '    ^----------------!';\n      const inner = cold('--i-j-k-l-        ', values);\n      const innerSubs = ' -^                ';\n      const expected = '  ---i-j-k-l--------';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, and inner throws","suites":["concatMapTo"],"updatePoint":{"line":294,"column":67},"line":294,"code":"  it('should concatMapTo many outer to many inner, and inner throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---|');\n      const e1subs = '    ^----------!      ';\n      const inner = cold('--i-j-k-l-#       ', values);\n      const innerSubs = ' -^---------!      ';\n      const expected = '  ---i-j-k-l-#      ';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, and outer throws","suites":["concatMapTo"],"updatePoint":{"line":311,"column":67},"line":311,"code":"  it('should concatMapTo many outer to many inner, and outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---#');\n      const e1subs = '    ^----------------!';\n      const inner = cold('--i-j-k-l-|       ', values);\n      const innerSubs = [\n        '                 -^---------!      ',\n        '                 -----------^-----!'\n      ];\n      const expected = '  ---i-j-k-l---i-j-#';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to many inner, both inner and outer throw","suites":["concatMapTo"],"updatePoint":{"line":331,"column":77},"line":331,"code":"  it('should concatMapTo many outer to many inner, both inner and outer throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { i: 'foo', j: 'bar', k: 'baz', l: 'qux' };\n      const e1 = hot('    -a---b---c---d---#');\n      const e1subs = '    ^----------!      ';\n      const inner = cold('--i-j-k-l-#       ', values);\n      const innerSubs = ' -^---------!      ';\n      const expected = '  ---i-j-k-l-#      ';\n\n      const result = e1.pipe(concatMapTo(inner));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to an array","suites":["concatMapTo"],"updatePoint":{"line":348,"column":47},"line":348,"code":"  it('should concatMapTo many outer to an array', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const expected = '(0123)(0123)---(0123)---(0123)--|';\n\n      const result = e1.pipe(concatMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to inner arrays, and outer throws","suites":["concatMapTo"],"updatePoint":{"line":359,"column":69},"line":359,"code":"  it('should concatMapTo many outer to inner arrays, and outer throws', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  2-----4--------3--------2-------#');\n      const expected = '(0123)(0123)---(0123)---(0123)--#';\n\n      const result = e1.pipe(concatMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatMapTo many outer to inner arrays, outer unsubscribed early","suites":["concatMapTo"],"updatePoint":{"line":370,"column":77},"line":370,"code":"  it('should concatMapTo many outer to inner arrays, outer unsubscribed early', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const unsub = '   -------------!';\n      const expected = '(0123)(0123)--';\n\n      const result = e1.pipe(concatMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result, unsub).toBe(expected);\n    });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant resolved promises and concatenate","suites":["concatMapTo"],"updatePoint":{"line":382,"column":69},"line":382,"code":"  it('should map values to constant resolved promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n\n    const results: number[] = [];\n    source.pipe(concatMapTo(from(Promise.resolve(42)))).subscribe(\n      { next: (x) => {\n        results.push(x);\n      }, error: (err) => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      }, complete: () => {\n        expect(results).to.deep.equal([42, 42, 42, 42]);\n        done();\n      } });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant rejected promises and concatenate","suites":["concatMapTo"],"updatePoint":{"line":397,"column":69},"line":397,"code":"  it('should map values to constant rejected promises and concatenate', (done) => {\n    const source = from([4, 3, 2, 1]);\n\n    source.pipe(concatMapTo(from(Promise.reject(42)))).subscribe(\n      { next: (x) => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      }, error: (err) => {\n        expect(err).to.equal(42);\n        done();\n      }, complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      } });\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["concatMapTo"],"updatePoint":{"line":411,"column":73},"line":411,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      concatMapTo(of(0)),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/concatMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should concatenate two cold observables","suites":["concat operator"],"updatePoint":{"line":16,"column":45},"line":16,"code":"  it('should concatenate two cold observables', () => {\n    rxTest.run(({ cold, expectObservable }) => {\n      const e1 = cold(' --a--b-|');\n      const e2 = cold('        --x---y--|');\n      const expected = '--a--b---x---y--|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work properly with scalar observables","suites":["concat operator"],"updatePoint":{"line":26,"column":50},"line":26,"code":"  it('should work properly with scalar observables', (done) => {\n    const results: string[] = [];\n\n    const s1 = new Observable<number>(observer => {\n      setTimeout(() => {\n        observer.next(1);\n        observer.complete();\n      });\n    }).pipe(concatWith(of(2)));\n\n    s1.subscribe(\n      { next: x => {\n        results.push('Next: ' + x);\n      }, error: x => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        results.push('Completed');\n        expect(results).to.deep.equal(['Next: 1', 'Next: 2', 'Completed']);\n        done();\n      } }\n    );\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without emit if both sources are empty","suites":["concat operator"],"updatePoint":{"line":49,"column":60},"line":49,"code":"  it('should complete without emit if both sources are empty', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold('   ----|');\n      const e2subs = '  --^---!';\n      const expected = '------|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not completes","suites":["concat operator"],"updatePoint":{"line":63,"column":60},"line":63,"code":"  it('should not complete if first source does not completes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---');\n      const e1subs = '  ^--';\n      const e2 = cold('    --|');\n      const e2subs = NO_SUBS;\n      const expected = '---';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if second source does not completes","suites":["concat operator"],"updatePoint":{"line":77,"column":61},"line":77,"code":"  it('should not complete if second source does not completes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold('   ---');\n      const e2subs = '  --^--';\n      const expected = '-----';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if both sources do not complete","suites":["concat operator"],"updatePoint":{"line":91,"column":57},"line":91,"code":"  it('should not complete if both sources do not complete', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---');\n      const e1subs = '  ^--';\n      const e2 = cold('    ---');\n      const e2subs = NO_SUBS;\n      const expected = '---';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source is empty, second source raises error","suites":["concat operator"],"updatePoint":{"line":105,"column":79},"line":105,"code":"  it('should raise error when first source is empty, second source raises error', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold('   ----#');\n      const e2subs = '  --^---!';\n      const expected = '------#';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when first source raises error, second source is empty","suites":["concat operator"],"updatePoint":{"line":119,"column":79},"line":119,"code":"  it('should raise error when first source raises error, second source is empty', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#');\n      const e1subs = '  ^--!';\n      const e2 = cold('    ----|');\n      const expected = '---#';\n      const e2subs = NO_SUBS;\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise first error when both source raise error","suites":["concat operator"],"updatePoint":{"line":133,"column":59},"line":133,"code":"  it('should raise first error when both source raise error', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#');\n      const e1subs = '  ^--!';\n      const e2 = cold('    ------#');\n      const expected = '---#';\n      const e2subs = NO_SUBS;\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source emits once, second source is empty","suites":["concat operator"],"updatePoint":{"line":147,"column":70},"line":147,"code":"  it('should concat if first source emits once, second source is empty', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--|');\n      const e1subs = '  ^----!';\n      const e2 = cold('      --------|');\n      const e2subs = '  -----^-------!';\n      const expected = '--a----------|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should concat if first source is empty, second source emits once","suites":["concat operator"],"updatePoint":{"line":161,"column":70},"line":161,"code":"  it('should concat if first source is empty, second source emits once', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --|');\n      const e1subs = '  ^-!';\n      const e2 = cold('   --a--|');\n      const e2subs = '  --^----!';\n      const expected = '----a--|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if first source does not complete","suites":["concat operator"],"updatePoint":{"line":189,"column":59},"line":189,"code":"  it('should not complete if first source does not complete', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---');\n      const e1subs = '  ^--';\n      const e2 = cold('    --a--|');\n      const e2subs = NO_SUBS;\n      const expected = '---';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements from each source when source emit once","suites":["concat operator"],"updatePoint":{"line":203,"column":65},"line":203,"code":"  it('should emit elements from each source when source emit once', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a|');\n      const e1subs = '  ^---!';\n      const e2 = cold('     -----b--|');\n      const e2subs = '  ----^-------!';\n      const expected = '---a-----b--|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe to inner source if outer is unsubscribed early","suites":["concat operator"],"updatePoint":{"line":217,"column":71},"line":217,"code":"  it('should unsubscribe to inner source if outer is unsubscribed early', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  ---a-a--a|            ');\n      const e1subs = '   ^--------!            ';\n      const e2 = cold('           -----b-b--b-|');\n      const e2subs = '   ---------^-------!';\n      const unsub = '    -----------------!  ';\n      const expected = ' ---a-a--a-----b-b     ';\n\n      expectObservable(e1.pipe(concatWith(e2)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["concat operator"],"updatePoint":{"line":232,"column":83},"line":232,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-a--a|            ');\n      const e1subs = '  ^--------!            ';\n      const e2 = cold('          -----b-b--b-|');\n      const e2subs = '  ---------^--------!    ';\n      const expected = '---a-a--a-----b-b-    ';\n      const unsub = '   ------------------!    ';\n\n      const result = e1.pipe(\n        mergeMap(x => of(x)),\n        concatWith(e2),\n        mergeMap(x => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from first source and does not emit from second source","suites":["concat operator"],"updatePoint":{"line":253,"column":79},"line":253,"code":"  it('should raise error from first source and does not emit from second source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --#');\n      const e1subs = '  ^-!';\n      const e2 = cold('   ----a--|');\n      const e2subs = NO_SUBS;\n      const expected = '--#';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit element from first source then raise error from second source","suites":["concat operator"],"updatePoint":{"line":267,"column":79},"line":267,"code":"  it('should emit element from first source then raise error from second source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--|');\n      const e1subs = '  ^----!';\n      const e2 = cold('      -------#');\n      const e2subs = '  -----^------!';\n      const expected = '--a---------#';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit collapsing element from second source","suites":["concat operator"],"updatePoint":{"line":316,"column":59},"line":316,"code":"  it('should not emit collapsing element from second source', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const e2 = hot('  --------x--y--z--|');\n      const e2subs = '  -----------^-----!';\n      const expected = '--a--b--c--y--z--|';\n\n      expectObservable(e1.pipe(concatWith(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit self without parameters","suites":["concat operator"],"updatePoint":{"line":330,"column":41},"line":330,"code":"  it('should emit self without parameters', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-|');\n      const e1subs = '  ^----!';\n      const expected = '---a-|';\n\n      expectObservable(e1.pipe(concatWith())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["concat operator"],"updatePoint":{"line":341,"column":73},"line":341,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      concatWith(of(0)),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/concatWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect a source through a selector function","suites":["connect"],"updatePoint":{"line":14,"column":57},"line":14,"code":"  it('should connect a source through a selector function', () => {\n    rxTest.run(({ cold, time, expectObservable }) => {\n      const source = cold('---a----b-----c---|');\n      const d = time('        ---|');\n      const expected = '   ---a--a-b--b--c--c|';\n\n      const result = source.pipe(connect((shared) => merge(shared.pipe(delay(d)), shared)));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/connect-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect a source through a selector function and use the provided connector","suites":["connect"],"updatePoint":{"line":26,"column":88},"line":26,"code":"  it('should connect a source through a selector function and use the provided connector', () => {\n    rxTest.run(({ cold, time, expectObservable }) => {\n      const source = cold('--------a---------b---------c-----|');\n      const d = time('             ---|');\n      const expected = '   S--S----a--a------b--b------c--c--|';\n\n      const result = source.pipe(\n        connect(\n          (shared) => {\n            return merge(shared.pipe(delay(d)), shared);\n          },\n          {\n            connector: () => new BehaviorSubject('S'),\n          }\n        )\n      );\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/connect-spec.ts","skipped":false,"dir":"spec"},{"name":"should count the values of an observable","suites":["count"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should count the values of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--|');\n      const subs = '      ^----------!';\n      const expected = '  -----------(x|)';\n\n      expectObservable(source.pipe(count())).toBe(expected, { x: 3 });\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source is never","suites":["count"],"updatePoint":{"line":27,"column":42},"line":27,"code":"  it('should be never when source is never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(count())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should be zero when source is empty","suites":["count"],"updatePoint":{"line":38,"column":41},"line":38,"code":"  it('should be zero when source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '(w|)';\n\n      expectObservable(e1.pipe(count())).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source doesn't complete","suites":["count"],"updatePoint":{"line":49,"column":50},"line":49,"code":"  it(\"should be never when source doesn't complete\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--x--^--y--');\n      const e1subs = '     ^     ';\n      const expected = '   ------';\n\n      expectObservable(e1.pipe(count())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should be zero when source doesn't have values","suites":["count"],"updatePoint":{"line":60,"column":52},"line":60,"code":"  it(\"should be zero when source doesn't have values\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n\n      expectObservable(e1.pipe(count())).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should count the unique value of an observable","suites":["count"],"updatePoint":{"line":71,"column":52},"line":71,"code":"  it('should count the unique value of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--|');\n      const e1subs = '   ^-----!';\n      const expected = ' ------(w|)';\n\n      expectObservable(e1.pipe(count())).toBe(expected, { w: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should count the values of an ongoing hot observable","suites":["count"],"updatePoint":{"line":82,"column":58},"line":82,"code":"  it('should count the values of an ongoing hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a-^-b--c--d--|');\n      const subs = '          ^----------!';\n      const expected = '      -----------(x|)';\n\n      expectObservable(source.pipe(count())).toBe(expected, { x: 3 });\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should count a range() source observable","suites":["count"],"updatePoint":{"line":93,"column":46},"line":93,"code":"  it('should count a range() source observable', (done) => {\n    range(1, 10)\n      .pipe(count())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(10);\n        },\n        error: (x) => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should count a range().skip(1) source observable","suites":["count"],"updatePoint":{"line":109,"column":54},"line":109,"code":"  it('should count a range().skip(1) source observable', (done) => {\n    range(1, 10)\n      .pipe(skip(1), count())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(9);\n        },\n        error: (x) => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should count a range().take(1) source observable","suites":["count"],"updatePoint":{"line":125,"column":54},"line":125,"code":"  it('should count a range().take(1) source observable', (done) => {\n    range(1, 10)\n      .pipe(take(1), count())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(1);\n        },\n        error: (x) => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["count"],"updatePoint":{"line":141,"column":28},"line":141,"code":"  it('should work with error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--z--#', { x: 1, y: 2, z: 3 }, 'too bad');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable(e1.pipe(count())).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["count"],"updatePoint":{"line":152,"column":28},"line":152,"code":"  it('should work with throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(count())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-true predicate on an empty hot observable","suites":["count"],"updatePoint":{"line":163,"column":71},"line":163,"code":"  it('should handle an always-true predicate on an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n      const predicate = () => {\n        return true;\n      };\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-false predicate on an empty hot observable","suites":["count"],"updatePoint":{"line":177,"column":72},"line":177,"code":"  it('should handle an always-false predicate on an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n      const predicate = () => {\n        return false;\n      };\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-true predicate on a simple hot observable","suites":["count"],"updatePoint":{"line":191,"column":71},"line":191,"code":"  it('should handle an always-true predicate on a simple hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-|');\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n      const predicate = () => {\n        return true;\n      };\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-false predicate on a simple hot observable","suites":["count"],"updatePoint":{"line":205,"column":72},"line":205,"code":"  it('should handle an always-false predicate on a simple hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-|');\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n      const predicate = () => {\n        return false;\n      };\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["count"],"updatePoint":{"line":219,"column":53},"line":219,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--4-|');\n      const e1subs = '   ^-----!    ';\n      const expected = ' -------    ';\n      const unsub = '    ------!    ';\n\n      const result = e1.pipe(count((value: string) => parseInt(value) < 10));\n\n      expectObservable(result, unsub).toBe(expected, { w: 3 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["count"],"updatePoint":{"line":233,"column":83},"line":233,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--4-|');\n      const e1subs = '   ^-----!    ';\n      const expected = ' -------    ';\n      const unsub = '    ------!    ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        count((value: string) => parseInt(value) < 10),\n        mergeMap((x: number) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, { w: 3 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a match-all predicate on observable with many values","suites":["count"],"updatePoint":{"line":251,"column":72},"line":251,"code":"  it('should handle a match-all predicate on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--4-|');\n      const e1subs = '   ^---------!';\n      const expected = ' ----------(w|)';\n      const predicate = (value: string) => parseInt(value) < 10;\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 3 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a match-none predicate on observable with many values","suites":["count"],"updatePoint":{"line":263,"column":73},"line":263,"code":"  it('should handle a match-none predicate on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--4-|');\n      const e1subs = '   ^---------!';\n      const expected = ' ----------(w|)';\n      const predicate = (value: string) => parseInt(value) > 10;\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected, { w: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-true predicate on observable that throws","suites":["count"],"updatePoint":{"line":275,"column":70},"line":275,"code":"  it('should handle an always-true predicate on observable that throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^---#');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n      const predicate = () => true;\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-false predicate on observable that throws","suites":["count"],"updatePoint":{"line":287,"column":71},"line":287,"code":"  it('should handle an always-false predicate on observable that throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^---#');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n      const predicate = () => false;\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an always-true predicate on a hot never-observable","suites":["count"],"updatePoint":{"line":299,"column":70},"line":299,"code":"  it('should handle an always-true predicate on a hot never-observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^----');\n      const e1subs = '   ^    ';\n      const expected = ' -----';\n      const predicate = () => true;\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a predicate that throws, on observable with many values","suites":["count"],"updatePoint":{"line":311,"column":75},"line":311,"code":"  it('should handle a predicate that throws, on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--|');\n      const e1subs = '   ^----!   ';\n      const expected = ' -----#   ';\n      const predicate = (value: string) => {\n        if (value === '3') {\n          throw 'error';\n        }\n        return true;\n      };\n\n      expectObservable(e1.pipe(count(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/count-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce values by a specified cold Observable","suites":["debounce"],"updatePoint":{"line":20,"column":59},"line":20,"code":"  it('should debounce values by a specified cold Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a----bc----d-ef----|');\n      const e1subs = '  ^-------------------!';\n      const e2 = cold('  ---x                ');\n      //                       ---x\n      //                               ---x\n      const e2subs = [\n        '               -^--!                ',\n        '               ------^!             ',\n        '               -------^--!          ',\n        '               ------------^-!      ',\n        '               --------------^!     ',\n        '               ---------------^--!  ',\n      ];\n      const expected = '----a-----c-------f-|';\n\n      const result = e1.pipe(debounce(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay all element by selector observable","suites":["debounce"],"updatePoint":{"line":45,"column":53},"line":45,"code":"  it('should delay all element by selector observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d---------|');\n      const e1subs = '  ^--------------------!';\n      const expected = '----a--b--c--d-------|';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce by selector observable","suites":["debounce"],"updatePoint":{"line":56,"column":44},"line":56,"code":"  it('should debounce by selector observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^-------------!';\n      const expected = '----a---c--d--|';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a scalar selector observable","suites":["debounce"],"updatePoint":{"line":67,"column":49},"line":67,"code":"  it('should support a scalar selector observable', () => {\n    // If the selector returns a scalar observable, the debounce operator\n    // should emit the value immediately.\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^-------------!';\n      const expected = '--a--bc--d----|';\n\n      expectObservable(e1.pipe(debounce(() => of(0)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["debounce"],"updatePoint":{"line":80,"column":47},"line":80,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const e1subs = '  ^----!';\n      const expected = '-----|';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source is empty","suites":["debounce"],"updatePoint":{"line":91,"column":42},"line":91,"code":"  it('should complete when source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["debounce"],"updatePoint":{"line":102,"column":67},"line":102,"code":"  it('should raise error when source does not emit and raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----#');\n      const e1subs = '  ^----!';\n      const expected = '-----#';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source throws","suites":["debounce"],"updatePoint":{"line":113,"column":43},"line":113,"code":"  it('should raise error when source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["debounce"],"updatePoint":{"line":124,"column":53},"line":124,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^------!       ';\n      const expected = '----a---       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(debounce(getTimerSelector(2)));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["debounce"],"updatePoint":{"line":138,"column":73},"line":138,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^------!       ';\n      const expected = '----a---       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        debounce(getTimerSelector(2)),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce and does not complete when source does not completes","suites":["debounce"],"updatePoint":{"line":156,"column":74},"line":156,"code":"  it('should debounce and does not complete when source does not completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d---');\n      const e1subs = '  ^            ';\n      const expected = '----a---c--d-';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source does not complete","suites":["debounce"],"updatePoint":{"line":167,"column":55},"line":167,"code":"  it('should not complete when source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes when source never completes","suites":["debounce"],"updatePoint":{"line":178,"column":54},"line":178,"code":"  it('should not completes when source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay all element until source raises error","suites":["debounce"],"updatePoint":{"line":189,"column":56},"line":189,"code":"  it('should delay all element until source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d---------#');\n      const e1subs = '  ^--------------------!';\n      const expected = '----a--b--c--d-------#';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(2)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce all elements while source emits by selector observable","suites":["debounce"],"updatePoint":{"line":200,"column":76},"line":200,"code":"  it('should debounce all elements while source emits by selector observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c---d---e|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--------------------(e|)';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(4)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce all element while source emits by selector observable until raises error","suites":["debounce"],"updatePoint":{"line":211,"column":94},"line":211,"code":"  it('should debounce all element while source emits by selector observable until raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d-#');\n      const e1subs = '  ^------------!';\n      const expected = '-------------#';\n\n      expectObservable(e1.pipe(debounce(getTimerSelector(5)))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay element by same selector observable emits multiple","suites":["debounce"],"updatePoint":{"line":222,"column":69},"line":222,"code":"  it('should delay element by same selector observable emits multiple', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       ----a--b--c----d-----e-------|');\n      const e1subs = '       ^----------------------------!';\n      const expected = '     ------a--b--c----d-----e-----|';\n      const selector = cold('--x-y-');\n      const selectorSubs = [\n        '                    ----^-!                      ',\n        '                    -------^-!                   ',\n        '                    ----------^-!                ',\n        '                    ---------------^-!           ',\n        '                    ---------------------^-!     ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce by selector observable emits multiple","suites":["debounce"],"updatePoint":{"line":242,"column":59},"line":242,"code":"  it('should debounce by selector observable emits multiple', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--b--c----d-----e-------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------a-----c----------e-----|';\n      const selector = [\n        cold('              --x-y-                    '),\n        cold('                 ----x-y-               '),\n        cold('                    --x-y-              '),\n        cold('                         ------x-y-     '),\n        cold('                               --x-y-   '),\n      ];\n      const selectorSubs = [\n        '               ----^-!                       ',\n        '               -------^--!                   ',\n        '               ----------^-!                 ',\n        '               ---------------^-----!        ',\n        '               ---------------------^-!      ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce by selector observable until source completes","suites":["debounce"],"updatePoint":{"line":270,"column":67},"line":270,"code":"  it('should debounce by selector observable until source completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--b--c----d----e|    ');\n      const e1subs = '  ^--------------------!    ';\n      const expected = '------a-----c--------(e|) ';\n      const selector = [\n        cold('              --x-y-                '),\n        cold('                 ----x-y-           '),\n        cold('                    --x-y-          '),\n        cold('                         ------x-y- '),\n        cold('                              --x-y-'),\n      ];\n      const selectorSubs = [\n        '               ----^-!                   ',\n        '               -------^--!               ',\n        '               ----------^-!             ',\n        '               ---------------^----!     ',\n        '               --------------------^!    ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when selector observable raises error","suites":["debounce"],"updatePoint":{"line":298,"column":62},"line":298,"code":"  it('should raise error when selector observable raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a--------b--------c---------|');\n      const e1subs = '  ^----------------------------!       ';\n      const expected = '---------a---------b---------#       ';\n      const selector = [\n        cold('                  -x-y-                        '),\n        cold('                           --x-y-              '),\n        cold('                                    ---#       '),\n      ];\n      const selectorSubs = [\n        '               --------^!                           ',\n        '               -----------------^-!                 ',\n        '               --------------------------^--!       ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error with selector observable","suites":["debounce"],"updatePoint":{"line":322,"column":74},"line":322,"code":"  it('should raise error when source raises error with selector observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a--------b--------c---------d#      ');\n      const e1subs = '  ^------------------------------------!      ';\n      const expected = '---------a---------b---------c-------#      ';\n      const selector = [\n        cold('                  -x-y-                               '),\n        cold('                           --x-y-                     '),\n        cold('                                    ---x-y-           '),\n        cold('                                              ----x-y-'),\n      ];\n      const selectorSubs = [\n        '               --------^!                                  ',\n        '               -----------------^-!                        ',\n        '               --------------------------^--!              ',\n        '               ------------------------------------^!      ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when selector function throws","suites":["debounce"],"updatePoint":{"line":348,"column":54},"line":348,"code":"  it('should raise error when selector function throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a--------b--------c---------|');\n      const e1subs = '  ^-------------------------!          ';\n      const expected = '---------a---------b------#          ';\n      // prettier-ignore\n      const selector = [\n        cold('                  -x-y-                        '),\n        cold('                           --x-y-              '),\n      ];\n      // prettier-ignore\n      const selectorSubs = [\n        '               --------^!                           ',\n        '               -----------------^-!                 ',\n      ];\n\n      function selectorFunction(x: string) {\n        if (x !== 'c') {\n          return selector.shift();\n        } else {\n          throw 'error';\n        }\n      }\n\n      expectObservable(e1.pipe(debounce(selectorFunction as any))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore all values except last, when given an empty selector Observable","suites":["debounce"],"updatePoint":{"line":380,"column":83},"line":380,"code":"  it('should ignore all values except last, when given an empty selector Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a-x-yz---bxy---z--c--x--y--z|   ');\n      const e1subs = '  ^-----------------------------------!   ';\n      const expected = '------------------------------------(z|)';\n\n      function selectorFunction(x: string) {\n        return EMPTY;\n      }\n\n      expectObservable(e1.pipe(debounce(selectorFunction))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore all values except last, when given a never selector Observable","suites":["debounce"],"updatePoint":{"line":395,"column":82},"line":395,"code":"  it('should ignore all values except last, when given a never selector Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a-x-yz---bxy---z--c--x--y--z|  ');\n      const e1subs = '  ^-----------------------------------!  ';\n      const expected = '------------------------------------(z|)';\n\n      function selectorFunction() {\n        return NEVER;\n      }\n\n      expectObservable(e1.pipe(debounce(selectorFunction))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not delay by selector observable completes when it does not emits","suites":["debounce"],"updatePoint":{"line":410,"column":78},"line":410,"code":"  it('should not delay by selector observable completes when it does not emits', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------a--------b--------c---------|   ');\n      const e1subs = '  ^-----------------------------------!   ';\n      const expected = '------------------------------------(c|)';\n      const selector = [\n        cold('                  -|                              '),\n        cold('                           --|                    '),\n        cold('                                    ---|          '),\n      ];\n      const selectorSubs = [\n        '               --------^!                              ',\n        '               -----------------^-!                    ',\n        '               --------------------------^--!          ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not debounce by selector observable completes when it does not emits","suites":["debounce"],"updatePoint":{"line":434,"column":81},"line":434,"code":"  it('should not debounce by selector observable completes when it does not emits', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--b-c---------de-------------|   ');\n      const e1subs = '  ^---------------------------------!   ';\n      const expected = '----------------------------------(e|)';\n      const selector = [\n        cold('              -|                                '),\n        cold('                 --|                            '),\n        cold('                   ---|                         '),\n        cold('                             ----|              '),\n        cold('                              -----|            '),\n      ];\n      const selectorSubs = [\n        '               ----^!                                ',\n        '               -------^-!                            ',\n        '               ---------^--!                         ',\n        '               -------------------^!                 ',\n        '               --------------------^----!            ',\n      ];\n\n      expectObservable(e1.pipe(debounce(() => selector.shift()!))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let i = 0; i < selectorSubs.length; i++) {\n        expectSubscriptions(selector[i].subscriptions).toBe(selectorSubs[i]);\n      }\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by promise resolves","suites":["debounce"],"updatePoint":{"line":462,"column":38},"line":462,"code":"  it('should delay by promise resolves', (done) => {\n    const e1 = concat(of(1), timer(10).pipe(mapTo(2)), timer(10).pipe(mapTo(3)), timer(100).pipe(mapTo(4)));\n    const expected = [1, 2, 3, 4];\n\n    e1.pipe(\n      debounce(() => {\n        return new Promise((resolve: any) => {\n          resolve(42);\n        });\n      })\n    ).subscribe({\n      next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(expected.length).to.equal(0);\n        done();\n      },\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error when promise rejects","suites":["debounce"],"updatePoint":{"line":486,"column":46},"line":486,"code":"  it('should raises error when promise rejects', (done) => {\n    const e1 = concat(of(1), timer(10).pipe(mapTo(2)), timer(10).pipe(mapTo(3)), timer(100).pipe(mapTo(4)));\n    const expected = [1, 2];\n    const error = new Error('error');\n\n    e1.pipe(\n      debounce((x: number) => {\n        if (x === 3) {\n          return new Promise((resolve: any, reject: any) => {\n            reject(error);\n          });\n        } else {\n          return new Promise((resolve: any) => {\n            resolve(42);\n          });\n        }\n      })\n    ).subscribe({\n      next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: (err: any) => {\n        expect(err).to.be.an('error', 'error');\n        expect(expected.length).to.equal(0);\n        done();\n      },\n      complete: () => {\n        done(new Error('should not be called'));\n      },\n    });\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce correctly when synchronously reentered","suites":["debounce"],"updatePoint":{"line":518,"column":60},"line":518,"code":"  it('should debounce correctly when synchronously reentered', () => {\n    const results: number[] = [];\n    const source = new Subject<number>();\n\n    source.pipe(debounce(() => of(null))).subscribe((value) => {\n      results.push(value);\n\n      if (value === 1) {\n        source.next(2);\n      }\n    });\n    source.next(1);\n\n    expect(results).to.deep.equal([1, 2]);\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["debounce"],"updatePoint":{"line":534,"column":73},"line":534,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        debounce(() => of(0)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/debounce-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce values by 2 time units","suites":["debounceTime"],"updatePoint":{"line":19,"column":44},"line":19,"code":"  it('should debounce values by 2 time units', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--bc--d---|');\n      const e1subs = '  ^-----------!';\n      const expected = '---a---c--d-|';\n      const t = time('  --|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay all elements by the specified time","suites":["debounceTime"],"updatePoint":{"line":31,"column":53},"line":31,"code":"  it('should delay all elements by the specified time', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--------b------c----|');\n      const e1subs = '  ^---------------------!';\n      const expected = '------a--------b------(c|)';\n      const t = time('  -----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce and delay element by the specified time","suites":["debounceTime"],"updatePoint":{"line":43,"column":61},"line":43,"code":"  it('should debounce and delay element by the specified time', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--(bc)-----------d-------|');\n      const e1subs = '  ^--------------------------!';\n      const expected = '---------c--------------d--|';\n      const t = time('  -----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["debounceTime"],"updatePoint":{"line":55,"column":47},"line":55,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const e1subs = '  ^----!';\n      const expected = '-----|';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source is empty","suites":["debounceTime"],"updatePoint":{"line":67,"column":42},"line":67,"code":"  it('should complete when source is empty', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["debounceTime"],"updatePoint":{"line":79,"column":67},"line":79,"code":"  it('should raise error when source does not emit and raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----#');\n      const e1subs = '  ^----!';\n      const expected = '-----#';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source throws","suites":["debounceTime"],"updatePoint":{"line":91,"column":43},"line":91,"code":"  it('should raise error when source throws', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["debounceTime"],"updatePoint":{"line":103,"column":53},"line":103,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^------!       ';\n      const expected = '----a---       ';\n      const unsub = '   -------!       ';\n      const t = time('  --|');\n\n      const result = e1.pipe(debounceTime(t));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["debounceTime"],"updatePoint":{"line":118,"column":73},"line":118,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--bc--d----|');\n      const e1subs = '  ^------!       ';\n      const expected = '----a---       ';\n      const unsub = '   -------!       ';\n      const t = time('  --|');\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        debounceTime(t),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce and does not complete when source does not completes","suites":["debounceTime"],"updatePoint":{"line":137,"column":74},"line":137,"code":"  it('should debounce and does not complete when source does not completes', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--(bc)-----------d-------');\n      const e1subs = '  ^--------------------------';\n      const expected = '---------c--------------d--';\n      const t = time('  -----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes when source does not completes","suites":["debounceTime"],"updatePoint":{"line":149,"column":57},"line":149,"code":"  it('should not completes when source does not completes', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes when source never completes","suites":["debounceTime"],"updatePoint":{"line":161,"column":54},"line":161,"code":"  it('should not completes when source never completes', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n      const t = time('  -|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay all elements until source raises error","suites":["debounceTime"],"updatePoint":{"line":173,"column":57},"line":173,"code":"  it('should delay all elements until source raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--------b------c----#');\n      const e1subs = '  ^---------------------!';\n      const expected = '------a--------b------#';\n      const t = time('  -----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce all elements while source emits within given time","suites":["debounceTime"],"updatePoint":{"line":185,"column":71},"line":185,"code":"  it('should debounce all elements while source emits within given time', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--h-|');\n      const e1subs = '  ^------------------------!';\n      const expected = '-------------------------(h|)';\n      const t = time('  ----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce all element while source emits within given time until raises error","suites":["debounceTime"],"updatePoint":{"line":197,"column":89},"line":197,"code":"  it('should debounce all element while source emits within given time until raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--h-#');\n      const e1subs = '  ^------------------------!';\n      const expected = '-------------------------#';\n      const t = time('  ----|');\n\n      expectObservable(e1.pipe(debounceTime(t))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should debounce correctly when synchronously reentered","suites":["debounceTime"],"updatePoint":{"line":209,"column":60},"line":209,"code":"  it('should debounce correctly when synchronously reentered', () => {\n    const results: number[] = [];\n    const source = new Subject<number>();\n    const scheduler = new VirtualTimeScheduler();\n\n    source.pipe(debounceTime(0, scheduler)).subscribe((value) => {\n      results.push(value);\n\n      if (value === 1) {\n        source.next(2);\n      }\n    });\n    source.next(1);\n    scheduler.flush();\n\n    expect(results).to.deep.equal([1, 2]);\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from the scheduled debounce action when downstream unsubscribes","suites":["debounceTime"],"updatePoint":{"line":227,"column":88},"line":227,"code":"  it('should unsubscribe from the scheduled debounce action when downstream unsubscribes', () => {\n    const scheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n    expect(scheduler._scheduled).to.not.exist;\n    expect(scheduler.actions).to.be.empty;\n\n    const subscription = NEVER.pipe(startWith(1), debounceTime(0, scheduler)).subscribe();\n\n    expect(scheduler._scheduled).to.exist;\n    expect(scheduler.actions.length).to.equal(1);\n\n    subscription.unsubscribe();\n\n    expect(scheduler._scheduled).to.not.exist;\n    expect(scheduler.actions).to.be.empty;\n  });","file":"operators/debounceTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the Observable if not empty with a default value","suites":["defaultIfEmpty"],"updatePoint":{"line":16,"column":68},"line":16,"code":"  it('should return the Observable if not empty with a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------|');\n      const e1subs = '  ^-------!';\n      const expected = '--------(x|)';\n\n      expectObservable(e1.pipe(defaultIfEmpty(42))).toBe(expected, { x: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the argument if Observable is empty","suites":["defaultIfEmpty"],"updatePoint":{"line":27,"column":55},"line":27,"code":"  it('should return the argument if Observable is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(defaultIfEmpty('x'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the Observable if not empty with a default value","suites":["defaultIfEmpty"],"updatePoint":{"line":38,"column":68},"line":38,"code":"  it('should return the Observable if not empty with a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-------!';\n      const expected = '--a--b--|';\n\n      expectObservable(e1.pipe(defaultIfEmpty('x'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow undefined as a default value","suites":["defaultIfEmpty"],"updatePoint":{"line":49,"column":47},"line":49,"code":"  it('should allow undefined as a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------|');\n      const e1subs = '  ^-------!';\n      const expected = '--------(U|)';\n\n      expectObservable(e1.pipe(defaultIfEmpty(undefined))).toBe(expected, { U: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["defaultIfEmpty"],"updatePoint":{"line":60,"column":53},"line":60,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(defaultIfEmpty('x'));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["defaultIfEmpty"],"updatePoint":{"line":74,"column":73},"line":74,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        defaultIfEmpty('x'),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if the Observable errors","suites":["defaultIfEmpty"],"updatePoint":{"line":92,"column":43},"line":92,"code":"  it('should error if the Observable errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(defaultIfEmpty('x'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["defaultIfEmpty"],"updatePoint":{"line":103,"column":73},"line":103,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(defaultIfEmpty(0), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/defaultIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by specified timeframe","suites":["delay"],"updatePoint":{"line":17,"column":41},"line":17,"code":"  it('should delay by specified timeframe', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--|');\n      const e1subs = '  ^--------!';\n      const t = time('     --|    ');\n      //                      --|\n      const expected = '-----a--b|';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not delay at all if the delay number is negative","suites":["delay"],"updatePoint":{"line":32,"column":61},"line":32,"code":"  it('should not delay at all if the delay number is negative', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--|');\n      const e1subs = '  ^--------!';\n      const t = -1;\n      const expected = '---a--b--|';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by absolute time period","suites":["delay"],"updatePoint":{"line":46,"column":42},"line":46,"code":"  it('should delay by absolute time period', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a---a----a----a------------b---b---b---b--|');\n      const e1subs = '  ^----------------------------------------------!';\n      const t = time('  --------------------|                           ');\n      const expected = '--------------------(aaaaa)-----b---b---b---b--|';\n\n      const absoluteDelay = new Date(testScheduler.now() + t);\n      const result = e1.pipe(delay(absoluteDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not delay at all if the absolute time is in the past","suites":["delay"],"updatePoint":{"line":61,"column":65},"line":61,"code":"  it('should not delay at all if the absolute time is in the past', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a---a----a----a------------b---b---b---b--|');\n      const e1subs = '  ^----------------------------------------------!';\n      const t = -10000;\n      const expected = '--a--a---a----a----a------------b---b---b---b--|';\n\n      const absoluteDelay = new Date(testScheduler.now() + t);\n      const result = e1.pipe(delay(absoluteDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by absolute time period after source ends","suites":["delay"],"updatePoint":{"line":76,"column":60},"line":76,"code":"  it('should delay by absolute time period after source ends', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a-----a---a-----a---|             ');\n      const e1subs = '   ^----------------------!             ';\n      const t = time('   ------------------------------|      ');\n      const expected = ' ------------------------------(aaaa|)';\n\n      const absoluteDelay = new Date(testScheduler.now() + t);\n      const result = e1.pipe(delay(absoluteDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error","suites":["delay"],"updatePoint":{"line":91,"column":49},"line":91,"code":"  it('should raise error when source raises error', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---#');\n      const e1subs = '  ^----------!';\n      const t = time('     ---|     ');\n      //                       ---|\n      const expected = '------a---b#';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error before absolute delay fires","suites":["delay"],"updatePoint":{"line":106,"column":77},"line":106,"code":"  it('should raise error when source raises error before absolute delay fires', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a---a-----#     ');\n      const e1subs = '  ^--------------!     ';\n      const t = time('  --------------------|');\n      const expected = '---------------#     ';\n\n      const absoluteDelay = new Date(testScheduler.now() + t);\n      const result = e1.pipe(delay(absoluteDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error after absolute delay fires","suites":["delay"],"updatePoint":{"line":121,"column":76},"line":121,"code":"  it('should raise error when source raises error after absolute delay fires', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^---a--a---a---a--------b---b---b--#');\n      const e1subs = '   ^----------------------------------!';\n      const t = time('   -----------------|                  ');\n      const expected = ' -----------------(aaaa)-b---b---b--#';\n\n      const absoluteDelay = new Date(testScheduler.now() + t);\n      const result = e1.pipe(delay(absoluteDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay when source does not emit","suites":["delay"],"updatePoint":{"line":136,"column":44},"line":136,"code":"  it('should delay when source does not emit', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----|');\n      const e1subs = '  ^---!';\n      const t = time('  ---| ');\n      const expected = '----|';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not delay when source is empty","suites":["delay"],"updatePoint":{"line":150,"column":43},"line":150,"code":"  it('should not delay when source is empty', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const t = time('  ---|');\n      const expected = '|   ';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay complete when a value is scheduled","suites":["delay"],"updatePoint":{"line":164,"column":53},"line":164,"code":"  it('should delay complete when a value is scheduled', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -a-|    ');\n      const e1subs = '  ^--!    ';\n      const t = time('   ---|   ');\n      const expected = '----(a|)';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source does not complete","suites":["delay"],"updatePoint":{"line":178,"column":55},"line":178,"code":"  it('should not complete when source does not complete', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---------');\n      const e1subs = '  ^---------------!';\n      const t = time('     ---|          ');\n      //                       ---|\n      const expected = '------a---b------';\n      const unsub = '   ----------------!';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["delay"],"updatePoint":{"line":194,"column":83},"line":194,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b----');\n      const e1subs = '  ^-------!   ';\n      const t = time('     ---|     ');\n      //                       ---|\n      const expected = '------a--   ';\n      const unsub = '   --------!   ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        delay(t),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source never completes","suites":["delay"],"updatePoint":{"line":214,"column":53},"line":214,"code":"  it('should not complete when source never completes', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -   ');\n      const e1subs = '  ^   ';\n      const t = time('  ---|');\n      const expected = '-   ';\n\n      const result = e1.pipe(delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe scheduled actions after execution","suites":["delay"],"updatePoint":{"line":228,"column":58},"line":228,"code":"  it('should unsubscribe scheduled actions after execution', () => {\n    testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      let subscribeSpy: any = null;\n      const counts: number[] = [];\n\n      const e1 = cold(' a|      ');\n      const t = time('  -|      ');\n      const expected = '--a-(a|)';\n\n      const result = e1.pipe(\n        repeatWhen((notifications) => {\n          const delayed = notifications.pipe(delay(t));\n          subscribeSpy = sinon.spy((delayed as any)['source'], 'subscribe');\n          return delayed;\n        }),\n        skip(1),\n        take(2),\n        tap({\n          next() {\n            const [[subscriber]] = subscribeSpy.args;\n            counts.push(subscriber._finalizers.length);\n          },\n          complete() {\n            expect(counts).to.deep.equal([1, 1]);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should be possible to delay complete by composition","suites":["delay"],"updatePoint":{"line":260,"column":57},"line":260,"code":"  it('should be possible to delay complete by composition', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b---|  ');\n      const e1subs = '  ^---------!  ';\n      const t = time('     --|       ');\n      //                      --|\n      //                          --|\n      const expected = '-----a--b---|';\n\n      const result = concat(e1.pipe(delay(t)), of(undefined).pipe(delay(t), ignoreElements()));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delay-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by duration selector","suites":["delayWhen"],"updatePoint":{"line":16,"column":39},"line":16,"code":"  it('should delay by duration selector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---b---c--|      ');\n      const expected = '-----a------c----(b|)';\n      const subs = '    ^-------------!      ';\n      const selector = [\n        cold('             --x--|            '),\n        cold('                 ----------(x|)'),\n        cold('                     -x--|     '),\n      ];\n      const selectorSubs = [\n        '               ---^-!               ',\n        '               -------^---------!   ',\n        '               -----------^!        ',\n      ];\n\n      let idx = 0;\n      function durationSelector(x: any) {\n        return selector[idx++];\n      }\n\n      const result = e1.pipe(delayWhen(durationSelector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector[0].subscriptions).toBe(selectorSubs[0]);\n      expectSubscriptions(selector[1].subscriptions).toBe(selectorSubs[1]);\n      expectSubscriptions(selector[2].subscriptions).toBe(selectorSubs[2]);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by selector","suites":["delayWhen"],"updatePoint":{"line":47,"column":30},"line":47,"code":"  it('should delay by selector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--| ');\n      const expected = '   ---a--b-| ';\n      const subs = '       ^-------! ';\n      const selector = cold('-x--|   ');\n      //                        -x--|\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^!      ',\n        '                  -----^!   ',\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["delayWhen"],"updatePoint":{"line":68,"column":47},"line":68,"code":"  it('should raise error if source raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('      --a--# ');\n      const expected = '    ---a-# ';\n      const subs = '        ^----! ';\n      const selector = cold(' -x--|');\n      const selectorSubs = '--^!   ';\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if selector raises error","suites":["delayWhen"],"updatePoint":{"line":84,"column":49},"line":84,"code":"  it('should raise error if selector raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('      --a--b--|');\n      const expected = '    ---#     ';\n      const subs = '        ^--!     ';\n      const selector = cold(' -#     ');\n      const selectorSubs = '--^!     ';\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by selector and completes after value emits","suites":["delayWhen"],"updatePoint":{"line":100,"column":62},"line":100,"code":"  it('should delay by selector and completes after value emits', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--|       ');\n      const expected = '   ---------a--(b|)';\n      const subs = '       ^-------!       ';\n      const selector = cold('-------x--|   ');\n      //                        -------x--|\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^------!      ',\n        '                  -----^------!   '\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay, but not emit if the selector never emits a notification","suites":["delayWhen"],"updatePoint":{"line":121,"column":75},"line":121,"code":"  it('should delay, but not emit if the selector never emits a notification', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--|   ');\n      const expected = '   -----------|';\n      const subs = '       ^-------!   ';\n      const selector = cold('------|   ');\n      //                        ------|\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^-----!   ',\n        '                  -----^-----!'\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit for async source and sync empty selector","suites":["delayWhen"],"updatePoint":{"line":142,"column":62},"line":142,"code":"  it('should not emit for async source and sync empty selector', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  a--|');\n      const expected = '---|';\n      const subs = '    ^--!';\n\n      const result = e1.pipe(delayWhen((x: any) => EMPTY));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit if selector never emits","suites":["delayWhen"],"updatePoint":{"line":155,"column":45},"line":155,"code":"  it('should not emit if selector never emits', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--|');\n      const expected = '   -        ';\n      const subs = '       ^-------!';\n      const selector = cold('-      ');\n      //                        -\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^      ',\n        '                  -----^   ',\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by first value from selector","suites":["delayWhen"],"updatePoint":{"line":176,"column":47},"line":176,"code":"  it('should delay by first value from selector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--|       ');\n      const expected = '   ------a--(b|)   ';\n      const subs = '       ^-------!       ';\n      const selector = cold('----x--y--|   ');\n      //                        ----x--y--|\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^---!         ',\n        '                  -----^---!      ',\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay by selector that does not completes","suites":["delayWhen"],"updatePoint":{"line":197,"column":54},"line":197,"code":"  it('should delay by selector that does not completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('     --a--b--|          ');\n      const expected = '   ------a--(b|)      ';\n      const subs = '       ^-------!          ';\n      const selector = cold('----x-----y---   ');\n      //                        ----x-----y---\n      // prettier-ignore\n      const selectorSubs = [\n        '                  --^---!            ',\n        '                  -----^---!         '\n      ];\n\n      const result = e1.pipe(delayWhen((x: any) => selector));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if selector throws","suites":["delayWhen"],"updatePoint":{"line":218,"column":43},"line":218,"code":"  it('should raise error if selector throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-!      ';\n      const expected = '--#      ';\n\n      const err = new Error('error');\n      const result = e1.pipe(\n        delayWhen(<any>((x: any) => {\n          throw err;\n        }))\n      );\n\n      expectObservable(result).toBe(expected, null, err);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should start subscription when subscription delay emits","suites":["delayWhen"],"updatePoint":{"line":236,"column":61},"line":236,"code":"  it('should start subscription when subscription delay emits', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       -----a---b---| ');\n      const expected = '     -------a---b-| ';\n      const subs = '         ---^---------! ';\n      const selector = cold('     --x--|    ');\n      //                              --x--|\n      // prettier-ignore\n      const selectorSubs = [\n        '                      -----^-!     ',\n        '                      ---------^-! '\n      ];\n      const subDelay = cold('---x--|        ');\n      const subDelaySub = '  ^--!           ';\n\n      const result = e1.pipe(delayWhen((x: any) => selector, subDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n      expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should start subscription when subscription delay completes without emit value","suites":["delayWhen"],"updatePoint":{"line":260,"column":84},"line":260,"code":"  it('should start subscription when subscription delay completes without emit value', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       -----a---b---| ');\n      const expected = '     -------a---b-| ';\n      const subs = '         ---^---------! ';\n      const selector = cold('     --x--|    ');\n      //                              --x--|\n      // prettier-ignore\n      const selectorSubs = [\n        '                    -----^-!       ',\n        '                    ---------^-!   '\n      ];\n      const subDelay = cold('---|           ');\n      const subDelaySub = '  ^--!           ';\n\n      const result = e1.pipe(delayWhen((x: any) => selector, subDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(selector.subscriptions).toBe(selectorSubs);\n      expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when subscription delay raises error","suites":["delayWhen"],"updatePoint":{"line":284,"column":61},"line":284,"code":"  it('should raise error when subscription delay raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       -----a---b---|');\n      const expected = '     ---#          ';\n      const selector = cold('     --x--|   ');\n      const subDelay = cold('---#          ');\n      const subDelaySub = '  ^--!          ';\n\n      const result = e1.pipe(delayWhen((x: any) => selector, subDelay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe([]);\n      expectSubscriptions(selector.subscriptions).toBe([]);\n      expectSubscriptions(subDelay.subscriptions).toBe(subDelaySub);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when duration selector returns synchronous observable","suites":["delayWhen"],"updatePoint":{"line":301,"column":75},"line":301,"code":"  it('should complete when duration selector returns synchronous observable', () => {\n    let next: boolean = false;\n    let complete: boolean = false;\n\n    of(1)\n      .pipe(delayWhen(() => of(2)))\n      .subscribe({ next: () => (next = true), complete: () => (complete = true) });\n\n    expect(next).to.be.true;\n    expect(complete).to.be.true;\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should call predicate with indices starting at 0","suites":["delayWhen"],"updatePoint":{"line":313,"column":54},"line":313,"code":"  it('should call predicate with indices starting at 0', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('       --a--b--c--|');\n      const e1subs = '       ^----------!';\n      const expected = '     --a--b--c--|';\n      const selector = cold('  (x|)');\n      //                          (x|)\n      //                             (x|)\n\n      let indices: number[] = [];\n      const predicate = (value: string, index: number) => {\n        indices.push(index);\n        return selector;\n      };\n\n      const result = e1.pipe(delayWhen(predicate));\n\n      expectObservable(\n        result.pipe(\n          tap({\n            complete: () => {\n              expect(indices).to.deep.equal([0, 1, 2]);\n            },\n          })\n        )\n      ).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/delayWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize an Observable","suites":["dematerialize"],"updatePoint":{"line":16,"column":40},"line":16,"code":"  it('should dematerialize an Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '{x}',\n        b: '{y}',\n        c: '{z}',\n        d: '|',\n      };\n\n      const e1 = hot('  --a--b--c--d-|', values);\n      const e1subs = '  ^----------!  ';\n      const expected = '--x--y--z--|  ';\n\n      const result = e1.pipe(\n        map((x: string) => {\n          if (x === '|') {\n            return Notification.createComplete();\n          } else {\n            return Notification.createNext(x.replace('{', '').replace('}', ''));\n          }\n        }),\n        dematerialize()\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize a happy stream","suites":["dematerialize"],"updatePoint":{"line":45,"column":41},"line":45,"code":"  it('should dematerialize a happy stream', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: Notification.createNext('w'),\n        b: Notification.createNext('x'),\n        c: Notification.createNext('y'),\n        d: Notification.createComplete(),\n      };\n\n      const e1 = hot('  --a--b--c--d--|', values);\n      const e1subs = '  ^----------!   ';\n      const expected = '--w--x--y--|   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize a sad stream","suites":["dematerialize"],"updatePoint":{"line":63,"column":39},"line":63,"code":"  it('should dematerialize a sad stream', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: Notification.createNext('w'),\n        b: Notification.createNext('x'),\n        c: Notification.createNext('y'),\n        d: Notification.createError('error'),\n      };\n\n      const e1 = hot('  --a--b--c--d--|', values);\n      const e1subs = '  ^----------!   ';\n      const expected = '--w--x--y--#   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize stream does not completes","suites":["dematerialize"],"updatePoint":{"line":81,"column":52},"line":81,"code":"  it('should dematerialize stream does not completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot<ObservableNotification<any>>('------');\n      const e1subs = '                             ^';\n      const expected = '                           -';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize stream never completes","suites":["dematerialize"],"updatePoint":{"line":92,"column":49},"line":92,"code":"  it('should dematerialize stream never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold<ObservableNotification<any>>('-');\n      const e1subs = '                              ^';\n      const expected = '                            -';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize stream does not emit","suites":["dematerialize"],"updatePoint":{"line":103,"column":47},"line":103,"code":"  it('should dematerialize stream does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot<ObservableNotification<any>>('----|');\n      const e1subs = '                             ^---!';\n      const expected = '                           ----|';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize empty stream","suites":["dematerialize"],"updatePoint":{"line":114,"column":39},"line":114,"code":"  it('should dematerialize empty stream', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold<ObservableNotification<any>>('|   ');\n      const e1subs = '                              (^!)';\n      const expected = '                            |   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize stream throws","suites":["dematerialize"],"updatePoint":{"line":125,"column":40},"line":125,"code":"  it('should dematerialize stream throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const error = 'error';\n      const e1 = hot('  (x|)', { x: Notification.createError(error) });\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected, null, error);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["dematerialize"],"updatePoint":{"line":137,"column":53},"line":137,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: Notification.createNext('w'),\n        b: Notification.createNext('x'),\n      };\n\n      const e1 = hot('  --a--b--c--d--|', values);\n      const e1subs = '  ^------!       ';\n      const expected = '--w--x--       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(dematerialize());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["dematerialize"],"updatePoint":{"line":156,"column":73},"line":156,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: Notification.createNext('w'),\n        b: Notification.createNext('x'),\n      };\n\n      const e1 = hot('  --a--b--c--d--|', values);\n      const e1subs = '  ^------!       ';\n      const expected = '--w--x--       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        dematerialize(),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize and completes when stream completes with complete notification","suites":["dematerialize"],"updatePoint":{"line":179,"column":89},"line":179,"code":"  it('should dematerialize and completes when stream completes with complete notification', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----(a|)', { a: Notification.createComplete() });\n      const e1subs = '  ^---!   ';\n      const expected = '----|   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize and completes when stream emits complete notification","suites":["dematerialize"],"updatePoint":{"line":190,"column":80},"line":190,"code":"  it('should dematerialize and completes when stream emits complete notification', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--|', { a: Notification.createComplete() });\n      const e1subs = '  ^---!   ';\n      const expected = '----|   ';\n\n      expectObservable(e1.pipe(dematerialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with materialize","suites":["dematerialize"],"updatePoint":{"line":201,"column":34},"line":201,"code":"  it('should work with materialize', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--b---c---d---e----f--|');\n      const e1subs = '  ^--------------------------!';\n      const expected = '----a--b---c---d---e----f--|';\n\n      const result = e1.pipe(materialize(), dematerialize());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["dematerialize"],"updatePoint":{"line":214,"column":73},"line":214,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(materialize(), dematerialize(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/dematerialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values","suites":["distinct"],"updatePoint":{"line":16,"column":39},"line":16,"code":"  it('should distinguish between values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--b--b--a--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--------b--------|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values and does not complete","suites":["distinct"],"updatePoint":{"line":27,"column":61},"line":27,"code":"  it('should distinguish between values and does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--b--b--a-');\n      const e1subs = '  ^------------------';\n      const expected = '--a--------b-------';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never completes","suites":["distinct"],"updatePoint":{"line":38,"column":51},"line":38,"code":"  it('should not complete if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source does not complete","suites":["distinct"],"updatePoint":{"line":49,"column":53},"line":49,"code":"  it('should not complete if source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source is empty","suites":["distinct"],"updatePoint":{"line":60,"column":40},"line":60,"code":"  it('should complete if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source does not emit","suites":["distinct"],"updatePoint":{"line":71,"column":45},"line":71,"code":"  it('should complete if source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ------|');\n      const e1subs = '  ^-----!';\n      const expected = '------|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source emits single element only","suites":["distinct"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it('should emit if source emits single element only', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = '--a--|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source is scalar","suites":["distinct"],"updatePoint":{"line":93,"column":37},"line":93,"code":"  it('should emit if source is scalar', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of('a');\n      const expected = '(a|)';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error if source raises error","suites":["distinct"],"updatePoint":{"line":102,"column":48},"line":102,"code":"  it('should raises error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--#');\n      const e1subs = '  ^-------!';\n      const expected = '--a-----#';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error if source throws","suites":["distinct"],"updatePoint":{"line":113,"column":42},"line":113,"code":"  it('should raises error if source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should not omit if source elements are all different","suites":["distinct"],"updatePoint":{"line":124,"column":58},"line":124,"code":"  it('should not omit if source elements are all different', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--b--c--d--e--f--|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["distinct"],"updatePoint":{"line":135,"column":53},"line":135,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--b--d--a--f--|');\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(distinct());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["distinct"],"updatePoint":{"line":149,"column":73},"line":149,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--b--d--a--f--|');\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        distinct(),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit once if source elements are all same","suites":["distinct"],"updatePoint":{"line":167,"column":54},"line":167,"code":"  it('should emit once if source elements are all same', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--a--a--a--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----------------|';\n\n      expectObservable(e1.pipe(distinct())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish values by key","suites":["distinct"],"updatePoint":{"line":178,"column":38},"line":178,"code":"  it('should distinguish values by key', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 };\n      const e1 = hot('  --a--b--c--d--e--f--|', values);\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--b--c-----------|';\n      const selector = (value: number) => value % 3;\n\n      expectObservable(e1.pipe(distinct(selector))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error when selector throws","suites":["distinct"],"updatePoint":{"line":191,"column":46},"line":191,"code":"  it('should raises error when selector throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^----------!         ';\n      const expected = '--a--b--c--#         ';\n      const selector = (value: string) => {\n        if (value === 'd') {\n          throw new Error('d is for dumb');\n        }\n        return value;\n      };\n\n      expectObservable(e1.pipe(distinct(selector))).toBe(expected, undefined, new Error('d is for dumb'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a flushing stream","suites":["distinct"],"updatePoint":{"line":208,"column":38},"line":208,"code":"  it('should support a flushing stream', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--a--b--|');\n      const e1subs = '  ^-------------------!';\n      const e2 = hot('  -----------x--------|');\n      const e2subs = '  ^-------------------!';\n      const expected = '--a--b--------a--b--|';\n\n      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if flush raises error","suites":["distinct"],"updatePoint":{"line":222,"column":46},"line":222,"code":"  it('should raise error if flush raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--a--b--|');\n      const e1subs = '  ^------------!       ';\n      const e2 = hot('  -----------x-#       ');\n      const e2subs = '  ^------------!       ';\n      const expected = '--a--b-------#       ';\n\n      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from the flushing stream when the main stream is unsubbed","suites":["distinct"],"updatePoint":{"line":236,"column":82},"line":236,"code":"  it('should unsubscribe from the flushing stream when the main stream is unsubbed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--a--b--|');\n      const e1subs = '  ^----------!         ';\n      const e2 = hot('  -----------x--------|');\n      const e2subs = '  ^----------!         ';\n      const unsub = '   -----------!         ';\n      const expected = '--a--b------         ';\n\n      expectObservable(e1.pipe(distinct(undefined, e2)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow opting in to default comparator with flush","suites":["distinct"],"updatePoint":{"line":251,"column":61},"line":251,"code":"  it('should allow opting in to default comparator with flush', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--a--b--|');\n      const e1subs = '  ^-------------------!';\n      const e2 = hot('  -----------x--------|');\n      const e2subs = '  ^-------------------!';\n      const expected = '--a--b--------a--b--|';\n\n      expectObservable(e1.pipe(distinct(undefined, e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["distinct"],"updatePoint":{"line":265,"column":73},"line":265,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(distinct(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/distinct-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values","suites":["distinctUntilChanged"],"updatePoint":{"line":16,"column":39},"line":16,"code":"  it('should distinguish between values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -1--2-2----1-3-|');\n      const e1subs = '  ^--------------!';\n      const expected = '-1--2------1-3-|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values","suites":["distinctUntilChanged"],"updatePoint":{"line":27,"column":39},"line":27,"code":"  it('should distinguish between values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--b--b--a--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--------b-----a--|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values and does not complete","suites":["distinctUntilChanged"],"updatePoint":{"line":38,"column":61},"line":38,"code":"  it('should distinguish between values and does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--b--b--a-');\n      const e1subs = '  ^------------------';\n      const expected = '--a--------b-----a-';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never completes","suites":["distinctUntilChanged"],"updatePoint":{"line":49,"column":51},"line":49,"code":"  it('should not complete if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source does not complete","suites":["distinctUntilChanged"],"updatePoint":{"line":60,"column":53},"line":60,"code":"  it('should not complete if source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source is empty","suites":["distinctUntilChanged"],"updatePoint":{"line":71,"column":40},"line":71,"code":"  it('should complete if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source does not emit","suites":["distinctUntilChanged"],"updatePoint":{"line":82,"column":45},"line":82,"code":"  it('should complete if source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ------|');\n      const e1subs = '  ^-----!';\n      const expected = '------|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source emits single element only","suites":["distinctUntilChanged"],"updatePoint":{"line":93,"column":53},"line":93,"code":"  it('should emit if source emits single element only', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = '--a--|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source is scalar","suites":["distinctUntilChanged"],"updatePoint":{"line":104,"column":37},"line":104,"code":"  it('should emit if source is scalar', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of('a');\n      const expected = '(a|)';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["distinctUntilChanged"],"updatePoint":{"line":113,"column":47},"line":113,"code":"  it('should raise error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--#');\n      const e1subs = '  ^-------!';\n      const expected = '--a-----#';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws","suites":["distinctUntilChanged"],"updatePoint":{"line":124,"column":41},"line":124,"code":"  it('should raise error if source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not omit if source elements are all different","suites":["distinctUntilChanged"],"updatePoint":{"line":135,"column":58},"line":135,"code":"  it('should not omit if source elements are all different', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--b--c--d--e--f--|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["distinctUntilChanged"],"updatePoint":{"line":146,"column":53},"line":146,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--b--d--a--f--|');\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(distinctUntilChanged());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["distinctUntilChanged"],"updatePoint":{"line":160,"column":73},"line":160,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--b--d--a--f--|');\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        distinctUntilChanged(),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit once if source elements are all same","suites":["distinctUntilChanged"],"updatePoint":{"line":178,"column":54},"line":178,"code":"  it('should emit once if source elements are all same', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--a--a--a--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----------------|';\n\n      expectObservable(e1.pipe(distinctUntilChanged())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit once if comparator returns true always regardless of source emits","suites":["distinctUntilChanged"],"updatePoint":{"line":189,"column":83},"line":189,"code":"  it('should emit once if comparator returns true always regardless of source emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----------------|';\n      const comparator = () => true;\n\n      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit all if comparator returns false always regardless of source emits","suites":["distinctUntilChanged"],"updatePoint":{"line":201,"column":83},"line":201,"code":"  it('should emit all if comparator returns false always regardless of source emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--a--a--a--a--a--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--a--a--a--a--a--|';\n      const comparator = () => false;\n\n      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish values by comparator","suites":["distinctUntilChanged"],"updatePoint":{"line":213,"column":45},"line":213,"code":"  it('should distinguish values by comparator', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|', { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 });\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----c-----e-----|';\n      const comparator = (x: number, y: number) => y % 2 === 0;\n\n      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected, { a: 1, c: 3, e: 5 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when comparator throws","suites":["distinctUntilChanged"],"updatePoint":{"line":225,"column":47},"line":225,"code":"  it('should raise error when comparator throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^----------!         ';\n      const expected = '--a--b--c--#         ';\n      const comparator = (x: string, y: string) => {\n        if (y === 'd') {\n          throw 'error';\n        }\n        return x === y;\n      };\n\n      expectObservable(e1.pipe(distinctUntilChanged(comparator))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the keySelector to pick comparator values","suites":["distinctUntilChanged"],"updatePoint":{"line":242,"column":58},"line":242,"code":"  it('should use the keySelector to pick comparator values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|', { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 });\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--b-----d-----f--|';\n      const comparator = (x: number, y: number) => y % 2 === 1;\n      const keySelector = (x: number) => x % 2;\n\n      expectObservable(e1.pipe(distinctUntilChanged(comparator, keySelector))).toBe(expected, { a: 1, b: 2, d: 4, f: 6 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the keySelector even for the first emit","suites":["distinctUntilChanged"],"updatePoint":{"line":255,"column":56},"line":255,"code":"  it('should use the keySelector even for the first emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|', { a: 2, b: 4 });\n      const e1subs = '  ^-------!';\n      const expected = '--a-----|';\n      const keySelector = (x: number) => x % 2;\n\n      expectObservable(e1.pipe(distinctUntilChanged(null!, keySelector))).toBe(expected, { a: 2 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when keySelector throws","suites":["distinctUntilChanged"],"updatePoint":{"line":267,"column":48},"line":267,"code":"  it('should raise error when keySelector throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^----------!         ';\n      const expected = '--a--b--c--#         ';\n      const keySelector = (x: string) => {\n        if (x === 'd') {\n          throw 'error';\n        }\n        return x;\n      };\n\n      expectObservable(e1.pipe(distinctUntilChanged(null as any, keySelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["distinctUntilChanged"],"updatePoint":{"line":284,"column":73},"line":284,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(distinctUntilChanged(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should work properly with reentrant streams","suites":["distinctUntilChanged"],"updatePoint":{"line":306,"column":49},"line":306,"code":"  it('should work properly with reentrant streams', () => {\n    const subject = new Subject<number | undefined>();\n    const results: any[] = [];\n    let count = 0;\n\n    subject.pipe(distinctUntilChanged()).subscribe((n) => {\n      results.push(n);\n\n      // Protect against an infinite loop in this test.\n      // That shouldn't happen.\n      if (++count > 2) {\n        throw new Error('this should have only been hit once');\n      }\n\n      // If we reenter with the same value, it should not\n      // emit again.\n      subject.next(1);\n    });\n\n    // Start with 1.\n    subject.next(1);\n\n    // It should only have emitted one value.\n    expect(results).to.deep.equal([1]);\n  });","file":"operators/distinctUntilChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":16,"column":39},"line":16,"code":"  it('should distinguish between values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { k: 1 }, b: { k: 2 }, c: { k: 3 } };\n      const e1 = hot('  -a--b-b----a-c-|', values);\n      const e1Subs = '  ^--------------!';\n      const expected = '-a--b------a-c-|';\n\n      const result = e1.pipe(distinctUntilKeyChanged('k'));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1Subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":30,"column":39},"line":30,"code":"  it('should distinguish between values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 } };\n      const e1 = hot('  --a--a--a--b--b--a--|', values);\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--------b-----a--|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values and does not complete","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":42,"column":61},"line":42,"code":"  it('should distinguish between values and does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 } };\n      const e1 = hot('  --a--a--a--b--b--a-', values);\n      const e1subs = '  ^                  ';\n      const expected = '--a--------b-----a-';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish between values with key","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":54,"column":48},"line":54,"code":"  it('should distinguish between values with key', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { valOther: 1 }, c: { valOther: 3 }, d: { val: 1 }, e: { val: 5 } };\n      const e1 = hot<any>('--a--b--c--d--e--|', values);\n      const e1subs = '     ^----------------!';\n      const expected = '   --a--b-----d--e--|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not compare if source does not have element with key","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":66,"column":65},"line":66,"code":"  it('should not compare if source does not have element with key', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { valOther: 1 }, b: { valOther: 1 }, c: { valOther: 3 }, d: { valOther: 1 }, e: { valOther: 5 } };\n      const e1 = hot<any>('--a--b--c--d--e--|', values);\n      const e1subs = '     ^----------------!';\n      const expected = '   --a--------------|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never completes","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":78,"column":51},"line":78,"code":"  it('should not complete if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold<any>('-');\n      const e1subs = '      ^';\n      const expected = '    -';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source does not complete","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":89,"column":53},"line":89,"code":"  it('should not complete if source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot<any>('-');\n      const e1subs = '     ^';\n      const expected = '   -';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source is empty","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":100,"column":40},"line":100,"code":"  it('should complete if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold<any>('|');\n      const e1subs = '      (^!)';\n      const expected = '    |';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if source does not emit","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":111,"column":45},"line":111,"code":"  it('should complete if source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot<any>('------|');\n      const e1subs = '     ^-----!';\n      const expected = '   ------|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source emits single element only","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":122,"column":53},"line":122,"code":"  it('should emit if source emits single element only', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 } };\n      const e1 = hot('  --a--|', values);\n      const e1subs = '  ^----!';\n      const expected = '--a--|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit if source is scalar","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":134,"column":37},"line":134,"code":"  it('should emit if source is scalar', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const values = { a: { val: 1 } };\n      const e1 = of(values.a);\n      const expected = '(a|)';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":144,"column":47},"line":144,"code":"  it('should raise error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 } };\n      const e1 = hot('  --a--a--#', values);\n      const e1subs = '  ^-------!';\n      const expected = '--a-----#';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":156,"column":41},"line":156,"code":"  it('should raise error if source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold<any>('#   ');\n      const e1subs = '      (^!)';\n      const expected = '    #   ';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not omit if source elements are all different","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":167,"column":58},"line":167,"code":"  it('should not omit if source elements are all different', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------------!';\n      const expected = '--a--b--c--d--e--|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":179,"column":53},"line":179,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--b--d--a--e--|', values);\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(distinctUntilKeyChanged('val'));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":194,"column":73},"line":194,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--b--d--a--e--|', values);\n      const e1subs = '  ^---------!          ';\n      const expected = '--a--b-----          ';\n      const unsub = '   ----------!          ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        distinctUntilKeyChanged('val'),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit once if source elements are all same","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":213,"column":54},"line":213,"code":"  it('should emit once if source elements are all same', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 } };\n      const e1 = hot('  --a--a--a--a--a--a--|', values);\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----------------|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val'))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit once if comparer returns true always regardless of source emits","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":225,"column":81},"line":225,"code":"  it('should emit once if comparer returns true always regardless of source emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------------!';\n      const expected = '--a--------------|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val', () => true))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit all if comparer returns false always regardless of source emits","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":237,"column":81},"line":237,"code":"  it('should emit all if comparer returns false always regardless of source emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 } };\n      const e1 = hot('  --a--a--a--a--a--a--|', values);\n      const e1subs = '  ^-------------------!';\n      const expected = '--a--a--a--a--a--a--|';\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val', () => false))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should distinguish values by selector","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":249,"column":43},"line":249,"code":"  it('should distinguish values by selector', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------------!';\n      const expected = '--a-----c-----e--|';\n      const selector = (x: number, y: number) => y % 2 === 0;\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val', selector))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when comparer throws","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":262,"column":45},"line":262,"code":"  it('should raise error when comparer throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: { val: 1 }, b: { val: 2 }, c: { val: 3 }, d: { val: 4 }, e: { val: 5 } };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------!      ';\n      const expected = '--a--b--c--#      ';\n      const selector = (x: number, y: number) => {\n        if (y === 4) {\n          throw 'error';\n        }\n        return x === y;\n      };\n\n      expectObservable(e1.pipe(distinctUntilKeyChanged('val', selector))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["distinctUntilKeyChanged"],"updatePoint":{"line":280,"column":73},"line":280,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        map((value) => ({ value })),\n        distinctUntilKeyChanged('value'),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/distinctUntilKeyChanged-spec.ts","skipped":false,"dir":"spec"},{"name":"should return next to last element by zero-based index","suites":["elementAt"],"updatePoint":{"line":16,"column":60},"line":16,"code":"  it('should return next to last element by zero-based index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c-d---|');\n      const e1subs = '  ^-------!      ';\n      const expected = '--------(c|)   ';\n\n      expectObservable(e1.pipe(elementAt(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should return first element by zero-based index","suites":["elementAt"],"updatePoint":{"line":27,"column":53},"line":27,"code":"  it('should return first element by zero-based index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-!';\n      const expected = '--(a|)';\n\n      expectObservable(e1.pipe(elementAt(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow undefined as a default value","suites":["elementAt"],"updatePoint":{"line":38,"column":47},"line":38,"code":"  it('should allow undefined as a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--a---a-|   ');\n      const e1subs = '  ^-------------!   ';\n      const expected = '--------------(U|)';\n\n      expectObservable(e1.pipe(elementAt(100, undefined))).toBe(expected, { U: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should return non-first element by zero-based index","suites":["elementAt"],"updatePoint":{"line":49,"column":57},"line":49,"code":"  it('should return non-first element by zero-based index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--|');\n      const e1subs = '  ^----------!         ';\n      const expected = '-----------(d|)      ';\n\n      expectObservable(e1.pipe(elementAt(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should return last element by zero-based index","suites":["elementAt"],"updatePoint":{"line":60,"column":52},"line":60,"code":"  it('should return last element by zero-based index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-------!   ';\n      const expected = '--------(c|)';\n\n      expectObservable(e1.pipe(elementAt(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if e1 is Empty Observable","suites":["elementAt"],"updatePoint":{"line":71,"column":50},"line":71,"code":"  it('should raise error if e1 is Empty Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(elementAt(0))).toBe(expected, undefined, new ArgumentOutOfRangeError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws","suites":["elementAt"],"updatePoint":{"line":82,"column":41},"line":82,"code":"  it('should raise error if source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(elementAt(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never completes","suites":["elementAt"],"updatePoint":{"line":93,"column":51},"line":93,"code":"  it('should not complete if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const expected = '-';\n      const e1subs = '  ^';\n\n      expectObservable(e1.pipe(elementAt(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["elementAt"],"updatePoint":{"line":104,"column":53},"line":104,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(elementAt(2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result Observable is unsubscribed","suites":["elementAt"],"updatePoint":{"line":118,"column":83},"line":118,"code":"  it('should not break unsubscription chains when result Observable is unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        elementAt(2),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if index is smaller than zero","suites":["elementAt"],"updatePoint":{"line":136,"column":48},"line":136,"code":"  it('should throw if index is smaller than zero', () => {\n    expect(() => {\n      range(0, 10).pipe(elementAt(-1));\n    }).to.throw(ArgumentOutOfRangeError);\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if index is out of range but does not have default value","suites":["elementAt"],"updatePoint":{"line":142,"column":81},"line":142,"code":"  it('should raise error if index is out of range but does not have default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = '-----#';\n\n      expectObservable(e1.pipe(elementAt(3))).toBe(expected, null, new ArgumentOutOfRangeError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should return default value if index is out of range","suites":["elementAt"],"updatePoint":{"line":153,"column":58},"line":153,"code":"  it('should return default value if index is out of range', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|   ');\n      const e1subs = '  ^----!   ';\n      const expected = '-----(x|)';\n      const defaultValue = '42';\n\n      expectObservable(e1.pipe(elementAt(3, defaultValue))).toBe(expected, { x: defaultValue });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["elementAt"],"updatePoint":{"line":165,"column":73},"line":165,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits, it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(elementAt(2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/elementAt-spec.ts","skipped":false,"dir":"spec"},{"name":"should append to a cold Observable","suites":["endWith"],"updatePoint":{"line":17,"column":40},"line":17,"code":"  it('should append to a cold Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a--b--c--|   ');\n      const e1subs = '  ^-----------!   ';\n      const expected = '---a--b--c--(s|)';\n\n      expectObservable(e1.pipe(endWith('s'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should append numbers to a cold Observable","suites":["endWith"],"updatePoint":{"line":28,"column":48},"line":28,"code":"  it('should append numbers to a cold Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 2, c: 3, s: 4 };\n      const e1 = cold(' ---a--b--c--|   ', values);\n      const e1subs = '  ^-----------!   ';\n      const expected = '---a--b--c--(s|)';\n\n      expectObservable(e1.pipe(endWith(values.s))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end an observable with given value","suites":["endWith"],"updatePoint":{"line":40,"column":47},"line":40,"code":"  it('should end an observable with given value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|   ');\n      const e1subs = '  ^----!   ';\n      const expected = '--a--(x|)';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not end with given value if source does not complete","suites":["endWith"],"updatePoint":{"line":51,"column":65},"line":51,"code":"  it('should not end with given value if source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-');\n      const e1subs = '  ^     ';\n      const expected = '----a-';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not end with given value if source never emits and does not completes","suites":["endWith"],"updatePoint":{"line":62,"column":82},"line":62,"code":"  it('should not end with given value if source never emits and does not completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end with given value if source does not emit but does complete","suites":["endWith"],"updatePoint":{"line":73,"column":75},"line":73,"code":"  it('should end with given value if source does not emit but does complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---|   ');\n      const e1subs = '  ^--!   ';\n      const expected = '---(x|)';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit given value and complete immediately if source is empty","suites":["endWith"],"updatePoint":{"line":84,"column":73},"line":84,"code":"  it('should emit given value and complete immediately if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end with given value and source both if source emits single value","suites":["endWith"],"updatePoint":{"line":95,"column":78},"line":95,"code":"  it('should end with given value and source both if source emits single value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' (a|) ');\n      const e1subs = '  (^!) ';\n      const expected = '(ax|)';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end with given values when given more than one value","suites":["endWith"],"updatePoint":{"line":106,"column":65},"line":106,"code":"  it('should end with given values when given more than one value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--|    ');\n      const e1subs = '  ^-------!    ';\n      const expected = '-----a--(yz|)';\n\n      expectObservable(e1.pipe(endWith('y', 'z'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error and not end with given value if source raises error","suites":["endWith"],"updatePoint":{"line":117,"column":76},"line":117,"code":"  it('should raise error and not end with given value if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --#');\n      const e1subs = '  ^-!';\n      const expected = '--#';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected, defaultEndValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error immediately and not end with given value if source throws error immediately","suites":["endWith"],"updatePoint":{"line":128,"column":100},"line":128,"code":"  it('should raise error immediately and not end with given value if source throws error immediately', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue))).toBe(expected, defaultEndValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["endWith"],"updatePoint":{"line":139,"column":53},"line":139,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b----c--d--|');\n      const e1subs = '  ^--------!        ';\n      const expected = '---a--b---        ';\n      const unsub = '   ---------!        ';\n\n      const result = e1.pipe(endWith('s'));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["endWith"],"updatePoint":{"line":153,"column":83},"line":153,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b----c--d--|');\n      const e1subs = '  ^--------!        ';\n      const expected = '---a--b---        ';\n      const unsub = '   ---------!        ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        endWith('s'),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end with empty if given value is not specified","suites":["endWith"],"updatePoint":{"line":171,"column":59},"line":171,"code":"  it('should end with empty if given value is not specified', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-|');\n      const e1subs = '  ^--!';\n      const expected = '-a-|';\n\n      expectObservable(e1.pipe(endWith())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler as last argument with single value","suites":["endWith"],"updatePoint":{"line":182,"column":64},"line":182,"code":"  it('should accept scheduler as last argument with single value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|   ');\n      const e1subs = '  ^----!   ';\n      const expected = '--a--(x|)';\n\n      expectObservable(e1.pipe(endWith(defaultEndValue, testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler as last argument with multiple value","suites":["endWith"],"updatePoint":{"line":193,"column":66},"line":193,"code":"  it('should accept scheduler as last argument with multiple value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--|    ');\n      const e1subs = '  ^-------!    ';\n      const expected = '-----a--(yz|)';\n\n      expectObservable(e1.pipe(endWith('y', 'z', testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["endWith"],"updatePoint":{"line":204,"column":73},"line":204,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(endWith(0), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/endWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false if only one of elements does not match with predicate","suites":["every"],"updatePoint":{"line":24,"column":79},"line":24,"code":"  it('should return false if only one of elements does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15, d: 18, e: 20 };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------!      ';\n      const expected = '-----------(x|)   ';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept thisArg with scalar observables","suites":["every"],"updatePoint":{"line":36,"column":51},"line":36,"code":"  it('should accept thisArg with scalar observables', () => {\n    const thisArg = {};\n\n    of(1)\n      .pipe(\n        every(function (this: any, value: number, index: number) {\n          expect(this).to.deep.equal(thisArg);\n          return true;\n        }, thisArg)\n      )\n      .subscribe();\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should increment index on each call to the predicate","suites":["every"],"updatePoint":{"line":49,"column":58},"line":49,"code":"  it('should increment index on each call to the predicate', () => {\n    const indices: number[] = [];\n    of(1, 2, 3, 4)\n      .pipe(\n        every((_, i) => {\n          indices.push(i);\n          return true;\n        })\n      )\n      .subscribe();\n\n    expect(indices).to.deep.equal([0, 1, 2, 3]);\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept thisArg with array observable","suites":["every"],"updatePoint":{"line":63,"column":49},"line":63,"code":"  it('should accept thisArg with array observable', () => {\n    const thisArg = {};\n\n    of(1, 2, 3, 4)\n      .pipe(\n        every(function (this: any, value: number, index: number) {\n          expect(this).to.deep.equal(thisArg);\n          return true;\n        }, thisArg)\n      )\n      .subscribe();\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept thisArg with ordinary observable","suites":["every"],"updatePoint":{"line":76,"column":52},"line":76,"code":"  it('should accept thisArg with ordinary observable', () => {\n    const thisArg = {};\n\n    const source = new Observable((observer: Observer<number>) => {\n      observer.next(1);\n      observer.complete();\n    });\n    source\n      .pipe(\n        every(function (this: any, value: number, index: number) {\n          expect(this).to.deep.equal(thisArg);\n          return true;\n        }, thisArg)\n      )\n      .subscribe();\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if source is empty","suites":["every"],"updatePoint":{"line":93,"column":41},"line":93,"code":"  it('should emit true if source is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|   ');\n      const e1subs = '  ^----!   ';\n      const expected = '-----(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit false if single source element does not match with predicate","suites":["every"],"updatePoint":{"line":104,"column":78},"line":104,"code":"  it('should emit false if single source element does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^-!   ';\n      const expected = '--(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit false if none of elements match with predicate","suites":["every"],"updatePoint":{"line":115,"column":64},"line":115,"code":"  it('should emit false if none of elements match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^-!               ';\n      const expected = '--(x|)            ';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false if only some of elements matches with predicate","suites":["every"],"updatePoint":{"line":126,"column":73},"line":126,"code":"  it('should return false if only some of elements matches with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15 };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^----------!      ';\n      const expected = '-----------(x|)   ';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["every"],"updatePoint":{"line":138,"column":53},"line":138,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15 };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^------!          ';\n      const expected = '--------          ';\n      const unsub = '   -------!          ';\n\n      const result = e1.pipe(every(predicate));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result observable is unsubscribed","suites":["every"],"updatePoint":{"line":153,"column":83},"line":153,"code":"  it('should not break unsubscription chains when result observable is unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15 };\n      const e1 = hot('  --a--b--c--d--e--|', values);\n      const e1subs = '  ^------!          ';\n      const expected = '--------          ';\n      const unsub = '   -------!          ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        every(predicate),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error if predicate eventually throws","suites":["every"],"updatePoint":{"line":172,"column":59},"line":172,"code":"  it('should propagate error if predicate eventually throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^-------!';\n      const expected = '--------#';\n\n      function faultyPredicate(x: string) {\n        if (x === 'c') {\n          throw 'error';\n        } else {\n          return true;\n        }\n      }\n\n      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if single source element matches with predicate","suites":["every"],"updatePoint":{"line":191,"column":70},"line":191,"code":"  it('should emit true if single source element matches with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5 };\n      const e1 = hot('  --a--|   ', values);\n      const e1subs = '  ^----!   ';\n      const expected = '-----(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if scalar source matches with predicate","suites":["every"],"updatePoint":{"line":203,"column":62},"line":203,"code":"  it('should emit true if scalar source matches with predicate', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(5);\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit false if scalar source does not match with predicate","suites":["every"],"updatePoint":{"line":212,"column":70},"line":212,"code":"  it('should emit false if scalar source does not match with predicate', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(3);\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error if predicate throws on scalar source","suites":["every"],"updatePoint":{"line":221,"column":65},"line":221,"code":"  it('should propagate error if predicate throws on scalar source', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(3);\n      const expected = '#';\n\n      function faultyPredicate(x: number): boolean {\n        throw 'error';\n      }\n\n      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if scalar array source matches with predicate","suites":["every"],"updatePoint":{"line":234,"column":68},"line":234,"code":"  it('should emit true if scalar array source matches with predicate', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(5, 10, 15, 20);\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit false if scalar array source does not match with predicate","suites":["every"],"updatePoint":{"line":243,"column":76},"line":243,"code":"  it('should emit false if scalar array source does not match with predicate', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(5, 9, 15, 20);\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error if predicate eventually throws on scalar array source","suites":["every"],"updatePoint":{"line":252,"column":82},"line":252,"code":"  it('should propagate error if predicate eventually throws on scalar array source', () => {\n    testScheduler.run(({ expectObservable }) => {\n      const e1 = of(5, 10, 15, 20);\n      const expected = '#';\n\n      function faultyPredicate(x: number) {\n        if (x === 15) {\n          throw 'error';\n        }\n        return true;\n      }\n\n      expectObservable(e1.pipe(every(faultyPredicate))).toBe(expected);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if all source elements match with predicate","suites":["every"],"updatePoint":{"line":268,"column":66},"line":268,"code":"  it('should emit true if all source elements match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15, d: 20, e: 25 };\n      const e1 = hot('  --a--b--c--d--e--|   ', values);\n      const e1subs = '  ^----------------!   ';\n      const expected = '-----------------(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["every"],"updatePoint":{"line":280,"column":47},"line":280,"code":"  it('should raise error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --#');\n      const e1subs = '  ^-!';\n      const expected = '--#';\n\n      expectObservable(e1.pipe(every(truePredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never emits","suites":["every"],"updatePoint":{"line":291,"column":47},"line":291,"code":"  it('should not complete if source never emits', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(every(truePredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if source element matches with predicate after subscription","suites":["every"],"updatePoint":{"line":302,"column":82},"line":302,"code":"  it('should emit true if source element matches with predicate after subscription', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15, d: 20, e: 25 };\n      const e1 = hot('--z--^--a--b--c--d--e--|   ', values);\n      const e1subs = '     ^-----------------!   ';\n      const expected = '   ------------------(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit false if source element does not match with predicate after subscription","suites":["every"],"updatePoint":{"line":314,"column":90},"line":314,"code":"  it('should emit false if source element does not match with predicate after subscription', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 5, b: 10, c: 15, d: 20 };\n      const e1 = hot('--z--^--b--c--z--d--|', values);\n      const e1subs = '     ^--------!      ';\n      const expected = '   ---------(x|)   ';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error after subscription","suites":["every"],"updatePoint":{"line":326,"column":66},"line":326,"code":"  it('should raise error if source raises error after subscription', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--z--^--#');\n      const e1subs = '     ^--!';\n      const expected = '   ---#';\n\n      expectObservable(e1.pipe(every(truePredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit true if source does not emit after subscription","suites":["every"],"updatePoint":{"line":337,"column":65},"line":337,"code":"  it('should emit true if source does not emit after subscription', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--z--^-----|   ');\n      const e1subs = '     ^-----!   ';\n      const expected = '   ------(x|)';\n\n      expectObservable(e1.pipe(every(predicate))).toBe(expected, { x: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/every-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of hot observables","suites":["exhaust"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should handle a hot observable of hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   -----a---b---c--|                  ');\n      const xsubs = '   ------^---------!                  ';\n      const y = hot('   -------d--e---f---|                ');\n      const ysubs: string[] = [];\n      const z = hot('   --------------g--h---i---|         ');\n      const zsubs = '   --------------------^----!         ';\n      const e1 = hot('  ------x-------y-----z-------------|', { x: x, y: y, z: z });\n      const e1subs = '  ^---------------------------------!';\n      const expected = '---------b---c-------i------------|';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to first immediately-scheduled inner Observable","suites":["exhaust"],"updatePoint":{"line":36,"column":67},"line":36,"code":"  it('should switch to first immediately-scheduled inner Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' (ab|)');\n      const e1subs = '  (^!) ';\n      const e2 = cold(' (cd|)');\n      const e2subs: string[] = [];\n      const expected = '(ab|)';\n\n      expectObservable(of(e1, e2).pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["exhaust"],"updatePoint":{"line":50,"column":25},"line":50,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["exhaust"],"updatePoint":{"line":61,"column":25},"line":61,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["exhaust"],"updatePoint":{"line":72,"column":25},"line":72,"code":"  it('should handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables","suites":["exhaust"],"updatePoint":{"line":83,"column":51},"line":83,"code":"  it('should handle a hot observable of observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|               ');\n      const xsubs = '   ------^------------!               ';\n      const y = cold('                ---d--e---f---|      ');\n      const ysubs: string[] = [];\n      const z = cold('                      ---g--h---i---|');\n      const zsubs = '   --------------------^-------------!';\n      const e1 = hot('  ------x-------y-----z-------------|', { x: x, y: y, z: z });\n      const e1subs = '  ^---------------------------------!';\n      const expected = '--------a---b---c------g--h---i---|';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, outer is unsubscribed early","suites":["exhaust"],"updatePoint":{"line":103,"column":80},"line":103,"code":"  it('should handle a hot observable of observables, outer is unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^---------!            ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs: string[] = [];\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const unsub = '   ----------------!            ';\n      const expected = '--------a---b----            ';\n\n      expectObservable(e1.pipe(exhaustAll()), unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["exhaust"],"updatePoint":{"line":119,"column":83},"line":119,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^---------!            ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs: string[] = [];\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const unsub = '   ----------------!            ';\n      const expected = '--------a---b----            ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        exhaustAll(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, inner never completes","suites":["exhaust"],"updatePoint":{"line":141,"column":74},"line":141,"code":"  it('should handle a hot observable of observables, inner never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a---b--|              ');\n      const xsubs = '   ---^--------!              ';\n      const y = cold('         -d---e-             ');\n      const ysubs: string[] = [];\n      const z = cold('                ---f--g---h--');\n      const zsubs = '   --------------^------------';\n      const e1 = hot('  ---x---y------z----------| ', { x: x, y: y, z: z });\n      const expected = '-----a---b-------f--g---h--';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch and stay on the first inner observable","suites":["exhaust"],"updatePoint":{"line":159,"column":79},"line":159,"code":"  it('should handle a synchronous switch and stay on the first inner observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|   ');\n      const xsubs = '   ------^------------!   ';\n      const y = cold('        ---d--e---f---|  ');\n      const ysubs: string[] = [];\n      const e1 = hot('  ------(xy)------------|', { x: x, y: y });\n      const expected = '--------a---b---c-----|';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, one inner throws","suites":["exhaust"],"updatePoint":{"line":174,"column":69},"line":174,"code":"  it('should handle a hot observable of observables, one inner throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---#                ');\n      const xsubs = '   ------^-----!                ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs: string[] = [];\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const expected = '--------a---#                ';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, outer throws","suites":["exhaust"],"updatePoint":{"line":189,"column":65},"line":189,"code":"  it('should handle a hot observable of observables, outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^------------!         ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs: string[] = [];\n      const e1 = hot('  ------x-------y-------#      ', { x: x, y: y });\n      const expected = '--------a---b---c-----#      ';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty hot observable","suites":["exhaust"],"updatePoint":{"line":204,"column":43},"line":204,"code":"  it('should handle an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ------|');\n      const e1subs = '  ^-----!';\n      const expected = '------|';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never hot observable","suites":["exhaust"],"updatePoint":{"line":215,"column":42},"line":215,"code":"  it('should handle a never hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete not before the outer completes","suites":["exhaust"],"updatePoint":{"line":226,"column":52},"line":226,"code":"  it('should complete not before the outer completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|   ');\n      const xsubs = '   ------^------------!   ';\n      const e1 = hot('  ------x---------------|', { x: x });\n      const expected = '--------a---b---c-----|';\n\n      expectObservable(e1.pipe(exhaustAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n    });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an observable of promises","suites":["exhaust"],"updatePoint":{"line":238,"column":45},"line":238,"code":"  it('should handle an observable of promises', (done) => {\n    const expected = [1];\n\n    of(Promise.resolve(1), Promise.resolve(2), Promise.resolve(3))\n      .pipe(exhaustAll())\n      .subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected.shift());\n        },\n        complete: () => {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an observable of promises, where one rejects","suites":["exhaust"],"updatePoint":{"line":254,"column":64},"line":254,"code":"  it('should handle an observable of promises, where one rejects', (done) => {\n    of(Promise.reject(2), Promise.resolve(1))\n      .pipe(exhaustAll())\n      .subscribe({\n        next: (x) => {\n          done(new Error('should not be called'));\n        },\n        error: (err) => {\n          expect(err).to.equal(2);\n          done();\n        },\n        complete: () => {\n          done(new Error('should not be called'));\n        },\n      });\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["exhaust"],"updatePoint":{"line":271,"column":73},"line":271,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    of(synchronousObservable)\n      .pipe(exhaustAll(), take(3))\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/exhaustAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["exhaustMap"],"updatePoint":{"line":17,"column":55},"line":17,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { x: 10, y: 30, z: 50 };\n      const e1 = hot('   --1-----3--5-------|');\n      const e1subs = '   ^------------------!';\n      const e2 = cold('    x-x-x|            ', values);\n      //                         x-x-x|\n      //                            x-x-x|\n      const expected = ' --x-x-x-y-y-y------|';\n\n      const result = e1.pipe(exhaustMap((x) => e2.pipe(map((i) => i * +x))));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["exhaustMap"],"updatePoint":{"line":34,"column":50},"line":34,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(\n        exhaustMap(\n          (x) => of(x, x + 1, x + 2),\n          (a, b, i, ii) => [a, b, i, ii]\n        )\n      )\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 1, 0, 0],\n            [1, 2, 0, 1],\n            [1, 3, 0, 2],\n            [2, 2, 1, 0],\n            [2, 3, 1, 1],\n            [2, 4, 1, 2],\n            [3, 3, 2, 0],\n            [3, 4, 2, 1],\n            [3, 5, 2, 2],\n          ]);\n        },\n      });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["exhaustMap"],"updatePoint":{"line":67,"column":61},"line":67,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(exhaustMap((x) => of(x, x + 1, x + 2), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5]);\n        },\n      });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer throw","suites":["exhaustMap"],"updatePoint":{"line":85,"column":31},"line":85,"code":"  it('should handle outer throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('  --a--b--c--|');\n      const xsubs: string[] = [];\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(exhaustMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer empty","suites":["exhaustMap"],"updatePoint":{"line":101,"column":31},"line":101,"code":"  it('should handle outer empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('  --a--b--c--|');\n      const xsubs: string[] = [];\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(exhaustMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer never","suites":["exhaustMap"],"updatePoint":{"line":117,"column":31},"line":117,"code":"  it('should handle outer never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('  --a--b--c--|');\n      const xsubs: string[] = [];\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(exhaustMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if project throws","suites":["exhaustMap"],"updatePoint":{"line":133,"column":42},"line":133,"code":"  it('should raise error if project throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---x---------y-----------------z-------------|');\n      const e1subs = '  ^--!';\n      const expected = '---#';\n\n      const result = e1.pipe(\n        exhaustMap(() => {\n          throw 'error';\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch with a selector function","suites":["exhaustMap"],"updatePoint":{"line":150,"column":44},"line":150,"code":"  it('should switch with a selector function', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a--b--c--|                               ');\n      const xsubs = '   ---^----------!                               ';\n      const y = cold('               --d--e--f--|                     ');\n      const ysubs: string[] = [];\n      const z = cold('                                 --g--h--i--|   ');\n      const zsubs = '   -------------------------------^----------!   ';\n      const e1 = hot('  ---x---------y-----------------z-------------|');\n      const e1subs = '  ^--------------------------------------------!';\n      const expected = '-----a--b--c---------------------g--h--i-----|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, outer is unsubscribed early","suites":["exhaustMap"],"updatePoint":{"line":174,"column":71},"line":174,"code":"  it('should switch inner cold observables, outer is unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a--b--c--|                               ');\n      const xsubs = '   ---^----------!                               ';\n      const y = cold('               --d--e--f--|                     ');\n      const ysubs: string[] = [];\n      const z = cold('                                 --g--h--i--|   ');\n      const zsubs = '   -------------------------------^--!           ';\n      const e1 = hot('  ---x---------y-----------------z-------------|');\n      const unsub = '   ----------------------------------!           ';\n      const e1subs = '  ^---------------------------------!           ';\n      const expected = '-----a--b--c---------------------g-           ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["exhaustMap"],"updatePoint":{"line":199,"column":83},"line":199,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a--b--c--|                               ');\n      const xsubs = '   ---^----------!                               ';\n      const y = cold('               --d--e--f--|                     ');\n      const ysubs: string[] = [];\n      const z = cold('                                 --g--h--i--|   ');\n      const zsubs = '   -------------------------------^--!           ';\n      const e1 = hot('  ---x---------y-----------------z-------------|');\n      const e1subs = '  ^---------------------------------!           ';\n      const expected = '-----a--b--c---------------------g-           ';\n      const unsub = '   ----------------------------------!           ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        exhaustMap((value) => observableLookup[value]),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains with interop inners when result is unsubscribed explicitly","suites":["exhaustMap"],"updatePoint":{"line":228,"column":103},"line":228,"code":"  it('should not break unsubscription chains with interop inners when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a--b--c--|                               ');\n      const xsubs = '   ---^----------!                               ';\n      const y = cold('               --d--e--f--|                     ');\n      const ysubs: string[] = [];\n      const z = cold('                                 --g--h--i--|   ');\n      const zsubs = '   -------------------------------^--!           ';\n      const e1 = hot('  ---x---------y-----------------z-------------|');\n      const e1subs = '  ^---------------------------------!           ';\n      const expected = '-----a--b--c---------------------g-           ';\n      const unsub = '   ----------------------------------!           ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      // This test is the same as the previous test, but the observable is\n      // manipulated to make it look like an interop observable - an observable\n      // from a foreign library. Interop subscribers are treated differently:\n      // they are wrapped in a safe subscriber. This test ensures that\n      // unsubscriptions are chained all the way to the interop subscriber.\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        exhaustMap((value) => asInteropObservable(observableLookup[value])),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["exhaustMap"],"updatePoint":{"line":263,"column":73},"line":263,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n\n    of(null)\n      .pipe(\n        exhaustMap(() => synchronousObservable),\n        takeWhile((x) => x != 2) // unsubscribe at the second side-effect\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([1, 2]);\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, inner never completes","suites":["exhaustMap"],"updatePoint":{"line":292,"column":65},"line":292,"code":"  it('should switch inner cold observables, inner never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('     --a--b--c--|                              ');\n      const xsubs = '   ---^----------!                              ';\n      const y = cold('               --d--e--f--|                    ');\n      const ysubs: string[] = [];\n      const z = cold('                                 --g--h--i-----');\n      const zsubs = '   -------------------------------^-------------';\n      const e1 = hot('  ---x---------y-----------------z---------|   ');\n      const e1subs = '  ^----------------------------------------!   ';\n      const expected = '-----a--b--c---------------------g--h--i-----';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch and stay on the first inner observable","suites":["exhaustMap"],"updatePoint":{"line":316,"column":79},"line":316,"code":"  it('should handle a synchronous switch and stay on the first inner observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|   ');\n      const xsubs = '   ---------^----------------!   ';\n      const y = cold('           ---f---g---h---i--|  ');\n      const ysubs: string[] = [];\n      const e1 = hot('  ---------(xy)----------------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------a--b--c--d--e-----|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, one inner throws","suites":["exhaustMap"],"updatePoint":{"line":337,"column":60},"line":337,"code":"  it('should switch inner cold observables, one inner throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--#             ');\n      const xsubs = '   ---------^-------------!             ';\n      const y = cold('                     ---f---g---h---i--');\n      const ysubs: string[] = [];\n      const e1 = hot('  ---------x---------y---------|       ');\n      const e1subs = '  ^----------------------!             ';\n      const expected = '-----------a--b--c--d--#             ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner hot observables","suites":["exhaustMap"],"updatePoint":{"line":358,"column":41},"line":358,"code":"  it('should switch inner hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   -----a--b--c--d--e--|                  ');\n      const xsubs = '   ---------^----------!                  ';\n      const y = hot('   --p-o-o-p-------f---g---h---i--|       ');\n      const ysubs: string[] = [];\n      const z = hot('   ---z-o-o-m-------------j---k---l---m--|');\n      const zsubs = '   --------------------^-----------------!';\n      const e1 = hot('  ---------x----y-----z--------|         ');\n      const e1subs = '  ^----------------------------!         ';\n      const expected = '-----------c--d--e-----j---k---l---m--|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y, z: z };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and empty","suites":["exhaustMap"],"updatePoint":{"line":382,"column":41},"line":382,"code":"  it('should switch inner empty and empty', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     |          ');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and never","suites":["exhaustMap"],"updatePoint":{"line":403,"column":41},"line":403,"code":"  it('should switch inner empty and never', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const xsubs = '   ---------(^!)                 ';\n      const y = cold('                     -          ');\n      const ysubs = '   -------------------^          ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------------------------';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should never switch inner never","suites":["exhaustMap"],"updatePoint":{"line":424,"column":37},"line":424,"code":"  it('should never switch inner never', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -                     ');\n      const xsubs = '   ---------^                     ';\n      const y = cold('                     #           ');\n      const ysubs: string[] = [];\n      const e1 = hot('  ---------x---------y----------|');\n      const e1subs = '  ^-----------------------------!';\n      const expected = '-------------------------------';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and throw","suites":["exhaustMap"],"updatePoint":{"line":445,"column":41},"line":445,"code":"  it('should switch inner empty and throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const xsubs = '   ---------(^!)                 ';\n      const y = cold('                     #          ');\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^------------------!          ';\n      const expected = '-------------------#          ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer error","suites":["exhaustMap"],"updatePoint":{"line":466,"column":31},"line":466,"code":"  it('should handle outer error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|');\n      const xsubs = '   ---------^---------!       ';\n      const e1 = hot('  ---------x---------#       ');\n      const e1subs = '  ^------------------!       ';\n      const expected = '-----------a--b--c-#       ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x };\n\n      const result = e1.pipe(exhaustMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["exhaustMap"],"updatePoint":{"line":484,"column":73},"line":484,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        exhaustMap((value) => of(value)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore subsequent synchronous reentrances during subscribing the inner sub","suites":["exhaustMap"],"updatePoint":{"line":507,"column":87},"line":507,"code":"  it('should ignore subsequent synchronous reentrances during subscribing the inner sub', () => {\n    const e = new BehaviorSubject(1);\n    const results: Array<number> = [];\n\n    e.pipe(\n      take(3),\n      exhaustMap(\n        (value) =>\n          new Observable<number>((subscriber) => {\n            e.next(value + 1);\n            subscriber.next(value);\n          })\n      )\n    ).subscribe((value) => results.push(value));\n\n    expect(results).to.deep.equal([1]);\n  });","file":"operators/exhaustMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should recursively map-and-flatten each item to an Observable","suites":["expand"],"updatePoint":{"line":16,"column":67},"line":16,"code":"  it('should recursively map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --x----|  ', { x: 1 });\n      const e1subs = '  ^------!  ';\n      const e2 = cold('   --c|    ', { c: 2 });\n      //                    --c|\n      //                      --c|\n      const expected = '--a-b-c-d|';\n      const values = { a: 1, b: 2, c: 4, d: 8 };\n\n      const result = e1.pipe(expand((x) => (x === 8 ? EMPTY : e2.pipe(map((c) => c * x)))));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with scheduler","suites":["expand"],"updatePoint":{"line":33,"column":32},"line":33,"code":"  it('should work with scheduler', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --x----|  ', { x: 1 });\n      const e1subs = '  ^------!  ';\n      const e2 = cold('   --c|    ', { c: 2 });\n      //                    --c|\n      //                      --c|\n      const expected = '--a-b-c-d|';\n      const values = { a: 1, b: 2, c: 4, d: 8 };\n\n      const result = e1.pipe(expand((x) => (x === 8 ? EMPTY : e2.pipe(map((c) => c * x))), Infinity, testScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and recursively flatten","suites":["expand"],"updatePoint":{"line":50,"column":40},"line":50,"code":"  it('should map and recursively flatten', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)            ', values);\n      const e1subs = '  (^!)            ';\n      const e2shape = ' ---(z|)         ';\n      const expected = 'a--b--c--d--(e|)';\n      /*\n        expectation explanation: (conjunction junction?) ...\n\n        since `cold('---(z|)')` emits `x + x` and completes on frame 30\n        but the next \"expanded\" return value is synchronously subscribed to in\n        that same frame, it stacks like so:\n\n        a\n        ---(b|)\n           ---(c|)\n              ---(d|)\n                 ---(e|)      (...which flattens into:)\n        a--b--c--d--(e|)\n      */\n\n      const result = e1.pipe(\n        expand(\n          (x, index): Observable<any> => {\n            if (x === 16) {\n              return EMPTY;\n            } else {\n              return cold(e2shape, { z: x + x });\n            }\n          }\n        )\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and recursively flatten, and handle event raised error","suites":["expand"],"updatePoint":{"line":95,"column":71},"line":95,"code":"  it('should map and recursively flatten, and handle event raised error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)         ', values);\n      const e1subs = '  (^!)         ';\n      const e2shape = ' ---(z|)      ';\n      const expected = 'a--b--c--(d#)';\n\n      const result = e1.pipe(\n        expand((x) => {\n          if (x === 8) {\n            return cold<number>('#');\n          }\n          return cold(e2shape, { z: x + x });\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and recursively flatten, and propagate error thrown from projection","suites":["expand"],"updatePoint":{"line":123,"column":84},"line":123,"code":"  it('should map and recursively flatten, and propagate error thrown from projection', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)         ', values);\n      const e1subs = '  (^!)         ';\n      const e2shape = ' ---(z|)      ';\n      const expected = 'a--b--c--(d#)';\n\n      const result = e1.pipe(\n        expand((x) => {\n          if (x === 8) {\n            throw 'error';\n          }\n          return cold(e2shape, { z: x + x });\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early","suites":["expand"],"updatePoint":{"line":151,"column":38},"line":151,"code":"  it('should allow unsubscribing early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)    ', values);\n      const unsub = '   -------!';\n      const e1subs = '  (^!)    ';\n      const e2shape = ' ---(z|) ';\n      const expected = 'a--b--c-';\n\n      const result = e1.pipe(\n        expand(\n          (x): Observable<any> => {\n            if (x === 16) {\n              return EMPTY;\n            }\n            return cold(e2shape, { z: x + x });\n          }\n        )\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["expand"],"updatePoint":{"line":182,"column":83},"line":182,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)    ', values);\n      const e1subs = '  (^!)    ';\n      const e2shape = ' ---(z|) ';\n      const expected = 'a--b--c-';\n      const unsub = '   -------!';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        expand(\n          (x): Observable<any> => {\n            if (x === 16) {\n              return EMPTY;\n            }\n            return cold(e2shape, { z: x + x });\n          }\n        ),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow concurrent expansions","suites":["expand"],"updatePoint":{"line":215,"column":40},"line":215,"code":"  it('should allow concurrent expansions', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  a-a|              ', values);\n      const e1subs = '  ^--!              ';\n      const e2shape = ' ---(z|)           ';\n      const expected = 'a-ab-bc-cd-de-(e|)';\n\n      const result = e1.pipe(\n        expand(\n          (x): Observable<any> => {\n            if (x === 16) {\n              return EMPTY;\n            }\n            return cold(e2shape, { z: x + x });\n          }\n        )\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow configuring the concurrency limit parameter to 1","suites":["expand"],"updatePoint":{"line":245,"column":67},"line":245,"code":"  it('should allow configuring the concurrency limit parameter to 1', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n        u: 10,\n        v: 20, // u + u\n        x: 40, // v + v\n        y: 80, // x + x\n        z: 160, // y + y\n      };\n      const e1 = hot('  a-u|                         ', values);\n      const e1subs = '  ^--!                         ';\n      const e2shape = ' ---(z|)                      ';\n      //                 ---(z|)\n      //                    ---(z|)\n      //                       ---(z|)\n      //                          ---(z|)\n      //                             ---(z|)\n      //                                ---(z|)\n      //                                   ---(z|)\n      // Notice how for each column, there is at most 1 `-` character.\n      const expected = 'a--u--b--v--c--x--d--y--(ez|)';\n      const concurrencyLimit = 1;\n\n      const result = e1.pipe(\n        expand((x): Observable<any> => {\n          if (x === 16 || x === 160) {\n            return EMPTY;\n          }\n          return cold(e2shape, { z: x + x });\n        }, concurrencyLimit)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow configuring the concurrency limit parameter to 2","suites":["expand"],"updatePoint":{"line":287,"column":67},"line":287,"code":"  it('should allow configuring the concurrency limit parameter to 2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        u: 10,\n        v: 20, // u + u\n        x: 40, // v + v\n      };\n      const e1 = hot('  a---au|                   ', values);\n      const e1subs = '  ^-----!                   ';\n      const e2shape = ' ------(z|)                ';\n      //                  ------(z|)\n      //                    ------(z|)\n      //                        ------(z|)\n      //                          ------(z|)\n      //                              ------(z|)\n      //                                ------(z|)\n      // Notice how for each column, there is at most 2 `-` characters.\n      const expected = 'a---a-u---b-b---v-(cc)(x|)';\n      const concurrencyLimit = 2;\n\n      const result = e1.pipe(\n        expand((x): Observable<any> => {\n          if (x === 4 || x === 40) {\n            return EMPTY;\n          }\n          return cold(e2shape, { z: x + x });\n        }, concurrencyLimit)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore concurrency limit if it is not passed","suites":["expand"],"updatePoint":{"line":324,"column":57},"line":324,"code":"  it('should ignore concurrency limit if it is not passed', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n        u: 10,\n        v: 20, // u + u\n        x: 40, // v + v\n        y: 80, // x + x\n        z: 160, // y + y\n      };\n      const e1 = hot('  a-u|              ', values);\n      const e1subs = '  ^--!              ';\n      const e2shape = ' ---(z|)           ';\n      const expected = 'a-ub-vc-xd-ye-(z|)';\n      const concurrencyLimit = 100;\n\n      const result = e1.pipe(\n        expand((x): Observable<any> => {\n          if (x === 16 || x === 160) {\n            return EMPTY;\n          }\n          return cold(e2shape, { z: x + x });\n        }, concurrencyLimit)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and recursively flatten with scalars","suites":["expand"],"updatePoint":{"line":358,"column":53},"line":358,"code":"  it('should map and recursively flatten with scalars', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)    ', values);\n      const e1subs = '  (^!)    ';\n      const expected = '(abcde|)';\n\n      const result = e1.pipe(\n        expand((x) => {\n          if (x === 16) {\n            return EMPTY;\n          }\n          return of(x + x); // scalar\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should recursively flatten promises","suites":["expand"],"updatePoint":{"line":385,"column":41},"line":385,"code":"  it('should recursively flatten promises', (done) => {\n    const expected = [1, 2, 4, 8, 16];\n    of(1)\n      .pipe(\n        expand((x): any => {\n          if (x === 16) {\n            return EMPTY;\n          }\n          return Promise.resolve(x + x);\n        })\n      )\n      .subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected.shift());\n        },\n        complete: () => {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should recursively flatten Arrays","suites":["expand"],"updatePoint":{"line":407,"column":39},"line":407,"code":"  it('should recursively flatten Arrays', (done) => {\n    const expected = [1, 2, 4, 8, 16];\n    of(1)\n      .pipe(\n        expand((x): any => {\n          if (x === 16) {\n            return EMPTY;\n          }\n          return [x + x];\n        })\n      )\n      .subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected.shift());\n        },\n        complete: () => {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should recursively flatten lowercase-o observables","suites":["expand"],"updatePoint":{"line":429,"column":56},"line":429,"code":"  it('should recursively flatten lowercase-o observables', (done) => {\n    const expected = [1, 2, 4, 8, 16];\n    const project = (x: number): InteropObservable<number> => {\n      if (x === 16) {\n        return EMPTY as any;\n      }\n\n      return {\n        subscribe(observer: Observer<number>) {\n          observer.next(x + x);\n          observer.complete();\n        },\n        [Symbol.observable]() {\n          return this;\n        },\n      } as any;\n    };\n\n    of(1)\n      .pipe(expand(project))\n      .subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected.shift());\n        },\n        complete: () => {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should work when passing undefined for the optional arguments","suites":["expand"],"updatePoint":{"line":460,"column":67},"line":460,"code":"  it('should work when passing undefined for the optional arguments', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: 1,\n        b: 1 + 1, // a + a,\n        c: 2 + 2, // b + b,\n        d: 4 + 4, // c + c,\n        e: 8 + 8, // d + d\n      };\n      const e1 = hot('  (a|)            ', values);\n      const e1subs = '  (^!)            ';\n      const e2shape = ' ---(z|)         ';\n      const expected = 'a--b--c--d--(e|)';\n\n      const project = (x: any, index: number): Observable<any> => {\n        if (x === 16) {\n          return EMPTY;\n        }\n        return cold(e2shape, { z: x + x });\n      };\n\n      const result = e1.pipe(expand(project, undefined, undefined));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with the AsapScheduler","suites":["expand"],"updatePoint":{"line":488,"column":40},"line":488,"code":"  it('should work with the AsapScheduler', (done) => {\n    const expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    of(0)\n      .pipe(\n        expand((x) => of(x + 1), Infinity, asapScheduler),\n        take(10),\n        toArray()\n      )\n      .subscribe({ next: (actual) => expect(actual).to.deep.equal(expected), error: done, complete: done });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with the AsyncScheduler","suites":["expand"],"updatePoint":{"line":499,"column":41},"line":499,"code":"  it('should work with the AsyncScheduler', (done) => {\n    const expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    of(0)\n      .pipe(\n        expand((x) => of(x + 1), Infinity, asyncScheduler),\n        take(10),\n        toArray()\n      )\n      .subscribe({ next: (actual) => expect(actual).to.deep.equal(expected), error: done, complete: done });\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["expand"],"updatePoint":{"line":510,"column":73},"line":510,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        expand(() => EMPTY),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/expand-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter out even values","suites":["filter"],"updatePoint":{"line":33,"column":35},"line":33,"code":"  it('should filter out even values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --0--1--2--3--4--|');\n      const e1subs = '  ^----------------!';\n      const expected = '-----1-----3-----|';\n\n      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers","suites":["filter"],"updatePoint":{"line":44,"column":41},"line":44,"code":"  it('should filter in only prime numbers', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3---5----7-------|';\n\n      expectObservable(e1.pipe(filter(isPrime))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter with an always-true predicate","suites":["filter"],"updatePoint":{"line":55,"column":49},"line":55,"code":"  it('should filter with an always-true predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3-4-5-6--7-8--9--|';\n\n      const predicate = () => {\n        return true;\n      };\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter with an always-false predicate","suites":["filter"],"updatePoint":{"line":70,"column":50},"line":70,"code":"  it('should filter with an always-false predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     -------------------|';\n\n      const predicate = () => {\n        return false;\n      };\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, source unsubscribes early","suites":["filter"],"updatePoint":{"line":85,"column":68},"line":85,"code":"  it('should filter in only prime numbers, source unsubscribes early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^-----------!       ';\n      const expected = '     --3---5----7-       ';\n      const unsub = '        ------------!       ';\n\n      expectObservable(e1.pipe(filter(isPrime)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, source throws","suites":["filter"],"updatePoint":{"line":97,"column":56},"line":97,"code":"  it('should filter in only prime numbers, source throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--#');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3---5----7-------#';\n\n      expectObservable(e1.pipe(filter(isPrime))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, but predicate throws","suites":["filter"],"updatePoint":{"line":108,"column":63},"line":108,"code":"  it('should filter in only prime numbers, but predicate throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^-------!           ';\n      const expected = '     --3---5-#           ';\n\n      let invoked = 0;\n      function predicate(x: any) {\n        invoked++;\n        if (invoked === 4) {\n          throw 'error';\n        }\n        return isPrime(x);\n      }\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, predicate with index","suites":["filter"],"updatePoint":{"line":128,"column":63},"line":128,"code":"  it('should filter in only prime numbers, predicate with index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3--------7-------|';\n\n      function predicate(x: any, i: number) {\n        return isPrime(+x + i * 10);\n      }\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke predicate once for each checked value","suites":["filter"],"updatePoint":{"line":143,"column":57},"line":143,"code":"  it('should invoke predicate once for each checked value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3---5----7-------|';\n\n      let invoked = 0;\n      const predicate = (x: any) => {\n        invoked++;\n        return isPrime(x);\n      };\n\n      const result = e1.pipe(\n        filter(predicate),\n        tap({\n          complete: () => {\n            expect(invoked).to.equal(7);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, predicate with index, source unsubscribes early","suites":["filter"],"updatePoint":{"line":169,"column":90},"line":169,"code":"  it('should filter in only prime numbers, predicate with index, source unsubscribes early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^-----------!       ';\n      const expected = '     --3--------7-       ';\n      const unsub = '        ------------!       ';\n\n      function predicate(x: any, i: number) {\n        return isPrime(+x + i * 10);\n      }\n\n      expectObservable(e1.pipe(filter(predicate)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, predicate with index, source throws","suites":["filter"],"updatePoint":{"line":185,"column":78},"line":185,"code":"  it('should filter in only prime numbers, predicate with index, source throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--#');\n      const e1subs = '       ^------------------!';\n      const expected = '     --3--------7-------#';\n\n      function predicate(x: any, i: number) {\n        return isPrime(+x + i * 10);\n      }\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should filter in only prime numbers, predicate with index and throws","suites":["filter"],"updatePoint":{"line":200,"column":74},"line":200,"code":"  it('should filter in only prime numbers, predicate with index and throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^-------!           ';\n      const expected = '     --3-----#           ';\n\n      let invoked = 0;\n      function predicate(x: any, i: number) {\n        invoked++;\n        if (invoked === 4) {\n          throw 'error';\n        }\n        return isPrime(+x + i * 10);\n      }\n\n      expectObservable(e1.pipe(filter(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should compose with another filter to allow multiples of six","suites":["filter"],"updatePoint":{"line":220,"column":66},"line":220,"code":"  it('should compose with another filter to allow multiples of six', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --------6----------|';\n\n      const result = e1.pipe(\n        filter((x: string) => +x % 2 === 0),\n        filter((x: string) => +x % 3 === 0)\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to accept and use a thisArg","suites":["filter"],"updatePoint":{"line":236,"column":48},"line":236,"code":"  it('should be able to accept and use a thisArg', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     --------6----------|';\n\n      class Filterer {\n        filter1 = (x: string) => +x % 2 === 0;\n        filter2 = (x: string) => +x % 3 === 0;\n      }\n\n      const filterer = new Filterer();\n\n      const result = e1.pipe(\n        filter(function (this: any, x) {\n          return this.filter1(x);\n        }, filterer),\n        filter(function (this: any, x) {\n          return this.filter2(x);\n        }, filterer),\n        filter(function (this: any, x) {\n          return this.filter1(x);\n        }, filterer)\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to use filter and map composed","suites":["filter"],"updatePoint":{"line":266,"column":51},"line":266,"code":"  it('should be able to use filter and map composed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^------------------!';\n      const expected = '     ----a---b----c-----|';\n      const values = { a: 16, b: 36, c: 64 };\n\n      const result = e1.pipe(\n        filter((x: string) => +x % 2 === 0),\n        map((x: string) => +x * +x)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from the source","suites":["filter"],"updatePoint":{"line":283,"column":45},"line":283,"code":"  it('should propagate errors from the source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --0--1--2--3--4--#');\n      const e1subs = '  ^----------------!';\n      const expected = '-----1-----3-----#';\n\n      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["filter"],"updatePoint":{"line":294,"column":25},"line":294,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["filter"],"updatePoint":{"line":305,"column":25},"line":305,"code":"  it('should handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["filter"],"updatePoint":{"line":316,"column":25},"line":316,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(filter(oddFilter))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should send errors down the error path","suites":["filter"],"updatePoint":{"line":327,"column":44},"line":327,"code":"  it('should send errors down the error path', (done) => {\n    of(42)\n      .pipe(\n        filter((x: number, index: number): boolean => {\n          throw 'bad';\n        })\n      )\n      .subscribe({\n        next: (x: number) => {\n          done(new Error('should not be called'));\n        },\n        error: (err: any) => {\n          expect(err).to.equal('bad');\n          done();\n        },\n        complete: () => {\n          done(new Error('should not be called'));\n        },\n      });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["filter"],"updatePoint":{"line":348,"column":72},"line":348,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1--2--^-3-4-5-6--7-8--9--|');\n      const e1subs = '       ^-----------!       ';\n      const expected = '     --3---5----7-       ';\n      const unsub = '        ------------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        filter(isPrime),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should support type guards without breaking previous behavior","suites":["filter"],"updatePoint":{"line":366,"column":67},"line":366,"code":"  it('should support type guards without breaking previous behavior', () => {\n    // tslint:disable no-unused-variable\n\n    // type guards with interfaces and classes\n    {\n      interface Bar {\n        bar?: string;\n      }\n      interface Baz {\n        baz?: number;\n      }\n      class Foo implements Bar, Baz {\n        constructor(public bar: string = 'name', public baz: number = 42) {}\n      }\n\n      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined;\n      const isBaz = (x: any): x is Baz => x && (<Baz>x).baz !== undefined;\n\n      const foo: Foo = new Foo();\n      of(foo)\n        .pipe(filter((foo) => foo.baz === 42))\n        .subscribe((x) => x.baz); // x is still Foo\n      of(foo)\n        .pipe(filter(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n\n      const foobar: Bar = new Foo(); // type is interface, not the class\n      of(foobar)\n        .pipe(filter((foobar) => foobar.bar === 'name'))\n        .subscribe((x) => x.bar); // <-- x is still Bar\n      of(foobar)\n        .pipe(filter(isBar))\n        .subscribe((x) => x.bar); // <--- x is Bar!\n\n      const barish = { bar: 'quack', baz: 42 }; // type can quack like a Bar\n      of(barish)\n        .pipe(filter((x) => x.bar === 'quack'))\n        .subscribe((x) => x.bar); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(filter(isBar))\n        .subscribe((bar) => bar.bar); // x is Bar!\n    }\n\n    // type guards with primitive types\n    {\n      const xs: Observable<string | number> = from([1, 'aaa', 3, 'bb']);\n\n      // This type guard will narrow a `string | number` to a string in the examples below\n      const isString = (x: string | number): x is string => typeof x === 'string';\n\n      xs.pipe(filter(isString)).subscribe((s) => s.length); // s is string\n\n      // In contrast, this type of regular boolean predicate still maintains the original type\n      xs.pipe(filter((x) => typeof x === 'number')).subscribe((x) => x); // x is still string | number\n      xs.pipe(filter((x, i) => typeof x === 'number' && x > i)).subscribe((x) => x); // x is still string | number\n    }\n\n    // tslint:disable enable\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should support Boolean as a predicate","suites":["filter"],"updatePoint":{"line":426,"column":43},"line":426,"code":"  it('should support Boolean as a predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { t: 1, f: 0 };\n      const e1 = hot('-t--f--^-t-f-t-f--t-f--f--|', values);\n      const e1subs = '       ^------------------!';\n      const expected = '     --t---t----t-------|';\n\n      expectObservable(e1.pipe(filter(Boolean))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["filter"],"updatePoint":{"line":438,"column":73},"line":438,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        filter(() => true),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/filter-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize after complete","suites":["finalize"],"updatePoint":{"line":11,"column":41},"line":11,"code":"  it('should call finalize after complete', (done) => {\n    let completed = false;\n    of(1, 2, 3)\n      .pipe(\n        finalize(() => {\n          expect(completed).to.be.true;\n          done();\n        })\n      )\n      .subscribe({\n        complete: () => {\n          completed = true;\n        },\n      });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize after error","suites":["finalize"],"updatePoint":{"line":27,"column":38},"line":27,"code":"  it('should call finalize after error', (done) => {\n    let thrown = false;\n    of(1, 2, 3)\n      .pipe(\n        map(function (x) {\n          if (x === 3) {\n            throw x;\n          }\n          return x;\n        }),\n        finalize(() => {\n          expect(thrown).to.be.true;\n          done();\n        })\n      )\n      .subscribe({\n        error: () => {\n          thrown = true;\n        },\n      });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize upon disposal","suites":["finalize"],"updatePoint":{"line":49,"column":40},"line":49,"code":"  it('should call finalize upon disposal', (done) => {\n    let disposed = false;\n    const subscription = timer(100)\n      .pipe(\n        finalize(() => {\n          expect(disposed).to.be.true;\n          done();\n        })\n      )\n      .subscribe();\n    disposed = true;\n    subscription.unsubscribe();\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize when synchronously subscribing to and unsubscribing from a shared Observable","suites":["finalize"],"updatePoint":{"line":63,"column":103},"line":63,"code":"  it('should call finalize when synchronously subscribing to and unsubscribing from a shared Observable', (done) => {\n    interval(50).pipe(finalize(done), share()).subscribe().unsubscribe();\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should call two finalize instances in succession on a shared Observable","suites":["finalize"],"updatePoint":{"line":67,"column":77},"line":67,"code":"  it('should call two finalize instances in succession on a shared Observable', (done) => {\n    let invoked = 0;\n    function checkFinally() {\n      invoked += 1;\n      if (invoked === 2) {\n        done();\n      }\n    }\n\n    of(1, 2, 3).pipe(finalize(checkFinally), finalize(checkFinally), share()).subscribe();\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["finalize"],"updatePoint":{"line":79,"column":25},"line":79,"code":"  it('should handle empty', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["finalize"],"updatePoint":{"line":98,"column":25},"line":98,"code":"  it('should handle never', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.false;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["finalize"],"updatePoint":{"line":117,"column":25},"line":117,"code":"  it('should handle throw', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle basic hot observable","suites":["finalize"],"updatePoint":{"line":136,"column":40},"line":136,"code":"  it('should handle basic hot observable', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const expected = '--a--b--c--|';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle basic cold observable","suites":["finalize"],"updatePoint":{"line":155,"column":41},"line":155,"code":"  it('should handle basic cold observable', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = cold(' --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const expected = '--a--b--c--|';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle basic error","suites":["finalize"],"updatePoint":{"line":174,"column":31},"line":174,"code":"  it('should handle basic error', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  --a--b--c--#');\n      const e1subs = '  ^----------!';\n      const expected = '--a--b--c--#';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle unsubscription","suites":["finalize"],"updatePoint":{"line":193,"column":34},"line":193,"code":"  it('should handle unsubscription', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      let executed = false;\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--a--b-';\n      const unsub = '   ------!';\n\n      const result = e1.pipe(finalize(() => (executed = true)));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // manually flush so `finalize()` has chance to execute before the test is over.\n      testScheduler.flush();\n      expect(executed).to.be.true;\n    });\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle interop source observables","suites":["finalize"],"updatePoint":{"line":213,"column":46},"line":213,"code":"  it('should handle interop source observables', () => {\n    // https://github.com/ReactiveX/rxjs/issues/5237\n    let finalized = false;\n    const subscription = asInteropObservable(NEVER)\n      .pipe(finalize(() => (finalized = true)))\n      .subscribe();\n    subscription.unsubscribe();\n    expect(finalized).to.be.true;\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize sources before sinks","suites":["finalize"],"updatePoint":{"line":223,"column":42},"line":223,"code":"  it('should finalize sources before sinks', () => {\n    const finalized: string[] = [];\n    of(42)\n      .pipe(\n        finalize(() => finalized.push('source')),\n        finalize(() => finalized.push('sink'))\n      )\n      .subscribe();\n    expect(finalized).to.deep.equal(['source', 'sink']);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize after the finalization","suites":["finalize"],"updatePoint":{"line":234,"column":44},"line":234,"code":"  it('should finalize after the finalization', () => {\n    const order: string[] = [];\n    const source = new Observable<void>(() => {\n      return () => order.push('finalizer');\n    });\n    const subscription = source.pipe(finalize(() => order.push('finalize'))).subscribe();\n    subscription.unsubscribe();\n    expect(order).to.deep.equal(['finalizer', 'finalize']);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize after the finalizer with synchronous completion","suites":["finalize"],"updatePoint":{"line":244,"column":69},"line":244,"code":"  it('should finalize after the finalizer with synchronous completion', () => {\n    const order: string[] = [];\n    const source = new Observable<void>((subscriber) => {\n      subscriber.complete();\n      return () => order.push('finalizer');\n    });\n    source.pipe(finalize(() => order.push('finalize'))).subscribe();\n    expect(order).to.deep.equal(['finalizer', 'finalize']);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["finalize"],"updatePoint":{"line":254,"column":73},"line":254,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        finalize(() => {\n          /* noop */\n        }),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalize even with a sync thrown error","suites":["finalize"],"updatePoint":{"line":279,"column":59},"line":279,"code":"  it('should execute finalize even with a sync thrown error', () => {\n    let called = false;\n    const badObservable = new Observable(() => {\n      throw new Error('bad');\n    }).pipe(\n      finalize(() => {\n        called = true;\n      })\n    );\n\n    badObservable.subscribe({\n      error: noop,\n    });\n\n    expect(called).to.be.true;\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalize in order even with a sync error","suites":["finalize"],"updatePoint":{"line":296,"column":61},"line":296,"code":"  it('should execute finalize in order even with a sync error', () => {\n    const results: any[] = [];\n    const badObservable = new Observable((subscriber) => {\n      subscriber.error(new Error('bad'));\n    }).pipe(\n      finalize(() => {\n        results.push(1);\n      }),\n      finalize(() => {\n        results.push(2);\n      })\n    );\n\n    badObservable.subscribe({\n      error: noop,\n    });\n\n    expect(results).to.deep.equal([1, 2]);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute finalize in order even with a sync thrown error","suites":["finalize"],"updatePoint":{"line":316,"column":68},"line":316,"code":"  it('should execute finalize in order even with a sync thrown error', () => {\n    const results: any[] = [];\n    const badObservable = new Observable(() => {\n      throw new Error('bad');\n    }).pipe(\n      finalize(() => {\n        results.push(1);\n      }),\n      finalize(() => {\n        results.push(2);\n      })\n    );\n\n    badObservable.subscribe({\n      error: noop,\n    });\n    expect(results).to.deep.equal([1, 2]);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize in the proper order","suites":["finalize"],"updatePoint":{"line":335,"column":41},"line":335,"code":"  it('should finalize in the proper order', () => {\n    const results: any[] = [];\n    of(1)\n      .pipe(\n        finalize(() => results.push(1)),\n        finalize(() => results.push(2)),\n        finalize(() => results.push(3)),\n        finalize(() => results.push(4))\n      )\n      .subscribe();\n\n    expect(results).to.deep.equal([1, 2, 3, 4]);\n  });","file":"operators/finalize-spec.ts","skipped":false,"dir":"spec"},{"name":"should return matching element from source emits single element","suites":["find"],"updatePoint":{"line":20,"column":69},"line":20,"code":"  it('should return matching element from source emits single element', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 3, b: 9, c: 15, d: 20 };\n      const e1 = hot('  ---a--b--c--d---|', values);\n      const e1subs = '  ^--------!       ';\n      const expected = '---------(c|)    ';\n\n      const predicate = function (x: number) {\n        return x % 5 === 0;\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit if source does not emit","suites":["find"],"updatePoint":{"line":36,"column":45},"line":36,"code":"  it('should not emit if source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(find(truePredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should return undefined if source is empty to match predicate","suites":["find"],"updatePoint":{"line":47,"column":67},"line":47,"code":"  it('should return undefined if source is empty to match predicate', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      const result = e1.pipe(find(truePredicate));\n\n      expectObservable(result).toBe(expected, { x: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should return matching element from source emits single element","suites":["find"],"updatePoint":{"line":60,"column":69},"line":60,"code":"  it('should return matching element from source emits single element', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^-!   ';\n      const expected = '--(a|)';\n\n      const predicate = function (value: string) {\n        return value === 'a';\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should return matching element from source emits multiple elements","suites":["find"],"updatePoint":{"line":75,"column":72},"line":75,"code":"  it('should return matching element from source emits multiple elements', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|');\n      const e1subs = '  ^----!      ';\n      const expected = '-----(b|)   ';\n\n      const predicate = function (value: string) {\n        return value === 'b';\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with a custom thisArg","suites":["find"],"updatePoint":{"line":90,"column":39},"line":90,"code":"  it('should work with a custom thisArg', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|');\n      const e1subs = '  ^----!      ';\n      const expected = '-----(b|)   ';\n\n      const finder = {\n        target: 'b',\n      };\n      const predicate = function (this: typeof finder, value: string) {\n        return value === this.target;\n      };\n\n      expectObservable(e1.pipe(find(predicate, finder))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should return undefined if element does not match with predicate","suites":["find"],"updatePoint":{"line":108,"column":70},"line":108,"code":"  it('should return undefined if element does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|   ');\n      const e1subs = '  ^----------!   ';\n      const expected = '-----------(x|)';\n\n      const predicate = function (value: string) {\n        return value === 'z';\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected, { x: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["find"],"updatePoint":{"line":123,"column":53},"line":123,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(find((value: string) => value === 'z'));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["find"],"updatePoint":{"line":137,"column":83},"line":137,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        find((value) => value === 'z'),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe when the predicate is matched","suites":["find"],"updatePoint":{"line":155,"column":54},"line":155,"code":"  it('should unsubscribe when the predicate is matched', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|');\n      const e1subs = '  ^----!      ';\n      const t = time('    --|       ');\n      //                     --|\n      const expected = '-------(b|) ';\n\n      const result = e1.pipe(\n        find((value: string) => value === 'b'),\n        delay(t)\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise if source raise error while element does not match with predicate","suites":["find"],"updatePoint":{"line":173,"column":84},"line":173,"code":"  it('should raise if source raise error while element does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const expected = '--------#';\n\n      const predicate = function (value: string) {\n        return value === 'z';\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if predicate throws error","suites":["find"],"updatePoint":{"line":188,"column":50},"line":188,"code":"  it('should raise error if predicate throws error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-!         ';\n      const expected = '--#         ';\n\n      const predicate = function (value: string) {\n        throw 'error';\n      };\n\n      expectObservable(e1.pipe(find(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should support type guards without breaking previous behavior","suites":["find"],"updatePoint":{"line":203,"column":67},"line":203,"code":"  it('should support type guards without breaking previous behavior', () => {\n    // tslint:disable no-unused-variable\n\n    // type guards with interfaces and classes\n    {\n      interface Bar {\n        bar?: string;\n      }\n      interface Baz {\n        baz?: number;\n      }\n      class Foo implements Bar, Baz {\n        constructor(public bar: string = 'name', public baz: number = 42) {}\n      }\n\n      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined;\n      const isBaz = (x: any): x is Baz => x && (<Baz>x).baz !== undefined;\n\n      const foo: Foo = new Foo();\n      of(foo)\n        .pipe(find((foo) => foo.baz === 42))\n        .subscribe((x) => x!.baz); // x is still Foo\n      of(foo)\n        .pipe(find(isBar))\n        .subscribe((x) => x!.bar); // x is Bar!\n\n      const foobar: Bar = new Foo(); // type is interface, not the class\n      of(foobar)\n        .pipe(find((foobar) => foobar.bar === 'name'))\n        .subscribe((x) => x!.bar); // <-- x is still Bar\n      of(foobar)\n        .pipe(find(isBar))\n        .subscribe((x) => x!.bar); // <--- x is Bar!\n\n      const barish = { bar: 'quack', baz: 42 }; // type can quack like a Bar\n      of(barish)\n        .pipe(find((x) => x.bar === 'quack'))\n        .subscribe((x) => x!.bar); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(find(isBar))\n        .subscribe((bar) => bar!.bar); // x is Bar!\n    }\n\n    // type guards with primitive types\n    {\n      const xs: Observable<string | number> = from([1, 'aaa', 3, 'bb']);\n\n      // This type guard will narrow a `string | number` to a string in the examples below\n      const isString = (x: string | number): x is string => typeof x === 'string';\n\n      xs.pipe(find(isString)).subscribe((s) => s!.length); // s is string\n\n      // In contrast, this type of regular boolean predicate still maintains the original type\n      xs.pipe(find((x) => typeof x === 'number')).subscribe((x) => x); // x is still string | number\n      xs.pipe(find((x, i) => typeof x === 'number' && x > i)).subscribe((x) => x); // x is still string | number\n    }\n\n    // tslint:disable enable\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["find"],"updatePoint":{"line":263,"column":73},"line":263,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits, it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(find((value) => value === 2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/find-spec.ts","skipped":false,"dir":"spec"},{"name":"should return matching element from source emits single element","suites":["findIndex"],"updatePoint":{"line":20,"column":69},"line":20,"code":"  it('should return matching element from source emits single element', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 3, b: 9, c: 15, d: 20 };\n      const e1 = hot('  ---a--b--c--d---|', values);\n      const e1subs = '  ^--------!       ';\n      const expected = '---------(x|)    ';\n\n      const predicate = function (x: number) {\n        return x % 5 === 0;\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 2 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit if source does not emit","suites":["findIndex"],"updatePoint":{"line":36,"column":45},"line":36,"code":"  it('should not emit if source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(findIndex(truePredicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should return negative index if source is empty to match predicate","suites":["findIndex"],"updatePoint":{"line":47,"column":72},"line":47,"code":"  it('should return negative index if source is empty to match predicate', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      const result = e1.pipe(findIndex(truePredicate));\n\n      expectObservable(result).toBe(expected, { x: -1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should return index of element from source emits single element","suites":["findIndex"],"updatePoint":{"line":60,"column":69},"line":60,"code":"  it('should return index of element from source emits single element', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|', { a: 1 });\n      const e1subs = '  ^-!   ';\n      const expected = '--(x|)';\n\n      const predicate = function (value: number) {\n        return value === 1;\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 0 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should return index of matching element from source emits multiple elements","suites":["findIndex"],"updatePoint":{"line":75,"column":81},"line":75,"code":"  it('should return index of matching element from source emits multiple elements', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|', { b: 7 });\n      const e1subs = '  ^----!      ';\n      const expected = '-----(x|)   ';\n\n      const predicate = function (value: number) {\n        return value === 7;\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with a custom thisArg","suites":["findIndex"],"updatePoint":{"line":90,"column":39},"line":90,"code":"  it('should work with a custom thisArg', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const sourceValues = { b: 7 };\n      const e1 = hot('  --a--b---c-|', sourceValues);\n      const e1subs = '  ^----!      ';\n      const expected = '-----(x|)   ';\n\n      const predicate = function (this: typeof sourceValues, value: number) {\n        return value === this.b;\n      };\n      const result = e1.pipe(findIndex(predicate, sourceValues));\n\n      expectObservable(result).toBe(expected, { x: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should return negative index if element does not match with predicate","suites":["findIndex"],"updatePoint":{"line":107,"column":75},"line":107,"code":"  it('should return negative index if element does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|   ');\n      const e1subs = '  ^----------!   ';\n      const expected = '-----------(x|)';\n\n      const predicate = function (value: string) {\n        return value === 'z';\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected, { x: -1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["findIndex"],"updatePoint":{"line":122,"column":53},"line":122,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(findIndex((value: string) => value === 'z'));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["findIndex"],"updatePoint":{"line":136,"column":83},"line":136,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        findIndex((value: string) => value === 'z'),\n        mergeMap((x: number) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe when the predicate is matched","suites":["findIndex"],"updatePoint":{"line":154,"column":54},"line":154,"code":"  it('should unsubscribe when the predicate is matched', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|');\n      const e1subs = '  ^----!      ';\n      const t = time('    --|       ');\n      //                     --|\n      const expected = '-------(x|) ';\n\n      const result = e1.pipe(\n        findIndex((value: string) => value === 'b'),\n        delay(t)\n      );\n\n      expectObservable(result).toBe(expected, { x: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise if source raise error while element does not match with predicate","suites":["findIndex"],"updatePoint":{"line":172,"column":84},"line":172,"code":"  it('should raise if source raise error while element does not match with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const expected = '--------#';\n\n      const predicate = function (value: string) {\n        return value === 'z';\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if predicate throws error","suites":["findIndex"],"updatePoint":{"line":187,"column":50},"line":187,"code":"  it('should raise error if predicate throws error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-!         ';\n      const expected = '--#         ';\n\n      const predicate = function (value: string) {\n        throw 'error';\n      };\n\n      expectObservable(e1.pipe(findIndex(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["findIndex"],"updatePoint":{"line":202,"column":73},"line":202,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits, it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(findIndex((value) => value === 2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/findIndex-spec.ts","skipped":false,"dir":"spec"},{"name":"should take the first value of an observable with many values","suites":["first"],"updatePoint":{"line":16,"column":67},"line":16,"code":"  it('should take the first value of an observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--b--c---d---|');\n      const e1subs = '  ^----!              ';\n      const expected = '-----(a|)           ';\n\n      expectObservable(e1.pipe(first())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should take the first value of an observable with one value","suites":["first"],"updatePoint":{"line":27,"column":65},"line":27,"code":"  it('should take the first value of an observable with one value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---(a|)');\n      const e1subs = '  ^--!   ';\n      const expected = '---(a|)';\n\n      expectObservable(e1.pipe(first())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow undefined as a default value","suites":["first"],"updatePoint":{"line":38,"column":47},"line":38,"code":"  it('should allow undefined as a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--a---a-|   ');\n      const e1subs = '  ^-------------!   ';\n      const expected = '--------------(U|)';\n\n      expectObservable(e1.pipe(first((value) => value === 'b', undefined))).toBe(expected, { U: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on empty","suites":["first"],"updatePoint":{"line":49,"column":27},"line":49,"code":"  it('should error on empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^----|');\n      const e1subs = '     ^----!';\n      const expected = '   -----#';\n\n      expectObservable(e1.pipe(first())).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the default value if source observable was empty","suites":["first"],"updatePoint":{"line":60,"column":68},"line":60,"code":"  it('should return the default value if source observable was empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-----^----|   ');\n      const e1subs = '     ^----!   ';\n      const expected = '   -----(a|)';\n\n      expectObservable(e1.pipe(first(null, 'a'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should only emit one value in recursive cases","suites":["first"],"updatePoint":{"line":71,"column":51},"line":71,"code":"  it('should only emit one value in recursive cases', () => {\n    const subject = new Subject<number>();\n    const results: number[] = [];\n\n    subject.pipe(first()).subscribe((x) => {\n      results.push(x);\n      subject.next(x + 1);\n    });\n\n    subject.next(0);\n\n    expect(results).to.deep.equal([0]);\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from the source observable","suites":["first"],"updatePoint":{"line":85,"column":55},"line":85,"code":"  it('should propagate error from the source observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^---#');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      expectObservable(e1.pipe(first())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should go on forever on never","suites":["first"],"updatePoint":{"line":96,"column":35},"line":96,"code":"  it('should go on forever on never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--^-------');\n      const e1subs = '  ^-------';\n      const expected = '--------';\n\n      expectObservable(e1.pipe(first())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["first"],"updatePoint":{"line":107,"column":53},"line":107,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^-----b----c---d--|');\n      const e1subs = '     ^--!               ';\n      const expected = '   ----               ';\n      const unsub = '      ---!               ';\n\n      expectObservable(e1.pipe(first()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["first"],"updatePoint":{"line":119,"column":83},"line":119,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^-----b----c---d--|');\n      const e1subs = '     ^--!               ';\n      const expected = '   ----               ';\n      const unsub = '      ---!               ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        first(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe when the first value is received","suites":["first"],"updatePoint":{"line":137,"column":57},"line":137,"code":"  it('should unsubscribe when the first value is received', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b---c-|');\n      const e1subs = '  ^-!         ';\n      const t = time('    --|       ');\n      const expected = '----(a|)    ';\n\n      const result = e1.pipe(first(), delay(t));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should return first value that matches a predicate","suites":["first"],"updatePoint":{"line":151,"column":56},"line":151,"code":"  it('should return first value that matches a predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^--b--c--a--c--|');\n      const e1subs = '    ^-----!         ';\n      const expected = '  ------(c|)      ';\n\n      expectObservable(e1.pipe(first((value) => value === 'c'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should return first value that matches a predicate for odd numbers","suites":["first"],"updatePoint":{"line":162,"column":72},"line":162,"code":"  it('should return first value that matches a predicate for odd numbers', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 2, c: 3, d: 4, e: 5 };\n      const e1 = hot('--a-^--b--c--d--e--|', values);\n      const e1subs = '    ^-----!         ';\n      const expected = '  ------(c|)      ';\n\n      expectObservable(e1.pipe(first((x) => x % 2 === 1))).toBe(expected, { c: 3 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should error when no value matches the predicate","suites":["first"],"updatePoint":{"line":174,"column":54},"line":174,"code":"  it('should error when no value matches the predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^--b--c--a--c--|');\n      const e1subs = '    ^--------------!';\n      const expected = '  ---------------#';\n\n      expectObservable(e1.pipe(first((x) => x === 's'))).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the default value when no value matches the predicate","suites":["first"],"updatePoint":{"line":185,"column":73},"line":185,"code":"  it('should return the default value when no value matches the predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^--b--c--a--c--|   ');\n      const e1subs = '    ^--------------!   ';\n      const expected = '  ---------------(d|)';\n\n      expectObservable(e1.pipe(first((x) => x === 's', 'd'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error when no value matches the predicate","suites":["first"],"updatePoint":{"line":196,"column":64},"line":196,"code":"  it('should propagate error when no value matches the predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^--b--c--a--#');\n      const e1subs = '    ^-----------!';\n      const expected = '  ------------#';\n\n      expectObservable(e1.pipe(first((x) => x === 's'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should return first value that matches the index in the predicate","suites":["first"],"updatePoint":{"line":207,"column":71},"line":207,"code":"  it('should return first value that matches the index in the predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^--b--c--a--c--|');\n      const e1subs = '    ^--------!      ';\n      const expected = '  ---------(a|)   ';\n\n      expectObservable(e1.pipe(first((_, i) => i === 2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from predicate","suites":["first"],"updatePoint":{"line":218,"column":43},"line":218,"code":"  it('should propagate error from predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 2, c: 3, d: 4, e: 5 };\n      const e1 = hot('--a-^--b--c--d--e--|', values);\n      const e1subs = '    ^--------!      ';\n      const expected = '  ---------#      ';\n\n      const predicate = function (value: number) {\n        if (value < 4) {\n          return false;\n        } else {\n          throw 'error';\n        }\n      };\n\n      expectObservable(e1.pipe(first(predicate))).toBe(expected, null, 'error');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should support type guards without breaking previous behavior","suites":["first"],"updatePoint":{"line":238,"column":67},"line":238,"code":"  it('should support type guards without breaking previous behavior', () => {\n    // tslint:disable no-unused-variable\n\n    // type guards with interfaces and classes\n    {\n      interface Bar {\n        bar?: string;\n      }\n      interface Baz {\n        baz?: number;\n      }\n      class Foo implements Bar, Baz {\n        constructor(public bar: string = 'name', public baz: number = 42) {}\n      }\n\n      const isBar = (x: any): x is Bar => x && (x as Bar).bar !== undefined;\n      const isBaz = (x: any): x is Baz => x && (x as Baz).baz !== undefined;\n\n      const foo: Foo = new Foo();\n      of(foo)\n        .pipe(first())\n        .subscribe((x) => x.baz); // x is Foo\n      of(foo)\n        .pipe(first((foo) => foo.bar === 'name'))\n        .subscribe((x) => x.baz); // x is still Foo\n      of(foo)\n        .pipe(first(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n\n      const foobar: Bar = new Foo(); // type is the interface, not the class\n      of(foobar)\n        .pipe(first())\n        .subscribe((x) => x.bar); // x is Bar\n      of(foobar)\n        .pipe(first((foobar) => foobar.bar === 'name'))\n        .subscribe((x) => x.bar); // x is still Bar\n      of(foobar)\n        .pipe(first(isBaz))\n        .subscribe((x) => x.baz); // x is Baz!\n\n      const barish = { bar: 'quack', baz: 42 }; // type can quack like a Bar\n      of(barish)\n        .pipe(first())\n        .subscribe((x) => x.baz); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(first((x) => x.bar === 'quack'))\n        .subscribe((x) => x.bar); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(first(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n    }\n\n    // type guards with primitive types\n    {\n      const xs: Observable<string | number> = from([1, 'aaa', 3, 'bb']);\n\n      // This type guard will narrow a `string | number` to a string in the examples below\n      const isString = (x: string | number): x is string => typeof x === 'string';\n\n      // missing predicate preserves the type\n      xs.pipe(first()).subscribe((x) => x); // x is still string | number\n\n      // null predicate preserves the type\n      xs.pipe(first(null)).subscribe((x) => x); // x is still string | number\n\n      // undefined predicate preserves the type\n      xs.pipe(first(undefined)).subscribe((x) => x); // x is still string | number\n\n      // After the type guard `first` predicates, the type is narrowed to string\n      xs.pipe(first(isString)).subscribe((s) => s.length); // s is string\n\n      // boolean predicates preserve the type\n      xs.pipe(first((x) => typeof x === 'string')).subscribe((x) => x); // x is still string | number\n    }\n\n    // tslint:disable enable\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["first"],"updatePoint":{"line":316,"column":73},"line":316,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits, it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(first((value) => value === 2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/first-spec.ts","skipped":false,"dir":"spec"},{"name":"should group numbers by odd/even","suites":["groupBy operator"],"updatePoint":{"line":17,"column":38},"line":17,"code":"  it('should group numbers by odd/even', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const e1 = hot('  --1---2---3---4---5---|');\n      const expected = '--x---y---------------|';\n      const x = cold('  1-------3-------5---|');\n      const y = cold('  2-------4-------|');\n      const expectedValues = { x: x, y: y };\n\n      const source = e1.pipe(groupBy((val: string) => parseInt(val) % 2));\n      expectObservable(source).toBe(expected, expectedValues);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values","suites":["groupBy operator"],"updatePoint":{"line":44,"column":25},"line":44,"code":"  it('should group values', (done) => {\n    const expectedGroups = [\n      { key: 1, values: [1, 3] },\n      { key: 0, values: [2] },\n    ];\n\n    of(1, 2, 3)\n      .pipe(groupBy((x) => x % 2))\n      .subscribe({\n        next: (g: any) => {\n          const expectedGroup = expectedGroups.shift()!;\n          expect(g.key).to.equal(expectedGroup.key);\n\n          g.subscribe((x: any) => {\n            expect(x).to.deep.equal(expectedGroup.values.shift());\n          });\n        },\n        complete: done,\n      });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with an element selector","suites":["groupBy operator"],"updatePoint":{"line":65,"column":50},"line":65,"code":"  it('should group values with an element selector', (done) => {\n    const expectedGroups = [\n      { key: 1, values: ['1!', '3!'] },\n      { key: 0, values: ['2!'] },\n    ];\n\n    of(1, 2, 3)\n      .pipe(\n        groupBy(\n          (x) => x % 2,\n          (x) => x + '!'\n        )\n      )\n      .subscribe({\n        next: (g: any) => {\n          const expectedGroup = expectedGroups.shift()!;\n          expect(g.key).to.equal(expectedGroup.key);\n\n          g.subscribe((x: any) => {\n            expect(x).to.deep.equal(expectedGroup.values.shift());\n          });\n        },\n        complete: done,\n      });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a duration selector","suites":["groupBy operator"],"updatePoint":{"line":91,"column":50},"line":91,"code":"  it('should group values with a duration selector', () => {\n    const expectedGroups = [\n      { key: 1, values: [1, 3] },\n      { key: 0, values: [2, 4] },\n      { key: 1, values: [5] },\n      { key: 0, values: [6] },\n    ];\n\n    const resultingGroups: { key: number; values: number[] }[] = [];\n\n    of(1, 2, 3, 4, 5, 6)\n      .pipe(\n        groupBy((x) => x % 2, {\n          duration: (g) => g.pipe(skip(1)),\n        })\n      )\n      .subscribe((g: any) => {\n        let group = { key: g.key, values: [] as number[] };\n\n        g.subscribe((x: any) => {\n          group.values.push(x);\n        });\n\n        resultingGroups.push(group);\n      });\n\n    expect(resultingGroups).to.deep.equal(expectedGroups);\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a subject selector","suites":["groupBy operator"],"updatePoint":{"line":120,"column":49},"line":120,"code":"  it('should group values with a subject selector', (done) => {\n    const expectedGroups = [\n      { key: 1, values: [3] },\n      { key: 0, values: [2] },\n    ];\n\n    of(1, 2, 3)\n      .pipe(\n        groupBy((x) => x % 2, {\n          connector: () => new ReplaySubject(1),\n        }),\n        // Ensure each inner group reaches the destination after the first event\n        // has been next'd to the group\n        delay(5)\n      )\n      .subscribe({\n        next: (g: any) => {\n          const expectedGroup = expectedGroups.shift()!;\n          expect(g.key).to.equal(expectedGroup.key);\n\n          g.subscribe((x: any) => {\n            expect(x).to.deep.equal(expectedGroup.values.shift());\n          });\n        },\n        complete: done,\n      });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty Observable","suites":["groupBy operator"],"updatePoint":{"line":148,"column":39},"line":148,"code":"  it('should handle an empty Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never Observable","suites":["groupBy operator"],"updatePoint":{"line":161,"column":38},"line":161,"code":"  it('should handle a never Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a just-throw Observable","suites":["groupBy operator"],"updatePoint":{"line":174,"column":43},"line":174,"code":"  it('should handle a just-throw Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  #  ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an Observable with a single value","suites":["groupBy operator"],"updatePoint":{"line":187,"column":53},"line":187,"code":"  it('should handle an Observable with a single value', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: '  foo' };\n      const e1 = hot('  ^--a--|', values);\n      const e1subs = '  ^-----!';\n      const expected = '---g--|';\n      const g = cold('     a--|', values);\n      const expectedValues = { g: g };\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector","suites":["groupBy operator"],"updatePoint":{"line":203,"column":44},"line":203,"code":"  it('should group values with a keySelector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --w---x---y-z-------------|';\n      const w = cold('         a-b---d---------i-----l-|', values);\n      const x = cold('             c-------g-h---------|', values);\n      const y = cold('                 e---------j-k---|', values);\n      const z = cold('                   f-------------|', values);\n      const expectedValues = { w: w, x: x, y: y, z: z };\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit GroupObservables","suites":["groupBy operator"],"updatePoint":{"line":235,"column":34},"line":235,"code":"  it('should emit GroupObservables', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n      };\n      const e1 = hot('-1--2--^-a-b----|', values);\n      const e1subs = '       ^--------!';\n      const expected = '     --g------|';\n      const expectedValues = { g: 'foo' };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        tap((group: any) => {\n          expect(group.key).to.equal('foo');\n          expect(group instanceof Observable).to.be.true;\n        }),\n        map((group: any) => {\n          return group.key;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector, assert GroupSubject key","suites":["groupBy operator"],"updatePoint":{"line":262,"column":69},"line":262,"code":"  it('should group values with a keySelector, assert GroupSubject key', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --w---x---y-z-------------|';\n      const expectedValues = { w: 'foo', x: 'bar', y: 'baz', z: 'qux' };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        map((g: any) => g.key)\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector, but outer throws","suites":["groupBy operator"],"updatePoint":{"line":293,"column":62},"line":293,"code":"  it('should group values with a keySelector, but outer throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --w---x---y-z-------------#';\n      const expectedValues = { w: 'foo', x: 'bar', y: 'baz', z: 'qux' };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        map((g: any) => g.key)\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector, inners propagate error from outer","suites":["groupBy operator"],"updatePoint":{"line":324,"column":79},"line":324,"code":"  it('should group values with a keySelector, inners propagate error from outer', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --w---x---y-z-------------#';\n      const w = cold('         a-b---d---------i-----l-#', values);\n      const x = cold('             c-------g-h---------#', values);\n      const y = cold('                 e---------j-k---#', values);\n      const z = cold('                   f-------------#', values);\n      const expectedValues = { w: w, x: x, y: y, z: z };\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow outer to be unsubscribed early","suites":["groupBy operator"],"updatePoint":{"line":356,"column":49},"line":356,"code":"  it('should allow outer to be unsubscribed early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const unsub = '        -----------!               ';\n      const e1subs = '       ^----------!               ';\n      const expected = '     --w---x---y-               ';\n      const expectedValues = { w: 'foo', x: 'bar', y: 'baz' };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        map((group: any) => group.key)\n      );\n\n      expectObservable(source, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from the source when the outer and inner subscriptions are disposed","suites":["groupBy operator"],"updatePoint":{"line":388,"column":92},"line":388,"code":"  it('should unsubscribe from the source when the outer and inner subscriptions are disposed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-!                        ';\n      const expected = '     --(a|)                     ';\n\n      const source = e1.pipe(\n        groupBy((val) => val.toLowerCase().trim()),\n        take(1),\n        mergeMap((group) => group.pipe(take(1)))\n      );\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["groupBy operator"],"updatePoint":{"line":419,"column":72},"line":419,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^----------!               ';\n      const expected = '     --w---x---y-               ';\n      const unsub = '        -----------!               ';\n      const expectedValues = { w: 'foo', x: 'bar', y: 'baz' };\n\n      const source = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        groupBy((x: string) => x.toLowerCase().trim()),\n        mergeMap((group: any) => of(group.key))\n      );\n\n      expectObservable(source, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector which eventually throws","suites":["groupBy operator"],"updatePoint":{"line":452,"column":68},"line":452,"code":"  it('should group values with a keySelector which eventually throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------!';\n      const expected = '     --w---x---y-z-------#';\n      const w = cold('         a-b---d---------i-#', values);\n      const x = cold('             c-------g-h---#', values);\n      const y = cold('                 e---------#', values);\n      const z = cold('                   f-------#', values);\n      const expectedValues = { w: w, x: x, y: y, z: z };\n\n      let invoked = 0;\n      const source = e1.pipe(\n        groupBy((val: string) => {\n          invoked++;\n          if (invoked === 10) {\n            throw 'error';\n          }\n          return val.toLowerCase().trim();\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should group values with a keySelector and elementSelector, but elementSelector throws","suites":["groupBy operator"],"updatePoint":{"line":493,"column":92},"line":493,"code":"  it('should group values with a keySelector and elementSelector, but elementSelector throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const reversedValues = mapObject(values, reverseString);\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------!';\n      const expected = '     --w---x---y-z-------#';\n      const w = cold('         a-b---d---------i-#', reversedValues);\n      const x = cold('             c-------g-h---#', reversedValues);\n      const y = cold('                 e---------#', reversedValues);\n      const z = cold('                   f-------#', reversedValues);\n      const expectedValues = { w: w, x: x, y: y, z: z };\n\n      let invoked = 0;\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => {\n            invoked++;\n            if (invoked === 10) {\n              throw 'error';\n            }\n            return reverseString(val);\n          }\n        )\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow the outer to be unsubscribed early but inners continue","suites":["groupBy operator"],"updatePoint":{"line":538,"column":73},"line":538,"code":"  it('should allow the outer to be unsubscribed early but inners continue', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const unsub = '         ---------!                ';\n      const expected = '      --w---x---                ';\n      const w = cold('        a-b---d---------i-----l-| ', values);\n      const x = cold('            c-------g-h---------| ', values);\n      const expectedValues = { w: w, x: x };\n\n      const source = e1.pipe(groupBy((val: string) => val.toLowerCase().trim()));\n\n      expectObservable(source, unsub).toBe(expected, expectedValues);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow an inner to be unsubscribed early but other inners continue","suites":["groupBy operator"],"updatePoint":{"line":567,"column":78},"line":567,"code":"  it('should allow an inner to be unsubscribed early but other inners continue', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const expected = '     --w---x---y-z-------------|';\n      const w = '            --a-b---d-                 ';\n      const unsubw = '       ---------!                 ';\n      const x = '            ------c-------g-h---------|';\n      const y = '            ----------e---------j-k---|';\n      const z = '            ------------f-------------|';\n\n      const expectedGroups = {\n        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),\n        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),\n        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),\n      };\n\n      const fooUnsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubw, true).unsubscribedFrame;\n\n      const source = e1.pipe(\n        groupBy((val) => val.toLowerCase().trim()),\n        map((group) => {\n          const arr: any[] = [];\n\n          const subscription = group.pipe(phonyMarbelize(testScheduler)).subscribe((value) => {\n            arr.push(value);\n          });\n\n          if (group.key === 'foo') {\n            testScheduler.schedule(() => {\n              subscription.unsubscribe();\n            }, fooUnsubscriptionFrame - testScheduler.frame);\n          }\n          return arr;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedGroups);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow inners to be unsubscribed early at different times","suites":["groupBy operator"],"updatePoint":{"line":622,"column":69},"line":622,"code":"  it('should allow inners to be unsubscribed early at different times', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const expected = '     --w---x---y-z-------------|';\n      const w = '            --a-b---d-                 ';\n      const unsubw = '       ---------!                 ';\n      const x = '            ------c------              ';\n      const unsubx = '       ------------!              ';\n      const y = '            ----------e------          ';\n      const unsuby = '       ----------------!          ';\n      const z = '            ------------f-------       ';\n      const unsubz = '       -------------------!       ';\n\n      const expectedGroups = {\n        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),\n        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),\n        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),\n      };\n\n      const unsubscriptionFrames: Record<string, number> = {\n        foo: TestScheduler.parseMarblesAsSubscriptions(unsubw, true).unsubscribedFrame,\n        bar: TestScheduler.parseMarblesAsSubscriptions(unsubx, true).unsubscribedFrame,\n        baz: TestScheduler.parseMarblesAsSubscriptions(unsuby, true).unsubscribedFrame,\n        qux: TestScheduler.parseMarblesAsSubscriptions(unsubz, true).unsubscribedFrame,\n      };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        map((group: any) => {\n          const arr: any[] = [];\n\n          const subscription = group.pipe(phonyMarbelize(testScheduler)).subscribe((value: any) => {\n            arr.push(value);\n          });\n\n          testScheduler.schedule(() => {\n            subscription.unsubscribe();\n          }, unsubscriptionFrames[group.key] - testScheduler.frame);\n          return arr;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedGroups);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow subscribing late to an inner Observable, outer completes","suites":["groupBy operator"],"updatePoint":{"line":683,"column":75},"line":683,"code":"  it('should allow subscribing late to an inner Observable, outer completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        d: 'foO ',\n        i: 'FOO ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('          --a-b---d---------i-----l-|  ', values);\n      const subs = '            ^-------------------------!  ';\n      const subDuration = time('--------------------------|  ');\n      const expected = '        ----------------------------|';\n\n      e1.pipe(groupBy((val: string) => val.toLowerCase().trim())).subscribe((group: any) => {\n        testScheduler.schedule(() => {\n          expectObservable(group).toBe(expected);\n        }, subDuration);\n      });\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow subscribing late to an inner Observable, outer throws","suites":["groupBy operator"],"updatePoint":{"line":706,"column":72},"line":706,"code":"  it('should allow subscribing late to an inner Observable, outer throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        d: 'foO ',\n        i: 'FOO ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('           --a-b---d---------i-----l-#', values);\n      const subs = '             ^-------------------------! ';\n      const subsDuration = time('--------------------------| ');\n      const expected = '         ----------------------------#';\n\n      e1.pipe(groupBy((val: string) => val.toLowerCase().trim())).subscribe({\n        next: (group: any) => {\n          testScheduler.schedule(() => {\n            expectObservable(group).toBe(expected);\n          }, subsDuration);\n        },\n        error: () => {\n          //noop\n        },\n      });\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow subscribing late to inner, unsubscribe outer early","suites":["groupBy operator"],"updatePoint":{"line":734,"column":69},"line":734,"code":"  it('should allow subscribing late to inner, unsubscribe outer early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        d: 'foO ',\n        i: 'FOO ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('           --a-b---d---------i-----l-#', values);\n      const unsub = '            ------------!              ';\n      const e1subs = '           ^-----------!              ';\n      const subsDuration = time('------------|              ');\n      const expectedOuter = '    --w----------              ';\n      const expectedInner = '    -------------              ';\n      const outerValues = { w: 'foo' };\n\n      const source = e1.pipe(\n        groupBy((val: string) => val.toLowerCase().trim()),\n        tap((group: any) => {\n          testScheduler.schedule(() => {\n            expectObservable(group).toBe(expectedInner);\n          }, subsDuration);\n        }),\n        map((group: any) => {\n          return group.key;\n        })\n      );\n\n      expectObservable(source, unsub).toBe(expectedOuter, outerValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a keySelector, elementSelector, and durationSelector","suites":["groupBy operator"],"updatePoint":{"line":768,"column":77},"line":768,"code":"  it('should allow using a keySelector, elementSelector, and durationSelector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const reversedValues = mapObject(values, reverseString);\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --v---w---x-y-----z-------|';\n      const v = cold('       a-b---(d|)                 ', reversedValues);\n      const w = cold('             c-------g-(h|)       ', reversedValues);\n      const x = cold('                  e---------j-(k|)', reversedValues);\n      const y = cold('                   f-------------|', reversedValues);\n      const z = cold('                         i-----l-|', reversedValues);\n      const expectedValues = { v: v, w: w, x: x, y: y, z: z };\n\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => reverseString(val),\n          (group: any) => group.pipe(skip(2))\n        )\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a keySelector, elementSelector, and durationSelector that throws","suites":["groupBy operator"],"updatePoint":{"line":808,"column":89},"line":808,"code":"  it('should allow using a keySelector, elementSelector, and durationSelector that throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const reversedValues = mapObject(values, reverseString);\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const expected = '     --v---w---x-y-----z-------|';\n      const v = cold('         a-b---(d#)               ', reversedValues);\n      const w = cold('             c-------g-(h#)       ', reversedValues);\n      const x = cold('                 e---------j-(k#) ', reversedValues);\n      const y = cold('                   f-------------|', reversedValues);\n      const z = cold('                         i-----l-|', reversedValues);\n      const expectedValues = { v: v, w: w, x: x, y: y, z: z };\n\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => reverseString(val),\n          (group: any) =>\n            group.pipe(\n              skip(2),\n              map(() => {\n                throw 'error';\n              })\n            )\n        )\n      );\n      expectObservable(source).toBe(expected, expectedValues);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a keySelector and a durationSelector, outer throws","suites":["groupBy operator"],"updatePoint":{"line":851,"column":75},"line":851,"code":"  it('should allow using a keySelector and a durationSelector, outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-#', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --v---w---x-y-----z-------#';\n      const v = cold('         a-b---(d|)               ', values);\n      const w = cold('             c-------g-(h|)       ', values);\n      const x = cold('                 e---------j-(k|) ', values);\n      const y = cold('                   f-------------#', values);\n      const z = cold('                         i-----l-#', values);\n      const expectedValues = { v: v, w: w, x: x, y: y, z: z };\n\n      const source = e1.pipe(\n        groupBy((val) => val.toLowerCase().trim(), {\n          duration: (group) => group.pipe(skip(2)),\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a durationSelector, and outer unsubscribed early","suites":["groupBy operator"],"updatePoint":{"line":888,"column":73},"line":888,"code":"  it('should allow using a durationSelector, and outer unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const unsub = '        -----------!               ';\n      const expected = '     --v---w---x-               ';\n      const v = cold('         a-b---(d|)               ', values);\n      const w = cold('             c-------g-(h|)       ', values);\n      const x = cold('                 e---------j-(k|) ', values);\n      const expectedValues = { v: v, w: w, x: x };\n\n      const source = e1.pipe(\n        groupBy((val) => val.toLowerCase().trim(), {\n          duration: (group) => group.pipe(skip(2)),\n        })\n      );\n\n      expectObservable(source, unsub).toBe(expected, expectedValues);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a durationSelector, outer and all inners unsubscribed early","suites":["groupBy operator"],"updatePoint":{"line":922,"column":84},"line":922,"code":"  it('should allow using a durationSelector, outer and all inners unsubscribed early', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const unsub = '        -----------!';\n      const expected = '     --v---w---x-';\n      const v = '            --a-b---(d|)';\n      const w = '            ------c-----';\n      const x = '            ----------e-';\n\n      const expectedGroups = {\n        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),\n        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),\n      };\n\n      const unsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsub, true).unsubscribedFrame;\n\n      const source = e1.pipe(\n        groupBy((val) => val.toLowerCase().trim(), {\n          duration: (group) => group.pipe(skip(2)),\n        }),\n        map((group) => {\n          const arr: any[] = [];\n\n          const subscription = group.pipe(phonyMarbelize(testScheduler)).subscribe((value) => {\n            arr.push(value);\n          });\n\n          testScheduler.schedule(() => {\n            subscription.unsubscribe();\n          }, unsubscriptionFrame - testScheduler.frame);\n          return arr;\n        })\n      );\n\n      expectObservable(source, unsub).toBe(expected, expectedGroups);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose a durationSelector after closing the group","suites":["groupBy operator"],"updatePoint":{"line":975,"column":63},"line":975,"code":"  it('should dispose a durationSelector after closing the group', () => {\n    testScheduler.run(({ cold, hot, expectSubscriptions }) => {\n      const obs = hot(' -0-1--------2-| ');\n      const sub = '     ^--------------!';\n      // prettier-ignore\n      const unsubs = [\n        '              -^--!',\n        '              ---^--!',\n        '              ------------^-!',\n      ];\n      const dur = '     ---s';\n      const durations = [cold(dur), cold(dur), cold(dur)];\n\n      const unsubscribedFrame = TestScheduler.parseMarblesAsSubscriptions(sub, true).unsubscribedFrame;\n\n      obs\n        .pipe(\n          groupBy((val) => val, {\n            duration: (group) => durations[Number(group.key)],\n          })\n        )\n        .subscribe();\n\n      testScheduler.schedule(() => {\n        durations.forEach((d, i) => {\n          expectSubscriptions(d.subscriptions).toBe(unsubs[i]);\n        });\n      }, unsubscribedFrame);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a durationSelector, but keySelector throws","suites":["groupBy operator"],"updatePoint":{"line":1006,"column":67},"line":1006,"code":"  it('should allow using a durationSelector, but keySelector throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------!      ';\n      const expected = '     --v---w---x-y-----z-#      ';\n      const v = cold('         a-b---(d|)               ', values);\n      const w = cold('             c-------g-(h|)       ', values);\n      const x = cold('                 e---------#      ', values);\n      const y = cold('                   f-------#      ', values);\n      const z = cold('                         i-#      ', values);\n      const expectedValues = { v: v, w: w, x: x, y: y, z: z };\n\n      let invoked = 0;\n      const source = e1.pipe(\n        groupBy(\n          (val: any) => {\n            invoked++;\n            if (invoked === 10) {\n              throw 'error';\n            }\n            return val.toLowerCase().trim();\n          },\n          (val: string) => val,\n          (group: any) => group.pipe(skip(2))\n        )\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a durationSelector, but elementSelector throws","suites":["groupBy operator"],"updatePoint":{"line":1052,"column":71},"line":1052,"code":"  it('should allow using a durationSelector, but elementSelector throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------!      ';\n      const expected = '     --v---w---x-y-----z-#      ';\n      const v = cold('         a-b---(d|)               ', values);\n      const w = cold('             c-------g-(h|)       ', values);\n      const x = cold('                 e---------#      ', values);\n      const y = cold('                   f-------#      ', values);\n      const z = cold('                         i-#      ', values);\n      const expectedValues = { v: v, w: w, x: x, y: y, z: z };\n\n      let invoked = 0;\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => {\n            invoked++;\n            if (invoked === 10) {\n              throw 'error';\n            }\n            return val;\n          },\n          (group: any) => group.pipe(skip(2))\n        )\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow using a durationSelector which eventually throws","suites":["groupBy operator"],"updatePoint":{"line":1098,"column":67},"line":1098,"code":"  it('should allow using a durationSelector which eventually throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-----------!              ';\n      const expected = '  --v---w---x-(y#)              ';\n      const v = cold('         a-b---(d|)               ', values);\n      const w = cold('             c-----#              ', values);\n      const x = cold('                 e-#              ', values);\n      const y = cold('                   #              ', values);\n      const expectedValues = { v: v, w: w, x: x, y: y };\n\n      let invoked = 0;\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => val,\n          (group: any) => {\n            invoked++;\n            if (invoked === 4) {\n              throw 'error';\n            }\n            return group.pipe(skip(2));\n          }\n        )\n      );\n\n      expectObservable(source).toBe(expected, expectedValues);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow an inner to be unsubscribed early but other inners continue, with durationSelector","suites":["groupBy operator"],"updatePoint":{"line":1143,"column":101},"line":1143,"code":"  it('should allow an inner to be unsubscribed early but other inners continue, with durationSelector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const reversedValues = mapObject(values, reverseString);\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --v---w---x-y-----z-------|';\n      const v = '            --a-b---                   ';\n      const unsubv = '       -------!                   ';\n      const w = '            ------c-------g-(h|)       ';\n      const x = '             ----------e---------j-(k|)';\n      const y = '            ------------f-------------|';\n      const z = '            ------------------i-----l-|';\n\n      const expectedGroups = {\n        v: TestScheduler.parseMarbles(v, reversedValues, undefined, undefined, true),\n        w: TestScheduler.parseMarbles(w, reversedValues, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, reversedValues, undefined, undefined, true),\n        y: TestScheduler.parseMarbles(y, reversedValues, undefined, undefined, true),\n        z: TestScheduler.parseMarbles(z, reversedValues, undefined, undefined, true),\n      };\n\n      const fooUnsubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(unsubv, true).unsubscribedFrame;\n\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => reverseString(val),\n          (group: any) => group.pipe(skip(2))\n        ),\n        map((group: any, index: number) => {\n          const arr: any[] = [];\n\n          const subscription = group.pipe(phonyMarbelize(testScheduler)).subscribe((value: any) => {\n            arr.push(value);\n          });\n\n          if (group.key === 'foo' && index === 0) {\n            testScheduler.schedule(() => {\n              subscription.unsubscribe();\n            }, fooUnsubscriptionFrame - testScheduler.frame);\n          }\n          return arr;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedGroups);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow inners to be unsubscribed early at different times, with durationSelector","suites":["groupBy operator"],"updatePoint":{"line":1207,"column":92},"line":1207,"code":"  it('should allow inners to be unsubscribed early at different times, with durationSelector', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|', values);\n      const e1subs = '       ^-------------------------!';\n      const expected = '     --v---w---x-y-----z-------|';\n      const v = '            --a-b---                   ';\n      const unsubv = '       -------!                   ';\n      const w = '            ------c---                 ';\n      const unsubw = '       ---------!                 ';\n      const x = '            ----------e---------j-     ';\n      const unsubx = '       ---------------------!     ';\n      const y = '            ------------f----          ';\n      const unsuby = '       ----------------!          ';\n      const z = '            ------------------i----    ';\n      const unsubz = '       ----------------------!    ';\n\n      const expectedGroups = {\n        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),\n        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),\n        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),\n        z: TestScheduler.parseMarbles(z, values, undefined, undefined, true),\n      };\n\n      const unsubscriptionFrames: Record<string, number> = {\n        foo: TestScheduler.parseMarblesAsSubscriptions(unsubv, true).unsubscribedFrame,\n        bar: TestScheduler.parseMarblesAsSubscriptions(unsubw, true).unsubscribedFrame,\n        baz: TestScheduler.parseMarblesAsSubscriptions(unsubx, true).unsubscribedFrame,\n        qux: TestScheduler.parseMarblesAsSubscriptions(unsuby, true).unsubscribedFrame,\n        foo2: TestScheduler.parseMarblesAsSubscriptions(unsubz, true).unsubscribedFrame,\n      };\n      const hasUnsubscribed: Record<string, boolean> = {};\n\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => val,\n          (group: any) => group.pipe(skip(2))\n        ),\n        map((group: any) => {\n          const arr: any[] = [];\n\n          const subscription = group.pipe(phonyMarbelize(testScheduler)).subscribe((value: any) => {\n            arr.push(value);\n          });\n\n          const unsubscriptionFrame = hasUnsubscribed[group.key] ? unsubscriptionFrames[group.key + '2'] : unsubscriptionFrames[group.key];\n          testScheduler.schedule(() => {\n            subscription.unsubscribe();\n            hasUnsubscribed[group.key] = true;\n          }, unsubscriptionFrame - testScheduler.frame);\n          return arr;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedGroups);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should return inners that when subscribed late exhibit hot behavior","suites":["groupBy operator"],"updatePoint":{"line":1281,"column":73},"line":1281,"code":"  it('should return inners that when subscribed late exhibit hot behavior', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        c: 'baR  ',\n        d: 'foO ',\n        e: ' Baz   ',\n        f: '  qux ',\n        g: '   bar',\n        h: ' BAR  ',\n        i: 'FOO ',\n        j: 'baz  ',\n        k: ' bAZ ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b-c-d-e-f-g-h-i-j-k-l-|    ', values);\n      const e1subs = '       ^-------------------------!    ';\n      const expected = '     --v---w---x-y-------------|    ';\n      const subv = '         ---^                           '; // foo\n      const v = '            ----b---d---------i-----l-|    '; // foo\n      const subw = '         ---------^                     '; // bar\n      const w = '            --------------g-h---------|    '; // bar\n      const subx = '         -------------------^           '; // baz\n      const x = '            --------------------j-k---|    '; // baz\n      const suby = '         ------------------------------^'; // qux\n      const y = '            ------------------------------|'; // qux\n\n      const expectedGroups = {\n        v: TestScheduler.parseMarbles(v, values, undefined, undefined, true),\n        w: TestScheduler.parseMarbles(w, values, undefined, undefined, true),\n        x: TestScheduler.parseMarbles(x, values, undefined, undefined, true),\n        y: TestScheduler.parseMarbles(y, values, undefined, undefined, true),\n      };\n\n      const subscriptionFrames: Record<string, number> = {\n        foo: TestScheduler.parseMarblesAsSubscriptions(subv, true).subscribedFrame,\n        bar: TestScheduler.parseMarblesAsSubscriptions(subw, true).subscribedFrame,\n        baz: TestScheduler.parseMarblesAsSubscriptions(subx, true).subscribedFrame,\n        qux: TestScheduler.parseMarblesAsSubscriptions(suby, true).subscribedFrame,\n      };\n\n      const result = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => val\n        ),\n        map((group: any) => {\n          const innerNotifications: any[] = [];\n          const subscriptionFrame = subscriptionFrames[group.key];\n\n          testScheduler.schedule(() => {\n            group.pipe(phonyMarbelize(testScheduler)).subscribe((value: any) => {\n              innerNotifications.push(value);\n            });\n          }, subscriptionFrame - testScheduler.frame);\n\n          return innerNotifications;\n        })\n      );\n\n      expectObservable(result).toBe(expected, expectedGroups);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should return inner group that when subscribed late emits complete()","suites":["groupBy operator"],"updatePoint":{"line":1347,"column":74},"line":1347,"code":"  it('should return inner group that when subscribed late emits complete()', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = {\n        a: '  foo',\n        b: ' FoO ',\n        d: 'foO ',\n        i: 'FOO ',\n        l: '    fOo    ',\n      };\n      const e1 = hot('-1--2--^-a-b---d---------i-----l-|      ', values);\n      const e1subs = '       ^-------------------------!      ';\n      const expected = '     --g-----------------------|      ';\n      const innerSub = '     --------------------------------^';\n      const g = '            --------------------------------|';\n\n      const expectedGroups = {\n        g: TestScheduler.parseMarbles(g, values, undefined, undefined, true),\n      };\n\n      const innerSubscriptionFrame = TestScheduler.parseMarblesAsSubscriptions(innerSub, true).subscribedFrame;\n\n      const source = e1.pipe(\n        groupBy(\n          (val: string) => val.toLowerCase().trim(),\n          (val: string) => val,\n          (group: any) => group.pipe(skip(7))\n        ),\n        map((group: any) => {\n          const arr: any[] = [];\n\n          testScheduler.schedule(() => {\n            group.pipe(phonyMarbelize(testScheduler)).subscribe((value: any) => {\n              arr.push(value);\n            });\n          }, innerSubscriptionFrame - testScheduler.frame);\n\n          return arr;\n        })\n      );\n\n      expectObservable(source).toBe(expected, expectedGroups);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should return inner group that when subscribed late emits error()","suites":["groupBy operator"],"line":1392,"code":"  it.skip('should return inner group that when subscribed late emits error()', () => {","file":"operators/groupBy-spec.ts","skipped":true,"dir":"spec"},{"name":"should not error for late subscribed inners if outer is unsubscribed before inners are subscribed","suites":["groupBy operator"],"updatePoint":{"line":1437,"column":103},"line":1437,"code":"  it('should not error for late subscribed inners if outer is unsubscribed before inners are subscribed', () => {\n    testScheduler.run(({ hot, expectObservable }) => {\n      const source = hot('-----^----a----b-----a------b----a----b---#');\n      // Unsubscribe before the error happens.\n      const unsub = '          -------------------!                  ';\n      // Used to hold two subjects we're going to use to subscribe to our groups\n      const subjects: Record<string, Subject<string>> = {\n        a: new Subject(),\n        b: new Subject(),\n      };\n      const result = source.pipe(\n        groupBy((char) => char),\n        tap({\n          // The real test is here, schedule each group to be subscribed to\n          // long after the source errors and long after the unsubscription happens.\n          next: (group) => {\n            testScheduler.schedule(() => group.subscribe(subjects[group.key]), 1000);\n          },\n        }),\n        // We don't are about what the outer is emitting\n        ignoreElements()\n      );\n      // Just to get the test going.\n      expectObservable(result, unsub).toBe('-');\n      // Our two groups should error immediately upon subscription.\n      expectObservable(subjects.a).toBe('-');\n      expectObservable(subjects.b).toBe('-');\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break lift() composability","suites":["groupBy operator"],"updatePoint":{"line":1467,"column":43},"line":1467,"code":"  it('should not break lift() composability', (done) => {\n    class MyCustomObservable<T> extends Observable<T> {\n      lift<R>(operator: Operator<T, R>): Observable<R> {\n        const observable = new MyCustomObservable<R>();\n        (<any>observable).source = this;\n        (<any>observable).operator = operator;\n        return observable;\n      }\n    }\n\n    const result = new MyCustomObservable((observer: Observer<number>) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(\n      groupBy(\n        (x: number) => x % 2,\n        (x: number) => x + '!'\n      )\n    );\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expectedGroups = [\n      { key: 1, values: ['1!', '3!'] },\n      { key: 0, values: ['2!'] },\n    ];\n\n    result.subscribe({\n      next: (g: any) => {\n        const expectedGroup = expectedGroups.shift()!;\n        expect(g.key).to.equal(expectedGroup.key);\n\n        g.subscribe((x: any) => {\n          expect(x).to.deep.equal(expectedGroup.values.shift());\n        });\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        done();\n      },\n    });\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["groupBy operator"],"updatePoint":{"line":1514,"column":73},"line":1514,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        groupBy((value) => value),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/groupBy-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore all the elements of the source","suites":["ignoreElements"],"updatePoint":{"line":15,"column":50},"line":15,"code":"  it('should ignore all the elements of the source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^-------------!';\n      const expected = '--------------|';\n\n      expectObservable(e1.pipe(ignoreElements())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["ignoreElements"],"updatePoint":{"line":26,"column":53},"line":26,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^------!       ';\n      const expected = '--------       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(ignoreElements());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly with higher order","suites":["ignoreElements"],"updatePoint":{"line":40,"column":71},"line":40,"code":"  it('should allow unsubscribing early and explicitly with higher order', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^------!       ';\n      const expected = '--------       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        ignoreElements(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from the source","suites":["ignoreElements"],"updatePoint":{"line":58,"column":45},"line":58,"code":"  it('should propagate errors from the source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--#');\n      const e1subs = '  ^----!';\n      const expected = '-----#';\n\n      expectObservable(e1.pipe(ignoreElements())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["ignoreElements"],"updatePoint":{"line":69,"column":25},"line":69,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(ignoreElements())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["ignoreElements"],"updatePoint":{"line":80,"column":25},"line":80,"code":"  it('should handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(ignoreElements())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["ignoreElements"],"updatePoint":{"line":91,"column":25},"line":91,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('  #  ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(ignoreElements())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/ignoreElements-spec.ts","skipped":false,"dir":"spec"},{"name":"should export operators","suites":["operators/index"],"updatePoint":{"line":5,"column":29},"line":5,"code":"  it('should export operators', () => {\n    expect(index.audit).to.exist;\n    expect(index.auditTime).to.exist;\n    expect(index.buffer).to.exist;\n    expect(index.bufferCount).to.exist;\n    expect(index.bufferTime).to.exist;\n    expect(index.bufferToggle).to.exist;\n    expect(index.bufferWhen).to.exist;\n    expect(index.catchError).to.exist;\n    expect(index.combineAll).to.exist;\n    expect(index.combineLatestAll).to.exist;\n    expect(index.concatAll).to.exist;\n    expect(index.concatMap).to.exist;\n    expect(index.concatMapTo).to.exist;\n    expect(index.count).to.exist;\n    expect(index.debounce).to.exist;\n    expect(index.debounceTime).to.exist;\n    expect(index.defaultIfEmpty).to.exist;\n    expect(index.delay).to.exist;\n    expect(index.delayWhen).to.exist;\n    expect(index.dematerialize).to.exist;\n    expect(index.distinct).to.exist;\n    expect(index.distinctUntilChanged).to.exist;\n    expect(index.distinctUntilKeyChanged).to.exist;\n    expect(index.elementAt).to.exist;\n    expect(index.every).to.exist;\n    expect(index.exhaust).to.exist;\n    expect(index.exhaustAll).to.exist;\n    expect(index.exhaustMap).to.exist;\n    expect(index.expand).to.exist;\n    expect(index.filter).to.exist;\n    expect(index.finalize).to.exist;\n    expect(index.find).to.exist;\n    expect(index.findIndex).to.exist;\n    expect(index.first).to.exist;\n    expect(index.groupBy).to.exist;\n    expect(index.ignoreElements).to.exist;\n    expect(index.isEmpty).to.exist;\n    expect(index.last).to.exist;\n    expect(index.map).to.exist;\n    expect(index.mapTo).to.exist;\n    expect(index.materialize).to.exist;\n    expect(index.max).to.exist;\n    expect(index.mergeAll).to.exist;\n    expect(index.mergeMap).to.exist;\n    expect(index.flatMap).to.exist;\n    expect(index.mergeMap).to.exist;\n    expect(index.mergeMapTo).to.exist;\n    expect(index.mergeScan).to.exist;\n    expect(index.min).to.exist;\n    expect(index.multicast).to.exist;\n    expect(index.observeOn).to.exist;\n    expect(index.pairwise).to.exist;\n    expect(index.partition).to.exist;\n    expect(index.pluck).to.exist;\n    expect(index.publish).to.exist;\n    expect(index.publishBehavior).to.exist;\n    expect(index.publishLast).to.exist;\n    expect(index.publishReplay).to.exist;\n    expect(index.reduce).to.exist;\n    expect(index.repeat).to.exist;\n    expect(index.repeatWhen).to.exist;\n    expect(index.retry).to.exist;\n    expect(index.retryWhen).to.exist;\n    expect(index.refCount).to.exist;\n    expect(index.sample).to.exist;\n    expect(index.sampleTime).to.exist;\n    expect(index.scan).to.exist;\n    expect(index.sequenceEqual).to.exist;\n    expect(index.share).to.exist;\n    expect(index.shareReplay).to.exist;\n    expect(index.single).to.exist;\n    expect(index.skip).to.exist;\n    expect(index.skipLast).to.exist;\n    expect(index.skipUntil).to.exist;\n    expect(index.skipWhile).to.exist;\n    expect(index.startWith).to.exist;\n    expect(index.switchAll).to.exist;\n    expect(index.switchScan).to.exist;\n    expect(index.switchMap).to.exist;\n    expect(index.switchMapTo).to.exist;\n    expect(index.take).to.exist;\n    expect(index.takeLast).to.exist;\n    expect(index.takeUntil).to.exist;\n    expect(index.takeWhile).to.exist;\n    expect(index.tap).to.exist;\n    expect(index.throttle).to.exist;\n    expect(index.throttleTime).to.exist;\n    expect(index.timeInterval).to.exist;\n    expect(index.timeout).to.exist;\n    expect(index.timeoutWith).to.exist;\n    expect(index.timestamp).to.exist;\n    expect(index.toArray).to.exist;\n    expect(index.window).to.exist;\n    expect(index.windowCount).to.exist;\n    expect(index.windowTime).to.exist;\n    expect(index.windowToggle).to.exist;\n    expect(index.windowWhen).to.exist;\n    expect(index.withLatestFrom).to.exist;\n    expect(index.zipAll).to.exist;\n  });","file":"operators/index-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true if source is empty","suites":["isEmpty"],"updatePoint":{"line":15,"column":43},"line":15,"code":"  it('should return true if source is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|   ');\n      const e1subs = '  ^----!   ';\n      const expected = '-----(T|)';\n\n      expectObservable(e1.pipe(isEmpty())).toBe(expected, { T: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false if source emits element","suites":["isEmpty"],"updatePoint":{"line":26,"column":49},"line":26,"code":"  it('should return false if source emits element', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--|');\n      const e1subs = '     ^--!   ';\n      const expected = '   ---(F|)';\n\n      expectObservable(e1.pipe(isEmpty())).toBe(expected, { F: false });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["isEmpty"],"updatePoint":{"line":37,"column":47},"line":37,"code":"  it('should raise error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --#');\n      const e1subs = '  ^-!';\n      const expected = '--#';\n\n      expectObservable(e1.pipe(isEmpty())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never emits","suites":["isEmpty"],"updatePoint":{"line":48,"column":47},"line":48,"code":"  it('should not complete if source never emits', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(isEmpty())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true if source is empty","suites":["isEmpty"],"updatePoint":{"line":59,"column":43},"line":59,"code":"  it('should return true if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(T|)';\n\n      expectObservable(e1.pipe(isEmpty())).toBe(expected, { T: true });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["isEmpty"],"updatePoint":{"line":70,"column":53},"line":70,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -----------a--b--|');\n      const e1subs = '  ^-----!           ';\n      const expected = '-------           ';\n      const unsub = '   ------!           ';\n\n      expectObservable(e1.pipe(isEmpty()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["isEmpty"],"updatePoint":{"line":82,"column":83},"line":82,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -----------a--b--|');\n      const e1subs = '  ^-----!           ';\n      const expected = '-------           ';\n      const unsub = '   ------!           ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        isEmpty(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/isEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should take the last value of an observable","suites":["last"],"updatePoint":{"line":15,"column":49},"line":15,"code":"  it('should take the last value of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a----b--c--|   ');\n      const e1subs = '  ^------------!   ';\n      const expected = '-------------(c|)';\n\n      expectObservable(e1.pipe(last())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on nothing sent but completed","suites":["last"],"updatePoint":{"line":26,"column":48},"line":26,"code":"  it('should error on nothing sent but completed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^----|');\n      const e1subs = '     ^----!';\n      const expected = '   -----#';\n\n      expectObservable(e1.pipe(last())).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on empty","suites":["last"],"updatePoint":{"line":37,"column":27},"line":37,"code":"  it('should error on empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(last())).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should go on forever on never","suites":["last"],"updatePoint":{"line":48,"column":35},"line":48,"code":"  it('should go on forever on never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(last())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow undefined as a default value","suites":["last"],"updatePoint":{"line":59,"column":47},"line":59,"code":"  it('should allow undefined as a default value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--a---a-|   ');\n      const e1subs = '  ^-------------!   ';\n      const expected = '--------------(U|)';\n\n      expectObservable(e1.pipe(last((value) => value === 'b', undefined))).toBe(expected, { U: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should return last element matches with predicate","suites":["last"],"updatePoint":{"line":70,"column":55},"line":70,"code":"  it('should return last element matches with predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--|   ');\n      const e1subs = '  ^-------------!   ';\n      const expected = '--------------(b|)';\n\n      expectObservable(e1.pipe(last((value) => value === 'b'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["last"],"updatePoint":{"line":81,"column":53},"line":81,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^------!       ';\n      const expected = '--------       ';\n      const unsub = '   -------!       ';\n\n      expectObservable(e1.pipe(last()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["last"],"updatePoint":{"line":93,"column":83},"line":93,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^------!       ';\n      const expected = '--------       ';\n      const unsub = '   -------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        last(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a default value if no element found","suites":["last"],"updatePoint":{"line":111,"column":55},"line":111,"code":"  it('should return a default value if no element found', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(a|)';\n\n      expectObservable(e1.pipe(last(null, 'a'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should not return default value if an element is found","suites":["last"],"updatePoint":{"line":122,"column":60},"line":122,"code":"  it('should not return default value if an element is found', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a---^---b---c---d---|   ');\n      const e1subs = '      ^---------------!   ';\n      const expected = '    ----------------(d|)';\n\n      expectObservable(e1.pipe(last(null, 'x'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when predicate throws","suites":["last"],"updatePoint":{"line":133,"column":46},"line":133,"code":"  it('should raise error when predicate throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^---b---c---d---e--|');\n      const e1subs = '     ^-------!           ';\n      const expected = '   --------#           ';\n\n      const predicate = function (x: string) {\n        if (x === 'c') {\n          throw 'error';\n        } else {\n          return false;\n        }\n      };\n\n      expectObservable(e1.pipe(last(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should support type guards without breaking previous behavior","suites":["last"],"updatePoint":{"line":152,"column":67},"line":152,"code":"  it('should support type guards without breaking previous behavior', () => {\n    // tslint:disable no-unused-variable\n\n    // type guards with interfaces and classes\n    {\n      interface Bar {\n        bar?: string;\n      }\n      interface Baz {\n        baz?: number;\n      }\n      class Foo implements Bar, Baz {\n        constructor(public bar: string = 'name', public baz: number = 42) {}\n      }\n\n      const isBar = (x: any): x is Bar => x && (x as Bar).bar !== undefined;\n      const isBaz = (x: any): x is Baz => x && (x as Baz).baz !== undefined;\n\n      const foo: Foo = new Foo();\n      of(foo)\n        .pipe(last())\n        .subscribe((x) => x.baz); // x is Foo\n      of(foo)\n        .pipe(last((foo) => foo.bar === 'name'))\n        .subscribe((x) => x.baz); // x is still Foo\n      of(foo)\n        .pipe(last(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n\n      const foobar: Bar = new Foo(); // type is the interface, not the class\n      of(foobar)\n        .pipe(last())\n        .subscribe((x) => x.bar); // x is Bar\n      of(foobar)\n        .pipe(last((foobar) => foobar.bar === 'name'))\n        .subscribe((x) => x.bar); // x is still Bar\n      of(foobar)\n        .pipe(last(isBaz))\n        .subscribe((x) => x.baz); // x is Baz!\n\n      const barish = { bar: 'quack', baz: 42 }; // type can quack like a Bar\n      of(barish)\n        .pipe(last())\n        .subscribe((x) => x.baz); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(last((x) => x.bar === 'quack'))\n        .subscribe((x) => x.bar); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(last(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n    }\n\n    // type guards with primitive types\n    {\n      const xs: Observable<string | number> = from([1, 'aaa', 3, 'bb']);\n\n      // This type guard will narrow a `string | number` to a string in the examples below\n      const isString = (x: string | number): x is string => typeof x === 'string';\n\n      // missing predicate preserves the type\n      xs.pipe(last()).subscribe((x) => x); // x is still string | number\n\n      // null predicate preserves the type\n      xs.pipe(last(null)).subscribe((x) => x); // x is still string | number\n\n      // undefined predicate preserves the type\n      xs.pipe(last(undefined)).subscribe((x) => x); // x is still string | number\n\n      // After the type guard `last` predicates, the type is narrowed to string\n      xs.pipe(last(isString)).subscribe((s) => s.length); // s is string\n\n      // boolean predicates preserve the type\n      xs.pipe(last((x) => typeof x === 'string')).subscribe((x) => x); // x is still string | number\n    }\n\n    // tslint:disable enable\n  });","file":"operators/last-spec.ts","skipped":false,"dir":"spec"},{"name":"should map multiple values","suites":["map"],"updatePoint":{"line":19,"column":32},"line":19,"code":"  it('should map multiple values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^----------!';\n      const expected = '--x--y--z--|';\n\n      const result = e1.pipe(map((x) => 10 * +x));\n\n      expectObservable(result).toBe(expected, { x: 10, y: 20, z: 30 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map one value","suites":["map"],"updatePoint":{"line":32,"column":26},"line":32,"code":"  it('should map one value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const values = { x: 42 };\n      const e1 = cold(' --x--|', values);\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      const result = e1.pipe(map(addDrama));\n\n      expectObservable(result).toBe(expected, { y: '42!' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map multiple values","suites":["map"],"updatePoint":{"line":46,"column":32},"line":46,"code":"  it('should map multiple values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^----------!';\n      const expected = '--x--y--z--|';\n\n      const result = e1.pipe(map(addDrama));\n\n      expectObservable(result).toBe(expected, { x: '1!', y: '2!', z: '3!' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from map function","suites":["map"],"updatePoint":{"line":59,"column":47},"line":59,"code":"  it('should propagate errors from map function', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const values = { x: 42 };\n      const e1 = cold(' --x--|', values);\n      const e1subs = '  ^-!   ';\n      const expected = '--#   ';\n\n      const result = e1.pipe(\n        map((x: any) => {\n          throw 'too bad';\n        })\n      );\n\n      expectObservable(result).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emits only errors","suites":["map"],"updatePoint":{"line":77,"column":68},"line":77,"code":"  it('should propagate errors from observable that emits only errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(map(identity));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emit values","suites":["map"],"updatePoint":{"line":90,"column":62},"line":90,"code":"  it('should propagate errors from observable that emit values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 2 };\n      const e1 = cold(' --a--b--#', values, 'too bad');\n      const e1subs = '  ^-------!';\n      const expected = '--x--y--#';\n\n      const result = e1.pipe(map(addDrama));\n\n      expectObservable(result).toBe(expected, { x: '1!', y: '2!' }, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should not map an empty observable","suites":["map"],"updatePoint":{"line":104,"column":40},"line":104,"code":"  it('should not map an empty observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      let invoked = 0;\n      const result = e1.pipe(\n        map((x: any) => {\n          invoked++;\n          return x;\n        }),\n        tap({\n          complete() {\n            expect(invoked).to.equal(0);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["map"],"updatePoint":{"line":128,"column":53},"line":128,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--x--y-     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(map(addDrama));\n\n      expectObservable(result, unsub).toBe(expected, { x: '1!', y: '2!' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map with index","suites":["map"],"updatePoint":{"line":142,"column":27},"line":142,"code":"  it('should map with index', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-5-^-4--3---2----1--|');\n      const e1subs = '   ^----------------!';\n      const expected = ' --a--b---c----d--|';\n      const values = { a: 5, b: 14, c: 23, d: 32 };\n\n      let invoked = 0;\n      const result = e1.pipe(\n        map((x: string, index: number) => {\n          invoked++;\n          return parseInt(x) + 1 + index * 10;\n        }),\n        tap({\n          complete() {\n            expect(invoked).to.equal(4);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map with index until completed","suites":["map"],"updatePoint":{"line":167,"column":43},"line":167,"code":"  it('should map with index until completed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-5-^-4--3---2----1--|');\n      const e1subs = '   ^----------------!';\n      const expected = ' --a--b---c----d--|';\n      const values = { a: 5, b: 14, c: 23, d: 32 };\n\n      let invoked = 0;\n      const result = e1.pipe(\n        map((x: string, index: number) => {\n          invoked++;\n          return parseInt(x) + 1 + index * 10;\n        }),\n        tap({\n          complete() {\n            expect(invoked).to.equal(4);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map with index until an error occurs","suites":["map"],"updatePoint":{"line":192,"column":49},"line":192,"code":"  it('should map with index until an error occurs', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-5-^-4--3---2----1--#', undefined, 'too bad');\n      const e1subs = '   ^----------------!';\n      const expected = ' --a--b---c----d--#';\n      const values = { a: 5, b: 14, c: 23, d: 32 };\n\n      let invoked = 0;\n      const result = e1.pipe(\n        map((x: string, index: number) => {\n          invoked++;\n          return parseInt(x) + 1 + index * 10;\n        }),\n        tap({\n          error() {\n            expect(invoked).to.equal(4);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected, values, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map using a custom thisArg","suites":["map"],"updatePoint":{"line":217,"column":39},"line":217,"code":"  it('should map using a custom thisArg', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-5-^-4--3---2----1--|');\n      const e1subs = '   ^----------------!';\n      const expected = ' --a--b---c----d--|';\n      const values = { a: 46, b: 55, c: 64, d: 73 };\n\n      const foo = {\n        value: 42,\n      };\n      const result = e1.pipe(\n        map(function (this: typeof foo, x: string, index: number) {\n          expect(this).to.equal(foo);\n          return parseInt(x) + foo.value + index * 10;\n        }, foo)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map twice","suites":["map"],"updatePoint":{"line":239,"column":22},"line":239,"code":"  it('should map twice', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-0----1-^-2---3--4-5--6--7-8-|');\n      const e1subs = '        ^--------------------!';\n      const expected = '      --a---b--c-d--e--f-g-|';\n      const values = { a: 2, b: 3, c: 4, d: 5, e: 6, f: 7, g: 8 };\n\n      let invoked1 = 0;\n      let invoked2 = 0;\n      const result = e1.pipe(\n        map((x: string) => {\n          invoked1++;\n          return parseInt(x) * 2;\n        }),\n        map((x: number) => {\n          invoked2++;\n          return x / 2;\n        }),\n        tap({\n          complete() {\n            expect(invoked1).to.equal(7);\n            expect(invoked2).to.equal(7);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should do multiple maps using a custom thisArg","suites":["map"],"updatePoint":{"line":270,"column":52},"line":270,"code":"  it('should do multiple maps using a custom thisArg', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1--2--3--4--|');\n      const e1subs = '  ^-------------!';\n      const expected = '--a--b--c--d--|';\n      const values = { a: 11, b: 14, c: 17, d: 20 };\n\n      class Filterer {\n        selector1 = (x: string) => parseInt(x) + 2;\n        selector2 = (x: string) => parseInt(x) * 3;\n      }\n      const filterer = new Filterer();\n\n      const result = e1.pipe(\n        map(function (this: any, x) {\n          return this.selector1(x);\n        }, filterer),\n        map(function (this: any, x) {\n          return this.selector2(x);\n        }, filterer),\n        map(function (this: any, x) {\n          return this.selector1(x);\n        }, filterer)\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["map"],"updatePoint":{"line":300,"column":72},"line":300,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--x--y-     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        map(addDrama),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, { x: '1!', y: '2!' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["map"],"updatePoint":{"line":318,"column":73},"line":318,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(map(identity), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/map-spec.ts","skipped":false,"dir":"spec"},{"name":"should map multiple values","suites":["mapTo"],"updatePoint":{"line":16,"column":32},"line":16,"code":"  it('should map multiple values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^----------!';\n      const expected = '--a--a--a--|';\n\n      expectObservable(e1.pipe(mapTo('a'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map one value","suites":["mapTo"],"updatePoint":{"line":27,"column":26},"line":27,"code":"  it('should map one value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --7--|');\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      expectObservable(e1.pipe(mapTo('y'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["mapTo"],"updatePoint":{"line":38,"column":53},"line":38,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--x--x-     ';\n      const unsub = '   ------!     ';\n\n      expectObservable(e1.pipe(mapTo('x')), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emits only errors","suites":["mapTo"],"updatePoint":{"line":50,"column":68},"line":50,"code":"  it('should propagate errors from observable that emits only errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --#', undefined, 'too bad');\n      const e1subs = '  ^-!';\n      const expected = '--#';\n\n      expectObservable(e1.pipe(mapTo(1))).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emit values, then errors","suites":["mapTo"],"updatePoint":{"line":61,"column":75},"line":61,"code":"  it('should propagate errors from observable that emit values, then errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--#', undefined, 'too bad');\n      const e1subs = '  ^-------!';\n      const expected = '--x--x--#';\n\n      expectObservable(e1.pipe(mapTo('x'))).toBe(expected, undefined, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should not map an empty observable","suites":["mapTo"],"updatePoint":{"line":72,"column":40},"line":72,"code":"  it('should not map an empty observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(mapTo(-1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map twice","suites":["mapTo"],"updatePoint":{"line":83,"column":22},"line":83,"code":"  it('should map twice', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-0----1-^-2---3--4-5--6--7-8-|');\n      const e1subs = '        ^--------------------!';\n      const expected = '      --h---h--h-h--h--h-h-|';\n\n      // prettier-ignore\n      const result = e1.pipe(\n        mapTo(-1),\n        mapTo('h')\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["mapTo"],"updatePoint":{"line":100,"column":72},"line":100,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--x--x-     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        mapTo('x'),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mapTo"],"updatePoint":{"line":118,"column":73},"line":118,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(mapTo(0), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize an Observable","suites":["materialize"],"updatePoint":{"line":16,"column":38},"line":16,"code":"  it('should materialize an Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --x--y--z--|   ');\n      const e1subs = '  ^----------!   ';\n      const expected = '--a--b--c--(d|)';\n      const values = { a: '{x}', b: '{y}', c: '{z}', d: '|' };\n\n      const result = e1.pipe(\n        materialize(),\n        map((x: Notification<string>) => {\n          if (x.kind === 'C') {\n            return '|';\n          } else {\n            return '{' + x.value + '}';\n          }\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize a happy stream","suites":["materialize"],"updatePoint":{"line":39,"column":39},"line":39,"code":"  it('should materialize a happy stream', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|   ');\n      const e1subs = '  ^----------!   ';\n      const expected = '--w--x--y--(z|)';\n\n      const expectedValue = {\n        w: Notification.createNext('a'),\n        x: Notification.createNext('b'),\n        y: Notification.createNext('c'),\n        z: Notification.createComplete(),\n      };\n\n      expectObservable(e1.pipe(materialize())).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize a sad stream","suites":["materialize"],"updatePoint":{"line":57,"column":37},"line":57,"code":"  it('should materialize a sad stream', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--#   ');\n      const e1subs = '  ^----------!   ';\n      const expected = '--w--x--y--(z|)';\n\n      const expectedValue = {\n        w: Notification.createNext('a'),\n        x: Notification.createNext('b'),\n        y: Notification.createNext('c'),\n        z: Notification.createError('error'),\n      };\n\n      expectObservable(e1.pipe(materialize())).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["materialize"],"updatePoint":{"line":75,"column":53},"line":75,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--w--x-     ';\n      const unsub = '   ------!     ';\n\n      const expectedValue = {\n        w: Notification.createNext('a'),\n        x: Notification.createNext('b'),\n      };\n\n      expectObservable(e1.pipe(materialize()), unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["materialize"],"updatePoint":{"line":92,"column":83},"line":92,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^-----!     ';\n      const expected = '--w--x-     ';\n      const unsub = '   ------!     ';\n\n      const expectedValue = {\n        w: Notification.createNext('a'),\n        x: Notification.createNext('b'),\n      };\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        materialize(),\n        mergeMap((x: Notification<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize stream that does not complete","suites":["materialize"],"updatePoint":{"line":115,"column":54},"line":115,"code":"  it('should materialize stream that does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(materialize())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize stream that does not emit","suites":["materialize"],"updatePoint":{"line":126,"column":50},"line":126,"code":"  it('should materialize stream that does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----|   ');\n      const e1subs = '  ^---!   ';\n      const expected = '----(x|)';\n\n      expectObservable(e1.pipe(materialize())).toBe(expected, { x: Notification.createComplete() });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize empty stream","suites":["materialize"],"updatePoint":{"line":137,"column":37},"line":137,"code":"  it('should materialize empty stream', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(materialize())).toBe(expected, { x: Notification.createComplete() });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should materialize stream that throws","suites":["materialize"],"updatePoint":{"line":148,"column":43},"line":148,"code":"  it('should materialize stream that throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      expectObservable(e1.pipe(materialize())).toBe(expected, { x: Notification.createError('error') });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["materialize"],"updatePoint":{"line":159,"column":73},"line":159,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(materialize(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/materialize-spec.ts","skipped":false,"dir":"spec"},{"name":"should find the max of values of an observable","suites":["max"],"updatePoint":{"line":16,"column":52},"line":16,"code":"  it('should find the max of values of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|   ', { a: 42, b: -1, c: 3 });\n      const e1subs = '  ^----------!   ';\n      const expected = '-----------(x|)';\n\n      expectObservable(e1.pipe(max())).toBe(expected, { x: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source is never","suites":["max"],"updatePoint":{"line":27,"column":42},"line":27,"code":"  it('should be never when source is never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(max())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should be zero when source is empty","suites":["max"],"updatePoint":{"line":38,"column":41},"line":38,"code":"  it('should be zero when source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(max())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source doesn't complete","suites":["max"],"updatePoint":{"line":49,"column":50},"line":49,"code":"  it(\"should be never when source doesn't complete\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--x--^--y--');\n      const e1subs = '     ^-----';\n      const expected = '   ------';\n\n      expectObservable(e1.pipe(max())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source doesn't have values","suites":["max"],"updatePoint":{"line":60,"column":53},"line":60,"code":"  it(\"should complete when source doesn't have values\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----|';\n\n      expectObservable(e1.pipe(max())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should max the unique value of an observable","suites":["max"],"updatePoint":{"line":71,"column":50},"line":71,"code":"  it('should max the unique value of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--|   ', { y: 42 });\n      const e1subs = '   ^-----!   ';\n      const expected = ' ------(w|)';\n\n      expectObservable(e1.pipe(max())).toBe(expected, { w: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should max the values of an ongoing hot observable","suites":["max"],"updatePoint":{"line":82,"column":56},"line":82,"code":"  it('should max the values of an ongoing hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--|   ', { a: 42, b: -1, c: 0, d: 6 });\n      const e1subs = '    ^----------!   ';\n      const expected = '  -----------(x|)';\n\n      expectObservable(e1.pipe(max())).toBe(expected, { x: 6 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["max"],"updatePoint":{"line":93,"column":53},"line":93,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|', { a: 42, b: -1, c: 0 });\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      expectObservable(e1.pipe(max()), unsub).toBe(expected, { x: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["max"],"updatePoint":{"line":105,"column":83},"line":105,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|', { a: 42, b: -1, c: 0 });\n      const e1subs = '  ^-----!     ';\n      const expected = '-------     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x: number) => of(x)),\n        max(),\n        mergeMap((x: number) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, { x: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should max a range() source observable","suites":["max"],"updatePoint":{"line":123,"column":44},"line":123,"code":"  it('should max a range() source observable', (done) => {\n    range(1, 10000)\n      .pipe(max())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(10000);\n        },\n        error: () => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should max a range().pipe(skip(1)) source observable","suites":["max"],"updatePoint":{"line":139,"column":58},"line":139,"code":"  it('should max a range().pipe(skip(1)) source observable', (done) => {\n    range(1, 10)\n      .pipe(skip(1), max())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(10);\n        },\n        error: () => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should max a range().pipe(take(1)) source observable","suites":["max"],"updatePoint":{"line":155,"column":58},"line":155,"code":"  it('should max a range().pipe(take(1)) source observable', (done) => {\n    range(1, 10)\n      .pipe(take(1), max())\n      .subscribe({\n        next: (value: number) => {\n          expect(value).to.equal(1);\n        },\n        error: () => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          done();\n        },\n      });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["max"],"updatePoint":{"line":171,"column":28},"line":171,"code":"  it('should work with error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--z--#', { x: 1, y: 2, z: 3 }, 'too bad');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable(e1.pipe(max())).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["max"],"updatePoint":{"line":182,"column":28},"line":182,"code":"  it('should work with throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(max())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on an empty hot observable","suites":["max"],"updatePoint":{"line":193,"column":67},"line":193,"code":"  it('should handle a constant predicate on an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----|';\n\n      const predicate = function <T>() {\n        return 42;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on an never hot observable","suites":["max"],"updatePoint":{"line":208,"column":67},"line":208,"code":"  it('should handle a constant predicate on an never hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^----');\n      const e1subs = '   ^----';\n      const expected = ' -----';\n\n      const predicate = function <T>() {\n        return 42;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on a simple hot observable","suites":["max"],"updatePoint":{"line":223,"column":67},"line":223,"code":"  it('should handle a constant predicate on a simple hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-|   ', { a: 1 });\n      const e1subs = '   ^---!   ';\n      const expected = ' ----(w|)';\n\n      const predicate = function () {\n        return 42;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a reverse predicate on observable with many values","suites":["max"],"updatePoint":{"line":238,"column":70},"line":238,"code":"  it('should handle a reverse predicate on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-b--c--d-|   ', { a: 42, b: -1, c: 0, d: 666 });\n      const e1subs = '   ^---------!   ';\n      const expected = ' ----------(w|)';\n\n      const predicate = function <T>(x: T, y: T) {\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: -1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a predicate for string on observable with many values","suites":["max"],"updatePoint":{"line":253,"column":73},"line":253,"code":"  it('should handle a predicate for string on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-b--c--d-|   ');\n      const e1subs = '   ^---------!   ';\n      const expected = ' ----------(w|)';\n\n      const predicate = function <T>(x: T, y: T) {\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected, { w: 'b' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on observable that throws","suites":["max"],"updatePoint":{"line":268,"column":66},"line":268,"code":"  it('should handle a constant predicate on observable that throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^---#');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      const predicate = () => {\n        return 42;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a predicate that throws, on observable with many values","suites":["max"],"updatePoint":{"line":283,"column":75},"line":283,"code":"  it('should handle a predicate that throws, on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--|');\n      const e1subs = '   ^----!   ';\n      const expected = ' -----#   ';\n\n      const predicate = function (x: string, y: string) {\n        if (y === '3') {\n          throw 'error';\n        }\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable(e1.pipe(max(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/max-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge an immediately-scheduled source with an immediately-scheduled second","suites":["merge (legacy)"],"updatePoint":{"line":6,"column":87},"line":6,"code":"  it('should merge an immediately-scheduled source with an immediately-scheduled second', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [1, 2, 4, 3, 5, 6, 7, 8];\n\n    a.pipe(merge(b, queueScheduler)).subscribe(\n      { next: val => {\n        expect(val).to.equal(r.shift());\n      }, error: x => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"operators/merge-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge a hot observable of cold observables","suites":["mergeAll"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should merge a hot observable of cold observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    --a---b--c---d--|      ');\n      const xsubs = '   --^---------------!      ';\n      const y = cold('           ----e---f--g---|');\n      const ysubs = '   ---------^--------------!';\n      const e1 = hot('  --x------y-------|       ', { x: x, y: y });\n      const e1subs = '  ^----------------!       ';\n      const expected = '----a---b--c-e-d-f--g---|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge all observables in an observable","suites":["mergeAll"],"updatePoint":{"line":33,"column":51},"line":33,"code":"  it('should merge all observables in an observable', () => {\n    testScheduler.run(({ expectObservable }) => {\n      // prettier-ignore\n      const e1 = from([\n        of('a'),\n        of('b'),\n        of('c')\n      ]);\n      const expected = '(abc|)';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if any child observable throws","suites":["mergeAll"],"updatePoint":{"line":47,"column":49},"line":47,"code":"  it('should throw if any child observable throws', () => {\n    testScheduler.run(({ expectObservable }) => {\n      // prettier-ignore\n      const e1 = from([\n        of('a'),\n        throwError(() => ('error')),\n        of('c')\n      ]);\n      const expected = '(a#)';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging a hot observable of observables","suites":["mergeAll"],"updatePoint":{"line":61,"column":59},"line":61,"code":"  it('should handle merging a hot observable of observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a---b---c---|   ');\n      const xsubs = '   --^-----------!   ';\n      const y = cold('       d---e---f---|');\n      const ysubs = '   -----^-----------!';\n      const e1 = hot('  --x--y--|         ', { x: x, y: y });\n      const e1subs = '  ^-------!         ';\n      const expected = '--a--db--ec--f---|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge one cold Observable at a time with parameter concurrency=1","suites":["mergeAll"],"updatePoint":{"line":78,"column":77},"line":78,"code":"  it('should merge one cold Observable at a time with parameter concurrency=1', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a---b---c---|            ');\n      const xsubs = '   --^-----------!            ';\n      const y = cold('                d---e---f---|');\n      const ysubs = '   --------------^-----------!';\n      const e1 = hot('  --x--y--|                  ', { x: x, y: y });\n      const e1subs = '  ^-------!                  ';\n      const expected = '--a---b---c---d---e---f---|';\n\n      expectObservable(e1.pipe(mergeAll(1))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two cold Observables at a time with parameter concurrency=2","suites":["mergeAll"],"updatePoint":{"line":95,"column":78},"line":95,"code":"  it('should merge two cold Observables at a time with parameter concurrency=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a---b---c---|        ');\n      const xsubs = '   --^-----------!        ';\n      const y = cold('       d---e---f---|     ');\n      const ysubs = '   -----^-----------!     ';\n      const z = cold('                --g---h-|');\n      const zsubs = '   --------------^-------!';\n      const e1 = hot('  --x--y--z--|           ', { x: x, y: y, z: z });\n      const e1subs = '  ^----------!           ';\n      const expected = '--a--db--ec--f--g---h-|';\n\n      expectObservable(e1.pipe(mergeAll(2))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge one hot Observable at a time with parameter concurrency=1","suites":["mergeAll"],"updatePoint":{"line":115,"column":76},"line":115,"code":"  it('should merge one hot Observable at a time with parameter concurrency=1', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   ---a---b---c---|          ');\n      const xsubs = '   --^------------!          ';\n      const y = hot('   -------------d---e---f---|');\n      const ysubs = '   ---------------^---------!';\n      const e1 = hot('  --x--y--|                 ', { x: x, y: y });\n      const e1subs = '  ^-------!                 ';\n      const expected = '---a---b---c-----e---f---|';\n\n      expectObservable(e1.pipe(mergeAll(1))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two hot Observables at a time with parameter concurrency=2","suites":["mergeAll"],"updatePoint":{"line":132,"column":77},"line":132,"code":"  it('should merge two hot Observables at a time with parameter concurrency=2', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   i--a---b---c---|        ');\n      const xsubs = '   --^------------!        ';\n      const y = hot('   -i-i--d---e---f---|     ');\n      const ysubs = '   -----^------------!     ';\n      const z = hot('   --i--i--i--i-----g---h-|');\n      const zsubs = '   ---------------^-------!';\n      const e1 = hot('  --x--y--z--|            ', { x: x, y: y, z: z });\n      const e1subs = '  ^----------!            ';\n      const expected = '---a--db--ec--f--g---h-|';\n\n      expectObservable(e1.pipe(mergeAll(2))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging a hot observable of observables, outer unsubscribed early","suites":["mergeAll"],"updatePoint":{"line":152,"column":85},"line":152,"code":"  it('should handle merging a hot observable of observables, outer unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a---b---c---|   ');\n      const xsubs = '   --^---------!     ';\n      const y = cold('       d---e---f---|');\n      const ysubs = '   -----^------!     ';\n      const e1 = hot('  --x--y--|         ', { x: x, y: y });\n      const e1subs = '  ^-------!         ';\n      const expected = '--a--db--ec--     ';\n      const unsub = '   ------------!     ';\n\n      expectObservable(e1.pipe(mergeAll()), unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["mergeAll"],"updatePoint":{"line":170,"column":83},"line":170,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a---b---c---|   ');\n      const xsubs = '   --^---------!     ';\n      const y = cold('       d---e---f---|');\n      const ysubs = '   -----^------!     ';\n      const e1 = hot('  --x--y--|         ', { x: x, y: y });\n      const e1subs = '  ^-------!         ';\n      const expected = '--a--db--ec--     ';\n      const unsub = '   ------------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        mergeAll(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge parallel emissions","suites":["mergeAll"],"updatePoint":{"line":194,"column":37},"line":194,"code":"  it('should merge parallel emissions', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    ----a----b----c---|');\n      const xsubs = '   --^-----------------!';\n      const y = cold('       -d----e----f---|');\n      const ysubs = '   -----^--------------!';\n      const e1 = hot('  --x--y--|            ', { x: x, y: y });\n      const e1subs = '  ^-------!            ';\n      const expected = '------(ad)-(be)-(cf)|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and empty","suites":["mergeAll"],"updatePoint":{"line":211,"column":34},"line":211,"code":"  it('should merge empty and empty', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    |      ');\n      const xsubs = '   --(^!)   ';\n      const y = cold('       |   ');\n      const ysubs = '   -----(^!)';\n      const e1 = hot('  --x--y--|', { x: x, y: y });\n      const e1subs = '  ^-------!';\n      const expected = '--------|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge three empties","suites":["mergeAll"],"updatePoint":{"line":228,"column":32},"line":228,"code":"  it('should merge three empties', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    |         ');\n      const xsubs = '   --(^!)      ';\n      const y = cold('       |      ');\n      const ysubs = '   -----(^!)   ';\n      const z = cold('         |    ');\n      const zsubs = '   -------(^!) ';\n      const e1 = hot('  --x--y-z---|', { x: x, y: y, z: z });\n      const e1subs = '  ^----------!';\n      const expected = '-----------|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and empty","suites":["mergeAll"],"updatePoint":{"line":248,"column":34},"line":248,"code":"  it('should merge never and empty', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    -      ');\n      const xsubs = '   --^      ';\n      const y = cold('       |   ');\n      const ysubs = '   -----(^!)';\n      const e1 = hot('  --x--y--|', { x: x, y: y });\n      const e1subs = '  ^-------!';\n      const expected = '---------';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and never","suites":["mergeAll"],"updatePoint":{"line":265,"column":34},"line":265,"code":"  it('should merge never and never', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    -      ');\n      const xsubs = '   --^      ';\n      const y = cold('       -   ');\n      const ysubs = '   -----^   ';\n      const e1 = hot('  --x--y--|', { x: x, y: y });\n      const e1subs = '  ^-------!';\n      const expected = '---------';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and throw","suites":["mergeAll"],"updatePoint":{"line":282,"column":34},"line":282,"code":"  it('should merge empty and throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    |      ');\n      const xsubs = '   --(^!)   ';\n      const y = cold('       #   ');\n      const ysubs = '   -----(^!)';\n      const e1 = hot('  --x--y--|', { x: x, y: y });\n      const e1subs = '  ^----!   ';\n      const expected = '-----#   ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and throw","suites":["mergeAll"],"updatePoint":{"line":299,"column":34},"line":299,"code":"  it('should merge never and throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    -      ');\n      const xsubs = '   --^--!   ';\n      const y = cold('       #   ');\n      const ysubs = '   -----(^!)';\n      const e1 = hot('  --x--y--|', { x: x, y: y });\n      const e1subs = '  ^----!   ';\n      const expected = '-----#   ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and eventual error","suites":["mergeAll"],"updatePoint":{"line":316,"column":43},"line":316,"code":"  it('should merge empty and eventual error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    |         ');\n      const xsubs = '   --(^!)      ';\n      const y = cold('       ------#');\n      const ysubs = '   -----^-----!';\n      const e1 = hot('  --x--y--|   ', { x: x, y: y });\n      const e1subs = '  ^-------!   ';\n      const expected = '-----------#';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and eventual error","suites":["mergeAll"],"updatePoint":{"line":333,"column":43},"line":333,"code":"  it('should merge never and eventual error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    -         ');\n      const xsubs = '   --^--------!';\n      const y = cold('       ------#');\n      const ysubs = '   -----^-----!';\n      const e1 = hot('  --x--y--|   ', { x: x, y: y });\n      const e1subs = '  ^-------!   ';\n      const expected = '-----------#';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should take an empty source and return empty too","suites":["mergeAll"],"updatePoint":{"line":350,"column":54},"line":350,"code":"  it('should take an empty source and return empty too', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a never source and return never too","suites":["mergeAll"],"updatePoint":{"line":361,"column":53},"line":361,"code":"  it('should take a never source and return never too', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should take a throw source and return throw too","suites":["mergeAll"],"updatePoint":{"line":372,"column":53},"line":372,"code":"  it('should take a throw source and return throw too', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging a hot observable of non-overlapped observables","suites":["mergeAll"],"updatePoint":{"line":383,"column":74},"line":383,"code":"  it('should handle merging a hot observable of non-overlapped observables', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a-b---------|                 ');\n      const xsubs = '   --^-----------!                 ';\n      const y = cold('              c-d-e-f-|           ');\n      const ysubs = '   ------------^-------!           ';\n      const z = cold('                       g-h-i-j-k-|');\n      const zsubs = '   ---------------------^---------!';\n      const e1 = hot('  --x---------y--------z--------| ', { x: x, y: y, z: z });\n      const e1subs = '  ^-----------------------------! ';\n      const expected = '--a-b-------c-d-e-f--g-h-i-j-k-|';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if inner observable raises error","suites":["mergeAll"],"updatePoint":{"line":403,"column":57},"line":403,"code":"  it('should raise error if inner observable raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a-b---------|                 ');\n      const xsubs = '   --^-----------!                 ';\n      const y = cold('              c-d-e-f-#           ');\n      const ysubs = '   ------------^-------!           ';\n      const z = cold('                       g-h-i-j-k-|');\n      const zsubs: string[] = [];\n      const e1 = hot('  --x---------y--------z--------| ', { x: x, y: y, z: z });\n      const e1subs = '  ^-------------------!           ';\n      const expected = '--a-b-------c-d-e-f-#           ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if outer observable raises error","suites":["mergeAll"],"updatePoint":{"line":423,"column":57},"line":423,"code":"  it('should raise error if outer observable raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    a-b---------|      ');\n      const xsubs = '   --^-----------!      ';\n      const y = cold('              c-d-e-f-|');\n      const ysubs = '   ------------^---!    ';\n      const e1 = hot('  --x---------y---#    ', { x: x, y: y });\n      const e1subs = '  ^---------------!    ';\n      const expected = '--a-b-------c-d-#    ';\n\n      expectObservable(e1.pipe(mergeAll())).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge all promises in an observable","suites":["mergeAll"],"updatePoint":{"line":440,"column":48},"line":440,"code":"  it('should merge all promises in an observable', (done) => {\n    const e1 = from([\n      new Promise<string>((res) => {\n        res('a');\n      }),\n      new Promise<string>((res) => {\n        res('b');\n      }),\n      new Promise<string>((res) => {\n        res('c');\n      }),\n      new Promise<string>((res) => {\n        res('d');\n      }),\n    ]);\n    const expected = ['a', 'b', 'c', 'd'];\n\n    const res: string[] = [];\n    e1.pipe(mergeAll()).subscribe({\n      next: (x) => {\n        res.push(x);\n      },\n      error: () => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(res).to.deep.equal(expected);\n        done();\n      },\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when promise rejects","suites":["mergeAll"],"updatePoint":{"line":472,"column":45},"line":472,"code":"  it('should raise error when promise rejects', (done) => {\n    const error = 'error';\n    const e1 = from([\n      new Promise<string>((res) => {\n        res('a');\n      }),\n      new Promise<string>((res: any, rej) => {\n        rej(error);\n      }),\n      new Promise<string>((res) => {\n        res('c');\n      }),\n      new Promise<string>((res) => {\n        res('d');\n      }),\n    ]);\n\n    const res: string[] = [];\n    e1.pipe(mergeAll()).subscribe({\n      next: (x) => {\n        res.push(x);\n      },\n      error: (err) => {\n        expect(res.length).to.equal(1);\n        expect(err).to.equal('error');\n        done();\n      },\n      complete: () => {\n        done(new Error('should not be called'));\n      },\n    });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize generators when merged if the subscription ends","suites":["mergeAll"],"updatePoint":{"line":505,"column":69},"line":505,"code":"  it('should finalize generators when merged if the subscription ends', () => {\n    const iterable = {\n      finalized: false,\n      next() {\n        return { value: 'duck', done: false };\n      },\n      return() {\n        this.finalized = true;\n      },\n      [Symbol.iterator]() {\n        return this;\n      },\n    };\n\n    const results: string[] = [];\n\n    const iterableObservable = from<string>(iterable as any);\n    of(iterableObservable)\n      .pipe(mergeAll(), take(3))\n      .subscribe({ next: (x) => results.push(x), complete: () => results.push('GOOSE!') });\n\n    expect(results).to.deep.equal(['duck', 'duck', 'duck', 'GOOSE!']);\n    expect(iterable.finalized).to.be.true;\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two observables","suites":["mergeAll"],"updatePoint":{"line":530,"column":34},"line":530,"code":"  it('should merge two observables', (done) => {\n    const a = of(1, 2, 3);\n    const b = of(4, 5, 6, 7, 8);\n    const r = [1, 2, 3, 4, 5, 6, 7, 8];\n\n    of(a, b)\n      .pipe(mergeAll())\n      .subscribe({\n        next: (val) => {\n          expect(val).to.equal(r.shift());\n        },\n        complete: done,\n      });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two immediately-scheduled observables","suites":["mergeAll"],"updatePoint":{"line":545,"column":56},"line":545,"code":"  it('should merge two immediately-scheduled observables', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [1, 2, 4, 3, 5, 6, 7, 8];\n\n    of(a, b, queueScheduler)\n      .pipe(mergeAll())\n      .subscribe({\n        next: (val) => {\n          expect(val).to.equal(r.shift());\n        },\n        complete: done,\n      });\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeAll"],"updatePoint":{"line":560,"column":73},"line":560,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    of(synchronousObservable)\n      .pipe(mergeAll(), take(3))\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mergeAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["mergeMap"],"updatePoint":{"line":17,"column":55},"line":17,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const values = { x: 10, y: 30, z: 50 };\n      const x = cold('    x-x-x|             ', values);\n      //                        y-y-y|\n      //                           z-z-z|\n      const xsubs = [\n        '               --^----!             ',\n        '               --------^----!       ',\n        '               -----------^----!    ',\n      ];\n      const e1 = hot('  --1-----3--5--------|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--x-x-x-y-yzyz-z----|';\n\n      const result = e1.pipe(mergeMap((value) => x.pipe(map((i) => i * +value))));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["mergeMap"],"updatePoint":{"line":40,"column":50},"line":40,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(\n        mergeMap(\n          (x) => of(x, x + 1, x + 2),\n          (a, b, i, ii) => [a, b, i, ii]\n        )\n      )\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 1, 0, 0],\n            [1, 2, 0, 1],\n            [1, 3, 0, 2],\n            [2, 2, 1, 0],\n            [2, 3, 1, 1],\n            [2, 4, 1, 2],\n            [3, 3, 2, 0],\n            [3, 4, 2, 1],\n            [3, 5, 2, 2],\n          ]);\n        },\n      });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["mergeMap"],"updatePoint":{"line":73,"column":61},"line":73,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(mergeMap((x) => of(x, x + 1, x + 2), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5]);\n        },\n      });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated) and concurrency limit","suites":["mergeMap"],"updatePoint":{"line":91,"column":83},"line":91,"code":"  it('should support a void resultSelector (still deprecated) and concurrency limit', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(mergeMap((x) => of(x, x + 1, x + 2), void 0, 1))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5]);\n        },\n      });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many regular interval inners","suites":["mergeMap"],"updatePoint":{"line":109,"column":50},"line":109,"code":"  it('should mergeMap many regular interval inners', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  ----a---a---a---(a|)                    ');\n      const asubs = '   ^---------------!                       ';\n      const b = cold('      ----b---b---(b|)                    ');\n      const bsubs = '   ----^-----------!                       ';\n      const c = cold('                  ----c---c---c---c---(c|)');\n      const csubs = '   ----------------^-------------------!   ';\n      const d = cold('                          ----(d|)        ');\n      const dsubs = '   ------------------------^---!           ';\n      const e1 = hot('  a---b-----------c-------d-------|       ');\n      const e1subs = '  ^-------------------------------!       ';\n      const expected = '----a---(ab)(ab)(ab)c---c---(cd)c---(c|)';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d };\n      const source = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant resolved promises and merge","suites":["mergeMap"],"updatePoint":{"line":135,"column":63},"line":135,"code":"  it('should map values to constant resolved promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = () => from(Promise.resolve(42));\n\n    const results: number[] = [];\n    source.pipe(mergeMap(project)).subscribe({\n      next: (x) => {\n        results.push(x);\n      },\n      error: (err) => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      },\n      complete: () => {\n        expect(results).to.deep.equal([42, 42, 42, 42]);\n        done();\n      },\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant rejected promises and merge","suites":["mergeMap"],"updatePoint":{"line":154,"column":63},"line":154,"code":"  it('should map values to constant rejected promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = () => from(Promise.reject<number>(42));\n\n    source.pipe(mergeMap(project)).subscribe({\n      next: (x) => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      },\n      error: (err) => {\n        expect(err).to.equal(42);\n        done();\n      },\n      complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      },\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to resolved promises and merge","suites":["mergeMap"],"updatePoint":{"line":172,"column":54},"line":172,"code":"  it('should map values to resolved promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: number, index: number) => from(Promise.resolve(value + index));\n\n    const results: number[] = [];\n    source.pipe(mergeMap(project)).subscribe({\n      next: (x) => {\n        results.push(x);\n      },\n      error: (err) => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      },\n      complete: () => {\n        expect(results).to.deep.equal([4, 4, 4, 4]);\n        done();\n      },\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to rejected promises and merge","suites":["mergeMap"],"updatePoint":{"line":191,"column":54},"line":191,"code":"  it('should map values to rejected promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n    const project = (value: number, index: number) => from(Promise.reject<string>('' + value + '-' + index));\n\n    source.pipe(mergeMap(project)).subscribe({\n      next: (x) => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      },\n      error: (err) => {\n        expect(err).to.equal('4-0');\n        done();\n      },\n      complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      },\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer values to many inner values","suites":["mergeMap"],"updatePoint":{"line":209,"column":60},"line":209,"code":"  it('should mergeMap many outer values to many inner values', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                        ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                        ',\n        '               ---------^-------------------!                ',\n        '               -----------------^-------------------!        ',\n        '               -------------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------|            ');\n      const e1subs = '  ^--------------------------------!            ';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l---|';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, complete late","suites":["mergeMap"],"updatePoint":{"line":233,"column":61},"line":233,"code":"  it('should mergeMap many outer to many inner, complete late', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                            ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                            ',\n        '               ---------^-------------------!                    ',\n        '               -----------------^-------------------!            ',\n        '               -------------------------^-------------------!    ',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-----------------------|');\n      const e1subs = '  ^------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-------|';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, outer never completes","suites":["mergeMap"],"updatePoint":{"line":257,"column":69},"line":257,"code":"  it('should mergeMap many outer to many inner, outer never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                  ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      //                                                 ----i---j---k---l---|\n      //                                                                 ----i--\n      const xsubs = [\n        '               -^-------------------!                                  ',\n        '               ---------^-------------------!                          ',\n        '               -----------------^-------------------!                  ',\n        '               -------------------------^-------------------!          ',\n        '               ---------------------------------^-------------------!  ',\n        '               -------------------------------------------------^-----!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------e---------------f------');\n      const e1subs = '  ^------------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i--';\n      const unsub = '   -------------------------------------------------------!';\n\n      const source = e1.pipe(mergeMap(() => x));\n\n      expectObservable(source, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["mergeMap"],"updatePoint":{"line":286,"column":83},"line":286,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                  ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      //                                                 ----i---j---k---l---|\n      //                                                                 ----i--\n      const xsubs = [\n        '               -^-------------------!                                  ',\n        '               ---------^-------------------!                          ',\n        '               -----------------^-------------------!                  ',\n        '               -------------------------^-------------------!          ',\n        '               ---------------------------------^-------------------!  ',\n        '               -------------------------------------------------^-----!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------e---------------f------');\n      const e1subs = '  ^------------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i--';\n      const unsub = '   -------------------------------------------------------!';\n\n      const source = e1.pipe(\n        map((x) => x),\n        mergeMap(() => x),\n        map((x) => x)\n      );\n\n      expectObservable(source, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains with interop inners when result is unsubscribed explicitly","suites":["mergeMap"],"updatePoint":{"line":319,"column":103},"line":319,"code":"  it('should not break unsubscription chains with interop inners when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^-----------!                ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const expected = '-----------a--b--c--d-                ';\n      const unsub = '   ---------------------!                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      // This test manipulates the observable to make it look like an interop\n      // observable - an observable from a foreign library. Interop subscribers\n      // are treated differently: they are wrapped in a safe subscriber. This\n      // test ensures that unsubscriptions are chained all the way to the\n      // interop subscriber.\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        mergeMap((value) => asInteropObservable(observableLookup[value])),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, inner never completes","suites":["mergeMap"],"updatePoint":{"line":351,"column":69},"line":351,"code":"  it('should mergeMap many outer to many inner, inner never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l-------------------------');\n      //                         ----i---j---k---l-----------------\n      //                                 ----i---j---k---l---------\n      //                                         ----i---j---k---l-\n      const xsubs = [\n        '               -^-----------------------------------------',\n        '               ---------^---------------------------------',\n        '               -----------------^-------------------------',\n        '               -------------------------^-----------------',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------|         ');\n      const e1subs = '  ^--------------------------------!         ';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, and inner throws","suites":["mergeMap"],"updatePoint":{"line":375,"column":64},"line":375,"code":"  it('should mergeMap many outer to many inner, and inner throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l-------#   ');\n      //                         ----i---j---k---l\n      //                                 ----i---j\n      //                                         -\n      const xsubs = [\n        '               -^-----------------------!   ',\n        '               ---------^---------------!   ',\n        '               -----------------^-------!   ',\n        '               -------------------------(^!)',\n      ];\n      const e1 = hot('  -a-------b-------c-------d   ');\n      const e1subs = '  ^------------------------!   ';\n      const expected = '-----i---j---(ki)(lj)(ki)#   ';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, and outer throws","suites":["mergeMap"],"updatePoint":{"line":399,"column":64},"line":399,"code":"  it('should mergeMap many outer to many inner, and outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|            ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l\n      //                                         ----i---j\n      const xsubs = [\n        '               -^-------------------!            ',\n        '               ---------^-------------------!    ',\n        '               -----------------^---------------!',\n        '               -------------------------^-------!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------#');\n      const e1subs = '  ^--------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)#';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to many inner, both inner and outer throw","suites":["mergeMap"],"updatePoint":{"line":423,"column":74},"line":423,"code":"  it('should mergeMap many outer to many inner, both inner and outer throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---#            ');\n      //                         ----i---j---k\n      //                                 ----i\n      const xsubs = [\n        '               -^-------------------!            ',\n        '               ---------^-----------!            ',\n        '               -----------------^---!            ',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------#');\n      const e1subs = '  ^--------------------!            ';\n      const expected = '-----i---j---(ki)(lj)#            ';\n\n      const result = e1.pipe(mergeMap(() => x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap to many cold Observable, with parameter concurrency=1","suites":["mergeMap"],"updatePoint":{"line":445,"column":75},"line":445,"code":"  it('should mergeMap to many cold Observable, with parameter concurrency=1', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                        ');\n      //                                     ----i---j---k---l---|\n      //                                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                                        ',\n        '               ---------------------^-------------------!                    ',\n        '               -----------------------------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c---|                                        ');\n      const e1subs = '  ^--------------------!                                        ';\n      const expected = '-----i---j---k---l-------i---j---k---l-------i---j---k---l---|';\n\n      const project = () => x;\n      const result = e1.pipe(mergeMap(project, 1));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap to many cold Observable, with parameter concurrency=2","suites":["mergeMap"],"updatePoint":{"line":468,"column":75},"line":468,"code":"  it('should mergeMap to many cold Observable, with parameter concurrency=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                    ');\n      //                         ----i---j---k---l---|\n      //                                     ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                    ',\n        '               ---------^-------------------!            ',\n        '               ---------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c---|                    ');\n      const e1subs = '  ^--------------------!                    ';\n      const expected = '-----i---j---(ki)(lj)k---(li)j---k---l---|';\n\n      const project = () => x;\n      const result = e1.pipe(mergeMap(project, 2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap to many hot Observable, with parameter concurrency=1","suites":["mergeMap"],"updatePoint":{"line":491,"column":74},"line":491,"code":"  it('should mergeMap to many hot Observable, with parameter concurrency=1', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   x----i---j---k---l---|                                        ');\n      const asubs = '   -^-------------------!                                        ';\n      const b = hot('   -x-x-xxxx-x-x-xxxxx-x----i---j---k---l---|                    ');\n      const bsubs = '   ---------------------^-------------------!                    ';\n      const c = hot('   x-xxxx---x-x-x-x-x-xx--x--x-x--x--xxxx-x-----i---j---k---l---|');\n      const csubs = '   -----------------------------------------^-------------------!';\n      const e1 = hot('  -a-------b-------c---|                                        ');\n      const e1subs = '  ^--------------------!                                        ';\n      const expected = '-----i---j---k---l-------i---j---k---l-------i---j---k---l---|';\n      const inners: Record<string, Observable<string>> = { a: a, b: b, c: c };\n\n      const project = (x: string) => inners[x];\n      const result = e1.pipe(mergeMap(project, 1));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap to many hot Observable, with parameter concurrency=2","suites":["mergeMap"],"updatePoint":{"line":515,"column":74},"line":515,"code":"  it('should mergeMap to many hot Observable, with parameter concurrency=2', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   x----i---j---k---l---|                    ');\n      const xsubs = '   -^-------------------!                    ';\n      const y = hot('   -x-x-xxxx----i---j---k---l---|            ');\n      const ysubs = '   ---------^-------------------!            ';\n      const z = hot('   x-xxxx---x-x-x-x-x-xx----i---j---k---l---|');\n      const zsubs = '   ---------------------^-------------------!';\n      const e1 = hot('  -a-------b-------c---|                    ');\n      const e1subs = '  ^--------------------!                    ';\n      const expected = '-----i---j---(ki)(lj)k---(li)j---k---l---|';\n      const inners: Record<string, Observable<string>> = { a: x, b: y, c: z };\n\n      const project = (x: string) => inners[x];\n      const result = e1.pipe(mergeMap(project, 2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, where all inners are finite","suites":["mergeMap"],"updatePoint":{"line":539,"column":63},"line":539,"code":"  it('should mergeMap many complex, where all inners are finite', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^------------------------------!             ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^--------------!                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^------------------------------!';\n      const f = cold('                                      --|            ');\n      const fsubs = '       --------------------------------^-!            ';\n      const g = cold('                                            ---1-2|  ');\n      const gsubs = '       --------------------------------------^-----!  ';\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g|       ');\n      const e1subs = '      ^--------------------------------------!       ';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2--|';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, all inners finite except one","suites":["mergeMap"],"updatePoint":{"line":575,"column":64},"line":575,"code":"  it('should mergeMap many complex, all inners finite except one', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^------------------------------!             ';\n      const d = cold('              -----------2--3-                       ');\n      const dsubs = '       --------^---------------                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^------------------------------!';\n      const f = cold('                                      --|            ');\n      const fsubs = '       --------------------------------^-!            ';\n      const g = cold('                                            ---1-2|  ');\n      const gsubs = '       --------------------------------------^-----!  ';\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g|       ');\n      const e1subs = '      ^--------------------------------------!       ';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2---';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, inners finite, outer does not complete","suites":["mergeMap"],"updatePoint":{"line":611,"column":74},"line":611,"code":"  it('should mergeMap many complex, inners finite, outer does not complete', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^------------------------------!             ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^--------------!                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^------------------------------!';\n      const f = cold('                                      --|            ');\n      const fsubs = '       --------------------------------^-!            ';\n      const g = cold('                                            ---1-2|  ');\n      const gsubs = '       --------------------------------------^-----!  ';\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g--------');\n      const e1subs = '      ^----------------------------------------------';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--6--4--5---1-2---';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, all inners finite, and outer throws","suites":["mergeMap"],"updatePoint":{"line":647,"column":71},"line":647,"code":"  it('should mergeMap many complex, all inners finite, and outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^------------------------------!             ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^--------------!                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^-----------------------!       ';\n      const f = cold('                                      --|            ');\n      const fsubs = '       --------------------------------^-!            ';\n      const g = cold('                                            ---1-2|  ');\n      const gsubs = '       --------------------------------------^!       ';\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g#       ');\n      const e1subs = '      ^--------------------------------------!       ';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--6--4--5-#       ';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, all inners complete except one throws","suites":["mergeMap"],"updatePoint":{"line":683,"column":73},"line":683,"code":"  it('should mergeMap many complex, all inners complete except one throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-#             ');\n      const csubs = '       --^------------------------------!             ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^--------------!                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^-----------------!             ';\n      const f = cold('                                      --|            ');\n      const fsubs = '       --------------------------------^!             ';\n      const g = cold('                                            ---1-2|  ');\n      const gsubs: string[] = [];\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g|       ');\n      const e1subs = '      ^--------------------------------!             ';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--6-#             ';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const result = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, all inners finite, outer is unsubscribed","suites":["mergeMap"],"updatePoint":{"line":719,"column":76},"line":719,"code":"  it('should mergeMap many complex, all inners finite, outer is unsubscribed', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^---------------------------!                ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^--------------!                       ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs = '       ---------------^--------------!                ';\n      const f = cold('                                      --|            ');\n      const fsubs: string[] = [];\n      const g = cold('                                            ---1-2|  ');\n      const gsubs: string[] = [];\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g|');\n      const e1subs = '      ^-----------------------------!                ';\n      const expected = '    ---2--3--4--5---1--2--3--2--3--                ';\n      const unsub = '       ------------------------------!                ';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n\n      const source = e1.pipe(mergeMap((value) => observableLookup[value]));\n\n      expectObservable(source, unsub).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many complex, all inners finite, project throws","suites":["mergeMap"],"updatePoint":{"line":756,"column":69},"line":756,"code":"  it('should mergeMap many complex, all inners finite, project throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold(' -#                                                  ');\n      const asubs: string[] = [];\n      const b = cold('   -#                                                ');\n      const bsubs: string[] = [];\n      const c = cold('        -2--3--4--5------------------6-|             ');\n      const csubs = '       --^------------!                               ';\n      const d = cold('              -----------2--3|                       ');\n      const dsubs = '       --------^------!                               ';\n      const e = cold('                     -1--------2--3-----4--5--------|');\n      const esubs: string[] = [];\n      const f = cold('                                      --|            ');\n      const fsubs: string[] = [];\n      const g = cold('                                            ---1-2|  ');\n      const gsubs: string[] = [];\n      const e1 = hot('-a-b--^-c-----d------e----------------f-----g|       ');\n      const e1subs = '      ^--------------!                               ';\n      const expected = '    ---2--3--4--5--#                               ';\n\n      const observableLookup: Record<string, Observable<string>> = { a: a, b: b, c: c, d: d, e: e, f: f, g: g };\n      const source = e1.pipe(\n        mergeMap((value) => {\n          if (value === 'e') {\n            throw 'error';\n          }\n          return observableLookup[value];\n        })\n      );\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n      expectSubscriptions(c.subscriptions).toBe(csubs);\n      expectSubscriptions(d.subscriptions).toBe(dsubs);\n      expectSubscriptions(e.subscriptions).toBe(esubs);\n      expectSubscriptions(f.subscriptions).toBe(fsubs);\n      expectSubscriptions(g.subscriptions).toBe(gsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to an array for each value","suites":["mergeMap"],"updatePoint":{"line":806,"column":59},"line":806,"code":"  it('should mergeMap many outer to an array for each value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^-------------------------------!';\n      const expected = '(22)--(4444)---(333)----(22)----|';\n\n      const source = e1.pipe(mergeMap((value) => arrayRepeat(value, +value)));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to inner arrays, and outer throws","suites":["mergeMap"],"updatePoint":{"line":819,"column":66},"line":819,"code":"  it('should mergeMap many outer to inner arrays, and outer throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------#');\n      const e1subs = '  ^-------------------------------!';\n      const expected = '(22)--(4444)---(333)----(22)----#';\n\n      const source = e1.pipe(mergeMap((value) => arrayRepeat(value, +value)));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to inner arrays, outer gets unsubscribed","suites":["mergeMap"],"updatePoint":{"line":832,"column":73},"line":832,"code":"  it('should mergeMap many outer to inner arrays, outer gets unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^------------!                   ';\n      const expected = '(22)--(4444)--                   ';\n      const unsub = '   -------------!                   ';\n\n      const source = e1.pipe(mergeMap((value) => arrayRepeat(value, +value)));\n\n      expectObservable(source, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMap many outer to inner arrays, project throws","suites":["mergeMap"],"updatePoint":{"line":846,"column":64},"line":846,"code":"  it('should mergeMap many outer to inner arrays, project throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^--------------!                 ';\n      const expected = '(22)--(4444)---#                 ';\n\n      const source = e1.pipe(\n        mergeMap((value) => {\n          if (value === '3') {\n            throw 'error';\n          }\n          return arrayRepeat(value, +value);\n        })\n      );\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and flatten","suites":["mergeMap"],"updatePoint":{"line":866,"column":28},"line":866,"code":"  it('should map and flatten', () => {\n    const source = of(1, 2, 3, 4).pipe(mergeMap((x) => of(x + '!')));\n\n    const expected = ['1!', '2!', '3!', '4!'];\n    let completed = false;\n\n    source.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: () => {\n        expect(expected.length).to.equal(0);\n        completed = true;\n      },\n    });\n\n    expect(completed).to.be.true;\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and flatten an Array","suites":["mergeMap"],"updatePoint":{"line":885,"column":37},"line":885,"code":"  it('should map and flatten an Array', () => {\n    const source = of(1, 2, 3, 4).pipe(mergeMap((x): any => [x + '!']));\n\n    const expected = ['1!', '2!', '3!', '4!'];\n    let completed = false;\n\n    source.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: () => {\n        expect(expected.length).to.equal(0);\n        completed = true;\n      },\n    });\n\n    expect(completed).to.be.true;\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support nested merges","suites":["mergeMap"],"updatePoint":{"line":904,"column":34},"line":904,"code":"  it('should support nested merges', (done) => {\n    // Added as a failing test when investigating:\n    // https://github.com/ReactiveX/rxjs/issues/4071\n\n    const results: (number | string)[] = [];\n\n    of(1)\n      .pipe(mergeMap(() => defer(() => of(2, asapScheduler)).pipe(mergeMap(() => defer(() => of(3, asapScheduler))))))\n      .subscribe({\n        next(value: any) {\n          results.push(value);\n        },\n        complete() {\n          results.push('done');\n        },\n      });\n\n    setTimeout(() => {\n      expect(results).to.deep.equal([3, 'done']);\n      done();\n    }, 0);\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support nested merges with promises","suites":["mergeMap"],"updatePoint":{"line":927,"column":48},"line":927,"code":"  it('should support nested merges with promises', (done) => {\n    // Added as a failing test when investigating:\n    // https://github.com/ReactiveX/rxjs/issues/4071\n\n    const results: (number | string)[] = [];\n\n    of(1)\n      .pipe(mergeMap(() => from(Promise.resolve(2)).pipe(mergeMap(() => Promise.resolve(3)))))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        complete() {\n          results.push('done');\n        },\n      });\n\n    setTimeout(() => {\n      expect(results).to.deep.equal([3, 'done']);\n      done();\n    }, 0);\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support wrapped sources","suites":["mergeMap"],"updatePoint":{"line":950,"column":36},"line":950,"code":"  it('should support wrapped sources', (done) => {\n    // Added as a failing test when investigating:\n    // https://github.com/ReactiveX/rxjs/issues/4095\n\n    const results: (number | string)[] = [];\n\n    const wrapped = new Observable<number>((subscriber) => {\n      const subscription = timer(0, asapScheduler).subscribe(subscriber);\n      return () => subscription.unsubscribe();\n    });\n    wrapped.pipe(mergeMap(() => timer(0, asapScheduler))).subscribe({\n      next(value) {\n        results.push(value);\n      },\n      complete() {\n        results.push('done');\n      },\n    });\n\n    setTimeout(() => {\n      expect(results).to.deep.equal([0, 'done']);\n      done();\n    }, 0);\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should properly handle errors from iterables that are processed after some async","suites":["mergeMap"],"updatePoint":{"line":976,"column":86},"line":976,"code":"  it('should properly handle errors from iterables that are processed after some async', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const noXError = new Error('we do not allow x');\n      const e1 = cold(' -----a------------b-----|', { a: ['o', 'o', 'o'], b: ['o', 'x', 'o'] });\n      const e1subs = '  ^-----------------!      ';\n      const expected = '-----(ooo)--------(o#)   ';\n\n      const iterable = function* (data: string[]) {\n        for (const d of data) {\n          if (d === 'x') {\n            throw noXError;\n          }\n          yield d;\n        }\n      };\n      const result = e1.pipe(mergeMap((x) => of(x).pipe(delay(0), mergeMap(iterable))));\n\n      expectObservable(result).toBe(expected, undefined, noXError);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeMap"],"updatePoint":{"line":998,"column":73},"line":998,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        mergeMap((value) => of(value)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mergeMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["mergeMapTo"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('    x-x-x|            ');\n      //                        x-x-x|\n      //                           x-x-x|\n      // prettier-ignore\n      const xsubs = [\n        '               --^----!            ',\n        '               --------^----!      ',\n        '               -----------^----!   ',\n      ];\n      const e1 = hot('  --1-----3--5-------|');\n      const e1subs = '  ^------------------!';\n      const expected = '--x-x-x-x-xxxx-x---|';\n\n      const result = e1.pipe(mergeMapTo(x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["mergeMapTo"],"updatePoint":{"line":39,"column":50},"line":39,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(mergeMapTo(of(4, 5, 6), (a, b, i, ii) => [a, b, i, ii]))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 4, 0, 0],\n            [1, 5, 0, 1],\n            [1, 6, 0, 2],\n            [2, 4, 1, 0],\n            [2, 5, 1, 1],\n            [2, 6, 1, 2],\n            [3, 4, 2, 0],\n            [3, 5, 2, 1],\n            [3, 6, 2, 2],\n          ]);\n        },\n      });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["mergeMapTo"],"updatePoint":{"line":67,"column":61},"line":67,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(mergeMapTo(of(4, 5, 6), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([4, 5, 6, 4, 5, 6, 4, 5, 6]);\n        },\n      });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many regular interval inners","suites":["mergeMapTo"],"updatePoint":{"line":85,"column":52},"line":85,"code":"  it('should mergeMapTo many regular interval inners', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('  ----1---2---3---(4|)                        ');\n      //                    ----1---2---3---(4|)\n      //                                ----1---2---3---(4|)\n      //                                        ----1---2---3---(4|)\n      const xsubs = [\n        '               ^---------------!                           ',\n        '               ----^---------------!                       ',\n        '               ----------------^---------------!           ',\n        '               ------------------------^---------------!   ',\n      ];\n      const e1 = hot('  a---b-----------c-------d-------|           ');\n      const e1subs = '  ^-------------------------------!           ';\n      const expected = '----1---(21)(32)(43)(41)2---(31)(42)3---(4|)';\n\n      const result = e1.pipe(mergeMapTo(x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant resolved promises and merge","suites":["mergeMapTo"],"updatePoint":{"line":109,"column":63},"line":109,"code":"  it('should map values to constant resolved promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n\n    const results: number[] = [];\n    source.pipe(mergeMapTo(from(Promise.resolve(42)))).subscribe({\n      next: (x) => {\n        results.push(x);\n      },\n      error: () => {\n        done(new Error('Subscriber error handler not supposed to be called.'));\n      },\n      complete: () => {\n        expect(results).to.deep.equal([42, 42, 42, 42]);\n        done();\n      },\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map values to constant rejected promises and merge","suites":["mergeMapTo"],"updatePoint":{"line":127,"column":63},"line":127,"code":"  it('should map values to constant rejected promises and merge', (done) => {\n    const source = from([4, 3, 2, 1]);\n\n    source.pipe(mergeMapTo(from(Promise.reject(42)))).subscribe({\n      next: () => {\n        done(new Error('Subscriber next handler not supposed to be called.'));\n      },\n      error: (err) => {\n        expect(err).to.equal(42);\n        done();\n      },\n      complete: () => {\n        done(new Error('Subscriber complete handler not supposed to be called.'));\n      },\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer values to many inner values","suites":["mergeMapTo"],"updatePoint":{"line":144,"column":62},"line":144,"code":"  it('should mergeMapTo many outer values to many inner values', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                        ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                        ',\n        '               ---------^-------------------!                ',\n        '               -----------------^-------------------!        ',\n        '               -------------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------|            ');\n      const e1subs = '  ^--------------------------------!            ';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l---|';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, complete late","suites":["mergeMapTo"],"updatePoint":{"line":166,"column":63},"line":166,"code":"  it('should mergeMapTo many outer to many inner, complete late', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                            ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                            ',\n        '               ---------^-------------------!                    ',\n        '               -----------------^-------------------!            ',\n        '               -------------------------^-------------------!    ',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-----------------------|');\n      const e1subs = '  ^------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-------|';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, outer never completes","suites":["mergeMapTo"],"updatePoint":{"line":188,"column":71},"line":188,"code":"  it('should mergeMapTo many outer to many inner, outer never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                  ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      //                                                 ----i---j---k---l---|\n      //                                                                 ----i--\n      const xsubs = [\n        '               -^-------------------!                                  ',\n        '               ---------^-------------------!                          ',\n        '               -----------------^-------------------!                  ',\n        '               -------------------------^-------------------!          ',\n        '               ---------------------------------^-------------------!  ',\n        '               -------------------------------------------------^-----!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------e---------------f------');\n      const e1subs = '  ^------------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i-';\n      const unsub = '   -------------------------------------------------------!';\n\n      const result = e1.pipe(mergeMapTo(x));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["mergeMapTo"],"updatePoint":{"line":217,"column":83},"line":217,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                  ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l---|\n      //                                         ----i---j---k---l---|\n      //                                                 ----i---j---k---l---|\n      //                                                                 ----i--\n      const xsubs = [\n        '               -^-------------------!                                  ',\n        '               ---------^-------------------!                          ',\n        '               -----------------^-------------------!                  ',\n        '               -------------------------^-------------------!          ',\n        '               ---------------------------------^-------------------!  ',\n        '               -------------------------------------------------^-----!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------e---------------f------');\n      const e1subs = '  ^------------------------------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)(ki)(lj)k---l---i-';\n      const unsub = '   -------------------------------------------------------!';\n\n      const result = e1.pipe(\n        map((x) => x),\n        mergeMapTo(x),\n        map((x) => x)\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, inner never completes","suites":["mergeMapTo"],"updatePoint":{"line":250,"column":71},"line":250,"code":"  it('should mergeMapTo many outer to many inner, inner never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l-                        ');\n      //                         ----i---j---k---l-\n      //                                 ----i---j---k---l-\n      //                                         ----i---j---k---l-\n      const xsubs = [\n        '               -^-----------------------------------------',\n        '               ---------^---------------------------------',\n        '               -----------------^-------------------------',\n        '               -------------------------^-----------------',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------|         ');\n      const e1subs = '  ^--------------------------------!         ';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)(lj)k---l-';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, and inner throws","suites":["mergeMapTo"],"updatePoint":{"line":272,"column":66},"line":272,"code":"  it('should mergeMapTo many outer to many inner, and inner throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l-------#        ');\n      //                         ----i---j---k---l-------#\n      //                                 ----i---j---k---l\n      const xsubs = [\n        '               -^-----------------------!        ',\n        '               ---------^---------------!        ',\n        '               -----------------^-------!        ',\n        '               -------------------------(^!)     ',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------|');\n      const e1subs = '  ^------------------------!        ';\n      const expected = '-----i---j---(ki)(lj)(ki)#        ';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, and outer throws","suites":["mergeMapTo"],"updatePoint":{"line":293,"column":66},"line":293,"code":"  it('should mergeMapTo many outer to many inner, and outer throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|            ');\n      //                         ----i---j---k---l---|\n      //                                 ----i---j---k---l\n      //                                         ----i---j\n      const xsubs = [\n        '               -^-------------------!            ',\n        '               ---------^-------------------!    ',\n        '               -----------------^---------------!',\n        '               -------------------------^-------!',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------#');\n      const e1subs = '  ^--------------------------------!';\n      const expected = '-----i---j---(ki)(lj)(ki)(lj)(ki)#';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to many inner, both inner and outer throw","suites":["mergeMapTo"],"updatePoint":{"line":315,"column":76},"line":315,"code":"  it('should mergeMapTo many outer to many inner, both inner and outer throw', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---#            ');\n      //                         ----i---j---k\n      //                                 ----i\n      const xsubs = [\n        '               -^-------------------!            ',\n        '               ---------^-----------!            ',\n        '               -----------------^---!            ',\n      ];\n      const e1 = hot('  -a-------b-------c-------d-------#');\n      const e1subs = '  ^--------------------!            ';\n      const expected = '-----i---j---(ki)(lj)#            ';\n\n      expectObservable(e1.pipe(mergeMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many cold Observable, with parameter concurrency=1, without resultSelector","suites":["mergeMapTo"],"updatePoint":{"line":335,"column":98},"line":335,"code":"  it('should mergeMapTo many cold Observable, with parameter concurrency=1, without resultSelector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                                        ');\n      //                                     ----i---j---k---l---|\n      //                                                         ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                                        ',\n        '               ---------------------^-------------------!                    ',\n        '               -----------------------------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c---|                                        ');\n      const e1subs = '  ^--------------------!                                        ';\n      const expected = '-----i---j---k---l-------i---j---k---l-------i---j---k---l---|';\n\n      const result = e1.pipe(mergeMapTo(x, 1));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo to many cold Observable, with parameter concurrency=2, without resultSelector","suites":["mergeMapTo"],"updatePoint":{"line":357,"column":101},"line":357,"code":"  it('should mergeMapTo to many cold Observable, with parameter concurrency=2, without resultSelector', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('   ----i---j---k---l---|                    ');\n      //                         ----i---j---k---l---|\n      //                                     ----i---j---k---l---|\n      const xsubs = [\n        '               -^-------------------!                    ',\n        '               ---------^-------------------!            ',\n        '               ---------------------^-------------------!',\n      ];\n      const e1 = hot('  -a-------b-------c---|                    ');\n      const e1subs = '  ^--------------------!                    ';\n      const expected = '-----i---j---(ki)(lj)k---(li)j---k---l---|';\n\n      const result = e1.pipe(mergeMapTo(x, 2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to arrays","suites":["mergeMapTo"],"updatePoint":{"line":379,"column":44},"line":379,"code":"  it('should mergeMapTo many outer to arrays', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^-------------------------------!';\n      const expected = '(0123)(0123)---(0123)---(0123)--|';\n\n      const result = e1.pipe(mergeMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to inner arrays, and outer throws","suites":["mergeMapTo"],"updatePoint":{"line":392,"column":68},"line":392,"code":"  it('should mergeMapTo many outer to inner arrays, and outer throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------#');\n      const e1subs = '  ^-------------------------------!';\n      const expected = '(0123)(0123)---(0123)---(0123)--#';\n\n      const result = e1.pipe(mergeMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeMapTo many outer to inner arrays, outer gets unsubscribed","suites":["mergeMapTo"],"updatePoint":{"line":405,"column":75},"line":405,"code":"  it('should mergeMapTo many outer to inner arrays, outer gets unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  2-----4--------3--------2-------|');\n      const e1subs = '  ^------------!                   ';\n      const expected = '(0123)(0123)--                   ';\n      const unsub = '   -------------!                   ';\n\n      const result = e1.pipe(mergeMapTo(['0', '1', '2', '3']));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and flatten","suites":["mergeMapTo"],"updatePoint":{"line":419,"column":28},"line":419,"code":"  it('should map and flatten', () => {\n    const source = of(1, 2, 3, 4).pipe(mergeMapTo(of('!')));\n\n    const expected = ['!', '!', '!', '!'];\n    let completed = false;\n\n    source.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: () => {\n        expect(expected.length).to.equal(0);\n        completed = true;\n      },\n    });\n\n    expect(completed).to.be.true;\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map and flatten an Array","suites":["mergeMapTo"],"updatePoint":{"line":438,"column":37},"line":438,"code":"  it('should map and flatten an Array', () => {\n    const source = of(1, 2, 3, 4).pipe(mergeMapTo(['!']));\n\n    const expected = ['!', '!', '!', '!'];\n    let completed = false;\n\n    source.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: () => {\n        expect(expected.length).to.equal(0);\n        completed = true;\n      },\n    });\n\n    expect(completed).to.be.true;\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeMapTo"],"updatePoint":{"line":457,"column":73},"line":457,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(mergeMapTo(of(0)), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mergeMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan things","suites":["mergeScan"],"updatePoint":{"line":16,"column":29},"line":16,"code":"  it('should mergeScan things', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ---u--v--w--x--y--z--|';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["mergeScan"],"updatePoint":{"line":38,"column":26},"line":38,"code":"  it('should handle errors', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--#');\n      const e1subs = '     ^-----------!';\n      const expected = '   ---u--v--w--#';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan values and be able to asynchronously project them","suites":["mergeScan"],"updatePoint":{"line":57,"column":72},"line":57,"code":"  it('should mergeScan values and be able to asynchronously project them', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const t = time('        --|                '); // t = 2\n      //                         --|\n      //                            --|\n      //                               --|\n      //                                  --|\n      //                                     --|\n      const expected = '   -----u--v--w--x--y--z|';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)).pipe(delay(t)), [] as string[]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not stop ongoing async projections when source completes","suites":["mergeScan"],"updatePoint":{"line":85,"column":69},"line":85,"code":"  it('should not stop ongoing async projections when source completes', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|     ');\n      const e1subs = '     ^--------------------!     ';\n      const t = time('        -----|'); //          acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5\n      //                         -----|             acc = []; x = 'c'; acc.concat(x) = ['c']\n      //                            -----|          acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']\n      //                               -----|       acc = ['c']; x = 'e'; acc.concat(x) = ['c', 'e']\n      //                                  -----|    acc = ['b', 'd']; x = 'f'; acc.concat(x) = ['b', 'd', 'f']\n      //                                     -----| acc = ['c', 'e']; x = 'g'; acc.concat(x) = ['c', 'e', 'g']\n      const expected = '   --------u--v--w--x--y--(z|)';\n\n      const values = {\n        u: ['b'],\n        v: ['c'],\n        w: ['b', 'd'],\n        x: ['c', 'e'],\n        y: ['b', 'd', 'f'],\n        z: ['c', 'e', 'g'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)).pipe(delay(t)), [] as string[]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should interrupt ongoing async projections when result is unsubscribed early","suites":["mergeScan"],"updatePoint":{"line":113,"column":82},"line":113,"code":"  it('should interrupt ongoing async projections when result is unsubscribed early', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^---------------!     ';\n      const t = time('        -----|'); // acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5\n      //                         -----|    acc = []; x = 'c'; acc.concat(x) = ['c']\n      //                            -----| acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']\n      const expected = '   --------u--v--w--     ';\n      const unsub = '      ----------------!     ';\n\n      const values = {\n        u: ['b'],\n        v: ['c'],\n        w: ['b', 'd'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)).pipe(delay(t)), [] as string[]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["mergeScan"],"updatePoint":{"line":136,"column":83},"line":136,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^---------------!     ';\n      const t = time('        -----|'); // acc = []; x = 'b'; acc.concat(x) = ['b']; t = 5\n      //                         -----|    acc = []; x = 'c'; acc.concat(x) = ['c']\n      //                            -----| acc = ['b']; x = 'd'; acc.concat(x) = ['b', 'd']\n      const expected = '   --------u--v--w--     ';\n      const unsub = '      ----------------!     ';\n\n      const values = {\n        u: ['b'],\n        v: ['c'],\n        w: ['b', 'd'],\n      };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        mergeScan((acc, x) => of(acc.concat(x)).pipe(delay(t)), [] as string[]),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeScan"],"updatePoint":{"line":163,"column":73},"line":163,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n\n    of(null)\n      .pipe(\n        mergeScan(() => synchronousObservable, 0),\n        takeWhile((x) => x != 2) // unsubscribe at the second side-effect\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([1, 2]);\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors in the projection function","suites":["mergeScan"],"updatePoint":{"line":192,"column":53},"line":192,"code":"  it('should handle errors in the projection function', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------!';\n      const expected = '   ---u--v--#';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n      };\n\n      const result = e1.pipe(\n        mergeScan((acc, x) => {\n          if (x === 'd') {\n            throw new Error('bad!');\n          }\n          return of(acc.concat(x));\n        }, [] as string[])\n      );\n\n      expectObservable(result).toBe(expected, values, new Error('bad!'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from the projected Observable","suites":["mergeScan"],"updatePoint":{"line":217,"column":59},"line":217,"code":"  it('should propagate errors from the projected Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--!';\n      const expected = '   ---#';\n\n      const result = e1.pipe(mergeScan(() => throwError(() => new Error('bad!')), []));\n\n      expectObservable(result).toBe(expected, undefined, new Error('bad!'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty projected Observable","suites":["mergeScan"],"updatePoint":{"line":230,"column":49},"line":230,"code":"  it('should handle an empty projected Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ---------------------|';\n\n      const result = e1.pipe(mergeScan(() => EMPTY, []));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never projected Observable","suites":["mergeScan"],"updatePoint":{"line":243,"column":48},"line":243,"code":"  it('should handle a never projected Observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ----------------------';\n\n      const result = e1.pipe(mergeScan(() => NEVER, []));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle empty","suites":["mergeScan"],"updatePoint":{"line":256,"column":18},"line":256,"code":"  it('handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle never","suites":["mergeScan"],"updatePoint":{"line":269,"column":18},"line":269,"code":"  it('handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle throw","suites":["mergeScan"],"updatePoint":{"line":282,"column":18},"line":282,"code":"  it('handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan unsubscription","suites":["mergeScan"],"updatePoint":{"line":295,"column":37},"line":295,"code":"  it('should mergeScan unsubscription', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^-------------!       ';\n      const expected = '   ---u--v--w--x--       ';\n      const unsub = '      --------------!       ';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n      };\n\n      const result = e1.pipe(mergeScan((acc, x) => of(acc.concat(x)), [] as string[]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan projects cold Observable with single concurrency","suites":["mergeScan"],"updatePoint":{"line":316,"column":71},"line":316,"code":"  it('should mergeScan projects cold Observable with single concurrency', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const inner = [\n        cold('            --d--e--f--|                      '),\n        cold('                       --g--h--i--|           '),\n        cold('                                  --j--k--l--|'),\n      ];\n      const xsubs = '   --^----------!                      ';\n      const ysubs = '   -------------^----------!           ';\n      const zsubs = '   ------------------------^----------!';\n\n      const e1 = hot('  --0--1--2--|                        ');\n      const e1subs = '  ^----------!                        ';\n      const expected = '--x-d--e--f--f-g--h--i--i-j--k--l--|';\n\n      const result = e1.pipe(mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), 'x', 1));\n\n      expectObservable(result).toBe(expected);\n\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner[0].subscriptions).toBe(xsubs);\n      expectSubscriptions(inner[1].subscriptions).toBe(ysubs);\n      expectSubscriptions(inner[2].subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit accumulator if inner completes without value","suites":["mergeScan"],"updatePoint":{"line":342,"column":66},"line":342,"code":"  it('should not emit accumulator if inner completes without value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ---------------------|';\n\n      const result = e1.pipe(mergeScan(() => EMPTY, ['1']));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit accumulator if inner completes without value after source completes","suites":["mergeScan"],"updatePoint":{"line":355,"column":89},"line":355,"code":"  it('should not emit accumulator if inner completes without value after source completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const x = cold('        -----|   ');\n      //                         -----|\n      // prettier-ignore\n      const xsubs = [\n        '                  ---^----!   ',\n        '                  ------^----!',\n      ];\n      const e1 = hot('--a--^--b--c--|  ');\n      const e1subs = '     ^--------!  ';\n      const expected = '   -----------|';\n\n      const result = e1.pipe(mergeScan(() => x, '1'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan projects hot Observable with single concurrency","suites":["mergeScan"],"updatePoint":{"line":376,"column":70},"line":376,"code":"  it('should mergeScan projects hot Observable with single concurrency', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const inner = [\n        hot('           --d--e--f--|                 '),\n        hot('           ----g----h----i----|         '),\n        hot('           ------j------k-------l------|'),\n      ];\n      const xsubs = '   ---^-------!                 ';\n      const ysubs = '   -----------^-------!         ';\n      const zsubs = '   -------------------^--------!';\n      const e1 = hot('  ---0---1---2---|             ');\n      const e1subs = '  ^--------------!             ';\n      const expected = '---x-e--f--f--i----i-l------|';\n\n      const result = e1.pipe(mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), 'x', 1));\n\n      expectObservable(result).toBe(expected);\n\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner[0].subscriptions).toBe(xsubs);\n      expectSubscriptions(inner[1].subscriptions).toBe(ysubs);\n      expectSubscriptions(inner[2].subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan projects cold Observable with dual concurrency","suites":["mergeScan"],"updatePoint":{"line":401,"column":69},"line":401,"code":"  it('should mergeScan projects cold Observable with dual concurrency', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const inner = [\n        cold('              ---d---e---f---|               '),\n        cold('                   ---g---h---i---|          '),\n        cold('                             ---j---k---l---|'),\n      ];\n      const xsubs = '   ----^--------------!               ';\n      const ysubs = '   ---------^--------------!          ';\n      const zsubs = '   -------------------^--------------!';\n      const e1 = hot('  ----0----1----2----|               ');\n      const e1subs = '  ^------------------!               ';\n      const expected = '----x--d-d-eg--fh--hi-j---k---l---|';\n\n      const result = e1.pipe(mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), 'x', 2));\n\n      expectObservable(result).toBe(expected);\n\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner[0].subscriptions).toBe(xsubs);\n      expectSubscriptions(inner[1].subscriptions).toBe(ysubs);\n      expectSubscriptions(inner[2].subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should mergeScan projects hot Observable with dual concurrency","suites":["mergeScan"],"updatePoint":{"line":426,"column":68},"line":426,"code":"  it('should mergeScan projects hot Observable with dual concurrency', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const inner = [\n        hot('           --d--e--f-----|              '),\n        hot('           ----g----h------i----|       '),\n        hot('           ------j--------k-----l------|'),\n      ];\n      const xsubs = '   ---^----------!              ';\n      const ysubs = '   -------^-------------!       ';\n      const zsubs = '   --------------^-------------!';\n      const e1 = hot('  ---0---1---2---|             ');\n      const e1subs = '  ^--------------!             ';\n      const expected = '---x-e-efh----hki----l------|';\n\n      const result = e1.pipe(mergeScan((acc, x) => inner[+x].pipe(startWith(acc)), 'x', 2));\n\n      expectObservable(result).toBe(expected);\n\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(inner[0].subscriptions).toBe(xsubs);\n      expectSubscriptions(inner[1].subscriptions).toBe(ysubs);\n      expectSubscriptions(inner[2].subscriptions).toBe(zsubs);\n    });\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass current index to accumulator","suites":["mergeScan"],"updatePoint":{"line":451,"column":46},"line":451,"code":"  it('should pass current index to accumulator', () => {\n    const recorded: number[] = [];\n    const e1 = of('a', 'b', 'c', 'd');\n\n    e1.pipe(\n      mergeScan((acc, x, index) => {\n        recorded.push(index);\n        return of(index);\n      }, 0)\n    ).subscribe();\n\n    expect(recorded).to.deep.equal([0, 1, 2, 3]);\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeScan"],"updatePoint":{"line":465,"column":73},"line":465,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        mergeScan((acc, value) => of(value), 0),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mergeScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging two hot observables","suites":["merge operator"],"updatePoint":{"line":15,"column":47},"line":15,"code":"  it('should handle merging two hot observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a-----b-----c----|');\n      const e1subs = '  ^------------------!';\n      const e2 = hot('-----d-----e-----f---|');\n      const e2subs = '  ^--------------------!';\n      const expected = '--a--d--b--e--c--f---|';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge a source with a second","suites":["merge operator"],"updatePoint":{"line":31,"column":41},"line":31,"code":"  it('should merge a source with a second', (done) => {\n    const a = of(1, 2, 3);\n    const b = of(4, 5, 6, 7, 8);\n    const r = [1, 2, 3, 4, 5, 6, 7, 8];\n\n    a.pipe(mergeWith(b)).subscribe(\n      { next: val => {\n        expect(val).to.equal(r.shift());\n      }, error: () => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge cold and cold","suites":["merge operator"],"updatePoint":{"line":47,"column":32},"line":47,"code":"  it('should merge cold and cold', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|');\n      const e1subs = '  ^-------------------!';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^----------------------!';\n      const expected = '---a--x--b--y--c--z----|';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and hot","suites":["merge operator"],"updatePoint":{"line":63,"column":30},"line":63,"code":"  it('should merge hot and hot', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---a---^-b-----c----|');\n      const e1subs = '       ^------------!';\n      const e2 = hot('-----x-^----y-----z----|');\n      const e2subs = '       ^---------------!';\n      const expected = '     --b--y--c--z----|';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and cold","suites":["merge operator"],"updatePoint":{"line":79,"column":31},"line":79,"code":"  it('should merge hot and cold', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---a-^---b-----c----|');\n      const e1subs = '     ^--------------!';\n      const e2 = cold('    --x-----y-----z----|');\n      const e2subs = '     ^------------------!';\n      const expected = '   --x-b---y-c---z----|';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge parallel emissions","suites":["merge operator"],"updatePoint":{"line":95,"column":37},"line":95,"code":"  it('should merge parallel emissions', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a----b----c----|');\n      const e1subs = '  ^-----------------!';\n      const e2 = hot('  ---x----y----z----|');\n      const e2subs = '  ^-----------------!';\n      const expected = '---(ax)-(by)-(cz)-|';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["merge operator"],"updatePoint":{"line":111,"column":53},"line":111,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a-----b-----c----|  ');\n      const e1subs = '  ^---------!           ';\n      const e2 = hot('  -----d-----e-----f---|');\n      const e2subs = '  ^---------!           ';\n      const expected = '--a--d--b--           ';\n      const unsub = '   ----------!           ';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["merge operator"],"updatePoint":{"line":128,"column":83},"line":128,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a-----b-----c----|  ');\n      const e1subs = '  ^---------!           ';\n      const e2 = hot('  -----d-----e-----f---|');\n      const e2subs = '  ^---------!           ';\n      const expected = '--a--d--b--           ';\n      const unsub = '   ----------!           ';\n\n      const result = e1.pipe(\n        map(x => x),\n        mergeWith(e2),\n        map(x => x)\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and empty","suites":["merge operator"],"updatePoint":{"line":149,"column":34},"line":149,"code":"  it('should merge empty and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('|   ');\n      const e1subs = ' (^!)';\n      const e2 = cold('|   ');\n      const e2subs = ' (^!)';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('|');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge three empties","suites":["merge operator"],"updatePoint":{"line":164,"column":32},"line":164,"code":"  it('should merge three empties', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('|');\n      const e1subs = ' (^!)';\n      const e2 = cold('|');\n      const e2subs = ' (^!)';\n      const e3 = cold('|');\n      const e3subs = ' (^!)';\n\n      const result = e1.pipe(mergeWith(e2, e3));\n\n      expectObservable(result).toBe('|');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and empty","suites":["merge operator"],"updatePoint":{"line":182,"column":34},"line":182,"code":"  it('should merge never and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const e1subs = ' ^';\n      const e2 = cold('|');\n      const e2subs = ' (^!)';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('-');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and never","suites":["merge operator"],"updatePoint":{"line":197,"column":34},"line":197,"code":"  it('should merge never and never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const e1subs = ' ^';\n      const e2 = cold('-');\n      const e2subs = ' ^';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('-');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and throw","suites":["merge operator"],"updatePoint":{"line":212,"column":34},"line":212,"code":"  it('should merge empty and throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('|');\n      const e1subs = ' (^!)';\n      const e2 = cold('#');\n      const e2subs = ' (^!)';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('#');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and throw","suites":["merge operator"],"updatePoint":{"line":227,"column":32},"line":227,"code":"  it('should merge hot and throw', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot(' --a--b--c--|');\n      const e1subs = '(^!)';\n      const e2 = cold('#');\n      const e2subs = '(^!)';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('#');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and throw","suites":["merge operator"],"updatePoint":{"line":242,"column":34},"line":242,"code":"  it('should merge never and throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const e1subs = ' (^!)';\n      const e2 = cold('#');\n      const e2subs = ' (^!)';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe('#');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge empty and eventual error","suites":["merge operator"],"updatePoint":{"line":257,"column":43},"line":257,"code":"  it('should merge empty and eventual error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)    ';\n      const e2 = hot('  -------#');\n      const e2subs = '  ^------!';\n      const expected = '-------#';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge hot and error","suites":["merge operator"],"updatePoint":{"line":273,"column":32},"line":273,"code":"  it('should merge hot and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^------!    ';\n      const e2 = hot('  -------#    ');\n      const e2subs = '  ^------!    ';\n      const expected = '--a--b-#    ';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge never and error","suites":["merge operator"],"updatePoint":{"line":289,"column":34},"line":289,"code":"  it('should merge never and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --------');\n      const e1subs = '  ^------!';\n      const e2 = hot('  -------#');\n      const e2subs = '  ^------!';\n      const expected = '-------#';\n\n      const result = e1.pipe(mergeWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two observables","suites":["mergeAll operator"],"updatePoint":{"line":307,"column":34},"line":307,"code":"  it('should merge two observables', (done) => {\n    const a = of(1, 2, 3);\n    const b = of(4, 5, 6, 7, 8);\n    const r = [1, 2, 3, 4, 5, 6, 7, 8];\n\n    of(a, b)\n      .pipe(mergeAll())\n      .subscribe(\n        { next: val => {\n          expect(val).to.equal(r.shift());\n        }, complete: done }\n      );\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge two immediately-scheduled observables","suites":["mergeAll operator"],"updatePoint":{"line":321,"column":56},"line":321,"code":"  it('should merge two immediately-scheduled observables', (done) => {\n    const a = of(1, 2, 3, queueScheduler);\n    const b = of(4, 5, 6, 7, 8, queueScheduler);\n    const r = [1, 2, 4, 3, 5, 6, 7, 8];\n\n    of(a, b, queueScheduler)\n      .pipe(mergeAll())\n      .subscribe(\n        { next: val => {\n          expect(val).to.equal(r.shift());\n        }, complete: done }\n      );\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["mergeAll operator"],"updatePoint":{"line":335,"column":73},"line":335,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      mergeWith(of(0)),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/mergeWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should min the values of an observable","suites":["min"],"updatePoint":{"line":16,"column":44},"line":16,"code":"  it('should min the values of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--|', { a: 42, b: -1, c: 3 });\n      const subs = '      ^----------!';\n      const expected = '  -----------(x|)';\n\n      expectObservable((<any>source).pipe(min())).toBe(expected, { x: -1 });\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source is never","suites":["min"],"updatePoint":{"line":27,"column":42},"line":27,"code":"  it('should be never when source is never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should be zero when source is empty","suites":["min"],"updatePoint":{"line":38,"column":41},"line":38,"code":"  it('should be zero when source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source doesn't complete","suites":["min"],"updatePoint":{"line":49,"column":50},"line":49,"code":"  it(\"should be never when source doesn't complete\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--x--^--y--');\n      const e1subs = '     ^     ';\n      const expected = '   ------';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should be completes when source doesn't have values","suites":["min"],"updatePoint":{"line":60,"column":57},"line":60,"code":"  it(\"should be completes when source doesn't have values\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----|';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should min the unique value of an observable","suites":["min"],"updatePoint":{"line":71,"column":50},"line":71,"code":"  it('should min the unique value of an observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--|', { y: 42 });\n      const e1subs = '   ^-----!';\n      const expected = ' ------(w|)';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected, { w: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should min the values of an ongoing hot observable","suites":["min"],"updatePoint":{"line":82,"column":56},"line":82,"code":"  it('should min the values of an ongoing hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--|', { a: 42, b: -1, c: 0, d: 666 });\n      const subs = '      ^----------!';\n      const expected = '  -----------(x|)';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected, { x: -1 });\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should min a range() source observable","suites":["min"],"updatePoint":{"line":93,"column":44},"line":93,"code":"  it('should min a range() source observable', (done) => {\n    (<any>range(1, 10000)).pipe(min()).subscribe(\n      (value: number) => {\n        expect(value).to.equal(1);\n      },\n      (x: any) => {\n        done(new Error('should not be called'));\n      },\n      () => {\n        done();\n      }\n    );\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should min a range().skip(1) source observable","suites":["min"],"updatePoint":{"line":107,"column":52},"line":107,"code":"  it('should min a range().skip(1) source observable', (done) => {\n    (<any>range(1, 10)).pipe(skip(1), min()).subscribe(\n      (value: number) => {\n        expect(value).to.equal(2);\n      },\n      (x: any) => {\n        done(new Error('should not be called'));\n      },\n      () => {\n        done();\n      }\n    );\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should min a range().take(1) source observable","suites":["min"],"updatePoint":{"line":121,"column":52},"line":121,"code":"  it('should min a range().take(1) source observable', (done) => {\n    (<any>range(1, 10)).pipe(take(1), min()).subscribe(\n      (value: number) => {\n        expect(value).to.equal(1);\n      },\n      (x: any) => {\n        done(new Error('should not be called'));\n      },\n      () => {\n        done();\n      }\n    );\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["min"],"updatePoint":{"line":135,"column":28},"line":135,"code":"  it('should work with error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--z--#', { x: 1, y: 2, z: 3 }, 'too bad');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["min"],"updatePoint":{"line":146,"column":28},"line":146,"code":"  it('should work with throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable((<any>e1).pipe(min())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on an empty hot observable","suites":["min"],"updatePoint":{"line":157,"column":67},"line":157,"code":"  it('should handle a constant predicate on an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|');\n      const e1subs = '   ^---!';\n      const expected = ' ----|';\n\n      const predicate = function <T>(x: T, y: T) {\n        return 42;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on an never hot observable","suites":["min"],"updatePoint":{"line":172,"column":67},"line":172,"code":"  it('should handle a constant predicate on an never hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^----');\n      const e1subs = '   ^----';\n      const expected = ' -----';\n\n      const predicate = function <T>(x: T, y: T) {\n        return 42;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on a simple hot observable","suites":["min"],"updatePoint":{"line":187,"column":67},"line":187,"code":"  it('should handle a constant predicate on a simple hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-|', { a: 1 });\n      const e1subs = '   ^---!';\n      const expected = ' ----(w|)';\n\n      const predicate = () => {\n        return 42;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, { w: 1 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["min"],"updatePoint":{"line":202,"column":53},"line":202,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-b-c-d-e-f-g-|');\n      const unsub = '    -------!         ';\n      const e1subs = '   ^------!         ';\n      const expected = ' --------         ';\n\n      const predicate = () => {\n        return 42;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["min"],"updatePoint":{"line":218,"column":83},"line":218,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^-a-b-c-d-e-f-g-|');\n      const e1subs = '   ^------!         ';\n      const expected = ' --------         ';\n      const unsub = '    -------!         ';\n\n      const predicate = function () {\n        return 42;\n      };\n\n      const result = (<any>e1).pipe(\n        mergeMap((x: string) => of(x)),\n        min(predicate),\n        mergeMap((x: number) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a reverse predicate on observable with many values","suites":["min"],"updatePoint":{"line":240,"column":70},"line":240,"code":"  it('should handle a reverse predicate on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-b--c--d-|', { a: 42, b: -1, c: 0, d: 666 });\n      const e1subs = '   ^---------!';\n      const expected = ' ----------(w|)';\n\n      const predicate = function <T>(x: T, y: T) {\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, { w: 666 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a predicate for string on observable with many values","suites":["min"],"updatePoint":{"line":255,"column":73},"line":255,"code":"  it('should handle a predicate for string on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-a-^-b--c--d-|');\n      const e1subs = '   ^---------!';\n      const expected = ' ----------(w|)';\n\n      const predicate = function <T>(x: T, y: T) {\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected, { w: 'd' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a constant predicate on observable that throws","suites":["min"],"updatePoint":{"line":270,"column":66},"line":270,"code":"  it('should handle a constant predicate on observable that throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^---#');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      const predicate = () => {\n        return 42;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a predicate that throws, on observable with many values","suites":["min"],"updatePoint":{"line":285,"column":75},"line":285,"code":"  it('should handle a predicate that throws, on observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^-2--3--|');\n      const e1subs = '   ^----!   ';\n      const expected = ' -----#   ';\n\n      const predicate = function (x: string, y: string) {\n        if (y === '3') {\n          throw 'error';\n        }\n        return x > y ? -1 : 1;\n      };\n\n      expectObservable((<any>e1).pipe(min(predicate))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/min-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["multicast"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1-2---3-4--5-|');\n      const e1subs = '  ^--------------!';\n      const expected = '--1-2---3-4--5-|';\n\n      const result = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      result.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept Subjects","suites":["multicast"],"updatePoint":{"line":31,"column":28},"line":31,"code":"  it('should accept Subjects', (done) => {\n    const expected = [1, 2, 3, 4];\n\n    const connectable = of(1, 2, 3, 4).pipe(multicast(new Subject<number>())) as ConnectableObservable<number>;\n\n    connectable.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: () => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        done();\n      },\n    });\n\n    connectable.connect();\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a ConnectableObservable","suites":["multicast"],"updatePoint":{"line":51,"column":46},"line":51,"code":"  it('should multicast a ConnectableObservable', (done) => {\n    const expected = [1, 2, 3, 4];\n\n    const source = new Subject<number>();\n    const connectable = source.pipe(multicast(new Subject<number>())) as ConnectableObservable<number>;\n    const replayed = connectable.pipe(multicast(new ReplaySubject<number>())) as ConnectableObservable<number>;\n\n    connectable.connect();\n    replayed.connect();\n\n    source.next(1);\n    source.next(2);\n    source.next(3);\n    source.next(4);\n    source.complete();\n\n    replayed\n      .pipe(\n        tap({\n          next(x) {\n            expect(x).to.equal(expected.shift());\n          },\n          complete() {\n            expect(expected.length).to.equal(0);\n          },\n        })\n      )\n      .subscribe({ error: done, complete: done });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept Subject factory functions","suites":["multicast"],"updatePoint":{"line":81,"column":45},"line":81,"code":"  it('should accept Subject factory functions', (done) => {\n    const expected = [1, 2, 3, 4];\n\n    const connectable = of(1, 2, 3, 4).pipe(multicast(() => new Subject<number>())) as ConnectableObservable<number>;\n\n    connectable.subscribe({\n      next: (x) => {\n        expect(x).to.equal(expected.shift());\n      },\n      error: () => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        done();\n      },\n    });\n\n    connectable.connect();\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a multicast selector and connect to a hot source for each subscriber","suites":["multicast"],"updatePoint":{"line":101,"column":88},"line":101,"code":"  it('should accept a multicast selector and connect to a hot source for each subscriber', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const subjectFactory = () => new Subject<string>();\n      const selector = (x: Observable<string>) => zip(x, x).pipe(map(([a, b]) => (parseInt(a) + parseInt(b)).toString()));\n\n      const e1 = hot('         -1-2-3----4-|');\n      // prettier-ignore\n      const e1subs = [\n        '                      ^-----------!',\n        '                      ----^-------!',\n        '                      --------^---!',\n      ];\n      const multicasted = e1.pipe(multicast(subjectFactory, selector));\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -2-4-6----8-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----6----8-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ----------8-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a multicast selector and connect to a cold source for each subscriber","suites":["multicast"],"updatePoint":{"line":128,"column":89},"line":128,"code":"  it('should accept a multicast selector and connect to a cold source for each subscriber', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const subjectFactory = () => new Subject<string>();\n      const selector = (x: Observable<string>) => zip(x, x).pipe(map(([a, b]) => (parseInt(a) + parseInt(b)).toString()));\n\n      const e1 = cold('        -1-2-3----4-|        ');\n      //                           -1-2-3----4-|\n      //                               -1-2-3----4-|\n      const e1subs = [\n        '                      ^-----------!        ',\n        '                      ----^-----------!    ',\n        '                      --------^-----------!',\n      ];\n      const multicasted = e1.pipe(multicast(subjectFactory, selector));\n      const subscriber1 = hot('a|                   ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -2-4-6----8-|        ';\n      const subscriber2 = hot('----b|               ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----2-4-6----8-|    ';\n      const subscriber3 = hot('--------c|           ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ---------2-4-6----8-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a multicast selector and respect the subject's messaging semantics","suites":["multicast"],"updatePoint":{"line":156,"column":86},"line":156,"code":"  it(\"should accept a multicast selector and respect the subject's messaging semantics\", () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const subjectFactory = () => new ReplaySubject<string>(1);\n      const selector = (x: Observable<string>) => concat(x, x.pipe(takeLast(1)));\n\n      const e1 = cold('        -1-2-3----4-|           ');\n      //                                   (4|)\n      //                           -1-2-3----4-|\n      //                                       (4|)\n      //                               -1-2-3----4-|\n      //                                           (4|)\n      const e1subs = [\n        '                      ^-----------!           ',\n        '                      ----^-----------!       ',\n        '                      --------^-----------!   ',\n      ];\n      const multicasted = e1.pipe(multicast(subjectFactory, selector));\n      const subscriber1 = hot('a|                      ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -1-2-3----4-(4|)        ';\n      const subscriber2 = hot('----b|                  ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----1-2-3----4-(4|)    ';\n      const subscriber3 = hot('--------c|              ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ---------1-2-3----4-(4|)';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if connect is not called, despite subscriptions","suites":["multicast"],"updatePoint":{"line":187,"column":71},"line":187,"code":"  it('should do nothing if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1-2---3-4--5-|');\n      const e1subs: string[] = [];\n      const expected = '----------------';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>()));\n\n      expectObservable(multicasted).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers","suites":["multicast"],"updatePoint":{"line":199,"column":60},"line":199,"code":"  it('should multicast the same values to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('        -1-2-3----4-|');\n      const e1subs = '         ^-----------!';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -1-2-3----4-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----3----4-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ----------4-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["multicast"],"updatePoint":{"line":220,"column":69},"line":220,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('        -1-2-3----4-#');\n      const e1subs = '         ^-----------!';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -1-2-3----4-#';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----3----4-#';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ----------4-#';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, but is unsubscribed explicitly and early","suites":["multicast"],"updatePoint":{"line":241,"column":102},"line":241,"code":"  it('should multicast the same values to multiple observers, but is unsubscribed explicitly and early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('        -1-2-3----4-|');\n      const e1subs = '         ^--------!   ';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const unsub = '          ---------u   ';\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----3----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ----------   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["multicast"],"updatePoint":{"line":273,"column":83},"line":273,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const project = (x: string) => of(x);\n      const subjectFactory = () => new Subject<string>();\n\n      const e1 = cold('        -1-2-3----4-|');\n      const e1subs = '         ^--------!   ';\n      const multicasted = e1.pipe(mergeMap(project), multicast(subjectFactory)) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(multicasted));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(multicasted));\n      const expected2 = '      -----3----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(multicasted));\n      const expected3 = '      ----------   ';\n      const unsub = '          ---------u   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["multicast"],"updatePoint":{"line":308,"column":38},"line":308,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const expected = '|   ';\n\n      expectObservable(multicasted).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["multicast"],"updatePoint":{"line":322,"column":37},"line":322,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const expected = '-';\n\n      expectObservable(multicasted).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["multicast"],"updatePoint":{"line":336,"column":37},"line":336,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const multicasted = e1.pipe(multicast(() => new Subject<string>())) as ConnectableObservable<string>;\n      const expected = '#   ';\n\n      expectObservable(multicasted).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n\n      multicasted.connect();\n    });\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":351,"column":55},"line":351,"code":"    it('should connect when first subscriber subscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject<string>();\n\n        const e1 = cold('           -1-2-3----4-|');\n        const e1subs = '         ---^-----------!';\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(multicasted));\n        const expected1 = '      ----1-2-3----4-|';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(multicasted));\n        const expected2 = '      --------3----4-|';\n        const subscriber3 = hot('-----------c|   ').pipe(mergeMapTo(multicasted));\n        const expected3 = '      -------------4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":372,"column":59},"line":372,"code":"    it('should disconnect when last subscriber unsubscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject<string>();\n\n        const e1 = cold('           -1-2-3----4-|');\n        const e1subs = '         ---^--------!   ';\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(multicasted));\n        const expected1 = '      ----1-2-3--     ';\n        const unsub1 = '         ----------!     ';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(multicasted));\n        const expected2 = '      --------3----   ';\n        const unsub2 = '         ------------!   ';\n\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable when cold source is synchronous","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":392,"column":59},"line":392,"code":"    it('should be retryable when cold source is synchronous', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject<string>();\n\n        const e1 = cold('   (123#)          ');\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's               ';\n        const expected1 = ' (123123123123#) ';\n        const subscribe2 = '-s              ';\n        const expected2 = ' -(123123123123#)';\n        const e1subs = [\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n        ];\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(3))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(3))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable with ReplaySubject and cold source is synchronous","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":433,"column":77},"line":433,"code":"    it('should be retryable with ReplaySubject and cold source is synchronous', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new ReplaySubject(1);\n\n        const e1 = cold('   (123#)          ');\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's               ';\n        const expected1 = ' (123123123123#) ';\n        const subscribe2 = '-s              ';\n        const expected2 = ' -(123123123123#)';\n        const e1subs = [\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 (^!)            ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n          '                 -(^!)           ',\n        ];\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(3))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(3))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable when cold source is synchronous","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":474,"column":60},"line":474,"code":"    it('should be repeatable when cold source is synchronous', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject<string>();\n\n        const e1 = cold('   (123|)             ');\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's                  ';\n        const expected1 = ' (123123123123123|) ';\n        const subscribe2 = '-s                 ';\n        const expected2 = ' -(123123123123123|)';\n        const e1subs = [\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n        ];\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(5))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(5))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable with ReplaySubject and cold source is synchronous","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":517,"column":78},"line":517,"code":"    it('should be repeatable with ReplaySubject and cold source is synchronous', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new ReplaySubject(1);\n\n        const e1 = cold('   (123|)             ');\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's                  ';\n        const expected1 = ' (123123123123123|) ';\n        const subscribe2 = '-s                 ';\n        const expected2 = ' -(123123123123123|)';\n        const e1subs = [\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 (^!)               ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n          '                 -(^!)              ',\n        ];\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(5))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(5))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":560,"column":27},"line":560,"code":"    it('should be retryable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject<string>();\n\n        const e1 = cold('   -1-2-3----4-#                        ');\n        //                              -1-2-3----4-#\n        //                                          -1-2-3----4-#\n        const e1subs = [\n          '                 ^-----------!                        ',\n          '                 ------------^-----------!            ',\n          '                 ------------------------^-----------!',\n        ];\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's------------------------------------';\n        const expected1 = ' -1-2-3----4--1-2-3----4--1-2-3----4-#';\n        const subscribe2 = '----s--------------------------------';\n        const expected2 = ' -----3----4--1-2-3----4--1-2-3----4-#';\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(2))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(retry(2))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable using a ReplaySubject","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":598,"column":49},"line":598,"code":"    it('should be retryable using a ReplaySubject', () => {\n      testScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new ReplaySubject(1);\n\n        const e1 = cold('        -1-2-3----4-#                        ');\n        const e1subs = [\n          '                      ^-----------!                        ',\n          '                      ------------^-----------!            ',\n          '                      ------------------------^-----------!',\n        ];\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const expected1 = '      -1-2-3----4--1-2-3----4--1-2-3----4-#';\n        const subscribe2 = time('----|                                ');\n        const expected2 = '      ----23----4--1-2-3----4--1-2-3----4-#';\n\n        expectObservable(multicasted.pipe(retry(2))).toBe(expected1);\n\n        testScheduler.schedule(() => expectObservable(multicasted.pipe(retry(2))).toBe(expected2), subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":621,"column":28},"line":621,"code":"    it('should be repeatable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new Subject();\n\n        const e1 = cold('   -1-2-3----4-|                        ');\n        const e1subs = [\n          '                 ^-----------!                        ',\n          '                 ------------^-----------!            ',\n          '                 ------------------------^-----------!',\n        ];\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's------------------------------------';\n        const expected1 = ' -1-2-3----4--1-2-3----4--1-2-3----4-|';\n        const subscribe2 = '----s--------------------------------';\n        const expected2 = ' -----3----4--1-2-3----4--1-2-3----4-|';\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(3))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(3))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable using a ReplaySubject","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":657,"column":50},"line":657,"code":"    it('should be repeatable using a ReplaySubject', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const subjectFactory = () => new ReplaySubject(1);\n        const e1 = cold('   -1-2-3----4-|                        ');\n        const e1subs = [\n          '                 ^-----------!                        ',\n          '                 ------------^-----------!            ',\n          '                 ------------------------^-----------!',\n        ];\n        const multicasted = e1.pipe(multicast(subjectFactory), refCount());\n        const subscribe1 = 's------------------------------------';\n        const expected1 = ' -1-2-3----4--1-2-3----4--1-2-3----4-|';\n        const subscribe2 = '----s--------------------------------';\n        const expected2 = ' ----23----4--1-2-3----4--1-2-3----4-|';\n\n        expectObservable(\n          hot(subscribe1).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(3))).toBe(expected1);\n            })\n          )\n        ).toBe(subscribe1);\n\n        expectObservable(\n          hot(subscribe2).pipe(\n            tap(() => {\n              expectObservable(multicasted.pipe(repeat(3))).toBe(expected2);\n            })\n          )\n        ).toBe(subscribe2);\n\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast one observable to multiple observers","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":693,"column":59},"line":693,"code":"  it('should multicast one observable to multiple observers', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(\n      multicast(() => {\n        return new Subject<number>();\n      })\n    ) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([1, 2, 3, 4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should remove all subscribers from the subject when disconnected","suites":["multicast","with refCount() and subject factory"],"updatePoint":{"line":732,"column":70},"line":732,"code":"  it('should remove all subscribers from the subject when disconnected', () => {\n    const subject = new Subject<number>();\n    const expected = [1, 2, 3, 4];\n    let i = 0;\n\n    const source = from([1, 2, 3, 4]).pipe(multicast(subject)) as ConnectableObservable<number>;\n\n    source.subscribe((x) => {\n      expect(x).to.equal(expected[i++]);\n    });\n\n    source.connect();\n    expect(subject.observers.length).to.equal(0);\n  });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow you to reconnect by subscribing again","suites":["multicast","when given a subject factory"],"updatePoint":{"line":748,"column":58},"line":748,"code":"    it('should allow you to reconnect by subscribing again', (done) => {\n      const expected = [1, 2, 3, 4];\n      let i = 0;\n\n      const source = of(1, 2, 3, 4).pipe(multicast(() => new Subject<number>())) as ConnectableObservable<number>;\n\n      source.subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected[i++]);\n        },\n        complete: () => {\n          i = 0;\n\n          source.subscribe({\n            next: (x) => {\n              expect(x).to.equal(expected[i++]);\n            },\n            complete: done,\n          });\n\n          source.connect();\n        },\n      });\n\n      source.connect();\n    });","file":"operators/multicast-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe on specified scheduler","suites":["observeOn"],"updatePoint":{"line":16,"column":43},"line":16,"code":"  it('should observe on specified scheduler', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-------!';\n      const expected = '--a--b--|';\n\n      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe after specified delay","suites":["observeOn"],"updatePoint":{"line":27,"column":42},"line":27,"code":"  it('should observe after specified delay', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a----b-|   ');\n      const e1subs = '    ^--------!   ';\n      const delay = time('  ---|       ');\n      //                         ---|\n      //                           ---|\n      const expected = '  -----a----b-|';\n\n      expectObservable(e1.pipe(observeOn(testScheduler, delay))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe when source raises error","suites":["observeOn"],"updatePoint":{"line":41,"column":45},"line":41,"code":"  it('should observe when source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--#');\n      const e1subs = '  ^----!';\n      const expected = '--a--#';\n\n      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe when source is empty","suites":["observeOn"],"updatePoint":{"line":52,"column":41},"line":52,"code":"  it('should observe when source is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const e1subs = '  ^----!';\n      const expected = '-----|';\n\n      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should observe when source does not complete","suites":["observeOn"],"updatePoint":{"line":63,"column":50},"line":63,"code":"  it('should observe when source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----');\n      const e1subs = '  ^----';\n      const expected = '-----';\n\n      expectObservable(e1.pipe(observeOn(testScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["observeOn"],"updatePoint":{"line":74,"column":53},"line":74,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(observeOn(testScheduler));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when the result is unsubscribed explicitly","suites":["observeOn"],"updatePoint":{"line":88,"column":87},"line":88,"code":"  it('should not break unsubscription chains when the result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        observeOn(testScheduler),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["observeOn"],"updatePoint":{"line":106,"column":73},"line":106,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(observeOn(queueScheduler), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/observeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue observable sequence with next observable","suites":["onErrorResumeNext"],"updatePoint":{"line":16,"column":62},"line":16,"code":"  it('should continue observable sequence with next observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#        ');\n      const e1subs = '  ^-------!        ';\n      const e2 = cold('         --c--d--|');\n      const e2subs = '  --------^-------!';\n      const expected = '--a--b----c--d--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue with hot observables","suites":["onErrorResumeNext"],"updatePoint":{"line":30,"column":42},"line":30,"code":"  it('should continue with hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#        ');\n      const e1subs = '  ^-------!        ';\n      const e2 = hot('  -----x----c--d--|');\n      const e2subs = '  --------^-------!';\n      const expected = '--a--b----c--d--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue with array of multiple observables that throw errors","suites":["onErrorResumeNext"],"updatePoint":{"line":44,"column":74},"line":44,"code":"  it('should continue with array of multiple observables that throw errors', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#                     ');\n      const e1subs = '  ^-------!                     ';\n      const e2 = [\n        cold('                  --c--d--#             '),\n        cold('                          --e--#        '),\n        cold('                               --f--g--|'),\n      ];\n      const e2subs = [\n        '               --------^-------!',\n        '               ----------------^----!',\n        '               ---------------------^-------!',\n      ];\n      const expected = '--a--b----c--d----e----f--g--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2[0].subscriptions).toBe(e2subs[0]);\n      expectSubscriptions(e2[1].subscriptions).toBe(e2subs[1]);\n      expectSubscriptions(e2[2].subscriptions).toBe(e2subs[2]);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue with multiple observables that throw errors","suites":["onErrorResumeNext"],"updatePoint":{"line":68,"column":65},"line":68,"code":"  it('should continue with multiple observables that throw errors', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#                     ');\n      const e1subs = '  ^-------!                     ';\n      const e2 = cold('         --c--d--#             ');\n      const e2subs = '  --------^-------!             ';\n      const e3 = cold('                 --e--#        ');\n      const e3subs = '  ----------------^----!        ';\n      const e4 = cold('                      --f--g--|');\n      const e4subs = '  ---------------------^-------!';\n      const expected = '--a--b----c--d----e----f--g--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n      expectSubscriptions(e4.subscriptions).toBe(e4subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue with multiple observables that don't throw error","suites":["onErrorResumeNext"],"updatePoint":{"line":88,"column":70},"line":88,"code":"  it(\"should continue with multiple observables that don't throw error\", () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|                     ');\n      const e1subs = '  ^-------!                     ';\n      const e2 = cold('         --c--d--|             ');\n      const e2subs = '  --------^-------!             ';\n      const e3 = cold('                 --e--|        ');\n      const e3subs = '  ----------------^----!        ';\n      const e4 = cold('                      --f--g--|');\n      const e4subs = '  ---------------------^-------!';\n      const expected = '--a--b----c--d----e----f--g--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n      expectSubscriptions(e4.subscriptions).toBe(e4subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should continue after empty observable","suites":["onErrorResumeNext"],"updatePoint":{"line":108,"column":44},"line":108,"code":"  it('should continue after empty observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  |                     ');\n      const e1subs = '  (^!)                  ';\n      const e2 = cold(' --c--d--|             ');\n      const e2subs = '  ^-------!             ';\n      const e3 = cold('         --e--#        ');\n      const e3subs = '  --------^----!        ';\n      const e4 = cold('              --f--g--|');\n      const e4subs = '  -------------^-------!';\n      const expected = '--c--d----e----f--g--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2, e3, e4))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n      expectSubscriptions(e4.subscriptions).toBe(e4subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete with observable that does not complete","suites":["onErrorResumeNext"],"updatePoint":{"line":128,"column":64},"line":128,"code":"  it('should not complete with observable that does not complete', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--| ');\n      const e1subs = '  ^-------! ';\n      const e2 = cold('         --');\n      const e2subs = '  --------^-';\n      const expected = '--a--b----';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should not continue when source observable does not complete","suites":["onErrorResumeNext"],"updatePoint":{"line":142,"column":66},"line":142,"code":"  it('should not continue when source observable does not complete', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--');\n      const e1subs = '  ^----';\n      const e2 = cold('-b--c-');\n      const e2subs: string[] = [];\n      const expected = '--a--';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete observable when next observable throws","suites":["onErrorResumeNext"],"updatePoint":{"line":156,"column":60},"line":156,"code":"  it('should complete observable when next observable throws', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#        ');\n      const e1subs = '  ^-------!        ';\n      const e2 = cold('         --c--d--#');\n      const e2subs = '  --------^-------!';\n      const expected = '--a--b----c--d--|';\n\n      expectObservable(e1.pipe(onErrorResumeNext(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["onErrorResumeNext"],"updatePoint":{"line":170,"column":73},"line":170,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    throwError(() => new Error('Some error'))\n      .pipe(onErrorResumeNext(synchronousObservable), take(3))\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from an interop observable upon explicit unsubscription","suites":["onErrorResumeNext"],"updatePoint":{"line":190,"column":80},"line":190,"code":"  it('should unsubscribe from an interop observable upon explicit unsubscription', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#       ');\n      const e1subs = '  ^-------!       ';\n      const e2 = cold('         --c--d--');\n      const e2subs = '  --------^---!   ';\n      const unsub = '   ------------!   ';\n      const expected = '--a--b----c--   ';\n\n      // This test manipulates the observable to make it look like an interop\n      // observable - an observable from a foreign library. Interop subscribers\n      // are treated differently: they are wrapped in a safe subscriber. This\n      // test ensures that unsubscriptions are chained all the way to the\n      // interop subscriber.\n\n      expectObservable(e1.pipe(onErrorResumeNext(asInteropObservable(e2))), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with promise","suites":["onErrorResumeNext"],"updatePoint":{"line":211,"column":30},"line":211,"code":"  it('should work with promise', (done) => {\n    const expected = [1, 2];\n    const source = concat(\n      of(1),\n      throwError(() => 'meh')\n    );\n\n    source.pipe(onErrorResumeNext(Promise.resolve(2))).subscribe({\n      next: (x) => {\n        expect(expected.shift()).to.equal(x);\n      },\n      error: () => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(expected).to.be.empty;\n        done();\n      },\n    });\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip invalid sources and move on","suites":["onErrorResumeNext"],"updatePoint":{"line":232,"column":45},"line":232,"code":"  it('should skip invalid sources and move on', () => {\n    const results: any[] = [];\n\n    of(1)\n      .pipe(onErrorResumeNext([2, 3, 4], { notValid: 'LOL' } as any, of(5, 6)))\n      .subscribe({\n        next: (value) => results.push(value),\n        complete: () => results.push('complete'),\n      });\n\n    expect(results).to.deep.equal([1, 2, 3, 4, 5, 6, 'complete']);\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should call finalize after each sync observable","suites":["onErrorResumeNext"],"updatePoint":{"line":245,"column":53},"line":245,"code":"  it('should call finalize after each sync observable', () => {\n    const results: any[] = [];\n\n    of(1)\n      .pipe(\n        finalize(() => results.push('finalize 1')),\n        onErrorResumeNext(\n          of(2).pipe(finalize(() => results.push('finalize 2'))),\n          of(3).pipe(finalize(() => results.push('finalize 3'))),\n          of(4).pipe(finalize(() => results.push('finalize 4')))\n        )\n      )\n      .subscribe({\n        next: (value) => results.push(value),\n        complete: () => results.push('complete'),\n      });\n\n    expect(results).to.deep.equal([1, 'finalize 1', 2, 'finalize 2', 3, 'finalize 3', 4, 'finalize 4', 'complete']);\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should not subscribe to the next source until after the previous is finalized.","suites":["onErrorResumeNext"],"updatePoint":{"line":265,"column":84},"line":265,"code":"  it('should not subscribe to the next source until after the previous is finalized.', () => {\n    const results: any[] = [];\n\n    of(1)\n      .pipe(\n        tap({\n          subscribe: () => results.push('subscribe 1'),\n          finalize: () => results.push('finalize 1'),\n        }),\n        onErrorResumeNext(\n          of(2).pipe(\n            tap({\n              subscribe: () => results.push('subscribe 2'),\n              finalize: () => results.push('finalize 2'),\n            })\n          ),\n          of(3).pipe(\n            tap({\n              subscribe: () => results.push('subscribe 3'),\n              finalize: () => results.push('finalize 3'),\n            })\n          ),\n          of(4).pipe(\n            tap({\n              subscribe: () => results.push('subscribe 4'),\n              finalize: () => results.push('finalize 4'),\n            })\n          )\n        )\n      )\n      .subscribe({\n        next: (value) => results.push(value),\n        complete: () => results.push('complete'),\n      });\n\n    expect(results).to.deep.equal([\n      'subscribe 1',\n      1,\n      'finalize 1',\n      'subscribe 2',\n      2,\n      'finalize 2',\n      'subscribe 3',\n      3,\n      'finalize 3',\n      'subscribe 4',\n      4,\n      'finalize 4',\n      'complete',\n    ]);\n  });","file":"operators/onErrorResumeNext-spec.ts","skipped":false,"dir":"spec"},{"name":"should group consecutive emissions as arrays of two","suites":["pairwise operator"],"updatePoint":{"line":16,"column":57},"line":16,"code":"  it('should group consecutive emissions as arrays of two', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b-c----d--e---|');\n      const e1subs = '  ^------------------!';\n      const expected = '-----u-v----w--x---|';\n\n      const values = {\n        u: ['a', 'b'],\n        v: ['b', 'c'],\n        w: ['c', 'd'],\n        x: ['d', 'e'],\n      };\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should pairwise things","suites":["pairwise operator"],"updatePoint":{"line":34,"column":28},"line":34,"code":"  it('should pairwise things', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ------v--w--x--y--z--|';\n\n      const values = {\n        v: ['b', 'c'],\n        w: ['c', 'd'],\n        x: ['d', 'e'],\n        y: ['e', 'f'],\n        z: ['f', 'g'],\n      };\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit on single-element streams","suites":["pairwise operator"],"updatePoint":{"line":53,"column":47},"line":53,"code":"  it('should not emit on single-element streams', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----|');\n      const e1subs = '     ^-------!';\n      const expected = '   --------|';\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle mid-stream throw","suites":["pairwise operator"],"updatePoint":{"line":64,"column":36},"line":64,"code":"  it('should handle mid-stream throw', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--#');\n      const e1subs = '     ^--------------!';\n      const expected = '   ------v--w--x--#';\n\n      const values = {\n        v: ['b', 'c'],\n        w: ['c', 'd'],\n        x: ['d', 'e'],\n      };\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["pairwise operator"],"updatePoint":{"line":81,"column":25},"line":81,"code":"  it('should handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["pairwise operator"],"updatePoint":{"line":92,"column":25},"line":92,"code":"  it('should handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["pairwise operator"],"updatePoint":{"line":103,"column":25},"line":103,"code":"  it('should handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(pairwise())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should be recursively re-enterable","suites":["pairwise operator"],"updatePoint":{"line":114,"column":40},"line":114,"code":"  it('should be recursively re-enterable', () => {\n    const results = new Array<[string, string]>();\n\n    const subject = new Subject<string>();\n\n    subject.pipe(pairwise(), take(3)).subscribe((pair) => {\n      results.push(pair);\n      subject.next('c');\n    });\n\n    subject.next('a');\n    subject.next('b');\n\n    expect(results).to.deep.equal([\n      ['a', 'b'],\n      ['b', 'c'],\n      ['c', 'c'],\n    ]);\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["pairwise operator"],"updatePoint":{"line":134,"column":73},"line":134,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(pairwise(), take(2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/pairwise-spec.ts","skipped":false,"dir":"spec"},{"name":"should dematerialize an Observable","suites":["pluck"],"updatePoint":{"line":16,"column":40},"line":16,"code":"  it('should dematerialize an Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = {\n        a: '{v:1}',\n        b: '{v:2}',\n        c: '{v:3}',\n      };\n\n      const e1 = cold(' --a--b--c--|', inputs);\n      const e1subs = '  ^----------!';\n      const expected = '--x--y--z--|';\n\n      const result = e1.pipe(\n        map((x) => ({ v: x.charAt(3) })),\n        pluck('v')\n      );\n\n      expectObservable(result).toBe(expected, { x: '1', y: '2', z: '3' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for one array","suites":["pluck"],"updatePoint":{"line":38,"column":31},"line":38,"code":"  it('should work for one array', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = { x: ['abc'] };\n      const e1 = cold(' --x--|', inputs);\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      const result = e1.pipe(pluck(0));\n\n      expectObservable(result).toBe(expected, { y: 'abc' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for one object","suites":["pluck"],"updatePoint":{"line":52,"column":32},"line":52,"code":"  it('should work for one object', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = { x: { prop: 42 } };\n      const e1 = cold(' --x--|', inputs);\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      const result = e1.pipe(pluck('prop'));\n\n      expectObservable(result).toBe(expected, { y: 42 });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for multiple objects","suites":["pluck"],"updatePoint":{"line":66,"column":38},"line":66,"code":"  it('should work for multiple objects', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = {\n        a: { prop: '1' },\n        b: { prop: '2' },\n        c: { prop: '3' },\n        d: { prop: '4' },\n        e: { prop: '5' },\n      };\n      const e1 = cold(' --a-b--c-d---e-|', inputs);\n      const e1subs = '  ^--------------!';\n      const expected = '--1-2--3-4---5-|';\n\n      const result = e1.pipe(pluck('prop'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with deep nested properties","suites":["pluck"],"updatePoint":{"line":86,"column":45},"line":86,"code":"  it('should work with deep nested properties', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = {\n        a: { a: { b: { c: '1' } } },\n        b: { a: { b: { c: '2' } } },\n        c: { a: { b: { c: '3' } } },\n        d: { a: { b: { c: '4' } } },\n        e: { a: { b: { c: '5' } } },\n      };\n      const e1 = cold(' --a-b--c-d---e-|', inputs);\n      const e1subs = '  ^--------------!';\n      const expected = '--1-2--3-4---5-|';\n\n      const result = e1.pipe(pluck('a', 'b', 'c'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with edge cases of deep nested properties","suites":["pluck"],"updatePoint":{"line":106,"column":59},"line":106,"code":"  it('should work with edge cases of deep nested properties', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = {\n        a: { i: { j: { k: 1 } } },\n        b: { i: { j: 2 } },\n        c: { i: { k: { k: 3 } } },\n        d: {},\n        e: { i: { j: { k: 5 } } },\n      };\n      const e1 = cold(' --a-b--c-d---e-|', inputs);\n      const e1subs = '  ^--------------!';\n      const expected = '--v-w--x-y---z-|';\n      const values: { [key: string]: number | undefined } = { v: 1, w: undefined, x: undefined, y: undefined, z: 5 };\n\n      const result = e1.pipe(pluck('i', 'j', 'k'));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error if not property is passed","suites":["pluck"],"updatePoint":{"line":127,"column":53},"line":127,"code":"  it('should throw an error if not property is passed', () => {\n    expect(() => {\n      of({ prop: 1 }, { prop: 2 }).pipe(pluck());\n    }).to.throw(Error, 'list of properties cannot be empty.');\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emits only errors","suites":["pluck"],"updatePoint":{"line":133,"column":68},"line":133,"code":"  it('should propagate errors from observable that emits only errors', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(pluck('whatever'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors from observable that emit values","suites":["pluck"],"updatePoint":{"line":146,"column":62},"line":146,"code":"  it('should propagate errors from observable that emit values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = { a: { prop: '1' }, b: { prop: '2' } };\n      const e1 = cold(' --a--b--#', inputs, 'too bad');\n      const e1subs = '  ^-------!';\n      const expected = '--1--2--#';\n\n      const result = e1.pipe(pluck('prop'));\n\n      expectObservable(result).toBe(expected, undefined, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should not pluck an empty observable","suites":["pluck"],"updatePoint":{"line":160,"column":42},"line":160,"code":"  it('should not pluck an empty observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(pluck('whatever'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["pluck"],"updatePoint":{"line":173,"column":53},"line":173,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--c--|', { a: { prop: '1' }, b: { prop: '2' } });\n      const e1subs = '  ^-----!     ';\n      const expected = '--1--2-     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(pluck('prop'));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should pluck twice","suites":["pluck"],"updatePoint":{"line":187,"column":24},"line":187,"code":"  it('should pluck twice', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = {\n        a: { a: { b: { c: '1' } } },\n        b: { a: { b: { c: '2' } } },\n        c: { a: { b: { c: '3' } } },\n        d: { a: { b: { c: '4' } } },\n        e: { a: { b: { c: '5' } } },\n      };\n      const e1 = cold(' --a-b--c-d---e-|', inputs);\n      const e1subs = '  ^--------------!';\n      const expected = '--1-2--3-4---5-|';\n\n      const result = e1.pipe(pluck('a', 'b'), pluck('c'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["pluck"],"updatePoint":{"line":207,"column":72},"line":207,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = { a: { prop: '1' }, b: { prop: '2' } };\n      const e1 = cold(' --a--b--c--|', inputs);\n      const e1subs = '  ^-----!     ';\n      const expected = '--1--2-     ';\n      const unsub = '   ------!     ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        pluck('prop'),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should support symbols","suites":["pluck"],"updatePoint":{"line":226,"column":28},"line":226,"code":"  it('should support symbols', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const sym = Symbol('sym');\n      const inputs = { x: { [sym]: 'abc' } };\n\n      const e1 = cold(' --x--|', inputs);\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      const result = e1.pipe(pluck(sym));\n\n      expectObservable(result).toBe(expected, { y: 'abc' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break on null values","suites":["pluck"],"updatePoint":{"line":242,"column":37},"line":242,"code":"  it('should not break on null values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const inputs = { x: null };\n      const e1 = cold(' --x--|', inputs);\n      const e1subs = '  ^----!';\n      const expected = '--y--|';\n\n      const result = e1.pipe(pluck('prop'));\n\n      expectObservable(result).toBe(expected, { y: undefined });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["pluck"],"updatePoint":{"line":256,"column":73},"line":256,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(pluck('whatever'), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/pluck-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["publish operator"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs = ' ^--------------!';\n      const published = source.pipe(publish()) as ConnectableObservable<any>;\n      const expected = '   --1-2---3-4--5-|';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a ConnectableObservable-ish","suites":["publish operator"],"updatePoint":{"line":30,"column":47},"line":30,"code":"  it('should return a ConnectableObservable-ish', () => {\n    const source = of(1).pipe(publish()) as ConnectableObservable<number>;\n    expect(typeof (<any>source)._subscribe === 'function').to.be.true;\n    expect(typeof (<any>source).getSubject === 'function').to.be.true;\n    expect(typeof source.connect === 'function').to.be.true;\n    expect(typeof source.refCount === 'function').to.be.true;\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if connect is not called, despite subscriptions","suites":["publish operator"],"updatePoint":{"line":38,"column":71},"line":38,"code":"  it('should do nothing if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs: string[] = [];\n      const published = source.pipe(publish());\n      const expected = '   -               ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers","suites":["publish operator"],"updatePoint":{"line":50,"column":60},"line":50,"code":"  it('should multicast the same values to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('   -1-2-3----4-|');\n      const sourceSubs = '    ^-----------!';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----4-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      -----3----4-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------4-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept selectors","suites":["publish operator"],"updatePoint":{"line":71,"column":29},"line":71,"code":"  it('should accept selectors', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('     -1-2-3----4-|');\n      const sourceSubs = [\n        '                      ^-----------!',\n        '                      ----^-------!',\n        '                      --------^---!',\n      ];\n      const published = source.pipe(publish((x) => x.pipe(zip(x, (a, b) => (parseInt(a) + parseInt(b)).toString()))));\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -2-4-6----8-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      -----6----8-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------8-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["publish operator"],"updatePoint":{"line":94,"column":69},"line":94,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-#');\n      const sourceSubs = '     ^-----------!';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----4-#';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      -----3----4-#';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------4-#';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, but is unsubscribed explicitly and early","suites":["publish operator"],"updatePoint":{"line":115,"column":102},"line":115,"code":"  it('should multicast the same values to multiple observers, but is unsubscribed explicitly and early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const unsub = '          ---------u   ';\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      -----3----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["publish operator"],"updatePoint":{"line":147,"column":83},"line":147,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(\n        mergeMap((x) => of(x)),\n        publish()\n      ) as ConnectableObservable<any>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      -----3----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------   ';\n      const unsub = '          ---------u   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["publish operator","with refCount()"],"updatePoint":{"line":183,"column":55},"line":183,"code":"    it('should connect when first subscriber subscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^-----------!';\n        const replayed = source.pipe(publish(), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const expected1 = '      ----1-2-3----4-|';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const expected2 = '      --------3----4-|';\n        const subscriber3 = hot('-----------c|   ').pipe(mergeMapTo(replayed));\n        const expected3 = '      -------------4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["publish operator","with refCount()"],"updatePoint":{"line":202,"column":59},"line":202,"code":"    it('should disconnect when last subscriber unsubscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^--------!   ';\n        const replayed = source.pipe(publish(), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const unsub1 = '         ----------!     ';\n        const expected1 = '      ----1-2-3--     ';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const unsub2 = '         ------------!   ';\n        const expected2 = '      --------3----   ';\n\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be retryable","suites":["publish operator","with refCount()"],"updatePoint":{"line":220,"column":31},"line":220,"code":"    it('should NOT be retryable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('   -1-2-3----4-#');\n        const sourceSubs = '    ^-----------!';\n        const published = source.pipe(publish(), refCount(), retry(3));\n        const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n        const expected1 = '      -1-2-3----4-#';\n        const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n        const expected2 = '      -----3----4-#';\n        const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n        const expected3 = '      ----------4-#';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be repeatable","suites":["publish operator","with refCount()"],"updatePoint":{"line":239,"column":32},"line":239,"code":"    it('should NOT be repeatable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-|');\n        const sourceSubs = '     ^-----------!';\n        const published = source.pipe(publish(), refCount(), repeat(3));\n        const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n        const expected1 = '      -1-2-3----4-|';\n        const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n        const expected2 = '      -----3----4-|';\n        const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n        const expected3 = '      ----------4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit completed when subscribed after completed","suites":["publish operator","with refCount()"],"updatePoint":{"line":259,"column":59},"line":259,"code":"  it('should emit completed when subscribed after completed', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publish()) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([]);\n    expect(subscriptions).to.equal(1);\n\n    connectable.subscribe({\n      next: (x) => {\n        results2.push(x);\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(results2).to.deep.equal([]);\n        done();\n      },\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["publish operator","with refCount()"],"updatePoint":{"line":302,"column":38},"line":302,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const expected = '   |   ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["publish operator","with refCount()"],"updatePoint":{"line":316,"column":37},"line":316,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const sourceSubs = ' ^';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const expected = '   -';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["publish operator","with refCount()"],"updatePoint":{"line":330,"column":37},"line":330,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publish()) as ConnectableObservable<string>;\n      const expected = '   #   ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast one observable to multiple observers","suites":["publish operator","with refCount()"],"updatePoint":{"line":344,"column":59},"line":344,"code":"  it('should multicast one observable to multiple observers', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publish()) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([1, 2, 3, 4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["publish operator","with refCount()"],"updatePoint":{"line":379,"column":41},"line":379,"code":"  it('should be referentially-transparent', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source1 = cold('-1-2-3-4-5-|');\n      const source1Subs = ' ^----------!';\n      const expected1 = '   -1-2-3-4-5-|';\n      const source2 = cold('-6-7-8-9-0-|');\n      const source2Subs = ' ^----------!';\n      const expected2 = '   -6-7-8-9-0-|';\n\n      // Calls to the _operator_ must be referentially-transparent.\n      const partialPipeLine = pipe(publish());\n\n      // The non-referentially-transparent publishing occurs within the _operator function_\n      // returned by the _operator_ and that happens when the complete pipeline is composed.\n      const published1 = source1.pipe(partialPipeLine) as ConnectableObservable<any>;\n      const published2 = source2.pipe(partialPipeLine) as ConnectableObservable<any>;\n\n      expectObservable(published1).toBe(expected1);\n      expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n      expectObservable(published2).toBe(expected2);\n      expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n\n      published1.connect();\n      published2.connect();\n    });\n  });","file":"operators/publish-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["publishBehavior operator"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs = ' ^--------------!';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const expected = '   0-1-2---3-4--5-|';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a ConnectableObservable-ish","suites":["publishBehavior operator"],"updatePoint":{"line":30,"column":47},"line":30,"code":"  it('should return a ConnectableObservable-ish', () => {\n    const source = of(1).pipe(publishBehavior(1)) as ConnectableObservable<number>;\n    expect(typeof (<any>source)._subscribe === 'function').to.be.true;\n    expect(typeof (<any>source).getSubject === 'function').to.be.true;\n    expect(typeof source.connect === 'function').to.be.true;\n    expect(typeof source.refCount === 'function').to.be.true;\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should only emit default value if connect is not called, despite subscriptions","suites":["publishBehavior operator"],"updatePoint":{"line":38,"column":84},"line":38,"code":"  it('should only emit default value if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs: string[] = [];\n      const published = source.pipe(publishBehavior('0'));\n      const expected = '   0               ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers","suites":["publishBehavior operator"],"updatePoint":{"line":50,"column":60},"line":50,"code":"  it('should multicast the same values to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('   -1-2-3----4-| ');\n      const sourceSubs = '    ^-----------! ';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      01-2-3----4-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----4-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-4-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["publishBehavior operator"],"updatePoint":{"line":71,"column":69},"line":71,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-#');\n      const sourceSubs = '     ^-----------!';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      01-2-3----4-#';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----4-#';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-4-#';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, but is unsubscribed explicitly and early","suites":["publishBehavior operator"],"updatePoint":{"line":92,"column":102},"line":92,"code":"  it('should multicast the same values to multiple observers, but is unsubscribed explicitly and early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const unsub = '          ---------u   ';\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      01-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["publishBehavior operator"],"updatePoint":{"line":124,"column":83},"line":124,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('   -1-2-3----4-|');\n      const sourceSubs = '    ^--------!   ';\n      const published = source.pipe(\n        mergeMap((x) => of(x)),\n        publishBehavior('0')\n      ) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      01-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-   ';\n      const unsub = '          ---------u   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":160,"column":55},"line":160,"code":"    it('should connect when first subscriber subscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^-----------!';\n        const replayed = source.pipe(publishBehavior('0'), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const expected1 = '      ---01-2-3----4-|';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const expected2 = '      -------23----4-|';\n        const subscriber3 = hot('-----------c|   ').pipe(mergeMapTo(replayed));\n        const expected3 = '      -----------3-4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":179,"column":59},"line":179,"code":"    it('should disconnect when last subscriber unsubscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^--------!   ';\n        const replayed = source.pipe(publishBehavior('0'), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const unsub1 = '         ----------!     ';\n        const expected1 = '      ---01-2-3--     ';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const unsub2 = '         ------------!   ';\n        const expected2 = '      -------23----   ';\n\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be retryable","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":197,"column":31},"line":197,"code":"    it('should NOT be retryable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-#');\n        const sourceSubs = '     ^-----------!';\n        const published = source.pipe(publishBehavior('0'), refCount(), retry(3));\n        const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n        const expected1 = '      01-2-3----4-#';\n        const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n        const expected2 = '      ----23----4-#';\n        const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n        const expected3 = '      --------3-4-#';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be repeatable","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":216,"column":32},"line":216,"code":"    it('should NOT be repeatable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-|');\n        const sourceSubs = '     ^-----------!';\n        const published = source.pipe(publishBehavior('0'), refCount(), repeat(3));\n        const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n        const expected1 = '      01-2-3----4-|';\n        const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n        const expected2 = '      ----23----4-|';\n        const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n        const expected3 = '      --------3-4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit completed when subscribed after completed","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":236,"column":59},"line":236,"code":"  it('should emit completed when subscribed after completed', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishBehavior(0)) as ConnectableObservable<number>;\n\n    connectable.subscribe(function (x) {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([0]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([0, 1, 2, 3, 4]);\n    expect(results2).to.deep.equal([]);\n    expect(subscriptions).to.equal(1);\n\n    connectable.subscribe({\n      next: function (x) {\n        results2.push(x);\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(results2).to.deep.equal([]);\n        done();\n      },\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":279,"column":38},"line":279,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const expected = '   (0|)';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":293,"column":37},"line":293,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const sourceSubs = ' ^';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const expected = '   0';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":307,"column":37},"line":307,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#  ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishBehavior('0')) as ConnectableObservable<string>;\n      const expected = '   (0#)';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast one observable to multiple observers","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":321,"column":59},"line":321,"code":"  it('should multicast one observable to multiple observers', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n    });\n\n    const connectable = source.pipe(publishBehavior(0)) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([0]);\n\n    connectable.connect();\n\n    expect(results2).to.deep.equal([]);\n\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([0, 1, 2, 3, 4]);\n    expect(results2).to.deep.equal([4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should follow the RxJS 4 behavior and emit nothing to observer after completed","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":356,"column":84},"line":356,"code":"  it('should follow the RxJS 4 behavior and emit nothing to observer after completed', (done) => {\n    const results: number[] = [];\n\n    const source = new Observable<number>((observer) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishBehavior(0)) as ConnectableObservable<number>;\n\n    connectable.connect();\n\n    connectable.subscribe((x) => {\n      results.push(x);\n    });\n\n    expect(results).to.deep.equal([]);\n    done();\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["publishBehavior operator","with refCount()"],"updatePoint":{"line":379,"column":41},"line":379,"code":"  it('should be referentially-transparent', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source1 = cold('-1-2-3-4-5-|');\n      const source1Subs = ' ^----------!';\n      const expected1 = '   x1-2-3-4-5-|';\n      const source2 = cold('-6-7-8-9-0-|');\n      const source2Subs = ' ^----------!';\n      const expected2 = '   x6-7-8-9-0-|';\n\n      // Calls to the _operator_ must be referentially-transparent.\n      const partialPipeLine = pipe(publishBehavior('x'));\n\n      // The non-referentially-transparent publishing occurs within the _operator function_\n      // returned by the _operator_ and that happens when the complete pipeline is composed.\n      const published1 = source1.pipe(partialPipeLine) as ConnectableObservable<any>;\n      const published2 = source2.pipe(partialPipeLine) as ConnectableObservable<any>;\n\n      expectObservable(published1).toBe(expected1);\n      expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n      expectObservable(published2).toBe(expected2);\n      expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n\n      published1.connect();\n      published2.connect();\n    });\n  });","file":"operators/publishBehavior-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit last notification of a simple source Observable","suites":["publishLast operator"],"updatePoint":{"line":16,"column":65},"line":16,"code":"  it('should emit last notification of a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|   ');\n      const sourceSubs = ' ^--------------!   ';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const expected = '   ---------------(5|)';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a ConnectableObservable-ish","suites":["publishLast operator"],"updatePoint":{"line":30,"column":47},"line":30,"code":"  it('should return a ConnectableObservable-ish', () => {\n    const source = of(1).pipe(publishLast()) as ConnectableObservable<number>;\n    expect(typeof (<any>source)._subscribe === 'function').to.be.true;\n    expect(typeof (<any>source).getSubject === 'function').to.be.true;\n    expect(typeof source.connect === 'function').to.be.true;\n    expect(typeof source.refCount === 'function').to.be.true;\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if connect is not called, despite subscriptions","suites":["publishLast operator"],"updatePoint":{"line":38,"column":71},"line":38,"code":"  it('should do nothing if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs: string[] = [];\n      const published = source.pipe(publishLast());\n      const expected = '   -               ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers","suites":["publishLast operator"],"updatePoint":{"line":50,"column":60},"line":50,"code":"  it('should multicast the same values to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|   ');\n      const sourceSubs = '     ^-----------!   ';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|              ').pipe(mergeMapTo(published));\n      const expected1 = '      ------------(4|)';\n      const subscriber2 = hot('----b|          ').pipe(mergeMapTo(published));\n      const expected2 = '      ------------(4|)';\n      const subscriber3 = hot('--------c|      ').pipe(mergeMapTo(published));\n      const expected3 = '      ------------(4|)';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["publishLast operator"],"updatePoint":{"line":71,"column":69},"line":71,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-#');\n      const sourceSubs = '     ^-----------!';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      ------------#';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ------------#';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ------------#';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not cast any values to multiple observers, when source is unsubscribed explicitly and early","suites":["publishLast operator"],"updatePoint":{"line":92,"column":104},"line":92,"code":"  it('should not cast any values to multiple observers, when source is unsubscribed explicitly and early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const unsub = '          ---------u   ';\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      ----------   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----------   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["publishLast operator"],"updatePoint":{"line":124,"column":83},"line":124,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(\n        mergeMap((x) => of(x)),\n        publishLast()\n      ) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      ----------   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----------   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      ----------   ';\n      const unsub = '          ---------u   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":160,"column":55},"line":160,"code":"    it('should connect when first subscriber subscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^-----------!';\n        const replayed = source.pipe(publishLast(), refCount());\n        const subscriber1 = hot('---a|              ').pipe(mergeMapTo(replayed));\n        const expected1 = '      ---------------(4|)';\n        const subscriber2 = hot('-------b|          ').pipe(mergeMapTo(replayed));\n        const expected2 = '      ---------------(4|)';\n        const subscriber3 = hot('-----------c|      ').pipe(mergeMapTo(replayed));\n        const expected3 = '      ---------------(4|)';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":179,"column":59},"line":179,"code":"    it('should disconnect when last subscriber unsubscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^--------!   ';\n        const replayed = source.pipe(publishLast(), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const unsub1 = '         ----------!     ';\n        const expected1 = '      -----------     ';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const unsub2 = '         ------------!   ';\n        const expected2 = '      -------------   ';\n\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be retryable","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":197,"column":31},"line":197,"code":"    it('should NOT be retryable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-#');\n        const sourceSubs = '     ^-----------!';\n        const published = source.pipe(publishLast(), refCount(), retry(3));\n        const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n        const expected1 = '      ------------#';\n        const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n        const expected2 = '      ------------#';\n        const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n        const expected3 = '      ------------#';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":217,"column":38},"line":217,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const expected = '   |   ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":231,"column":37},"line":231,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const sourceSubs = ' ^';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const expected = '   -';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":245,"column":37},"line":245,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishLast()) as ConnectableObservable<string>;\n      const expected = '   #   ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast one observable to multiple observers","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":259,"column":59},"line":259,"code":"  it('should multicast one observable to multiple observers', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishLast()) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([4]);\n    expect(results2).to.deep.equal([4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["publishLast operator","with refCount()"],"updatePoint":{"line":294,"column":41},"line":294,"code":"  it('should be referentially-transparent', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source1 = cold('-1-2-3-4-5-|   ');\n      const source1Subs = ' ^----------!   ';\n      const expected1 = '   -----------(5|)';\n      const source2 = cold('-6-7-8-9-0-|   ');\n      const source2Subs = ' ^----------!   ';\n      const expected2 = '   -----------(0|)';\n\n      // Calls to the _operator_ must be referentially-transparent.\n      const partialPipeLine = pipe(publishLast());\n\n      // The non-referentially-transparent publishing occurs within the _operator function_\n      // returned by the _operator_ and that happens when the complete pipeline is composed.\n      const published1 = source1.pipe(partialPipeLine) as ConnectableObservable<any>;\n      const published2 = source2.pipe(partialPipeLine) as ConnectableObservable<any>;\n\n      expectObservable(published1).toBe(expected1);\n      expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n      expectObservable(published2).toBe(expected2);\n      expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n\n      published1.connect();\n      published2.connect();\n    });\n  });","file":"operators/publishLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["publishReplay operator"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs = ' ^--------------!';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const expected = '   --1-2---3-4--5-|';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a ConnectableObservable-ish","suites":["publishReplay operator"],"updatePoint":{"line":30,"column":47},"line":30,"code":"  it('should return a ConnectableObservable-ish', () => {\n    const source = of(1).pipe(publishReplay()) as ConnectableObservable<number>;\n    expect(typeof (<any>source)._subscribe === 'function').to.be.true;\n    expect(typeof (<any>source).getSubject === 'function').to.be.true;\n    expect(typeof source.connect === 'function').to.be.true;\n    expect(typeof source.refCount === 'function').to.be.true;\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if connect is not called, despite subscriptions","suites":["publishReplay operator"],"updatePoint":{"line":38,"column":71},"line":38,"code":"  it('should do nothing if connect is not called, despite subscriptions', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs: string[] = [];\n      const published = source.pipe(publishReplay(1));\n      const expected = '   -';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, bufferSize=1","suites":["publishReplay operator"],"updatePoint":{"line":50,"column":74},"line":50,"code":"  it('should multicast the same values to multiple observers, bufferSize=1', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^-----------!';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----4-|';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----4-|';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-4-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, bufferSize=2","suites":["publishReplay operator"],"updatePoint":{"line":71,"column":74},"line":71,"code":"  it('should multicast the same values to multiple observers, bufferSize=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-----3------4-|');\n      const sourceSubs = '     ^-----------------!';\n      const published = source.pipe(publishReplay(2)) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|                 ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-----3------4-|';\n      const subscriber2 = hot('----b|             ').pipe(mergeMapTo(published));\n      const expected2 = '      ----(12)-3------4-|';\n      const subscriber3 = hot('-----------c|      ').pipe(mergeMapTo(published));\n      const expected3 = '      -----------(23)-4-|';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["publishReplay operator"],"updatePoint":{"line":92,"column":69},"line":92,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-#');\n      const sourceSubs = '     ^-----------!';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----4-#';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----4-#';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-4-#';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, but is unsubscribed explicitly and early","suites":["publishReplay operator"],"updatePoint":{"line":113,"column":102},"line":113,"code":"  it('should multicast the same values to multiple observers, but is unsubscribed explicitly and early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const unsub = '          ---------u   ';\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["publishReplay operator"],"updatePoint":{"line":145,"column":83},"line":145,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^--------!   ';\n      const published = source.pipe(\n        mergeMap((x) => of(x)),\n        publishReplay(1)\n      ) as ConnectableObservable<string>;\n      const subscriber1 = hot('a|           ').pipe(mergeMapTo(published));\n      const expected1 = '      -1-2-3----   ';\n      const subscriber2 = hot('----b|       ').pipe(mergeMapTo(published));\n      const expected2 = '      ----23----   ';\n      const subscriber3 = hot('--------c|   ').pipe(mergeMapTo(published));\n      const expected3 = '      --------3-   ';\n      const unsub = '          ---------u   ';\n\n      expectObservable(subscriber1).toBe(expected1);\n      expectObservable(subscriber2).toBe(expected2);\n      expectObservable(subscriber3).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      // Set up unsubscription action\n      let connection: Subscription;\n      expectObservable(\n        hot(unsub).pipe(\n          tap(() => {\n            connection.unsubscribe();\n          })\n        )\n      ).toBe(unsub);\n\n      connection = published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":181,"column":55},"line":181,"code":"    it('should connect when first subscriber subscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^-----------!';\n        const replayed = source.pipe(publishReplay(1), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const expected1 = '      ----1-2-3----4-|';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const expected2 = '      -------23----4-|';\n        const subscriber3 = hot('-----------c|   ').pipe(mergeMapTo(replayed));\n        const expected3 = '      -----------3-4-|';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":200,"column":59},"line":200,"code":"    it('should disconnect when last subscriber unsubscribes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('       -1-2-3----4-|');\n        const sourceSubs = '     ---^--------!   ';\n        const replayed = source.pipe(publishReplay(1), refCount());\n        const subscriber1 = hot('---a|           ').pipe(mergeMapTo(replayed));\n        const unsub1 = '         ----------!     ';\n        const expected1 = '      ----1-2-3--     ';\n        const subscriber2 = hot('-------b|       ').pipe(mergeMapTo(replayed));\n        const unsub2 = '         ------------!   ';\n        const expected2 = '      -------23----   ';\n\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be retryable","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":218,"column":31},"line":218,"code":"    it('should NOT be retryable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-#     ');\n        const sourceSubs = '     ^-----------!     ';\n        const published = source.pipe(publishReplay(1), refCount(), retry(3));\n        const subscriber1 = hot('a|                ').pipe(mergeMapTo(published));\n        const expected1 = '      -1-2-3----4-(444#)';\n        const subscriber2 = hot('----b|            ').pipe(mergeMapTo(published));\n        const expected2 = '      ----23----4-(444#)';\n        const subscriber3 = hot('--------c|        ').pipe(mergeMapTo(published));\n        const expected3 = '      --------3-4-(444#)';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT be repeatable","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":237,"column":32},"line":237,"code":"    it('should NOT be repeatable', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = cold('    -1-2-3----4-|    ');\n        const sourceSubs = '     ^-----------!    ';\n        const published = source.pipe(publishReplay(1), refCount(), repeat(3));\n        const subscriber1 = hot('a|               ').pipe(mergeMapTo(published));\n        const expected1 = '      -1-2-3----4-(44|)';\n        const subscriber2 = hot('----b|           ').pipe(mergeMapTo(published));\n        const expected2 = '      ----23----4-(44|)';\n        const subscriber3 = hot('--------c|       ').pipe(mergeMapTo(published));\n        const expected3 = '      --------3-4-(44|)';\n\n        expectObservable(subscriber1).toBe(expected1);\n        expectObservable(subscriber2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast one observable to multiple observers","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":257,"column":59},"line":257,"code":"  it('should multicast one observable to multiple observers', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishReplay()) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([1, 2, 3, 4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay as many events as specified by the bufferSize","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":291,"column":65},"line":291,"code":"  it('should replay as many events as specified by the bufferSize', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishReplay(2)) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([3, 4]);\n    expect(subscriptions).to.equal(1);\n    done();\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit replayed values and resubscribe to the source when reconnected without source completion","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":326,"column":106},"line":326,"code":"  it('should emit replayed values and resubscribe to the source when reconnected without source completion', () => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      // observer.complete();\n    });\n\n    const connectable = source.pipe(publishReplay(2)) as ConnectableObservable<number>;\n    const subscription1 = connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect().unsubscribe();\n    subscription1.unsubscribe();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([]);\n    expect(subscriptions).to.equal(1);\n\n    const subscription2 = connectable.subscribe((x) => {\n      results2.push(x);\n    });\n\n    connectable.connect().unsubscribe();\n    subscription2.unsubscribe();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([3, 4, 1, 2, 3, 4]);\n    expect(subscriptions).to.equal(2);\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit replayed values plus completed when subscribed after completed","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":367,"column":80},"line":367,"code":"  it('should emit replayed values plus completed when subscribed after completed', (done) => {\n    const results1: number[] = [];\n    const results2: number[] = [];\n    let subscriptions = 0;\n\n    const source = new Observable<number>((observer) => {\n      subscriptions++;\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.next(4);\n      observer.complete();\n    });\n\n    const connectable = source.pipe(publishReplay(2)) as ConnectableObservable<number>;\n\n    connectable.subscribe((x) => {\n      results1.push(x);\n    });\n\n    expect(results1).to.deep.equal([]);\n    expect(results2).to.deep.equal([]);\n\n    connectable.connect();\n\n    expect(results1).to.deep.equal([1, 2, 3, 4]);\n    expect(results2).to.deep.equal([]);\n    expect(subscriptions).to.equal(1);\n\n    connectable.subscribe({\n      next: (x) => {\n        results2.push(x);\n      },\n      error: (x) => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(results2).to.deep.equal([3, 4]);\n        done();\n      },\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":410,"column":38},"line":410,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|  ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const expected = '   |';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":424,"column":37},"line":424,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const sourceSubs = ' ^';\n\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const expected = '   -';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":439,"column":37},"line":439,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#   ');\n      const sourceSubs = ' (^!)';\n      const published = source.pipe(publishReplay(1)) as ConnectableObservable<string>;\n      const expected = '   #   ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n\n      published.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable with selector","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":453,"column":60},"line":453,"code":"  it('should mirror a simple source Observable with selector', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const values = { a: 2, b: 4, c: 6, d: 8 };\n      const selector = (observable: Observable<string>) => observable.pipe(map((v) => 2 * +v));\n      const source = cold('--1-2---3-4---|');\n      const sourceSubs = ' ^-------------!';\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   --a-b---c-d---|';\n\n      expectObservable(published).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should EMIT an error when the selector throws an exception","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":467,"column":64},"line":467,"code":"  it('should EMIT an error when the selector throws an exception', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const error = \"It's broken\";\n      const selector = () => {\n        throw error;\n      };\n      const source = cold('--1-2---3-4---|');\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   #              ';\n\n      expectObservable(published).toBe(expected, undefined, \"It's broken\");\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit an error when the selector returns an Observable that emits an error","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":481,"column":86},"line":481,"code":"  it('should emit an error when the selector returns an Observable that emits an error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const error = \"It's broken\";\n      const innerObservable = cold('--5-6----#', undefined, error);\n      const selector = (observable: Observable<string>) => observable.pipe(mergeMapTo(innerObservable));\n      const source = cold('--1--2---3---|');\n      const sourceSubs = ' ^----------!  ';\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   ----5-65-6-#  ';\n\n      expectObservable(published).toBe(expected, undefined, error);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should terminate immediately when the selector returns an empty Observable","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":496,"column":80},"line":496,"code":"  it('should terminate immediately when the selector returns an empty Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const selector = () => EMPTY;\n      const source = cold('--1--2---3---|');\n      const sourceSubs = ' (^!)          ';\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   |             ';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit and should not complete/error when the selector returns never","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":509,"column":83},"line":509,"code":"  it('should not emit and should not complete/error when the selector returns never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const selector = () => NEVER;\n      const source = cold('-');\n      const sourceSubs = ' ^';\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   -';\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit error when the selector returns Observable.throw","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":522,"column":66},"line":522,"code":"  it('should emit error when the selector returns Observable.throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const error = \"It's broken\";\n      const selector = () => throwError(() => error);\n      const source = cold('--1--2---3---|');\n      const sourceSubs = ' (^!)          ';\n      const published = source.pipe(publishReplay(1, Infinity, selector));\n      const expected = '   #             ';\n\n      expectObservable(published).toBe(expected, undefined, error);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["publishReplay operator","with refCount()"],"updatePoint":{"line":536,"column":41},"line":536,"code":"  it('should be referentially-transparent', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source1 = cold('-1-2-3-4-5-|');\n      const source1Subs = ' ^----------!';\n      const expected1 = '   -1-2-3-4-5-|';\n      const source2 = cold('-6-7-8-9-0-|');\n      const source2Subs = ' ^----------!';\n      const expected2 = '   -6-7-8-9-0-|';\n\n      // Calls to the _operator_ must be referentially-transparent.\n      const partialPipeLine = pipe(publishReplay(1));\n\n      // The non-referentially-transparent publishing occurs within the _operator function_\n      // returned by the _operator_ and that happens when the complete pipeline is composed.\n      const published1 = source1.pipe(partialPipeLine) as ConnectableObservable<any>;\n      const published2 = source2.pipe(partialPipeLine) as ConnectableObservable<any>;\n\n      expectObservable(published1).toBe(expected1);\n      expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n      expectObservable(published2).toBe(expected2);\n      expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n\n      published1.connect();\n      published2.connect();\n    });\n  });","file":"operators/publishReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should race cold and cold","suites":["race operator"],"updatePoint":{"line":17,"column":31},"line":17,"code":"  it('should race cold and cold', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race cold and cold and accept an Array of Observable argument","suites":["race operator"],"updatePoint":{"line":33,"column":74},"line":33,"code":"  it('should race cold and cold and accept an Array of Observable argument', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(race([e2]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and hot","suites":["race operator"],"updatePoint":{"line":49,"column":29},"line":49,"code":"  it('should race hot and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and cold","suites":["race operator"],"updatePoint":{"line":65,"column":30},"line":65,"code":"  it('should race hot and cold', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race 2nd and 1st","suites":["race operator"],"updatePoint":{"line":81,"column":29},"line":81,"code":"  it('should race 2nd and 1st', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ------x-----y-----z----|');\n      const e1subs = '  ^--!                    ';\n      const e2 = cold(' ---a-----b-----c----|   ');\n      const e2subs = '  ^-------------------!   ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race emit and complete","suites":["race operator"],"updatePoint":{"line":97,"column":35},"line":97,"code":"  it('should race emit and complete', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -----|                  ');\n      const e1subs = '  ^----!                  ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^----!                  ';\n      const expected = '-----|                  ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["race operator"],"updatePoint":{"line":113,"column":53},"line":113,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('---a-----b-----c----|   ');\n      const e1subs = ' ^-----------!           ';\n      const e2 = hot(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                   ';\n      const expected = '---a-----b---          ';\n      const unsub = '   ------------!          ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["race operator"],"updatePoint":{"line":130,"column":73},"line":130,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--^--b--c---d-| ');\n      const e1subs = '       ^--------!    ';\n      const e2 = hot('  ---e-^---f--g---h-|');\n      const e2subs = '       ^--!    ';\n      const expected = '     ---b--c---    ';\n      const unsub = '        ---------!    ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        race(e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should never emit when given non emitting sources","suites":["race operator"],"updatePoint":{"line":151,"column":55},"line":151,"code":"  it('should never emit when given non emitting sources', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---|');\n      const e2 = cold(' ---|');\n      const e1subs = '  ^--!';\n      const expected = '---|';\n\n      const source = e1.pipe(race(e2));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs mid stream","suites":["race operator"],"updatePoint":{"line":165,"column":47},"line":165,"code":"  it('should throw when error occurs mid stream', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----#              ');\n      const e1subs = '  ^--------!              ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----#              ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs before a winner is found","suites":["race operator"],"updatePoint":{"line":181,"column":61},"line":181,"code":"  it('should throw when error occurs before a winner is found', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#                    ');\n      const e1subs = '  ^--!                    ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---#                    ';\n\n      const result = e1.pipe(race(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow observable emits immediately","suites":["race operator"],"updatePoint":{"line":197,"column":47},"line":197,"code":"  it('should allow observable emits immediately', (done) => {\n    const e1 = of(true);\n    const e2 = timer(200).pipe(map((_) => false));\n\n    e1.pipe(race(e2)).subscribe({\n      next: (x) => {\n        expect(x).to.be.true;\n      },\n      error: done,\n      complete: done,\n    });\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one emits immediately","suites":["race operator"],"updatePoint":{"line":210,"column":72},"line":210,"code":"  it('should ignore latter observables if a former one emits immediately', () => {\n    const onNext = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = of('a'); // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(race(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('a')).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one completes immediately","suites":["race operator"],"updatePoint":{"line":221,"column":76},"line":221,"code":"  it('should ignore latter observables if a former one completes immediately', () => {\n    const onComplete = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = EMPTY; // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(race(e2)).subscribe({ complete: onComplete });\n    expect(onComplete.calledWithExactly()).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one errors immediately","suites":["race operator"],"updatePoint":{"line":232,"column":73},"line":232,"code":"  it('should ignore latter observables if a former one errors immediately', () => {\n    const onError = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = throwError(() => 'kaboom'); // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(race(e2)).subscribe({ error: onError });\n    expect(onError.calledWithExactly('kaboom')).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe former observables if a latter one emits immediately","suites":["race operator"],"updatePoint":{"line":243,"column":77},"line":243,"code":"  it('should unsubscribe former observables if a latter one emits immediately', () => {\n    const onNext = sinon.spy();\n    const onUnsubscribe = sinon.spy();\n    const e1 = NEVER.pipe(finalize(onUnsubscribe)); // Should be unsubscribed\n    const e2 = of('b'); // Wins the race\n\n    e1.pipe(race(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('b')).to.be.true;\n    expect(onUnsubscribe.calledOnce).to.be.true;\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from immediately emitting observable on unsubscription","suites":["race operator"],"updatePoint":{"line":254,"column":79},"line":254,"code":"  it('should unsubscribe from immediately emitting observable on unsubscription', () => {\n    const onNext = sinon.spy();\n    const onUnsubscribe = sinon.spy();\n    const e1 = <Observable<never>>NEVER.pipe(startWith('a'), finalize(onUnsubscribe)); // Wins the race\n    const e2 = NEVER; // Loses the race\n\n    const subscription = e1.pipe(race(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('a')).to.be.true;\n    expect(onUnsubscribe.called).to.be.false;\n    subscription.unsubscribe();\n    expect(onUnsubscribe.calledOnce).to.be.true;\n  });","file":"operators/race-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should race cold and cold","suites":["raceWith operator"],"updatePoint":{"line":17,"column":31},"line":17,"code":"  it('should race cold and cold', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and hot","suites":["raceWith operator"],"updatePoint":{"line":33,"column":29},"line":33,"code":"  it('should race hot and hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should race hot and cold","suites":["raceWith operator"],"updatePoint":{"line":49,"column":30},"line":49,"code":"  it('should race hot and cold', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-------------------!   ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should race 2nd and 1st","suites":["raceWith operator"],"updatePoint":{"line":65,"column":29},"line":65,"code":"  it('should race 2nd and 1st', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ------x-----y-----z----|');\n      const e1subs = '  ^--!                    ';\n      const e2 = cold(' ---a-----b-----c----|   ');\n      const e2subs = '  ^-------------------!   ';\n      const expected = '---a-----b-----c----|   ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should race emit and complete","suites":["raceWith operator"],"updatePoint":{"line":81,"column":35},"line":81,"code":"  it('should race emit and complete', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -----|                  ');\n      const e1subs = '  ^----!                  ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^----!                  ';\n      const expected = '-----|                  ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["raceWith operator"],"updatePoint":{"line":97,"column":53},"line":97,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----b-----c----|   ');\n      const e1subs = '  ^-----------!           ';\n      const e2 = hot('  ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----b---           ';\n      const unsub = '   ------------!           ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["raceWith operator"],"updatePoint":{"line":114,"column":73},"line":114,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--^--b--c---d-| ');\n      const e1subs = '       ^--------!    ';\n      const e2 = hot('  ---e-^---f--g---h-|');\n      const e2subs = '       ^--!          ';\n      const expected = '     ---b--c---    ';\n      const unsub = '        ---------!    ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        raceWith(e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should never emit when given non emitting sources","suites":["raceWith operator"],"updatePoint":{"line":135,"column":55},"line":135,"code":"  it('should never emit when given non emitting sources', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---|');\n      const e2 = cold(' ---|');\n      const e1subs = '  ^--!';\n      const expected = '---|';\n\n      const source = e1.pipe(raceWith(e2));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs mid stream","suites":["raceWith operator"],"updatePoint":{"line":149,"column":47},"line":149,"code":"  it('should throw when error occurs mid stream', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a-----#              ');\n      const e1subs = '  ^--------!              ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---a-----#              ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw when error occurs before a winner is found","suites":["raceWith operator"],"updatePoint":{"line":165,"column":61},"line":165,"code":"  it('should throw when error occurs before a winner is found', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---#                    ');\n      const e1subs = '  ^--!                    ';\n      const e2 = cold(' ------x-----y-----z----|');\n      const e2subs = '  ^--!                    ';\n      const expected = '---#                    ';\n\n      const result = e1.pipe(raceWith(e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow observable emits immediately","suites":["raceWith operator"],"updatePoint":{"line":181,"column":47},"line":181,"code":"  it('should allow observable emits immediately', (done) => {\n    const e1 = of(true);\n    const e2 = timer(200).pipe(map((_) => false));\n\n    e1.pipe(raceWith(e2)).subscribe({\n      next: (x) => {\n        expect(x).to.be.true;\n      },\n      error: done,\n      complete: done,\n    });\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one emits immediately","suites":["raceWith operator"],"updatePoint":{"line":194,"column":72},"line":194,"code":"  it('should ignore latter observables if a former one emits immediately', () => {\n    const onNext = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = of('a'); // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(raceWith(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('a')).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one completes immediately","suites":["raceWith operator"],"updatePoint":{"line":205,"column":76},"line":205,"code":"  it('should ignore latter observables if a former one completes immediately', () => {\n    const onComplete = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = EMPTY; // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(raceWith(e2)).subscribe({ complete: onComplete });\n    expect(onComplete.calledWithExactly()).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore latter observables if a former one errors immediately","suites":["raceWith operator"],"updatePoint":{"line":216,"column":73},"line":216,"code":"  it('should ignore latter observables if a former one errors immediately', () => {\n    const onError = sinon.spy();\n    const onSubscribe = sinon.spy() as any;\n    const e1 = throwError(() => 'kaboom'); // Wins the race\n    const e2 = defer(onSubscribe); // Should be ignored\n\n    e1.pipe(raceWith(e2)).subscribe({ error: onError });\n    expect(onError.calledWithExactly('kaboom')).to.be.true;\n    expect(onSubscribe.called).to.be.false;\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe former observables if a latter one emits immediately","suites":["raceWith operator"],"updatePoint":{"line":227,"column":77},"line":227,"code":"  it('should unsubscribe former observables if a latter one emits immediately', () => {\n    const onNext = sinon.spy();\n    const onUnsubscribe = sinon.spy();\n    const e1 = NEVER.pipe(finalize(onUnsubscribe)); // Should be unsubscribed\n    const e2 = of('b'); // Wins the race\n\n    e1.pipe(raceWith(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('b')).to.be.true;\n    expect(onUnsubscribe.calledOnce).to.be.true;\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from immediately emitting observable on unsubscription","suites":["raceWith operator"],"updatePoint":{"line":238,"column":79},"line":238,"code":"  it('should unsubscribe from immediately emitting observable on unsubscription', () => {\n    const onNext = sinon.spy();\n    const onUnsubscribe = sinon.spy();\n    const e1 = <Observable<never>>NEVER.pipe(startWith('a'), finalize(onUnsubscribe)); // Wins the race\n    const e2 = NEVER; // Loses the race\n\n    const subscription = e1.pipe(raceWith(e2)).subscribe(onNext);\n    expect(onNext.calledWithExactly('a')).to.be.true;\n    expect(onUnsubscribe.called).to.be.false;\n    subscription.unsubscribe();\n    expect(onUnsubscribe.calledOnce).to.be.true;\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["raceWith operator"],"updatePoint":{"line":251,"column":73},"line":251,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(raceWith(of(0)), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/raceWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce","suites":["reduce"],"updatePoint":{"line":16,"column":19},"line":16,"code":"  it('should reduce', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values = { a: 1, b: 3, c: 5, x: 9 };\n      const e1 = hot('  --a--b--c--|   ', values);\n      const e1subs = '  ^----------!   ';\n      const expected = '-----------(x|)';\n\n      const result = e1.pipe(reduce((o, x) => o + x, 0));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce with seed","suites":["reduce"],"updatePoint":{"line":30,"column":29},"line":30,"code":"  it('should reduce with seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|   ');\n      const e1subs = '  ^-------!   ';\n      const expected = '--------(x|)';\n\n      const result = e1.pipe(reduce((o, x) => o + ' ' + x, 'n'));\n\n      expectObservable(result).toBe(expected, { x: 'n a b' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce with a seed of undefined","suites":["reduce"],"updatePoint":{"line":43,"column":44},"line":43,"code":"  it('should reduce with a seed of undefined', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|   ');\n      const e1subs = '     ^--------------------!   ';\n      const expected = '   ---------------------(x|)';\n\n      const result = e1.pipe(reduce((o: string | undefined, x) => o + ' ' + x, undefined));\n\n      expectObservable(result).toBe(expected, { x: 'undefined b c d e f g' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce without a seed","suites":["reduce"],"updatePoint":{"line":56,"column":34},"line":56,"code":"  it('should reduce without a seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|   ');\n      const e1subs = '     ^--------------------!   ';\n      const expected = '   ---------------------(x|)';\n\n      const result = e1.pipe(reduce((o, x) => o + ' ' + x));\n\n      expectObservable(result).toBe(expected, { x: 'b c d e f g' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce with index without seed","suites":["reduce"],"updatePoint":{"line":69,"column":43},"line":69,"code":"  it('should reduce with index without seed', () => {\n    const idx = [1, 2, 3, 4, 5];\n\n    range(0, 6)\n      .pipe(\n        reduce((acc, value, index) => {\n          expect(idx.shift()).to.equal(index);\n          return value;\n        })\n      )\n      .subscribe({\n        complete() {\n          expect(idx).to.be.empty;\n        },\n      });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce with index with seed","suites":["reduce"],"updatePoint":{"line":86,"column":40},"line":86,"code":"  it('should reduce with index with seed', () => {\n    const idx = [0, 1, 2, 3, 4, 5];\n\n    range(0, 6)\n      .pipe(\n        reduce((acc, value, index) => {\n          expect(idx.shift()).to.equal(index);\n          return value;\n        }, -1)\n      )\n      .subscribe({\n        complete() {\n          expect(idx).to.be.empty;\n        },\n      });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce with seed if source is empty","suites":["reduce"],"updatePoint":{"line":103,"column":48},"line":103,"code":"  it('should reduce with seed if source is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^-------|   ');\n      const e1subs = '     ^-------!   ';\n      const expected = '   --------(x|)';\n\n      const result = e1.pipe(reduce((o, x) => o + x, '42'));\n\n      expectObservable(result).toBe(expected, { x: '42' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if reduce function throws without seed","suites":["reduce"],"updatePoint":{"line":116,"column":63},"line":116,"code":"  it('should raise error if reduce function throws without seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^----!   ';\n      const expected = '-----#   ';\n\n      const result = e1.pipe(\n        reduce(() => {\n          throw 'error';\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["reduce"],"updatePoint":{"line":133,"column":53},"line":133,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-----!  ';\n      const expected = '-------  ';\n      const unsub = '   ------!  ';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["reduce"],"updatePoint":{"line":147,"column":83},"line":147,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-----!  ';\n      const expected = '-------  ';\n      const unsub = '   ------!  ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        reduce((o, x) => o + x),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source emits and raises error with seed","suites":["reduce"],"updatePoint":{"line":165,"column":67},"line":165,"code":"  it('should raise error if source emits and raises error with seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const expected = '--------#';\n\n      const result = e1.pipe(reduce((o, x) => o + x, '42'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error with seed","suites":["reduce"],"updatePoint":{"line":178,"column":57},"line":178,"code":"  it('should raise error if source raises error with seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----#');\n      const e1subs = '  ^---!';\n      const expected = '----#';\n\n      const result = e1.pipe(reduce((o, x) => o + x, '42'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if reduce function throws with seed","suites":["reduce"],"updatePoint":{"line":191,"column":60},"line":191,"code":"  it('should raise error if reduce function throws with seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const e1subs = '  ^-!      ';\n      const expected = '--#      ';\n\n      const result = e1.pipe(\n        reduce(() => {\n          throw 'error';\n        }, 'n')\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete with seed if source emits but does not complete","suites":["reduce"],"updatePoint":{"line":208,"column":73},"line":208,"code":"  it('should not complete with seed if source emits but does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--');\n      const e1subs = '  ^----';\n      const expected = '-----';\n\n      const result = e1.pipe(reduce((o, x) => o + x, 'n'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete with seed if source never completes","suites":["reduce"],"updatePoint":{"line":221,"column":61},"line":221,"code":"  it('should not complete with seed if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(reduce((o, x) => o + x, 'n'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete without seed if source emits but does not completes","suites":["reduce"],"updatePoint":{"line":234,"column":77},"line":234,"code":"  it('should not complete without seed if source emits but does not completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--');\n      const e1subs = '  ^-------';\n      const expected = '--------';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete without seed if source never completes","suites":["reduce"],"updatePoint":{"line":247,"column":64},"line":247,"code":"  it('should not complete without seed if source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce if source does not emit without seed","suites":["reduce"],"updatePoint":{"line":260,"column":56},"line":260,"code":"  it('should reduce if source does not emit without seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^-------|');\n      const e1subs = '     ^-------!';\n      const expected = '   --------|';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source emits and raises error without seed","suites":["reduce"],"updatePoint":{"line":273,"column":70},"line":273,"code":"  it('should raise error if source emits and raises error without seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--#');\n      const e1subs = '  ^-------!';\n      const expected = '--------#';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error without seed","suites":["reduce"],"updatePoint":{"line":286,"column":60},"line":286,"code":"  it('should raise error if source raises error without seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----#');\n      const e1subs = '  ^---!';\n      const expected = '----#';\n\n      const result = e1.pipe(reduce((o, x) => o + x));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/reduce-spec.ts","skipped":false,"dir":"spec"},{"name":"should turn a multicasted Observable an automatically (dis)connecting hot one","suites":["refCount"],"updatePoint":{"line":10,"column":83},"line":10,"code":"  it('should turn a multicasted Observable an automatically (dis)connecting hot one', () => {\n    const testScheduler = new TestScheduler(observableMatcher);\n\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1-2---3-4--5-|');\n      const e1Subs = '  ^--------------!';\n      const expected = '--1-2---3-4--5-|';\n\n      const result = e1.pipe(publish(), refCount());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1Subs);\n    });\n  });","file":"operators/refCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should count references","suites":["refCount"],"updatePoint":{"line":25,"column":29},"line":25,"code":"  it('should count references', () => {\n    const connectable = NEVER.pipe(publish());\n    const refCounted = connectable.pipe(refCount());\n\n    const sub1 = refCounted.subscribe({\n      next: noop,\n    });\n    const sub2 = refCounted.subscribe({\n      next: noop,\n    });\n    const sub3 = refCounted.subscribe({\n      next: noop,\n    });\n\n    expect((connectable as any)._refCount).to.equal(3);\n\n    sub1.unsubscribe();\n    sub2.unsubscribe();\n    sub3.unsubscribe();\n  });","file":"operators/refCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsub from the source when all other subscriptions are unsubbed","suites":["refCount"],"updatePoint":{"line":46,"column":76},"line":46,"code":"  it('should unsub from the source when all other subscriptions are unsubbed', (done) => {\n    let unsubscribeCalled = false;\n    const connectable = new Observable<boolean>((observer) => {\n      observer.next(true);\n      return () => {\n        unsubscribeCalled = true;\n      };\n    }).pipe(publish());\n\n    const refCounted = connectable.pipe(refCount());\n\n    const sub1 = refCounted.subscribe(() => {\n      //noop\n    });\n    const sub2 = refCounted.subscribe(() => {\n      //noop\n    });\n    const sub3 = refCounted.subscribe(() => {\n      expect((connectable as any)._refCount).to.equal(1);\n    });\n\n    sub1.unsubscribe();\n    sub2.unsubscribe();\n    sub3.unsubscribe();\n\n    expect((connectable as any)._refCount).to.equal(0);\n    expect(unsubscribeCalled).to.be.true;\n    done();\n  });","file":"operators/refCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present","suites":["refCount"],"updatePoint":{"line":76,"column":106},"line":76,"code":"  it('should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present', () => {\n    let unsubscribeCalled = false;\n    const connectable = new Observable<boolean>((observer) => {\n      observer.next(true);\n      return () => {\n        unsubscribeCalled = true;\n      };\n    }).pipe(publishReplay(1));\n\n    const refCounted = connectable.pipe(refCount());\n\n    refCounted.subscribe();\n    refCounted.subscribe().unsubscribe();\n\n    expect((connectable as any)._refCount).to.equal(1);\n    expect(unsubscribeCalled).to.be.false;\n  });","file":"operators/refCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present and the source is a Subject","suites":["refCount"],"updatePoint":{"line":94,"column":134},"line":94,"code":"  it('should not unsubscribe when a subscriber synchronously unsubscribes if other subscribers are present and the source is a Subject', () => {\n    const arr: string[] = [];\n    const subject = new Subject<string>();\n    const connectable = subject.pipe(publishReplay(1));\n    const refCounted = connectable.pipe(refCount());\n\n    refCounted.subscribe((val) => {\n      arr.push(val);\n    });\n\n    subject.next('the number one');\n\n    refCounted.pipe(first()).subscribe().unsubscribe();\n\n    subject.next('the number two');\n\n    expect((connectable as any)._refCount).to.equal(1);\n    expect(arr[0]).to.equal('the number one');\n    expect(arr[1]).to.equal('the number two');\n  });","file":"operators/refCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should resubscribe count number of times","suites":["repeat operator"],"updatePoint":{"line":16,"column":46},"line":16,"code":"  it('should resubscribe count number of times', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                ');\n      const subs = [\n        '               ^-------!                ', //\n        '               --------^-------!        ',\n        '               ----------------^-------!',\n      ];\n      const expected = '--a--b----a--b----a--b--|';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should resubscribe multiple times","suites":["repeat operator"],"updatePoint":{"line":31,"column":39},"line":31,"code":"  it('should resubscribe multiple times', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                        ');\n      const subs = [\n        '               ^-------!                        ',\n        '               --------^-------!                ',\n        '               ----------------^-------!        ',\n        '               ------------------------^-------!',\n      ];\n      const expected = '--a--b----a--b----a--b----a--b--|';\n\n      expectObservable(e1.pipe(repeat(2), repeat(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without emit when count is zero","suites":["repeat operator"],"updatePoint":{"line":47,"column":53},"line":47,"code":"  it('should complete without emit when count is zero', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('--a--b--|');\n      const subs: string[] = [];\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit source once when count is one","suites":["repeat operator"],"updatePoint":{"line":58,"column":47},"line":58,"code":"  it('should emit source once when count is one', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|');\n      const subs = '    ^-------!';\n      const expected = '--a--b--|';\n\n      expectObservable(e1.pipe(repeat(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should repeat until gets unsubscribed","suites":["repeat operator"],"updatePoint":{"line":69,"column":43},"line":69,"code":"  it('should repeat until gets unsubscribed', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|      ');\n      const subs = [\n        '               ^-------!      ', //\n        '               --------^------!',\n      ];\n      const unsub = '   ---------------!';\n      const expected = '--a--b----a--b-';\n\n      expectObservable(e1.pipe(repeat(10)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to repeat indefinitely until unsubscribed","suites":["repeat operator"],"updatePoint":{"line":84,"column":62},"line":84,"code":"  it('should be able to repeat indefinitely until unsubscribed', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                                    ');\n      const subs = [\n        '               ^-------!                                    ',\n        '               --------^-------!                            ',\n        '               ----------------^-------!                    ',\n        '               ------------------------^-------!            ',\n        '               --------------------------------^-------!    ',\n        '               ----------------------------------------^---!',\n      ];\n      const unsub = '   --------------------------------------------!';\n      const expected = '--a--b----a--b----a--b----a--b----a--b----a--';\n\n      expectObservable(e1.pipe(repeat()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["repeat operator"],"updatePoint":{"line":103,"column":72},"line":103,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                                    ');\n      const subs = [\n        '               ^-------!                                    ',\n        '               --------^-------!                            ',\n        '               ----------------^-------!                    ',\n        '               ------------------------^-------!            ',\n        '               --------------------------------^-------!    ',\n        '               ----------------------------------------^---!',\n      ];\n      const unsub = '   --------------------------------------------!';\n      const expected = '--a--b----a--b----a--b----a--b----a--b----a--';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        repeat(),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should consider negative count as no repeat, and return EMPTY","suites":["repeat operator"],"updatePoint":{"line":128,"column":67},"line":128,"code":"  it('should consider negative count as no repeat, and return EMPTY', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('--a--b--|                                    ');\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(-1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe([]);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should always finalization before starting the next cycle","suites":["repeat operator"],"updatePoint":{"line":138,"column":63},"line":138,"code":"  it('should always finalization before starting the next cycle', async () => {\n    const results: any[] = [];\n    const source = new Observable<number>((subscriber) => {\n      Promise.resolve().then(() => {\n        subscriber.next(1);\n        Promise.resolve().then(() => {\n          subscriber.next(2);\n          Promise.resolve().then(() => {\n            subscriber.complete();\n          });\n        });\n      });\n      return () => {\n        results.push('finalizer');\n      };\n    });\n\n    await source.pipe(repeat(3)).forEach((value) => results.push(value));\n\n    expect(results).to.deep.equal([1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'finalizer']);\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should always finalize before starting the next cycle, even when synchronous","suites":["repeat operator"],"updatePoint":{"line":160,"column":82},"line":160,"code":"  it('should always finalize before starting the next cycle, even when synchronous', () => {\n    const results: any[] = [];\n    const source = new Observable<number>((subscriber) => {\n      subscriber.next(1);\n      subscriber.next(2);\n      subscriber.complete();\n      return () => {\n        results.push('finalizer');\n      };\n    });\n    const subscription = source.pipe(repeat(3)).subscribe({\n      next: (value) => results.push(value),\n      complete: () => results.push('complete'),\n    });\n\n    expect(subscription.closed).to.be.true;\n    expect(results).to.deep.equal([1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'complete', 'finalizer']);\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source never completes","suites":["repeat operator"],"updatePoint":{"line":179,"column":53},"line":179,"code":"  it('should not complete when source never completes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const e1subs = '^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source does not completes","suites":["repeat operator"],"updatePoint":{"line":190,"column":56},"line":190,"code":"  it('should not complete when source does not completes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const unsub = '------------------------------!';\n      const subs = ' ^-----------------------------!';\n      const expected = '-';\n\n      expectObservable(e1.pipe(repeat(3)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete immediately when source does not complete without emit but count is zero","suites":["repeat operator"],"updatePoint":{"line":202,"column":94},"line":202,"code":"  it('should complete immediately when source does not complete without emit but count is zero', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('-');\n      const subs: string[] = [];\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete immediately when source does not complete but count is zero","suites":["repeat operator"],"updatePoint":{"line":213,"column":81},"line":213,"code":"  it('should complete immediately when source does not complete but count is zero', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('--a--b--');\n      const subs: string[] = [];\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit source once and does not complete when source emits but does not complete","suites":["repeat operator"],"updatePoint":{"line":224,"column":91},"line":224,"code":"  it('should emit source once and does not complete when source emits but does not complete', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--');\n      const subs = ['   ^-------'];\n      const expected = '--a--b--';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source is empty","suites":["repeat operator"],"updatePoint":{"line":235,"column":42},"line":235,"code":"  it('should complete when source is empty', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('|');\n      const e1subs = ['(^!)', '(^!)', '(^!)'];\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["repeat operator"],"updatePoint":{"line":246,"column":47},"line":246,"code":"  it('should complete when source does not emit', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('----|        ');\n      const subs = [\n        '              ^---!        ', //\n        '              ----^---!    ',\n        '              --------^---!',\n      ];\n      const expected = '------------|';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete immediately when source does not emit but count is zero","suites":["repeat operator"],"updatePoint":{"line":261,"column":77},"line":261,"code":"  it('should complete immediately when source does not emit but count is zero', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('----|');\n      const subs: string[] = [];\n      const expected = '|';\n\n      expectObservable(e1.pipe(repeat(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error","suites":["repeat operator"],"updatePoint":{"line":272,"column":49},"line":272,"code":"  it('should raise error when source raises error', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--#');\n      const subs = '    ^-------!';\n      const expected = '--a--b--#';\n\n      expectObservable(e1.pipe(repeat(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error if source throws","suites":["repeat operator"],"updatePoint":{"line":283,"column":42},"line":283,"code":"  it('should raises error if source throws', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('#');\n      const e1subs = '(^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(repeat(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raises error if source throws when repeating infinitely","suites":["repeat operator"],"updatePoint":{"line":294,"column":68},"line":294,"code":"  it('should raises error if source throws when repeating infinitely', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('#');\n      const e1subs = '(^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(repeat())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error after first emit succeed","suites":["repeat operator"],"updatePoint":{"line":305,"column":49},"line":305,"code":"  it('should raise error after first emit succeed', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      let repeated = false;\n\n      const e1 = cold('--a--|').pipe(\n        map((x: string) => {\n          if (repeated) {\n            throw 'error';\n          } else {\n            repeated = true;\n            return x;\n          }\n        })\n      );\n      const expected = '--a----#';\n\n      expectObservable(e1.pipe(repeat(2))).toBe(expected);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should repeat a synchronous source (multicasted and refCounted) multiple times","suites":["repeat operator"],"updatePoint":{"line":325,"column":84},"line":325,"code":"  it('should repeat a synchronous source (multicasted and refCounted) multiple times', (done) => {\n    const expected = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3];\n\n    of(1, 2, 3)\n      .pipe(\n        multicast(() => new Subject<number>()),\n        refCount(),\n        repeat(5)\n      )\n      .subscribe({\n        next: (x: number) => {\n          expect(x).to.equal(expected.shift());\n        },\n        error: (x) => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["repeat operator"],"updatePoint":{"line":348,"column":73},"line":348,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(repeat(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow count configuration","suites":["repeat operator"],"updatePoint":{"line":366,"column":38},"line":366,"code":"  it('should allow count configuration', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                ');\n      const subs = [\n        '               ^-------!                ', //\n        '               --------^-------!        ',\n        '               ----------------^-------!',\n      ];\n      const expected = '--a--b----a--b----a--b--|';\n\n      expectObservable(e1.pipe(repeat({ count: 3 }))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow delay time configuration","suites":["repeat operator"],"updatePoint":{"line":381,"column":43},"line":381,"code":"  it('should allow delay time configuration', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a--b--|                ');\n      const delay = 3; //       ---|       ---|\n      const subs = [\n        '               ^-------!                ', //\n        '               -----------^-------!        ',\n        '               ----------------------^-------!',\n      ];\n      const expected = '--a--b-------a--b-------a--b--|';\n\n      expectObservable(e1.pipe(repeat({ count: 3, delay }))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow delay function configuration","suites":["repeat operator"],"updatePoint":{"line":397,"column":47},"line":397,"code":"  it('should allow delay function configuration', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const expectedCounts = [1, 2, 3];\n\n      const e1 = cold(' --a--b--|                ');\n      const delay = 3; //       ---|       ---|\n      const subs = [\n        '               ^-------!                ', //\n        '               -----------^-------!        ',\n        '               ----------------------^-------!',\n      ];\n      const expected = '--a--b-------a--b-------a--b--|';\n\n      expectObservable(\n        e1.pipe(\n          repeat({\n            count: 3,\n            delay: (count) => {\n              expect(count).to.equal(expectedCounts.shift());\n              return timer(delay);\n            },\n          })\n        )\n      ).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle delay function throwing","suites":["repeat operator"],"updatePoint":{"line":425,"column":43},"line":425,"code":"  it('should handle delay function throwing', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const expectedCounts = [1, 2, 3];\n\n      const e1 = cold(' --a--b--|                ');\n      const delay = 3; //       ---|       ---|\n      const subs = [\n        '               ^-------!                ', //\n        '               -----------^-------!        ',\n      ];\n      const expected = '--a--b-------a--b--#';\n\n      expectObservable(\n        e1.pipe(\n          repeat({\n            count: 3,\n            delay: (count) => {\n              if (count === 2) {\n                throw 'bad';\n              }\n              return timer(delay);\n            },\n          })\n        )\n      ).toBe(expected, undefined, 'bad');\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeat-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual complete using a hot notifier","suites":["repeatWhen operator"],"updatePoint":{"line":17,"column":72},"line":17,"code":"  it('should handle a source with eventual complete using a hot notifier', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('-1--2--|');\n      //                                 -1--2--|\n      //                                              -1--2--|\n      const subs = [\n        '                  ^------!                          ',\n        '                  -------------^------!             ',\n        '                  --------------------------^------!',\n      ];\n      const notifier = hot('-------------r------------r-|    ');\n      const expected = '    -1--2---------1--2---------1--2--|';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual complete using a hot notifier that raises error","suites":["repeatWhen operator"],"updatePoint":{"line":37,"column":90},"line":37,"code":"  it('should handle a source with eventual complete using a hot notifier that raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--|');\n      const subs = [\n        '                   ^------!                      ',\n        '                   -----------^------!           ',\n        '                   -------------------^------!   ',\n      ];\n      const notifier = hot('-----------r-------r---------#');\n      const expected = '    -1--2-------1--2----1--2-----#';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should repeat when notified via returned notifier on complete","suites":["repeatWhen operator"],"updatePoint":{"line":55,"column":67},"line":55,"code":"  it('should repeat when notified via returned notifier on complete', (done) => {\n    let retried = false;\n    const expected = [1, 2, 1, 2];\n    let i = 0;\n    try {\n      of(1, 2)\n        .pipe(\n          map((n: number) => {\n            return n;\n          }),\n          repeatWhen((notifications: any) =>\n            notifications.pipe(\n              map((x: any) => {\n                if (retried) {\n                  throw new Error('done');\n                }\n                retried = true;\n                return x;\n              })\n            )\n          )\n        )\n        .subscribe({\n          next: (x: any) => {\n            expect(x).to.equal(expected[i++]);\n          },\n          error: (err: any) => {\n            expect(err).to.be.an('error', 'done');\n            done();\n          },\n        });\n    } catch (err) {\n      done(err);\n    }\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not repeat when applying an empty notifier","suites":["repeatWhen operator"],"updatePoint":{"line":91,"column":55},"line":91,"code":"  it('should not repeat when applying an empty notifier', (done) => {\n    const expected = [1, 2];\n    const nexted: number[] = [];\n    of(1, 2)\n      .pipe(\n        map((n: number) => {\n          return n;\n        }),\n        repeatWhen((notifications: any) => EMPTY)\n      )\n      .subscribe({\n        next: (n: number) => {\n          expect(n).to.equal(expected.shift());\n          nexted.push(n);\n        },\n        error: (err: any) => {\n          done(new Error('should not be called'));\n        },\n        complete: () => {\n          expect(nexted).to.deep.equal([1, 2]);\n          done();\n        },\n      });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not error when applying an empty synchronous notifier","suites":["repeatWhen operator"],"updatePoint":{"line":116,"column":66},"line":116,"code":"  it('should not error when applying an empty synchronous notifier', () => {\n    const errors: any[] = [];\n    // The current Subscriber.prototype.error implementation does nothing for\n    // stopped subscribers. This test was written to fail and expose a problem\n    // with synchronous notifiers. However, by the time the error occurs the\n    // subscriber is stopped, so the test logs errors by both patching the\n    // prototype and by using an error callback (for when/if the do-nothing-if-\n    // stopped behaviour is fixed).\n    const originalSubscribe = Observable.prototype.subscribe;\n    Observable.prototype.subscribe = function (...args: any[]): any {\n      let [subscriber] = args;\n      if (!(subscriber instanceof Subscriber)) {\n        subscriber = new SafeSubscriber(...args);\n      }\n      subscriber.error = function (err: any): void {\n        errors.push(err);\n        Subscriber.prototype.error.call(this, err);\n      };\n      return originalSubscribe.call(this, subscriber);\n    };\n    of(1, 2)\n      .pipe(repeatWhen((notifications: any) => EMPTY))\n      .subscribe({ error: (err) => errors.push(err) });\n    Observable.prototype.subscribe = originalSubscribe;\n    expect(errors).to.deep.equal([]);\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not error when applying a non-empty synchronous notifier","suites":["repeatWhen operator"],"updatePoint":{"line":143,"column":69},"line":143,"code":"  it('should not error when applying a non-empty synchronous notifier', () => {\n    const errors: any[] = [];\n    // The current Subscriber.prototype.error implementation does nothing for\n    // stopped subscribers. This test was written to fail and expose a problem\n    // with synchronous notifiers. However, by the time the error occurs the\n    // subscriber is stopped, so the test logs errors by both patching the\n    // prototype and by using an error callback (for when/if the do-nothing-if-\n    // stopped behaviour is fixed).\n    const originalSubscribe = Observable.prototype.subscribe;\n    Observable.prototype.subscribe = function (...args: any[]): any {\n      let [subscriber] = args;\n      if (!(subscriber instanceof Subscriber)) {\n        subscriber = new SafeSubscriber(...args);\n      }\n      subscriber.error = function (err: any): void {\n        errors.push(err);\n        Subscriber.prototype.error.call(this, err);\n      };\n      return originalSubscribe.call(this, subscriber);\n    };\n    of(1, 2)\n      .pipe(repeatWhen((notifications: any) => of(1)))\n      .subscribe({ error: (err) => errors.push(err) });\n    Observable.prototype.subscribe = originalSubscribe;\n    expect(errors).to.deep.equal([]);\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply an empty notifier on an empty source","suites":["repeatWhen operator"],"updatePoint":{"line":170,"column":55},"line":170,"code":"  it('should apply an empty notifier on an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |   ');\n      const subs = '         (^!)';\n      const notifier = cold('|   ');\n      const expected = '     |   ';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply a never notifier on an empty source","suites":["repeatWhen operator"],"updatePoint":{"line":184,"column":54},"line":184,"code":"  it('should apply a never notifier on an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |   ');\n      const subs = '         (^!)';\n      const notifier = cold('-   ');\n      const expected = '     -   ';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply an empty notifier on a never source","suites":["repeatWhen operator"],"updatePoint":{"line":198,"column":54},"line":198,"code":"  it('should apply an empty notifier on a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  -                                         ');\n      const unsub = '        -----------------------------------------!';\n      const subs = '         ^----------------------------------------!';\n      const notifier = cold('|                                         ');\n      const expected = '     -                                         ';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply a never notifier on a never source","suites":["repeatWhen operator"],"updatePoint":{"line":213,"column":53},"line":213,"code":"  it('should apply a never notifier on a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  -                                         ');\n      const unsub = '        -----------------------------------------!';\n      const subs = '         ^----------------------------------------!';\n      const notifier = cold('-                                        ');\n      const expected = '     -                                        ';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should return an empty observable given a just-throw source and empty notifier","suites":["repeatWhen operator"],"updatePoint":{"line":228,"column":84},"line":228,"code":"  it('should return an empty observable given a just-throw source and empty notifier', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const source = cold('  #');\n      const notifier = cold('|');\n      const expected = '     #';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a error observable given a just-throw source and never notifier","suites":["repeatWhen operator"],"updatePoint":{"line":240,"column":83},"line":240,"code":"  it('should return a error observable given a just-throw source and never notifier', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const source = cold('  #');\n      const notifier = cold('-');\n      const expected = '     #';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a never-ending result if the notifier is never","suites":["repeatWhen operator"],"updatePoint":{"line":252,"column":66},"line":252,"code":"  it('should return a never-ending result if the notifier is never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--|                              ');\n      const subs = '         ^----------!                              ';\n      const notifier = cold('           -                              ');\n      const expected = '     --a--b--c---------------------------------';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from notifierSelector function","suites":["repeatWhen operator"],"updatePoint":{"line":266,"column":66},"line":266,"code":"  it('should propagate error thrown from notifierSelector function', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--a--b--c--|');\n      const subs = '       ^----------!';\n      const expected = '   --a--b--c--#';\n\n      const result = source.pipe(\n        repeatWhen(<any>(() => {\n          throw 'bad!';\n        }))\n      );\n\n      expectObservable(result).toBe(expected, undefined, 'bad!');\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if the notifier only completes","suites":["repeatWhen operator"],"updatePoint":{"line":283,"column":52},"line":283,"code":"  it('should complete if the notifier only completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--|');\n      const subs = '         ^----------!';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c--|';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic cold source with complete, given a never notifier","suites":["repeatWhen operator"],"updatePoint":{"line":297,"column":77},"line":297,"code":"  it('should mirror a basic cold source with complete, given a never notifier', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--|');\n      const subs = '         ^----------!';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c--|';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic cold source with no termination, given a never notifier","suites":["repeatWhen operator"],"updatePoint":{"line":311,"column":83},"line":311,"code":"  it('should mirror a basic cold source with no termination, given a never notifier', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c---');\n      const subs = '         ^-----------';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c---';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic hot source with complete, given a never notifier","suites":["repeatWhen operator"],"updatePoint":{"line":325,"column":76},"line":325,"code":"  it('should mirror a basic hot source with complete, given a never notifier', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-a-^--b--c--|');\n      const subs = '         ^--------!';\n      const notifier = cold('         |');\n      const expected = '     ---b--c--|';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a host source that completes via operator like take, and a hot notifier","suites":["repeatWhen operator"],"line":340,"code":"  it.skip('should handle a host source that completes via operator like take, and a hot notifier', () => {","file":"operators/repeatWhen-spec.ts","skipped":true,"dir":"spec"},{"name":"should tear down resources when result is unsubscribed early","suites":["repeatWhen operator"],"updatePoint":{"line":363,"column":66},"line":363,"code":"  it('should tear down resources when result is unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--|');\n      const unsub = '       --------------------!       ';\n      const subs = [\n        '                   ^------!                    ',\n        '                   ---------^------!           ',\n        '                   -----------------^--!       ',\n      ];\n      const notifier = hot('---------r-------r---------#');\n      const nsubs = '       -------^------------!       ';\n      const expected = '    -1--2-----1--2----1--       ';\n\n      const result = source.pipe(repeatWhen((notifications: any) => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(notifier.subscriptions).toBe(nsubs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["repeatWhen operator"],"updatePoint":{"line":384,"column":73},"line":384,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--|');\n      const subs = [\n        '                   ^------!                    ',\n        '                   ---------^------!           ',\n        '                   -----------------^--!       ',\n      ];\n      const notifier = hot('---------r-------r-------r-#');\n      const nsubs = '       -------^------------!       ';\n      const expected = '    -1--2-----1--2----1--       ';\n      const unsub = '       --------------------!       ';\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        repeatWhen((notifications: any) => notifier),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(notifier.subscriptions).toBe(nsubs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a dynamic notifier selector which eventually throws","suites":["repeatWhen operator"],"updatePoint":{"line":409,"column":106},"line":409,"code":"  it('should handle a source with eventual error using a dynamic notifier selector which eventually throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-1--2--|');\n      const subs = [\n        '                  ^------!              ',\n        '                  -------^------!       ',\n        '                  --------------^------!',\n      ];\n      const expected = '   -1--2---1--2---1--2--#';\n\n      let invoked = 0;\n      const result = source.pipe(\n        repeatWhen((notifications: any) =>\n          notifications.pipe(\n            map((err: any) => {\n              if (++invoked === 3) {\n                throw 'error';\n              } else {\n                return 'x';\n              }\n            })\n          )\n        )\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a dynamic notifier selector which eventually completes","suites":["repeatWhen operator"],"updatePoint":{"line":439,"column":109},"line":439,"code":"  it('should handle a source with eventual error using a dynamic notifier selector which eventually completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-1--2--|');\n      const subs = [\n        '                  ^------!              ',\n        '                  -------^------!       ',\n        '                  --------------^------!',\n      ];\n      const expected = '   -1--2---1--2---1--2--|';\n\n      let invoked = 0;\n      const result = source.pipe(\n        repeatWhen((notifications: any) =>\n          notifications.pipe(\n            map(() => 'x'),\n            takeUntil(\n              notifications.pipe(\n                mergeMap(() => {\n                  if (++invoked < 3) {\n                    return EMPTY;\n                  } else {\n                    return of('stop!');\n                  }\n                })\n              )\n            )\n          )\n        )\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should always finalize before starting the next cycle, even when synchronous","suites":["repeatWhen operator"],"updatePoint":{"line":474,"column":82},"line":474,"code":"  it('should always finalize before starting the next cycle, even when synchronous', () => {\n    const results: any[] = [];\n    const source = new Observable<number>((subscriber) => {\n      subscriber.next(1);\n      subscriber.next(2);\n      subscriber.complete();\n      return () => {\n        results.push('finalizer');\n      }\n    });\n    const subscription = source.pipe(repeatWhen((completions$) => completions$.pipe(takeWhile((_, i) => i < 3)))).subscribe({\n      next: (value) => results.push(value),\n      complete: () => results.push('complete'),\n    });\n\n    expect(subscription.closed).to.be.true;\n    expect(results).to.deep.equal([1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'complete', 'finalizer']);\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["repeatWhen operator"],"updatePoint":{"line":493,"column":73},"line":493,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        repeatWhen(() => of(0)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/repeatWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a basic source that emits next then errors, count=3","suites":["retry"],"updatePoint":{"line":16,"column":71},"line":16,"code":"  it('should handle a basic source that emits next then errors, count=3', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2-3-#');\n      const subs = [\n        '                  ^-------!                ',\n        '                  --------^-------!        ',\n        '                  ----------------^-------!',\n      ];\n      const expected = '   --1-2-3---1-2-3---1-2-3-#';\n\n      const result = source.pipe(retry(2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a number of times, without error, then complete","suites":["retry"],"updatePoint":{"line":33,"column":66},"line":33,"code":"  it('should retry a number of times, without error, then complete', (done) => {\n    let errors = 0;\n    const retries = 2;\n    new Observable((observer: Observer<number>) => {\n      observer.next(42);\n      observer.complete();\n    })\n      .pipe(\n        map((x: any) => {\n          if (++errors < retries) {\n            throw 'bad';\n          }\n          errors = 0;\n          return x;\n        }),\n        retry(retries)\n      )\n      .subscribe({\n        next(x: number) {\n          expect(x).to.equal(42);\n        },\n        error() {\n          expect('this was called').to.be.true;\n        },\n        complete: done,\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a number of times, then call error handler","suites":["retry"],"updatePoint":{"line":61,"column":61},"line":61,"code":"  it('should retry a number of times, then call error handler', (done) => {\n    let errors = 0;\n    const retries = 2;\n    new Observable((observer: Observer<number>) => {\n      observer.next(42);\n      observer.complete();\n    })\n      .pipe(\n        map(() => {\n          errors += 1;\n          throw 'bad';\n        }),\n        retry(retries - 1)\n      )\n      .subscribe({\n        next() {\n          done(\"shouldn't next\");\n        },\n        error() {\n          expect(errors).to.equal(2);\n          done();\n        },\n        complete() {\n          done(\"shouldn't complete\");\n        },\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a number of times, then call error handler (with resetOnSuccess)","suites":["retry"],"updatePoint":{"line":89,"column":83},"line":89,"code":"  it('should retry a number of times, then call error handler (with resetOnSuccess)', (done) => {\n    let errors = 0;\n    const retries = 2;\n    new Observable((observer: Observer<number>) => {\n      observer.next(42);\n      observer.complete();\n    })\n      .pipe(\n        map(() => {\n          errors += 1;\n          throw 'bad';\n        }),\n        retry({ count: retries - 1, resetOnSuccess: true })\n      )\n      .subscribe({\n        next() {\n          done(\"shouldn't next\");\n        },\n        error() {\n          expect(errors).to.equal(2);\n          done();\n        },\n        complete() {\n          done(\"shouldn't complete\");\n        },\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a number of times, then call next handler without error, then retry and complete","suites":["retry"],"updatePoint":{"line":117,"column":99},"line":117,"code":"  it('should retry a number of times, then call next handler without error, then retry and complete', (done) => {\n    let index = 0;\n    let errors = 0;\n    const retries = 2;\n    defer(() => range(0, 4 - index))\n      .pipe(\n        mergeMap(() => {\n          index++;\n          if (index === 1 || index === 3) {\n            errors++;\n            return throwError(() => 'bad');\n          } else {\n            return of(42);\n          }\n        }),\n        retry({ count: retries - 1, resetOnSuccess: true })\n      )\n      .subscribe({\n        next(x: number) {\n          expect(x).to.equal(42);\n        },\n        error() {\n          done(\"shouldn't error\");\n        },\n        complete() {\n          expect(errors).to.equal(retries);\n          done();\n        },\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should always finalize before starting the next cycle, even when synchronous","suites":["retry"],"updatePoint":{"line":148,"column":82},"line":148,"code":"  it('should always finalize before starting the next cycle, even when synchronous', () => {\n    const results: any[] = [];\n    const source = new Observable<number>((subscriber) => {\n      subscriber.next(1);\n      subscriber.next(2);\n      subscriber.error('bad');\n      return () => {\n        results.push('finalizer');\n      };\n    });\n    const subscription = source.pipe(retry(3)).subscribe({\n      next: (value) => results.push(value),\n      error: (err) => results.push(err),\n    });\n\n    expect(subscription.closed).to.be.true;\n    expect(results).to.deep.equal([1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'bad', 'finalizer']);\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a number of times, then call next handler without error, then retry and error","suites":["retry"],"updatePoint":{"line":167,"column":96},"line":167,"code":"  it('should retry a number of times, then call next handler without error, then retry and error', (done) => {\n    let index = 0;\n    let errors = 0;\n    const retries = 2;\n    defer(() => range(0, 4 - index))\n      .pipe(\n        mergeMap(() => {\n          index++;\n          if (index === 1 || index === 3) {\n            errors++;\n            return throwError(() => 'bad');\n          } else {\n            return of(42);\n          }\n        }),\n        retry({ count: retries - 1, resetOnSuccess: false })\n      )\n      .subscribe({\n        next(x: number) {\n          expect(x).to.equal(42);\n        },\n        error() {\n          expect(errors).to.equal(retries);\n          done();\n        },\n        complete() {\n          done(\"shouldn't complete\");\n        },\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry until successful completion","suites":["retry"],"updatePoint":{"line":198,"column":46},"line":198,"code":"  it('should retry until successful completion', (done) => {\n    let errors = 0;\n    const retries = 10;\n    new Observable((observer: Observer<number>) => {\n      observer.next(42);\n      observer.complete();\n    })\n      .pipe(\n        map((x: any) => {\n          if (++errors < retries) {\n            throw 'bad';\n          }\n          errors = 0;\n          return x;\n        }),\n        retry(),\n        take(retries)\n      )\n      .subscribe({\n        next(x: number) {\n          expect(x).to.equal(42);\n        },\n        error() {\n          expect('this was called').to.be.true;\n        },\n        complete: done,\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["retry"],"updatePoint":{"line":227,"column":35},"line":227,"code":"  it('should handle an empty source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|  ');\n      const subs = '      (^!)';\n      const expected = '   |  ';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["retry"],"updatePoint":{"line":240,"column":34},"line":240,"code":"  it('should handle a never source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const subs = '       ^';\n      const expected = '   -';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a never observable given an async just-throw source and no count","suites":["retry"],"updatePoint":{"line":253,"column":84},"line":253,"code":"  it('should return a never observable given an async just-throw source and no count', () => {\n    rxTest.run(({ cold, expectObservable }) => {\n      const source = cold('-#                                    '); // important that it's not a sync error\n      const unsub = '     -------------------------------------!';\n      const expected = '  --------------------------------------';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result, unsub).toBe(expected);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a basic source that emits next then completes","suites":["retry"],"updatePoint":{"line":265,"column":65},"line":265,"code":"  it('should handle a basic source that emits next then completes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--1--2--^--3--4--5---|');\n      const subs = '              ^------------!';\n      const expected = '          ---3--4--5---|';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a basic source that emits next but does not complete","suites":["retry"],"updatePoint":{"line":278,"column":72},"line":278,"code":"  it('should handle a basic source that emits next but does not complete', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--1--2--^--3--4--5---');\n      const subs = '              ^------------';\n      const expected = '          ---3--4--5---';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a basic source that emits next then errors, no count","suites":["retry"],"updatePoint":{"line":291,"column":72},"line":291,"code":"  it('should handle a basic source that emits next then errors, no count', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2-3-#                             ');\n      //                           --1-2-3-#\n      //                                   --1-2-3-#\n      //                                           --1-2-3-#\n      //                                                   --1-2-3-#\n      const unsub = '      -------------------------------------!';\n      const subs = [\n        '                  ^-------!                             ',\n        '                  --------^-------!                     ',\n        '                  ----------------^-------!             ',\n        '                  ------------------------^-------!     ',\n        '                  --------------------------------^----!',\n      ];\n      const expected = '   --1-2-3---1-2-3---1-2-3---1-2-3---1-2-';\n\n      const result = source.pipe(retry());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source which eventually throws, count=3, and result is unsubscribed early","suites":["retry"],"updatePoint":{"line":315,"column":95},"line":315,"code":"  it('should handle a source which eventually throws, count=3, and result is unsubscribed early', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2-3-#     ');\n      //                           --1-2-3-#\n      const unsub = '      -------------!';\n      // prettier-ignore\n      const subs = [\n        '                  ^-------!     ',\n        '                  --------^----!',\n      ];\n      const expected = '   --1-2-3---1-2-';\n\n      const result = source.pipe(retry(3));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["retry"],"updatePoint":{"line":334,"column":72},"line":334,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2-3-#     ');\n      //                           --1-2-3-#\n      // prettier-ignore\n      const subs = [\n        '                  ^-------!     ',\n        '                  --------^----!',\n      ];\n      const expected = '   --1-2-3---1-2-';\n      const unsub = '      -------------!';\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        retry(100),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry a synchronous source (multicasted and refCounted) multiple times","suites":["retry"],"updatePoint":{"line":357,"column":83},"line":357,"code":"  it('should retry a synchronous source (multicasted and refCounted) multiple times', (done) => {\n    const expected = [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3];\n\n    of(1, 2, 3)\n      .pipe(\n        concat(throwError(() => 'bad!')),\n        multicast(() => new Subject<number>()),\n        refCount(),\n        retry(4)\n      )\n      .subscribe({\n        next(x: number) {\n          expect(x).to.equal(expected.shift());\n        },\n        error(err: any) {\n          expect(err).to.equal('bad!');\n          expect(expected.length).to.equal(0);\n          done();\n        },\n        complete() {\n          done(new Error('should not be called'));\n        },\n      });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["retry"],"updatePoint":{"line":382,"column":73},"line":382,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(retry(1), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should not alter the source when the number of retries is smaller than 1","suites":["retry"],"updatePoint":{"line":400,"column":78},"line":400,"code":"  it('should not alter the source when the number of retries is smaller than 1', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2-3-# ');\n      const subs = ['      ^-------! '];\n\n      const expected = '   --1-2-3-# ';\n      const unsub = '      ---------!';\n\n      const result = source.pipe(retry(0));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay the retry by a specified amount of time","suites":["retry","with delay config","of a number"],"updatePoint":{"line":417,"column":62},"line":417,"code":"      it('should delay the retry by a specified amount of time', () => {\n        rxTest.run(({ cold, time, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const t = time('                ----|');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ---------------^----------!',\n            '                  ------------------------------^----------!',\n            '                  ---------------------------------------------^----!',\n          ];\n          const unsub = '      ^-------------------------------------------------!';\n          const expected = '   ---a---b----------a---b----------a---b----------a--';\n          const result = source.pipe(\n            retry({\n              delay: t,\n            })\n          );\n          expectObservable(result, unsub).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should act like a normal retry if delay is set to 0","suites":["retry","with delay config","of a number"],"updatePoint":{"line":440,"column":61},"line":440,"code":"      it('should act like a normal retry if delay is set to 0', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  -----------^----------!',\n            '                  ----------------------^----------!',\n            '                  ---------------------------------^----!',\n          ];\n          const unsub = '      ^-------------------------------------!';\n          const expected = '   ---a---b------a---b------a---b------a--';\n          const result = source.pipe(\n            retry({\n              delay: 0,\n            })\n          );\n          expectObservable(result, unsub).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should act like a normal retry if delay is less than 0","suites":["retry","with delay config","of a number"],"updatePoint":{"line":462,"column":64},"line":462,"code":"      it('should act like a normal retry if delay is less than 0', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  -----------^----------!',\n            '                  ----------------------^----------!',\n            '                  ---------------------------------^----!',\n          ];\n          const unsub = '      ^-------------------------------------!';\n          const expected = '   ---a---b------a---b------a---b------a--';\n          const result = source.pipe(\n            retry({\n              delay: -100,\n            })\n          );\n          expectObservable(result, unsub).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should honor count as the max retries","suites":["retry","with delay config","of a number"],"updatePoint":{"line":484,"column":47},"line":484,"code":"      it('should honor count as the max retries', () => {\n        rxTest.run(({ cold, time, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const t = time('                ----|');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ---------------^----------!',\n            '                  ------------------------------^----------!',\n          ];\n          const expected = '   ---a---b----------a---b----------a---b---#';\n          const result = source.pipe(\n            retry({\n              count: 2,\n              delay: t,\n            })\n          );\n          expectObservable(result).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay the retry with a function that returns a notifier","suites":["retry","with delay config","of a function"],"updatePoint":{"line":508,"column":72},"line":508,"code":"      it('should delay the retry with a function that returns a notifier', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ------------^----------!',\n            '                  -------------------------^----------!',\n            '                  ---------------------------------------^----!',\n          ];\n          const unsub = '      ^-------------------------------------------!';\n          const expected = '   ---a---b-------a---b--------a---b---------a--';\n          const result = source.pipe(\n            retry({\n              delay: (_err, retryCount) => {\n                // retryCount will be 1, 2, 3, etc.\n                return timer(retryCount);\n              },\n            })\n          );\n          expectObservable(result, unsub).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should delay the retry with a function that returns a hot observable","suites":["retry","with delay config","of a function"],"updatePoint":{"line":533,"column":78},"line":533,"code":"      it('should delay the retry with a function that returns a hot observable', () => {\n        rxTest.run(({ cold, hot, expectSubscriptions, expectObservable }) => {\n          const source = cold(' ---a---b---#');\n          const notifier = hot('--------------x----------------x----------------x------');\n          const subs = [\n            //\n            '                   ^----------!',\n            '                   --------------^----------!',\n            '                   -------------------------------^----------!',\n          ];\n          const notifierSubs = [\n            //\n            '                   -----------^--!',\n            '                   -------------------------^-----!',\n            '                   ------------------------------------------^-!',\n          ];\n          const unsub = '       ^-------------------------------------------!';\n          const expected = '    ---a---b---------a---b------------a---b------';\n          const result = source.pipe(\n            retry({\n              delay: () => notifier,\n            })\n          );\n          expectObservable(result, unsub).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n          expectSubscriptions(notifier.subscriptions).toBe(notifierSubs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete if the notifier completes","suites":["retry","with delay config","of a function"],"updatePoint":{"line":562,"column":51},"line":562,"code":"      it('should complete if the notifier completes', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ------------^----------!',\n            '                  -------------------------^----------!',\n            '                  ------------------------------------!',\n          ];\n          const expected = '   ---a---b-------a---b--------a---b---|';\n          const result = source.pipe(\n            retry({\n              delay: (_err, retryCount) => {\n                return retryCount <= 2 ? timer(retryCount) : EMPTY;\n              },\n            })\n          );\n          expectObservable(result).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if the notifier errors","suites":["retry","with delay config","of a function"],"updatePoint":{"line":585,"column":45},"line":585,"code":"      it('should error if the notifier errors', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ------------^----------!',\n            '                  -------------------------^----------!',\n            '                  ------------------------------------!',\n          ];\n          const expected = '   ---a---b-------a---b--------a---b---#';\n          const result = source.pipe(\n            retry({\n              delay: (_err, retryCount) => {\n                return retryCount <= 2 ? timer(retryCount) : throwError(() => new Error('blah'));\n              },\n            })\n          );\n          expectObservable(result).toBe(expected, undefined, new Error('blah'));\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if the delay function throws","suites":["retry","with delay config","of a function"],"updatePoint":{"line":608,"column":51},"line":608,"code":"      it('should error if the delay function throws', () => {\n        rxTest.run(({ cold, expectSubscriptions, expectObservable }) => {\n          const source = cold('---a---b---#');\n          const subs = [\n            //\n            '                  ^----------!',\n            '                  ------------^----------!',\n            '                  -------------------------^----------!',\n            '                  ------------------------------------!',\n          ];\n          const expected = '   ---a---b-------a---b--------a---b---#';\n          const result = source.pipe(\n            retry({\n              delay: (_err, retryCount) => {\n                if (retryCount <= 2) {\n                  return timer(retryCount);\n                } else {\n                  throw new Error('blah');\n                }\n              },\n            })\n          );\n          expectObservable(result).toBe(expected, undefined, new Error('blah'));\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should be usable for exponential backoff","suites":["retry","with delay config","of a function"],"updatePoint":{"line":635,"column":50},"line":635,"code":"      it('should be usable for exponential backoff', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('---a---#');\n          const subs = [\n            //\n            '                  ^------!',\n            '                  ---------^------!',\n            '                  --------------------^------!',\n            '                  -----------------------------------^------!',\n          ];\n          const expected = '   ---a--------a----------a--------------a---#';\n          const result = source.pipe(\n            retry({\n              count: 3,\n              delay: (_err, retryCount) => timer(2 ** retryCount),\n            })\n          );\n          expectObservable(result).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/retry-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a hot notifier","suites":["retryWhen"],"updatePoint":{"line":16,"column":69},"line":16,"code":"  it('should handle a source with eventual error using a hot notifier', () => {\n    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--#                     ');\n      //                                 -1--2--#\n      //                                              -1--2--#\n      const subs = [\n        '                   ^------!                     ',\n        '                   -------------^------!        ',\n        '                   --------------------------^-!',\n      ];\n      const notifier = hot('-------------r------------r-|');\n      const expected = '    -1--2---------1--2---------1|';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a hot notifier that raises error","suites":["retryWhen"],"updatePoint":{"line":36,"column":87},"line":36,"code":"  it('should handle a source with eventual error using a hot notifier that raises error', () => {\n    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--#                      ');\n      //                               -1--2--#\n      //                                       -1--2--#\n      const subs = [\n        '                   ^------!                      ',\n        '                   -----------^------!           ',\n        '                   -------------------^------!   ',\n      ];\n      const notifier = hot('-----------r-------r---------#');\n      const expected = '    -1--2-------1--2----1--2-----#';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry when notified via returned notifier on thrown error","suites":["retryWhen"],"updatePoint":{"line":56,"column":70},"line":56,"code":"  it('should retry when notified via returned notifier on thrown error', (done) => {\n    let retried = false;\n    const expected = [1, 2, 1, 2];\n    let i = 0;\n    of(1, 2, 3)\n      .pipe(\n        map((n: number) => {\n          if (n === 3) {\n            throw 'bad';\n          }\n          return n;\n        }),\n        retryWhen((errors: any) =>\n          errors.pipe(\n            map((x: any) => {\n              expect(x).to.equal('bad');\n              if (retried) {\n                throw new Error('done');\n              }\n              retried = true;\n              return x;\n            })\n          )\n        )\n      )\n      .subscribe({\n        next(x: any) {\n          expect(x).to.equal(expected[i++]);\n        },\n        error(err: any) {\n          expect(err).to.be.an('error', 'done');\n          done();\n        },\n      });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry when notified and complete on returned completion","suites":["retryWhen"],"updatePoint":{"line":92,"column":68},"line":92,"code":"  it('should retry when notified and complete on returned completion', (done) => {\n    const expected = [1, 2, 1, 2];\n    of(1, 2, 3)\n      .pipe(\n        map((n: number) => {\n          if (n === 3) {\n            throw 'bad';\n          }\n          return n;\n        }),\n        retryWhen(() => EMPTY)\n      )\n      .subscribe({\n        next(n: number) {\n          expect(n).to.equal(expected.shift());\n        },\n        error() {\n          done(new Error('should not be called'));\n        },\n        complete() {\n          done();\n        },\n      });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply an empty notifier on an empty source","suites":["retryWhen"],"updatePoint":{"line":117,"column":55},"line":117,"code":"  it('should apply an empty notifier on an empty source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |   ');\n      const subs = '         (^!)';\n      const notifier = cold('|   ');\n      const expected = '     |   ';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply a never notifier on an empty source","suites":["retryWhen"],"updatePoint":{"line":131,"column":54},"line":131,"code":"  it('should apply a never notifier on an empty source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |   ');\n      const subs = '         (^!)';\n      const notifier = cold('-   ');\n      const expected = '     |   ';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply an empty notifier on a never source","suites":["retryWhen"],"updatePoint":{"line":145,"column":54},"line":145,"code":"  it('should apply an empty notifier on a never source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  ------------------------------------------');\n      const unsub = '        -----------------------------------------!';\n      const subs = '         ^----------------------------------------!';\n      const notifier = cold('|                                         ');\n      const expected = '     ------------------------------------------';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should apply a never notifier on a never source","suites":["retryWhen"],"updatePoint":{"line":160,"column":53},"line":160,"code":"  it('should apply a never notifier on a never source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  -----------------------------------------');\n      const unsub = '        -----------------------------------------!';\n      const subs = '         ^----------------------------------------!';\n      const notifier = cold('------------------------------------------');\n      const expected = '     -----------------------------------------';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should return an empty observable given a just-throw source and empty notifier","suites":["retryWhen"],"updatePoint":{"line":175,"column":84},"line":175,"code":"  it('should return an empty observable given a just-throw source and empty notifier', () => {\n    rxTest.run(({ cold, expectObservable }) => {\n      const source = cold('  #');\n      const notifier = cold('|');\n      const expected = '     |';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a never observable given a just-throw source and never notifier","suites":["retryWhen"],"updatePoint":{"line":187,"column":83},"line":187,"code":"  it('should return a never observable given a just-throw source and never notifier', () => {\n    rxTest.run(({ cold, expectObservable }) => {\n      const source = cold('  #');\n      const notifier = cold('-');\n      const expected = '     -';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should hide errors using a never notifier on a source with eventual error","suites":["retryWhen"],"updatePoint":{"line":199,"column":79},"line":199,"code":"  it('should hide errors using a never notifier on a source with eventual error', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--#                              ');\n      const subs = '         ^----------!                              ';\n      const notifier = cold('           -------------------------------');\n      const expected = '     --a--b--c---------------------------------';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from notifierSelector function","suites":["retryWhen"],"updatePoint":{"line":213,"column":66},"line":213,"code":"  it('should propagate error thrown from notifierSelector function', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--a--b--c--#');\n      const subs = '       ^----------!';\n      const expected = '   --a--b--c--#';\n\n      const result = source.pipe(\n        retryWhen(() => {\n          throw 'bad!';\n        })\n      );\n\n      expectObservable(result).toBe(expected, undefined, 'bad!');\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should replace error with complete using an empty notifier on a source with eventual error","suites":["retryWhen"],"updatePoint":{"line":230,"column":96},"line":230,"code":"  it('should replace error with complete using an empty notifier on a source with eventual error', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--#');\n      const subs = '         ^----------!';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c--|';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic cold source with complete, given an empty notifier","suites":["retryWhen"],"updatePoint":{"line":244,"column":78},"line":244,"code":"  it('should mirror a basic cold source with complete, given an empty notifier', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c--|');\n      const subs = '         ^----------!';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c--|';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic cold source with no termination, given an empty notifier","suites":["retryWhen"],"updatePoint":{"line":258,"column":84},"line":258,"code":"  it('should mirror a basic cold source with no termination, given an empty notifier', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  --a--b--c---');\n      const subs = '         ^-----------';\n      const notifier = cold('           |');\n      const expected = '     --a--b--c---';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a basic hot source with complete, given an empty notifier","suites":["retryWhen"],"updatePoint":{"line":272,"column":77},"line":272,"code":"  it('should mirror a basic hot source with complete, given an empty notifier', () => {\n    rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-a-^--b--c--|');\n      const subs = '         ^--------!';\n      const notifier = cold('         |');\n      const expected = '     ---b--c--|';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot source that raises error but eventually completes","suites":["retryWhen"],"updatePoint":{"line":286,"column":75},"line":286,"code":"  it('should handle a hot source that raises error but eventually completes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -1--2--3----4--5---|                  ');\n      const ssubs = [\n        '                   ^------!                              ',\n        '                   --------------^----!                  ',\n      ];\n      const notifier = hot('--------------r--------r---r--r--r---|');\n      const nsubs = '       -------^-----------!                  ';\n      const expected = '    -1--2----------5---|                  ';\n\n      const result = source.pipe(\n        map((x: string) => {\n          if (x === '3') {\n            throw 'error';\n          }\n          return x;\n        }),\n        retryWhen(() => notifier)\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(ssubs);\n      expectSubscriptions(notifier.subscriptions).toBe(nsubs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should tear down resources when result is unsubscribed early","suites":["retryWhen"],"updatePoint":{"line":313,"column":66},"line":313,"code":"  it('should tear down resources when result is unsubscribed early', () => {\n    rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--#                    ');\n      //                             -1--2--#\n      //                                     -1--2--#\n      const unsub = '       --------------------!       ';\n      const subs = [\n        '                   ^------!                    ',\n        '                   ---------^------!           ',\n        '                   -----------------^--!       ',\n      ];\n      const notifier = hot('---------r-------r---------#');\n      const nsubs = '       -------^------------!       ';\n      const expected = '    -1--2-----1--2----1--       ';\n\n      const result = source.pipe(retryWhen(() => notifier));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(notifier.subscriptions).toBe(nsubs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when unsubscribed explicitly","suites":["retryWhen"],"updatePoint":{"line":336,"column":73},"line":336,"code":"  it('should not break unsubscription chains when unsubscribed explicitly', () => {\n    rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = cold(' -1--2--#                    ');\n      //                             -1--2--#\n      //                                     -1--2--#\n      const subs = [\n        '                   ^------!                    ',\n        '                   ---------^------!           ',\n        '                   -----------------^--!       ',\n      ];\n      const notifier = hot('---------r-------r-------r-#');\n      const nsubs = '       -------^------------!       ';\n      const expected = '    -1--2-----1--2----1--       ';\n      const unsub = '       --------------------!       ';\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        retryWhen(() => notifier),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(notifier.subscriptions).toBe(nsubs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a dynamic notifier selector which eventually throws","suites":["retryWhen"],"updatePoint":{"line":363,"column":106},"line":363,"code":"  it('should handle a source with eventual error using a dynamic notifier selector which eventually throws', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-1--2--#              ');\n      //                          -1--2--#\n      //                                 -1--2--#\n      const subs = [\n        '                  ^------!              ',\n        '                  -------^------!       ',\n        '                  --------------^------!',\n      ];\n      const expected = '   -1--2---1--2---1--2--#';\n\n      let invoked = 0;\n      const result = source.pipe(\n        retryWhen((errors: any) =>\n          errors.pipe(\n            map(() => {\n              if (++invoked === 3) {\n                throw 'error';\n              } else {\n                return 'x';\n              }\n            })\n          )\n        )\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a source with eventual error using a dynamic notifier selector which eventually completes","suites":["retryWhen"],"updatePoint":{"line":395,"column":109},"line":395,"code":"  it('should handle a source with eventual error using a dynamic notifier selector which eventually completes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-1--2--#              ');\n      //                          -1--2--#\n      //                                 -1--2--#\n      const subs = [\n        '                  ^------!              ',\n        '                  -------^------!       ',\n        '                  --------------^------!',\n      ];\n      const expected = '   -1--2---1--2---1--2--|';\n\n      let invoked = 0;\n      const result = source.pipe(\n        retryWhen((errors: any) =>\n          errors.pipe(\n            map(() => 'x'),\n            takeUntil(\n              errors.pipe(\n                mergeMap(() => {\n                  if (++invoked < 3) {\n                    return EMPTY;\n                  } else {\n                    return of('stop!');\n                  }\n                })\n              )\n            )\n          )\n        )\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should always finalize before starting the next cycle, even when synchronous","suites":["retryWhen"],"updatePoint":{"line":432,"column":82},"line":432,"code":"  it('should always finalize before starting the next cycle, even when synchronous', () => {\n    const results: any[] = [];\n    const source = new Observable<number>((subscriber) => {\n      subscriber.next(1);\n      subscriber.next(2);\n      subscriber.error('bad');\n      return () => {\n        results.push('finalizer');\n      };\n    });\n    const subscription = source\n      .pipe(retryWhen((errors$) => errors$.pipe(mergeMap((err, i) => (i < 3 ? of(true) : throwError(() => err))))))\n      .subscribe({\n        next: (value) => results.push(value),\n        error: (err) => results.push(err),\n      });\n\n    expect(subscription.closed).to.be.true;\n    expect(results).to.deep.equal([1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'finalizer', 1, 2, 'bad', 'finalizer']);\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["retryWhen"],"updatePoint":{"line":453,"column":73},"line":453,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        retryWhen(() => of(0)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/retryWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should get samples when the notifier emits","suites":["sample"],"updatePoint":{"line":16,"column":48},"line":16,"code":"  it('should get samples when the notifier emits', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a----b---c----------d-----|   ');\n      const e1subs = '  ^----------------------------!   ';\n      const e2 = hot('  -----x----------x---x------x---| ');\n      const e2subs = '  ^----------------------------!   ';\n      const expected = '-----a----------c----------d-|   ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample nothing if source has not nexted at all","suites":["sample"],"updatePoint":{"line":30,"column":59},"line":30,"code":"  it('should sample nothing if source has not nexted at all', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('----a-^------------|');\n      const e1subs = '      ^------------!';\n      const e2 = hot('      -----x-------|');\n      const e2subs = '      ^------------!';\n      const expected = '    -------------|';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should behave properly when notified by the same observable as the source (issue #2075)","suites":["sample"],"updatePoint":{"line":44,"column":93},"line":44,"code":"  it('should behave properly when notified by the same observable as the source (issue #2075)', () => {\n    const item$ = new Subject<number>();\n    const results: number[] = [];\n\n    item$.pipe(sample(item$)).subscribe((value) => results.push(value));\n\n    item$.next(1);\n    item$.next(2);\n    item$.next(3);\n\n    expect(results).to.deep.equal([1, 2, 3]);\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample nothing if source has nexted after all notifications, but notifier does not complete","suites":["sample"],"updatePoint":{"line":57,"column":104},"line":57,"code":"  it('should sample nothing if source has nexted after all notifications, but notifier does not complete', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-^------b-----|');\n      const e1subs = '        ^------------!';\n      const e2 = hot('        -----x--------');\n      const e2subs = '        ^------------!';\n      const expected = '      -------------|';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should not sample when the notifier completes","suites":["sample"],"updatePoint":{"line":71,"column":51},"line":71,"code":"  it('should not sample when the notifier completes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-^------b----------|');\n      const e1subs = '        ^-----------------!';\n      const e2 = hot('        -----x-----|       ');\n      const e2subs = '        ^----------!       ';\n      const expected = '      ------------------|';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when the notifier completes, nor should it emit","suites":["sample"],"updatePoint":{"line":85,"column":73},"line":85,"code":"  it('should not complete when the notifier completes, nor should it emit', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a----b----c----d----e----f----');\n      const e1subs = '  ^---------------------------------';\n      const e2 = hot('  ------x-|                         ');\n      const e2subs = '  ^-------!                         ';\n      const expected = '------a---------------------------';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete only when the source completes, if notifier completes early","suites":["sample"],"updatePoint":{"line":99,"column":81},"line":99,"code":"  it('should complete only when the source completes, if notifier completes early', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a----b----c----d----e----f---|');\n      const e1subs = '  ^--------------------------------!';\n      const e2 = hot('  ------x-|                         ');\n      const e2subs = '  ^-------!                         ';\n      const expected = '------a--------------------------|';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["sample"],"updatePoint":{"line":113,"column":53},"line":113,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-^--b----c----d----e----f----|          ');\n      const unsub = '         --------------!                        ';\n      const e1subs = '        ^-------------!                        ';\n      const e2 = hot('        -----x----------x----------x----------|');\n      const e2subs = '        ^-------------!                        ';\n      const expected = '      -----b---------                        ';\n\n      expectObservable(e1.pipe(sample(e2)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["sample"],"updatePoint":{"line":128,"column":83},"line":128,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-^--b----c----d----e----f----|          ');\n      const e1subs = '        ^-------------!                        ';\n      const e2 = hot('        -----x----------x----------x----------|');\n      const e2subs = '        ^-------------!                        ';\n      const expected = '      -----b---------                        ';\n      const unsub = '         --------------!                        ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        sample(e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should only sample when a new value arrives, even if it is the same value","suites":["sample"],"updatePoint":{"line":149,"column":79},"line":149,"code":"  it('should only sample when a new value arrives, even if it is the same value', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a----b----c----c----e----f----|  ');\n      const e1subs = '  ^---------------------------------!  ';\n      const e2 = hot('  ------x-x------xx-x---x----x--------|');\n      const e2subs = '  ^---------------------------------!  ';\n      const expected = '------a--------c------c----e------|  ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["sample"],"updatePoint":{"line":163,"column":47},"line":163,"code":"  it('should raise error if source raises error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-^--b----c----d----#                    ');\n      const e1subs = '        ^-----------------!                    ';\n      const e2 = hot('        -----x----------x----------x----------|');\n      const e2subs = '        ^-----------------!                    ';\n      const expected = '      -----b----------d-#                    ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should completes if source does not emits","suites":["sample"],"updatePoint":{"line":177,"column":47},"line":177,"code":"  it('should completes if source does not emits', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  |              ');\n      const e2 = hot('  ------x-------|');\n      const expected = '|              ';\n      const e1subs = '  (^!)           ';\n      const e2subs = '  (^!)           ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws immediately","suites":["sample"],"updatePoint":{"line":191,"column":53},"line":191,"code":"  it('should raise error if source throws immediately', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  #              ');\n      const e2 = hot('  ------x-------|');\n      const expected = '#              ';\n      const e1subs = '  (^!)           ';\n      const e2subs = '  (^!)           ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if notification raises error","suites":["sample"],"updatePoint":{"line":205,"column":53},"line":205,"code":"  it('should raise error if notification raises error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a-----|');\n      const e2 = hot('  ----#    ');\n      const expected = '----#    ';\n      const e1subs = '  ^---!    ';\n      const e2subs = '  ^---!    ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes if source does not complete","suites":["sample"],"updatePoint":{"line":219,"column":54},"line":219,"code":"  it('should not completes if source does not complete', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---------------');\n      const e1subs = '  ^--------------';\n      const e2 = hot('  ------x-------|');\n      const e2subs = '  ^-------------!';\n      const expected = '---------------';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample only until source completes","suites":["sample"],"updatePoint":{"line":233,"column":47},"line":233,"code":"  it('should sample only until source completes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a----b----c----d-|              ');\n      const e1subs = '  ^--------------------!              ';\n      const e2 = hot('  -----------x----------x------------|');\n      const e2subs = '  ^--------------------!              ';\n      const expected = '-----------b---------|              ';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete sampling if sample observable completes","suites":["sample"],"updatePoint":{"line":247,"column":61},"line":247,"code":"  it('should complete sampling if sample observable completes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a----b----c----d-|');\n      const e1subs = '  ^--------------------!';\n      const e2 = hot('  |                     ');\n      const e2subs = '  (^!)                  ';\n      const expected = '---------------------|';\n\n      expectObservable(e1.pipe(sample(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/sample-spec.ts","skipped":false,"dir":"spec"},{"name":"should get samples on a delay","suites":["sampleTime"],"updatePoint":{"line":15,"column":35},"line":15,"code":"  it('should get samples on a delay', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('     a---b-c---------d--e---f-g-h--|');\n      const e1subs = '     ^-----------------------------!';\n      const expected = '   -------c-------------e------h-|';\n      // period            -------!------!------!------!--\n      const period = time('-------|                       ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample nothing if new value has not arrived","suites":["sampleTime"],"updatePoint":{"line":28,"column":56},"line":28,"code":"  it('should sample nothing if new value has not arrived', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  ----a-^--b----c--------------f----|');\n      const e1subs = '        ^---------------------------!';\n      const expected = '      -----------c----------------|';\n      // period               -----------!----------!---------\n      const period = time('   -----------|                 ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample if new value has arrived, even if it is the same value","suites":["sampleTime"],"updatePoint":{"line":41,"column":74},"line":41,"code":"  it('should sample if new value has arrived, even if it is the same value', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('----a-^--b----c----------c---f----|');\n      const e1subs = '      ^---------------------------!';\n      const expected = '    -----------c----------c-----|';\n      // period             -----------!----------!---------\n      const period = time(' -----------|                 ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should sample nothing if source has not nexted by time of sample","suites":["sampleTime"],"updatePoint":{"line":54,"column":70},"line":54,"code":"  it('should sample nothing if source has not nexted by time of sample', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('----a-^-------------b-------------|');\n      const e1subs = '      ^---------------------------!';\n      const expected = '    ----------------------b-----|';\n      // period             -----------!----------!---------\n      const period = time(' -----------|                 ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["sampleTime"],"updatePoint":{"line":67,"column":47},"line":67,"code":"  it('should raise error if source raises error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('----a-^--b----c----d----#');\n      const e1subs = '      ^-----------------!';\n      const expected = '    -----------c------#';\n      // period             -----------!----------!---------\n      const period = time(' -----------|       ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["sampleTime"],"updatePoint":{"line":80,"column":53},"line":80,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('----a-^--b----c----d----e----f----|');\n      const unsub = '       ----------------!            ';\n      const e1subs = '      ^---------------!            ';\n      const expected = '    -----------c-----            ';\n      // period             -----------!----------!---------\n      const period = time(' -----------|                 ');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["sampleTime"],"updatePoint":{"line":94,"column":83},"line":94,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('----a-^--b----c----d----e----f----|');\n      const e1subs = '      ^---------------!            ';\n      // period             -----------!----------!---------\n      const period = time(' -----------|                 ');\n      const expected = '    -----------c-----            ';\n      const unsub = '       ----------------!            ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        sampleTime(period, rxTest),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should completes if source does not emits","suites":["sampleTime"],"updatePoint":{"line":114,"column":47},"line":114,"code":"  it('should completes if source does not emits', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n      const e1 = cold('    |     ');\n      const e1subs = '     (^!)  ';\n      const expected = '   |     ';\n      const period = time('-----|');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws immediately","suites":["sampleTime"],"updatePoint":{"line":126,"column":53},"line":126,"code":"  it('should raise error if source throws immediately', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n      const e1 = cold('    #     ');\n      const e1subs = '     (^!)  ';\n      const expected = '   #     ';\n      const period = time('-----|');\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source does not complete","suites":["sampleTime"],"updatePoint":{"line":138,"column":53},"line":138,"code":"  it('should not complete if source does not complete', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n      const e1 = cold('    --------');\n      const e1subs = '     ^------!';\n      const expected = '   --------';\n      const period = time('-----|  ');\n      const e1unsbs = '    -------!';\n\n      expectObservable(e1.pipe(sampleTime(period, rxTest)), e1unsbs).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/sampleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should scan","suites":["scan"],"updatePoint":{"line":16,"column":17},"line":16,"code":"  it('should scan', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      // prettier-ignore\n      const values = {\n        a: 1, b: 3, c: 5,\n        x: 1, y: 4, z: 9,\n      };\n      const e1 = hot('  --a--b--c--|', values);\n      const e1subs = '  ^----------!';\n      const expected = '--x--y--z--|';\n\n      const scanFunction = function (o: number, x: number) {\n        return o + x;\n      };\n\n      expectObservable(e1.pipe(scan(scanFunction, 0))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should scan things","suites":["scan"],"updatePoint":{"line":36,"column":24},"line":36,"code":"  it('should scan things', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ---u--v--w--x--y--z--|';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should provide the proper index if seed is skipped","suites":["scan"],"updatePoint":{"line":58,"column":56},"line":58,"code":"  it('should provide the proper index if seed is skipped', () => {\n    const expected = [1, 2];\n    of(3, 3, 3)\n      .pipe(\n        scan((_: any, __, i) => {\n          expect(i).to.equal(expected.shift());\n          return null;\n        })\n      )\n      .subscribe();\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should scan with a seed of undefined","suites":["scan"],"updatePoint":{"line":70,"column":42},"line":70,"code":"  it('should scan with a seed of undefined', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------------------!';\n      const expected = '   ---u--v--w--x--y--z--|';\n\n      const values = {\n        u: 'undefined b',\n        v: 'undefined b c',\n        w: 'undefined b c d',\n        x: 'undefined b c d e',\n        y: 'undefined b c d e f',\n        z: 'undefined b c d e f g',\n      };\n\n      const source = e1.pipe(scan((acc: any, x: string) => acc + ' ' + x, undefined));\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should scan without seed","suites":["scan"],"updatePoint":{"line":92,"column":30},"line":92,"code":"  it('should scan without seed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--|');\n      const e1subs = '     ^-----------!';\n      const expected = '   ---x--y--z--|';\n\n      const values = {\n        x: 'b',\n        y: 'bc',\n        z: 'bcd',\n      };\n\n      const source = e1.pipe(scan((acc: any, x: string) => acc + x));\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["scan"],"updatePoint":{"line":111,"column":26},"line":111,"code":"  it('should handle errors', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--#');\n      const e1subs = '     ^-----------!';\n      const expected = '   ---u--v--w--#';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n      };\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors in the projection function","suites":["scan"],"updatePoint":{"line":130,"column":53},"line":130,"code":"  it('should handle errors in the projection function', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^--------!            ';\n      const expected = '   ---u--v--#            ';\n\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const source = e1.pipe(\n        scan((acc, x) => {\n          if (x === 'd') {\n            throw 'bad!';\n          }\n          return acc.concat(x);\n        }, [] as string[])\n      );\n\n      expectObservable(source).toBe(expected, values, 'bad!');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle empty","suites":["scan"],"updatePoint":{"line":159,"column":18},"line":159,"code":"  it('handle empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle never","suites":["scan"],"updatePoint":{"line":172,"column":18},"line":172,"code":"  it('handle never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"handle throw","suites":["scan"],"updatePoint":{"line":185,"column":18},"line":185,"code":"  it('handle throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["scan"],"updatePoint":{"line":198,"column":53},"line":198,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const unsub = '      --------------!       ';\n      const e1subs = '     ^-------------!       ';\n      const expected = '   ---u--v--w--x--       ';\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const source = e1.pipe(scan((acc, x) => acc.concat(x), [] as string[]));\n\n      expectObservable(source, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["scan"],"updatePoint":{"line":220,"column":83},"line":220,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b--c--d--e--f--g--|');\n      const e1subs = '     ^-------------!       ';\n      const expected = '   ---u--v--w--x--       ';\n      const unsub = '      --------------!       ';\n      const values = {\n        u: ['b'],\n        v: ['b', 'c'],\n        w: ['b', 'c', 'd'],\n        x: ['b', 'c', 'd', 'e'],\n        y: ['b', 'c', 'd', 'e', 'f'],\n        z: ['b', 'c', 'd', 'e', 'f', 'g'],\n      };\n\n      const source = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        scan((acc, x) => acc.concat(x), [] as string[]),\n        mergeMap((x: string[]) => of(x))\n      );\n\n      expectObservable(source, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass current index to accumulator","suites":["scan"],"updatePoint":{"line":246,"column":46},"line":246,"code":"  it('should pass current index to accumulator', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      // prettier-ignore\n      const values = {\n        a: 1, b: 3, c: 5,\n        x: 1, y: 4, z: 9,\n      };\n      let idx = [0, 1, 2];\n\n      const e1 = hot('  --a--b--c--|', values);\n      const e1subs = '  ^----------!';\n      const expected = '--x--y--z--|';\n\n      const scanFunction = (o: number, value: number, index: number) => {\n        expect(index).to.equal(idx.shift());\n        return o + value;\n      };\n\n      const scanObs = e1.pipe(\n        scan(scanFunction, 0),\n        finalize(() => {\n          expect(idx).to.be.empty;\n        })\n      );\n\n      expectObservable(scanObs).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["scan"],"updatePoint":{"line":276,"column":73},"line":276,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        scan((_acc, value: number) => value, 0),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/scan-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for two equal sequences","suites":["sequenceEqual"],"updatePoint":{"line":16,"column":48},"line":16,"code":"  it('should return true for two equal sequences', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d--e--f--g--|       ');\n      const s1subs = '     ^--------------------!       ';\n      const s2 = hot('-----^-----b--c--d-e-f------g-|   ');\n      const s2subs = '     ^------------------------!   ';\n      const expected = '   -------------------------(T|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for two sync observables that are unequal in length","suites":["sequenceEqual"],"updatePoint":{"line":32,"column":77},"line":32,"code":"  it('should return false for two sync observables that are unequal in length', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' (abcdefg|)');\n      const s2 = cold(' (abc|)    ');\n      const expected = '(F|)      ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for two sync observables that match","suites":["sequenceEqual"],"updatePoint":{"line":44,"column":60},"line":44,"code":"  it('should return true for two sync observables that match', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' (abcdefg|)');\n      const s2 = cold(' (abcdefg|)');\n      const expected = '(T|)      ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for two observables that match when the last one emits and completes in the same frame","suites":["sequenceEqual"],"updatePoint":{"line":56,"column":111},"line":56,"code":"  it('should return true for two observables that match when the last one emits and completes in the same frame', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d--e--f--g--|       ');\n      const s1subs = '     ^--------------------!       ';\n      const s2 = hot('-----^--b--c--d--e--f--g------|   ');\n      const s2subs = '     ^------------------------!   ';\n      const expected = '   -------------------------(T|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for two observables that match when the last one emits and completes in the same frame","suites":["sequenceEqual"],"updatePoint":{"line":72,"column":111},"line":72,"code":"  it('should return true for two observables that match when the last one emits and completes in the same frame', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d--e--f--g--|       ');\n      const s1subs = '     ^--------------------!       ';\n      const s2 = hot('-----^--b--c--d--e--f---------(g|)');\n      const s2subs = '     ^------------------------!   ';\n      const expected = '   -------------------------(T|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should error with an errored source","suites":["sequenceEqual"],"updatePoint":{"line":88,"column":41},"line":88,"code":"  it('should error with an errored source', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b---c---#  ');\n      const s2 = hot('--a--^--b---c-----|');\n      const expected = '   -----------#  ';\n      const sub = '        ^----------!  ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(sub);\n      expectSubscriptions(s2.subscriptions).toBe(sub);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should error with an errored compareTo","suites":["sequenceEqual"],"updatePoint":{"line":103,"column":44},"line":103,"code":"  it('should error with an errored compareTo', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b---c-----|');\n      const s2 = hot('--a--^--b---c---#  ');\n      const expected = '   -----------#  ';\n      const sub = '        ^----------!  ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(sub);\n      expectSubscriptions(s2.subscriptions).toBe(sub);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if the source is a throw","suites":["sequenceEqual"],"updatePoint":{"line":118,"column":43},"line":118,"code":"  it('should error if the source is a throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' #            ');\n      const s2 = cold(' ---a--b--c--|');\n      const expected = '#            ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should never return if source is a never","suites":["sequenceEqual"],"updatePoint":{"line":130,"column":46},"line":130,"code":"  it('should never return if source is a never', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' ------------');\n      const s2 = cold(' --a--b--c--|');\n      const expected = '------------';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should never return if compareTo is a never","suites":["sequenceEqual"],"updatePoint":{"line":142,"column":49},"line":142,"code":"  it('should never return if compareTo is a never', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' --a--b--c--|');\n      const s2 = cold(' ------------');\n      const expected = '------------';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false if source is empty and compareTo is not","suites":["sequenceEqual"],"updatePoint":{"line":154,"column":65},"line":154,"code":"  it('should return false if source is empty and compareTo is not', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const s1 = cold(' |            ');\n      const s1subs = '  (^!)          ';\n      const s2 = cold(' ------a------');\n      const s2subs = '  ^-----!      ';\n      const expected = '------(F|)   ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false if compareTo is empty and source is not","suites":["sequenceEqual"],"updatePoint":{"line":170,"column":65},"line":170,"code":"  it('should return false if compareTo is empty and source is not', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const s1 = cold(' ------a------');\n      const s2 = cold(' |            ');\n      const expected = '------(F|)   ';\n      const s1subs = '  ^-----!      ';\n      const s2subs = '  (^!)         ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return never if compareTo is empty and source is never","suites":["sequenceEqual"],"updatePoint":{"line":186,"column":67},"line":186,"code":"  it('should return never if compareTo is empty and source is never', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' -');\n      const s2 = cold(' |');\n      const expected = '-';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return never if source is empty and compareTo is never","suites":["sequenceEqual"],"updatePoint":{"line":198,"column":67},"line":198,"code":"  it('should return never if source is empty and compareTo is never', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' |');\n      const s2 = cold(' -');\n      const expected = '-';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should error if the comparator function errors","suites":["sequenceEqual"],"updatePoint":{"line":210,"column":52},"line":210,"code":"  it('should error if the comparator function errors', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values: { [key: string]: any } = {\n        a: null,\n        b: { value: 'bees knees' },\n        c: { value: 'carpy dumb' },\n        d: { value: 'derp' },\n        x: { value: 'bees knees', foo: 'lol' },\n        y: { value: 'carpy dumb', scooby: 'doo' },\n        z: { value: 'derp', weCouldBe: 'dancin, yeah' },\n      };\n\n      const s1 = hot('--a--^--b-----c------d--|      ', values);\n      const s1subs = '     ^------------!            ';\n      const s2 = hot('-----^--------x---y---z-------|', values);\n      const s2subs = '     ^------------!            ';\n      const expected = '   -------------#            ';\n\n      let i = 0;\n      const source = s1.pipe(\n        sequenceEqual(s2, (a: any, b: any) => {\n          if (++i === 2) {\n            throw new Error('shazbot');\n          }\n          return a.value === b.value;\n        })\n      );\n\n      expectObservable(source).toBe(expected, booleans, new Error('shazbot'));\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the provided comparator function","suites":["sequenceEqual"],"updatePoint":{"line":244,"column":49},"line":244,"code":"  it('should use the provided comparator function', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const values: { [key: string]: any } = {\n        a: null,\n        b: { value: 'bees knees' },\n        c: { value: 'carpy dumb' },\n        d: { value: 'derp' },\n        x: { value: 'bees knees', foo: 'lol' },\n        y: { value: 'carpy dumb', scooby: 'doo' },\n        z: { value: 'derp', weCouldBe: 'dancin, yeah' },\n      };\n\n      const s1 = hot('--a--^--b-----c------d--|         ', values);\n      const s1subs = '     ^------------------!         ';\n      const s2 = hot('-----^--------x---y---z-------|   ', values);\n      const s2subs = '     ^------------------------!   ';\n      const expected = '   -------------------------(T|)';\n\n      const source = s1.pipe(sequenceEqual(s2, (a: any, b: any) => a.value === b.value));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for two unequal sequences, compareTo finishing last","suites":["sequenceEqual"],"updatePoint":{"line":270,"column":77},"line":270,"code":"  it('should return false for two unequal sequences, compareTo finishing last', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d--e--f--g--|    ');\n      const s1subs = '     ^--------------------!    ';\n      const s2 = hot('-----^-----b--c--d-e-f------z-|');\n      const s2subs = '     ^----------------------!   ';\n      const expected = '   -----------------------(F|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for two unequal sequences, early wrong value from source","suites":["sequenceEqual"],"updatePoint":{"line":286,"column":82},"line":286,"code":"  it('should return false for two unequal sequences, early wrong value from source', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c---x-----------|');\n      const s1subs = '     ^---------!            ';\n      const s2 = hot('-----^--b--c--d--e--f--|    ');\n      const s2subs = '     ^---------!            ';\n      const expected = '   ----------(F|)         ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false when the source emits an extra value after the compareTo completes","suites":["sequenceEqual"],"updatePoint":{"line":302,"column":92},"line":302,"code":"  it('should return false when the source emits an extra value after the compareTo completes', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d--e--f--g--h--|');\n      const s1subs = '     ^-----------!            ';\n      const s2 = hot('-----^--b--c--d-|             ');\n      const s2subs = '     ^----------!             ';\n      const expected = '   ------------(F|)         ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false when the compareTo emits an extra value after the source completes","suites":["sequenceEqual"],"updatePoint":{"line":318,"column":92},"line":318,"code":"  it('should return false when the compareTo emits an extra value after the source completes', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('--a--^--b--c--d-|             ');\n      const s1subs = '     ^----------!             ';\n      const s2 = hot('-----^--b--c--d--e--f--g--h--|');\n      const s2subs = '     ^-----------!            ';\n      const expected = '   ------------(F|)         ';\n\n      const source = s1.pipe(sequenceEqual(s2));\n\n      expectObservable(source).toBe(expected, booleans);\n      expectSubscriptions(s1.subscriptions).toBe(s1subs);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for two empty observables","suites":["sequenceEqual"],"updatePoint":{"line":334,"column":50},"line":334,"code":"  it('should return true for two empty observables', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' |   ');\n      const s2 = cold(' |   ');\n      const expected = '(T|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n      expectObservable(source).toBe(expected, booleans);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for an empty observable and an observable that emits","suites":["sequenceEqual"],"updatePoint":{"line":345,"column":78},"line":345,"code":"  it('should return false for an empty observable and an observable that emits', () => {\n    rxTestScheduler.run(({ cold, expectObservable }) => {\n      const s1 = cold(' |      ');\n      const s2 = cold(' ---a--|');\n      const expected = '---(F|)';\n\n      const source = s1.pipe(sequenceEqual(s2));\n      expectObservable(source).toBe(expected, booleans);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should return compare hot and cold observables","suites":["sequenceEqual"],"updatePoint":{"line":356,"column":52},"line":356,"code":"  it('should return compare hot and cold observables', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const s1 = hot('---a--^---b---c---d---e---f---g---h---i---j---|   ');\n      const s2 = cold('     ----b---c-|                                 ');\n      const s2subs = '      ^---------!                                 ';\n      const expected1 = '   ------------(F|)                            ';\n      const s3 = cold('                        -f---g---h---i---j---|   ');\n      const test2subs = '   -------------------^                        ';\n      const expected2 = '   ----------------------------------------(T|)';\n      const s3subs = '      -------------------^--------------------!   ';\n\n      const test1 = s1.pipe(sequenceEqual(s2));\n      const test2 = s1.pipe(sequenceEqual(s3));\n\n      expectObservable(test1).toBe(expected1, booleans);\n      expectObservable(test2, test2subs).toBe(expected2, booleans);\n      expectSubscriptions(s2.subscriptions).toBe(s2subs);\n      expectSubscriptions(s3.subscriptions).toBe(s3subs);\n    });\n  });","file":"operators/sequenceEqual-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["share"],"updatePoint":{"line":85,"column":50},"line":85,"code":"      it('should mirror a simple source Observable', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('--1-2---3-4--5-|');\n          const sourceSubs = ' ^--------------!';\n          const expected = '   --1-2---3-4--5-|';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(shared).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share a single subscription","suites":["share"],"updatePoint":{"line":98,"column":44},"line":98,"code":"      it('should share a single subscription', () => {\n        let subscriptionCount = 0;\n        const obs = new Observable<never>(() => {\n          subscriptionCount++;\n        });\n\n        const source = obs.pipe(share(options));\n\n        expect(subscriptionCount).to.equal(0);\n\n        source.subscribe();\n        source.subscribe();\n\n        expect(subscriptionCount).to.equal(1);\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not change the output of the observable when error","suites":["share"],"updatePoint":{"line":114,"column":67},"line":114,"code":"      it('should not change the output of the observable when error', () => {\n        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n          const e1 = hot('---a--^--b--c--d--e--#');\n          const e1subs = '      ^--------------!';\n          const expected = '    ---b--c--d--e--#';\n\n          expectObservable(e1.pipe(share(options))).toBe(expected);\n          expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not change the output of the observable when successful with cold observable","suites":["share"],"updatePoint":{"line":125,"column":93},"line":125,"code":"      it('should not change the output of the observable when successful with cold observable', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const e1 = cold(' ---a--b--c--d--e--|');\n          const e1subs = '  ^-----------------!';\n          const expected = '---a--b--c--d--e--|';\n\n          expectObservable(e1.pipe(share(options))).toBe(expected);\n          expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not change the output of the observable when error with cold observable","suites":["share"],"updatePoint":{"line":136,"column":88},"line":136,"code":"      it('should not change the output of the observable when error with cold observable', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const e1 = cold(' ---a--b--c--d--e--#');\n          const e1subs = '  ^-----------------!';\n          const expected = '---a--b--c--d--e--#';\n\n          expectObservable(e1.pipe(share(options))).toBe(expected);\n          expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should retry just fine","suites":["share"],"updatePoint":{"line":147,"column":32},"line":147,"code":"      it('should retry just fine', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const e1 = cold(' ---a--b--c--d--e--#                  ');\n          // prettier-ignore\n          const e1subs = [\n            '               ^-----------------!                  ',\n            '               ------------------^-----------------!'\n          ];\n          const expected = '---a--b--c--d--e-----a--b--c--d--e--#';\n\n          expectObservable(e1.pipe(share(options), retry(1))).toBe(expected);\n          expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share the same values to multiple observers","suites":["share"],"updatePoint":{"line":162,"column":60},"line":162,"code":"      it('should share the same values to multiple observers', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('    -1-2-3----4-|');\n          const sourceSubs = '     ^-----------!';\n          const subscriber1 = hot('a|           ');\n          const expected1 = '      -1-2-3----4-|';\n          const subscriber2 = hot('----b|       ');\n          const expected2 = '      -----3----4-|';\n          const subscriber3 = hot('--------c|   ');\n          const expected3 = '      ----------4-|';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share an error from the source to multiple observers","suites":["share"],"updatePoint":{"line":182,"column":69},"line":182,"code":"      it('should share an error from the source to multiple observers', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('    -1-2-3----4-#');\n          const sourceSubs = '     ^-----------!';\n          const subscriber1 = hot('a|           ');\n          const expected1 = '      -1-2-3----4-#';\n          const subscriber2 = hot('----b|       ');\n          const expected2 = '      -----3----4-#';\n          const subscriber3 = hot('--------c|   ');\n          const expected3 = '      ----------4-#';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share the same values to multiple observers, but is unsubscribed explicitly and early","suites":["share"],"updatePoint":{"line":202,"column":102},"line":202,"code":"      it('should share the same values to multiple observers, but is unsubscribed explicitly and early', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('    -1-2-3----4-|');\n          const sourceSubs = '     ^--------!   ';\n          const unsub = '          ---------!   ';\n          const subscriber1 = hot('a|           ');\n          const expected1 = '      -1-2-3----   ';\n          const subscriber2 = hot('----b|       ');\n          const expected2 = '      -----3----   ';\n          const subscriber3 = hot('--------c|   ');\n          const expected3 = '      ----------   ';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub).toBe(expected2);\n          expectObservable(subscriber3.pipe(mergeMapTo(shared)), unsub).toBe(expected3);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share an empty source","suites":["share"],"updatePoint":{"line":223,"column":38},"line":223,"code":"      it('should share an empty source', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('|   ');\n          const sourceSubs = ' (^!)';\n          const expected = '   |   ';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(shared).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share a never source","suites":["share"],"updatePoint":{"line":236,"column":37},"line":236,"code":"      it('should share a never source', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('-');\n          const sourceSubs = ' ^';\n          const expected = '   -';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(shared).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should share a throw source","suites":["share"],"updatePoint":{"line":249,"column":37},"line":249,"code":"      it('should share a throw source', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('#   ');\n          const sourceSubs = ' (^!)';\n          const expected = '   #   ';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(shared).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should connect when first subscriber subscribes","suites":["share"],"updatePoint":{"line":262,"column":57},"line":262,"code":"      it('should connect when first subscriber subscribes', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('       -1-2-3----4-|');\n          const sourceSubs = '     ---^-----------!';\n          const subscriber1 = hot('---a|           ');\n          const expected1 = '      ----1-2-3----4-|';\n          const subscriber2 = hot('-------b|       ');\n          const expected2 = '      --------3----4-|';\n          const subscriber3 = hot('-----------c|   ');\n          const expected3 = '      -------------4-|';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n          expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should disconnect when last subscriber unsubscribes","suites":["share"],"updatePoint":{"line":282,"column":61},"line":282,"code":"      it('should disconnect when last subscriber unsubscribes', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('       -1-2-3----4-|');\n          const sourceSubs = '     ---^--------!   ';\n          const subscriber1 = hot('---a|           ');\n          const unsub1 = '         ----------!     ';\n          const expected1 = '      ----1-2-3--     ';\n          const subscriber2 = hot('-------b|       ');\n          const unsub2 = '         ------------!   ';\n          const expected2 = '      --------3----   ';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub1).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub2).toBe(expected2);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when last subscriber unsubscribes","suites":["share"],"updatePoint":{"line":301,"column":81},"line":301,"code":"      it('should not break unsubscription chain when last subscriber unsubscribes', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('       -1-2-3----4-|');\n          const sourceSubs = '     ---^--------!   ';\n          const subscriber1 = hot('---a|           ');\n          const unsub1 = '         ----------!     ';\n          const expected1 = '      ----1-2-3--     ';\n          const subscriber2 = hot('-------b|       ');\n          const unsub2 = '         ------------!   ';\n          const expected2 = '      --------3----   ';\n\n          const shared = source.pipe(\n            mergeMap((x: string) => of(x)),\n            share(options),\n            mergeMap((x: string) => of(x))\n          );\n\n          expectObservable(subscriber1.pipe(mergeMapTo(shared)), unsub1).toBe(expected1);\n          expectObservable(subscriber2.pipe(mergeMapTo(shared)), unsub2).toBe(expected2);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable when cold source is synchronous","suites":["share"],"updatePoint":{"line":324,"column":61},"line":324,"code":"      it('should be retryable when cold source is synchronous', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('(123#)    ');\n          const subscribe1 = ' s         ';\n          const expected1 = '  (123123#) ';\n          const subscribe2 = ' -s        ';\n          const expected2 = '  -(123123#)';\n          const sourceSubs = [\n            '                  (^!)      ',\n            '                  (^!)      ',\n            '                  -(^!)     ',\n            '                  -(^!)     ',\n          ];\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(\n            hot(subscribe1).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(retry(1))).toBe(expected1);\n              })\n            )\n          ).toBe(subscribe1);\n\n          expectObservable(\n            hot(subscribe2).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(retry(1))).toBe(expected2);\n              })\n            )\n          ).toBe(subscribe2);\n\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable when cold source is synchronous","suites":["share"],"updatePoint":{"line":360,"column":62},"line":360,"code":"      it('should be repeatable when cold source is synchronous', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('(123|)    ');\n          const subscribe1 = ' s         ';\n          const expected1 = '  (123123|) ';\n          const subscribe2 = ' -s        ';\n          const expected2 = '  -(123123|)';\n          const sourceSubs = [\n            '                  (^!)      ',\n            '                  (^!)      ',\n            '                  -(^!)     ',\n            '                  -(^!)     ',\n          ];\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(\n            hot(subscribe1).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(repeat(2))).toBe(expected1);\n              })\n            )\n          ).toBe(subscribe1);\n\n          expectObservable(\n            hot(subscribe2).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(repeat(2))).toBe(expected2);\n              })\n            )\n          ).toBe(subscribe2);\n\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable","suites":["share"],"updatePoint":{"line":396,"column":29},"line":396,"code":"      it('should be retryable', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('-1-2-3----4-#                        ');\n          const sourceSubs = [\n            '                  ^-----------!                        ',\n            '                  ------------^-----------!            ',\n            '                  ------------------------^-----------!',\n          ];\n          const subscribe1 = ' s------------------------------------';\n          const expected1 = '  -1-2-3----4--1-2-3----4--1-2-3----4-#';\n          const subscribe2 = ' ----s--------------------------------';\n          const expected2 = '  -----3----4--1-2-3----4--1-2-3----4-#';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(\n            hot(subscribe1).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(retry(2))).toBe(expected1);\n              })\n            )\n          ).toBe(subscribe1);\n\n          expectObservable(\n            hot(subscribe2).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(retry(2))).toBe(expected2);\n              })\n            )\n          ).toBe(subscribe2);\n\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should be repeatable","suites":["share"],"updatePoint":{"line":431,"column":30},"line":431,"code":"      it('should be repeatable', () => {\n        rxTest.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n          const source = cold('-1-2-3----4-|                        ');\n          const sourceSubs = [\n            '                  ^-----------!                        ',\n            '                  ------------^-----------!            ',\n            '                  ------------------------^-----------!',\n          ];\n          const subscribe1 = ' s------------------------------------';\n          const expected1 = '  -1-2-3----4--1-2-3----4--1-2-3----4-|';\n          const subscribe2 = ' ----s--------------------------------';\n          const expected2 = '  -----3----4--1-2-3----4--1-2-3----4-|';\n\n          const shared = source.pipe(share(options));\n\n          expectObservable(\n            hot(subscribe1).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(repeat(3))).toBe(expected1);\n              })\n            )\n          ).toBe(subscribe1);\n\n          expectObservable(\n            hot(subscribe2).pipe(\n              tap(() => {\n                expectObservable(shared.pipe(repeat(3))).toBe(expected2);\n              })\n            )\n          ).toBe(subscribe2);\n\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not change the output of the observable when never","suites":["share"],"updatePoint":{"line":466,"column":67},"line":466,"code":"      it('should not change the output of the observable when never', () => {\n        rxTest.run(({ expectObservable }) => {\n          const e1 = NEVER;\n          const expected = '-';\n\n          expectObservable(e1.pipe(share(options))).toBe(expected);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not change the output of the observable when empty","suites":["share"],"updatePoint":{"line":475,"column":67},"line":475,"code":"      it('should not change the output of the observable when empty', () => {\n        rxTest.run(({ expectObservable }) => {\n          const e1 = EMPTY;\n          const expected = '|';\n\n          expectObservable(e1.pipe(share(options))).toBe(expected);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["share"],"updatePoint":{"line":484,"column":77},"line":484,"code":"      it('should stop listening to a synchronous observable when unsubscribed', () => {\n        const sideEffects: number[] = [];\n        const synchronousObservable = new Observable<number>((subscriber) => {\n          // This will check to see if the subscriber was closed on each loop\n          // when the unsubscribe hits (from the `take`), it should be closed\n          for (let i = 0; !subscriber.closed && i < 10; i++) {\n            sideEffects.push(i);\n            subscriber.next(i);\n          }\n        });\n\n        synchronousObservable.pipe(share(options), take(3)).subscribe(() => {\n          /* noop */\n        });\n\n        expect(sideEffects).to.deep.equal([0, 1, 2]);\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not fail on reentrant subscription","suites":["share"],"updatePoint":{"line":502,"column":51},"line":502,"code":"      it('should not fail on reentrant subscription', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          // https://github.com/ReactiveX/rxjs/issues/6144\n          const source = cold('(123|)');\n          const subs = '       (^!)  ';\n          const expected = '   (136|)';\n\n          const deferred = defer(() => shared).pipe(startWith(0));\n          const shared: Observable<string> = source.pipe(\n            withLatestFrom(deferred),\n            map(([a, b]) => String(Number(a) + Number(b))),\n            share(options)\n          );\n\n          expectObservable(shared).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on error if configured to do so","suites":["share"],"updatePoint":{"line":539,"column":58},"line":539,"code":"      it('should not reset on error if configured to do so', () => {\n        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n          const source = hot('---a---b---c---d---e---f----#');\n          const expected = '  ---a---b---c---d---e---f----#';\n          const sourceSubs = [\n            '                 ^----------!                 ',\n            '                 -----------^-----------!     ',\n            '                 -----------------------^----!',\n          ];\n          const result = source.pipe(\n            // takes a, b, c... then repeat causes it to take d, e, f\n            take(3),\n            share({ resetOnError }),\n            repeat()\n          );\n\n          expectObservable(result).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on complete if configured to do so","suites":["share"],"updatePoint":{"line":560,"column":61},"line":560,"code":"      it('should not reset on complete if configured to do so', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('---a---b---c---#                          ');\n          const expected = '   ---a---b---c------a---b---c------a---b---|';\n          const sourceSubs = [\n            '                  ^--------------!                          ',\n            '                  ---------------^--------------!           ',\n            '                  ------------------------------^----------!',\n          ];\n\n          // Used to trigger the source to complete at a given moment.\n          const triggerComplete = new Subject<void>();\n\n          // just used to count how many values have made it through the share.\n          let count = 0;\n\n          const result = source.pipe(\n            takeUntil(triggerComplete),\n            share({ resetOnComplete }),\n            // Retry on any error.\n            retry(),\n            tap(() => {\n              if (++count === 9) {\n                // If we see the ninth value, complete the source this time.\n                triggerComplete.next();\n              }\n            })\n          );\n\n          expectObservable(result).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on refCount 0 if configured to do so","suites":["share"],"updatePoint":{"line":594,"column":63},"line":594,"code":"      it('should not reset on refCount 0 if configured to do so', () => {\n        rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n          const source = hot('  ---v---v---v---E--v---v---v---C---v----v------v---');\n          const expected = '    ---v---v---v------v---v---v-------v----v----      ';\n          const subscription = '^-------------------------------------------!     ';\n          const sourceSubs = [\n            '                   ^--------------!',\n            '                   ---------------^--------------!',\n            // Note this last subscription never ends, because refCount hitting zero isn't going to reset.\n            '                   ------------------------------^--------------     ',\n          ];\n\n          const result = source.pipe(\n            tap((value) => {\n              if (value === 'E') {\n                throw new Error('E');\n              }\n            }),\n            takeWhile((value) => value !== 'C'),\n            share({ resetOnRefCountZero }),\n            retry(),\n            repeat()\n          );\n\n          expectObservable(result, subscription).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["share"],"updatePoint":{"line":623,"column":45},"line":623,"code":"      it('should be referentially-transparent', () => {\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source1 = cold('-1-2-3-4-5-|');\n          const source1Subs = ' ^----------!';\n          const expected1 = '   -1-2-3-4-5-|';\n          const source2 = cold('-6-7-8-9-0-|');\n          const source2Subs = ' ^----------!';\n          const expected2 = '   -6-7-8-9-0-|';\n\n          // Calls to the _operator_ must be referentially-transparent.\n          const partialPipeLine = pipe(share({ resetOnRefCountZero }));\n\n          // The non-referentially-transparent sharing occurs within the _operator function_\n          // returned by the _operator_ and that happens when the complete pipeline is composed.\n          const shared1 = source1.pipe(partialPipeLine);\n          const shared2 = source2.pipe(partialPipeLine);\n\n          expectObservable(shared1).toBe(expected1);\n          expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n          expectObservable(shared2).toBe(expected2);\n          expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n        });\n      });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should use the connector function provided","suites":["share","share(config)"],"updatePoint":{"line":650,"column":50},"line":650,"code":"    it('should use the connector function provided', () => {\n      const connector = spy(() => new Subject());\n\n      rxTest.run(({ hot, expectObservable }) => {\n        const source = hot('  ---v---v---v---E--v---v---v---C---v----v--------v----v---');\n        const subs1 = '       ^-------------------------------------------!            ';\n        const expResult1 = '  ---v---v---v------v---v---v-------v----v-----            ';\n        const subs2 = '       ----------------------------------------------^---------!';\n        const expResult2 = '  ------------------------------------------------v----v---';\n\n        const result = source.pipe(\n          tap((value) => {\n            if (value === 'E') {\n              throw new Error('E');\n            }\n          }),\n          takeWhile((value) => value !== 'C'),\n          share({\n            connector,\n          }),\n          retry(),\n          repeat()\n        );\n\n        expectObservable(result, subs1).toBe(expResult1);\n        expectObservable(result, subs2).toBe(expResult2);\n      });\n\n      expect(connector).to.have.callCount(4);\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should reset on refCount 0 when synchronously resubscribing to a firehose and using a sync reset notifier","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":683,"column":113},"line":683,"code":"    it('should reset on refCount 0 when synchronously resubscribing to a firehose and using a sync reset notifier', () => {\n      let subscriptionCount = 0;\n      const source = new Observable((subscriber) => {\n        subscriptionCount++;\n        for (let i = 0; i < 3 && !subscriber.closed; i++) {\n          subscriber.next(i);\n        }\n        if (!subscriber.closed) {\n          subscriber.complete();\n        }\n      });\n\n      let result;\n      source\n        .pipe(share({ resetOnRefCountZero: () => syncNotify }), take(2), repeat(2), toArray())\n        .subscribe((numbers) => void (result = numbers));\n\n      expect(subscriptionCount).to.equal(2);\n      expect(result).to.deep.equal([0, 1, 0, 1]);\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should reset on refCount 0 when synchronously resubscribing and using a sync reset notifier","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":704,"column":99},"line":704,"code":"    it('should reset on refCount 0 when synchronously resubscribing and using a sync reset notifier', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const source = hot('  ---1---2---3---(4 )---5---|');\n        const sourceSubs = [\n          '                   ^------!                   ',\n          // break the line, please\n          '                   -------^-------(! )        ',\n        ];\n        const expected = '    ---1---2---3---(4|)        ';\n        const subscription = '^--------------(- )        ';\n\n        const sharedSource = source.pipe(share({ resetOnRefCountZero: () => syncNotify }), take(2));\n\n        const result = concat(sharedSource, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on refCount 0 when synchronously resubscribing and using a deferred reset notifier","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":724,"column":107},"line":724,"code":"    it('should not reset on refCount 0 when synchronously resubscribing and using a deferred reset notifier', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold(' ---1---2---3---4---5---|');\n        const sourceSubs = '  ^----------------------!';\n        const expected = '    ---1---2---3---4---5---|';\n        const subscription = '^-----------------------';\n\n        const sharedSource = source.pipe(share({ resetOnRefCountZero: () => asapNotify }), take(3));\n\n        const result = concat(sharedSource, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should reset on refCount 0 only after reset notifier emitted","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":740,"column":68},"line":740,"code":"    it('should reset on refCount 0 only after reset notifier emitted', () => {\n      rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n        const source = hot('      ---1---2---3---4---5---|');\n        const sourceSubs = [\n          '                       ^----------------!      ',\n          // break the line, please\n          '                       ------------------^----!',\n        ];\n        const expected = '        ---1---2---3---4---5---|';\n        const subscription = '    ^-----------------------';\n        const firstPause = cold('        -|               ');\n        const reset = cold('             --r              ');\n        const secondPause = cold('               ---|     ');\n        // reset: '                              --r      '\n\n        const sharedSource = source.pipe(share({ resetOnRefCountZero: () => reset }), take(2));\n\n        const result = concat(sharedSource, firstPause, sharedSource, secondPause, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should reset on error only after reset notifier emitted","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":764,"column":63},"line":764,"code":"    it('should reset on error only after reset notifier emitted', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('     ---1---2---#                ');\n        // source: '                            ---1---2---#  '\n        const sourceSubs = [\n          '                       ^----------!                ',\n          // break the line, please\n          '                       --------------^----------!  ',\n        ];\n        const expected = '        ---1---2---------1---2----# ';\n        const subscription = '    ^-------------------------- ';\n        const firstPause = cold('        -------|             ');\n        const reset = cold('                 --r              ');\n        const secondPause = cold('                     -----| ');\n        // reset: '                                        --r'\n\n        const sharedSource = source.pipe(share({ resetOnError: () => reset, resetOnRefCountZero: false }), take(2));\n\n        const result = concat(sharedSource, firstPause, sharedSource, secondPause, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should reset on complete only after reset notifier emitted","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":789,"column":66},"line":789,"code":"    it('should reset on complete only after reset notifier emitted', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('     ---1---2---|                ');\n        // source: '                            ---1---2---|  '\n        const sourceSubs = [\n          '                       ^----------!                ',\n          // break the line, please\n          '                       --------------^----------!  ',\n        ];\n        const expected = '        ---1---2---------1---2----| ';\n        const subscription = '    ^-------------------------- ';\n        const firstPause = cold('        -------|             ');\n        const reset = cold('                 --r              ');\n        const secondPause = cold('                     -----| ');\n        // reset: '                                        --r'\n\n        const sharedSource = source.pipe(share({ resetOnComplete: () => reset, resetOnRefCountZero: false }), take(2));\n\n        const result = concat(sharedSource, firstPause, sharedSource, secondPause, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on refCount 0 if reset notifier errors before emitting any value","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":814,"column":89},"line":814,"code":"    it('should not reset on refCount 0 if reset notifier errors before emitting any value', () => {\n      spyOnUnhandledError((onUnhandledError) => {\n        const error = new Error();\n\n        rxTest.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n          const source = hot('       ---1---2---3---4---(5 )---|');\n          const sourceSubs = '       ^------------------(- )---!';\n          const expected = '         ---1---2-------4---(5|)    ';\n          const subscription = '     ^------------------(- )    ';\n          const firstPause = cold('         ------|             ');\n          const reset = cold('              --#                 ', undefined, error);\n          // reset: '                                   (- )-#  '\n\n          const sharedSource = source.pipe(share({ resetOnRefCountZero: () => reset }), take(2));\n\n          const result = concat(sharedSource, firstPause, sharedSource);\n\n          expectObservable(result, subscription).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n\n        expect(onUnhandledError).to.have.been.calledTwice;\n        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(error);\n        expect(onUnhandledError.getCall(1)).to.have.been.calledWithExactly(error);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on error if reset notifier errors before emitting any value","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":841,"column":84},"line":841,"code":"    it('should not reset on error if reset notifier errors before emitting any value', () => {\n      spyOnUnhandledError((onUnhandledError) => {\n        const error = new Error();\n\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('    ---1---2---#   ');\n          const sourceSubs = '     ^----------!   ';\n          const expected = '       ---1---2------#';\n          const subscription = '   ^--------------';\n          const firstPause = cold('       -------|');\n          const reset = cold('                --# ', undefined, error);\n\n          const sharedSource = source.pipe(share({ resetOnError: () => reset, resetOnRefCountZero: false }), take(2));\n\n          const result = concat(sharedSource, firstPause, sharedSource);\n\n          expectObservable(result, subscription).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n\n        expect(onUnhandledError).to.have.been.calledOnce;\n        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(error);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reset on complete if reset notifier errors before emitting any value","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":866,"column":87},"line":866,"code":"    it('should not reset on complete if reset notifier errors before emitting any value', () => {\n      spyOnUnhandledError((onUnhandledError) => {\n        const error = new Error();\n\n        rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const source = cold('    ---1---2---|   ');\n          const sourceSubs = '     ^----------!   ';\n          const expected = '       ---1---2------|';\n          const subscription = '   ^--------------';\n          const firstPause = cold('       -------|');\n          const reset = cold('                --# ', undefined, error);\n\n          const sharedSource = source.pipe(share({ resetOnComplete: () => reset, resetOnRefCountZero: false }), take(2));\n\n          const result = concat(sharedSource, firstPause, sharedSource);\n\n          expectObservable(result, subscription).toBe(expected);\n          expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        });\n\n        expect(onUnhandledError).to.have.been.calledOnce;\n        expect(onUnhandledError.getCall(0)).to.have.been.calledWithExactly(error);\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not call \"resetOnRefCountZero\" on error","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":891,"column":54},"line":891,"code":"    it('should not call \"resetOnRefCountZero\" on error', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const resetOnRefCountZero = spy(() => EMPTY);\n\n        const source = cold('    ---1---(2#)                ');\n        // source: '                           ---1---(2#)  '\n        const sourceSubs = [\n          '                      ^------(! )                ',\n          // break the line, please\n          '                      -------(- )---^------(! )  ',\n        ];\n        const expected = '       ---1---(2 )------1---(2#)  ';\n        const subscription = '   ^------(- )----------(- )  ';\n        const firstPause = cold('       (- )---|            ');\n        const reset = cold('            (- )-r              ');\n        // reset: '                                   (- )-r'\n\n        const sharedSource = source.pipe(share({ resetOnError: () => reset, resetOnRefCountZero }));\n\n        const result = concat(sharedSource.pipe(onErrorResumeNext(firstPause)), sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expect(resetOnRefCountZero).to.not.have.been.called;\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should not call \"resetOnRefCountZero\" on complete","suites":["share","share(config) with async/deferred reset notifiers"],"updatePoint":{"line":918,"column":57},"line":918,"code":"    it('should not call \"resetOnRefCountZero\" on complete', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const resetOnRefCountZero = spy(() => EMPTY);\n\n        const source = cold('    ---1---(2|)                ');\n        // source: '                           ---1---(2|)  '\n        const sourceSubs = [\n          '                      ^------(! )                ',\n          // break the line, please\n          '                      -------(- )---^------(! )  ',\n        ];\n        const expected = '       ---1---(2 )------1---(2|)  ';\n        const subscription = '   ^------(- )----------(- )  ';\n        const firstPause = cold('       (- )---|            ');\n        const reset = cold('            (- )-r              ');\n        // reset: '                                   (- )-r'\n\n        const sharedSource = source.pipe(share({ resetOnComplete: () => reset, resetOnRefCountZero }));\n\n        const result = concat(sharedSource, firstPause, sharedSource);\n\n        expectObservable(result, subscription).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expect(resetOnRefCountZero).to.not.have.been.called;\n      });\n    });","file":"operators/share-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror a simple source Observable","suites":["shareReplay"],"updatePoint":{"line":17,"column":46},"line":17,"code":"  it('should mirror a simple source Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--1-2---3-4--5-|');\n      const sourceSubs = ' ^--------------!';\n      const expected = '   --1-2---3-4--5-|';\n\n      const published = source.pipe(shareReplay());\n\n      expectObservable(published).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should do nothing if result is not subscribed","suites":["shareReplay"],"updatePoint":{"line":30,"column":51},"line":30,"code":"  it('should do nothing if result is not subscribed', () => {\n    let subscribed = false;\n    const source = new Observable(() => {\n      subscribed = true;\n    });\n    source.pipe(shareReplay());\n    expect(subscribed).to.be.false;\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, bufferSize=1","suites":["shareReplay"],"updatePoint":{"line":39,"column":74},"line":39,"code":"  it('should multicast the same values to multiple observers, bufferSize=1', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-|');\n      const sourceSubs = '     ^-----------!';\n      const subscriber1 = hot('a|           ');\n      const expected1 = '      -1-2-3----4-|';\n      const subscriber2 = hot('----b|       ');\n      const expected2 = '      ----23----4-|';\n      const subscriber3 = hot('--------c|   ');\n      const expected3 = '      --------3-4-|';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast the same values to multiple observers, bufferSize=2","suites":["shareReplay"],"updatePoint":{"line":59,"column":74},"line":59,"code":"  it('should multicast the same values to multiple observers, bufferSize=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-----3------4-|');\n      const sourceSubs = '     ^-----------------!';\n      const subscriber1 = hot('a|                 ');\n      const expected1 = '      -1-2-----3------4-|';\n      const subscriber2 = hot('----b|             ');\n      const expected2 = '      ----(12)-3------4-|';\n      const subscriber3 = hot('-----------c|      ');\n      const expected3 = '      -----------(23)-4-|';\n\n      const shared = source.pipe(shareReplay(2));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an error from the source to multiple observers","suites":["shareReplay"],"updatePoint":{"line":79,"column":69},"line":79,"code":"  it('should multicast an error from the source to multiple observers', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-3----4-#');\n      const sourceSubs = '     ^-----------!';\n      const subscriber1 = hot('a|           ');\n      const expected1 = '      -1-2-3----4-#';\n      const subscriber2 = hot('----b|       ');\n      const expected2 = '      ----23----4-#';\n      const subscriber3 = hot('--------c|   ');\n      const expected3 = '      --------3-4-#';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast an empty source","suites":["shareReplay"],"updatePoint":{"line":99,"column":38},"line":99,"code":"  it('should multicast an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|   ');\n      const sourceSubs = ' (^!)';\n      const expected = '   |   ';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(shared).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a never source","suites":["shareReplay"],"updatePoint":{"line":112,"column":37},"line":112,"code":"  it('should multicast a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const sourceSubs = ' ^';\n      const expected = '   -';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(shared).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should multicast a throw source","suites":["shareReplay"],"updatePoint":{"line":125,"column":37},"line":125,"code":"  it('should multicast a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#   ');\n      const sourceSubs = ' (^!)';\n      const expected = '   #   ';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(shared).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay results to subsequent subscriptions if source completes, bufferSize=2","suites":["shareReplay"],"updatePoint":{"line":138,"column":89},"line":138,"code":"  it('should replay results to subsequent subscriptions if source completes, bufferSize=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-----3-|        ');\n      const sourceSubs = '     ^----------!        ';\n      const subscriber1 = hot('a|                  ');\n      const expected1 = '      -1-2-----3-|        ';\n      const subscriber2 = hot('----b|              ');\n      const expected2 = '      ----(12)-3-|        ';\n      const subscriber3 = hot('---------------(c|) ');\n      const expected3 = '      ---------------(23|)';\n\n      const shared = source.pipe(shareReplay(2));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should completely restart for subsequent subscriptions if source errors, bufferSize=2","suites":["shareReplay"],"updatePoint":{"line":158,"column":91},"line":158,"code":"  it('should completely restart for subsequent subscriptions if source errors, bufferSize=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const source = cold('    -1-2-----3-#               ');\n      const sourceSubs1 = '    ^----------!               ';\n      const subscriber1 = hot('a|                         ');\n      const expected1 = '      -1-2-----3-#               ';\n      const subscriber2 = hot('----b|                     ');\n      const expected2 = '      ----(12)-3-#               ';\n      const subscriber3 = hot('---------------(c|)        ');\n      const expected3 = '      ----------------1-2-----3-#';\n      const sourceSubs2 = '    ---------------^----------!';\n\n      const shared = source.pipe(shareReplay(2));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe([sourceSubs1, sourceSubs2]);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should be retryable, bufferSize=2","suites":["shareReplay"],"updatePoint":{"line":179,"column":39},"line":179,"code":"  it('should be retryable, bufferSize=2', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const subs = [];\n      const source = cold('    -1-2-----3-#                      ');\n      subs.push('              ^----------!                      ');\n      subs.push('              -----------^----------!           ');\n      subs.push('              ----------------------^----------!');\n      const subscriber1 = hot('a|                                ');\n      const expected1 = '      -1-2-----3--1-2-----3-#           ';\n      const subscriber2 = hot('----b|                            ');\n      const expected2 = '      ----(12)-3--1-2-----3-#           ';\n      const subscriber3 = hot('---------------(c|)               ');\n      const expected3 = '      ---------------(12)-3--1-2-----3-#';\n\n      const shared = source.pipe(shareReplay(2), retry(1));\n\n      expectObservable(subscriber1.pipe(mergeMapTo(shared))).toBe(expected1);\n      expectObservable(subscriber2.pipe(mergeMapTo(shared))).toBe(expected2);\n      expectObservable(subscriber3.pipe(mergeMapTo(shared))).toBe(expected3);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"when no windowTime is given ReplaySubject should be in _infiniteTimeWindow mode","suites":["shareReplay"],"updatePoint":{"line":202,"column":85},"line":202,"code":"  it('when no windowTime is given ReplaySubject should be in _infiniteTimeWindow mode', () => {\n    const spy = sinon.spy(testScheduler, 'now');\n\n    of(1).pipe(shareReplay(1, undefined, testScheduler)).subscribe();\n    spy.restore();\n    expect(spy, 'ReplaySubject should not call scheduler.now() when no windowTime is given').to.be.not.called;\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not restart due to unsubscriptions if refCount is false","suites":["shareReplay"],"updatePoint":{"line":210,"column":68},"line":210,"code":"  it('should not restart due to unsubscriptions if refCount is false', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('a-b-c-d-e-f-g-h-i-j');\n      const sourceSubs = ' ^------------------';\n      const sub1 = '       ^------!           ';\n      const expected1 = '  a-b-c-d-           ';\n      const sub2 = '       -----------^-------';\n      const expected2 = '  -----------fg-h-i-j';\n\n      const shared = source.pipe(shareReplay({ bufferSize: 1, refCount: false }));\n\n      expectObservable(shared, sub1).toBe(expected1);\n      expectObservable(shared, sub2).toBe(expected2);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should restart due to unsubscriptions if refCount is true","suites":["shareReplay"],"updatePoint":{"line":227,"column":63},"line":227,"code":"  it('should restart due to unsubscriptions if refCount is true', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const sourceSubs = [];\n      const source = cold('a-b-c-d-e-f-g-h-i-j           ');\n      sourceSubs.push('    ^------!----------------------');\n      sourceSubs.push('    -----------^------------------');\n      const sub1 = '       ^------!                      ';\n      const expected1 = '  a-b-c-d-                      ';\n      const sub2 = '       -----------^------------------';\n      const expected2 = '  -----------a-b-c-d-e-f-g-h-i-j';\n\n      const shared = source.pipe(shareReplay({ bufferSize: 1, refCount: true }));\n\n      expectObservable(shared, sub1).toBe(expected1);\n      expectObservable(shared, sub2).toBe(expected2);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not restart due to unsubscriptions if refCount is true when the source has completed","suites":["shareReplay"],"updatePoint":{"line":246,"column":97},"line":246,"code":"  it('should not restart due to unsubscriptions if refCount is true when the source has completed', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('a-(b|)         ');\n      const sourceSubs = ' ^-!            ';\n      const sub1 = '       ^------!       ';\n      const expected1 = '  a-(b|)         ';\n      const sub2 = '       -----------^!  ';\n      const expected2 = '  -----------(b|)';\n\n      const shared = source.pipe(shareReplay({ bufferSize: 1, refCount: true }));\n\n      expectObservable(shared, sub1).toBe(expected1);\n      expectObservable(shared, sub2).toBe(expected2);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not restart a synchronous source due to unsubscriptions if refCount is true when the source has completed","suites":["shareReplay"],"updatePoint":{"line":263,"column":118},"line":263,"code":"  it('should not restart a synchronous source due to unsubscriptions if refCount is true when the source has completed', () => {\n    // The test above this one doesn't actually test completely synchronous\n    // behaviour because of this problem:\n    // https://github.com/ReactiveX/rxjs/issues/5523\n\n    let subscriptions = 0;\n    const source = defer(() => {\n      ++subscriptions;\n      return of(42);\n    }).pipe(shareReplay({ bufferSize: 1, refCount: true }));\n    source.subscribe();\n    source.subscribe();\n    expect(subscriptions).to.equal(1);\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should default to refCount being false","suites":["shareReplay"],"updatePoint":{"line":278,"column":44},"line":278,"code":"  it('should default to refCount being false', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('a-b-c-d-e-f-g-h-i-j');\n      const sourceSubs = ' ^------------------';\n      const sub1 = '       ^------!           ';\n      const expected1 = '  a-b-c-d-           ';\n      const sub2 = '       -----------^-------';\n      const expected2 = '  -----------fg-h-i-j';\n\n      const shared = source.pipe(shareReplay(1));\n\n      expectObservable(shared, sub1).toBe(expected1);\n      expectObservable(shared, sub2).toBe(expected2);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break lift() composability","suites":["shareReplay"],"updatePoint":{"line":295,"column":43},"line":295,"code":"  it('should not break lift() composability', (done) => {\n    class MyCustomObservable<T> extends Observable<T> {\n      lift<R>(operator: Operator<T, R>): Observable<R> {\n        const observable = new MyCustomObservable<R>();\n        (<any>observable).source = this;\n        (<any>observable).operator = operator;\n        return observable;\n      }\n    }\n\n    const result = new MyCustomObservable((observer: Observer<number>) => {\n      observer.next(1);\n      observer.next(2);\n      observer.next(3);\n      observer.complete();\n    }).pipe(shareReplay());\n\n    expect(result instanceof MyCustomObservable).to.be.true;\n\n    const expected = [1, 2, 3];\n\n    result.subscribe({\n      next(n: any) {\n        expect(expected.length).to.be.greaterThan(0);\n        expect(n).to.equal(expected.shift());\n      },\n      error() {\n        done(new Error('should not be called'));\n      },\n      complete() {\n        done();\n      },\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip values on a sync source","suites":["shareReplay"],"updatePoint":{"line":330,"column":45},"line":330,"code":"  it('should not skip values on a sync source', () => {\n    testScheduler.run(({ cold, expectObservable }) => {\n      const a = from(['a', 'b', 'c', 'd']);\n      // We would like for the previous line to read like this:\n      //\n      // const a = cold('(abcd|)');\n      //\n      // However, that would synchronously emit multiple values at frame 0,\n      // but it's not synchronous upon-subscription.\n      // TODO: revisit once https://github.com/ReactiveX/rxjs/issues/5523 is fixed\n\n      const x = cold('  x-------x');\n      const expected = '(abcd)--d';\n\n      const shared = a.pipe(shareReplay(1));\n      const result = x.pipe(mergeMapTo(shared));\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["shareReplay"],"updatePoint":{"line":350,"column":73},"line":350,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(shareReplay({ refCount: true }), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should not leak the subscriber for sync sources","suites":["shareReplay"],"updatePoint":{"line":370,"column":55},"line":370,"code":"    it('should not leak the subscriber for sync sources', (done) => {\n      let callback: (() => void) | undefined = () => {\n        /* noop */\n      };\n\n      const registry = new FinalizationRegistry((value: any) => {\n        expect(value).to.equal('callback');\n        done();\n      });\n      registry.register(callback, 'callback');\n\n      const shared = of(42).pipe(shareReplay(1));\n      shared.subscribe(callback);\n\n      callback = undefined;\n      global.gc?.();\n    });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should be referentially-transparent","suites":["shareReplay"],"updatePoint":{"line":391,"column":41},"line":391,"code":"  it('should be referentially-transparent', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source1 = cold('-1-2-3-4-5-|');\n      const source1Subs = ' ^----------!';\n      const expected1 = '   -1-2-3-4-5-|';\n      const source2 = cold('-6-7-8-9-0-|');\n      const source2Subs = ' ^----------!';\n      const expected2 = '   -6-7-8-9-0-|';\n\n      // Calls to the _operator_ must be referentially-transparent.\n      const partialPipeLine = pipe(shareReplay({ refCount: false }));\n\n      // The non-referentially-transparent sharing occurs within the _operator function_\n      // returned by the _operator_ and that happens when the complete pipeline is composed.\n      const shared1 = source1.pipe(partialPipeLine);\n      const shared2 = source2.pipe(partialPipeLine);\n\n      expectObservable(shared1).toBe(expected1);\n      expectSubscriptions(source1.subscriptions).toBe(source1Subs);\n      expectObservable(shared2).toBe(expected2);\n      expectSubscriptions(source2.subscriptions).toBe(source2Subs);\n    });\n  });","file":"operators/shareReplay-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from empty predicate if observable emits multiple time","suites":["single operator"],"updatePoint":{"line":15,"column":79},"line":15,"code":"  it('should raise error from empty predicate if observable emits multiple time', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----!      ';\n      const expected = '-----#      ';\n\n      expectObservable(e1.pipe(single())).toBe(expected, null, new SequenceError('Too many matching values'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from empty predicate if observable does not emit","suites":["single operator"],"updatePoint":{"line":26,"column":73},"line":26,"code":"  it('should raise error from empty predicate if observable does not emit', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--|');\n      const e1subs = '     ^--!';\n      const expected = '   ---#';\n\n      expectObservable(e1.pipe(single())).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should return only element from empty predicate if observable emits only once","suites":["single operator"],"updatePoint":{"line":37,"column":83},"line":37,"code":"  it('should return only element from empty predicate if observable emits only once', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = '-----(a|)';\n\n      expectObservable(e1.pipe(single())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["single operator"],"updatePoint":{"line":48,"column":53},"line":48,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const unsub = '   ----!        ';\n      const e1subs = '  ^---!        ';\n      const expected = '------------';\n\n      expectObservable(e1.pipe(single()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["single operator"],"updatePoint":{"line":60,"column":83},"line":60,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^--!        ';\n      const expected = '----        ';\n      const unsub = '   ---!        ';\n\n      const result = e1.pipe(\n        mergeMap(x => of(x)),\n        single(),\n        mergeMap(x => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from empty predicate if observable emits error","suites":["single operator"],"updatePoint":{"line":78,"column":71},"line":78,"code":"  it('should raise error from empty predicate if observable emits error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b^--#');\n      const e1subs = '        ^--!';\n      const expected = '      ---#';\n\n      expectObservable(e1.pipe(single())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from predicate if observable emits error","suites":["single operator"],"updatePoint":{"line":89,"column":65},"line":89,"code":"  it('should raise error from predicate if observable emits error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--b^--#');\n      const e1subs = '      ^--!';\n      const expected = '    ---#';\n\n      expectObservable(e1.pipe(single(v => v === 'c'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if predicate throws error","suites":["single operator"],"updatePoint":{"line":100,"column":50},"line":100,"code":"  it('should raise error if predicate throws error', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--|');\n      const e1subs = '  ^----------!   ';\n      const expected = '-----------#   ';\n\n      expectObservable(\n        e1.pipe(\n          single(v => {\n            if (v !== 'd') {\n              return false;\n            }\n            throw 'error';\n          })\n        )\n      ).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should return element from predicate if observable have single matching element","suites":["single operator"],"updatePoint":{"line":120,"column":85},"line":120,"code":"  it('should return element from predicate if observable have single matching element', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const expected = '-----------(b|)';\n\n      expectObservable(e1.pipe(single(v => v === 'b'))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from predicate if observable have multiple matching element","suites":["single operator"],"updatePoint":{"line":131,"column":84},"line":131,"code":"  it('should raise error from predicate if observable have multiple matching element', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--a--b--b--|');\n      const e1subs = '  ^----------!      ';\n      const expected = '-----------#      ';\n\n      expectObservable(e1.pipe(single(v => v === 'b'))).toBe(expected, null, new SequenceError('Too many matching values'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from predicate if observable does not emit","suites":["single operator"],"updatePoint":{"line":142,"column":67},"line":142,"code":"  it('should raise error from predicate if observable does not emit', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--|');\n      const e1subs = '     ^--!';\n      const expected = '   ---#';\n\n      expectObservable(e1.pipe(single(v => v === 'a'))).toBe(expected, null, new EmptyError());\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error from predicate if observable does not contain matching element","suites":["single operator"],"updatePoint":{"line":153,"column":87},"line":153,"code":"  it('should raise error from predicate if observable does not contain matching element', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const expected = '-----------#';\n\n      expectObservable(e1.pipe(single(v => v === 'x'))).toBe(expected, undefined, new NotFoundError('No matching values'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should call predicate with indices starting at 0","suites":["single operator"],"updatePoint":{"line":164,"column":54},"line":164,"code":"  it('should call predicate with indices starting at 0', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--|');\n      const e1subs = '  ^----------!';\n      const expected = '-----------(b|)';\n\n      let indices: number[] = [];\n      const predicate = function(value: string, index: number) {\n        indices.push(index);\n        return value === 'b';\n      };\n\n      expectObservable(\n        e1.pipe(\n          single(predicate),\n          tap({ complete: () => {\n            expect(indices).to.deep.equal([0, 1, 2]);\n          } })\n        )\n      ).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for synchronous empty observables when no arguments are provided","suites":["single operator"],"updatePoint":{"line":188,"column":83},"line":188,"code":"  it('should error for synchronous empty observables when no arguments are provided', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|');\n      const expected = '   #';\n      const subs = ['      (^!)'];\n      const result = source.pipe(single());\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for async empty observables when no arguments are provided","suites":["single operator"],"updatePoint":{"line":200,"column":77},"line":200,"code":"  it('should error for async empty observables when no arguments are provided', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-------|');\n      const expected = '   -------#';\n      const subs = ['      ^------!'];\n      const result = source.pipe(single());\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for hot observables that do not emit while active when no arguments are provided","suites":["single operator"],"updatePoint":{"line":212,"column":99},"line":212,"code":"  it('should error for hot observables that do not emit while active when no arguments are provided', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--^----|');\n      const expected = '          -----#';\n      const subs = ['             ^----!'];\n      const result = source.pipe(single());\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for synchronous empty observables when predicate never passes","suites":["single operator"],"updatePoint":{"line":224,"column":80},"line":224,"code":"  it('should error for synchronous empty observables when predicate never passes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|');\n      const expected = '   #';\n      const subs = ['      (^!)'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for async empty observables when predicate never passes","suites":["single operator"],"updatePoint":{"line":236,"column":74},"line":236,"code":"  it('should error for async empty observables when predicate never passes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-------|');\n      const expected = '   -------#';\n      const subs = ['      ^------!'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for hot observables that do not emit while active when predicate never passes","suites":["single operator"],"updatePoint":{"line":248,"column":96},"line":248,"code":"  it('should error for hot observables that do not emit while active when predicate never passes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--^----|');\n      const expected = '          -----#';\n      const subs = ['             ^----!'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new EmptyError());\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for synchronous observables that emit when predicate never passes","suites":["single operator"],"updatePoint":{"line":260,"column":84},"line":260,"code":"  it('should error for synchronous observables that emit when predicate never passes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('(a|)');\n      const expected = '   #';\n      const subs = ['      (^!)'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new NotFoundError('No matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for async observables that emit when predicate never passes","suites":["single operator"],"updatePoint":{"line":272,"column":78},"line":272,"code":"  it('should error for async observables that emit when predicate never passes', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--a--b-|');\n      const expected = '   -------#';\n      const subs = ['      ^------!'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new NotFoundError('No matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for hot observables that emit while active when predicate never passes","suites":["single operator"],"updatePoint":{"line":284,"column":89},"line":284,"code":"  it('should error for hot observables that emit while active when predicate never passes', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--^--c--d--|');\n      const expected = '          ---------#';\n      const subs = ['             ^--------!'];\n      const result = source.pipe(single(() => false));\n\n      expectObservable(result).toBe(expected, undefined, new NotFoundError('No matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for synchronous observables when the predicate passes more than once","suites":["single operator"],"updatePoint":{"line":296,"column":87},"line":296,"code":"  it('should error for synchronous observables when the predicate passes more than once', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('(axbxc|)');\n      const expected = '   #';\n      const subs = ['      (^!)'];\n      const result = source.pipe(single(v => v === 'x'));\n\n      expectObservable(result).toBe(expected, undefined, new SequenceError('Too many matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for async observables that emit when the predicate passes more than once","suites":["single operator"],"updatePoint":{"line":308,"column":91},"line":308,"code":"  it('should error for async observables that emit when the predicate passes more than once', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--a-x-b-x-c-|');\n      const expected = '   --------#';\n      const subs = ['      ^-------!'];\n      const result = source.pipe(single(v => v === 'x'));\n\n      expectObservable(result).toBe(expected, undefined, new SequenceError('Too many matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should error for hot observables that emit while active when the predicate passes more than once","suites":["single operator"],"updatePoint":{"line":320,"column":102},"line":320,"code":"  it('should error for hot observables that emit while active when the predicate passes more than once', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--^--c--x--d--x--|');\n      const expected = '          ------------#';\n      const subs = ['             ^-----------!'];\n      const result = source.pipe(single(v => v === 'x'));\n\n      expectObservable(result).toBe(expected, undefined, new SequenceError('Too many matching values'));\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["single operator"],"updatePoint":{"line":332,"column":73},"line":332,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits, it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      single(),\n    ).subscribe({ next: () => { /* noop */ }, error: () => { /* noop */ } });\n\n    expect(sideEffects).to.deep.equal([0, 1]);\n  });","file":"operators/single-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip values before a total","suites":["skip"],"updatePoint":{"line":15,"column":39},"line":15,"code":"  it('should skip values before a total', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const subs = '      ^----------------!';\n      const expected = '  -----------d--e--|';\n\n      expectObservable(source.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all values without error if total is more than actual number of values","suites":["skip"],"updatePoint":{"line":26,"column":88},"line":26,"code":"  it('should skip all values without error if total is more than actual number of values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const subs = '      ^----------------!';\n      const expected = '  -----------------|';\n\n      expectObservable(source.pipe(skip(6))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all values without error if total is same as actual number of values","suites":["skip"],"updatePoint":{"line":37,"column":86},"line":37,"code":"  it('should skip all values without error if total is same as actual number of values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const subs = '      ^----------------!';\n      const expected = '  -----------------|';\n\n      expectObservable(source.pipe(skip(5))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip if count is zero","suites":["skip"],"updatePoint":{"line":48,"column":38},"line":48,"code":"  it('should not skip if count is zero', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const subs = '      ^----------------!';\n      const expected = '  --a--b--c--d--e--|';\n\n      expectObservable(source.pipe(skip(0))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip if count is negative value","suites":["skip"],"updatePoint":{"line":59,"column":48},"line":59,"code":"  it('should not skip if count is negative value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('--a--b--c--d--e--|');\n      const subs = '       ^----------------!';\n      const expected = '   --a--b--c--d--e--|';\n\n      expectObservable(source.pipe(skip(-42))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["skip"],"updatePoint":{"line":70,"column":53},"line":70,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const unsub = '     ----------!       ';\n      const subs = '      ^---------!       ';\n      const expected = '  --------c--       ';\n\n      expectObservable(source.pipe(skip(2)), unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["skip"],"updatePoint":{"line":82,"column":83},"line":82,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|');\n      const subs = '      ^---------!       ';\n      const expected = '  --------c--       ';\n      const unsub = '     ----------!       ';\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        skip(2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if skip count is more than actual number of emits and source raises error","suites":["skip"],"updatePoint":{"line":100,"column":98},"line":100,"code":"  it('should raise error if skip count is more than actual number of emits and source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--#');\n      const subs = '      ^-------------!';\n      const expected = '  --------------#';\n\n      expectObservable(source.pipe(skip(6))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if skip count is same as emits of source and source raises error","suites":["skip"],"updatePoint":{"line":111,"column":89},"line":111,"code":"  it('should raise error if skip count is same as emits of source and source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--#');\n      const subs = '      ^-------------!';\n      const expected = '  --------------#';\n\n      expectObservable(source.pipe(skip(4))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip values before a total and raises error if source raises error","suites":["skip"],"updatePoint":{"line":122,"column":79},"line":122,"code":"  it('should skip values before a total and raises error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--#');\n      const subs = '      ^-------------!';\n      const expected = '  -----------d--#';\n\n      expectObservable(source.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete regardless of skip count if source is empty","suites":["skip"],"updatePoint":{"line":133,"column":65},"line":133,"code":"  it('should complete regardless of skip count if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source never completes without emit","suites":["skip"],"updatePoint":{"line":144,"column":64},"line":144,"code":"  it('should not complete if source never completes without emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip values before total and never completes if source emits and does not complete","suites":["skip"],"updatePoint":{"line":155,"column":95},"line":155,"code":"  it('should skip values before total and never completes if source emits and does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c-');\n      const e1subs = '  ^         ';\n      const expected = '-----b--c-';\n\n      expectObservable(e1.pipe(skip(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all values and never completes if total is more than numbers of value and source does not complete","suites":["skip"],"updatePoint":{"line":166,"column":116},"line":166,"code":"  it('should skip all values and never completes if total is more than numbers of value and source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c-');\n      const e1subs = '  ^         ';\n      const expected = '----------';\n\n      expectObservable(e1.pipe(skip(6))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all values and never completes if total is same asnumbers of value and source does not complete","suites":["skip"],"updatePoint":{"line":177,"column":113},"line":177,"code":"  it('should skip all values and never completes if total is same asnumbers of value and source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c-');\n      const e1subs = '  ^         ';\n      const expected = '----------';\n\n      expectObservable(e1.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source throws","suites":["skip"],"updatePoint":{"line":188,"column":41},"line":188,"code":"  it('should raise error if source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(skip(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["skip"],"updatePoint":{"line":199,"column":73},"line":199,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      skip(1),\n      take(2),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/skip-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip two values of an observable with many values","suites":["skipLast operator"],"updatePoint":{"line":15,"column":62},"line":15,"code":"  it('should skip two values of an observable with many values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '-------------a---b--|';\n\n      expectObservable(e1.pipe(skipLast(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip last three values","suites":["skipLast operator"],"updatePoint":{"line":26,"column":35},"line":26,"code":"  it('should skip last three values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '-----------------a--|';\n\n      expectObservable(e1.pipe(skipLast(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements when trying to skip larger then source","suites":["skipLast operator"],"updatePoint":{"line":37,"column":69},"line":37,"code":"  it('should skip all elements when trying to skip larger then source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--------------------|';\n\n      expectObservable(e1.pipe(skipLast(5))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements when trying to skip exact","suites":["skipLast operator"],"updatePoint":{"line":48,"column":56},"line":48,"code":"  it('should skip all elements when trying to skip exact', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--------------------|';\n\n      expectObservable(e1.pipe(skipLast(4))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip any values","suites":["skipLast operator"],"updatePoint":{"line":59,"column":32},"line":59,"code":"  it('should not skip any values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----b----c---d--|';\n\n      expectObservable(e1.pipe(skipLast(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip any values if provided with negative value","suites":["skipLast operator"],"updatePoint":{"line":70,"column":64},"line":70,"code":"  it('should not skip any values if provided with negative value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------------------!';\n      const expected = '--a-----b----c---d--|';\n\n      expectObservable(e1.pipe(skipLast(-42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty","suites":["skipLast operator"],"updatePoint":{"line":81,"column":28},"line":81,"code":"  it('should work with empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should go on forever on never","suites":["skipLast operator"],"updatePoint":{"line":92,"column":35},"line":92,"code":"  it('should go on forever on never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip one value from an observable with one value","suites":["skipLast operator"],"updatePoint":{"line":103,"column":61},"line":103,"code":"  it('should skip one value from an observable with one value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---(a|)');\n      const e1subs = '  ^--!   ';\n      const expected = '---|   ';\n\n      expectObservable(e1.pipe(skipLast(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip one value from an observable with many values","suites":["skipLast operator"],"updatePoint":{"line":114,"column":63},"line":114,"code":"  it('should skip one value from an observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----c---d--|');\n      const e1subs = '     ^--------------!';\n      const expected = '   --------b---c--|';\n\n      expectObservable(e1.pipe(skipLast(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and early emission","suites":["skipLast operator"],"updatePoint":{"line":125,"column":47},"line":125,"code":"  it('should work with empty and early emission', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^----|');\n      const e1subs = '     ^----!';\n      const expected = '   -----|';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from the source observable","suites":["skipLast operator"],"updatePoint":{"line":136,"column":55},"line":136,"code":"  it('should propagate error from the source observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^---#', undefined, 'too bad');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from an observable with values","suites":["skipLast operator"],"updatePoint":{"line":147,"column":59},"line":147,"code":"  it('should propagate error from an observable with values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b--#');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["skipLast operator"],"updatePoint":{"line":158,"column":53},"line":158,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!            ';\n      const e1subs = '   ^--------!            ';\n      const expected = ' ----------            ';\n\n      expectObservable(e1.pipe(skipLast(42)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["skipLast operator"],"updatePoint":{"line":170,"column":28},"line":170,"code":"  it('should work with throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(skipLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["skipLast operator"],"updatePoint":{"line":181,"column":72},"line":181,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!            ';\n      const e1subs = '   ^--------!            ';\n      const expected = ' ----------            ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        skipLast(42),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["skipLast operator"],"updatePoint":{"line":199,"column":73},"line":199,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      skipLast(1),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    // This expectation might seem a little strange, but the implementation of\n    // skipLast works by eating the number of elements that are to be skipped,\n    // so it will consume the number skipped in addition to the number taken.\n    expect(sideEffects).to.deep.equal([0, 1, 2, 3]);\n  });","file":"operators/skipLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip values until another observable notifies","suites":["skipUntil"],"updatePoint":{"line":17,"column":58},"line":17,"code":"  it('should skip values until another observable notifies', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--c--d--e----|');\n      const e1subs = '    ^------------------!';\n      const skip = hot('  ---------x------|   ');\n      const skipSubs = '  ^--------!          ';\n      const expected = '  -----------d--e----|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements after notifier emits","suites":["skipUntil"],"updatePoint":{"line":31,"column":47},"line":31,"code":"  it('should emit elements after notifier emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--c--d--e--|');\n      const e1subs = '    ^----------------!';\n      const skip = hot('  ---------x----|   ');\n      const skipSubs = '  ^--------!        ';\n      const expected = '  -----------d--e--|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit elements after a synchronous notifier emits","suites":["skipUntil"],"updatePoint":{"line":45,"column":61},"line":45,"code":"  it('should emit elements after a synchronous notifier emits', () => {\n    const values: string[] = [];\n\n    of('a', 'b')\n      .pipe(skipUntil(of('x')))\n      .subscribe({\n        next(value) {\n          values.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(values).to.deep.equal(['a', 'b']);\n        },\n      });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise an error if notifier throws and source is hot","suites":["skipUntil"],"updatePoint":{"line":63,"column":64},"line":63,"code":"  it('should raise an error if notifier throws and source is hot', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^------------!    ';\n      const skip = hot('-------------#    ');\n      const skipSubs = '^------------!    ';\n      const expected = '-------------#    ';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements when notifier does not emit and completes early","suites":["skipUntil"],"updatePoint":{"line":77,"column":78},"line":77,"code":"  it('should skip all elements when notifier does not emit and completes early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^----------------!';\n      const skip = hot('------------|     ');\n      const skipSubs = '^-----------!     ';\n      const expected = '-----------------|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["skipUntil"],"updatePoint":{"line":91,"column":53},"line":91,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--c--d--e----|');\n      const unsub = '     ---------!          ';\n      const e1subs = '    ^--------!          ';\n      const skip = hot('  -------------x--|   ');\n      const skipSubs = '  ^--------!          ';\n      const expected = '  ----------          ';\n\n      expectObservable(e1.pipe(skipUntil(skip)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["skipUntil"],"updatePoint":{"line":106,"column":83},"line":106,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--c--d--e----|');\n      const e1subs = '    ^--------!          ';\n      const skip = hot('  -------------x--|   ');\n      const skipSubs = '  ^--------!          ';\n      const expected = '  ----------          ';\n      const unsub = '     ---------!          ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        skipUntil(skip),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains with interop inners when result is unsubscribed explicitly","suites":["skipUntil"],"updatePoint":{"line":127,"column":103},"line":127,"code":"  it('should not break unsubscription chains with interop inners when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--c--d--e----|');\n      const e1subs = '    ^--------!          ';\n      const skip = hot('  -------------x--|   ');\n      const skipSubs = '  ^--------!          ';\n      const expected = '  ----------          ';\n      const unsub = '     ---------!          ';\n\n      // This test is the same as the previous test, but the observable is\n      // manipulated to make it look like an interop observable - an observable\n      // from a foreign library. Interop subscribers are treated differently:\n      // they are wrapped in a safe subscriber. This test ensures that\n      // unsubscriptions are chained all the way to the interop subscriber.\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        skipUntil(asInteropObservable(skip)),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements when notifier is empty","suites":["skipUntil"],"updatePoint":{"line":154,"column":53},"line":154,"code":"  it('should skip all elements when notifier is empty', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   --a--b--c--d--e--|');\n      const e1subs = '   ^----------------!';\n      const skip = cold('|                 ');\n      const skipSubs = ' (^!)              ';\n      const expected = ' -----------------|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should keep subscription to source, to wait for its eventual completion","suites":["skipUntil"],"updatePoint":{"line":168,"column":77},"line":168,"code":"  it('should keep subscription to source, to wait for its eventual completion', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ------------------------------|');\n      const e1subs = '  ^-----------------------------!';\n      const skip = hot('-------|                       ');\n      const skipSubs = '^------!                       ';\n      const expected = '------------------------------|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if hot source observable does not complete","suites":["skipUntil"],"updatePoint":{"line":182,"column":68},"line":182,"code":"  it('should not complete if hot source observable does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -                ');\n      const e1subs = '  ^                ';\n      const skip = hot('-------------x--|');\n      const skipSubs = '^------------!   ';\n      const expected = '-                ';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if cold source observable never completes","suites":["skipUntil"],"updatePoint":{"line":196,"column":67},"line":196,"code":"  it('should not complete if cold source observable never completes', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -                ');\n      const e1subs = '  ^                ';\n      const skip = hot('-------------x--|');\n      const skipSubs = '^------------!   ';\n      const expected = '-                ';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if cold source is never and notifier errors","suites":["skipUntil"],"updatePoint":{"line":210,"column":68},"line":210,"code":"  it('should raise error if cold source is never and notifier errors', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -             ');\n      const e1subs = '  ^------------!';\n      const skip = hot('-------------#');\n      const skipSubs = '^------------!';\n      const expected = '-------------#';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements and complete if notifier is cold never","suites":["skipUntil"],"updatePoint":{"line":224,"column":69},"line":224,"code":"  it('should skip all elements and complete if notifier is cold never', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   --a--b--c--d--e--|');\n      const e1subs = '   ^----------------!';\n      const skip = cold('-                 ');\n      const skipSubs = ' ^----------------!';\n      const expected = ' -----------------|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements and complete if notifier is a hot never","suites":["skipUntil"],"updatePoint":{"line":238,"column":70},"line":238,"code":"  it('should skip all elements and complete if notifier is a hot never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = '  ^----------------!';\n      const skip = hot('-                 ');\n      const skipSubs = '^----------------!';\n      const expected = '-----------------|';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements and complete, even if notifier would not complete until later","suites":["skipUntil"],"updatePoint":{"line":252,"column":92},"line":252,"code":"  it('should skip all elements and complete, even if notifier would not complete until later', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ^-a--b--c--d--e--|       ');\n      const e1subs = '  ^----------------!       ';\n      const skip = hot('^-----------------------|');\n      const skipSubs = '^----------------!       ';\n      const expected = '-----------------|       ';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source does not complete if notifier completes without emission","suites":["skipUntil"],"updatePoint":{"line":266,"column":92},"line":266,"code":"  it('should not complete if source does not complete if notifier completes without emission', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -              ');\n      const e1subs = '  ^              ';\n      const skip = hot('--------------|');\n      const skipSubs = '^-------------!';\n      const expected = '-              ';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete if source and notifier are both hot never","suites":["skipUntil"],"updatePoint":{"line":280,"column":67},"line":280,"code":"  it('should not complete if source and notifier are both hot never', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const skip = hot('-');\n      const skipSubs = '^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(skip.subscriptions).toBe(skipSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip skip all elements if notifier is unsubscribed explicitly before the notifier emits","suites":["skipUntil"],"updatePoint":{"line":294,"column":100},"line":294,"code":"  it('should skip skip all elements if notifier is unsubscribed explicitly before the notifier emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const e1subs = [\n        '               ^----------------!',\n        '               ^----------------!', // for the explicit subscribe some lines below\n      ];\n      const skip = new Subject<string>();\n      const expected = '-----------------|';\n\n      e1.subscribe((x: string) => {\n        if (x === 'd' && !skip.closed) {\n          skip.next('x');\n        }\n\n        skip.unsubscribe();\n      });\n\n      expectObservable(e1.pipe(skipUntil(skip))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe the notifier after its first nexted value","suites":["skipUntil"],"updatePoint":{"line":317,"column":66},"line":317,"code":"  it('should unsubscribe the notifier after its first nexted value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -^-o---o---o---o---o---o---|');\n      const notifier = hot('-^--------n--n--n--n--n--n-|');\n      const nSubs = '        ^--------!                 ';\n      const expected = '    -^---------o---o---o---o---|';\n      const result = source.pipe(skipUntil(notifier));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(notifier.subscriptions).toBe(nSubs);\n    });\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous notifier after its first nexted value","suites":["skipUntil"],"updatePoint":{"line":330,"column":82},"line":330,"code":"  it('should stop listening to a synchronous notifier after its first nexted value', () => {\n    const sideEffects: number[] = [];\n    const synchronousNotifer = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n    of(null)\n      .pipe(skipUntil(synchronousNotifer))\n      .subscribe(() => {\n        /* noop */\n      });\n    expect(sideEffects).to.deep.equal([1]);\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["skipUntil"],"updatePoint":{"line":354,"column":73},"line":354,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(skipUntil(of(0)), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/skipUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements until predicate is false","suites":["skipWhile"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should skip all elements until predicate is false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-^2--3--4--5--6--|');\n      const sourceSubs = '   ^---------------!';\n      const expected = '     -------4--5--6--|';\n\n      const predicate = function (v: string) {\n        return +v < 4;\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements with a true predicate","suites":["skipWhile"],"updatePoint":{"line":33,"column":52},"line":33,"code":"  it('should skip all elements with a true predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-^2--3--4--5--6--|');\n      const sourceSubs = '   ^---------------!';\n      const expected = '     ----------------|';\n\n      const result = source.pipe(skipWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements with a truthy predicate","suites":["skipWhile"],"updatePoint":{"line":46,"column":54},"line":46,"code":"  it('should skip all elements with a truthy predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-^2--3--4--5--6--|');\n      const sourceSubs = '   ^---------------!';\n      const expected = '     ----------------|';\n\n      const result = source.pipe(\n        skipWhile((): any => {\n          return {};\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip any element with a false predicate","suites":["skipWhile"],"updatePoint":{"line":63,"column":56},"line":63,"code":"  it('should not skip any element with a false predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-^2--3--4--5--6--|');\n      const sourceSubs = '   ^---------------!';\n      const expected = '     -2--3--4--5--6--|';\n\n      const result = source.pipe(skipWhile(() => false));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should not skip any elements with a falsy predicate","suites":["skipWhile"],"updatePoint":{"line":76,"column":57},"line":76,"code":"  it('should not skip any elements with a falsy predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-^2--3--4--5--6--|');\n      const sourceSubs = '   ^---------------!';\n      const expected = '     -2--3--4--5--6--|';\n\n      const result = source.pipe(skipWhile(() => undefined as any));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip elements on hot source","suites":["skipWhile"],"updatePoint":{"line":89,"column":40},"line":89,"code":"  it('should skip elements on hot source', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--1--2-^-3--4--5--6--7--8--');\n      const sourceSubs = '       ^-------------------';\n      const expected = '         --------5--6--7--8--';\n\n      const predicate = function (v: string) {\n        return +v < 5;\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should be possible to skip using the element's index","suites":["skipWhile"],"updatePoint":{"line":106,"column":58},"line":106,"code":"  it(\"should be possible to skip using the element's index\", () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--|');\n      const sourceSubs = '       ^-------------------!';\n      const expected = '         --------e--f--g--h--|';\n\n      const predicate = function (_v: string, index: number) {\n        return index < 2;\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip using index with source unsubscribes early","suites":["skipWhile"],"updatePoint":{"line":123,"column":60},"line":123,"code":"  it('should skip using index with source unsubscribes early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--|');\n      const sourceSubs = '       ^----------!         ';\n      const unsub = '            -----------!         ';\n      const expected = '         -----d--e---         ';\n\n      const predicate = function (_v: string, index: number) {\n        return index < 1;\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["skipWhile"],"updatePoint":{"line":141,"column":83},"line":141,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--|');\n      const sourceSubs = '       ^----------!         ';\n      const expected = '         -----d--e---         ';\n      const unsub = '            -----------!         ';\n\n      const predicate = function (_v: string, index: number) {\n        return index < 1;\n      };\n\n      const result = source.pipe(\n        mergeMap(function (x) {\n          return of(x);\n        }),\n        skipWhile(predicate),\n        mergeMap(function (x) {\n          return of(x);\n        })\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip using value with source throws","suites":["skipWhile"],"updatePoint":{"line":167,"column":48},"line":167,"code":"  it('should skip using value with source throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--#');\n      const sourceSubs = '       ^-------------------!';\n      const expected = '         -----d--e--f--g--h--#';\n\n      const predicate = function (v: string) {\n        return v !== 'd';\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke predicate while its false and never again","suites":["skipWhile"],"updatePoint":{"line":184,"column":61},"line":184,"code":"  it('should invoke predicate while its false and never again', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--|');\n      const sourceSubs = '       ^-------------------!';\n      const expected = '         --------e--f--g--h--|';\n\n      let invoked = 0;\n      const predicate = function (v: string) {\n        invoked++;\n        return v !== 'e';\n      };\n\n      const result = source.pipe(\n        skipWhile(predicate),\n        tap({\n          complete() {\n            expect(invoked).to.equal(3);\n          },\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle predicate that throws","suites":["skipWhile"],"updatePoint":{"line":210,"column":41},"line":210,"code":"  it('should handle predicate that throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b-^-c--d--e--f--g--h--|');\n      const sourceSubs = '       ^-------!            ';\n      const expected = '         --------#            ';\n\n      const predicate = function (v: string) {\n        if (v === 'e') {\n          throw new Error(\"nom d'une pipe !\");\n        }\n\n        return v !== 'f';\n      };\n\n      const result = source.pipe(skipWhile(predicate));\n\n      expectObservable(result).toBe(expected, undefined, new Error(\"nom d'une pipe !\"));\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle Observable.empty","suites":["skipWhile"],"updatePoint":{"line":231,"column":36},"line":231,"code":"  it('should handle Observable.empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|   ');\n      const subs = '       (^!)';\n      const expected = '   |   ';\n\n      const result = source.pipe(skipWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle Observable.never","suites":["skipWhile"],"updatePoint":{"line":244,"column":36},"line":244,"code":"  it('should handle Observable.never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const subs = '       ^';\n      const expected = '   -';\n\n      const result = source.pipe(skipWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle Observable.throw","suites":["skipWhile"],"updatePoint":{"line":257,"column":36},"line":257,"code":"  it('should handle Observable.throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('#   ');\n      const subs = '       (^!)';\n      const expected = '   #   ';\n\n      const result = source.pipe(skipWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["skipWhile"],"updatePoint":{"line":270,"column":73},"line":270,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        skipWhile((value) => value < 2),\n        take(1)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/skipWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should prepend to a cold Observable","suites":["startWith"],"updatePoint":{"line":17,"column":41},"line":17,"code":"  it('should prepend to a cold Observable', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' ---a--b--c--|');\n      const e1subs = '  ^-----------!';\n      const expected = 's--a--b--c--|';\n\n      const result = e1.pipe(startWith('s'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start an observable with given value","suites":["startWith"],"updatePoint":{"line":30,"column":49},"line":30,"code":"  it('should start an observable with given value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = 'x-a--|';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and does not completes if source does not completes","suites":["startWith"],"updatePoint":{"line":43,"column":87},"line":43,"code":"  it('should start with given value and does not completes if source does not completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a-');\n      const e1subs = '  ^-----';\n      const expected = 'x---a-';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and does not completes if source never emits","suites":["startWith"],"updatePoint":{"line":56,"column":80},"line":56,"code":"  it('should start with given value and does not completes if source never emits', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' - ');\n      const e1subs = '  ^ ';\n      const expected = 'x-';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and completes if source does not emits","suites":["startWith"],"updatePoint":{"line":69,"column":74},"line":69,"code":"  it('should start with given value and completes if source does not emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---|');\n      const e1subs = '  ^--!';\n      const expected = 'x--|';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and complete immediately if source is empty","suites":["startWith"],"updatePoint":{"line":82,"column":79},"line":82,"code":"  it('should start with given value and complete immediately if source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(x|)';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and source both if source emits single value","suites":["startWith"],"updatePoint":{"line":95,"column":80},"line":95,"code":"  it('should start with given value and source both if source emits single value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' (a|)');\n      const e1subs = '  (^!)';\n      const expected = '(xa|)';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given values when given value is more than one","suites":["startWith"],"updatePoint":{"line":108,"column":70},"line":108,"code":"  it('should start with given values when given value is more than one', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--|');\n      const e1subs = '  ^-------!';\n      const expected = '(yz)-a--|';\n\n      const result = e1.pipe(startWith('y', 'z'));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and raises error if source raises error","suites":["startWith"],"updatePoint":{"line":121,"column":75},"line":121,"code":"  it('should start with given value and raises error if source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --#');\n      const e1subs = '  ^-!';\n      const expected = 'x-#';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected, defaultStartValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with given value and raises error immediately if source throws error","suites":["startWith"],"updatePoint":{"line":134,"column":87},"line":134,"code":"  it('should start with given value and raises error immediately if source throws error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '(x#)';\n\n      const result = e1.pipe(startWith(defaultStartValue));\n\n      expectObservable(result).toBe(expected, defaultStartValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["startWith"],"updatePoint":{"line":147,"column":53},"line":147,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b----c--d--|');\n      const unsub = '   ---------!        ';\n      const e1subs = '  ^--------!        ';\n      const expected = 's--a--b---        ';\n      const values = { s: 's', a: 'a', b: 'b' };\n\n      const result = e1.pipe(startWith('s', testScheduler));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["startWith"],"updatePoint":{"line":162,"column":83},"line":162,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b----c--d--|');\n      const e1subs = '  ^--------!        ';\n      const expected = 's--a--b---        ';\n      const unsub = '   ---------!        ';\n      const values = { s: 's', a: 'a', b: 'b' };\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        startWith('s', testScheduler),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with empty if given value is not specified","suites":["startWith"],"updatePoint":{"line":181,"column":61},"line":181,"code":"  it('should start with empty if given value is not specified', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-|');\n      const e1subs = '  ^--!';\n      const expected = '-a-|';\n\n      const result = e1.pipe(startWith(testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler as last argument with single value","suites":["startWith"],"updatePoint":{"line":194,"column":64},"line":194,"code":"  it('should accept scheduler as last argument with single value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|');\n      const e1subs = '  ^----!';\n      const expected = 'x-a--|';\n\n      const result = e1.pipe(startWith(defaultStartValue, testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept scheduler as last argument with multiple value","suites":["startWith"],"updatePoint":{"line":207,"column":66},"line":207,"code":"  it('should accept scheduler as last argument with multiple value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----a--|');\n      const e1subs = '  ^-------!';\n      const expected = '(yz)-a--|';\n\n      const result = e1.pipe(startWith('y', 'z', testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["startWith"],"updatePoint":{"line":220,"column":73},"line":220,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(startWith(-1), take(4)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/startWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe on specified scheduler","suites":["subscribeOn"],"updatePoint":{"line":16,"column":45},"line":16,"code":"  it('should subscribe on specified scheduler', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const expected = '--a--b--|';\n      const sub = '     ^-------!';\n\n      const result = e1.pipe(subscribeOn(testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should start subscribe after specified delay","suites":["subscribeOn"],"updatePoint":{"line":29,"column":50},"line":29,"code":"  it('should start subscribe after specified delay', () => {\n    testScheduler.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('    --a--b--|');\n      const expected = '  -----b--|';\n      const delay = time('---|     ');\n      const sub = '       ---^----!';\n\n      const result = e1.pipe(subscribeOn(testScheduler, delay));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe when source raises error","suites":["subscribeOn"],"updatePoint":{"line":43,"column":49},"line":43,"code":"  it('should unsubscribe when source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--#');\n      const expected = '--a--#';\n      const sub = '     ^----!';\n\n      const result = e1.pipe(subscribeOn(testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe when source is empty","suites":["subscribeOn"],"updatePoint":{"line":56,"column":43},"line":56,"code":"  it('should subscribe when source is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----|');\n      const expected = '----|';\n      const sub = '     ^---!';\n\n      const result = e1.pipe(subscribeOn(testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe when source does not complete","suites":["subscribeOn"],"updatePoint":{"line":69,"column":52},"line":69,"code":"  it('should subscribe when source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----');\n      const expected = '----';\n      const sub = '     ^---';\n\n      const result = e1.pipe(subscribeOn(testScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["subscribeOn"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const sub = '     ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(subscribeOn(testScheduler));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when the result is unsubscribed explicitly","suites":["subscribeOn"],"updatePoint":{"line":96,"column":87},"line":96,"code":"  it('should not break unsubscription chains when the result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const sub = '     ^---!    ';\n      const expected = '--a--    ';\n      const unsub = '   ----!    ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        subscribeOn(testScheduler),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(sub);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should properly support a delayTime of Infinity","suites":["subscribeOn"],"updatePoint":{"line":114,"column":53},"line":114,"code":"  it('should properly support a delayTime of Infinity', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--|');\n      const expected = '---------';\n\n      const result = e1.pipe(subscribeOn(testScheduler, Infinity));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe([]);\n    });\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["subscribeOn"],"updatePoint":{"line":126,"column":73},"line":126,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(subscribeOn(queueScheduler), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/subscribeOn-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch a hot observable of cold observables","suites":["switchAll"],"updatePoint":{"line":16,"column":56},"line":16,"code":"  it('should switch a hot observable of cold observables', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('    --a---b--c---d--|      ');\n      const xsubs = '   --^------!               ';\n      const y = cold('           ----e---f--g---|');\n      const ysubs = '   ---------^--------------!';\n      const e1 = hot('  --x------y-------|       ', { x: x, y: y });\n      const e1subs = '  ^----------------!       ';\n      const expected = '----a---b----e---f--g---|';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to each immediately-scheduled inner Observable","suites":["switchAll"],"updatePoint":{"line":35,"column":66},"line":35,"code":"  it('should switch to each immediately-scheduled inner Observable', (done) => {\n    const a = scheduled([1, 2, 3], queueScheduler);\n    const b = scheduled([4, 5, 6], queueScheduler);\n    const r = [1, 4, 5, 6];\n    let i = 0;\n    scheduled([a, b], queueScheduler)\n      .pipe(switchAll())\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(r[i++]);\n        },\n        complete: done,\n      });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsub inner observables","suites":["switchAll"],"updatePoint":{"line":50,"column":36},"line":50,"code":"  it('should unsub inner observables', () => {\n    const unsubbed: string[] = [];\n\n    of('a', 'b')\n      .pipe(\n        map(\n          (x) =>\n            new Observable<string>((subscriber) => {\n              subscriber.complete();\n              return () => {\n                unsubbed.push(x);\n              };\n            })\n        ),\n        switchAll()\n      )\n      .subscribe();\n\n    expect(unsubbed).to.deep.equal(['a', 'b']);\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to each inner Observable","suites":["switchAll"],"updatePoint":{"line":71,"column":44},"line":71,"code":"  it('should switch to each inner Observable', (done) => {\n    const a = of(1, 2, 3);\n    const b = of(4, 5, 6);\n    const r = [1, 2, 3, 4, 5, 6];\n    let i = 0;\n    of(a, b)\n      .pipe(switchAll())\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(r[i++]);\n        },\n        complete: done,\n      });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables","suites":["switchAll"],"updatePoint":{"line":86,"column":51},"line":86,"code":"  it('should handle a hot observable of observables', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^-------!              ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs = '   --------------^-------------!';\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const e1subs = '  ^--------------------!       ';\n      const expected = '--------a---b----d--e---f---|';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, outer is unsubscribed early","suites":["switchAll"],"updatePoint":{"line":105,"column":80},"line":105,"code":"  it('should handle a hot observable of observables, outer is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^-------!              ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs = '   --------------^-!            ';\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const unsub = '   ----------------!            ';\n      const expected = '--------a---b---             ';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["switchAll"],"updatePoint":{"line":123,"column":83},"line":123,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^-------!              ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs = '   --------------^-!            ';\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const expected = '--------a---b----            ';\n      const unsub = '   ----------------!            ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        switchAll(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, inner never completes","suites":["switchAll"],"updatePoint":{"line":145,"column":74},"line":145,"code":"  it('should handle a hot observable of observables, inner never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|          ');\n      const xsubs = '   ------^-------!               ';\n      const y = cold('                ---d--e---f-----');\n      const ysubs = '   --------------^               ';\n      const e1 = hot('  ------x-------y------|        ', { x: x, y: y });\n      const expected = '--------a---b----d--e---f-----';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch to the second inner observable","suites":["switchAll"],"updatePoint":{"line":162,"column":71},"line":162,"code":"  it('should handle a synchronous switch to the second inner observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|   ');\n      const xsubs = '   ------(^!)             ';\n      const y = cold('        ---d--e---f---|  ');\n      const ysubs = '   ------^-------------!  ';\n      const e1 = hot('  ------(xy)------------|', { x: x, y: y });\n      const expected = '---------d--e---f-----|';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, one inner throws","suites":["switchAll"],"updatePoint":{"line":179,"column":69},"line":179,"code":"  it('should handle a hot observable of observables, one inner throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---#                ');\n      const xsubs = '   ------^-----!                ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs = '                                ';\n      const e1 = hot('  ------x-------y------|       ', { x: x, y: y });\n      const expected = '--------a---#                ';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables, outer throws","suites":["switchAll"],"updatePoint":{"line":196,"column":65},"line":196,"code":"  it('should handle a hot observable of observables, outer throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|         ');\n      const xsubs = '   ------^-------!              ';\n      const y = cold('                ---d--e---f---|');\n      const ysubs = '   --------------^-------!      ';\n      const e1 = hot('  ------x-------y-------#      ', { x: x, y: y });\n      const expected = '--------a---b----d--e-#      ';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty hot observable","suites":["switchAll"],"updatePoint":{"line":213,"column":43},"line":213,"code":"  it('should handle an empty hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ------|');\n      const e1subs = '  ^-----!';\n      const expected = '------|';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never hot observable","suites":["switchAll"],"updatePoint":{"line":226,"column":42},"line":226,"code":"  it('should handle a never hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete not before the outer completes","suites":["switchAll"],"updatePoint":{"line":239,"column":52},"line":239,"code":"  it('should complete not before the outer completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('        --a---b---c--|   ');\n      const xsubs = '   ------^------------!   ';\n      const e1 = hot('  ------x---------------|', { x: x });\n      const e1subs = '  ^---------------------!';\n      const expected = '--------a---b---c-----|';\n\n      const result = e1.pipe(switchAll());\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an observable of promises","suites":["switchAll"],"updatePoint":{"line":255,"column":45},"line":255,"code":"  it('should handle an observable of promises', (done) => {\n    const expected = [3];\n\n    of(Promise.resolve(1), Promise.resolve(2), Promise.resolve(3))\n      .pipe(switchAll())\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(expected.shift());\n        },\n        complete() {\n          expect(expected.length).to.equal(0);\n          done();\n        },\n      });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an observable of promises, where last rejects","suites":["switchAll"],"updatePoint":{"line":271,"column":65},"line":271,"code":"  it('should handle an observable of promises, where last rejects', (done) => {\n    of(Promise.resolve(1), Promise.resolve(2), Promise.reject(3))\n      .pipe(switchAll())\n      .subscribe({\n        next() {\n          done(new Error('should not be called'));\n        },\n        error(err) {\n          expect(err).to.equal(3);\n          done();\n        },\n        complete() {\n          done(new Error('should not be called'));\n        },\n      });\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an observable with Arrays in it","suites":["switchAll"],"updatePoint":{"line":288,"column":51},"line":288,"code":"  it('should handle an observable with Arrays in it', () => {\n    const expected = [1, 2, 3, 4];\n    let completed = false;\n\n    of(NEVER, NEVER, [1, 2, 3, 4])\n      .pipe(switchAll())\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(expected.shift());\n        },\n        complete() {\n          completed = true;\n          expect(expected.length).to.equal(0);\n        },\n      });\n\n    expect(completed).to.be.true;\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not leak when child completes before each switch (prevent memory leaks #2355)","suites":["switchAll"],"updatePoint":{"line":307,"column":90},"line":307,"code":"  it('should not leak when child completes before each switch (prevent memory leaks #2355)', () => {\n    let iStream: Subject<number>;\n    const oStreamControl = new Subject<number>();\n    const oStream = oStreamControl.pipe(map(() => (iStream = new Subject<number>())));\n    const switcher = oStream.pipe(switchAll());\n    const result: number[] = [];\n    let sub = switcher.subscribe((x) => result.push(x));\n\n    [0, 1, 2, 3, 4].forEach((n) => {\n      oStreamControl.next(n); // creates inner\n      iStream.complete();\n    });\n\n    // Expect one child of switchAll(): The oStream\n    expect((sub as any)._finalizers?.[0]._finalizers?.length).to.equal(1);\n    sub.unsubscribe();\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not leak if we switch before child completes (prevent memory leaks #2355)","suites":["switchAll"],"updatePoint":{"line":325,"column":86},"line":325,"code":"  it('should not leak if we switch before child completes (prevent memory leaks #2355)', () => {\n    const oStreamControl = new Subject<number>();\n    const oStream = oStreamControl.pipe(map(() => new Subject<number>()));\n    const switcher = oStream.pipe(switchAll());\n    const result: number[] = [];\n    let sub = switcher.subscribe((x) => result.push(x));\n\n    [0, 1, 2, 3, 4].forEach((n) => {\n      oStreamControl.next(n); // creates inner\n    });\n    // Expect one child of switchAll(): The oStream\n    expect((sub as any)._finalizers?.[0]._finalizers?.length).to.equal(1);\n    // Expect two children of subscribe(): The destination and the first inner\n    // See #4106 - inner subscriptions are now added to destinations\n    expect((sub as any)._finalizers?.length).to.equal(2);\n    sub.unsubscribe();\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["switchAll"],"updatePoint":{"line":343,"column":73},"line":343,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    of(synchronousObservable)\n      .pipe(switchAll(), take(3))\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/switchAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["switchMap"],"updatePoint":{"line":17,"column":55},"line":17,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('   --1-----3--5-------|');\n      const e1subs = '   ^------------------!';\n      const e2 = cold('    x-x-x|            ', { x: 10 });\n      //                         x-x-x|\n      //                            x-x-x|\n      const expected = ' --x-x-x-y-yz-z-z---|';\n      const values = { x: 10, y: 30, z: 50 };\n\n      const result = e1.pipe(switchMap((x) => e2.pipe(map((i) => i * +x))));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["switchMap"],"updatePoint":{"line":34,"column":50},"line":34,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(\n        switchMap(\n          (x) => of(x, x + 1, x + 2),\n          (a, b, i, ii) => [a, b, i, ii]\n        )\n      )\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 1, 0, 0],\n            [1, 2, 0, 1],\n            [1, 3, 0, 2],\n            [2, 2, 1, 0],\n            [2, 3, 1, 1],\n            [2, 4, 1, 2],\n            [3, 3, 2, 0],\n            [3, 4, 2, 1],\n            [3, 5, 2, 2],\n          ]);\n        },\n      });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["switchMap"],"updatePoint":{"line":67,"column":61},"line":67,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(switchMap((x) => of(x, x + 1, x + 2), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([1, 2, 3, 2, 3, 4, 3, 4, 5]);\n        },\n      });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsub inner observables","suites":["switchMap"],"updatePoint":{"line":85,"column":36},"line":85,"code":"  it('should unsub inner observables', () => {\n    const unsubbed: string[] = [];\n\n    of('a', 'b')\n      .pipe(\n        switchMap(\n          (x) =>\n            new Observable<string>((subscriber) => {\n              subscriber.complete();\n              return () => {\n                unsubbed.push(x);\n              };\n            })\n        )\n      )\n      .subscribe();\n\n    expect(unsubbed).to.deep.equal(['a', 'b']);\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables","suites":["switchMap"],"updatePoint":{"line":105,"column":42},"line":105,"code":"  it('should switch inner cold observables', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-----------------!';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^----------------------------!        ';\n      const expected = '-----------a--b--c----f---g---h---i--|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when projection throws","suites":["switchMap"],"updatePoint":{"line":126,"column":47},"line":126,"code":"  it('should raise error when projection throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -------x-----y---|');\n      const e1subs = '  ^------!          ';\n      const expected = '-------#          ';\n      function project(): any[] {\n        throw 'error';\n      }\n\n      expectObservable(e1.pipe(switchMap(project))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, outer is unsubscribed early","suites":["switchMap"],"updatePoint":{"line":140,"column":71},"line":140,"code":"  it('should switch inner cold observables, outer is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const unsub = '   ---------------------!                ';\n      const expected = '-----------a--b--c----                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["switchMap"],"updatePoint":{"line":162,"column":83},"line":162,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const expected = '-----------a--b--c----                ';\n      const unsub = '   ---------------------!                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        switchMap((value) => observableLookup[value]),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains with interop inners when result is unsubscribed explicitly","suites":["switchMap"],"updatePoint":{"line":188,"column":103},"line":188,"code":"  it('should not break unsubscription chains with interop inners when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const expected = '-----------a--b--c----                ';\n      const unsub = '   ---------------------!                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      // This test is the same as the previous test, but the observable is\n      // manipulated to make it look like an interop observable - an observable\n      // from a foreign library. Interop subscribers are treated differently:\n      // they are wrapped in a safe subscriber. This test ensures that\n      // unsubscriptions are chained all the way to the interop subscriber.\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        switchMap((value) => asInteropObservable(observableLookup[value])),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["switchMap"],"updatePoint":{"line":220,"column":73},"line":220,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n\n    of(null)\n      .pipe(\n        switchMap(() => synchronousObservable),\n        takeWhile((x) => x != 2) // unsubscribe at the second side-effect\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([1, 2]);\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, inner never completes","suites":["switchMap"],"updatePoint":{"line":249,"column":65},"line":249,"code":"  it('should switch inner cold observables, inner never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|          ');\n      const xsubs = '   ---------^---------!                 ';\n      const y = cold('                     ---f---g---h---i--');\n      const ysubs = '   -------------------^                 ';\n      const e1 = hot('  ---------x---------y---------|       ');\n      const e1subs = '  ^----------------------------!       ';\n      const expected = '-----------a--b--c----f---g---h---i--';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch to the second inner observable","suites":["switchMap"],"updatePoint":{"line":270,"column":71},"line":270,"code":"  it('should handle a synchronous switch to the second inner observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|   ');\n      const xsubs = '   ---------(^!)                 ';\n      const y = cold('           ---f---g---h---i--|  ');\n      const ysubs = '   ---------^-----------------!  ';\n      const e1 = hot('  ---------(xy)----------------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------f---g---h---i----|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, one inner throws","suites":["switchMap"],"updatePoint":{"line":291,"column":60},"line":291,"code":"  it('should switch inner cold observables, one inner throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--#--d--e--|          ');\n      const xsubs = '   ---------^-------!                   ';\n      const y = cold('                     ---f---g---h---i--');\n      const ysubs = '                                        ';\n      const e1 = hot('  ---------x---------y---------|       ');\n      const e1subs = '  ^----------------!                   ';\n      const expected = '-----------a--b--#                   ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner hot observables","suites":["switchMap"],"updatePoint":{"line":312,"column":41},"line":312,"code":"  it('should switch inner hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   -----a--b--c--d--e--|                 ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = hot('   --p-o-o-p-------------f---g---h---i--|');\n      const ysubs = '   -------------------^-----------------!';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^----------------------------!        ';\n      const expected = '-----------c--d--e----f---g---h---i--|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and empty","suites":["switchMap"],"updatePoint":{"line":333,"column":41},"line":333,"code":"  it('should switch inner empty and empty', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     |          ');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and never","suites":["switchMap"],"updatePoint":{"line":354,"column":41},"line":354,"code":"  it('should switch inner empty and never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     -          ');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------^          ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------------------------';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner never and empty","suites":["switchMap"],"updatePoint":{"line":375,"column":41},"line":375,"code":"  it('should switch inner never and empty', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -                    ');\n      const y = cold('                     |          ');\n      const xsubs = '   ---------^---------!          ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner never and throw","suites":["switchMap"],"updatePoint":{"line":396,"column":41},"line":396,"code":"  it('should switch inner never and throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -                    ');\n      const y = cold('                     #          ', undefined, 'sad');\n      const xsubs = '   ---------^---------!          ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^------------------!          ';\n      const expected = '-------------------#          ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected, undefined, 'sad');\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and throw","suites":["switchMap"],"updatePoint":{"line":417,"column":41},"line":417,"code":"  it('should switch inner empty and throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     #          ', undefined, 'sad');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^------------------!          ';\n      const expected = '-------------------#          ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x, y: y };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected, undefined, 'sad');\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer empty","suites":["switchMap"],"updatePoint":{"line":438,"column":31},"line":438,"code":"  it('should handle outer empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(switchMap((value) => of(value)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer never","suites":["switchMap"],"updatePoint":{"line":451,"column":31},"line":451,"code":"  it('should handle outer never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(switchMap((value) => of(value)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer throw","suites":["switchMap"],"updatePoint":{"line":464,"column":31},"line":464,"code":"  it('should handle outer throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(switchMap((value) => of(value)));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer error","suites":["switchMap"],"updatePoint":{"line":477,"column":31},"line":477,"code":"  it('should handle outer error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|');\n      const xsubs = '   ---------^---------!       ';\n      const e1 = hot('  ---------x---------#       ');\n      const e1subs = '  ^------------------!       ';\n      const expected = '-----------a--b--c-#       ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x };\n\n      const result = e1.pipe(switchMap((value) => observableLookup[value]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["switchMap"],"updatePoint":{"line":495,"column":73},"line":495,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        switchMap((value) => of(value)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe previous inner sub when getting synchronously reentrance during subscribing the inner sub","suites":["switchMap"],"updatePoint":{"line":518,"column":114},"line":518,"code":"  it('should unsubscribe previous inner sub when getting synchronously reentrance during subscribing the inner sub', () => {\n    const e = new BehaviorSubject(1);\n    const results: Array<number> = [];\n\n    e.pipe(\n      take(3),\n      switchMap(\n        (value) =>\n          new Observable<number>((subscriber) => {\n            e.next(value + 1);\n            subscriber.next(value);\n          })\n      )\n    ).subscribe((value) => results.push(value));\n\n    expect(results).to.deep.equal([3]);\n  });","file":"operators/switchMap-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable","suites":["switchMapTo"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should map-and-flatten each item to an Observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1-----3--5-------|');\n      const e1subs = '  ^------------------!';\n      const e2 = cold('   x-x-x|            ', { x: 10 });\n      //                        x-x-x|\n      //                           x-x-x|\n      const expected = '--x-x-x-x-xx-x-x---|';\n      const values = { x: 10 };\n\n      const result = e1.pipe(switchMapTo(e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support the deprecated resultSelector","suites":["switchMapTo"],"updatePoint":{"line":33,"column":50},"line":33,"code":"  it('should support the deprecated resultSelector', () => {\n    const results: Array<number[]> = [];\n\n    of(1, 2, 3)\n      .pipe(switchMapTo(of(4, 5, 6), (a, b, i, ii) => [a, b, i, ii]))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([\n            [1, 4, 0, 0],\n            [1, 5, 0, 1],\n            [1, 6, 0, 2],\n            [2, 4, 1, 0],\n            [2, 5, 1, 1],\n            [2, 6, 1, 2],\n            [3, 4, 2, 0],\n            [3, 5, 2, 1],\n            [3, 6, 2, 2],\n          ]);\n        },\n      });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should support a void resultSelector (still deprecated)","suites":["switchMapTo"],"updatePoint":{"line":61,"column":61},"line":61,"code":"  it('should support a void resultSelector (still deprecated)', () => {\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(switchMapTo(of(4, 5, 6), void 0))\n      .subscribe({\n        next(value) {\n          results.push(value);\n        },\n        error(err) {\n          throw err;\n        },\n        complete() {\n          expect(results).to.deep.equal([4, 5, 6, 4, 5, 6, 4, 5, 6]);\n        },\n      });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch a synchronous many outer to a synchronous many inner","suites":["switchMapTo"],"updatePoint":{"line":79,"column":72},"line":79,"code":"  it('should switch a synchronous many outer to a synchronous many inner', (done) => {\n    const a = of(1, 2, 3);\n    const expected = ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'];\n    a.pipe(switchMapTo(of('a', 'b', 'c'))).subscribe({\n      next(x) {\n        expect(x).to.equal(expected.shift());\n      },\n      complete: done,\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsub inner observables","suites":["switchMapTo"],"updatePoint":{"line":90,"column":36},"line":90,"code":"  it('should unsub inner observables', () => {\n    let unsubbed = 0;\n\n    of('a', 'b')\n      .pipe(\n        switchMapTo(\n          new Observable<string>((subscriber) => {\n            subscriber.complete();\n            return () => {\n              unsubbed++;\n            };\n          })\n        )\n      )\n      .subscribe();\n\n    expect(unsubbed).to.equal(2);\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner cold observable","suites":["switchMapTo"],"updatePoint":{"line":109,"column":47},"line":109,"code":"  it('should switch to an inner cold observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|          ');\n      const xsubs = [\n        '               ---------^---------!                 ',\n        //                                 --a--b--c--d--e--|\n        '               -------------------^----------------!',\n      ];\n      const e1 = hot('  ---------x---------x---------|       ');\n      const e1subs = '  ^----------------------------!       ';\n      const expected = '-----------a--b--c---a--b--c--d--e--|';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner cold observable, outer eventually throws","suites":["switchMapTo"],"updatePoint":{"line":127,"column":72},"line":127,"code":"  it('should switch to an inner cold observable, outer eventually throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|');\n      const xsubs = '   ---------^---------!       ';\n      const e1 = hot('  ---------x---------#       ');\n      const e1subs = '  ^------------------!       ';\n      const expected = '-----------a--b--c-#       ';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner cold observable, outer is unsubscribed early","suites":["switchMapTo"],"updatePoint":{"line":141,"column":76},"line":141,"code":"  it('should switch to an inner cold observable, outer is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|   ');\n      const xsubs = [\n        '               ---------^---------!          ',\n        //                                 --a--b--c--d--e--|\n        '               -------------------^--!       ',\n      ];\n      const e1 = hot('  ---------x---------x---------|');\n      const unsub = '   ----------------------!       ';\n      const e1subs = '  ^---------------------!       ';\n      const expected = '-----------a--b--c---a-       ';\n\n      expectObservable(e1.pipe(switchMapTo(x)), unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["switchMapTo"],"updatePoint":{"line":160,"column":83},"line":160,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('--a--b--c--d--e--|   ');\n      const xsubs = [\n        '               ---------^---------!          ',\n        //                                 --a--b--c--d--e--|\n        '               -------------------^--!       ',\n      ];\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^---------------------!       ';\n      const expected = '-----------a--b--c---a-       ';\n      const unsub = '   ----------------------!       ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        switchMapTo(x),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner cold observable, inner never completes","suites":["switchMapTo"],"updatePoint":{"line":185,"column":70},"line":185,"code":"  it('should switch to an inner cold observable, inner never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e-          ');\n      const xsubs = [\n        '               ---------^---------!               ',\n        //                                 --a--b--c--d--e-\n        '               -------------------^               ',\n      ];\n      const e1 = hot('  ---------x---------y---------|     ');\n      const e1subs = '  ^----------------------------!     ';\n      const expected = '-----------a--b--c---a--b--c--d--e-';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch to the inner observable","suites":["switchMapTo"],"updatePoint":{"line":203,"column":64},"line":203,"code":"  it('should handle a synchronous switch to the inner observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|   ');\n      // prettier-ignore\n      const xsubs = [\n        '               ---------(^!)                 ', \n        '               ---------^----------------!   '\n      ];\n      const e1 = hot('  ---------(xx)----------------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------a--b--c--d--e-----|';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner cold observable, inner raises an error","suites":["switchMapTo"],"updatePoint":{"line":221,"column":70},"line":221,"code":"  it('should switch to an inner cold observable, inner raises an error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--#            ');\n      const xsubs = '   ---------^-------!            ';\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^----------------!            ';\n      const expected = '-----------a--b--#            ';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch an inner hot observable","suites":["switchMapTo"],"updatePoint":{"line":235,"column":43},"line":235,"code":"  it('should switch an inner hot observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   --p-o-o-p---a--b--c--d-|      ');\n      // prettier-ignore\n      const xsubs = [\n        '               ---------^---------!          ',\n        '               -------------------^---!      '\n      ];\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------a--b--c--d-------|';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner empty","suites":["switchMapTo"],"updatePoint":{"line":253,"column":37},"line":253,"code":"  it('should switch to an inner empty', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const xsubs = [\n        '               ---------(^!)                 ',\n        //                                 |\n        '               -------------------(^!)       ',\n      ];\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner never","suites":["switchMapTo"],"updatePoint":{"line":271,"column":37},"line":271,"code":"  it('should switch to an inner never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -                    ');\n      const xsubs = [\n        '               ---------^---------!          ',\n        //                                 -\n        '               -------------------^          ',\n      ];\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------------------------';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch to an inner that just raises an error","suites":["switchMapTo"],"updatePoint":{"line":289,"column":57},"line":289,"code":"  it('should switch to an inner that just raises an error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           #                    ');\n      const xsubs = '   ---------(^!)                 ';\n      const e1 = hot('  ---------x---------x---------|');\n      const e1subs = '  ^--------!                    ';\n      const expected = '---------#                    ';\n\n      expectObservable(e1.pipe(switchMapTo(x))).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty outer","suites":["switchMapTo"],"updatePoint":{"line":303,"column":34},"line":303,"code":"  it('should handle an empty outer', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(switchMapTo(of('foo')))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never outer","suites":["switchMapTo"],"updatePoint":{"line":314,"column":33},"line":314,"code":"  it('should handle a never outer', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(switchMapTo(of('foo')))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an outer that just raises and error","suites":["switchMapTo"],"updatePoint":{"line":325,"column":55},"line":325,"code":"  it('should handle an outer that just raises and error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(switchMapTo(of('foo')))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["switchMapTo"],"updatePoint":{"line":336,"column":73},"line":336,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(switchMapTo(of(0)), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/switchMapTo-spec.ts","skipped":false,"dir":"spec"},{"name":"should map-and-flatten each item to an Observable while passing the accumulated value","suites":["switchScan"],"updatePoint":{"line":16,"column":91},"line":16,"code":"  it('should map-and-flatten each item to an Observable while passing the accumulated value', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1-----3--5-------|');\n      const e1subs = '  ^------------------!';\n      const e2 = cold('    x-x-x|           ', { x: 10 });\n      //                        x-x-x|\n      //                           x-x-x|\n      const expected = '--x-x-x-y-yz-z-z---|';\n      const values = { x: 10, y: 40, z: 90 };\n\n      const result = e1.pipe(switchScan((acc, x) => e2.pipe(map((i) => i * Number(x) + acc)), 0));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should provide the proper accumulated values","suites":["switchScan"],"updatePoint":{"line":33,"column":50},"line":33,"code":"  it('should provide the proper accumulated values', () => {\n    const accs: number[] = [];\n\n    of(1, 3, 5)\n      .pipe(\n        switchScan((acc, x) => {\n          accs.push(acc);\n          return of(acc + x);\n        }, 100)\n      )\n      .subscribe();\n\n    expect(accs).to.deep.equal([100, 101, 104]);\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsub inner observables","suites":["switchScan"],"updatePoint":{"line":48,"column":36},"line":48,"code":"  it('should unsub inner observables', () => {\n    const unsubbed: string[] = [];\n\n    of('a', 'b')\n      .pipe(\n        switchScan(\n          (_acc, x) =>\n            new Observable<string>((subscriber) => {\n              subscriber.complete();\n              return () => {\n                unsubbed.push(x);\n              };\n            }),\n          null\n        )\n      )\n      .subscribe();\n\n    expect(unsubbed).to.deep.equal(['a', 'b']);\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables","suites":["switchScan"],"updatePoint":{"line":69,"column":42},"line":69,"code":"  it('should switch inner cold observables', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-----------------!';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^----------------------------!        ';\n      const expected = '-----------a--b--c----f---g---h---i--|';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when projection throws","suites":["switchScan"],"updatePoint":{"line":90,"column":47},"line":90,"code":"  it('should raise error when projection throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -------x-----y---|');\n      const e1subs = '  ^------!          ';\n      const expected = '-------#          ';\n\n      function project(): any[] {\n        throw 'error';\n      }\n\n      expectObservable(e1.pipe(switchScan(project, null))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, outer is unsubscribed early","suites":["switchScan"],"updatePoint":{"line":105,"column":71},"line":105,"code":"  it('should switch inner cold observables, outer is unsubscribed early', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const unsub = '   ---------------------!                ';\n      const expected = '-----------a--b--c----                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["switchScan"],"updatePoint":{"line":127,"column":83},"line":127,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|           ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = cold('                     ---f---g---h---i--|');\n      const ysubs = '   -------------------^-!                ';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^--------------------!                ';\n      const expected = '-----------a--b--c----                ';\n      const unsub = '   ---------------------!                ';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        switchScan((_acc, value) => observableLookup[value], null),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["switchScan"],"updatePoint":{"line":153,"column":73},"line":153,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = concat(\n      defer(() => {\n        sideEffects.push(1);\n        return of(1);\n      }),\n      defer(() => {\n        sideEffects.push(2);\n        return of(2);\n      }),\n      defer(() => {\n        sideEffects.push(3);\n        return of(3);\n      })\n    );\n\n    of(null)\n      .pipe(\n        switchScan(() => synchronousObservable, null),\n        takeWhile((x) => x != 2) // unsubscribe at the second side-effect\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([1, 2]);\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, inner never completes","suites":["switchScan"],"updatePoint":{"line":182,"column":65},"line":182,"code":"  it('should switch inner cold observables, inner never completes', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|          ');\n      const xsubs = '   ---------^---------!                 ';\n      const y = cold('                     ---f---g---h---i--');\n      const ysubs = '   -------------------^                 ';\n      const e1 = hot('  ---------x---------y---------|       ');\n      const e1subs = '  ^----------------------------!       ';\n      const expected = '-----------a--b--c----f---g---h---i--';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a synchronous switch to the second inner observable","suites":["switchScan"],"updatePoint":{"line":203,"column":71},"line":203,"code":"  it('should handle a synchronous switch to the second inner observable', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|   ');\n      const xsubs = '   ---------(^!)                 ';\n      const y = cold('           ---f---g---h---i--|  ');\n      const ysubs = '   ---------^-----------------!  ';\n      const e1 = hot('  ---------(xy)----------------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------f---g---h---i----|';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner cold observables, one inner throws","suites":["switchScan"],"updatePoint":{"line":224,"column":60},"line":224,"code":"  it('should switch inner cold observables, one inner throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--#--d--e--|          ');\n      const xsubs = '   ---------^-------!                   ';\n      const y = cold('                     ---f---g---h---i--');\n      const ysubs = '                                        ';\n      const e1 = hot('  ---------x---------y---------|       ');\n      const e1subs = '  ^----------------!                   ';\n      const expected = '-----------a--b--#                   ';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner hot observables","suites":["switchScan"],"updatePoint":{"line":245,"column":41},"line":245,"code":"  it('should switch inner hot observables', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const x = hot('   -----a--b--c--d--e--|                 ');\n      const xsubs = '   ---------^---------!                  ';\n      const y = hot('   --p-o-o-p-------------f---g---h---i--|');\n      const ysubs = '   -------------------^-----------------!';\n      const e1 = hot('  ---------x---------y---------|        ');\n      const e1subs = '  ^----------------------------!        ';\n      const expected = '-----------c--d--e----f---g---h---i--|';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and empty","suites":["switchScan"],"updatePoint":{"line":266,"column":41},"line":266,"code":"  it('should switch inner empty and empty', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     |          ');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and never","suites":["switchScan"],"updatePoint":{"line":287,"column":41},"line":287,"code":"  it('should switch inner empty and never', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     -----------');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------^          ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '------------------------------';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner never and empty","suites":["switchScan"],"updatePoint":{"line":308,"column":41},"line":308,"code":"  it('should switch inner never and empty', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -----------          ');\n      const y = cold('                     |          ');\n      const xsubs = '   ---------^---------!          ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^----------------------------!';\n      const expected = '-----------------------------|';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner never and throw","suites":["switchScan"],"updatePoint":{"line":329,"column":41},"line":329,"code":"  it('should switch inner never and throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           -----------          ');\n      const y = cold('                     #          ', undefined, 'sad');\n      const xsubs = '   ---------^---------!          ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^------------------!          ';\n      const expected = '-------------------#          ';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected, undefined, 'sad');\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch inner empty and throw","suites":["switchScan"],"updatePoint":{"line":350,"column":41},"line":350,"code":"  it('should switch inner empty and throw', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           |                    ');\n      const y = cold('                     #          ', undefined, 'sad');\n      const xsubs = '   ---------(^!)                 ';\n      const ysubs = '   -------------------(^!)       ';\n      const e1 = hot('  ---------x---------y---------|');\n      const e1subs = '  ^------------------!          ';\n      const expected = '-------------------#          ';\n\n      const observableLookup: Record<string, Observable<string>> = { x, y };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected, undefined, 'sad');\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer empty","suites":["switchScan"],"updatePoint":{"line":371,"column":31},"line":371,"code":"  it('should handle outer empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(switchScan((_acc, value) => of(value), ''));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer never","suites":["switchScan"],"updatePoint":{"line":384,"column":31},"line":384,"code":"  it('should handle outer never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(switchScan((_acc, value) => of(value), ''));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer throw","suites":["switchScan"],"updatePoint":{"line":397,"column":31},"line":397,"code":"  it('should handle outer throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(switchScan((_acc, value) => of(value), ''));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle outer error","suites":["switchScan"],"updatePoint":{"line":410,"column":31},"line":410,"code":"  it('should handle outer error', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('           --a--b--c--d--e--|');\n      const xsubs = '   ---------^---------!       ';\n      const e1 = hot('  ---------x---------#       ');\n      const e1subs = '  ^------------------!       ';\n      const expected = '-----------a--b--c-#       ';\n\n      const observableLookup: Record<string, Observable<string>> = { x: x };\n\n      const result = e1.pipe(switchScan((_acc, value) => observableLookup[value], null));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a new seed for each subscriber","suites":["switchScan"],"updatePoint":{"line":428,"column":50},"line":428,"code":"  it('should create a new seed for each subscriber', () => {\n    const seeds: string[] = [];\n    const observer = (value: string) => seeds.push(value);\n\n    const source = of('a', 'b').pipe(switchScan((acc, x) => of(acc + x), ''));\n\n    source.subscribe(observer);\n    source.subscribe(observer);\n\n    expect(seeds).to.deep.equal(['a', 'ab', 'a', 'ab']);\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass index to the accumulator function","suites":["switchScan"],"updatePoint":{"line":440,"column":51},"line":440,"code":"  it('should pass index to the accumulator function', () => {\n    const indices: number[] = [];\n\n    of('a', 'b', 'c', 'd')\n      .pipe(\n        switchScan((_acc, _x, index) => {\n          indices.push(index);\n          return of();\n        }, '')\n      )\n      .subscribe();\n\n    expect(indices).to.deep.equal([0, 1, 2, 3]);\n  });","file":"operators/switchScan-spec.ts","skipped":false,"dir":"spec"},{"name":"should take two values of an observable with many values","suites":["take"],"updatePoint":{"line":16,"column":62},"line":16,"code":"  it('should take two values of an observable with many values', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------!------------';\n      const expected = '--a-----(b|)         ';\n\n      expectObservable(e1.pipe(take(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty","suites":["take"],"updatePoint":{"line":27,"column":28},"line":27,"code":"  it('should work with empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should go on forever on never","suites":["take"],"updatePoint":{"line":38,"column":35},"line":38,"code":"  it('should go on forever on never', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should be empty on take(0)","suites":["take"],"updatePoint":{"line":49,"column":32},"line":49,"code":"  it('should be empty on take(0)', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----c---d--|');\n      const e1subs: string[] = []; // Don't subscribe at all\n      const expected = '   |';\n\n      expectObservable(e1.pipe(take(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should be empty if provided with negative value","suites":["take"],"updatePoint":{"line":60,"column":53},"line":60,"code":"  it('should be empty if provided with negative value', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const expected = '|';\n      const e1subs: string[] = []; // Don't subscribe at all\n\n      expectObservable(e1.pipe(take(-42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should take one value of an observable with one value","suites":["take"],"updatePoint":{"line":71,"column":59},"line":71,"code":"  it('should take one value of an observable with one value', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---(a|)');\n      const e1subs = '  ^--!---';\n      const expected = '---(a|)';\n\n      expectObservable(e1.pipe(take(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should take one values of an observable with many values","suites":["take"],"updatePoint":{"line":82,"column":62},"line":82,"code":"  it('should take one values of an observable with many values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----c---d--|');\n      const e1subs = '     ^--!------------';\n      const expected = '   ---(b|)         ';\n\n      expectObservable(e1.pipe(take(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on empty","suites":["take"],"updatePoint":{"line":93,"column":27},"line":93,"code":"  it('should error on empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^----|');\n      const e1subs = '     ^----!';\n      const expected = '   -----|';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from the source observable","suites":["take"],"updatePoint":{"line":104,"column":55},"line":104,"code":"  it('should propagate error from the source observable', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^---#', undefined, 'too bad');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from an observable with values","suites":["take"],"updatePoint":{"line":115,"column":59},"line":115,"code":"  it('should propagate error from an observable with values', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b--#');\n      const e1subs = '   ^--------!';\n      const expected = ' ---a--b--#';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["take"],"updatePoint":{"line":126,"column":53},"line":126,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!------------';\n      const e1subs = '   ^--------!------------';\n      const expected = ' ---a--b---            ';\n\n      expectObservable(e1.pipe(take(42)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["take"],"updatePoint":{"line":138,"column":28},"line":138,"code":"  it('should work with throw', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(take(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["take"],"updatePoint":{"line":149,"column":72},"line":149,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!            ';\n      const e1subs = '   ^--------!            ';\n      const expected = ' ---a--b---            ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        take(42),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from the source when it reaches the limit","suites":["take"],"updatePoint":{"line":167,"column":66},"line":167,"code":"  it('should unsubscribe from the source when it reaches the limit', () => {\n    const source = new Observable<number>((observer) => {\n      expect(observer.closed).to.be.false;\n      observer.next(42);\n      expect(observer.closed).to.be.true;\n    }).pipe(take(1));\n\n    source.subscribe();\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when the source is reentrant","suites":["take"],"updatePoint":{"line":177,"column":50},"line":177,"code":"  it('should complete when the source is reentrant', () => {\n    let completed = false;\n    const source = new Subject<void>();\n    source.pipe(take(5)).subscribe({\n      next() {\n        source.next();\n      },\n      complete() {\n        completed = true;\n      },\n    });\n    source.next();\n    expect(completed).to.be.true;\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["take"],"updatePoint":{"line":192,"column":73},"line":192,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete even if the parameter is a string","suites":["take"],"updatePoint":{"line":210,"column":55},"line":210,"code":"  it('should complete even if the parameter is a string', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const e1subs = '  ^-------!------------';\n      const expected = '--a-----(b|)         ';\n\n      expectObservable(e1.pipe(take('2' as any))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/take-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from the source when it reaches the limit before a recursive synchronous upstream error is notified","suites":["take"],"line":223,"code":"  it.skip('should unsubscribe from the source when it reaches the limit before a recursive synchronous upstream error is notified', () => {","file":"operators/take-spec.ts","skipped":true,"dir":"spec"},{"name":"should take two values of an observable with many values","suites":["takeLast operator"],"updatePoint":{"line":14,"column":62},"line":14,"code":"  it('should take two values of an observable with many values', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold('--a-----b----c---d--|    ');\n      const e1subs = ' ^-------------------!    ';\n      const expected = '--------------------(cd|)';\n\n      expectObservable(e1.pipe(takeLast(2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take last three values","suites":["takeLast operator"],"updatePoint":{"line":25,"column":35},"line":25,"code":"  it('should take last three values', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|    ');\n      const e1subs = '  ^-------------------!    ';\n      const expected = '--------------------(bcd|)';\n\n      expectObservable(e1.pipe(takeLast(3))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all element when try to take larger then source","suites":["takeLast operator"],"updatePoint":{"line":36,"column":65},"line":36,"code":"  it('should take all element when try to take larger then source', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|    ');\n      const e1subs = '  ^-------------------!    ';\n      const expected = '--------------------(abcd|)';\n\n      expectObservable(e1.pipe(takeLast(5))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all element when try to take exact","suites":["takeLast operator"],"updatePoint":{"line":47,"column":52},"line":47,"code":"  it('should take all element when try to take exact', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|    ');\n      const e1subs = '  ^-------------------!    ';\n      const expected = '--------------------(abcd|)';\n\n      expectObservable(e1.pipe(takeLast(4))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not take any values","suites":["takeLast operator"],"updatePoint":{"line":58,"column":32},"line":58,"code":"  it('should not take any values', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const expected = '|';\n      const e1subs: string[] = [];\n\n      expectObservable(e1.pipe(takeLast(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not take any values if provided with negative value","suites":["takeLast operator"],"updatePoint":{"line":69,"column":64},"line":69,"code":"  it('should not take any values if provided with negative value', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --a-----b----c---d--|');\n      const expected = '|';\n      const e1subs: string[] = [];\n\n      expectObservable(e1.pipe(takeLast(-42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty","suites":["takeLast operator"],"updatePoint":{"line":80,"column":28},"line":80,"code":"  it('should work with empty', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |');\n      const e1subs = '  (^!)';\n      const expected = '|';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should go on forever on never","suites":["takeLast operator"],"updatePoint":{"line":91,"column":35},"line":91,"code":"  it('should go on forever on never', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should be empty on takeLast(0)","suites":["takeLast operator"],"updatePoint":{"line":102,"column":36},"line":102,"code":"  it('should be empty on takeLast(0)', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----c---d--|');\n      const expected = '   |';\n      const e1subs: string[] = []; // Don't subscribe at all\n\n      expectObservable(e1.pipe(takeLast(0))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take one value from an observable with one value","suites":["takeLast operator"],"updatePoint":{"line":113,"column":61},"line":113,"code":"  it('should take one value from an observable with one value', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---(a|)');\n      const e1subs = '  ^--!   ';\n      const expected = '---(a|)';\n\n      expectObservable(e1.pipe(takeLast(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take one value from an observable with many values","suites":["takeLast operator"],"updatePoint":{"line":124,"column":63},"line":124,"code":"  it('should take one value from an observable with many values', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^--b----c---d--|   ');\n      const e1subs = '     ^--------------!   ';\n      const expected = '   ---------------(d|)';\n\n      expectObservable(e1.pipe(takeLast(1))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should error on empty","suites":["takeLast operator"],"updatePoint":{"line":135,"column":27},"line":135,"code":"  it('should error on empty', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^----|');\n      const e1subs = '     ^----!';\n      const expected = '   -----|';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from the source observable","suites":["takeLast operator"],"updatePoint":{"line":146,"column":55},"line":146,"code":"  it('should propagate error from the source observable', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^---#', undefined, 'too bad');\n      const e1subs = '   ^---!';\n      const expected = ' ----#';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from an observable with values","suites":["takeLast operator"],"updatePoint":{"line":157,"column":59},"line":157,"code":"  it('should propagate error from an observable with values', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b--#');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["takeLast operator"],"updatePoint":{"line":168,"column":53},"line":168,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!            ';\n      const e1subs = '   ^--------!            ';\n      const expected = ' ----------------------';\n\n      expectObservable(e1.pipe(takeLast(42)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["takeLast operator"],"updatePoint":{"line":180,"column":28},"line":180,"code":"  it('should work with throw', () => {\n    rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      expectObservable(e1.pipe(takeLast(42))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["takeLast operator"],"updatePoint":{"line":191,"column":72},"line":191,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('---^--a--b-----c--d--e--|');\n      const unsub = '    ---------!            ';\n      const e1subs = '   ^--------!            ';\n      const expected = ' ----------------------';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        takeLast(42),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeLast-spec.ts","skipped":false,"dir":"spec"},{"name":"should take values until notifier emits","suites":["takeUntil operator"],"updatePoint":{"line":15,"column":45},"line":15,"code":"  it('should take values until notifier emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^------------!          ';\n      const e2 = hot('  -------------z--|       ');\n      const e2subs = '  ^------------!          ';\n      const expected = '--a--b--c--d-|          ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should take values and raises error when notifier raises error","suites":["takeUntil operator"],"updatePoint":{"line":29,"column":68},"line":29,"code":"  it('should take values and raises error when notifier raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^------------!          ';\n      const e2 = hot('  -------------#          ');\n      const e2subs = '  ^------------!          ';\n      const expected = '--a--b--c--d-#          ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all values when notifier is empty","suites":["takeUntil operator"],"updatePoint":{"line":43,"column":51},"line":43,"code":"  it('should take all values when notifier is empty', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^----------------------!';\n      const e2 = hot('  -------------|          ');\n      const e2subs = '  ^------------!          ';\n      const expected = '--a--b--c--d--e--f--g--|';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all values when notifier does not complete","suites":["takeUntil operator"],"updatePoint":{"line":57,"column":60},"line":57,"code":"  it('should take all values when notifier does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^----------------------!';\n      const e2 = hot('  -                       ');\n      const e2subs = '  ^----------------------!';\n      const expected = '--a--b--c--d--e--f--g--|';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete without subscribing to the source when notifier synchronously emits","suites":["takeUntil operator"],"updatePoint":{"line":71,"column":89},"line":71,"code":"  it('should complete without subscribing to the source when notifier synchronously emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--|');\n      const e2 = of(1, 2, 3);\n      const expected = '(|)     ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe([]);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should subscribe to the source when notifier synchronously completes without emitting","suites":["takeUntil operator"],"updatePoint":{"line":82,"column":91},"line":82,"code":"  it('should subscribe to the source when notifier synchronously completes without emitting', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--|');\n      const e1subs = '  ^------!';\n      const e2 = EMPTY;\n      const expected = '----a--|';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["takeUntil operator"],"updatePoint":{"line":94,"column":53},"line":94,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^------!                ';\n      const e2 = hot('  -------------z--|       ');\n      const e2subs = '  ^------!                ';\n      const unsub = '   -------!                ';\n      const expected = '--a--b--                ';\n\n      expectObservable(e1.pipe(takeUntil(e2)), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when notifier emits if source observable does not complete","suites":["takeUntil operator"],"updatePoint":{"line":109,"column":80},"line":109,"code":"  it('should complete when notifier emits if source observable does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -        ');\n      const e1subs = '  ^-!      ';\n      const e2 = hot('  --a--b--|');\n      const e2subs = '  ^-!      ';\n      const expected = '--|      ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when notifier raises error if source observable does not complete","suites":["takeUntil operator"],"updatePoint":{"line":123,"column":90},"line":123,"code":"  it('should raise error when notifier raises error if source observable does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -  ');\n      const e1subs = '  ^-!';\n      const e2 = hot('  --#');\n      const e2subs = '  ^-!';\n      const expected = '--#';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when notifier is empty if source observable does not complete","suites":["takeUntil operator"],"updatePoint":{"line":137,"column":87},"line":137,"code":"  it('should not complete when notifier is empty if source observable does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -  ');\n      const e1subs = '  ^  ';\n      const e2 = hot('  --|');\n      const e2subs = '  ^-!';\n      const expected = '---';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source and notifier do not complete","suites":["takeUntil operator"],"updatePoint":{"line":151,"column":66},"line":151,"code":"  it('should not complete when source and notifier do not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -');\n      const e1subs = '  ^';\n      const e2 = hot('  -');\n      const e2subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when notifier emits before source observable emits","suites":["takeUntil operator"],"updatePoint":{"line":165,"column":72},"line":165,"code":"  it('should complete when notifier emits before source observable emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----a--|');\n      const e1subs = '  ^-!     ';\n      const e2 = hot('  --x     ');\n      const e2subs = '  ^-!     ';\n      const expected = '--|     ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error before notifier emits","suites":["takeUntil operator"],"updatePoint":{"line":179,"column":69},"line":179,"code":"  it('should raise error if source raises error before notifier emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--#     ');\n      const e1subs = '  ^-------------!     ';\n      const e2 = hot('  ----------------a--|');\n      const e2subs = '  ^-------------!     ';\n      const expected = '--a--b--c--d--#     ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error immediately if source throws","suites":["takeUntil operator"],"updatePoint":{"line":193,"column":53},"line":193,"code":"  it('should raise error immediately if source throws', () => {\n    testScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const e2 = hot('  --x ');\n      const e2subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose source observable if notifier emits before source emits","suites":["takeUntil operator"],"updatePoint":{"line":207,"column":76},"line":207,"code":"  it('should dispose source observable if notifier emits before source emits', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a---|');\n      const e1subs = '  ^-!     ';\n      const e2 = hot('  --x-|   ');\n      const e2subs = '  ^-!     ';\n      const expected = '--|     ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose notifier if source observable completes","suites":["takeUntil operator"],"updatePoint":{"line":221,"column":60},"line":221,"code":"  it('should dispose notifier if source observable completes', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--|     ');\n      const e1subs = '  ^----!     ';\n      const e2 = hot('  -------x--|');\n      const e2subs = '  ^----!     ';\n      const expected = '--a--|     ';\n\n      expectObservable(e1.pipe(takeUntil(e2))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["takeUntil operator"],"updatePoint":{"line":235,"column":72},"line":235,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b--c--d--e--f--g--|');\n      const e1subs = '  ^------!                ';\n      const e2 = hot('  -------------z--|       ');\n      const e2subs = '  ^------!                ';\n      const unsub = '   -------!                ';\n      const expected = '--a--b--                ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        takeUntil(e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/takeUntil-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all elements until predicate is false","suites":["takeWhile"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should take all elements until predicate is false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-1-^2--3--4--5--6--|');\n      const e1subs = '   ^------!         ';\n      const expected = ' -2--3--|         ';\n\n      const result = e1.pipe(takeWhile((v) => +v < 4));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all elements with predicate returns true","suites":["takeWhile"],"updatePoint":{"line":29,"column":58},"line":29,"code":"  it('should take all elements with predicate returns true', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------------!';\n      const expected = '  --b--c--d--e--|';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all elements with truthy predicate","suites":["takeWhile"],"updatePoint":{"line":42,"column":52},"line":42,"code":"  it('should take all elements with truthy predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------------!';\n      const expected = '  --b--c--d--e--|';\n\n      const result = e1.pipe(\n        takeWhile(<any>(() => {\n          return {};\n        }))\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements with predicate returns false","suites":["takeWhile"],"updatePoint":{"line":59,"column":59},"line":59,"code":"  it('should skip all elements with predicate returns false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-!            ';\n      const expected = '  --|            ';\n\n      const result = e1.pipe(takeWhile(() => false));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should skip all elements with falsy predicate","suites":["takeWhile"],"updatePoint":{"line":72,"column":51},"line":72,"code":"  it('should skip all elements with falsy predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-!            ';\n      const expected = '  --|            ';\n\n      const result = e1.pipe(takeWhile(() => null as any));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all elements until predicate return false","suites":["takeWhile"],"updatePoint":{"line":85,"column":59},"line":85,"code":"  it('should take all elements until predicate return false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------!      ';\n      const expected = '  --b--c--|      ';\n\n      function predicate(value: string) {\n        return value !== 'd';\n      }\n\n      const result = e1.pipe(takeWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all elements up to and including the element that made the predicate return false","suites":["takeWhile"],"updatePoint":{"line":102,"column":99},"line":102,"code":"  it('should take all elements up to and including the element that made the predicate return false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------!      ';\n      const expected = '  --b--c--(d|)   ';\n\n      function predicate(value: string) {\n        return value !== 'd';\n      }\n      const inclusive = true;\n\n      const result = e1.pipe(takeWhile(predicate, inclusive));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take elements with predicate when source does not complete","suites":["takeWhile"],"updatePoint":{"line":120,"column":71},"line":120,"code":"  it('should take elements with predicate when source does not complete', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--');\n      const e1subs = '    ^-------------';\n      const expected = '  --b--c--d--e--';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should not complete when source never completes","suites":["takeWhile"],"updatePoint":{"line":133,"column":53},"line":133,"code":"  it('should not complete when source never completes', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["takeWhile"],"updatePoint":{"line":146,"column":47},"line":146,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^------------|');\n      const e1subs = '    ^------------!';\n      const expected = '  -------------|';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source is empty","suites":["takeWhile"],"updatePoint":{"line":159,"column":42},"line":159,"code":"  it('should complete when source is empty', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass element index to predicate","suites":["takeWhile"],"updatePoint":{"line":172,"column":44},"line":172,"code":"  it('should pass element index to predicate', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------!      ';\n      const expected = '  --b--c--|      ';\n\n      function predicate(value: string, index: number) {\n        return index < 2;\n      }\n\n      const result = e1.pipe(takeWhile(predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source raises error","suites":["takeWhile"],"updatePoint":{"line":189,"column":49},"line":189,"code":"  it('should raise error when source raises error', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--#');\n      const e1subs = '    ^-------------!';\n      const expected = '  --b--c--d--e--#';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source throws","suites":["takeWhile"],"updatePoint":{"line":202,"column":43},"line":202,"code":"  it('should raise error when source throws', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      const result = e1.pipe(takeWhile(() => true));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should invoke predicate until return false","suites":["takeWhile"],"updatePoint":{"line":215,"column":48},"line":215,"code":"  it('should invoke predicate until return false', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-------!      ';\n      const expected = '  --b--c--|      ';\n\n      let invoked = 0;\n      function predicate(value: string) {\n        invoked++;\n        return value !== 'd';\n      }\n\n      const result = e1.pipe(\n        takeWhile(predicate),\n        tap({\n          complete: () => {\n            expect(invoked).to.equal(3);\n          },\n        })\n      );\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if predicate throws","suites":["takeWhile"],"updatePoint":{"line":240,"column":44},"line":240,"code":"  it('should raise error if predicate throws', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const e1subs = '    ^-!            ';\n      const expected = '  --#            ';\n\n      function predicate(value: string) {\n        throw 'error';\n      }\n\n      const result = e1.pipe(takeWhile(<any>predicate));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should take elements until unsubscribed","suites":["takeWhile"],"updatePoint":{"line":257,"column":45},"line":257,"code":"  it('should take elements until unsubscribed', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const unsub = '     -----!         ';\n      const e1subs = '    ^----!         ';\n      const expected = '  --b---         ';\n\n      function predicate(value: string) {\n        return value !== 'd';\n      }\n\n      const result = e1.pipe(takeWhile(predicate));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["takeWhile"],"updatePoint":{"line":275,"column":72},"line":275,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a-^-b--c--d--e--|');\n      const unsub = '     -----!         ';\n      const e1subs = '    ^----!         ';\n      const expected = '  --b---         ';\n\n      function predicate(value: string) {\n        return value !== 'd';\n      }\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        takeWhile(predicate),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should support type guards without breaking previous behavior","suites":["takeWhile"],"updatePoint":{"line":297,"column":67},"line":297,"code":"  it('should support type guards without breaking previous behavior', () => {\n    // type guards with interfaces and classes\n    {\n      interface Bar {\n        bar?: string;\n      }\n      interface Baz {\n        baz?: number;\n      }\n      class Foo implements Bar, Baz {\n        constructor(public bar: string = 'name', public baz: number = 42) {}\n      }\n\n      const isBar = (x: any): x is Bar => x && (<Bar>x).bar !== undefined;\n\n      const foo: Foo = new Foo();\n      of(foo)\n        .pipe(takeWhile((foo) => foo.baz === 42))\n        .subscribe((x) => x.baz); // x is still Foo\n      of(foo)\n        .pipe(takeWhile(isBar))\n        .subscribe((x) => x.bar); // x is Bar!\n\n      const foobar: Bar = new Foo(); // type is interface, not the class\n      of(foobar)\n        .pipe(takeWhile((foobar) => foobar.bar === 'name'))\n        .subscribe((x) => x.bar); // <-- x is still Bar\n      of(foobar)\n        .pipe(takeWhile(isBar))\n        .subscribe((x) => x.bar); // <--- x is Bar!\n\n      const barish = { bar: 'quack', baz: 42 }; // type can quack like a Bar\n      of(barish)\n        .pipe(takeWhile((x) => x.bar === 'quack'))\n        .subscribe((x) => x.bar); // x is still { bar: string; baz: number; }\n      of(barish)\n        .pipe(takeWhile(isBar))\n        .subscribe((bar) => bar.bar); // x is Bar!\n    }\n\n    // type guards with primitive types\n    {\n      const xs: Observable<string | number> = from([1, 'aaa', 3, 'bb']);\n\n      // This type guard will narrow a `string | number` to a string in the examples below\n      const isString = (x: string | number): x is string => typeof x === 'string';\n\n      xs.pipe(takeWhile(isString)).subscribe((s) => s.length); // s is string\n\n      // In contrast, this type of regular boolean predicate still maintains the original type\n      xs.pipe(takeWhile((x) => typeof x === 'number')).subscribe((x) => x); // x is still string | number\n      xs.pipe(takeWhile((x, i) => typeof x === 'number' && x > i)).subscribe((x) => x); // x is still string | number\n    }\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["takeWhile"],"updatePoint":{"line":352,"column":73},"line":352,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(takeWhile((value) => value < 2)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/takeWhile-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror multiple values and complete","suites":["tap"],"updatePoint":{"line":16,"column":48},"line":16,"code":"  it('should mirror multiple values and complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^----------!';\n      const expected = '--1--2--3--|';\n\n      const result = e1.pipe(\n        tap(() => {\n          //noop\n        })\n      );\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should next with a callback","suites":["tap"],"updatePoint":{"line":33,"column":33},"line":33,"code":"  it('should next with a callback', () => {\n    let value = null;\n    of(42)\n      .pipe(\n        tap(function (x) {\n          value = x;\n        })\n      )\n      .subscribe();\n\n    expect(value).to.equal(42);\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should error with a callback","suites":["tap"],"updatePoint":{"line":46,"column":34},"line":46,"code":"  it('should error with a callback', () => {\n    let err = null;\n    throwError(() => 'bad')\n      .pipe(\n        tap({\n          error: function (x) {\n            err = x;\n          },\n        })\n      )\n      .subscribe({\n        error(ex) {\n          expect(ex).to.equal('bad');\n        },\n      });\n\n    expect(err).to.equal('bad');\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle everything with an observer","suites":["tap"],"updatePoint":{"line":65,"column":47},"line":65,"code":"  it('should handle everything with an observer', (done) => {\n    const expected = [1, 2, 3];\n    const results: number[] = [];\n\n    of(1, 2, 3)\n      .pipe(\n        tap(<Observer<number>>{\n          next: (x: number) => {\n            results.push(x);\n          },\n          error: () => {\n            done(new Error('should not be called'));\n          },\n          complete: () => {\n            expect(results).to.deep.equal(expected);\n            done();\n          },\n        })\n      )\n      .subscribe();\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle everything with a Subject","suites":["tap"],"updatePoint":{"line":87,"column":45},"line":87,"code":"  it('should handle everything with a Subject', (done) => {\n    const expected = [1, 2, 3];\n    const results: number[] = [];\n    const subject = new Subject<number>();\n\n    subject.subscribe({\n      next: (x: any) => {\n        results.push(x);\n      },\n      error: () => {\n        done(new Error('should not be called'));\n      },\n      complete: () => {\n        expect(results).to.deep.equal(expected);\n        done();\n      },\n    });\n\n    of(1, 2, 3).pipe(tap(subject)).subscribe();\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an error with a callback","suites":["tap"],"updatePoint":{"line":108,"column":44},"line":108,"code":"  it('should handle an error with a callback', () => {\n    let errored = false;\n    throwError(() => 'bad')\n      .pipe(\n        tap({\n          error: (err: any) => {\n            expect(err).to.equal('bad');\n          },\n        })\n      )\n      .subscribe({\n        error(err: any) {\n          errored = true;\n          expect(err).to.equal('bad');\n        },\n      });\n\n    expect(errored).to.be.true;\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an error with observer","suites":["tap"],"updatePoint":{"line":128,"column":42},"line":128,"code":"  it('should handle an error with observer', () => {\n    let errored = false;\n    throwError(() => 'bad')\n      .pipe(\n        tap(<any>{\n          error: function (err: string) {\n            expect(err).to.equal('bad');\n          },\n        })\n      )\n      .subscribe({\n        error(err) {\n          errored = true;\n          expect(err).to.equal('bad');\n        },\n      });\n\n    expect(errored).to.be.true;\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle complete with observer","suites":["tap"],"updatePoint":{"line":148,"column":42},"line":148,"code":"  it('should handle complete with observer', () => {\n    let completed = false;\n\n    EMPTY.pipe(\n      tap(<any>{\n        complete: () => {\n          completed = true;\n        },\n      })\n    ).subscribe();\n\n    expect(completed).to.be.true;\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle next with observer","suites":["tap"],"updatePoint":{"line":162,"column":38},"line":162,"code":"  it('should handle next with observer', () => {\n    let value = null;\n\n    of('hi')\n      .pipe(\n        tap(<any>{\n          next: (x: string) => {\n            value = x;\n          },\n        })\n      )\n      .subscribe();\n\n    expect(value).to.equal('hi');\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if next handler raises error","suites":["tap"],"updatePoint":{"line":178,"column":53},"line":178,"code":"  it('should raise error if next handler raises error', () => {\n    of('hi')\n      .pipe(\n        tap(<any>{\n          next: () => {\n            throw new Error('bad');\n          },\n        })\n      )\n      .subscribe({\n        error(err: any) {\n          expect(err.message).to.equal('bad');\n        },\n      });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if error handler raises error","suites":["tap"],"updatePoint":{"line":194,"column":54},"line":194,"code":"  it('should raise error if error handler raises error', () => {\n    throwError(() => 'ops')\n      .pipe(\n        tap(<any>{\n          error: () => {\n            throw new Error('bad');\n          },\n        })\n      )\n      .subscribe({\n        error(err: any) {\n          expect(err.message).to.equal('bad');\n        },\n      });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if complete handler raises error","suites":["tap"],"updatePoint":{"line":210,"column":57},"line":210,"code":"  it('should raise error if complete handler raises error', () => {\n    EMPTY.pipe(\n      tap(<any>{\n        complete: () => {\n          throw new Error('bad');\n        },\n      })\n    ).subscribe({\n      error(err: any) {\n        expect(err.message).to.equal('bad');\n      },\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["tap"],"updatePoint":{"line":224,"column":53},"line":224,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1--2--3--#');\n      const unsub = '   -------!    ';\n      const e1subs = '  ^------!    ';\n      const expected = '--1--2--    ';\n\n      const result = e1.pipe(\n        tap(() => {\n          //noop\n        })\n      );\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["tap"],"updatePoint":{"line":241,"column":83},"line":241,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --1--2--3--#');\n      const e1subs = '  ^------!    ';\n      const expected = '--1--2--    ';\n      const unsub = '   -------!    ';\n\n      const result = e1.pipe(\n        mergeMap((x: any) => of(x)),\n        tap(() => {\n          //noop\n        }),\n        mergeMap((x: any) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror multiple values and complete","suites":["tap"],"updatePoint":{"line":261,"column":48},"line":261,"code":"  it('should mirror multiple values and complete', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--|');\n      const e1subs = '  ^----------!';\n      const expected = '--1--2--3--|';\n\n      const result = e1.pipe(\n        tap(() => {\n          //noop\n        })\n      );\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror multiple values and terminate with error","suites":["tap"],"updatePoint":{"line":277,"column":60},"line":277,"code":"  it('should mirror multiple values and terminate with error', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' --1--2--3--#');\n      const e1subs = '  ^----------!';\n      const expected = '--1--2--3--#';\n\n      const result = e1.pipe(\n        tap(() => {\n          //noop\n        })\n      );\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["tap"],"updatePoint":{"line":293,"column":73},"line":293,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        tap(() => {\n          /* noop */\n        }),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should support an unsubscribe event that fires before finalize","suites":["tap","lifecycle handlers"],"updatePoint":{"line":319,"column":70},"line":319,"code":"    it('should support an unsubscribe event that fires before finalize', () => {\n      const results: any[] = [];\n      const subject = new Subject<number>();\n\n      const subscription = subject\n        .pipe(\n          tap({\n            subscribe: () => results.push('subscribe'),\n            next: (value) => results.push(`next ${value}`),\n            error: (err) => results.push(`error: ${err.message}`),\n            complete: () => results.push('complete'),\n            unsubscribe: () => results.push('unsubscribe'),\n            finalize: () => results.push('finalize'),\n          })\n        )\n        .subscribe();\n\n      subject.next(1);\n      subject.next(2);\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2']);\n\n      subscription.unsubscribe();\n\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2', 'unsubscribe', 'finalize']);\n    });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not call unsubscribe if source completes","suites":["tap","lifecycle handlers"],"updatePoint":{"line":345,"column":55},"line":345,"code":"    it('should not call unsubscribe if source completes', () => {\n      const results: any[] = [];\n      const subject = new Subject<number>();\n\n      const subscription = subject\n        .pipe(\n          tap({\n            subscribe: () => results.push('subscribe'),\n            next: (value) => results.push(`next ${value}`),\n            error: (err) => results.push(`error: ${err.message}`),\n            complete: () => results.push('complete'),\n            unsubscribe: () => results.push('unsubscribe'),\n            finalize: () => results.push('finalize'),\n          })\n        )\n        .subscribe();\n\n      subject.next(1);\n      subject.next(2);\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2']);\n      subject.complete();\n      // should have no effect\n      subscription.unsubscribe();\n\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2', 'complete', 'finalize']);\n    });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should not call unsubscribe if source errors","suites":["tap","lifecycle handlers"],"updatePoint":{"line":372,"column":52},"line":372,"code":"    it('should not call unsubscribe if source errors', () => {\n      const results: any[] = [];\n      const subject = new Subject<number>();\n\n      const subscription = subject\n        .pipe(\n          tap({\n            subscribe: () => results.push('subscribe'),\n            next: (value) => results.push(`next ${value}`),\n            error: (err) => results.push(`error: ${err.message}`),\n            complete: () => results.push('complete'),\n            unsubscribe: () => results.push('unsubscribe'),\n            finalize: () => results.push('finalize'),\n          })\n        )\n        .subscribe({\n          error: noop,\n        });\n\n      subject.next(1);\n      subject.next(2);\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2']);\n      subject.error(new Error('bad'));\n      // should have no effect\n      subscription.unsubscribe();\n\n      expect(results).to.deep.equal(['subscribe', 'next 1', 'next 2', 'error: bad', 'finalize']);\n    });","file":"operators/tap-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the first value in each time window","suites":["throttle"],"updatePoint":{"line":16,"column":65},"line":16,"code":"  it('should immediately emit the first value in each time window', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-xy-----b--x--cxyz-|');\n      const e1subs = '  ^--------------------!';\n      const e2 = cold('  ----i                ');\n      //                          ----i\n      //                                ----i\n      const e2subs = [\n        '               -^---!                ',\n        '               ----------^---!       ',\n        '               ----------------^---! ',\n      ];\n      const expected = '-a--------b-----c----|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle sync source with sync notifier and trailing appropriately","suites":["throttle"],"updatePoint":{"line":38,"column":77},"line":38,"code":"  it('should handle sync source with sync notifier and trailing appropriately', () => {\n    const results: any[] = [];\n    const source = of(1).pipe(throttle(() => of(1), { leading: false, trailing: true }));\n\n    source.subscribe({\n      next: (value) => results.push(value),\n      complete: () => results.push('done'),\n    });\n\n    expect(results).to.deep.equal([1, 'done']);\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should simply mirror the source if values are not emitted often enough","suites":["throttle"],"updatePoint":{"line":50,"column":76},"line":50,"code":"  it('should simply mirror the source if values are not emitted often enough', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ^a--------b-----c----|');\n      const e1subs = '  ^--------------------!';\n      const e2 = cold('  ----|                ');\n      const e2subs = [\n        '               -^---!                ',\n        '               ----------^---!       ',\n        '               ----------------^---! ',\n      ];\n      const expected = '-a--------b-----c----|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle with duration Observable using next to close the duration","suites":["throttle"],"updatePoint":{"line":70,"column":79},"line":70,"code":"  it('should throttle with duration Observable using next to close the duration', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ^a-xy-----b--x--cxxx-|');\n      const e1subs = '  ^--------------------!';\n      const e2 = cold('  ----x-y-z            ');\n      const e2subs = [\n        '               -^---!                ',\n        '               ----------^---!       ',\n        '               ----------------^---! ',\n      ];\n      const expected = '-a--------b-----c----|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should interrupt source and duration when result is unsubscribed early","suites":["throttle"],"updatePoint":{"line":90,"column":76},"line":90,"code":"  it('should interrupt source and duration when result is unsubscribed early', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-x-y-z-xyz-x-y-z----b--x-x-|');\n      const unsub = '   --------------!               ';\n      const e1subs = '  ^-------------!               ';\n      const e2 = cold('  ---------------------|       ');\n      const e2subs = '  -^------------!               ';\n      const expected = '-a-------------               ';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["throttle"],"updatePoint":{"line":107,"column":83},"line":107,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a-x-y-z-xyz-x-y-z----b--x-x-|');\n      const e1subs = '  ^-------------!               ';\n      const e2 = cold('  ------------------|           ');\n      const e2subs = '  -^------------!               ';\n      const expected = '-a-------------               ';\n      const unsub = '   --------------!               ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        throttle(() => e2),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a busy producer emitting a regular repeating sequence","suites":["throttle"],"updatePoint":{"line":128,"column":73},"line":128,"code":"  it('should handle a busy producer emitting a regular repeating sequence', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const e2 = cold(' -----|                    ');\n      const e2subs = [\n        '               ^----!                    ',\n        '               ------^----!              ',\n        '               ------------^----!        ',\n        '               ------------------^----!  ',\n        '               ------------------------^!',\n      ];\n      const expected = 'a-----a-----a-----a-----a|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror source if durations are immediate","suites":["throttle"],"updatePoint":{"line":150,"column":53},"line":150,"code":"  it('should mirror source if durations are immediate', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const e2 = cold(' x                         ');\n      const expected = 'abcdefabcdefabcdefabcdefa|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should mirror source if durations are empty","suites":["throttle"],"updatePoint":{"line":164,"column":49},"line":164,"code":"  it('should mirror source if durations are empty', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^------------------------!';\n      const e2 = cold(' |                         ');\n      const expected = 'abcdefabcdefabcdefabcdefa|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should take only the first value emitted if duration is a never","suites":["throttle"],"updatePoint":{"line":178,"column":69},"line":178,"code":"  it('should take only the first value emitted if duration is a never', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^----------------------------!';\n      const e2 = cold(' -                             ');\n      const e2subs = '  ----^------------------------!';\n      const expected = '----a------------------------|';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe duration Observable when source raise error","suites":["throttle"],"updatePoint":{"line":194,"column":68},"line":194,"code":"  it('should unsubscribe duration Observable when source raise error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa#');\n      const e1subs = '  ^----------------------------!';\n      const e2 = cold(' -                             ');\n      const e2subs = '  ----^------------------------!';\n      const expected = '----a------------------------#';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error as soon as just-throw duration is used","suites":["throttle"],"updatePoint":{"line":210,"column":63},"line":210,"code":"  it('should raise error as soon as just-throw duration is used', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ----abcdefabcdefabcdefabcdefa|');\n      const e1subs = '  ^---!-------------------------';\n      const e2 = cold(' #                             ');\n      const e2subs = '  ----(^!)                      ';\n      const expected = '----(a#)                      ';\n\n      const result = e1.pipe(throttle(() => e2));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle using durations of varying lengths","suites":["throttle"],"updatePoint":{"line":226,"column":56},"line":226,"code":"  it('should throttle using durations of varying lengths', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdabcdefghabca|   ');\n      const e1subs = '  ^---------------------!   ';\n      const e2 = [\n        cold('          -----|                    '),\n        cold('                ---|                '),\n        cold('                    -------|        '),\n        cold('                            --|     '),\n        cold('                               ----|'),\n      ];\n      const e2subs = [\n        '               ^----!                    ',\n        '               ------^--!                ',\n        '               ----------^------!        ',\n        '               ------------------^-!     ',\n        '               ---------------------^!   ',\n      ];\n      const expected = 'a-----a---a-------a--a|   ';\n\n      let i = 0;\n      const result = e1.pipe(throttle(() => e2[i++]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let j = 0; j < e2.length; j++) {\n        expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j]);\n      }\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from duration Observable","suites":["throttle"],"updatePoint":{"line":257,"column":53},"line":257,"code":"  it('should propagate error from duration Observable', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  abcdefabcdabcdefghabca|   ');\n      const e1subs = '  ^----------------!        ';\n      const e2 = [\n        cold('          -----|                    '),\n        cold('                ---|                '),\n        cold('                    -------#        '),\n      ];\n      const e2subs = [\n        '               ^----!                    ',\n        '               ------^--!                ',\n        '               ----------^------!        ',\n      ];\n      const expected = 'a-----a---a------#        ';\n\n      let i = 0;\n      const result = e1.pipe(throttle(() => e2[i++]));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      for (let j = 0; j < e2.length; j++) {\n        expectSubscriptions(e2[j].subscriptions).toBe(e2subs[j]);\n      }\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from durationSelector function","suites":["throttle"],"updatePoint":{"line":284,"column":66},"line":284,"code":"  it('should propagate error thrown from durationSelector function', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const s1 = hot(' --^--x--x--x--x--x--x--e--x--x--x--|');\n      const s1Subs = ' ^--------------------!              ';\n      const n1 = cold('----|                               ');\n      const n1Subs = [\n        '              ---^---!                            ',\n        '              ---------^---!                      ',\n        '              ---------------^---!                ',\n      ];\n      const exp = '    ---x-----x-----x-----(e#)           ';\n\n      let i = 0;\n      const result = s1.pipe(\n        throttle(() => {\n          if (i++ === 3) {\n            throw new Error('lol');\n          }\n          return n1;\n        })\n      );\n      expectObservable(result).toBe(exp, undefined, new Error('lol'));\n      expectSubscriptions(s1.subscriptions).toBe(s1Subs);\n      expectSubscriptions(n1.subscriptions).toBe(n1Subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["throttle"],"updatePoint":{"line":311,"column":47},"line":311,"code":"  it('should complete when source does not emit', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----|');\n      const subs = '    ^----!';\n      const expected = '-----|';\n\n      function durationSelector() {\n        return cold('-----|');\n      }\n\n      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["throttle"],"updatePoint":{"line":326,"column":67},"line":326,"code":"  it('should raise error when source does not emit and raises error', () => {\n    testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -----#');\n      const subs = '    ^----!';\n      const expected = '-----#';\n\n      function durationSelector() {\n        return cold('-----|');\n      }\n\n      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["throttle"],"updatePoint":{"line":341,"column":35},"line":341,"code":"  it('should handle an empty source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |     ');\n      const subs = '    (^!)  ';\n      const expected = '|     ';\n\n      function durationSelector() {\n        return cold('-----|');\n      }\n\n      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["throttle"],"updatePoint":{"line":356,"column":34},"line":356,"code":"  it('should handle a never source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -     ');\n      const subs = '    ^     ';\n      const expected = '-     ';\n\n      function durationSelector() {\n        return cold('-----|');\n      }\n\n      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a throw source","suites":["throttle"],"updatePoint":{"line":371,"column":34},"line":371,"code":"  it('should handle a throw source', () => {\n    testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #     ');\n      const subs = '    (^!)  ';\n      const expected = '#     ';\n\n      function durationSelector() {\n        return cold('-----|');\n      }\n\n      expectObservable(e1.pipe(throttle(durationSelector))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n    });\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the first value in each time window","suites":["throttle","throttle(fn, { leading: true, trailing: true })"],"updatePoint":{"line":387,"column":67},"line":387,"code":"    it('should immediately emit the first value in each time window', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-xy-----b--x--cxxx------|');\n        const e1subs = '  ^-------------------------!';\n        const e2 = cold('  ----x                     ');\n        const e2subs = [\n          '               -^---!                     ',\n          '               -----^---!                 ',\n          '               ----------^---!            ',\n          '               --------------^---!        ',\n          '               ------------------^---!    ',\n          '               ----------------------^---!',\n        ];\n        const expected = '-a---y----b---x---x---x---|';\n\n        const result = e1.pipe(throttle(() => e2, { leading: true, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for individual values","suites":["throttle","throttle(fn, { leading: true, trailing: true })"],"updatePoint":{"line":410,"column":41},"line":410,"code":"    it('should work for individual values', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const s1 = hot('-^-x------------------|     ');\n        const s1Subs = ' ^--------------------!     ';\n        const n1 = cold('  ------------------------|');\n        const n1Subs = ['--^------------------!     '];\n        const exp = '    --x------------------|     ';\n\n        const result = s1.pipe(throttle(() => n1, { leading: true, trailing: true }));\n        expectObservable(result).toBe(exp);\n        expectSubscriptions(s1.subscriptions).toBe(s1Subs);\n        expectSubscriptions(n1.subscriptions).toBe(n1Subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit trailing value after throttle duration when source completes","suites":["throttle","throttle(fn, { leading: true, trailing: true })"],"updatePoint":{"line":425,"column":80},"line":425,"code":"    it('should emit trailing value after throttle duration when source completes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--------xy|     ');\n        const e1subs = '  ^-----------!     ';\n        const e2 = cold('  ----x            ');\n        const e2subs = [\n          // because prettier\n          '               -^---!            ',\n          '               ----------^---!   ',\n        ];\n        const expected = '-a--------x---(y|)';\n\n        const result = e1.pipe(throttle(() => e2, { leading: true, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the first value in each time window","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":447,"column":67},"line":447,"code":"    it('should immediately emit the first value in each time window', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-xy-----b--x--cxxx------|');\n        const e1subs = '  ^-------------------------!';\n        const e2 = cold('  ----x                     ');\n        const e2subs = [\n          '               -^---!                     ',\n          '               -----^---!                 ',\n          '               ----------^---!            ',\n          '               --------------^---!        ',\n          '               ------------------^---!    ',\n          '               ----------------------^---!',\n        ];\n        const expected = '-----y--------x---x---x---|';\n\n        const result = e1.pipe(throttle(() => e2, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should work for individual values","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":470,"column":41},"line":470,"code":"    it('should work for individual values', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const s1 = hot('-^-x------------------|        ');\n        const s1Subs = ' ^--------------------!        ';\n        const n1 = cold('  ------------------------x   ');\n        const n1Subs = ['--^-----------------------!   '];\n        const exp = '    --------------------------(x|)';\n\n        const result = s1.pipe(throttle(() => n1, { leading: false, trailing: true }));\n        expectObservable(result).toBe(exp);\n        expectSubscriptions(s1.subscriptions).toBe(s1Subs);\n        expectSubscriptions(n1.subscriptions).toBe(n1Subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should wait for trailing throttle before completing, even if source completes","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":485,"column":85},"line":485,"code":"    it('should wait for trailing throttle before completing, even if source completes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const source = hot('  -^--x--------y---------|        ');\n        const sourceSubs = '   ^---------------------!        ';\n        const duration = cold('   ------------------------x   ');\n        const durationSubs = ' ---^-----------------------!   ';\n        const exp = '          ---------------------------(y|)';\n\n        const result = source.pipe(throttle(() => duration, { leading: false, trailing: true }));\n        expectObservable(result).toBe(exp);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(duration.subscriptions).toBe(durationSubs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit trailing value after throttle duration when source completes","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":500,"column":80},"line":500,"code":"    it('should emit trailing value after throttle duration when source completes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--------x|   ');\n        const e1subs = '  ^----------!   ';\n        const e2 = cold('  ----x         ');\n        const e2subs = [\n          // because prettier\n          '               -^---!         ',\n          '               -----^---!     ',\n          '               ----------^---!',\n        ];\n        const expected = '-----a--------(x|)';\n\n        const result = e1.pipe(throttle(() => e2, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last trailing value after throttle duration when source completes","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":521,"column":89},"line":521,"code":"    it('should emit the last trailing value after throttle duration when source completes', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--------xy|  ');\n        const e1subs = '  ^-----------!  ';\n        const e2 = cold('  ----x         ');\n        const e2subs = [\n          // because prettier\n          '               -^---!         ',\n          '               -----^---!     ',\n          '               ----------^---!',\n        ];\n        const expected = '-----a--------(y|)';\n\n        const result = e1.pipe(throttle(() => e2, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source completes if no value is available","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":542,"column":70},"line":542,"code":"    it('should complete when source completes if no value is available', () => {\n      testScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-----|');\n        const e1subs = '  ^------!';\n        const e2 = cold('  ----x  ');\n        const e2subs = [\n          // because prettier\n          '               -^---!  ',\n          '               -----^-!',\n        ];\n        const expected = '-----a-|';\n\n        const result = e1.pipe(throttle(() => e2, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n        expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      });\n    });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["throttle","throttle(fn, { leading: false, trailing: true })"],"updatePoint":{"line":563,"column":73},"line":563,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable\n      .pipe(\n        throttle(() => of(0)),\n        take(3)\n      )\n      .subscribe(() => {\n        /* noop */\n      });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/throttle-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the first value in each time window","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":17,"column":67},"line":17,"code":"    it('should immediately emit the first value in each time window', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-x-y----b---x-cx---|');\n        //                 ----|    ----| ----|\n        const expected = '-a--------b-----c----|';\n        const subs = '    ^--------------------!';\n\n        const result = e1.pipe(throttleTime(5, rxTest));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle events by 5 time units","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":31,"column":46},"line":31,"code":"    it('should throttle events by 5 time units', (done) => {\n      of(1, 2, 3)\n        .pipe(throttleTime(5))\n        .subscribe({\n          next: (x: number) => {\n            expect(x).to.equal(1);\n          },\n          complete: done,\n        });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle events multiple times","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":42,"column":45},"line":42,"code":"    it('should throttle events multiple times', () => {\n      const expected = ['1-0', '2-0'];\n      concat(\n        timer(0, 1, rxTest).pipe(\n          take(3),\n          map((x: number) => '1-' + x)\n        ),\n        timer(8, 1, rxTest).pipe(\n          take(5),\n          map((x: number) => '2-' + x)\n        )\n      )\n        .pipe(throttleTime(5, rxTest))\n        .subscribe((x: string) => {\n          expect(x).to.equal(expected.shift());\n        });\n\n      rxTest.flush();\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should simply mirror the source if values are not emitted often enough","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":62,"column":78},"line":62,"code":"    it('should simply mirror the source if values are not emitted often enough', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--------b-----c----|');\n        const subs = '    ^--------------------!';\n        const expected = '-a--------b-----c----|';\n\n        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a busy producer emitting a regular repeating sequence","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":73,"column":75},"line":73,"code":"    it('should handle a busy producer emitting a regular repeating sequence', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  abcdefabcdefabcdefabcdefa|');\n        const subs = '    ^------------------------!';\n        const expected = 'a-----a-----a-----a-----a|';\n\n        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when source does not emit","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":84,"column":49},"line":84,"code":"    it('should complete when source does not emit', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -----|');\n        const subs = '    ^----!';\n        const expected = '-----|';\n\n        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error when source does not emit and raises error","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":95,"column":69},"line":95,"code":"    it('should raise error when source does not emit and raises error', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -----#');\n        const subs = '    ^----!';\n        const expected = '-----#';\n\n        expectObservable(e1.pipe(throttleTime(10, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle an empty source","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":106,"column":37},"line":106,"code":"    it('should handle an empty source', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const e1 = cold(' |');\n        const subs = '    (^!)';\n        const expected = '|';\n\n        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":117,"column":36},"line":117,"code":"    it('should handle a never source', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const e1 = cold(' -');\n        const subs = '    ^';\n        const expected = '-';\n\n        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a throw source","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":128,"column":36},"line":128,"code":"    it('should handle a throw source', () => {\n      rxTest.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const e1 = cold(' #');\n        const subs = '    (^!)';\n        const expected = '#';\n\n        expectObservable(e1.pipe(throttleTime(30, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle and does not complete when source does not completes","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":139,"column":76},"line":139,"code":"    it('should throttle and does not complete when source does not completes', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--(bc)-------d----------------');\n        const unsub = '   -------------------------------!';\n        const subs = '    ^------------------------------!';\n        const expected = '-a-------------d----------------';\n\n        expectObservable(e1.pipe(throttleTime(5, rxTest)), unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":151,"column":85},"line":151,"code":"    it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--(bc)-------d----------------');\n        const subs = '    ^------------------------------!';\n        const expected = '-a-------------d----------------';\n        const unsub = '   -------------------------------!';\n\n        const result = e1.pipe(\n          mergeMap((x: string) => of(x)),\n          throttleTime(5, rxTest),\n          mergeMap((x: string) => of(x))\n        );\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should throttle values until source raises error","suites":["throttleTime operator","default behavior { leading: true, trailing: false }"],"updatePoint":{"line":169,"column":56},"line":169,"code":"    it('should throttle values until source raises error', () => {\n      rxTest.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a--(bc)-------d---------------#');\n        const subs = '    ^------------------------------!';\n        const expected = '-a-------------d---------------#';\n\n        expectObservable(e1.pipe(throttleTime(5, rxTest))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the first and last values in each time window","suites":["throttleTime operator","throttleTime(fn, { leading: true, trailing: true })"],"updatePoint":{"line":182,"column":77},"line":182,"code":"    it('should immediately emit the first and last values in each time window', () => {\n      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-xy-----b--x--cxxx--|');\n        const e1subs = '  ^---------------------!';\n        const t = time('   ----|                 ');\n        //                     ----|----|---|---|\n        const expected = '-a---y----b---x---x---(x|)';\n\n        const result = e1.pipe(throttleTime(t, rxTest, { leading: true, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the value if only a single one is given","suites":["throttleTime operator","throttleTime(fn, { leading: true, trailing: true })"],"updatePoint":{"line":197,"column":59},"line":197,"code":"    it('should emit the value if only a single one is given', () => {\n      rxTest.run(({ hot, time, expectObservable }) => {\n        const e1 = hot('  -a--------------------|');\n        const t = time('   ----|                 ');\n        const expected = '-a--------------------|';\n\n        const result = e1.pipe(throttleTime(t, rxTest, { leading: true, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should immediately emit the last value in each time window","suites":["throttleTime operator","throttleTime(fn, { leading: false, trailing: true })"],"updatePoint":{"line":211,"column":66},"line":211,"code":"    it('should immediately emit the last value in each time window', () => {\n      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-xy-----b--x--cxxx--|');\n        const e1subs = '  ^---------------------!';\n        const t = time('   ----|                 ');\n        //                 ----|---|----|---|---|\n        const expected = '-----y--------x---x---(x|)';\n\n        const result = e1.pipe(throttleTime(t, rxTest, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last throttled value when complete","suites":["throttleTime operator","throttleTime(fn, { leading: false, trailing: true })"],"updatePoint":{"line":226,"column":58},"line":226,"code":"    it('should emit the last throttled value when complete', () => {\n      rxTest.run(({ hot, time, expectObservable, expectSubscriptions }) => {\n        const e1 = hot('  -a-xy-----b--x--cxx-|');\n        const e1subs = '  ^-------------------!';\n        const t = time('   ----|               ');\n        //                 ----|---|----|---|---|\n        const expected = '-----y--------x---x-|';\n\n        const result = e1.pipe(throttleTime(t, rxTest, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the value if only a single one is given","suites":["throttleTime operator","throttleTime(fn, { leading: false, trailing: true })"],"updatePoint":{"line":241,"column":59},"line":241,"code":"    it('should emit the value if only a single one is given', () => {\n      rxTest.run(({ hot, time, expectObservable }) => {\n        const e1 = hot('  -a--------------------|');\n        const t = time('   ----|                 ');\n        const expected = '-----a----------------|';\n\n        const result = e1.pipe(throttleTime(t, rxTest, { leading: false, trailing: true }));\n\n        expectObservable(result).toBe(expected);\n      });\n    });","file":"operators/throttleTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should error when empty","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":17,"column":31},"line":17,"code":"    it('should error when empty', () => {\n      rxTestScheduler.run(({ cold, expectObservable }) => {\n        const source = cold('----|');\n        const expected = '   ----#';\n\n        const result = source.pipe(throwIfEmpty(() => new Error('test')));\n\n        expectObservable(result).toBe(expected, undefined, new Error('test'));\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if empty","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":28,"column":29},"line":28,"code":"    it('should throw if empty', () => {\n      const error = new Error('So empty inside');\n      let thrown: any;\n\n      EMPTY.pipe(throwIfEmpty(() => error)).subscribe({\n        error(err) {\n          thrown = err;\n        },\n      });\n\n      expect(thrown).to.equal(error);\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT throw if NOT empty","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":41,"column":37},"line":41,"code":"    it('should NOT throw if NOT empty', () => {\n      const error = new Error('So empty inside');\n      let thrown: any;\n\n      of('test')\n        .pipe(throwIfEmpty(() => error))\n        .subscribe({\n          error(err) {\n            thrown = err;\n          },\n        });\n\n      expect(thrown).to.be.undefined;\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass values through","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":56,"column":34},"line":56,"code":"    it('should pass values through', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('----a---b---c---|');\n        const sub1 = '       ^---------------!';\n        const expected = '   ----a---b---c---|';\n\n        const result = source.pipe(throwIfEmpty(() => new Error('test')));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should never when never","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":69,"column":31},"line":69,"code":"    it('should never when never', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('-');\n        const sub1 = '       ^';\n        const expected = '   -';\n\n        const result = source.pipe(throwIfEmpty(() => new Error('test')));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should error when empty","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":82,"column":31},"line":82,"code":"    it('should error when empty', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('----|');\n        const sub1 = '       ^---!';\n        const expected = '   ----#';\n\n        const result = source.pipe(throwIfEmpty(() => new Error('test')));\n\n        expectObservable(result).toBe(expected, undefined, new Error('test'));\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if empty after retry","suites":["throwIfEmpty","with errorFactory"],"updatePoint":{"line":95,"column":41},"line":95,"code":"    it('should throw if empty after retry', () => {\n      const error = new Error('So empty inside');\n      let thrown: any;\n      let sourceIsEmpty = false;\n\n      const source = defer(() => {\n        if (sourceIsEmpty) {\n          return EMPTY;\n        }\n        sourceIsEmpty = true;\n        return of(1, 2);\n      });\n\n      source\n        .pipe(\n          throwIfEmpty(() => error),\n          mergeMap((value) => {\n            if (value > 1) {\n              return throwError(() => new Error());\n            }\n\n            return of(value);\n          }),\n          retry(1)\n        )\n        .subscribe({\n          error(err) {\n            thrown = err;\n          },\n        });\n\n      expect(thrown).to.equal(error);\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw EmptyError if empty","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":131,"column":40},"line":131,"code":"    it('should throw EmptyError if empty', () => {\n      let thrown: any;\n\n      EMPTY.pipe(throwIfEmpty()).subscribe({\n        error(err) {\n          thrown = err;\n        },\n      });\n\n      expect(thrown).to.be.instanceof(EmptyError);\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT throw if NOT empty","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":143,"column":37},"line":143,"code":"    it('should NOT throw if NOT empty', () => {\n      let thrown: any;\n\n      of('test')\n        .pipe(throwIfEmpty())\n        .subscribe({\n          error(err) {\n            thrown = err;\n          },\n        });\n\n      expect(thrown).to.be.undefined;\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass values through","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":157,"column":34},"line":157,"code":"    it('should pass values through', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('----a---b---c---|');\n        const sub1 = '       ^---------------!';\n        const expected = '   ----a---b---c---|';\n\n        const result = source.pipe(throwIfEmpty());\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should never when never","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":170,"column":31},"line":170,"code":"    it('should never when never', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('-');\n        const sub1 = '       ^';\n        const expected = '   -';\n\n        const result = source.pipe(throwIfEmpty());\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should error when empty","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":183,"column":31},"line":183,"code":"    it('should error when empty', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const source = cold('----|');\n        const sub1 = '       ^---!';\n        const expected = '   ----#';\n\n        const result = source.pipe(throwIfEmpty());\n\n        expectObservable(result).toBe(expected, undefined, new EmptyError());\n        expectSubscriptions(source.subscriptions).toBe([sub1]);\n      });\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if empty after retry","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":196,"column":41},"line":196,"code":"    it('should throw if empty after retry', () => {\n      let thrown: any;\n      let sourceIsEmpty = false;\n\n      const source = defer(() => {\n        if (sourceIsEmpty) {\n          return EMPTY;\n        }\n        sourceIsEmpty = true;\n        return of(1, 2);\n      });\n\n      source\n        .pipe(\n          throwIfEmpty(),\n          mergeMap((value) => {\n            if (value > 1) {\n              return throwError(() => new Error());\n            }\n\n            return of(value);\n          }),\n          retry(1)\n        )\n        .subscribe({\n          error(err) {\n            thrown = err;\n          },\n        });\n\n      expect(thrown).to.be.instanceof(EmptyError);\n    });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["throwIfEmpty","without errorFactory"],"updatePoint":{"line":230,"column":73},"line":230,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(throwIfEmpty(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/throwIfEmpty-spec.ts","skipped":false,"dir":"spec"},{"name":"should record the time interval between source elements","suites":["timeInterval"],"updatePoint":{"line":17,"column":61},"line":17,"code":"  it('should record the time interval between source elements', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^b-c-----d--e--|');\n      const e1subs = '     ^--------------!';\n      const expected = '   -w-x-----y--z--|';\n      const expectedValue = { w: 1, x: 2, y: 6, z: 3 };\n\n      const result = e1.pipe(\n        timeInterval(rxTestScheduler),\n        map((x) => x.interval)\n      );\n\n      expectObservable(result).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should record interval if source emit elements","suites":["timeInterval"],"updatePoint":{"line":34,"column":52},"line":34,"code":"  it('should record interval if source emit elements', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^b--c----d---e--|');\n      const e1subs = '     ^---------------!';\n      const expected = '   -w--x----y---z--|';\n\n      const expectedValue = {\n        w: new TimeInterval('b', 1),\n        x: new TimeInterval('c', 3),\n        y: new TimeInterval('d', 5),\n        z: new TimeInterval('e', 4),\n      };\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should completes without record interval if source does not emits","suites":["timeInterval"],"updatePoint":{"line":52,"column":71},"line":52,"code":"  it('should completes without record interval if source does not emits', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---------|');\n      const e1subs = '  ^--------!';\n      const expected = '---------|';\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete immediately if source is empty","suites":["timeInterval"],"updatePoint":{"line":63,"column":52},"line":63,"code":"  it('should complete immediately if source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should record interval then does not completes if source emits but not completes","suites":["timeInterval"],"updatePoint":{"line":74,"column":86},"line":74,"code":"  it('should record interval then does not completes if source emits but not completes', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b--');\n      const e1subs = '  ^------';\n      const expected = '-y--z--';\n\n      const expectedValue = {\n        y: new TimeInterval('a', 1),\n        z: new TimeInterval('b', 3),\n      };\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timeInterval"],"updatePoint":{"line":90,"column":53},"line":90,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b-----c---d---|');\n      const unsub = '   -------!           ';\n      const e1subs = '  ^------!           ';\n      const expected = '-y--z---           ';\n\n      const expectedValue = {\n        y: new TimeInterval('a', 1),\n        z: new TimeInterval('b', 3),\n      };\n\n      const result = e1.pipe(timeInterval(rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["timeInterval"],"updatePoint":{"line":109,"column":83},"line":109,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b-----c---d---|');\n      const e1subs = '  ^------!           ';\n      const expected = '-y--z---           ';\n      const unsub = '   -------!           ';\n\n      const expectedValue = {\n        y: new TimeInterval('a', 1),\n        z: new TimeInterval('b', 3),\n      };\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        timeInterval(rxTestScheduler),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes if source never completes","suites":["timeInterval"],"updatePoint":{"line":132,"column":52},"line":132,"code":"  it('should not completes if source never completes', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"raise error if source raises error","suites":["timeInterval"],"updatePoint":{"line":143,"column":40},"line":143,"code":"  it('raise error if source raises error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---#');\n      const e1subs = '  ^--!';\n      const expected = '---#';\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should record interval then raise error if source raises error after emit","suites":["timeInterval"],"updatePoint":{"line":154,"column":79},"line":154,"code":"  it('should record interval then raise error if source raises error after emit', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b--#');\n      const e1subs = '  ^------!';\n      const expected = '-y--z--#';\n\n      const expectedValue = {\n        y: new TimeInterval('a', 1),\n        z: new TimeInterval('b', 3),\n      };\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source immediately throws","suites":["timeInterval"],"updatePoint":{"line":170,"column":53},"line":170,"code":"  it('should raise error if source immediately throws', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(timeInterval(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["timeInterval"],"updatePoint":{"line":181,"column":73},"line":181,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(timeInterval(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/timeInterval-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified timeout period","suites":["timeout operator"],"updatePoint":{"line":18,"column":53},"line":18,"code":"  it('should timeout after a specified timeout period', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n      const e1 = cold(' -------a--b--|');\n      const t = time('  -----|        ');\n      const e1subs = '  ^----!        ';\n      const expected = '-----#        ';\n\n      const result = e1.pipe(timeout(t, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, null, defaultTimeoutError);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit and TimeoutError on timeout with appropriate due as number","suites":["timeout operator"],"updatePoint":{"line":32,"column":76},"line":32,"code":"  it('should emit and TimeoutError on timeout with appropriate due as number', () => {\n    rxTestScheduler.run(({ cold, time }) => {\n      const e1 = cold('-------a--b--|');\n      const t = time(' -----|');\n      const result = e1.pipe(timeout(t, rxTestScheduler));\n      let error: any;\n      result.subscribe({\n        next: () => {\n          throw new Error('this should not next');\n        },\n        error: (err) => {\n          error = err;\n        },\n        complete: () => {\n          throw new Error('this should not complete');\n        },\n      });\n      rxTestScheduler.flush();\n      expect(error).to.be.an.instanceof(TimeoutError);\n      expect(error).to.have.property('name', 'TimeoutError');\n      expect(error!.info).to.deep.equal({\n        seen: 0,\n        meta: null,\n        lastValue: null,\n      });\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit and TimeoutError on timeout with appropriate due as Date","suites":["timeout operator"],"updatePoint":{"line":60,"column":74},"line":60,"code":"  it('should emit and TimeoutError on timeout with appropriate due as Date', () => {\n    rxTestScheduler.run(({ cold, time }) => {\n      const e1 = cold('-------a--b--|');\n      const t = time(' ----|');\n\n      // 4ms from \"now\", considering \"now\" with the rxTestScheduler is currently frame 0.\n      const dueDate = new Date(t);\n\n      const result = e1.pipe(timeout(dueDate, rxTestScheduler));\n      let error: any;\n      result.subscribe({\n        next: () => {\n          throw new Error('this should not next');\n        },\n        error: (err) => {\n          error = err;\n        },\n        complete: () => {\n          throw new Error('this should not complete');\n        },\n      });\n      rxTestScheduler.flush();\n      expect(error).to.be.an.instanceof(TimeoutError);\n      expect(error).to.have.property('name', 'TimeoutError');\n      expect(error!.info).to.deep.equal({\n        seen: 0,\n        meta: null,\n        lastValue: null,\n      });\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within absolute timeout period","suites":["timeout operator"],"updatePoint":{"line":92,"column":75},"line":92,"code":"  it('should not timeout if source completes within absolute timeout period', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const t = time('  --------------------|');\n      const e1subs = '  ^----------------!';\n      const expected = '--a--b--c--d--e--|';\n\n      // Start frame is zero.\n      const timeoutValue = new Date(t);\n\n      expectObservable(e1.pipe(timeout(timeoutValue, rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source emits within timeout period","suites":["timeout operator"],"updatePoint":{"line":107,"column":62},"line":107,"code":"  it('should not timeout if source emits within timeout period', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  --a--b--c--d--e--|');\n      const t = time('  -----|            ');\n      const e1subs = '  ^----------------!';\n      const expected = '--a--b--c--d--e--|';\n\n      expectObservable(e1.pipe(timeout(t, rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timeout operator"],"updatePoint":{"line":119,"column":53},"line":119,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  --a--b--c---d--e--|');\n      const t = time('  -----|             ');\n      const unsub = '   ----------!        ';\n      const e1subs = '  ^---------!        ';\n      const expected = '--a--b--c--        ';\n\n      const result = e1.pipe(timeout(t, rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["timeout operator"],"updatePoint":{"line":134,"column":83},"line":134,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  --a--b--c---d--e--|');\n      const t = time('  -----|             ');\n      const e1subs = '  ^---------!        ';\n      const expected = '--a--b--c--        ';\n      const unsub = '   ----------!        ';\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        timeout(t, rxTestScheduler),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified timeout period between emit with default error while source emits","suites":["timeout operator"],"updatePoint":{"line":153,"column":104},"line":153,"code":"  it('should timeout after a specified timeout period between emit with default error while source emits', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n      const e1 = hot('  ---a---b---c------d---e---|');\n      const t = time('             -----|');\n      const e1subs = '  ^---------------!          ';\n      const expected = '---a---b---c----#          ';\n\n      const result = e1.pipe(timeout(t, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout at a specified Date","suites":["timeout operator"],"updatePoint":{"line":167,"column":40},"line":167,"code":"  it('should timeout at a specified Date', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n      const e1 = cold(' -');\n      const t = time('  ----------|');\n      const e1subs = '  ^---------!';\n      const expected = '----------#';\n\n      // Start time is zero\n      const result = e1.pipe(timeout(new Date(t), rxTestScheduler));\n\n      expectObservable(result).toBe(expected, null, defaultTimeoutError);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with synchronous observable","suites":["timeout operator"],"updatePoint":{"line":182,"column":45},"line":182,"code":"  it('should work with synchronous observable', () => {\n    expect(() => {\n      of(1).pipe(timeout(10)).subscribe();\n    }).to.not.throw();\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified timeout period","suites":["timeout operator","config"],"updatePoint":{"line":189,"column":55},"line":189,"code":"    it('should timeout after a specified timeout period', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold(' -------a--b--|');\n        const t = time('  -----|        ');\n        const e1subs = '  ^----!        ';\n        const expected = '-----#        ';\n\n        const result = e1.pipe(\n          timeout({\n            each: t,\n          })\n        );\n\n        expectObservable(result).toBe(expected, null, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit and TimeoutError on timeout with appropriate due as number","suites":["timeout operator","config"],"updatePoint":{"line":207,"column":78},"line":207,"code":"    it('should emit and TimeoutError on timeout with appropriate due as number', () => {\n      rxTestScheduler.run(({ cold, time }) => {\n        const e1 = cold('-------a--b--|');\n        const t = time(' -----|');\n        const result = e1.pipe(timeout({ each: t }));\n        let error: any;\n        result.subscribe({\n          next: () => {\n            throw new Error('this should not next');\n          },\n          error: (err) => {\n            error = err;\n          },\n          complete: () => {\n            throw new Error('this should not complete');\n          },\n        });\n        rxTestScheduler.flush();\n        expect(error).to.be.an.instanceof(TimeoutError);\n        expect(error).to.have.property('name', 'TimeoutError');\n        expect(error!.info).to.deep.equal({\n          seen: 0,\n          meta: null,\n          lastValue: null,\n        });\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit and TimeoutError on timeout with appropriate due as Date","suites":["timeout operator","config"],"updatePoint":{"line":235,"column":76},"line":235,"code":"    it('should emit and TimeoutError on timeout with appropriate due as Date', () => {\n      rxTestScheduler.run(({ cold, time }) => {\n        const e1 = cold('-------a--b--|');\n        const t = time(' ----|');\n\n        // 4ms from \"now\", considering \"now\" with the rxTestScheduler is currently frame 0.\n        const dueDate = new Date(t);\n\n        const result = e1.pipe(timeout({ first: dueDate }));\n        let error: any;\n        result.subscribe({\n          next: () => {\n            throw new Error('this should not next');\n          },\n          error: (err) => {\n            error = err;\n          },\n          complete: () => {\n            throw new Error('this should not complete');\n          },\n        });\n        rxTestScheduler.flush();\n        expect(error).to.be.an.instanceof(TimeoutError);\n        expect(error).to.have.property('name', 'TimeoutError');\n        expect(error!.info).to.deep.equal({\n          seen: 0,\n          meta: null,\n          lastValue: null,\n        });\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within absolute timeout period","suites":["timeout operator","config"],"updatePoint":{"line":267,"column":77},"line":267,"code":"    it('should not timeout if source completes within absolute timeout period', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n        const e1 = hot('  --a--b--c--d--e--|');\n        const t = time('  --------------------|');\n        const e1subs = '  ^----------------!';\n        const expected = '--a--b--c--d--e--|';\n\n        expectObservable(e1.pipe(timeout({ first: new Date(t) }))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source emits within timeout period","suites":["timeout operator","config"],"updatePoint":{"line":279,"column":64},"line":279,"code":"    it('should not timeout if source emits within timeout period', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n        const e1 = hot('  --a--b--c--d--e--|');\n        const t = time('  -----|            ');\n        const e1subs = '  ^----------------!';\n        const expected = '--a--b--c--d--e--|';\n\n        expectObservable(e1.pipe(timeout({ each: t }))).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timeout operator","config"],"updatePoint":{"line":291,"column":55},"line":291,"code":"    it('should allow unsubscribing explicitly and early', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n        const e1 = hot('  --a--b--c---d--e--|');\n        const t = time('  -----|             ');\n        const unsub = '   ----------!        ';\n        const e1subs = '  ^---------!        ';\n        const expected = '--a--b--c--        ';\n\n        const result = e1.pipe(timeout({ each: t }));\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["timeout operator","config"],"updatePoint":{"line":306,"column":85},"line":306,"code":"    it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n        const e1 = hot('  --a--b--c---d--e--|');\n        const t = time('  -----|             ');\n        const e1subs = '  ^---------!        ';\n        const expected = '--a--b--c--        ';\n        const unsub = '   ----------!        ';\n\n        const result = e1.pipe(\n          mergeMap((x) => of(x)),\n          timeout({ each: t }),\n          mergeMap((x) => of(x))\n        );\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified timeout period between emit with default error while source emits","suites":["timeout operator","config"],"updatePoint":{"line":325,"column":106},"line":325,"code":"    it('should timeout after a specified timeout period between emit with default error while source emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions, time }) => {\n        const e1 = hot('  ---a---b---c------d---e---|');\n        const t = time('             -----|');\n        const e1subs = '  ^---------------!          ';\n        const expected = '---a---b---c----#          ';\n\n        const result = e1.pipe(timeout({ each: t }));\n\n        expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout at a specified Date","suites":["timeout operator","config"],"updatePoint":{"line":339,"column":42},"line":339,"code":"    it('should timeout at a specified Date', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold(' -');\n        const t = time('  ----------|');\n        const e1subs = '  ^---------!';\n        const expected = '----------#';\n\n        // Start time is zero\n        const result = e1.pipe(timeout({ first: new Date(t) }));\n\n        expectObservable(result).toBe(expected, null, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout at a specified time for first value only","suites":["timeout operator","config"],"updatePoint":{"line":354,"column":63},"line":354,"code":"    it('should timeout at a specified time for first value only', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold(' -');\n        const t = time('  ----------|');\n        const e1subs = '  ^---------!';\n        const expected = '----------#';\n\n        // Start time is zero\n        const result = e1.pipe(timeout({ first: t }));\n\n        expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout for long delays if only first is specified","suites":["timeout operator","config"],"updatePoint":{"line":369,"column":69},"line":369,"code":"    it('should not timeout for long delays if only first is specified', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold(' ---a-----------------------b---|');\n        const t = time('     ----------|');\n        const e1subs = '  ^------------------------------!';\n        const expected = '---a-----------------------b---|';\n\n        // Start time is zero\n        const result = e1.pipe(timeout({ first: t }));\n\n        expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout for long delays if only first is specified as Date","suites":["timeout operator","config"],"updatePoint":{"line":384,"column":77},"line":384,"code":"    it('should not timeout for long delays if only first is specified as Date', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold(' ---a-----------------------b---|');\n        const t = time('  ----------|');\n        const e1subs = '  ^------------------------------!';\n        const expected = '---a-----------------------b---|';\n\n        // Start time is zero\n        const result = e1.pipe(timeout({ first: new Date(t) }));\n\n        expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout for long delays if first is specified as Date AND each is specified","suites":["timeout operator","config"],"updatePoint":{"line":399,"column":90},"line":399,"code":"    it('should timeout for long delays if first is specified as Date AND each is specified', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions, time }) => {\n        const e1 = cold('   ---a-----------------------b---|');\n        const first = time('-------------|');\n        const each = time('    ------|');\n        const e1subs = '    ^--------!';\n        const expected = '  ---a-----#';\n\n        // Start time is zero\n        const result = e1.pipe(timeout({ first: new Date(first), each }));\n\n        expectObservable(result).toBe(expected, undefined, defaultTimeoutError);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable","suites":["timeout operator","using with"],"updatePoint":{"line":417,"column":87},"line":417,"code":"    it('should timeout after a specified period then subscribe to the passed observable', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = cold('  -------a--b--|');\n        const sourceSubs = '   ^----!        ';\n        const t = time('       -----|');\n        const inner = cold('        x-y-z-|  ');\n        const innerSubs = '    -----^-----!  ';\n        const expected = '     -----x-y-z-|  ';\n\n        const result = source.pipe(\n          timeout({\n            each: t,\n            with: () => inner,\n          })\n        );\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout at a specified date then subscribe to the passed observable","suites":["timeout operator","using with"],"updatePoint":{"line":439,"column":82},"line":439,"code":"    it('should timeout at a specified date then subscribe to the passed observable', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = cold('  -');\n        const sourceSubs = '   ^---------!           ';\n        const t = time('       ----------|');\n        const inner = cold('             --x--y--z--|');\n        const innerSubs = '    ----------^----------!';\n        const expected = '     ------------x--y--z--|';\n\n        // The the current frame is zero.\n        const result = source.pipe(\n          timeout({\n            first: new Date(t),\n            with: () => inner,\n          })\n        );\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then subscribe to the passed observable when source emits","suites":["timeout operator","using with"],"updatePoint":{"line":462,"column":118},"line":462,"code":"    it('should timeout after a specified period between emit then subscribe to the passed observable when source emits', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  ---a---b------c---|');\n        const t = time('             ----|       ');\n        const sourceSubs = '  ^----------!       ';\n        const inner = cold('             -x-y-|  ');\n        const innerSubs = '   -----------^----!  ';\n        const expected = '    ---a---b----x-y-|  ';\n\n        const result = source.pipe(\n          timeout({\n            each: t,\n            with: () => inner,\n          })\n        );\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timeout operator","using with"],"updatePoint":{"line":484,"column":55},"line":484,"code":"    it('should allow unsubscribing explicitly and early', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  ---a---b-----c----|');\n        const t = time('             ----|       ');\n        const sourceSubs = '  ^----------!       ';\n        const inner = cold('             -x---y| ');\n        const innerSubs = '   -----------^--!    ';\n        const expected = '    ---a---b----x--    ';\n        const unsub = '       --------------!    ';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["timeout operator","using with"],"updatePoint":{"line":502,"column":74},"line":502,"code":"    it('should not break unsubscription chain when unsubscribed explicitly', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  ---a---b-----c----|');\n        const t = time('      ----|              ');\n        const sourceSubs = '  ^----------!       ';\n        const inner = cold('             -x---y| ');\n        const innerSubs = '   -----------^--!    ';\n        const expected = '    ---a---b----x--    ';\n        const unsub = '       --------------!    ';\n\n        const result = source.pipe(\n          mergeMap((x) => of(x)),\n          timeout({ each: t, with: () => inner }),\n          mergeMap((x) => of(x))\n        );\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not subscribe to withObservable after explicit unsubscription","suites":["timeout operator","using with"],"updatePoint":{"line":524,"column":76},"line":524,"code":"    it('should not subscribe to withObservable after explicit unsubscription', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = cold('---a------b------');\n        const t = time('     -----|           ');\n        const sourceSubs = ' ^----!           ';\n        const inner = cold('      i---j---|   ');\n        const expected = '   ---a--           ';\n        const unsub = '      -----!           ';\n\n        const result = source.pipe(\n          mergeMap((x) => of(x)),\n          timeout({ each: t, with: () => inner }),\n          mergeMap((x) => of(x))\n        );\n\n        expectObservable(result, unsub).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable when source is empty","suites":["timeout operator","using with"],"updatePoint":{"line":545,"column":108},"line":545,"code":"    it('should timeout after a specified period then subscribe to the passed observable when source is empty', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  -------------|      ');\n        const t = time('      ----------|         ');\n        const sourceSubs = '  ^---------!         ';\n        const inner = cold('            ----x----|');\n        const innerSubs = '   ----------^--------!';\n        const expected = '    --------------x----|';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then never completes if other source does not complete","suites":["timeout operator","using with"],"updatePoint":{"line":562,"column":115},"line":562,"code":"    it('should timeout after a specified period between emit then never completes if other source does not complete', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  --a--b--------c--d--|');\n        const t = time('           ----|           ');\n        const sourceSubs = '  ^--------!           ';\n        const inner = cold('           ------------');\n        const innerSubs = '   ---------^-----------';\n        const expected = '    --a--b---------------';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable when source raises error after timeout","suites":["timeout operator","using with"],"updatePoint":{"line":579,"column":126},"line":579,"code":"    it('should timeout after a specified period then subscribe to the passed observable when source raises error after timeout', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  -------------#      ');\n        const t = time('      ----------|         ');\n        const sourceSubs = '  ^---------!         ';\n        const inner = cold('            ----x----|');\n        const innerSubs = '   ----------^--------!';\n        const expected = '    --------------x----|';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then never completes if other source emits but not complete","suites":["timeout operator","using with"],"updatePoint":{"line":596,"column":120},"line":596,"code":"    it('should timeout after a specified period between emit then never completes if other source emits but not complete', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  -------------|      ');\n        const t = time('      -----------|        ');\n        const sourceSubs = '  ^----------!        ';\n        const inner = cold('             ----x----');\n        const innerSubs = '   -----------^--------';\n        const expected = '    ---------------x----';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe(innerSubs);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within timeout period","suites":["timeout operator","using with"],"updatePoint":{"line":613,"column":68},"line":613,"code":"    it('should not timeout if source completes within timeout period', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('  -----|        ');\n        const t = time('      ----------|   ');\n        const sourceSubs = '  ^----!        ';\n        const inner = cold('            ----x----');\n        const expected = '    -----|        ';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source raises error within timeout period","suites":["timeout operator","using with"],"updatePoint":{"line":629,"column":71},"line":629,"code":"    it('should not timeout if source raises error within timeout period', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('-----#              ');\n        const t = time('    ----------|         ');\n        const sourceSubs = '^----!              ';\n        const inner = cold('       ----x----|');\n        const expected = '  -----#              ';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source emits within timeout period","suites":["timeout operator","using with"],"updatePoint":{"line":645,"column":64},"line":645,"code":"    it('should not timeout if source emits within timeout period', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('   --a--b--c--d--e--|');\n        const t = time('       -----|            ');\n        const sourceSubs = '   ^----------------!';\n        const inner = cold('        ----x----|   ');\n        const expected = '     --a--b--c--d--e--|';\n\n        const result = source.pipe(timeout({ each: t, with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within specified Date","suites":["timeout operator","using with"],"updatePoint":{"line":661,"column":68},"line":661,"code":"    it('should not timeout if source completes within specified Date', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('--a--b--c--d--e--|   ');\n        const t = time('    --------------------|');\n        const sourceSubs = '^----------------!   ';\n        const inner = cold('--x--|            ');\n        const expected = '  --a--b--c--d--e--|   ';\n\n        // Start frame is zero.\n        const result = source.pipe(timeout({ first: new Date(t), with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source raises error within specified Date","suites":["timeout operator","using with"],"updatePoint":{"line":678,"column":71},"line":678,"code":"    it('should not timeout if source raises error within specified Date', () => {\n      rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n        const source = hot('---a---#           ');\n        const t = time('       ----------|     ');\n        const sourceSubs = '^------!           ';\n        const inner = cold('             --x--|');\n        const expected = '  ---a---#           ';\n\n        // Start frame is zero.\n        const result = source.pipe(timeout({ first: new Date(t), with: () => inner }));\n\n        expectObservable(result).toBe(expected);\n        expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n        expectSubscriptions(inner.subscriptions).toBe([]);\n      });\n    });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["timeout operator","using with"],"updatePoint":{"line":696,"column":73},"line":696,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(timeout(0), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/timeout-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable","suites":["timeoutWith operator"],"updatePoint":{"line":16,"column":85},"line":16,"code":"  it('should timeout after a specified period then subscribe to the passed observable', () => {\n    rxTestScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const source = cold('  -------a--b--|');\n      const sourceSubs = '   ^----!        ';\n      const t = time('       -----|');\n      const switchTo = cold('     x-y-z-|  ');\n      const switchToSubs = ' -----^-----!  ';\n      const expected = '     -----x-y-z-|  ';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout at a specified date then subscribe to the passed observable","suites":["timeoutWith operator"],"updatePoint":{"line":33,"column":80},"line":33,"code":"  it('should timeout at a specified date then subscribe to the passed observable', () => {\n    rxTestScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const source = cold('  -');\n      const sourceSubs = '   ^---------!           ';\n      const t = time('       ----------|')\n      const switchTo = cold('          --x--y--z--|');\n      const switchToSubs = ' ----------^----------!';\n      const expected = '     ------------x--y--z--|';\n\n      // The the current frame is zero.\n      const result = source.pipe(timeoutWith(new Date(t), switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then subscribe to the passed observable when source emits","suites":["timeoutWith operator"],"updatePoint":{"line":51,"column":116},"line":51,"code":"  it('should timeout after a specified period between emit then subscribe to the passed observable when source emits', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  ---a---b------c---|');\n      const t = time('             ----|       ')\n      const sourceSubs = '  ^----------!       ';\n      const switchTo = cold('          -x-y-|  ');\n      const switchToSubs = '-----------^----!  ';\n      const expected = '    ---a---b----x-y-|  ';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timeoutWith operator"],"updatePoint":{"line":68,"column":53},"line":68,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  ---a---b-----c----|');\n      const t = time('             ----|       ')\n      const sourceSubs = '  ^----------!       ';\n      const switchTo = cold('          -x---y| ');\n      const switchToSubs = '-----------^--!    ';\n      const expected = '    ---a---b----x--    ';\n      const unsub = '       --------------!    ';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["timeoutWith operator"],"updatePoint":{"line":86,"column":72},"line":86,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  ---a---b-----c----|');\n      const t = time('      ----|              ');\n      const sourceSubs = '  ^----------!       ';\n      const switchTo = cold('          -x---y| ');\n      const switchToSubs = '-----------^--!    ';\n      const expected = '    ---a---b----x--    ';\n      const unsub = '       --------------!    ';\n\n      const result = source.pipe(\n        mergeMap((x) => of(x)),\n        timeoutWith(t, switchTo, rxTestScheduler),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not subscribe to withObservable after explicit unsubscription","suites":["timeoutWith operator"],"updatePoint":{"line":108,"column":74},"line":108,"code":"  it('should not subscribe to withObservable after explicit unsubscription', () => {\n    rxTestScheduler.run(({ cold, time, expectObservable, expectSubscriptions }) => {\n      const source = cold('---a------b------');\n      const t = time('     -----|           ')\n      const sourceSubs = ' ^----!           ';\n      const switchTo = cold('   i---j---|   ');\n      const expected = '   ---a--           ';\n      const unsub = '      -----!           ';\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        timeoutWith(t, switchTo, rxTestScheduler),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable when source is empty","suites":["timeoutWith operator"],"updatePoint":{"line":129,"column":106},"line":129,"code":"  it('should timeout after a specified period then subscribe to the passed observable when source is empty', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -------------|      ');\n      const t = time('      ----------|         ')\n      const sourceSubs = '  ^---------!         ';\n      const switchTo = cold('         ----x----|');\n      const switchToSubs = '----------^--------!';\n      const expected = '    --------------x----|';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then never completes if other source does not complete","suites":["timeoutWith operator"],"updatePoint":{"line":146,"column":113},"line":146,"code":"  it('should timeout after a specified period between emit then never completes if other source does not complete', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  --a--b--------c--d--|');\n      const t = time('           ----|           ');\n      const sourceSubs = '  ^--------!           ';\n      const switchTo = cold('        ------------');\n      const switchToSubs = '---------^-----------';\n      const expected = '    --a--b---------------';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period then subscribe to the passed observable when source raises error after timeout","suites":["timeoutWith operator"],"updatePoint":{"line":163,"column":124},"line":163,"code":"  it('should timeout after a specified period then subscribe to the passed observable when source raises error after timeout', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -------------#      ');\n      const t = time('      ----------|         ');\n      const sourceSubs = '  ^---------!         ';\n      const switchTo = cold('         ----x----|');\n      const switchToSubs = '----------^--------!';\n      const expected = '    --------------x----|';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should timeout after a specified period between emit then never completes if other source emits but not complete","suites":["timeoutWith operator"],"updatePoint":{"line":180,"column":118},"line":180,"code":"  it('should timeout after a specified period between emit then never completes if other source emits but not complete', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -------------|      ');\n      const t = time('      -----------|        ')\n      const sourceSubs = '  ^----------!        ';\n      const switchTo = cold('          ----x----');\n      const switchToSubs = '-----------^--------';\n      const expected = '    ---------------x----';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe(switchToSubs);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within timeout period","suites":["timeoutWith operator"],"updatePoint":{"line":197,"column":66},"line":197,"code":"  it('should not timeout if source completes within timeout period', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('  -----|        ');\n      const t = time('      ----------|   ');\n      const sourceSubs = '  ^----!        ';\n      const switchTo = cold('    ----x----');\n      const expected = '    -----|        ';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source raises error within timeout period","suites":["timeoutWith operator"],"updatePoint":{"line":213,"column":69},"line":213,"code":"  it('should not timeout if source raises error within timeout period', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('-----#              ');\n      const t = time('    ----------|         ');\n      const sourceSubs = '^----!              ';\n      const switchTo = cold('       ----x----|');\n      const expected = '  -----#              ';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source emits within timeout period","suites":["timeoutWith operator"],"updatePoint":{"line":229,"column":62},"line":229,"code":"  it('should not timeout if source emits within timeout period', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('   --a--b--c--d--e--|');\n      const t = time('       -----|            ');\n      const sourceSubs = '   ^----------------!';\n      const switchTo = cold('----x----|        ');\n      const expected = '     --a--b--c--d--e--|';\n\n      const result = source.pipe(timeoutWith(t, switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source completes within specified Date","suites":["timeoutWith operator"],"updatePoint":{"line":245,"column":66},"line":245,"code":"  it('should not timeout if source completes within specified Date', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--|   ');\n      const t = time('    --------------------|');\n      const sourceSubs = '^----------------!   ';\n      const switchTo = cold('--x--|            ');\n      const expected = '  --a--b--c--d--e--|   ';\n\n      // Start frame is zero.\n      const result = source.pipe(timeoutWith(new Date(t), switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not timeout if source raises error within specified Date","suites":["timeoutWith operator"],"updatePoint":{"line":262,"column":69},"line":262,"code":"  it('should not timeout if source raises error within specified Date', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectObservable, expectSubscriptions }) => {\n      const source = hot('---a---#           ');\n      const t = time('       ----------|     ');\n      const sourceSubs = '^------!           ';\n      const switchTo = cold('          --x--|');\n      const expected = '  ---a---#           ';\n\n      // Start frame is zero.\n      const result = source.pipe(timeoutWith(new Date(t), switchTo, rxTestScheduler));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(switchTo.subscriptions).toBe([]);\n    });\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["timeoutWith operator"],"updatePoint":{"line":279,"column":73},"line":279,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>(subscriber => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(\n      timeoutWith(0, EMPTY),\n      take(3),\n    ).subscribe(() => { /* noop */ });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/timeoutWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should record the time stamp per each source elements","suites":["timestamp"],"updatePoint":{"line":16,"column":59},"line":16,"code":"  it('should record the time stamp per each source elements', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -b-c-----d--e--|');\n      const e1subs = '  ^--------------!';\n      const expected = '-w-x-----y--z--|';\n      const expectedValue = { w: 1, x: 3, y: 9, z: 12 };\n\n      const result = e1.pipe(\n        timestamp(rxTestScheduler),\n        map((x) => x.timestamp)\n      );\n\n      expectObservable(result).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should record stamp if source emit elements","suites":["timestamp"],"updatePoint":{"line":33,"column":49},"line":33,"code":"  it('should record stamp if source emit elements', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--a--^b--c----d---e--|');\n      const e1subs = '     ^---------------!';\n      const expected = '   -w--x----y---z--|';\n\n      const expectedValue = {\n        w: { value: 'b', timestamp: 1 },\n        x: { value: 'c', timestamp: 4 },\n        y: { value: 'd', timestamp: 9 },\n        z: { value: 'e', timestamp: 13 },\n      };\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should completes without record stamp if source does not emits","suites":["timestamp"],"updatePoint":{"line":51,"column":68},"line":51,"code":"  it('should completes without record stamp if source does not emits', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---------|');\n      const e1subs = '  ^--------!';\n      const expected = '---------|';\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete immediately if source is empty","suites":["timestamp"],"updatePoint":{"line":62,"column":52},"line":62,"code":"  it('should complete immediately if source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '|   ';\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should record stamp then does not completes if source emits but not completes","suites":["timestamp"],"updatePoint":{"line":73,"column":83},"line":73,"code":"  it('should record stamp then does not completes if source emits but not completes', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b--');\n      const e1subs = '  ^------';\n      const expected = '-y--z--';\n\n      const expectedValue = {\n        y: { value: 'a', timestamp: 1 },\n        z: { value: 'b', timestamp: 4 },\n      };\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["timestamp"],"updatePoint":{"line":89,"column":53},"line":89,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b-----c---d---|');\n      const unsub = '   -------!           ';\n      const e1subs = '  ^------!           ';\n      const expected = '-y--z---           ';\n\n      const expectedValue = {\n        y: { value: 'a', timestamp: 1 },\n        z: { value: 'b', timestamp: 4 },\n      };\n\n      const result = e1.pipe(timestamp(rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["timestamp"],"updatePoint":{"line":108,"column":83},"line":108,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b-----c---d---|');\n      const e1subs = '  ^------!           ';\n      const expected = '-y--z---           ';\n      const unsub = '   -------!           ';\n\n      const expectedValue = {\n        y: { value: 'a', timestamp: 1 },\n        z: { value: 'b', timestamp: 4 },\n      };\n\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        timestamp(rxTestScheduler),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should not completes if source never completes","suites":["timestamp"],"updatePoint":{"line":131,"column":52},"line":131,"code":"  it('should not completes if source never completes', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"raise error if source raises error","suites":["timestamp"],"updatePoint":{"line":142,"column":40},"line":142,"code":"  it('raise error if source raises error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---#');\n      const e1subs = '  ^--!';\n      const expected = '---#';\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should record stamp then raise error if source raises error after emit","suites":["timestamp"],"updatePoint":{"line":153,"column":76},"line":153,"code":"  it('should record stamp then raise error if source raises error after emit', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  -a--b--#');\n      const e1subs = '  ^------!';\n      const expected = '-y--z--#';\n\n      const expectedValue = {\n        y: { value: 'a', timestamp: 1 },\n        z: { value: 'b', timestamp: 4 },\n      };\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected, expectedValue);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source immediately throws","suites":["timestamp"],"updatePoint":{"line":169,"column":53},"line":169,"code":"  it('should raise error if source immediately throws', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(timestamp(rxTestScheduler))).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["timestamp"],"updatePoint":{"line":180,"column":73},"line":180,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(timestamp(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/timestamp-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce the values of an observable into an array","suites":["toArray"],"updatePoint":{"line":15,"column":61},"line":15,"code":"  it('should reduce the values of an observable into an array', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--|   ');\n      const e1subs = '  ^--------!   ';\n      const expected = '---------(w|)';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected, { w: ['a', 'b'] });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source is never","suites":["toArray"],"updatePoint":{"line":26,"column":42},"line":26,"code":"  it('should be never when source is never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' -');\n      const e1subs = '  ^';\n      const expected = '-';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should be empty when source is empty","suites":["toArray"],"updatePoint":{"line":37,"column":42},"line":37,"code":"  it('should be empty when source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' |   ');\n      const e1subs = '  (^!)';\n      const expected = '(w|)';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected, { w: [] });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should be never when source doesn't complete","suites":["toArray"],"updatePoint":{"line":48,"column":50},"line":48,"code":"  it(\"should be never when source doesn't complete\", () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('--x--^--y--');\n      const e1subs = '     ^-----';\n      const expected = '   ------';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce observable without values into an array of length zero","suites":["toArray"],"updatePoint":{"line":59,"column":74},"line":59,"code":"  it('should reduce observable without values into an array of length zero', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^---|   ');\n      const e1subs = '   ^---!   ';\n      const expected = ' ----(w|)';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected, { w: [] });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should reduce the a single value of an observable into an array","suites":["toArray"],"updatePoint":{"line":70,"column":69},"line":70,"code":"  it('should reduce the a single value of an observable into an array', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--|  ');\n      const e1subs = '   ^-----!  ';\n      const expected = ' ------(w|)';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected, { w: ['y'] });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow multiple subscriptions","suites":["toArray"],"updatePoint":{"line":81,"column":41},"line":81,"code":"  it('should allow multiple subscriptions', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--|   ');\n      const e1subs = '   ^-----!   ';\n      const expected = ' ------(w|)';\n\n      const result = e1.pipe(toArray());\n      expectObservable(result).toBe(expected, { w: ['y'] });\n      expectObservable(result).toBe(expected, { w: ['y'] });\n      expectSubscriptions(e1.subscriptions).toBe([e1subs, e1subs]);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing explicitly and early","suites":["toArray"],"updatePoint":{"line":94,"column":53},"line":94,"code":"  it('should allow unsubscribing explicitly and early', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b----c-----d----e---|');\n      const e1subs = '  ^-------!                 ';\n      const expected = '---------                 ';\n      const unsub = '   --------!                 ';\n\n      expectObservable(e1.pipe(toArray()), unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["toArray"],"updatePoint":{"line":106,"column":83},"line":106,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  --a--b----c-----d----e---|');\n      const e1subs = '  ^-------!                 ';\n      const expected = '---------                 ';\n      const unsub = '   --------!                 ';\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        toArray(),\n        mergeMap((x: Array<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["toArray"],"updatePoint":{"line":124,"column":28},"line":124,"code":"  it('should work with error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('-x-^--y--z--#', { x: 1, y: 2, z: 3 }, 'too bad');\n      const e1subs = '   ^--------!';\n      const expected = ' ---------#';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected, null, 'too bad');\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with throw","suites":["toArray"],"updatePoint":{"line":135,"column":28},"line":135,"code":"  it('should work with throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e1 = cold(' #   ');\n      const e1subs = '  (^!)';\n      const expected = '#   ';\n\n      expectObservable(e1.pipe(toArray())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/toArray-spec.ts","skipped":false,"dir":"spec"},{"name":"should convert an Observable to a promise of its last value","suites":["Observable.toPromise"],"updatePoint":{"line":7,"column":65},"line":7,"code":"  it('should convert an Observable to a promise of its last value', (done) => {\n    of(1, 2, 3)\n      .toPromise(Promise)\n      .then((x) => {\n        expect(x).to.equal(3);\n        done();\n      });\n  });","file":"operators/toPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should convert an empty Observable to a promise of undefined","suites":["Observable.toPromise"],"updatePoint":{"line":16,"column":66},"line":16,"code":"  it('should convert an empty Observable to a promise of undefined', (done) => {\n    EMPTY.toPromise(Promise).then((x) => {\n      expect(x).to.be.undefined;\n      done();\n    });\n  });","file":"operators/toPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors properly","suites":["Observable.toPromise"],"updatePoint":{"line":23,"column":35},"line":23,"code":"  it('should handle errors properly', (done) => {\n    throwError(() => 'bad')\n      .toPromise(Promise)\n      .then(\n        () => {\n          done(new Error('should not be called'));\n        },\n        (err: any) => {\n          expect(err).to.equal('bad');\n          done();\n        }\n      );\n  });","file":"operators/toPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow for global config via config.Promise","suites":["Observable.toPromise"],"updatePoint":{"line":37,"column":55},"line":37,"code":"  it('should allow for global config via config.Promise', async () => {\n    try {\n      let wasCalled = false;\n      config.Promise = function MyPromise(callback: Function) {\n        wasCalled = true;\n        return new Promise(callback as any);\n      } as any;\n\n      const x = await of(42).toPromise();\n      expect(wasCalled).to.be.true;\n      expect(x).to.equal(42);\n    } finally {\n      config.Promise = undefined;\n    }\n  });","file":"operators/toPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows that close and reopen","suites":["window"],"updatePoint":{"line":15,"column":47},"line":15,"code":"  it('should emit windows that close and reopen', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('  ---a---b---c---d---e---f---g---h---i---|    ');\n      const sourceSubs = '  ^--------------------------------------!    ';\n      const closings = hot('-------------w------------w----------------|');\n      const closingSubs = ' ^--------------------------------------!    ';\n      const expected = '    x------------y------------z------------|    ';\n      const x = cold('      ---a---b---c-|                              ');\n      const y = cold('                   --d---e---f--|                 ');\n      const z = cold('                                -g---h---i---|    ');\n      const expectedValues = { x: x, y: y, z: z };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a single empty window if source is empty and closings are basic","suites":["window"],"updatePoint":{"line":35,"column":83},"line":35,"code":"  it('should return a single empty window if source is empty and closings are basic', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |        ');\n      const sourceSubs = '   (^!)     ';\n      const closings = cold('--x--x--|');\n      const closingSubs = '  (^!)     ';\n      const expected = '     (w|)     ';\n      const w = cold('       |        ');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a single empty window if source is empty and closing is empty","suites":["window"],"updatePoint":{"line":53,"column":81},"line":53,"code":"  it('should return a single empty window if source is empty and closing is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  |   ');\n      const sourceSubs = '   (^!)';\n      const closings = cold('|   ');\n      const closingSubs = '  (^!)';\n      const expected = '     (w|)';\n      const w = cold('       |   ');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a single empty window if source is sync empty and closing is sync empty","suites":["window"],"updatePoint":{"line":71,"column":91},"line":71,"code":"  it('should return a single empty window if source is sync empty and closing is sync empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  (|) ');\n      const sourceSubs = '   (^!)';\n      const expected = '     (w|)';\n      const w = cold('       |   ');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(EMPTY));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      // expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should split a Just source into a single window identical to source, using a Never closing","suites":["window"],"updatePoint":{"line":87,"column":96},"line":87,"code":"  it('should split a Just source into a single window identical to source, using a Never closing', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  (a|)');\n      const sourceSubs = '   (^!)';\n      const closings = cold('-   ');\n      const closingSubs = '  (^!)';\n      const expected = '     (w|)';\n      const w = cold('       (a|)');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a single Never window if source is Never","suites":["window"],"updatePoint":{"line":105,"column":60},"line":105,"code":"  it('should return a single Never window if source is Never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  ------');\n      const sourceSubs = '   ^-----';\n      const closings = cold('------');\n      const closingSubs = '  ^-----';\n      const expected = '     w-----';\n      const w = cold('       ------');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to split a never Observable into timely empty windows","suites":["window"],"updatePoint":{"line":123,"column":74},"line":123,"code":"  it('should be able to split a never Observable into timely empty windows', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('   ^--------');\n      const sourceSubs = '   ^--------';\n      const closings = cold('--x--x--|');\n      const closingSubs = '  ^-------!';\n      const expected = '     a-b--c---';\n      const a = cold('       --|      ');\n      const b = cold('         ---|   ');\n      const c = cold('            ----');\n      const expectedValues = { a: a, b: b, c: c };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit an error-only window if outer is a simple throw-Observable","suites":["window"],"updatePoint":{"line":143,"column":76},"line":143,"code":"  it('should emit an error-only window if outer is a simple throw-Observable', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  #        ');\n      const sourceSubs = '   (^!)     ';\n      const closings = cold('--x--x--|');\n      const closingSubs = '  (^!)     ';\n      const expected = '     (w#)     ';\n      const w = cold('       #        ');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle basic case with window closings","suites":["window"],"updatePoint":{"line":161,"column":51},"line":161,"code":"  it('should handle basic case with window closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-|         ');\n      const subs = '           ^--------------!         ';\n      const closings = hot('---^---x---x---x---x---x---|');\n      const closingSubs = '    ^--------------!         ';\n      const expected = '       a---b---c---d--|         ';\n      const a = cold('         -3-4|                    ');\n      const b = cold('             -5-6|                ');\n      const c = cold('                 -7-8|            ');\n      const d = cold('                     -9-|         ');\n      const expectedValues = { a: a, b: b, c: c, d: d };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle basic case with window closings, but outer throws","suites":["window"],"updatePoint":{"line":182,"column":69},"line":182,"code":"  it('should handle basic case with window closings, but outer throws', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-#         ');\n      const subs = '           ^--------------!         ';\n      const closings = hot('---^---x---x---x---x---x---|');\n      const closingSubs = '    ^--------------!         ';\n      const expected = '       a---b---c---d--#         ';\n      const a = cold('         -3-4|                    ');\n      const b = cold('             -5-6|                ');\n      const c = cold('                 -7-8|            ');\n      const d = cold('                     -9-#         ');\n      const expectedValues = { a: a, b: b, c: c, d: d };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop emitting windows when outer is unsubscribed early","suites":["window"],"updatePoint":{"line":203,"column":67},"line":203,"code":"  it('should stop emitting windows when outer is unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-|         ');\n      const subs = '           ^-------!                ';\n      const closings = hot('---^---x---x---x---x---x---|');\n      const closingSubs = '    ^-------!                ';\n      const expected = '       a---b----                ';\n      const a = cold('         -3-4|                    ');\n      const b = cold('             -5-6                 ');\n      const unsub = '          --------!                ';\n      const expectedValues = { a: a, b: b };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["window"],"updatePoint":{"line":223,"column":83},"line":223,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-|         ');\n      const subs = '           ^-------!                ';\n      const closings = hot('---^---x---x---x---x---x---|');\n      const closingSubs = '    ^-------!                ';\n      const expected = '       a---b----                ';\n      const a = cold('         -3-4|                    ');\n      const b = cold('             -5-6-                ');\n      const unsub = '          --------!                ';\n      const expectedValues = { a: a, b: b };\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        window(closings),\n        mergeMap((x: Observable<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should make outer emit error when closing throws","suites":["window"],"updatePoint":{"line":247,"column":54},"line":247,"code":"  it('should make outer emit error when closing throws', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-#');\n      const subs = '           ^---!           ';\n      const closings = hot('---^---#           ');\n      const closingSubs = '    ^---!           ';\n      const expected = '       a---#           ';\n      const a = cold('         -3-4#           ');\n      const expectedValues = { a: a };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete the resulting Observable when window closings completes","suites":["window"],"updatePoint":{"line":265,"column":77},"line":265,"code":"  it('should complete the resulting Observable when window closings completes', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('-1-2-^3-4-5-6-7-8-9-|');\n      const subs = '           ^--------------!';\n      const closings = hot('---^---x---x---|   ');\n      const closingSubs = '    ^-----------!   ';\n      const expected = '       a---b---c------|';\n      const a = cold('         -3-4|           ');\n      const b = cold('             -5-6|       ');\n      const c = cold('                 -7-8-9-|');\n      const expectedValues = { a: a, b: b, c: c };\n\n      const result = source.pipe(window(closings));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n      expectSubscriptions(closings.subscriptions).toBe(closingSubs);\n    });\n  });","file":"operators/window-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows with count 3, no skip specified","suites":["windowCount"],"updatePoint":{"line":16,"column":57},"line":16,"code":"  it('should emit windows with count 3, no skip specified', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('---a---b---c---d---e---f---g---h---i---|');\n      const sourceSubs = '^--------------------------------------!';\n      const expected = '  x----------y-----------z-----------w---|';\n      const x = cold('    ---a---b---(c|)                         ');\n      const y = cold('               ----d---e---(f|)             ');\n      const z = cold('                           ----g---h---(i|) ');\n      const w = cold('                                       ----|');\n      const expectedValues = { x: x, y: y, z: z, w: w };\n\n      const result = source.pipe(windowCount(3));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(sourceSubs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows with count 2 and skip 1","suites":["windowCount"],"updatePoint":{"line":34,"column":49},"line":34,"code":"  it('should emit windows with count 2 and skip 1', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('^-a--b--c--d--|');\n      const subs = '      ^-------------!';\n      const expected = '  u-v--x--y--z--|';\n      const u = cold('    --a--(b|)      ');\n      const v = cold('      ---b--(c|)   ');\n      const x = cold('         ---c--(d|)');\n      const y = cold('            ---d--|');\n      const z = cold('               ---|');\n      const values = { u: u, v: v, x: x, y: y, z: z };\n\n      const result = source.pipe(windowCount(2, 1));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows with count 2, and skip unspecified","suites":["windowCount"],"updatePoint":{"line":53,"column":60},"line":53,"code":"  it('should emit windows with count 2, and skip unspecified', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--f--|');\n      const subs = '      ^-------------------!';\n      const expected = '  x----y-----z-----w--|';\n      const x = cold('    --a--(b|)            ');\n      const y = cold('         ---c--(d|)      ');\n      const z = cold('               ---e--(f|)');\n      const w = cold('                     ---|');\n      const values = { x: x, y: y, z: z, w: w };\n\n      const result = source.pipe(windowCount(2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should return empty if source is empty","suites":["windowCount"],"updatePoint":{"line":71,"column":44},"line":71,"code":"  it('should return empty if source is empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('|');\n      const subs = '       (^!)';\n      const expected = '   (w|)';\n      const w = cold('     |');\n      const values = { w: w };\n\n      const result = source.pipe(windowCount(2, 1));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should return Never if source if Never","suites":["windowCount"],"updatePoint":{"line":86,"column":44},"line":86,"code":"  it('should return Never if source if Never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('-');\n      const subs = '       ^';\n      const expected = '   w';\n      const w = cold('     -');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(windowCount(2, 1));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error from a just-throw source","suites":["windowCount"],"updatePoint":{"line":101,"column":53},"line":101,"code":"  it('should propagate error from a just-throw source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const source = cold('  #');\n      const subs = '         (^!)';\n      const expected = '     (w#)';\n      const w = cold('       #');\n      const expectedValues = { w: w };\n\n      const result = source.pipe(windowCount(2, 1));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if source raises error","suites":["windowCount"],"updatePoint":{"line":116,"column":47},"line":116,"code":"  it('should raise error if source raises error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--a--b--c--d--e--f--#');\n      const subs = '      ^-------------------!';\n      const expected = '  u-v--w--x--y--z--q--#';\n      const u = cold('    --a--b--(c|)         ');\n      const v = cold('      ---b--c--(d|)      ');\n      const w = cold('         ---c--d--(e|)   ');\n      const x = cold('            ---d--e--(f|)');\n      const y = cold('               ---e--f--#');\n      const z = cold('                  ---f--#');\n      const q = cold('                     ---#');\n      const values = { u: u, v: v, w: w, x: x, y: y, z: z, q: q };\n\n      const result = source.pipe(windowCount(3, 1));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose of inner windows once outer is unsubscribed early","suites":["windowCount"],"updatePoint":{"line":137,"column":70},"line":137,"code":"  it('should dispose of inner windows once outer is unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('^-a--b--c--d--|');\n      const subs = '      ^--------!     ';\n      const expected = '  w-x--y--z-     ';\n      const w = cold('    --a--(b|)      ');\n      const x = cold('      ---b--(c|)   ');\n      const y = cold('         ---c-     ');\n      const z = cold('            --     ');\n      const unsub = '     ---------!     ';\n      const values = { w: w, x: x, y: y, z: z };\n\n      const result = source.pipe(windowCount(2, 1));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["windowCount"],"updatePoint":{"line":156,"column":83},"line":156,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('^-a--b--c--d--|');\n      const subs = '      ^--------!     ';\n      const expected = '  w-x--y--z-     ';\n      const w = cold('    --a--(b|)      ');\n      const x = cold('      ---b--(c|)   ');\n      const y = cold('         ---c-     ');\n      const z = cold('            --     ');\n      const unsub = '     ---------!     ';\n      const values = { w: w, x: x, y: y, z: z };\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        windowCount(2, 1),\n        mergeMap((x: Observable<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should stop listening to a synchronous observable when unsubscribed","suites":["windowCount"],"updatePoint":{"line":179,"column":73},"line":179,"code":"  it('should stop listening to a synchronous observable when unsubscribed', () => {\n    const sideEffects: number[] = [];\n    const synchronousObservable = new Observable<number>((subscriber) => {\n      // This will check to see if the subscriber was closed on each loop\n      // when the unsubscribe hits (from the `take`), it should be closed\n      for (let i = 0; !subscriber.closed && i < 10; i++) {\n        sideEffects.push(i);\n        subscriber.next(i);\n      }\n    });\n\n    synchronousObservable.pipe(windowCount(3), mergeAll(), take(3)).subscribe(() => {\n      /* noop */\n    });\n\n    expect(sideEffects).to.deep.equal([0, 1, 2]);\n  });","file":"operators/windowCount-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows given windowTimeSpan and windowCreationInterval","suites":["windowTime"],"updatePoint":{"line":15,"column":73},"line":15,"code":"  it('should emit windows given windowTimeSpan and windowCreationInterval', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--1--2--^-a--b--c--d--e---f--g--h-|');\n      const subs = '              ^-------------------------!';\n      //  10 frames               0---------1---------2-----|\n      //  5                       -----|\n      //  5                                 -----|\n      //  5                                           -----|\n      const expected = '          x---------y---------z-----|';\n      const x = cold('            --a--(b|)                  ');\n      const y = cold('                      -d--e|           ');\n      const z = cold('                                -g--h| ');\n      const values = { x, y, z };\n\n      const result = source.pipe(windowTime(5, 10, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should close windows after max count is reached","suites":["windowTime"],"updatePoint":{"line":39,"column":53},"line":39,"code":"  it('should close windows after max count is reached', () => {\n    rxTestScheduler.run(({ hot, time, cold, expectObservable, expectSubscriptions }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g-----|');\n      const subs = '              ^--------------------------!';\n      const timeSpan = time('     ----------|                 ');\n      //                                 ----------|\n      //                                       ----------|\n      //                                             ---------\n      const expected = '          w-----x-----y-----z--------|';\n      const w = cold('            ---a--(b|)                  ');\n      const x = cold('                  ---c--(d|)            ');\n      const y = cold('                        ---e--(f|)      ');\n      const z = cold('                              ---g-----|');\n      const values = { w, x, y, z };\n\n      const result = source.pipe(windowTime(timeSpan, null, 2, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should close window after max count is reached with windowCreationInterval","suites":["windowTime"],"updatePoint":{"line":61,"column":80},"line":61,"code":"  it('should close window after max count is reached with windowCreationInterval', () => {\n    rxTestScheduler.run(({ hot, cold, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^-a--b--c--de-f---g--h--i-|');\n      const subs = '              ^-------------------------!';\n      //  10 frames               0---------1---------2-----|\n      //  5                       -----|\n      //  5                                 -----|\n      //  5                                           -----|\n      const expected = '          x---------y---------z-----|';\n      const x = cold('            --a--(b|)                  ');\n      const y = cold('                      -de-(f|)         ');\n      const z = cold('                                -h--i| ');\n      const values = { x, y, z };\n\n      const result = source.pipe(windowTime(5, 10, 3, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows given windowTimeSpan","suites":["windowTime"],"updatePoint":{"line":82,"column":46},"line":82,"code":"  it('should emit windows given windowTimeSpan', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g--h--|');\n      const subs = '              ^--------------------------!';\n      const timeSpan = time('     ----------|                 ');\n      //  10 frames               0---------1---------2------|\n      //                                    ----------|\n      //                                              ----------|\n      const expected = '          x---------y---------z------|';\n      const x = cold('            ---a--b--c|                 ');\n      const y = cold('                      --d--e--f-|       ');\n      const z = cold('                                -g--h--|');\n      const values = { x, y, z };\n\n      const result = source.pipe(windowTime(timeSpan, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows given windowTimeSpan and windowCreationInterval","suites":["windowTime"],"updatePoint":{"line":103,"column":73},"line":103,"code":"  it('should emit windows given windowTimeSpan and windowCreationInterval', () => {\n    rxTestScheduler.run(({ hot, time, cold, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g--h--|');\n      const subs = '              ^--------------------------!';\n      //  10 frames               0---------1---------2------|\n      const interval = time('     ----------|                 ');\n      //  10                                ----------|\n      //  10                                          ----------|\n      const timeSpan = time('     -----|                      ');\n      //  5                                 ----|\n      //  5                                           ----|\n      const expected = '          x---------y---------z------|';\n      const x = cold('            ---a-|                      ');\n      const y = cold('                      --d--(e|)         ');\n      const z = cold('                                -g--h|  ');\n      const values = { x, y, z };\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should return a single empty window if source is empty","suites":["windowTime"],"updatePoint":{"line":127,"column":60},"line":127,"code":"  it('should return a single empty window if source is empty', () => {\n    rxTestScheduler.run(({ cold, time, expectSubscriptions, expectObservable }) => {\n      const source = cold('|');\n      const subs = '       (^!)';\n      const expected = '   (w|)';\n      const w = cold('     |');\n      const expectedValues = { w };\n      const timeSpan = time('-----|');\n      const interval = time('----------|');\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should split a Just source into a single window identical to source","suites":["windowTime"],"updatePoint":{"line":144,"column":73},"line":144,"code":"  it('should split a Just source into a single window identical to source', () => {\n    rxTestScheduler.run(({ cold, time, expectSubscriptions, expectObservable }) => {\n      const source = cold('(a|)');\n      const subs = '       (^!)';\n      const expected = '   (w|)';\n      const w = cold('     (a|)');\n      const expectedValues = { w };\n      const timeSpan = time('-----|');\n      const interval = time('----------|');\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should be able to split a never Observable into timely empty windows","suites":["windowTime"],"updatePoint":{"line":161,"column":74},"line":161,"code":"  it('should be able to split a never Observable into timely empty windows', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectSubscriptions, expectObservable }) => {\n      const source = hot('   ^----------');\n      const subs = '         ^---------!';\n      const timeSpan = time('---|');\n      const interval = time('---|');\n      //                        ---|\n      //                           ---|\n      //                              ---|\n      const expected = '     a--b--c--d-';\n      const a = cold('       ---|       ');\n      const b = cold('          ---|    ');\n      const c = cold('             ---| ');\n      const d = cold('                --');\n      const unsub = '        ----------!';\n      const expectedValues = { a, b, c, d };\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit an error-only window if outer is a simple throw-Observable","suites":["windowTime"],"updatePoint":{"line":185,"column":76},"line":185,"code":"  it('should emit an error-only window if outer is a simple throw-Observable', () => {\n    rxTestScheduler.run(({ cold, time, expectSubscriptions, expectObservable }) => {\n      const source = cold('#   ');\n      const subs = '       (^!)';\n      const expected = '   (w#)';\n      const w = cold('     #   ');\n      const expectedValues = { w };\n      const timeSpan = time('-----|');\n      const interval = time('----------|');\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, expectedValues);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle source Observable which eventually emits an error","suites":["windowTime"],"updatePoint":{"line":202,"column":69},"line":202,"code":"  it('should handle source Observable which eventually emits an error', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g--h--#');\n      const subs = '              ^--------------------------!';\n      const timeSpan = time('     -----|                      ');\n      const interval = time('     ----------|                 ');\n      //  10 frames               0---------1---------2------|\n      //  5                       ----|\n      //  5                                 ----|\n      //  5                                           ----|\n      const expected = '          x---------y---------z------#';\n      const x = cold('            ---a-|                      ');\n      const y = cold('                      --d--(e|)         ');\n      const z = cold('                                -g--h|  ');\n      const values = { x, y, z };\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows given windowTimeSpan and windowCreationInterval, but outer is unsubscribed early","suites":["windowTime"],"updatePoint":{"line":225,"column":106},"line":225,"code":"  it('should emit windows given windowTimeSpan and windowCreationInterval, but outer is unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g--h--|');\n      const subs = '              ^----------!                ';\n      const timeSpan = time('     -----|                      ');\n      const interval = time('     ----------|                 ');\n      //  10 frames               0---------1---------2------|\n      //  5                       ----|\n      //  5                                 ----|\n      //  5                                           ----|\n      const expected = '          x---------y-                ';\n      const x = cold('            ---a-|                      ');\n      const y = cold('                      --                ');\n      const unsub = '             -----------!                ';\n      const values = { x, y };\n\n      const result = source.pipe(windowTime(timeSpan, interval, rxTestScheduler));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(subs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["windowTime"],"updatePoint":{"line":248,"column":83},"line":248,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, time, expectSubscriptions, expectObservable }) => {\n      const source = hot('--1--2--^--a--b--c--d--e--f--g--h--|');\n      const sourcesubs = '        ^-------------!             ';\n      const timeSpan = time('     -----|                      ');\n      const interval = time('     ----------|                 ');\n      //  10 frames               0---------1---------2------|\n      //  5                       ----|\n      //  5                                 ----|\n      //  5                                           ----|\n      const expected = '          x---------y----             ';\n      const x = cold('            ---a-|                      ');\n      const y = cold('                      --d--             ');\n      const unsub = '             --------------!             ';\n      const values = { x, y };\n\n      const result = source.pipe(\n        mergeMap((x: string) => of(x)),\n        windowTime(timeSpan, interval, rxTestScheduler),\n        mergeMap((x: Observable<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(source.subscriptions).toBe(sourcesubs);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should not error if maxWindowSize is hit while nexting to other windows.","suites":["windowTime"],"updatePoint":{"line":275,"column":78},"line":275,"code":"  it('should not error if maxWindowSize is hit while nexting to other windows.', () => {\n    rxTestScheduler.run(({ cold, time, expectObservable }) => {\n      const source = cold('                ----a---b---c---d---e---f---g---h---i---j---');\n      const windowTimeSpan = time('        ------------|                               ');\n      const windowCreationInterval = time('--------|                                   ');\n      const maxWindowSize = 4;\n      const a = cold('                     ----a---b---|                               ');\n      //                                   ------------|\n      const b = cold('                             b---c---d---(e|)');\n      const c = cold('                                     ----e---f---(g|)');\n      const d = cold('                                             ----g---h---(i|)    ');\n      const e = cold('                                                     ----i---j---');\n      const f = cold('                                                             ----');\n      const expected = '                   a-------b-------c-------d-------e-------f---';\n      const killSub = '                    ------------------------------------------! ';\n      const values = { a, b, c, d, e, f };\n      const result = source.pipe(windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, rxTestScheduler));\n      expectObservable(result, killSub).toBe(expected, values);\n    });\n  });","file":"operators/windowTime-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows governed by openings and closings","suites":["windowToggle"],"updatePoint":{"line":16,"column":59},"line":16,"code":"  it('should emit windows governed by openings and closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('         ----w--------w--------w--|');\n      const e2subs = '          ^------------------------!';\n      const e3 = cold('             -----x                ');\n      //                                     -----x\n      //                                              -----x\n      const e3subs = [\n        '                       ----^----!                ',\n        '                       -------------^----!       ',\n        '                       ----------------------^--!',\n      ];\n      const e1 = hot('  --1--2--^-a--b--c--d--e--f--g--h-|');\n      const e1subs = '          ^------------------------!';\n      const expected = '        ----x--------y--------z--|';\n      const x = cold('              -b--c|                ');\n      const y = cold('                       -e--f|       ');\n      const z = cold('                                -h-|');\n      const values = { x, y, z };\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows that are opened by an observable from the first argument and closed by an observable returned by the function in the second argument","suites":["windowToggle"],"updatePoint":{"line":45,"column":158},"line":45,"code":"  it('should emit windows that are opened by an observable from the first argument and closed by an observable returned by the function in the second argument', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('       --------x-------x-------x--|');\n      const e2subs = '        ^--------------------------!';\n      const e3 = cold('               ----------(x|)      ');\n      //                                      ----------(x|)\n      //                                              ----------(x|)\n      const e3subs = [\n        '                     --------^---------!         ',\n        '                     ----------------^---------! ',\n        '                     ------------------------^--!',\n      ];\n\n      const e1 = hot('--1--2--^--a--b--c--d--e--f--g--h--|');\n      const e1subs = '        ^--------------------------!';\n      const expected = '      --------x-------y-------z--|';\n      const x = cold('                -c--d--e--(f|)      ');\n      const y = cold('                        --f--g--h-| ');\n      const z = cold('                                ---|');\n      const values = { x, y, z };\n\n      const source = e1.pipe(\n        windowToggle(e2, (value: string) => {\n          expect(value).to.equal('x');\n          return e3;\n        })\n      );\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying cold closings","suites":["windowToggle"],"updatePoint":{"line":80,"column":53},"line":80,"code":"  it('should emit windows using varying cold closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|            ');\n      const e2subs = '     ^--------------------------!            ';\n      const close = [\n        cold('               ---------------s--|                   '),\n        cold('                           ----(s|)                  '),\n        cold('                                  ---------------(s|)'),\n      ];\n      const closeSubs = [\n        '                  --^--------------!                      ',\n        '                  --------------^---!                     ',\n        '                  -----------------------^-----------!    ',\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|    ');\n      const e1subs = '     ^----------------------------------!    ';\n      const expected = '   --x-----------y--------z-----------|    ';\n      const x = cold('       --b---c---d---e|                      ');\n      const y = cold('                   --e-|                     ');\n      const z = cold('                            -g---h------|    ');\n      const values = { x, y, z };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(close[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying hot closings","suites":["windowToggle"],"updatePoint":{"line":115,"column":52},"line":115,"code":"  it('should emit windows using varying hot closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|           ');\n      const e2subs = '     ^--------------------------!           ';\n      const closings = [\n        hot('          -1--^----------------s-|                   '),\n        hot('              -----3----4-------(s|)                 '),\n        hot('              -------3----4-------5----------------s|'),\n      ];\n      const closingSubs = [\n        '                  --^--------------!                     ',\n        '                  --------------^---!                    ',\n        '                  -----------------------^-----------!   ',\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|   ');\n      const e1subs = '     ^----------------------------------!   ';\n      const expected = '   --x-----------y--------z-----------|   ';\n      const x = cold('       --b---c---d---e|                     ');\n      const y = cold('                   --e-|                    ');\n      const z = cold('                            -g---h------|   ');\n      const values = { x, y, z };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closingSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closingSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closingSubs[2]);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying empty delayed closings","suites":["windowToggle"],"updatePoint":{"line":150,"column":62},"line":150,"code":"  it('should emit windows using varying empty delayed closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|           ');\n      const e2subs = '     ^--------------------------!           ';\n      const close = [\n        cold('               ---------------|                     '),\n        cold('                           ----|                    '),\n        cold('                                    ---------------|'),\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|   ');\n      const e1subs = '     ^----------------------------------!   ';\n      const expected = '   --x-----------y--------z-----------|   ';\n      const x = cold('       --b---c---d---e---f---g---h------|   ');\n      const y = cold('                   --e---f---g---h------|   ');\n      const z = cold('                            -g---h------|   ');\n      const values = { x, y, z };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying cold closings, outer unsubscribed early","suites":["windowToggle"],"updatePoint":{"line":177,"column":79},"line":177,"code":"  it('should emit windows using varying cold closings, outer unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const e2subs = '     ^----------------!                        ';\n      const close = [\n        cold('               -------------s---|                      '),\n        cold('                           -----(s|)                   '),\n        cold('                                    ---------------(s|)'),\n      ];\n      const closeSubs = [\n        '                  --^------------!                          ',\n        '                  --------------^--!                        ',\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const e1subs = '     ^----------------!                        ';\n      const expected = '   --x-----------y---                        ';\n      const x = cold('       --b---c---d--|                          ');\n      const y = cold('                   --e-                        ');\n      const unsub = '      -----------------!                        ';\n      const values = { x, y };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(close[2].subscriptions).toBe([]);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["windowToggle"],"updatePoint":{"line":211,"column":83},"line":211,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const e2subs = '     ^--------------!                          ';\n      const close = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)'),\n      ];\n      const closeSubs = [\n        '                  --^------------!                          ',\n        '                  --------------^!                          ',\n      ];\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const e1subs = '     ^--------------!                          ';\n      const expected = '   --x-----------y-                          ';\n      const x = cold('       --b---c---d---                          ');\n      const y = cold('                   --                          ');\n      const unsub = '      ---------------!                          ';\n      const values = { x, y };\n\n      let i = 0;\n      const result = e1.pipe(\n        mergeMap((x) => of(x)),\n        windowToggle(e2, () => close[i++]),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(close[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(close[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should dispose window Subjects if the outer is unsubscribed early","suites":["windowToggle"],"updatePoint":{"line":247,"column":71},"line":247,"code":"  it('should dispose window Subjects if the outer is unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions, time }) => {\n      const open = cold(' o-------------------------|');\n      const e1 = hot('    --a--b--c--d--e--f--g--h--|');\n      const e1subs = '    ^--------!                 ';\n      const expected = '  x---------                 ';\n      const x = cold('    --a--b--c-                 ');\n      const unsub = '     ---------!                 ';\n      const late = time(' ---------------|           ');\n      const values = { x };\n\n      let window: Observable<string>;\n      const result = e1.pipe(\n        windowToggle(open, () => NEVER),\n        tap((w) => {\n          window = w;\n        })\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      rxTestScheduler.schedule(() => {\n        expect(() => {\n          window.subscribe();\n        }).to.throw(ObjectUnsubscribedError);\n      }, late);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from closingSelector","suites":["windowToggle"],"updatePoint":{"line":276,"column":56},"line":276,"code":"  it('should propagate error thrown from closingSelector', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|              ');\n      const e2subs = '     ^-------------!                           ';\n      const close = [\n        cold('               ---------------s--|                     '),\n        cold('                           ----(s|)                    '),\n        cold('                                    ---------------(s|)'),\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|      ');\n      const e1subs = '     ^-------------!                           ';\n      const expected = '   --x-----------#----                       ';\n      const x = cold('       --b---c---d-#                           ');\n      const values = { x: x };\n\n      let i = 0;\n      const result = e1.pipe(\n        windowToggle(e2, () => {\n          if (i === 1) {\n            throw 'error';\n          }\n          return close[i++];\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted from a closing","suites":["windowToggle"],"updatePoint":{"line":308,"column":51},"line":308,"code":"  it('should propagate error emitted from a closing', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|        ');\n      const e2subs = '     ^-------------!                     ';\n      // prettier-ignore\n      const close = [\n        cold('               ---------------s--|               '),\n        cold('                           #                     ')\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     ^-------------!                     ';\n      const expected = '   --x-----------(y#)                  ';\n      const x = cold('       --b---c---d-#                     ');\n      const y = cold('                   #                     ');\n      const values = { x, y };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted late from a closing","suites":["windowToggle"],"updatePoint":{"line":334,"column":56},"line":334,"code":"  it('should propagate error emitted late from a closing', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|        ');\n      const e2subs = '     ^------------------!                ';\n      // prettier-ignore\n      const close = [\n        cold('               ---------------s--|               '),\n        cold('                           -----#                ')\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     ^------------------!                ';\n      const expected = '   --x-----------y----#                ';\n      const x = cold('       --b---c---d---e|                  ');\n      const y = cold('                   --e--#                ');\n      const values = { x, y };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle errors","suites":["windowToggle"],"updatePoint":{"line":360,"column":26},"line":360,"code":"  it('should handle errors', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    --x-----------y--------z---|        ');\n      const e2subs = '     ^------------------!                ';\n      // prettier-ignore\n      const close = [\n        cold('               ---------------s--|               '),\n        cold('                           -------s|             ')\n      ];\n\n      const e1 = hot('--a--^---b---c---d---e--#                ');\n      const e1subs = '     ^------------------!                ';\n      const expected = '   --x-----------y----#                ';\n      const x = cold('       --b---c---d---e|                  ');\n      const y = cold('                   --e--#                ');\n      const values = { x, y };\n\n      let i = 0;\n      const result = e1.pipe(windowToggle(e2, () => close[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty source","suites":["windowToggle"],"updatePoint":{"line":386,"column":32},"line":386,"code":"  it('should handle empty source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('--o-----|');\n      const e2subs = '   (^!)';\n      const e3 = cold('  -----c--|');\n\n      const e1 = cold('  |');\n      const e1subs = '   (^!)';\n      const expected = ' |';\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["windowToggle"],"updatePoint":{"line":404,"column":25},"line":404,"code":"  it('should handle throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' --o-----|');\n      const e2subs = '  (^!)';\n      const e3 = cold(' -----c--|');\n\n      const e1 = cold(' #');\n      const e1subs = '  (^!)';\n      const expected = '#';\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["windowToggle"],"updatePoint":{"line":422,"column":25},"line":422,"code":"  it('should handle never', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' --o-----o------o-----o---o-----|             ');\n      const e2subs = '  ^------------------------------!             ';\n      const e3 = cold('   --c-|                                      ');\n\n      const e1 = hot('  -                                            ');\n      const e1subs = '  ^-------------------------------------------!';\n      const expected = '--u-----v------x-----y---z-------------------';\n      const u = cold('    --|                                        ');\n      const v = cold('          --|                                  ');\n      const x = cold('                 --|                           ');\n      const y = cold('                       --|                     ');\n      const z = cold('                           --|                 ');\n      const unsub = '   --------------------------------------------!';\n      const values = { u: u, v: v, x, y, z };\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never opening Observable","suites":["windowToggle"],"updatePoint":{"line":447,"column":46},"line":447,"code":"  it('should handle a never opening Observable', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    -                                   ');\n      const e2subs = '     ^----------------------------------!';\n      const e3 = cold('    --c-|                               ');\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     ^----------------------------------!';\n      const expected = '   -----------------------------------|';\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never closing Observable","suites":["windowToggle"],"updatePoint":{"line":465,"column":46},"line":465,"code":"  it('should handle a never closing Observable', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    ---o---------------o-----------|    ');\n      const e2subs = '     ^------------------------------!    ';\n      const e3 = cold('       -                                ');\n      //                                      -\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     ^----------------------------------!';\n      const expected = '   ---x---------------y---------------|';\n      const x = cold('        -b---c---d---e---f---g---h------|');\n      const y = cold('                        -f---g---h------|');\n      const values = { x, y };\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle opening Observable that just throws","suites":["windowToggle"],"updatePoint":{"line":487,"column":55},"line":487,"code":"  it('should handle opening Observable that just throws', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    #                                   ');\n      const e2subs = '     (^!)                                ';\n      const e3 = cold('    --c-|                               ');\n      const subs = '       (^!)                                ';\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     (^!)                                ';\n      const expected = '   #                                   ';\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty closing observable","suites":["windowToggle"],"updatePoint":{"line":507,"column":44},"line":507,"code":"  it('should handle empty closing observable', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('    ---o---------------o-----------|    ');\n      const e2subs = '     ^------------------------------!    ';\n      const e3 = EMPTY;\n\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '     ^----------------------------------!';\n      const expected = '   ---x---------------y---------------|';\n      const x = cold('        -b---c---d---e---f---g---h------|');\n      const y = cold('                        -f---g---h------|');\n      const values = { x, y };\n\n      const result = e1.pipe(windowToggle(e2, () => e3));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowToggle-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows that close and reopen","suites":["windowWhen"],"updatePoint":{"line":15,"column":47},"line":15,"code":"  it('should emit windows that close and reopen', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('       -----------|                ');\n      //                                 -----------|\n      //                                            -----------|\n      const e2subs = [\n        '                     ^----------!                ',\n        '                     -----------^----------!     ',\n        '                     ----------------------^----!',\n      ];\n      const e1 = hot('   --a--^--b--c--d--e--f--g--h--i--|');\n      const e1subs = '        ^--------------------------!';\n      const expected = '      a----------b----------c----|';\n\n      const a = cold('        ---b--c--d-|                ');\n      const b = cold('                   -e--f--g--h|     ');\n      const c = cold('                              --i--|');\n      const values = { a: a, b: b, c: c };\n\n      const source = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(source).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying cold closings","suites":["windowWhen"],"updatePoint":{"line":42,"column":53},"line":42,"code":"  it('should emit windows using varying cold closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('               -----------------s--|                    '),\n        cold('                                -----(s|)               '),\n        cold('                                     ---------------(s|)'),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                       ',\n        '                    -----------------^----!                  ',\n        '                    ----------------------^------------!     ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|     ');\n      const e1subs = '       ^----------------------------------!     ';\n      const expected = '     x----------------y----z------------|     ';\n\n      const x = cold('       ----b---c---d---e|                       ');\n      const y = cold('                        ---f-|                  ');\n      const z = cold('                             --g---h------|     ');\n      const values = { x: x, y: y, z: z };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying hot closings","suites":["windowWhen"],"updatePoint":{"line":74,"column":52},"line":74,"code":"  it('should emit windows using varying hot closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        hot('            -1--^----------------s-|                   '),\n        hot('                -----3----4-----------(s|)             '),\n        hot('                -------3----4-------5----------------s|'),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                     ',\n        '                    -----------------^----!                ',\n        '                    ----------------------^------------!   ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|   ');\n      const subs = '         ^----------------------------------!   ';\n      const expected = '     x----------------y----z------------|   ';\n\n      const x = cold('       ----b---c---d---e|                     ');\n      const y = cold('                        ---f-|                ');\n      const z = cold('                             --g---h------|   ');\n      const values = { x: x, y: y, z: z };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying empty delayed closings","suites":["windowWhen"],"updatePoint":{"line":106,"column":62},"line":106,"code":"  it('should emit windows using varying empty delayed closings', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('             -----------------|                    '),\n        cold('                              -----|               '),\n        cold('                                   ---------------|'),\n      ];\n      const closeSubs = [\n        '                  ^----------------!                    ',\n        '                  -----------------^----!               ',\n        '                  ----------------------^------------!  ',\n      ];\n      const e1 = hot('--a--^---b---c---d---e---f---g---h------|  ');\n      const e1subs = '     ^----------------------------------!  ';\n      const expected = '   x----------------y----z------------|  ';\n\n      const x = cold('     ----b---c---d---e|                    ');\n      const y = cold('                      ---f-|               ');\n      const z = cold('                           --g---h------|  ');\n      const values = { x: x, y: y, z: z };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n      expectSubscriptions(closings[2].subscriptions).toBe(closeSubs[2]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit windows using varying cold closings, outer unsubscribed early","suites":["windowWhen"],"updatePoint":{"line":138,"column":79},"line":138,"code":"  it('should emit windows using varying cold closings, outer unsubscribed early', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('               -----------------s--|               '),\n        cold('                                ---------(s|)      '),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                  ',\n        '                    -----------------^---!              ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       ^--------------------!              ';\n      const expected = '     x----------------y----              ';\n      const unsub = '        ---------------------!              ';\n\n      const x = cold('       ----b---c---d---e|                  ');\n      const y = cold('                        ---f-              ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["windowWhen"],"updatePoint":{"line":167,"column":72},"line":167,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('               -----------------s--|               '),\n        cold('                                ---------(s|)      '),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                  ',\n        '                    -----------------^---!              ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       ^--------------------!              ';\n      const expected = '     x----------------y----              ';\n      const unsub = '        ---------------------!              ';\n\n      const x = cold('       ----b---c---d---e|                  ');\n      const y = cold('                        ---f-              ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        windowWhen(() => closings[i++]),\n        mergeMap((x: Observable<string>) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error thrown from closingSelector","suites":["windowWhen"],"updatePoint":{"line":200,"column":56},"line":200,"code":"  it('should propagate error thrown from closingSelector', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('                 -----------------s--|                    '),\n        cold('                                  -----(s|)               '),\n        cold('                                       ---------------(s|)'),\n      ];\n      const closeSubs = ['     ^----------------!                       '];\n      const e1 = hot('    --a--^---b---c---d---e---f---g---h------|     ');\n      const e1subs = '         ^----------------!                       ';\n      const expected = '       x----------------(y#)                    ';\n\n      const x = cold('         ----b---c---d---e|                       ');\n      const y = cold('                          #                       ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(\n        windowWhen(() => {\n          if (i === 1) {\n            throw 'error';\n          }\n          return closings[i++];\n        })\n      );\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted from a closing","suites":["windowWhen"],"updatePoint":{"line":232,"column":51},"line":232,"code":"  it('should propagate error emitted from a closing', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('               -----------------s--|               '),\n        cold('                                #                  '),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                  ',\n        '                    -----------------(^!)               ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       ^----------------!                  ';\n      const expected = '     x----------------(y#)               ';\n\n      const x = cold('       ----b---c---d---e|                  ');\n      const y = cold('                        #                  ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate error emitted late from a closing","suites":["windowWhen"],"updatePoint":{"line":260,"column":56},"line":260,"code":"  it('should propagate error emitted late from a closing', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const closings = [\n        cold('               -----------------s--|               '),\n        cold('                                -----#             '),\n      ];\n      const closeSubs = [\n        '                    ^----------------!                  ',\n        '                    -----------------^----!             ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       ^---------------------!             ';\n      const expected = '     x----------------y----#             ';\n\n      const x = cold('       ----b---c---d---e|                  ');\n      const y = cold('                        ---f-#             ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should propagate errors emitted from the source","suites":["windowWhen"],"updatePoint":{"line":288,"column":53},"line":288,"code":"  it('should propagate errors emitted from the source', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      // prettier-ignore\n      const closings = [\n        cold('               -----------------s--|       '),\n        cold('                                -------(s|)'),\n      ];\n      // prettier-ignore\n      const closeSubs = [\n        '                    ^----------------!          ',\n        '                    -----------------^----!     ',\n      ];\n      const e1 = hot('  --a--^---b---c---d---e---f-#     ');\n      const e1subs = '       ^---------------------!     ';\n      const expected = '     x----------------y----#     ';\n\n      const x = cold('       ----b---c---d---e|          ');\n      const y = cold('                        ---f-#     ');\n      const values = { x: x, y: y };\n\n      let i = 0;\n      const result = e1.pipe(windowWhen(() => closings[i++]));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(closings[0].subscriptions).toBe(closeSubs[0]);\n      expectSubscriptions(closings[1].subscriptions).toBe(closeSubs[1]);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty source","suites":["windowWhen"],"updatePoint":{"line":318,"column":32},"line":318,"code":"  it('should handle empty source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' -----c--|');\n      const e2subs = '  (^!)     ';\n      const e1 = cold(' |        ');\n      const e1subs = '  (^!)     ';\n      const expected = '(w|)     ';\n      const win = cold('|        ');\n      const values = { w: win };\n\n      const result = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never source","suites":["windowWhen"],"updatePoint":{"line":336,"column":34},"line":336,"code":"  it('should handle a never source', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' -----c--|         ');\n      //                     -----c--|\n      //                        -----c--|\n      //                             -----\n      const e2subs = [\n        '               ^----!            ',\n        '               -----^----!       ',\n        '               ----------^----!  ',\n        '               ---------------^-!',\n      ];\n      const e1 = cold(' -                 ');\n      const e1subs = '  ^----------------!';\n      const expected = 'a----b----c----d--';\n      const unsub = '   -----------------!';\n\n      const win = cold('-----|');\n      //                     -----|\n      //                          -----|\n      const d = cold('                 ---');\n      const values = { a: win, b: win, c: win, d: d };\n\n      const result = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["windowWhen"],"updatePoint":{"line":367,"column":25},"line":367,"code":"  it('should handle throw', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' -----c--|');\n      const e2subs = '  (^!)     ';\n      const e1 = cold(' #        ');\n      const e1subs = '  (^!)     ';\n      const expected = '(w#)     ';\n      const win = cold('#        ');\n      const values = { w: win };\n\n      const result = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a never closing Observable","suites":["windowWhen"],"updatePoint":{"line":385,"column":46},"line":385,"code":"  it('should handle a never closing Observable', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('      -                                  ');\n      const e2subs = '       ^----------------------------------!';\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       ^----------------------------------!';\n      const expected = '     x----------------------------------|';\n\n      const x = cold('       ----b---c---d---e---f---g---h------|');\n      const values = { x: x };\n\n      const result = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a throw closing Observable","suites":["windowWhen"],"updatePoint":{"line":404,"column":46},"line":404,"code":"  it('should handle a throw closing Observable', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('      #                                   ');\n      const e2subs = '       (^!)                                ';\n      const e1 = hot('  --a--^---b---c---d---e---f---g---h------|');\n      const e1subs = '       (^!)                                ';\n      const expected = '     (x#)                                ';\n\n      const x = cold('       #                                   ');\n      const values = { x: x };\n\n      const result = e1.pipe(windowWhen(() => e2));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/windowWhen-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine events from cold observables","suites":["withLatestFrom"],"updatePoint":{"line":17,"column":49},"line":17,"code":"  it('should combine events from cold observables', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const e2 = cold(' --1--2-3-4---|   ');\n      const e2subs = '  ^------------!   ';\n      const e1 = cold(' -a--b-----c-d-e-|');\n      const e1subs = '  ^---------------!';\n      const expected = '----B-----C-D-E-|';\n\n      const result = e1.pipe(withLatestFrom(e2, (a: string, b: string) => String(a) + String(b)));\n\n      expectObservable(result).toBe(expected, { B: 'b1', C: 'c4', D: 'd4', E: 'e4' });\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge the value with the latest values from the other observables into arrays","suites":["withLatestFrom"],"updatePoint":{"line":33,"column":90},"line":33,"code":"  it('should merge the value with the latest values from the other observables into arrays', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h------|');\n      const e2subs = '       ^-------------!   ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^-------------!   ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^-------------!   ';\n      const expected = '     ----x---y---z-|   ';\n      const values = {\n        x: ['b', 'f', 'j'],\n        y: ['c', 'g', 'k'],\n        z: ['d', 'h', 'l'],\n      };\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should merge the value with the latest values from the other observables into arrays and a project argument","suites":["withLatestFrom"],"updatePoint":{"line":57,"column":113},"line":57,"code":"  it('should merge the value with the latest values from the other observables into arrays and a project argument', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h------|');\n      const e2subs = '       ^-------------!   ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^-------------!   ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^-------------!   ';\n      const expected = '     ----x---y---z-|   ';\n      const values = {\n        x: 'bfj',\n        y: 'cgk',\n        z: 'dhl',\n      };\n      const project = (a: string, b: string, c: string) => a + b + c;\n\n      const result = e1.pipe(withLatestFrom(e2, e3, project));\n\n      expectObservable(result).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow unsubscribing early and explicitly","suites":["withLatestFrom"],"updatePoint":{"line":82,"column":53},"line":82,"code":"  it('should allow unsubscribing early and explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h------|');\n      const e2subs = '       ^----------!      ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^----------!      ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^----------!      ';\n      const expected = '     ----x---y---      ';\n      const unsub = '        -----------!      ';\n      const values = {\n        x: 'bfj',\n        y: 'cgk',\n        z: 'dhl',\n      };\n      const project = (a: string, b: string, c: string) => a + b + c;\n\n      const result = e1.pipe(withLatestFrom(e2, e3, project));\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chains when result is unsubscribed explicitly","suites":["withLatestFrom"],"updatePoint":{"line":108,"column":83},"line":108,"code":"  it('should not break unsubscription chains when result is unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h------|');\n      const e2subs = '       ^----------!      ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^----------!      ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^----------!      ';\n      const expected = '     ----x---y---      ';\n      const unsub = '        -----------!      ';\n      const values = {\n        x: 'bfj',\n        y: 'cgk',\n        z: 'dhl',\n      };\n      const project = (a: string, b: string, c: string) => a + b + c;\n\n      const result = e1.pipe(\n        mergeMap((x: string) => of(x)),\n        withLatestFrom(e2, e3, project),\n        mergeMap((x: string) => of(x))\n      );\n\n      expectObservable(result, unsub).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["withLatestFrom"],"updatePoint":{"line":138,"column":25},"line":138,"code":"  it('should handle empty', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h----|');\n      const e2subs = '       (^!)            ';\n      const e3 = hot('  --i--^-j---k---l----|');\n      const e3subs = '       (^!)            ';\n      const e1 = cold('      |               ');\n      const e1subs = '       (^!)            ';\n      const expected = '     |               '; // empty\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["withLatestFrom"],"updatePoint":{"line":157,"column":25},"line":157,"code":"  it('should handle never', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('   --e--^-f---g---h----|  ');\n      const e2subs = '        ^--------------!  ';\n      const e3 = hot('   --i--^-j---k---l----|  ');\n      const e3subs = '        ^--------------!  ';\n      const e1 = cold('        -                ');\n      const e1subs = '         ^----------------';\n      const expected = '    --------------------'; // never\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle throw","suites":["withLatestFrom"],"updatePoint":{"line":176,"column":25},"line":176,"code":"  it('should handle throw', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h----|');\n      const e2subs = '       (^!)            ';\n      const e3 = hot('  --i--^-j---k---l----|');\n      const e3subs = '       (^!)            ';\n      const e1 = cold('      #               ');\n      const e1subs = '       (^!)            ';\n      const expected = '     #               '; // throw\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle error","suites":["withLatestFrom"],"updatePoint":{"line":195,"column":25},"line":195,"code":"  it('should handle error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h----|');\n      const e2subs = '       ^-------!       ';\n      const e3 = hot('  --i--^-j---k---l----|');\n      const e3subs = '       ^-------!       ';\n      const e1 = hot('  --a--^---b---#       ', undefined, new Error('boo-hoo'));\n      const e1subs = '       ^-------!       ';\n      const expected = '     ----x---#       '; // throw\n      const values = {\n        x: ['b', 'f', 'j'],\n      };\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected, values, new Error('boo-hoo'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle error with project argument","suites":["withLatestFrom"],"updatePoint":{"line":217,"column":47},"line":217,"code":"  it('should handle error with project argument', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e2 = hot('  --e--^-f---g---h----|');\n      const e2subs = '       ^-------!       ';\n      const e3 = hot('  --i--^-j---k---l----|');\n      const e3subs = '       ^-------!       ';\n      const e1 = hot('  --a--^---b---#       ', undefined, new Error('boo-hoo'));\n      const e1subs = '       ^-------!       ';\n      const expected = '     ----x---#       '; // throw\n      const values = {\n        x: 'bfj',\n      };\n      const project = (a: string, b: string, c: string) => a + b + c;\n\n      const result = e1.pipe(withLatestFrom(e2, e3, project));\n\n      expectObservable(result).toBe(expected, values, new Error('boo-hoo'));\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging with empty","suites":["withLatestFrom"],"updatePoint":{"line":240,"column":38},"line":240,"code":"  it('should handle merging with empty', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('      |                 ');\n      const e2subs = '       (^!)              ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^-------------!   ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^-------------!   ';\n      const expected = '     --------------|   ';\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging with never","suites":["withLatestFrom"],"updatePoint":{"line":259,"column":38},"line":259,"code":"  it('should handle merging with never', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const e2 = cold('      -                 ');\n      const e2subs = '       ^-------------!   ';\n      const e3 = hot('  --i--^-j---k---l------|');\n      const e3subs = '       ^-------------!   ';\n      const e1 = hot('  --a--^---b---c---d-|   ');\n      const e1subs = '       ^-------------!   ';\n      const expected = '     --------------|   ';\n\n      const result = e1.pipe(withLatestFrom(e2, e3));\n\n      expectObservable(result).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle promises","suites":["withLatestFrom"],"updatePoint":{"line":278,"column":28},"line":278,"code":"  it('should handle promises', (done) => {\n    of(1)\n      .pipe(delay(1), withLatestFrom(Promise.resolve(2), Promise.resolve(3)))\n      .subscribe({\n        next(x: any) {\n          expect(x).to.deep.equal([1, 2, 3]);\n        },\n        complete: done,\n      });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle arrays","suites":["withLatestFrom"],"updatePoint":{"line":289,"column":26},"line":289,"code":"  it('should handle arrays', () => {\n    of(1)\n      .pipe(delay(1), withLatestFrom([2, 3, 4], [4, 5, 6]))\n      .subscribe((x: any) => {\n        expect(x).to.deep.equal([1, 4, 6]);\n      });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle lowercase-o observables","suites":["withLatestFrom"],"updatePoint":{"line":297,"column":43},"line":297,"code":"  it('should handle lowercase-o observables', () => {\n    of(1)\n      .pipe(delay(1), withLatestFrom(lowerCaseO(2, 3, 4), lowerCaseO(4, 5, 6)))\n      .subscribe((x: any) => {\n        expect(x).to.deep.equal([1, 4, 6]);\n      });\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with synchronous observables","suites":["withLatestFrom"],"updatePoint":{"line":305,"column":46},"line":305,"code":"  it('should work with synchronous observables', () => {\n    const result: Array<Array<number>> = [];\n    of(1, 2, 3)\n      .pipe(withLatestFrom(of(4, 5)))\n      .subscribe((x) => {\n        result.push(x);\n      });\n\n    expect(result.length).to.equal(3);\n    expect(result[0]).to.deep.equal([1, 5]);\n    expect(result[1]).to.deep.equal([2, 5]);\n    expect(result[2]).to.deep.equal([3, 5]);\n  });","file":"operators/withLatestFrom-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip the provided observables","suites":["zip legacy"],"updatePoint":{"line":18,"column":41},"line":18,"code":"  it('should zip the provided observables', (done) => {\n    const expected = ['a1', 'b2', 'c3'];\n    let i = 0;\n\n    from(['a', 'b', 'c'])\n      .pipe(zip(from([1, 2, 3]), (a, b): string => a + b))\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(expected[i++]);\n        },\n        complete: done,\n      });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with selector throws","suites":["zip legacy"],"updatePoint":{"line":32,"column":38},"line":32,"code":"  it('should work with selector throws', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-2---4----|  ');\n      const asubs = '     ^-------!     ';\n      const b = hot('---1-^--3----5----|');\n      const bsubs = '     ^-------!     ';\n      const expected = '  ---x----#     ';\n\n      const selector = (x: string, y: string) => {\n        if (y === '5') {\n          throw new Error('too bad');\n        } else {\n          return x + y;\n        }\n      };\n      const observable = a.pipe(zip(b, selector));\n      expectObservable(observable).toBe(expected, { x: '23' }, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 1","suites":["zip legacy"],"updatePoint":{"line":54,"column":45},"line":54,"code":"  it('should work with some data asymmetric 1', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n      const asubs = '     ^-----------------!    ';\n      const b = hot('---1-^--2--4--6--8--0--|    ');\n      const bsubs = '     ^-----------------!    ';\n      const expected = '  ---a--b--c--d--e--|    ';\n\n      expectObservable(\n        a.pipe(\n          zip(b, (r1, r2) => {\n            return r1 + r2;\n          })\n        )\n      ).toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 2","suites":["zip legacy"],"updatePoint":{"line":74,"column":45},"line":74,"code":"  it('should work with some data asymmetric 2', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^--2--4--6--8--0--|    ');\n      const asubs = '     ^-----------------!    ';\n      const b = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n      const bsubs = '     ^-----------------!    ';\n      const expected = '  ---a--b--c--d--e--|    ';\n\n      expectObservable(\n        a.pipe(\n          zip(b, (r1, r2) => {\n            return r1 + r2;\n          })\n        )\n      ).toBe(expected, { a: '21', b: '43', c: '65', d: '87', e: '09' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data symmetric","suites":["zip legacy"],"updatePoint":{"line":94,"column":42},"line":94,"code":"  it('should work with some data symmetric', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1-3-5-7-9------| ');\n      const asubs = '     ^----------------! ';\n      const b = hot('---1-^--2--4--6--8--0--|');\n      const bsubs = '     ^----------------! ';\n      const expected = '  ---a--b--c--d--e-| ';\n\n      expectObservable(\n        a.pipe(\n          zip(b, (r1, r2) => {\n            return r1 + r2;\n          })\n        )\n      ).toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric selector","suites":["zip legacy"],"updatePoint":{"line":114,"column":47},"line":114,"code":"  it('should work with n-ary symmetric selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1----4----|');\n      const asubs = '     ^---------!  ';\n      const b = hot('---1-^--2--5----| ');\n      const bsubs = '     ^---------!  ';\n      const c = hot('---1-^---3---6-|  ');\n      const expected = '  ----x---y-|  ';\n\n      const observable = a.pipe(\n        zip(b, c, (r0, r1, r2) => {\n          return [r0, r1, r2];\n        })\n      );\n      expectObservable(observable).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric array selector","suites":["zip legacy"],"updatePoint":{"line":134,"column":53},"line":134,"code":"  it('should work with n-ary symmetric array selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1----4----|');\n      const asubs = '     ^---------!  ';\n      const b = hot('---1-^--2--5----| ');\n      const bsubs = '     ^---------!  ';\n      const c = hot('---1-^---3---6-|  ');\n      const expected = '  ----x---y-|  ';\n\n      const observable = a.pipe(\n        zip(b, c, (r0, r1, r2) => {\n          return [r0, r1, r2];\n        })\n      );\n      expectObservable(observable).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two observables and selector","suites":["zip legacy"],"updatePoint":{"line":154,"column":49},"line":154,"code":"  it('should combine two observables and selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---');\n      const asubs = '   ^';\n      const b = hot('   --4--5--6--7--8--');\n      const bsubs = '   ^';\n      const expected = '---x---y---z';\n\n      expectObservable(\n        a.pipe(\n          zip(b, (e1, e2) => {\n            return e1 + e2;\n          })\n        )\n      ).toBe(expected, { x: '14', y: '25', z: '36' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zip-legacy-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable selector that throws","suites":["zip"],"updatePoint":{"line":14,"column":87},"line":14,"code":"  it('should work with non-empty observable and non-empty iterable selector that throws', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---^--1--2--3--|');\n      const asubs = '   ^-----!';\n      const expected = '---x--#';\n      const b = [4, 5, 6];\n\n      const selector = function (x: string, y: number) {\n        if (y === 5) {\n          throw new Error('too bad');\n        } else {\n          return x + y;\n        }\n      };\n      expectObservable(a.pipe(zip(b, selector))).toBe(expected, { x: '14' }, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n    });\n  });","file":"operators/zip-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine paired events from two observables","suites":["zipAll operator"],"updatePoint":{"line":16,"column":55},"line":16,"code":"  it('should combine paired events from two observables', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable }) => {\n      const x = cold('                  -a-----b-|');\n      const y = cold('                  --1-2-----');\n      const outer = hot('-x----y--------|         ', { x: x, y: y });\n      const expected = ' -----------------A----B-|';\n\n      const result = outer.pipe(zipAll((a, b) => a + b));\n\n      expectObservable(result).toBe(expected, { A: 'a1', B: 'b2' });\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two observables","suites":["zipAll operator"],"updatePoint":{"line":29,"column":36},"line":29,"code":"  it('should combine two observables', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---');\n      const asubs = '   ^';\n      const b = hot('   --4--5--6--7--8--');\n      const bsubs = '   ^';\n      const expected = '---x---y---z';\n      const values = { x: ['1', '4'], y: ['2', '5'], z: ['3', '6'] };\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, values);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should take all observables from the source and zip them","suites":["zipAll operator"],"updatePoint":{"line":44,"column":62},"line":44,"code":"  it('should take all observables from the source and zip them', (done) => {\n    const expected = ['a1', 'b2', 'c3'];\n    let i = 0;\n    of(of('a', 'b', 'c'), of(1, 2, 3))\n      .pipe(zipAll((a: string, b: number) => a + b))\n      .subscribe({\n        next(x) {\n          expect(x).to.equal(expected[i++]);\n        },\n        complete: done,\n      });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should end once one observable completes and its buffer is empty","suites":["zipAll operator"],"updatePoint":{"line":57,"column":70},"line":57,"code":"  it('should end once one observable completes and its buffer is empty', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--c--|               ');\n      const e1subs = '  ^-----------!               ';\n      const e2 = hot('  ------d----e----f--------|  ');\n      const e2subs = '  ^-----------------!         ';\n      const e3 = hot('  --------h----i----j---------'); // doesn't complete\n      const e3subs = '  ^-----------------!         ';\n      const expected = '--------x----y----(z|)      '; // e1 complete and buffer empty\n      const values = {\n        x: ['a', 'd', 'h'],\n        y: ['b', 'e', 'i'],\n        z: ['c', 'f', 'j'],\n      };\n\n      expectObservable(of(e1, e2, e3).pipe(zipAll())).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip them with values","suites":["zipAll operator","with iterables"],"updatePoint":{"line":102,"column":35},"line":102,"code":"    it('should zip them with values', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const myIterator = (function* () {\n          for (let i = 0; i < 4; i++) {\n            yield i;\n          }\n        })();\n\n        const e1 = hot('  ---a---b---c---d---|');\n        const e1subs = '  ^--------------!';\n        const expected = '---w---x---y---(z|)';\n\n        const values = {\n          w: ['a', 0],\n          x: ['b', 1],\n          y: ['c', 2],\n          z: ['d', 3],\n        };\n\n        expectObservable(of(e1, myIterator).pipe(zipAll<string | number>())).toBe(expected, values);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete instantly with never observable and empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":126,"column":74},"line":126,"code":"    it('should complete instantly with never observable and empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  -');\n        const asubs = '   (^!)';\n        const b: string[] = [];\n        const expected = '|';\n\n        expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":138,"column":60},"line":138,"code":"    it('should work with empty observable and empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  |');\n        const asubs = '   (^!)';\n        const b: string[] = [];\n        const expected = '|';\n\n        expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and non-empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":150,"column":64},"line":150,"code":"    it('should work with empty observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  |');\n        const asubs = '   (^!)';\n        const b = [1];\n        const expected = '|';\n\n        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":162,"column":64},"line":162,"code":"    it('should work with non-empty observable and empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^----a--|');\n        const asubs = '   (^!)';\n        const b: string[] = [];\n        const expected = '|';\n\n        expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never observable and non-empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":174,"column":64},"line":174,"code":"    it('should work with never observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  -');\n        const asubs = '   ^';\n        const b = [1];\n        const expected = '-';\n\n        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":186,"column":68},"line":186,"code":"    it('should work with non-empty observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^----1--|');\n        const asubs = '   ^----!   ';\n        const b = [2];\n        const expected = '-----(x|)';\n\n        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(expected, { x: ['1', 2] });\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with observable which raises error and non-empty iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":198,"column":77},"line":198,"code":"    it('should work with observable which raises error and non-empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^----#');\n        const asubs = '   ^----!';\n        const b = [1];\n        const expected = '-----#';\n\n        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty many observable and non-empty many iterable","suites":["zipAll operator","with iterables"],"updatePoint":{"line":210,"column":78},"line":210,"code":"    it('should work with non-empty many observable and non-empty many iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^--1--2--3--|');\n        const asubs = '   ^--------!   ';\n        const b = [4, 5, 6];\n        const expected = '---x--y--(z|)';\n\n        expectObservable(of(a, b).pipe(zipAll<string | number>())).toBe(expected, { x: ['1', 4], y: ['2', 5], z: ['3', 6] });\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable selector that throws","suites":["zipAll operator","with iterables"],"updatePoint":{"line":222,"column":89},"line":222,"code":"    it('should work with non-empty observable and non-empty iterable selector that throws', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^--1--2--3--|');\n        const asubs = '   ^-----!';\n        const b = [4, 5, 6];\n        const expected = '---x--#';\n\n        const selector = function (x: string, y: number) {\n          if (y === 5) {\n            throw new Error('too bad');\n          } else {\n            return x + y;\n          }\n        };\n        expectObservable(of(a, b).pipe(zipAll(selector))).toBe(expected, { x: '14' }, new Error('too bad'));\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two observables and selector","suites":["zipAll operator","with iterables"],"updatePoint":{"line":242,"column":49},"line":242,"code":"  it('should combine two observables and selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---');\n      const asubs = '   ^';\n      const b = hot('   --4--5--6--7--8--');\n      const bsubs = '   ^';\n      const expected = '---x---y---z';\n\n      expectObservable(of(a, b).pipe(zipAll((e1, e2) => e1 + e2))).toBe(expected, { x: '14', y: '25', z: '36' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric","suites":["zipAll operator","with iterables"],"updatePoint":{"line":256,"column":38},"line":256,"code":"  it('should work with n-ary symmetric', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1-^-1----4----|');\n      const asubs = '        ^---------!  ';\n      const b = hot('   ---1-^--2--5----| ');\n      const bsubs = '        ^---------!  ';\n      const c = hot('   ---1-^---3---6-|  ');\n      const expected = '     ----x---y-|  ';\n\n      expectObservable(of(a, b, c).pipe(zipAll())).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric selector","suites":["zipAll operator","with iterables"],"updatePoint":{"line":271,"column":47},"line":271,"code":"  it('should work with n-ary symmetric selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1----4----|');\n      const asubs = '     ^---------!  ';\n      const b = hot('---1-^--2--5----| ');\n      const bsubs = '     ^---------!  ';\n      const c = hot('---1-^---3---6-|  ');\n      const expected = '  ----x---y-|  ';\n\n      const observable = of(a, b, c).pipe(zipAll((r0, r1, r2) => [r0, r1, r2]));\n      expectObservable(observable).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric array selector","suites":["zipAll operator","with iterables"],"updatePoint":{"line":287,"column":53},"line":287,"code":"  it('should work with n-ary symmetric array selector', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1-^-1----4----|');\n      const asubs = '        ^---------!  ';\n      const b = hot('   ---1-^--2--5----| ');\n      const bsubs = '        ^---------!  ';\n      const c = hot('   ---1-^---3---6-|  ');\n      const expected = '     ----x---y-|  ';\n\n      const observable = of(a, b, c).pipe(zipAll((r0, r1, r2) => [r0, r1, r2]));\n      expectObservable(observable).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 1","suites":["zipAll operator","with iterables"],"updatePoint":{"line":303,"column":45},"line":303,"code":"  it('should work with some data asymmetric 1', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n      const asubs = '     ^-----------------!    ';\n      const b = hot('---1-^--2--4--6--8--0--|    ');\n      const bsubs = '     ^-----------------!    ';\n      const expected = '  ---a--b--c--d--e--|    ';\n\n      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data asymmetric 2","suites":["zipAll operator","with iterables"],"updatePoint":{"line":317,"column":45},"line":317,"code":"  it('should work with some data asymmetric 2', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^--2--4--6--8--0--|    ');\n      const asubs = '     ^-----------------!    ';\n      const b = hot('---1-^-1-3-5-7-9-x-y-z-w-u-|');\n      const bsubs = '     ^-----------------!    ';\n      const expected = '  ---a--b--c--d--e--|    ';\n\n      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(expected, { a: '21', b: '43', c: '65', d: '87', e: '09' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with some data symmetric","suites":["zipAll operator","with iterables"],"updatePoint":{"line":331,"column":42},"line":331,"code":"  it('should work with some data symmetric', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1-3-5-7-9------| ');\n      const asubs = '     ^----------------! ';\n      const b = hot('---1-^--2--4--6--8--0--|');\n      const bsubs = '     ^----------------! ';\n      const expected = '  ---a--b--c--d--e-| ';\n\n      expectObservable(of(a, b).pipe(zipAll((r1, r2) => r1 + r2))).toBe(expected, { a: '12', b: '34', c: '56', d: '78', e: '90' });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with selector throws","suites":["zipAll operator","with iterables"],"updatePoint":{"line":345,"column":38},"line":345,"code":"  it('should work with selector throws', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-2---4----|  ');\n      const asubs = '     ^-------!     ';\n      const b = hot('---1-^--3----5----|');\n      const bsubs = '     ^-------!     ';\n      const expected = '  ---x----#     ';\n\n      const selector = function (x: string, y: string) {\n        if (y === '5') {\n          throw new Error('too bad');\n        } else {\n          return x + y;\n        }\n      };\n      const observable = of(a, b).pipe(zipAll(selector));\n      expectObservable(observable).toBe(expected, { x: '23' }, new Error('too bad'));\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with right completes first","suites":["zipAll operator","with iterables"],"updatePoint":{"line":368,"column":44},"line":368,"code":"  it('should work with right completes first', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-2-----|');\n      const asubs = '     ^-----!';\n      const b = hot('---1-^--3--|');\n      const bsubs = '     ^-----!';\n      const expected = '  ---x--|';\n\n      expectObservable(zip(a, b)).toBe(expected, { x: ['2', '3'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip until one child terminates","suites":["zipAll operator","with iterables"],"updatePoint":{"line":382,"column":43},"line":382,"code":"  it('should zip until one child terminates', (done) => {\n    const expected = ['a1', 'b2'];\n    let i = 0;\n    of(of('a', 'b', 'c'), of(1, 2))\n      .pipe(zipAll((a: string, b: number) => a + b))\n      .subscribe({\n        next: (x) => {\n          expect(x).to.equal(expected[i++]);\n        },\n        complete: done,\n      });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle a hot observable of observables","suites":["zipAll operator","with iterables"],"updatePoint":{"line":395,"column":51},"line":395,"code":"  it('should handle a hot observable of observables', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('          a---b---c---|      ');\n      const xsubs = '   --------^-----------!';\n      const y = cold('          d---e---f---|   ');\n      const ysubs = '   --------^-----------!';\n      const e1 = hot('  --x--y--|            ', { x: x, y: y });\n      const e1subs = '  ^-------!            ';\n      const expected = '--------u---v---w---|';\n      const values = {\n        u: ['a', 'd'],\n        v: ['b', 'e'],\n        w: ['c', 'f'],\n      };\n\n      expectObservable(e1.pipe(zipAll())).toBe(expected, values);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle merging a hot observable of non-overlapped observables","suites":["zipAll operator","with iterables"],"updatePoint":{"line":417,"column":74},"line":417,"code":"  it('should handle merging a hot observable of non-overlapped observables', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('                             a-b---------|');\n      const xsubs = '   ---------------------------^-----------!';\n      const y = cold('                             c-d-e-f-|');\n      const ysubs = '   ---------------------------^-------!';\n      const z = cold('                             g-h-i-j-k-|');\n      const zsubs = '   ---------------------------^---------!';\n      const e1 = hot('  --x------y--------z--------|            ', { x: x, y: y, z: z });\n      const e1subs = '  ^--------------------------!            ';\n      const expected = '---------------------------u-v---------|';\n      const values = {\n        u: ['a', 'c', 'g'],\n        v: ['b', 'd', 'h'],\n      };\n\n      expectObservable(e1.pipe(zipAll())).toBe(expected, values);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if inner observable raises error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":441,"column":57},"line":441,"code":"  it('should raise error if inner observable raises error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const x = cold('                                a-b---------|');\n      const xsubs = '   ------------------------------^-------!';\n      const y = cold('                                c-d-e-f-#');\n      const ysubs = '   ------------------------------^-------!';\n      const z = cold('                                g-h-i-j-k-|');\n      const zsubs = '   ------------------------------^-------!';\n      const e1 = hot('  --x---------y--------z--------|        ', { x: x, y: y, z: z });\n      const e1subs = '  ^-----------------------------!        ';\n      const expected = '------------------------------u-v-----#';\n\n      const expectedValues = {\n        u: ['a', 'c', 'g'],\n        v: ['b', 'd', 'h'],\n      };\n\n      expectObservable(e1.pipe(zipAll())).toBe(expected, expectedValues);\n      expectSubscriptions(x.subscriptions).toBe(xsubs);\n      expectSubscriptions(y.subscriptions).toBe(ysubs);\n      expectSubscriptions(z.subscriptions).toBe(zsubs);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should raise error if outer observable raises error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":466,"column":57},"line":466,"code":"  it('should raise error if outer observable raises error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const y = cold('  a-b---------|');\n      const z = cold('  c-d-e-f-|');\n      const e1 = hot('  --y---------z---#', { y: y, z: z });\n      const e1subs = '  ^---------------!';\n      const expected = '----------------#';\n\n      expectObservable(e1.pipe(zipAll())).toBe(expected);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["zipAll operator","with iterables"],"updatePoint":{"line":479,"column":33},"line":479,"code":"  it('should work with two nevers', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   ^';\n      const b = cold('  -');\n      const bsubs = '   ^';\n      const expected = '-';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":493,"column":38},"line":493,"code":"  it('should work with never and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["zipAll operator","with iterables"],"updatePoint":{"line":507,"column":38},"line":507,"code":"  it('should work with empty and never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = cold('  -');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":521,"column":38},"line":521,"code":"  it('should work with empty and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and non-empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":535,"column":42},"line":535,"code":"  it('should work with empty and non-empty', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = hot('   ---1--|');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":549,"column":42},"line":549,"code":"  it('should work with non-empty and empty', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1--|');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and non-empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":563,"column":42},"line":563,"code":"  it('should work with never and non-empty', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   ^';\n      const b = hot('   ---1--|');\n      const bsubs = '   ^-----!';\n      const expected = '-';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and never","suites":["zipAll operator","with iterables"],"updatePoint":{"line":577,"column":42},"line":577,"code":"  it('should work with non-empty and never', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1--|');\n      const asubs = '   ^-----!';\n      const b = cold('  -');\n      const bsubs = '   ^';\n      const expected = '-';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine a source with a second","suites":["zipAll operator","with iterables"],"updatePoint":{"line":591,"column":43},"line":591,"code":"  it('should combine a source with a second', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---');\n      const asubs = '   ^';\n      const b = hot('   --4--5--6--7--8--');\n      const bsubs = '   ^';\n      const expected = '---x---y---z';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, { x: ['1', '4'], y: ['2', '5'], z: ['3', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":605,"column":38},"line":605,"code":"  it('should work with empty and error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = hot('   ------#', undefined, 'too bad');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["zipAll operator","with iterables"],"updatePoint":{"line":619,"column":38},"line":619,"code":"  it('should work with error and empty', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#', undefined, 'too bad');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":633,"column":28},"line":633,"code":"  it('should work with error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ----------|');\n      const asubs = '   ^-----!    ';\n      const b = hot('   ------#    ');\n      const bsubs = '   ^-----!    ';\n      const expected = '------#    ';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":647,"column":38},"line":647,"code":"  it('should work with never and error', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   ^-----!';\n      const b = hot('   ------#');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and never","suites":["zipAll operator","with iterables"],"updatePoint":{"line":661,"column":38},"line":661,"code":"  it('should work with error and never', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#');\n      const asubs = '   ^-----!';\n      const b = cold('  -');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and error","suites":["zipAll operator","with iterables"],"updatePoint":{"line":675,"column":38},"line":675,"code":"  it('should work with error and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#', undefined, 'too bad');\n      const asubs = '   ^-----!';\n      const b = hot('   ----------#', undefined, 'too bad 2');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, null, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors","suites":["zipAll operator","with iterables"],"updatePoint":{"line":689,"column":63},"line":689,"code":"  it('should work with two sources that eventually raise errors', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   --w-----#----', { w: 1 }, 'too bad');\n      const asubs = '   ^-------!';\n      const b = hot('   -----z-----#-', { z: 2 }, 'too bad 2');\n      const bsubs = '   ^-------!';\n      const expected = '-----x--#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, { x: [1, 2] }, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors (swapped)","suites":["zipAll operator","with iterables"],"updatePoint":{"line":703,"column":73},"line":703,"code":"  it('should work with two sources that eventually raise errors (swapped)', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   -----z-----#-', { z: 2 }, 'too bad 2');\n      const asubs = '   ^-------!';\n      const b = hot('   --w-----#', { w: 1 }, 'too bad');\n      const bsubs = '   ^-------!';\n      const expected = '-----x--#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected, { x: [2, 1] }, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and some","suites":["zipAll operator","with iterables"],"updatePoint":{"line":717,"column":37},"line":717,"code":"  it('should work with error and some', () => {\n    rxTestScheduler.run(({ hot, cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  #');\n      const asubs = '   (^!)';\n      const b = hot('   --1--2--3--');\n      const bsubs = '   (^!)';\n      const expected = '#';\n\n      expectObservable(of(a, b).pipe(zipAll())).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine two immediately-scheduled observables","suites":["zipAll operator","with iterables"],"updatePoint":{"line":731,"column":58},"line":731,"code":"  it('should combine two immediately-scheduled observables', (done) => {\n    rxTestScheduler.run(() => {\n      const a = scheduled([1, 2, 3], queueScheduler);\n      const b = scheduled([4, 5, 6, 7, 8], queueScheduler);\n      const r = [\n        [1, 4],\n        [2, 5],\n        [3, 6],\n      ];\n      let i = 0;\n\n      const result = scheduled([a, b], queueScheduler).pipe(zipAll());\n\n      result.subscribe({\n        next(vals) {\n          expect(vals).to.deep.equal(r[i++]);\n        },\n        complete: done,\n      });\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine a source with an immediately-scheduled source","suites":["zipAll operator","with iterables"],"updatePoint":{"line":753,"column":66},"line":753,"code":"  it('should combine a source with an immediately-scheduled source', (done) => {\n    const a = scheduled([1, 2, 3], queueScheduler);\n    const b = of(4, 5, 6, 7, 8);\n    const r = [\n      [1, 4],\n      [2, 5],\n      [3, 6],\n    ];\n    let i = 0;\n\n    const result = scheduled([a, b], queueScheduler).pipe(zipAll());\n\n    result.subscribe({\n      next(vals) {\n        expect(vals).to.deep.equal(r[i++]);\n      },\n      complete: done,\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["zipAll operator","with iterables"],"updatePoint":{"line":773,"column":72},"line":773,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---|');\n      const unsub = '   ---------!';\n      const asubs = '   ^--------!';\n      const b = hot('   --4--5--6--7--8--|');\n      const bsubs = '   ^--------!';\n      const expected = '---x---y--';\n      const values = { x: ['1', '4'], y: ['2', '5'] };\n\n      const r = of(a, b).pipe(\n        mergeMap((x) => of(x)),\n        zipAll(),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(r, unsub).toBe(expected, values);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete when empty source","suites":["zipAll operator","with iterables"],"updatePoint":{"line":795,"column":39},"line":795,"code":"  it('should complete when empty source', () => {\n    rxTestScheduler.run(({ hot, expectObservable }) => {\n      const source = hot('|');\n      const expected = '  |';\n\n      expectObservable(source.pipe(zipAll())).toBe(expected);\n    });\n  });","file":"operators/zipAll-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine a source with a second","suites":["zipWith"],"updatePoint":{"line":16,"column":43},"line":16,"code":"  it('should combine a source with a second', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3-----');\n      const asubs = '   ^';\n      const b = hot('   --4--5--6--7--8--');\n      const bsubs = '   ^';\n      const expected = '---x---y---z-----';\n      expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ['1', '4'], y: ['2', '5'], z: ['3', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end once one observable completes and its buffer is empty","suites":["zipWith"],"updatePoint":{"line":29,"column":70},"line":29,"code":"  it('should end once one observable completes and its buffer is empty', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--c--|               ');\n      const e1subs = '  ^-----------!               ';\n      const e2 = hot('  ------d----e----f--------|  ');\n      const e2subs = '  ^-----------------!         ';\n      const e3 = hot('  --------h----i----j---------'); // doesn't complete\n      const e3subs = '  ^-----------------!         ';\n      const expected = '--------x----y----(z|)      '; // e1 complete and buffer empty\n      const values = {\n        x: ['a', 'd', 'h'],\n        y: ['b', 'e', 'i'],\n        z: ['c', 'f', 'j'],\n      };\n\n      expectObservable(e1.pipe(zipWith(e2, e3))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should end once one observable nexts and zips value from completed other observable whose buffer is empty","suites":["zipWith"],"updatePoint":{"line":51,"column":111},"line":51,"code":"  it('should end once one observable nexts and zips value from completed other observable whose buffer is empty', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const e1 = hot('  ---a--b--c--|             ');\n      const e1subs = '  ^-----------!             ';\n      const e2 = hot('  ------d----e----f|        ');\n      const e2subs = '  ^----------------!        ';\n      const e3 = hot('  --------h----i----j-------'); // doesn't complete\n      const e3subs = '  ^-----------------!       ';\n      const expected = '--------x----y----(z|)    '; // e2 buffer empty and signaled complete\n      const values = {\n        x: ['a', 'd', 'h'],\n        y: ['b', 'e', 'i'],\n        z: ['c', 'f', 'j'],\n      };\n\n      expectObservable(e1.pipe(zipWith(e2, e3))).toBe(expected, values);\n      expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      expectSubscriptions(e2.subscriptions).toBe(e2subs);\n      expectSubscriptions(e3.subscriptions).toBe(e3subs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should zip them with values","suites":["zipWith","with iterables"],"updatePoint":{"line":74,"column":35},"line":74,"code":"    it('should zip them with values', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const myIterator = (function* () {\n          for (let i = 0; i < 4; i++) {\n            yield i;\n          }\n        })();\n\n        const e1 = hot('  ---a---b---c---d---|');\n        const e1subs = '  ^--------------!';\n        const expected = '---w---x---y---(z|)';\n\n        const values = {\n          w: ['a', 0],\n          x: ['b', 1],\n          y: ['c', 2],\n          z: ['d', 3],\n        };\n\n        expectObservable(e1.pipe(zipWith(myIterator))).toBe(expected, values);\n        expectSubscriptions(e1.subscriptions).toBe(e1subs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete instantly for an empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":98,"column":55},"line":98,"code":"    it('should complete instantly for an empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  -');\n        const asubs = '   (^!)';\n        const expected = '|';\n        const b: string[] = [];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":110,"column":60},"line":110,"code":"    it('should work with empty observable and empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  |');\n        const asubs = '   (^!)';\n        const expected = '|';\n        const b: string[] = [];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty observable and non-empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":122,"column":64},"line":122,"code":"    it('should work with empty observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  |');\n        const asubs = '   (^!)';\n        const expected = '|';\n        const b = [1];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should complete instantly with non-empty observable and empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":134,"column":78},"line":134,"code":"    it('should complete instantly with non-empty observable and empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('   ---^----a--|');\n        const asubs = '      (^!)';\n        const b: string[] = [];\n        const expected = '   |';\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never observable and non-empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":146,"column":64},"line":146,"code":"    it('should work with never observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n        const a = cold('  -');\n        const asubs = '   ^';\n        const expected = '-';\n        const b = [1];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty observable and non-empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":158,"column":68},"line":158,"code":"    it('should work with non-empty observable and non-empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^----1--|');\n        const asubs = '   ^----!   ';\n        const expected = '-----(x|)';\n        const b = [2];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ['1', 2] });\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with observable which raises error and non-empty iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":170,"column":77},"line":170,"code":"    it('should work with observable which raises error and non-empty iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^----#');\n        const asubs = '   ^----!';\n        const expected = '-----#';\n        const b = [1];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected);\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty many observable and non-empty many iterable","suites":["zipWith","with iterables"],"updatePoint":{"line":182,"column":78},"line":182,"code":"    it('should work with non-empty many observable and non-empty many iterable', () => {\n      rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n        const a = hot('---^--1--2--3--|');\n        const asubs = '   ^--------!   ';\n        const expected = '---x--y--(z|)';\n        const b = [4, 5, 6];\n\n        expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ['1', 4], y: ['2', 5], z: ['3', 6] });\n        expectSubscriptions(a.subscriptions).toBe(asubs);\n      });\n    });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with n-ary symmetric","suites":["zipWith","with iterables"],"updatePoint":{"line":195,"column":38},"line":195,"code":"  it('should work with n-ary symmetric', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-1----4----|');\n      const asubs = '     ^---------!  ';\n      const b = hot('---1-^--2--5----| ');\n      const bsubs = '     ^---------!  ';\n      const c = hot('---1-^---3---6-|  ');\n      const expected = '  ----x---y-|  ';\n\n      expectObservable(a.pipe(zipWith(b, c))).toBe(expected, { x: ['1', '2', '3'], y: ['4', '5', '6'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with right completes first","suites":["zipWith","with iterables"],"updatePoint":{"line":210,"column":44},"line":210,"code":"  it('should work with right completes first', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('---1-^-2-----|');\n      const asubs = '     ^-----!';\n      const b = hot('---1-^--3--|');\n      const bsubs = '     ^-----!';\n      const expected = '  ---x--|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: ['2', '3'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two nevers","suites":["zipWith","with iterables"],"updatePoint":{"line":224,"column":33},"line":224,"code":"  it('should work with two nevers', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   ^';\n      const b = cold('  -');\n      const bsubs = '   ^';\n      const expected = '-';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and empty","suites":["zipWith","with iterables"],"updatePoint":{"line":238,"column":38},"line":238,"code":"  it('should work with never and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and never","suites":["zipWith","with iterables"],"updatePoint":{"line":252,"column":38},"line":252,"code":"  it('should work with empty and never', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = cold('  -');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and empty","suites":["zipWith","with iterables"],"updatePoint":{"line":266,"column":38},"line":266,"code":"  it('should work with empty and empty', () => {\n    rxTestScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and non-empty","suites":["zipWith","with iterables"],"updatePoint":{"line":280,"column":42},"line":280,"code":"  it('should work with empty and non-empty', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = hot('   ---1--|');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and empty","suites":["zipWith","with iterables"],"updatePoint":{"line":294,"column":42},"line":294,"code":"  it('should work with non-empty and empty', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1--|');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and non-empty","suites":["zipWith","with iterables"],"updatePoint":{"line":308,"column":42},"line":308,"code":"  it('should work with never and non-empty', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -');\n      const asubs = '   ^';\n      const b = hot('   ---1--|');\n      const bsubs = '   ^-----!';\n      const expected = '-';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with non-empty and never","suites":["zipWith","with iterables"],"updatePoint":{"line":322,"column":42},"line":322,"code":"  it('should work with non-empty and never', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1--|');\n      const asubs = '   ^-----!';\n      const b = cold('  -');\n      const bsubs = '   ^';\n      const expected = '-';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with empty and error","suites":["zipWith","with iterables"],"updatePoint":{"line":336,"column":38},"line":336,"code":"  it('should work with empty and error', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  |');\n      const asubs = '   (^!)';\n      const b = hot('   ------#', undefined, 'too bad');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and empty","suites":["zipWith","with iterables"],"updatePoint":{"line":350,"column":38},"line":350,"code":"  it('should work with error and empty', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#', undefined, 'too bad');\n      const asubs = '   (^!)';\n      const b = cold('  |');\n      const bsubs = '   (^!)';\n      const expected = '|';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error","suites":["zipWith","with iterables"],"updatePoint":{"line":364,"column":28},"line":364,"code":"  it('should work with error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ----------|');\n      const asubs = '   ^-----!    ';\n      const b = hot('   ------#    ');\n      const bsubs = '   ^-----!    ';\n      const expected = '------#    ';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with never and error","suites":["zipWith","with iterables"],"updatePoint":{"line":378,"column":38},"line":378,"code":"  it('should work with never and error', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  -------');\n      const asubs = '   ^-----!';\n      const b = hot('   ------#');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and never","suites":["zipWith","with iterables"],"updatePoint":{"line":392,"column":38},"line":392,"code":"  it('should work with error and never', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#');\n      const asubs = '   ^-----!';\n      const b = cold('  -------');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and error","suites":["zipWith","with iterables"],"updatePoint":{"line":406,"column":38},"line":406,"code":"  it('should work with error and error', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ------#', undefined, 'too bad');\n      const asubs = '   ^-----!';\n      const b = hot('   ----------#', undefined, 'too bad 2');\n      const bsubs = '   ^-----!';\n      const expected = '------#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected, null, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors","suites":["zipWith","with iterables"],"updatePoint":{"line":420,"column":63},"line":420,"code":"  it('should work with two sources that eventually raise errors', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   --w-----#----', { w: 1 }, 'too bad');\n      const asubs = '   ^-------!';\n      const b = hot('   -----z-----#-', { z: 2 }, 'too bad 2');\n      const bsubs = '   ^-------!';\n      const expected = '-----x--#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: [1, 2] }, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with two sources that eventually raise errors (swapped)","suites":["zipWith","with iterables"],"updatePoint":{"line":434,"column":73},"line":434,"code":"  it('should work with two sources that eventually raise errors (swapped)', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   -----z-----#-', { z: 2 }, 'too bad 2');\n      const asubs = '   ^-------!';\n      const b = hot('   --w-----#----', { w: 1 }, 'too bad');\n      const bsubs = '   ^-------!';\n      const expected = '-----x--#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected, { x: [2, 1] }, 'too bad');\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with error and some","suites":["zipWith","with iterables"],"updatePoint":{"line":448,"column":37},"line":448,"code":"  it('should work with error and some', () => {\n    rxTestScheduler.run(({ cold, hot, expectObservable, expectSubscriptions }) => {\n      const a = cold('  #');\n      const asubs = '   (^!)';\n      const b = hot('   --1--2--3--');\n      const bsubs = '   (^!)';\n      const expected = '#';\n\n      expectObservable(a.pipe(zipWith(b))).toBe(expected);\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should combine an immediately-scheduled source with an immediately-scheduled second","suites":["zipWith","with iterables"],"updatePoint":{"line":462,"column":89},"line":462,"code":"  it('should combine an immediately-scheduled source with an immediately-scheduled second', (done) => {\n    const a = scheduled([1, 2, 3], queueScheduler);\n    const b = scheduled([4, 5, 6, 7, 8], queueScheduler);\n    const r = [\n      [1, 4],\n      [2, 5],\n      [3, 6],\n    ];\n    let i = 0;\n\n    a.pipe(zipWith(b)).subscribe({\n      next(vals) {\n        expect(vals).to.deep.equal(r[i++]);\n      },\n      complete: done,\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should not break unsubscription chain when unsubscribed explicitly","suites":["zipWith","with iterables"],"updatePoint":{"line":480,"column":72},"line":480,"code":"  it('should not break unsubscription chain when unsubscribed explicitly', () => {\n    rxTestScheduler.run(({ hot, expectObservable, expectSubscriptions }) => {\n      const a = hot('   ---1---2---3---|');\n      const unsub = '   ---------!';\n      const asubs = '   ^--------!';\n      const b = hot('   --4--5--6--7--8--|');\n      const bsubs = '   ^--------!';\n      const expected = '---x---y--';\n\n      const r = a.pipe(\n        mergeMap((x) => of(x)),\n        zipWith(b),\n        mergeMap((x) => of(x))\n      );\n\n      expectObservable(r, unsub).toBe(expected, { x: ['1', '4'], y: ['2', '5'] });\n      expectSubscriptions(a.subscriptions).toBe(asubs);\n      expectSubscriptions(b.subscriptions).toBe(bsubs);\n    });\n  });","file":"operators/zipWith-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule a sync observable","suites":["scheduled"],"updatePoint":{"line":14,"column":39},"line":14,"code":"  it('should schedule a sync observable', () => {\n    const input = of('a', 'b', 'c');\n    testScheduler.run(({ expectObservable }) => {\n      expectObservable(scheduled(input, testScheduler)).toBe('(abc|)');\n    });\n  });","file":"scheduled/scheduled-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule an array","suites":["scheduled"],"updatePoint":{"line":21,"column":30},"line":21,"code":"  it('should schedule an array', () => {\n    const input = ['a', 'b', 'c'];\n    testScheduler.run(({ expectObservable }) => {\n      expectObservable(scheduled(input, testScheduler)).toBe('(abc|)');\n    });\n  });","file":"scheduled/scheduled-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule an iterable","suites":["scheduled"],"updatePoint":{"line":28,"column":33},"line":28,"code":"  it('should schedule an iterable', () => {\n    const input = 'abc'; // strings are iterables\n    testScheduler.run(({ expectObservable }) => {\n      expectObservable(scheduled(input, testScheduler)).toBe('(abc|)');\n    });\n  });","file":"scheduled/scheduled-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule an observable-like","suites":["scheduled"],"updatePoint":{"line":35,"column":40},"line":35,"code":"  it('should schedule an observable-like', () => {\n    const input = lowerCaseO('a', 'b', 'c'); // strings are iterables\n    testScheduler.run(({ expectObservable }) => {\n      expectObservable(scheduled(input, testScheduler)).toBe('(abc|)');\n    });\n  });","file":"scheduled/scheduled-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule a promise","suites":["scheduled"],"updatePoint":{"line":42,"column":31},"line":42,"code":"  it('should schedule a promise', (done) => {\n    const results: any[] = [];\n    const input = Promise.resolve('x'); // strings are iterables\n    scheduled(input, testScheduler).subscribe({\n      next(value) { results.push(value); },\n      complete() { results.push('done'); },\n    });\n\n    expect(results).to.deep.equal([]);\n\n    // Promises force async, so we can't schedule synchronously, no matter what.\n    testScheduler.flush();\n    expect(results).to.deep.equal([]);\n\n    Promise.resolve().then(() => {\n      // NOW it should work, as the other promise should have resolved.\n      testScheduler.flush();\n      expect(results).to.deep.equal(['x', 'done']);\n      done();\n    });\n  });","file":"scheduled/scheduled-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things recursively","suites":["Scheduler.queue"],"updatePoint":{"line":7,"column":40},"line":7,"code":"  it('should schedule things recursively', () => {\n    let call1 = false;\n    let call2 = false;\n    (queue as QueueScheduler)._active = false;\n    queue.schedule(() => {\n      call1 = true;\n      queue.schedule(() => {\n        call2 = true;\n      });\n    });\n    expect(call1).to.be.true;\n    expect(call2).to.be.true;\n  });","file":"Scheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things recursively via this.schedule","suites":["Scheduler.queue"],"updatePoint":{"line":21,"column":58},"line":21,"code":"  it('should schedule things recursively via this.schedule', () => {\n    let call1 = false;\n    let call2 = false;\n    (queue as QueueScheduler)._active = false;\n    queue.schedule(function (state) {\n      call1 = state!.call1;\n      call2 = state!.call2;\n      if (!call2) {\n        this.schedule({ call1: true, call2: true });\n      }\n    }, 0, { call1: true, call2: false });\n    expect(call1).to.be.true;\n    expect(call2).to.be.true;\n  });","file":"Scheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things in the future too","suites":["Scheduler.queue"],"updatePoint":{"line":36,"column":46},"line":36,"code":"  it('should schedule things in the future too', (done) => {\n    let called = false;\n    queue.schedule(() => {\n      called = true;\n    }, 60);\n\n    setTimeout(() => {\n      expect(called).to.be.false;\n    }, 20);\n\n    setTimeout(() => {\n      expect(called).to.be.true;\n      done();\n    }, 100);\n  });","file":"Scheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should be reusable after an error is thrown during execution","suites":["Scheduler.queue"],"updatePoint":{"line":52,"column":66},"line":52,"code":"  it('should be reusable after an error is thrown during execution', (done) => {\n    const results: number[] = [];\n\n    expect(() => {\n      queue.schedule(() => {\n        results.push(1);\n      });\n\n      queue.schedule(() => {\n        throw new Error('bad');\n      });\n    }).to.throw(Error, 'bad');\n\n    setTimeout(() => {\n      queue.schedule(() => {\n        results.push(2);\n        done();\n      });\n    }, 0);\n  });","file":"Scheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should be monkey patchable","suites":["animationFrameProvider"],"updatePoint":{"line":14,"column":32},"line":14,"code":"  it('should be monkey patchable', () => {\n    let requestCalled = false;\n    let cancelCalled = false;\n\n    global.requestAnimationFrame = () => {\n      requestCalled = true;\n      return 0;\n    };\n    global.cancelAnimationFrame = () => {\n      cancelCalled = true;\n    };\n\n    const handle = animationFrameProvider.requestAnimationFrame(() => {\n      /* noop */\n    });\n    animationFrameProvider.cancelAnimationFrame(handle);\n\n    expect(requestCalled).to.be.true;\n    expect(cancelCalled).to.be.true;\n  });","file":"schedulers/animationFrameProvider-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["Scheduler.animationFrame"],"updatePoint":{"line":20,"column":18},"line":20,"code":"  it('should exist', () => {\n    expect(animationFrame).exist;\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should act like the async scheduler if delay > 0","suites":["Scheduler.animationFrame"],"updatePoint":{"line":24,"column":54},"line":24,"code":"  it('should act like the async scheduler if delay > 0', () => {\n    testScheduler.run(({ animate, cold, expectObservable, time }) => {\n      animate('         ----------x--');\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const b = cold('  b            ');\n      const tb = time(' --------|    ');\n      const expected = '----a---b----';\n\n      const result = merge(\n        a.pipe(delay(ta, animationFrame)),\n        b.pipe(delay(tb, animationFrame))\n      );\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should cancel animationFrame actions when delay > 0","suites":["Scheduler.animationFrame"],"updatePoint":{"line":41,"column":57},"line":41,"code":"  it('should cancel animationFrame actions when delay > 0', () => {\n    testScheduler.run(({ animate, cold, expectObservable, flush, time }) => {\n      const requestSpy = sinon.spy(animationFrameProvider, 'requestAnimationFrame');\n      const setSpy = sinon.spy(intervalProvider, 'setInterval');\n      const clearSpy = sinon.spy(intervalProvider, 'clearInterval');\n\n      animate('         ----------x--');\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const subs = '    ^-!          ';\n      const expected = '-------------';\n\n      const result = merge(\n        a.pipe(delay(ta, animationFrame))\n      );\n      expectObservable(result, subs).toBe(expected);\n\n      flush();\n      expect(requestSpy).to.have.not.been.called;\n      expect(setSpy).to.have.been.calledOnce;\n      expect(clearSpy).to.have.been.calledOnce;\n      requestSpy.restore();\n      setSpy.restore();\n      clearSpy.restore();\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule an action to happen later","suites":["Scheduler.animationFrame"],"updatePoint":{"line":68,"column":47},"line":68,"code":"  it('should schedule an action to happen later', (done) => {\n    let actionHappened = false;\n    animationFrame.schedule(() => {\n      actionHappened = true;\n      done();\n    });\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    }\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute recursively scheduled actions in separate asynchronous contexts","suites":["Scheduler.animationFrame"],"updatePoint":{"line":79,"column":84},"line":79,"code":"  it('should execute recursively scheduled actions in separate asynchronous contexts', (done) => {\n    let syncExec1 = true;\n    let syncExec2 = true;\n    animationFrame.schedule(function (index) {\n      if (index === 0) {\n        this.schedule(1);\n        animationFrame.schedule(() => { syncExec1 = false; });\n      } else if (index === 1) {\n        this.schedule(2);\n        animationFrame.schedule(() => { syncExec2 = false; });\n      } else if (index === 2) {\n        this.schedule(3);\n      } else if (index === 3) {\n        if (!syncExec1 && !syncExec2) {\n          done();\n        } else {\n          done(new Error('Execution happened synchronously.'));\n        }\n      }\n    }, 0, 0);\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should cancel the animation frame if all scheduled actions unsubscribe before it executes","suites":["Scheduler.animationFrame"],"updatePoint":{"line":101,"column":95},"line":101,"code":"  it('should cancel the animation frame if all scheduled actions unsubscribe before it executes', (done) => {\n    let animationFrameExec1 = false;\n    let animationFrameExec2 = false;\n    const action1 = animationFrame.schedule(() => { animationFrameExec1 = true; });\n    const action2 = animationFrame.schedule(() => { animationFrameExec2 = true; });\n    expect(animationFrame._scheduled).to.exist;\n    expect(animationFrame.actions.length).to.equal(2);\n    action1.unsubscribe();\n    action2.unsubscribe();\n    expect(animationFrame.actions.length).to.equal(0);\n    expect(animationFrame._scheduled).to.equal(undefined);\n    animationFrame.schedule(() => {\n      expect(animationFrameExec1).to.equal(false);\n      expect(animationFrameExec2).to.equal(false);\n      done();\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute the rest of the scheduled actions if the first action is canceled","suites":["Scheduler.animationFrame"],"updatePoint":{"line":119,"column":86},"line":119,"code":"  it('should execute the rest of the scheduled actions if the first action is canceled', (done) => {\n    let actionHappened = false;\n    let secondSubscription: Subscription | null = null;\n\n    const firstSubscription = animationFrame.schedule(() => {\n      actionHappened = true;\n      if (secondSubscription) {\n        secondSubscription.unsubscribe();\n      }\n      done(new Error('The first action should not have executed.'));\n    });\n\n    secondSubscription = animationFrame.schedule(() => {\n      if (!actionHappened) {\n        done();\n      }\n    });\n\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    } else {\n      firstSubscription.unsubscribe();\n    }\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should not execute rescheduled actions when flushing","suites":["Scheduler.animationFrame"],"updatePoint":{"line":144,"column":58},"line":144,"code":"  it('should not execute rescheduled actions when flushing', (done) => {\n    let flushCount = 0;\n    let scheduledIndices: number[] = [];\n\n    let originalFlush = animationFrame.flush;\n    animationFrame.flush = (...args) => {\n      ++flushCount;\n      originalFlush.apply(animationFrame, args);\n      if (flushCount === 2) {\n        animationFrame.flush = originalFlush;\n        try {\n          expect(scheduledIndices).to.deep.equal([0, 1]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      }\n    };\n\n    animationFrame.schedule(function (index) {\n      if (flushCount < 2) {\n        this.schedule(index! + 1);\n        scheduledIndices.push(index! + 1);\n      }\n    }, 0, 0);\n    scheduledIndices.push(0);\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute actions scheduled when flushing in a subsequent flush","suites":["Scheduler.animationFrame"],"updatePoint":{"line":172,"column":74},"line":172,"code":"  it('should execute actions scheduled when flushing in a subsequent flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = (sandbox.stub(animationFrameScheduler, 'flush')).callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      c = animationFrameScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n    });\n    b = animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed","suites":["Scheduler.animationFrame"],"updatePoint":{"line":193,"column":109},"line":193,"code":"  it('should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = (sandbox.stub(animationFrameScheduler, 'flush')).callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = animationFrameScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      c = animationFrameScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n      b.unsubscribe();\n    });\n    b = animationFrameScheduler.schedule(() => {\n      done(new Error('Unexpected execution of b'));\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should properly cancel an unnecessary flush","suites":["Scheduler.animationFrame"],"updatePoint":{"line":215,"column":49},"line":215,"code":"  it('should properly cancel an unnecessary flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const cancelAnimationFrameStub = sandbox.stub(animationFrameProvider, 'cancelAnimationFrame').callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = animationFrameScheduler.schedule(() => {\n      expect(animationFrameScheduler.actions).to.have.length(1);\n      c = animationFrameScheduler.schedule(() => {\n        done(new Error('Unexpected execution of c'));\n      });\n      expect(animationFrameScheduler.actions).to.have.length(2);\n      // What we're testing here is that the unsubscription of action c effects\n      // the cancellation of the animation frame in a scenario in which the\n      // actions queue is not empty - it contains action b.\n      c.unsubscribe();\n      expect(animationFrameScheduler.actions).to.have.length(1);\n      expect(cancelAnimationFrameStub).to.have.callCount(1);\n    });\n    b = animationFrameScheduler.schedule(() => {\n      sandbox.restore();\n      done();\n    });\n  });","file":"schedulers/AnimationFrameScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["Scheduler.asap"],"updatePoint":{"line":20,"column":18},"line":20,"code":"  it('should exist', () => {\n    expect(asap).exist;\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should act like the async scheduler if delay > 0","suites":["Scheduler.asap"],"updatePoint":{"line":24,"column":54},"line":24,"code":"  it('should act like the async scheduler if delay > 0', () => {\n    testScheduler.run(({ cold, expectObservable, time }) => {\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const b = cold('  b            ');\n      const tb = time(' --------|    ');\n      const expected = '----a---b----';\n\n      const result = merge(\n        a.pipe(delay(ta, asap)),\n        b.pipe(delay(tb, asap))\n      );\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should cancel asap actions when delay > 0","suites":["Scheduler.asap"],"updatePoint":{"line":40,"column":47},"line":40,"code":"  it('should cancel asap actions when delay > 0', () => {\n    testScheduler.run(({ cold, expectObservable, flush, time }) => {\n      const sandbox = sinon.createSandbox();\n      const setImmediateSpy = sandbox.spy(immediateProvider, 'setImmediate');\n      const setSpy = sandbox.spy(intervalProvider, 'setInterval');\n      const clearSpy = sandbox.spy(intervalProvider, 'clearInterval');\n\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const subs = '    ^-!          ';\n      const expected = '-------------';\n\n      const result = merge(\n        a.pipe(delay(ta, asap))\n      );\n      expectObservable(result, subs).toBe(expected);\n\n      flush();\n      expect(setImmediateSpy).to.have.not.been.called;\n      expect(setSpy).to.have.been.calledOnce;\n      expect(clearSpy).to.have.been.calledOnce;\n      sandbox.restore();\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should reuse the interval for recursively scheduled actions with the same delay","suites":["Scheduler.asap"],"updatePoint":{"line":65,"column":85},"line":65,"code":"  it('should reuse the interval for recursively scheduled actions with the same delay', () => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    // callThrough is missing from the declarations installed by the typings tool in stable\n    const stubSetInterval = (<any> sandbox.stub(global, 'setInterval')).callThrough();\n    const period = 50;\n    const state = { index: 0, period };\n    type State = typeof state;\n    function dispatch(this: SchedulerAction<State>, state: State): void {\n      state.index += 1;\n      if (state.index < 3) {\n        this.schedule(state, state.period);\n      }\n    }\n    asap.schedule(dispatch as any, period, state);\n    expect(state).to.have.property('index', 0);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 1);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 2);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    sandbox.restore();\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should not reuse the interval for recursively scheduled actions with a different delay","suites":["Scheduler.asap"],"updatePoint":{"line":91,"column":92},"line":91,"code":"  it('should not reuse the interval for recursively scheduled actions with a different delay', () => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n    // callThrough is missing from the declarations installed by the typings tool in stable\n    const stubSetInterval = (<any> sandbox.stub(global, 'setInterval')).callThrough();\n    const period = 50;\n    const state = { index: 0, period };\n    type State = typeof state;\n    function dispatch(this: SchedulerAction<State>, state: State): void {\n      state.index += 1;\n      state.period -= 1;\n      if (state.index < 3) {\n        this.schedule(state, state.period);\n      }\n    }\n    asap.schedule(dispatch as any, period, state);\n    expect(state).to.have.property('index', 0);\n    expect(stubSetInterval).to.have.property('callCount', 1);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 1);\n    expect(stubSetInterval).to.have.property('callCount', 2);\n    fakeTimer.tick(period);\n    expect(state).to.have.property('index', 2);\n    expect(stubSetInterval).to.have.property('callCount', 3);\n    sandbox.restore();\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule an action to happen later","suites":["Scheduler.asap"],"updatePoint":{"line":118,"column":47},"line":118,"code":"  it('should schedule an action to happen later', (done) => {\n    let actionHappened = false;\n    asap.schedule(() => {\n      actionHappened = true;\n      done();\n    });\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    }\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute recursively scheduled actions in separate asynchronous contexts","suites":["Scheduler.asap"],"updatePoint":{"line":129,"column":84},"line":129,"code":"  it('should execute recursively scheduled actions in separate asynchronous contexts', (done) => {\n    let syncExec1 = true;\n    let syncExec2 = true;\n    asap.schedule(function (index) {\n      if (index === 0) {\n        this.schedule(1);\n        asap.schedule(() => { syncExec1 = false; });\n      } else if (index === 1) {\n        this.schedule(2);\n        asap.schedule(() => { syncExec2 = false; });\n      } else if (index === 2) {\n        this.schedule(3);\n      } else if (index === 3) {\n        if (!syncExec1 && !syncExec2) {\n          done();\n        } else {\n          done(new Error('Execution happened synchronously.'));\n        }\n      }\n    }, 0, 0);\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should cancel the setImmediate if all scheduled actions unsubscribe before it executes","suites":["Scheduler.asap"],"updatePoint":{"line":151,"column":92},"line":151,"code":"  it('should cancel the setImmediate if all scheduled actions unsubscribe before it executes', (done) => {\n    let asapExec1 = false;\n    let asapExec2 = false;\n    const action1 = asap.schedule(() => { asapExec1 = true; });\n    const action2 = asap.schedule(() => { asapExec2 = true; });\n    expect(asap._scheduled).to.exist;\n    expect(asap.actions.length).to.equal(2);\n    action1.unsubscribe();\n    action2.unsubscribe();\n    expect(asap.actions.length).to.equal(0);\n    expect(asap._scheduled).to.equal(undefined);\n    asap.schedule(() => {\n      expect(asapExec1).to.equal(false);\n      expect(asapExec2).to.equal(false);\n      done();\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute the rest of the scheduled actions if the first action is canceled","suites":["Scheduler.asap"],"updatePoint":{"line":169,"column":86},"line":169,"code":"  it('should execute the rest of the scheduled actions if the first action is canceled', (done) => {\n    let actionHappened = false;\n    let secondSubscription: Subscription | null = null;\n\n    const firstSubscription = asap.schedule(() => {\n      actionHappened = true;\n      if (secondSubscription) {\n        secondSubscription.unsubscribe();\n      }\n      done(new Error('The first action should not have executed.'));\n    });\n\n    secondSubscription = asap.schedule(() => {\n      if (!actionHappened) {\n        done();\n      }\n    });\n\n    if (actionHappened) {\n      done(new Error('Scheduled action happened synchronously'));\n    } else {\n      firstSubscription.unsubscribe();\n    }\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should not execute rescheduled actions when flushing","suites":["Scheduler.asap"],"updatePoint":{"line":194,"column":58},"line":194,"code":"  it('should not execute rescheduled actions when flushing', (done) => {\n    let flushCount = 0;\n    let scheduledIndices: number[] = [];\n\n    let originalFlush = asap.flush;\n    asap.flush = (...args) => {\n      ++flushCount;\n      originalFlush.apply(asap, args);\n      if (flushCount === 2) {\n        asap.flush = originalFlush;\n        try {\n          expect(scheduledIndices).to.deep.equal([0, 1]);\n          done();\n        } catch (error) {\n          done(error);\n        }\n      }\n    };\n\n    asap.schedule(function (index) {\n      if (flushCount < 2) {\n        this.schedule(index! + 1);\n        scheduledIndices.push(index! + 1);\n      }\n    }, 0, 0);\n    scheduledIndices.push(0);\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute actions scheduled when flushing in a subsequent flush","suites":["Scheduler.asap"],"updatePoint":{"line":222,"column":74},"line":222,"code":"  it('should execute actions scheduled when flushing in a subsequent flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = (sandbox.stub(asapScheduler, 'flush')).callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      c = asapScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n    });\n    b = asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed","suites":["Scheduler.asap"],"updatePoint":{"line":243,"column":109},"line":243,"code":"  it('should execute actions scheduled when flushing in a subsequent flush when some actions are unsubscribed', (done) => {\n    const sandbox = sinon.createSandbox();\n    const stubFlush = (sandbox.stub(asapScheduler, 'flush')).callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = asapScheduler.schedule(() => {\n      expect(stubFlush).to.have.callCount(1);\n      c = asapScheduler.schedule(() => {\n        expect(stubFlush).to.have.callCount(2);\n        sandbox.restore();\n        done();\n      });\n      b.unsubscribe();\n    });\n    b = asapScheduler.schedule(() => {\n      done(new Error('Unexpected execution of b'));\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should properly cancel an unnecessary flush","suites":["Scheduler.asap"],"updatePoint":{"line":265,"column":49},"line":265,"code":"  it('should properly cancel an unnecessary flush', (done) => {\n    const sandbox = sinon.createSandbox();\n    const clearImmediateStub = sandbox.stub(immediateProvider, 'clearImmediate').callThrough();\n\n    let a: Subscription;\n    let b: Subscription;\n    let c: Subscription;\n\n    a = asapScheduler.schedule(() => {\n      expect(asapScheduler.actions).to.have.length(1);\n      c = asapScheduler.schedule(() => {\n        done(new Error('Unexpected execution of c'));\n      });\n      expect(asapScheduler.actions).to.have.length(2);\n      // What we're testing here is that the unsubscription of action c effects\n      // the cancellation of the microtask in a scenario in which the actions\n      // queue is not empty - it contains action b.\n      c.unsubscribe();\n      expect(asapScheduler.actions).to.have.length(1);\n      expect(clearImmediateStub).to.have.callCount(1);\n    });\n    b = asapScheduler.schedule(() => {\n      sandbox.restore();\n      done();\n    });\n  });","file":"schedulers/AsapScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should be monkey patchable","suites":["dateTimestampProvider"],"updatePoint":{"line":12,"column":32},"line":12,"code":"  it('should be monkey patchable', () => {\n    let nowCalled = false;\n\n    global.Date = {\n      now() {\n        nowCalled = true;\n        return 0;\n      },\n    } as any;\n\n    dateTimestampProvider.now();\n\n    expect(nowCalled).to.be.true;\n  });","file":"schedulers/dateTimestampProvider-spec.ts","skipped":false,"dir":"spec"},{"name":"should be monkey patchable","suites":["intervalProvider"],"updatePoint":{"line":14,"column":32},"line":14,"code":"  it('should be monkey patchable', () => {\n    let setCalled = false;\n    let clearCalled = false;\n\n    global.setInterval = (() => {\n      setCalled = true;\n      return 0 as any;\n    }) as any; // TypeScript complains about a __promisify__ property\n    global.clearInterval = () => {\n      clearCalled = true;\n    };\n\n    const handle = intervalProvider.setInterval(() => {\n      /* noop */\n    });\n    intervalProvider.clearInterval(handle);\n\n    expect(setCalled).to.be.true;\n    expect(clearCalled).to.be.true;\n  });","file":"schedulers/intervalProvider-spec.ts","skipped":false,"dir":"spec"},{"name":"should act like the async scheduler if delay > 0","suites":["Scheduler.queue"],"updatePoint":{"line":18,"column":54},"line":18,"code":"  it('should act like the async scheduler if delay > 0', () => {\n    testScheduler.run(({ cold, expectObservable, time }) => {\n      const a = cold('  a            ');\n      const ta = time(' ----|        ');\n      const b = cold('  b            ');\n      const tb = time(' --------|    ');\n      const expected = '----a---b----';\n\n      const result = merge(\n        a.pipe(delay(ta, queue)),\n        b.pipe(delay(tb, queue))\n      );\n      expectObservable(result).toBe(expected);\n    });\n  });","file":"schedulers/QueueScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should switch from synchronous to asynchronous at will","suites":["Scheduler.queue"],"updatePoint":{"line":34,"column":60},"line":34,"code":"  it('should switch from synchronous to asynchronous at will', () => {\n    const sandbox = sinon.createSandbox();\n    const fakeTimer = sandbox.useFakeTimers();\n\n    let asyncExec = false;\n    let state: Array<number> = [];\n\n    queue.schedule(function (index) {\n      state.push(index!);\n      if (index === 0) {\n        this.schedule(1, 100);\n      } else if (index === 1) {\n        asyncExec = true;\n        this.schedule(2, 0);\n      }\n    }, 0, 0);\n\n    expect(asyncExec).to.be.false;\n    expect(state).to.be.deep.equal([0]);\n\n    fakeTimer.tick(100);\n\n    expect(asyncExec).to.be.true;\n    expect(state).to.be.deep.equal([0, 1, 2]);\n\n    sandbox.restore();\n  });","file":"schedulers/QueueScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe the rest of the scheduled actions if an action throws an error","suites":["Scheduler.queue"],"updatePoint":{"line":62,"column":87},"line":62,"code":"  it('should unsubscribe the rest of the scheduled actions if an action throws an error', () => {\n    const actions: Subscription[] = [];\n    let action2Exec = false;\n    let action3Exec = false;\n    let errorValue: any = undefined;\n    try {\n      queue.schedule(() => {\n        actions.push(\n          queue.schedule(() => { throw new Error('oops'); }),\n          queue.schedule(() => { action2Exec = true; }),\n          queue.schedule(() => { action3Exec = true; })\n        );\n      });\n    } catch (e) {\n      errorValue = e;\n    }\n    expect(actions.every((action) => action.closed)).to.be.true;\n    expect(action2Exec).to.be.false;\n    expect(action3Exec).to.be.false;\n    expect(errorValue).exist;\n    expect(errorValue.message).to.equal('oops');\n  });","file":"schedulers/QueueScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler"],"updatePoint":{"line":16,"column":18},"line":16,"code":"  it('should exist', () => {\n    expect(TestScheduler).exist;\n    expect(TestScheduler).to.be.a('function');\n  });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should have frameTimeFactor set initially","suites":["TestScheduler"],"updatePoint":{"line":21,"column":47},"line":21,"code":"  it('should have frameTimeFactor set initially', () => {\n    expect(TestScheduler.frameTimeFactor).to.equal(10);\n  });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a marble string into a series of notifications and types","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":26,"column":77},"line":26,"code":"    it('should parse a marble string into a series of notifications and types', () => {\n      const result = TestScheduler.parseMarbles('-------a---b---|', { a: 'A', b: 'B' });\n      expect(result).deep.equal([\n        { frame: 70, notification: nextNotification('A') },\n        { frame: 110, notification: nextNotification('B') },\n        { frame: 150, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a marble string, allowing spaces too","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":35,"column":57},"line":35,"code":"    it('should parse a marble string, allowing spaces too', () => {\n      const result = TestScheduler.parseMarbles('--a--b--|   ', { a: 'A', b: 'B' });\n      expect(result).deep.equal([\n        { frame: 20, notification: nextNotification('A') },\n        { frame: 50, notification: nextNotification('B') },\n        { frame: 80, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a marble string with a subscription point","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":44,"column":62},"line":44,"code":"    it('should parse a marble string with a subscription point', () => {\n      const result = TestScheduler.parseMarbles('---^---a---b---|', { a: 'A', b: 'B' });\n      expect(result).deep.equal([\n        { frame: 40, notification: nextNotification('A') },\n        { frame: 80, notification: nextNotification('B') },\n        { frame: 120, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a marble string with an error","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":53,"column":50},"line":53,"code":"    it('should parse a marble string with an error', () => {\n      const result = TestScheduler.parseMarbles('-------a---b---#', { a: 'A', b: 'B' }, 'omg error!');\n      expect(result).deep.equal([\n        { frame: 70, notification: nextNotification('A') },\n        { frame: 110, notification: nextNotification('B') },\n        { frame: 150, notification: errorNotification('omg error!') }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should default in the letter for the value if no value hash was passed","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":62,"column":78},"line":62,"code":"    it('should default in the letter for the value if no value hash was passed', () => {\n      const result = TestScheduler.parseMarbles('--a--b--c--');\n      expect(result).deep.equal([\n        { frame: 20, notification: nextNotification('a') },\n        { frame: 50, notification: nextNotification('b') },\n        { frame: 80, notification: nextNotification('c') },\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle grouped values","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":71,"column":36},"line":71,"code":"    it('should handle grouped values', () => {\n      const result = TestScheduler.parseMarbles('---(abc)---');\n      expect(result).deep.equal([\n        { frame: 30, notification: nextNotification('a') },\n        { frame: 30, notification: nextNotification('b') },\n        { frame: 30, notification: nextNotification('c') }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore whitespace when runMode=true","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":80,"column":50},"line":80,"code":"    it('should ignore whitespace when runMode=true', () => {\n      const runMode = true;\n      const result = TestScheduler.parseMarbles('  -a - b -    c |       ', { a: 'A', b: 'B', c: 'C' }, undefined, undefined, runMode);\n      expect(result).deep.equal([\n        { frame: 10, notification: nextNotification('A') },\n        { frame: 30, notification: nextNotification('B') },\n        { frame: 50, notification: nextNotification('C') },\n        { frame: 60, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support time progression syntax when runMode=true","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":91,"column":64},"line":91,"code":"    it('should support time progression syntax when runMode=true', () => {\n      const runMode = true;\n      const result = TestScheduler.parseMarbles('10.2ms a 1.2s b 1m c|', { a: 'A', b: 'B', c: 'C' }, undefined, undefined, runMode);\n      expect(result).deep.equal([\n        { frame: 10.2, notification: nextNotification('A') },\n        { frame: 10.2 + 10 + (1.2 * 1000), notification: nextNotification('B') },\n        { frame: 10.2 + 10 + (1.2 * 1000) + 10 + (1000 * 60), notification: nextNotification('C') },\n        { frame: 10.2 + 10 + (1.2 * 1000) + 10 + (1000 * 60) + 10, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support emoji characters","suites":["TestScheduler","parseMarbles()"],"updatePoint":{"line":102,"column":39},"line":102,"code":"    it('should support emoji characters', () => {\n      const result = TestScheduler.parseMarbles('--------|');\n      expect(result).deep.equal([\n        { frame: 20, notification: nextNotification('') },\n        { frame: 50, notification: nextNotification('') },\n        { frame: 80, notification: nextNotification('') },\n        { frame: 110, notification: COMPLETE_NOTIFICATION }\n      ]);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a subscription marble string into a subscriptionLog","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":114,"column":72},"line":114,"code":"    it('should parse a subscription marble string into a subscriptionLog', () => {\n      const result = TestScheduler.parseMarblesAsSubscriptions('---^---!-');\n      expect(result.subscribedFrame).to.equal(30);\n      expect(result.unsubscribedFrame).to.equal(70);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a subscription marble string with an unsubscription","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":120,"column":72},"line":120,"code":"    it('should parse a subscription marble string with an unsubscription', () => {\n      const result = TestScheduler.parseMarblesAsSubscriptions('---^-');\n      expect(result.subscribedFrame).to.equal(30);\n      expect(result.unsubscribedFrame).to.equal(Infinity);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a subscription marble string with a synchronous unsubscription","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":126,"column":83},"line":126,"code":"    it('should parse a subscription marble string with a synchronous unsubscription', () => {\n      const result = TestScheduler.parseMarblesAsSubscriptions('---(^!)-');\n      expect(result.subscribedFrame).to.equal(30);\n      expect(result.unsubscribedFrame).to.equal(30);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore whitespace when runMode=true","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":132,"column":50},"line":132,"code":"    it('should ignore whitespace when runMode=true', () => {\n      const runMode = true;\n      const result = TestScheduler.parseMarblesAsSubscriptions('  - -  - -  ^ -   - !  -- -      ', runMode);\n      expect(result.subscribedFrame).to.equal(40);\n      expect(result.unsubscribedFrame).to.equal(70);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support time progression syntax when runMode=true","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":139,"column":64},"line":139,"code":"    it('should support time progression syntax when runMode=true', () => {\n      const runMode = true;\n      const result = TestScheduler.parseMarblesAsSubscriptions('10.2ms ^ 1.2s - 1m !', runMode);\n      expect(result.subscribedFrame).to.equal(10.2);\n      expect(result.unsubscribedFrame).to.equal(10.2 + 10 + (1.2 * 1000) + 10 + (1000 * 60));\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if found more than one subscription point","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":146,"column":62},"line":146,"code":"    it('should throw if found more than one subscription point', () => {\n      expect(() => TestScheduler.parseMarblesAsSubscriptions('---^-^-!-')).to.throw();\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if found more than one unsubscription point","suites":["TestScheduler","parseMarblesAsSubscriptions()"],"updatePoint":{"line":150,"column":64},"line":150,"code":"    it('should throw if found more than one unsubscription point', () => {\n      expect(() => TestScheduler.parseMarblesAsSubscriptions('---^---!-!')).to.throw();\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a simple time marble string to a number","suites":["TestScheduler","createTime()"],"updatePoint":{"line":156,"column":60},"line":156,"code":"    it('should parse a simple time marble string to a number', () => {\n      const scheduler = new TestScheduler(null!);\n      const time = scheduler.createTime('-----|');\n      expect(time).to.equal(50);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should progress time with whitespace","suites":["TestScheduler","createTime()"],"updatePoint":{"line":162,"column":44},"line":162,"code":"    it('should progress time with whitespace', () => {\n      const scheduler = new TestScheduler(null!);\n      const time = scheduler.createTime('     |');\n      //                                 -----|\n      expect(time).to.equal(50);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should progress time with mix of whitespace and dashes","suites":["TestScheduler","createTime()"],"updatePoint":{"line":169,"column":62},"line":169,"code":"    it('should progress time with mix of whitespace and dashes', () => {\n      const scheduler = new TestScheduler(null!);\n      const time = scheduler.createTime('  --|');\n      expect(time).to.equal(40);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if not given good marble input","suites":["TestScheduler","createTime()"],"updatePoint":{"line":175,"column":51},"line":175,"code":"    it('should throw if not given good marble input', () => {\n      const scheduler = new TestScheduler(null!);\n      expect(() => {\n        scheduler.createTime('-a-b-#');\n      }).to.throw();\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable","suites":["TestScheduler","createColdObservable()"],"updatePoint":{"line":184,"column":39},"line":184,"code":"    it('should create a cold observable', () => {\n      const expected = ['A', 'B'];\n      const scheduler = new TestScheduler(null!);\n      const source = scheduler.createColdObservable('--a---b--|', { a: 'A', b: 'B' });\n      expect(source).to.be.an.instanceOf(Observable);\n      source.subscribe(x => {\n        expect(x).to.equal(expected.shift());\n      });\n      scheduler.flush();\n      expect(expected.length).to.equal(0);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a hot observable","suites":["TestScheduler","createHotObservable()"],"updatePoint":{"line":198,"column":38},"line":198,"code":"    it('should create a hot observable', () => {\n      const expected = ['A', 'B'];\n      const scheduler = new TestScheduler(null!);\n      const source = scheduler.createHotObservable('--a---b--|', { a: 'A', b: 'B' });\n      expect(source).to.be.an.instanceof(Subject);\n      source.subscribe(x => {\n        expect(x).to.equal(expected.shift());\n      });\n      scheduler.flush();\n      expect(expected.length).to.equal(0);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","rxTestScheduler"],"updatePoint":{"line":213,"column":22},"line":213,"code":"      it('should exist', () => {\n        expect(rxTestScheduler).to.be.an.instanceof(TestScheduler);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","cold()"],"updatePoint":{"line":219,"column":22},"line":219,"code":"      it('should exist', () => {\n        expect(cold).to.exist;\n        expect(cold).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a cold observable","suites":["TestScheduler","jasmine helpers","cold()"],"updatePoint":{"line":224,"column":41},"line":224,"code":"      it('should create a cold observable', () => {\n        const expected = [1, 2];\n        const source = cold('-a-b-|', { a: 1, b: 2 });\n        source.subscribe({ next: (x: number) => {\n          expect(x).to.equal(expected.shift());\n        }, complete: () => {\n          expect(expected.length).to.equal(0);\n        } });\n        expectObservable(source).toBe('-a-b-|', { a: 1, b: 2 });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","hot()"],"updatePoint":{"line":237,"column":22},"line":237,"code":"      it('should exist', () => {\n        expect(hot).to.exist;\n        expect(hot).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a hot observable","suites":["TestScheduler","jasmine helpers","hot()"],"updatePoint":{"line":242,"column":40},"line":242,"code":"      it('should create a hot observable', () => {\n        const source = hot('---^-a-b-|', { a: 1, b: 2 });\n        expect(source).to.be.an.instanceOf(Subject);\n        expectObservable(source).toBe('--a-b-|', { a: 1, b: 2 });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","time()"],"updatePoint":{"line":250,"column":22},"line":250,"code":"      it('should exist', () => {\n        expect(time).to.exist;\n        expect(time).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a simple time marble string to a number","suites":["TestScheduler","jasmine helpers","time()"],"updatePoint":{"line":255,"column":62},"line":255,"code":"      it('should parse a simple time marble string to a number', () => {\n        expect(time('-----|')).to.equal(50);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":261,"column":22},"line":261,"code":"      it('should exist', () => {\n        expect(expectObservable).to.exist;\n        expect(expectObservable).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should return an object with a toBe function","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":266,"column":54},"line":266,"code":"      it('should return an object with a toBe function', () => {\n        expect(expectObservable(of(1)).toBe).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should append to flushTests array","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":270,"column":43},"line":270,"code":"      it('should append to flushTests array', () => {\n        expectObservable(EMPTY);\n        expect((<any>rxTestScheduler).flushTests.length).to.equal(1);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle empty","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":275,"column":29},"line":275,"code":"      it('should handle empty', () => {\n        expectObservable(EMPTY).toBe('|', {});\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle never","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":279,"column":29},"line":279,"code":"      it('should handle never', () => {\n        expectObservable(NEVER).toBe('-', {});\n        expectObservable(NEVER).toBe('---', {});\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept an unsubscription marble diagram","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":284,"column":56},"line":284,"code":"      it('should accept an unsubscription marble diagram', () => {\n        const source = hot('---^-a-b-|');\n        const unsubscribe  =  '---!';\n        const expected =      '--a';\n        expectObservable(source, unsubscribe).toBe(expected);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should accept a subscription marble diagram","suites":["TestScheduler","jasmine helpers","expectObservable()"],"updatePoint":{"line":291,"column":53},"line":291,"code":"      it('should accept a subscription marble diagram', () => {\n        const source = hot('-a-b-c|');\n        const subscribe =  '---^';\n        const expected =   '---b-c|';\n        expectObservable(source, subscribe).toBe(expected);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":300,"column":22},"line":300,"code":"      it('should exist', () => {\n        expect(expectSubscriptions).to.exist;\n        expect(expectSubscriptions).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should return an object with a toBe function","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":305,"column":54},"line":305,"code":"      it('should return an object with a toBe function', () => {\n        expect(expectSubscriptions([]).toBe).to.be.a('function');\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should append to flushTests array","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":309,"column":43},"line":309,"code":"      it('should append to flushTests array', () => {\n        expectSubscriptions([]);\n        expect((<any>rxTestScheduler).flushTests.length).to.equal(1);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should assert subscriptions of a cold observable","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":314,"column":58},"line":314,"code":"      it('should assert subscriptions of a cold observable', () => {\n        const source = cold('---a---b-|');\n        const subs =        '^--------!';\n        expectSubscriptions(source.subscriptions).toBe(subs);\n        source.subscribe();\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support empty subscription marbles","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":321,"column":51},"line":321,"code":"      it('should support empty subscription marbles', () => {\n        const source = cold('---a---b-|');\n        const subs =        '----------';\n        expectSubscriptions(source.subscriptions).toBe(subs);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support empty subscription marbles within arrays","suites":["TestScheduler","jasmine helpers","expectSubscriptions()"],"updatePoint":{"line":327,"column":65},"line":327,"code":"      it('should support empty subscription marbles within arrays', () => {\n        const source = cold('---a---b-|');\n        const subs =       ['----------'];\n        expectSubscriptions(source.subscriptions).toBe(subs);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should be awesome","suites":["TestScheduler","jasmine helpers","end-to-end helper tests"],"updatePoint":{"line":335,"column":27},"line":335,"code":"      it('should be awesome', () => {\n        const values = { a: 1, b: 2 };\n        const myObservable = cold('---a---b--|', values);\n        const subs =              '^---------!';\n        expectObservable(myObservable).toBe('---a---b--|', values);\n        expectSubscriptions(myObservable.subscriptions).toBe(subs);\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support testing metastreams","suites":["TestScheduler","jasmine helpers","end-to-end helper tests"],"updatePoint":{"line":343,"column":44},"line":343,"code":"      it('should support testing metastreams', () => {\n        const x = cold('-a-b|');\n        const y = cold('-c-d|');\n        const myObservable = hot('---x---y----|', { x: x, y: y });\n        const expected =         '---x---y----|';\n        const expectedx = cold('-a-b|');\n        const expectedy = cold('-c-d|');\n        expectObservable(myObservable).toBe(expected, { x: expectedx, y: expectedy });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore whitespace","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":361,"column":34},"line":361,"code":"      it('should ignore whitespace', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n\n        testScheduler.run(({ cold, expectObservable, expectSubscriptions }) => {\n          const input = cold('  -a - b -    c |       ');\n          const output = input.pipe(\n            concatMap(d => of(d).pipe(\n              delay(10)\n            ))\n          );\n          const expected = '     -- 9ms a 9ms b 9ms (c|) ';\n\n          expectObservable(output).toBe(expected);\n          expectSubscriptions(input.subscriptions).toBe('  ^- - - - - !');\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support time progression syntax","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":378,"column":48},"line":378,"code":"      it('should support time progression syntax', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n\n        testScheduler.run(({ cold, hot, flush, expectObservable, expectSubscriptions }) => {\n          const output = cold('10.2ms a 1.2s b 1m c|');\n          const expected = '   10.2ms a 1.2s b 1m c|';\n\n          expectObservable(output).toBe(expected);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should provide the correct helpers","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":390,"column":42},"line":390,"code":"    it('should provide the correct helpers', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(({ cold, hot, flush, expectObservable, expectSubscriptions }) => {\n        expect(cold).to.be.a('function');\n        expect(hot).to.be.a('function');\n        expect(flush).to.be.a('function');\n        expect(expectObservable).to.be.a('function');\n        expect(expectSubscriptions).to.be.a('function');\n\n      const obs1 = cold('-a-c-e|');\n        const obs2 = hot(' ^-b-d-f|');\n        const output = merge(obs1, obs2);\n        const expected = ' -abcdef|';\n\n        expectObservable(output).toBe(expected);\n        expectObservable(output).toEqual(cold(expected));\n        // There are two subscriptions to each of these, because we merged\n        // them together, then we subscribed to the merged result once\n        // to check `toBe` and another time to check `toEqual`.\n        expectSubscriptions(obs1.subscriptions).toBe(['^-----!', '^-----!']);\n        expectSubscriptions(obs2.subscriptions).toBe(['^------!', '^------!']);\n      });\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should have each frame represent a single virtual millisecond","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":415,"column":69},"line":415,"code":"    it('should have each frame represent a single virtual millisecond', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(({ cold, expectObservable }) => {\n        const output = cold('-a-b-c--------|').pipe(\n          debounceTime(5)\n        );\n        const expected = '   ------ 4ms c---|';\n        expectObservable(output).toBe(expected);\n      });\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should have no maximum frame count","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":427,"column":42},"line":427,"code":"    it('should have no maximum frame count', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(({ cold, expectObservable }) => {\n        const output = cold('-a|').pipe(\n          delay(1000 * 10)\n        );\n        const expected = '   - 10s (a|)';\n        expectObservable(output).toBe(expected);\n      });\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should make operators that use AsyncScheduler automatically use TestScheduler for actual scheduling","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":439,"column":107},"line":439,"code":"    it('should make operators that use AsyncScheduler automatically use TestScheduler for actual scheduling', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(({ cold, expectObservable }) => {\n        const output = cold('-a-b-c--------|').pipe(\n          debounceTime(5)\n        );\n        const expected = '   ----------c---|';\n        expectObservable(output).toBe(expected);\n      });\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should flush automatically","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":451,"column":34},"line":451,"code":"    it('should flush automatically', () => {\n      const testScheduler = new TestScheduler((actual, expected) => {\n        expect(actual).deep.equal(expected);\n      });\n      testScheduler.run(({ cold, expectObservable }) => {\n        const output = cold('-a-b-c|').pipe(\n          concatMap(d => of(d).pipe(\n            delay(10)\n          ))\n        );\n        const expected = '   -- 9ms a 9ms b 9ms (c|)';\n        expectObservable(output).toBe(expected);\n\n        expect(testScheduler['flushTests'].length).to.equal(1);\n        expect(testScheduler['actions'].length).to.equal(1);\n      });\n\n      expect(testScheduler['flushTests'].length).to.equal(0);\n      expect(testScheduler['actions'].length).to.equal(0);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support explicit flushing","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":472,"column":40},"line":472,"code":"    it('should support explicit flushing', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(({ cold, expectObservable, flush }) => {\n        const output = cold('-a-b-c|').pipe(\n          concatMap(d => of(d).pipe(\n            delay(10)\n          ))\n        );\n        const expected = '   -- 9ms a 9ms b 9ms (c|)';\n        expectObservable(output).toBe(expected);\n\n        expect(testScheduler['flushTests'].length).to.equal(1);\n        expect(testScheduler['actions'].length).to.equal(1);\n\n        flush();\n\n        expect(testScheduler['flushTests'].length).to.equal(0);\n        expect(testScheduler['actions'].length).to.equal(0);\n      });\n\n      expect(testScheduler['flushTests'].length).to.equal(0);\n      expect(testScheduler['actions'].length).to.equal(0);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should pass-through return values, e.g. Promises","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":497,"column":56},"line":497,"code":"    it('should pass-through return values, e.g. Promises', (done) => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      testScheduler.run(() => {\n        return Promise.resolve('foo');\n      }).then(value => {\n        expect(value).to.equal('foo');\n        done();\n      });\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should restore changes upon thrown errors","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":508,"column":49},"line":508,"code":"    it('should restore changes upon thrown errors', () => {\n      const testScheduler = new TestScheduler(assertDeepEquals);\n\n      const frameTimeFactor = TestScheduler['frameTimeFactor'];\n      const maxFrames = testScheduler.maxFrames;\n      const runMode = testScheduler['runMode'];\n\n      try {\n        testScheduler.run(() => {\n          throw new Error('kaboom!');\n        });\n      } catch { /* empty */ }\n\n      expect(TestScheduler['frameTimeFactor']).to.equal(frameTimeFactor);\n      expect(testScheduler.maxFrames).to.equal(maxFrames);\n      expect(testScheduler['runMode']).to.equal(runMode);\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should flush expectations correctly","suites":["TestScheduler","TestScheduler.run()","marble diagrams"],"updatePoint":{"line":526,"column":43},"line":526,"code":"    it('should flush expectations correctly', () => {\n      expect(() => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ cold, expectObservable, flush }) => {\n          expectObservable(cold('-x')).toBe('-x');\n          expectObservable(cold('-y')).toBe('-y');\n          const expectation = expectObservable(cold('-z'));\n          flush();\n          expectation.toBe('-q');\n        });\n      }).to.throw();\n    });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if animate() is not called when needed","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":540,"column":61},"line":540,"code":"      it('should throw if animate() is not called when needed', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        expect(() => testScheduler.run(() => {\n          animationFrameProvider.schedule(() => { /* pointless lint rule */ });\n        })).to.throw();\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if animate() is called more than once","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":547,"column":60},"line":547,"code":"      it('should throw if animate() is called more than once', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        expect(() => testScheduler.run(({ animate }) => {\n          animate('--x');\n          animate('--x');\n        })).to.throw();\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if animate() completes","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":555,"column":45},"line":555,"code":"      it('should throw if animate() completes', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        expect(() => testScheduler.run(({ animate }) => {\n          animate('--|');\n        })).to.throw();\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if animate() errors","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":562,"column":42},"line":562,"code":"      it('should throw if animate() errors', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        expect(() => testScheduler.run(({ animate }) => {\n          animate('--#');\n        })).to.throw();\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule async requests within animate()","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":569,"column":57},"line":569,"code":"      it('should schedule async requests within animate()', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ animate }) => {\n          animate('--x');\n\n          const values: string[] = [];\n          const { schedule } = animationFrameProvider;\n\n          testScheduler.schedule(() => {\n            schedule(t => values.push(`a@${t}`));\n            expect(values).to.deep.equal([]);\n          }, 0);\n          testScheduler.schedule(() => {\n            schedule(t => values.push(`b@${t}`));\n            expect(values).to.deep.equal([]);\n          }, 1);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@2', 'b@2']);\n          }, 2);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule sync requests within animate()","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":591,"column":56},"line":591,"code":"      it('should schedule sync requests within animate()', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ animate }) => {\n          animate('--x');\n\n          const values: string[] = [];\n          const { schedule } = animationFrameProvider;\n\n          testScheduler.schedule(() => {\n            schedule(t => values.push(`a@${t}`));\n            schedule(t => values.push(`b@${t}`));\n            expect(values).to.deep.equal([]);\n          }, 1);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@2', 'b@2']);\n          }, 2);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support request cancellation within animate()","suites":["TestScheduler","TestScheduler.run()","animate"],"updatePoint":{"line":610,"column":62},"line":610,"code":"      it('should support request cancellation within animate()', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ animate }) => {\n          animate('--x');\n\n          const values: string[] = [];\n          const { schedule } = animationFrameProvider;\n\n          testScheduler.schedule(() => {\n            const subscription = schedule(t => values.push(`a@${t}`));\n            schedule(t => values.push(`b@${t}`));\n            subscription.unsubscribe();\n            expect(values).to.deep.equal([]);\n          }, 1);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['b@2']);\n          }, 2);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule immediates","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":632,"column":36},"line":632,"code":"      it('should schedule immediates', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setImmediate } = immediateProvider;\n          setImmediate(() => {\n            values.push(`a@${testScheduler.now()}`);\n          });\n          expect(values).to.deep.equal([]);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@0']);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support clearing immediates","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":647,"column":44},"line":647,"code":"      it('should support clearing immediates', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setImmediate, clearImmediate } = immediateProvider;\n          const handle = setImmediate(() => {\n            values.push(`a@${testScheduler.now()}`);\n          });\n          expect(values).to.deep.equal([]);\n          clearImmediate(handle);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal([]);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule intervals","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":663,"column":35},"line":663,"code":"      it('should schedule intervals', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setInterval, clearInterval } = intervalProvider;\n          const handle = setInterval(() => {\n            values.push(`a@${testScheduler.now()}`);\n            clearInterval(handle);\n          }, 1);\n          expect(values).to.deep.equal([]);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@1']);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should reschedule intervals until cleared","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":679,"column":51},"line":679,"code":"      it('should reschedule intervals until cleared', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setInterval, clearInterval } = intervalProvider;\n          const handle = setInterval(() => {\n            if (testScheduler.now() <= 3) {\n              values.push(`a@${testScheduler.now()}`);\n            } else {\n              clearInterval(handle);\n            }\n          }, 1);\n          expect(values).to.deep.equal([]);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@1', 'a@2', 'a@3']);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule timeouts","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":698,"column":34},"line":698,"code":"      it('should schedule timeouts', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setTimeout } = timeoutProvider;\n          setTimeout(() => {\n            values.push(`a@${testScheduler.now()}`);\n          }, 1);\n          expect(values).to.deep.equal([]);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['a@1']);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule immediates before intervals and timeouts","suites":["TestScheduler","TestScheduler.run()","immediate and interval"],"updatePoint":{"line":713,"column":66},"line":713,"code":"      it('should schedule immediates before intervals and timeouts', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(() => {\n          const values: string[] = [];\n          const { setImmediate } = immediateProvider;\n          const { setInterval, clearInterval } = intervalProvider;\n          const { setTimeout } = timeoutProvider;\n          const handle = setInterval(() => {\n            values.push(`a@${testScheduler.now()}`);\n            clearInterval(handle);\n          }, 0);\n          setTimeout(() => {\n            values.push(`b@${testScheduler.now()}`);\n          }, 0);\n          setImmediate(() => {\n            values.push(`c@${testScheduler.now()}`);\n          });\n          expect(values).to.deep.equal([]);\n          testScheduler.schedule(() => {\n            expect(values).to.deep.equal(['c@0', 'a@0', 'b@0']);\n          }, 10);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support animationFrame, async and asap schedulers","suites":["TestScheduler","TestScheduler.run()","schedulers"],"updatePoint":{"line":739,"column":66},"line":739,"code":"      it('should support animationFrame, async and asap schedulers', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ animate, cold, expectObservable, time }) => {\n          animate('            ---------x');\n          const mapped = cold('--m-------');\n          const tb = time('      -----|  ');\n          const expected = '   --(dc)-b-a';\n          const result = mapped.pipe(mergeMap(() => merge(\n            of('a').pipe(delay(0, animationFrameScheduler)),\n            of('b').pipe(delay(tb, asyncScheduler)),\n            of('c').pipe(delay(0, asyncScheduler)),\n            of('d').pipe(delay(0, asapScheduler))\n          )));\n          expectObservable(result).toBe(expected);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit asap notifications before async notifications","suites":["TestScheduler","TestScheduler.run()","schedulers"],"updatePoint":{"line":756,"column":67},"line":756,"code":"      it('should emit asap notifications before async notifications', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ cold, expectObservable }) => {\n          const mapped = cold('--ab------');\n          const expected = '   ---(ba)---';\n          const result = mapped.pipe(mergeMap((value) => value === 'a'\n            ? of(value).pipe(delay(1, asyncScheduler))\n            : of(value).pipe(delay(0, asapScheduler))\n          ));\n          expectObservable(result).toBe(expected);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support intervals with zero duration","suites":["TestScheduler","TestScheduler.run()","schedulers"],"updatePoint":{"line":769,"column":53},"line":769,"code":"      it('should support intervals with zero duration', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n        testScheduler.run(({ cold, expectObservable }) => {\n          const mapped = cold('--m-------');\n          const expected = '   --(bbbaaa)';\n          const result = mapped.pipe(mergeMap(() => merge(\n            interval(0, asyncScheduler).pipe(mapTo('a'), take(3)),\n            interval(0, asapScheduler).pipe(mapTo('b'), take(3))\n          )));\n          expectObservable(result).toBe(expected);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should parse a simple time marble string to a number","suites":["TestScheduler","TestScheduler.run()","time"],"updatePoint":{"line":784,"column":62},"line":784,"code":"      it('should parse a simple time marble string to a number', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n\n        testScheduler.run(({ time }) => {\n          const t = time('--|');\n          expect(t).to.equal(2);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore whitespace","suites":["TestScheduler","TestScheduler.run()","time"],"updatePoint":{"line":793,"column":34},"line":793,"code":"      it('should ignore whitespace', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n\n        testScheduler.run(({ time }) => {\n          const t = time('  --|');\n          expect(t).to.equal(2);\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if not given good marble input","suites":["TestScheduler","TestScheduler.run()","time"],"updatePoint":{"line":802,"column":53},"line":802,"code":"      it('should throw if not given good marble input', () => {\n        const testScheduler = new TestScheduler(assertDeepEquals);\n\n        testScheduler.run(({ time }) => {\n          expect(() => {\n            time('-a-b-#');\n          }).to.throw();\n        });\n      });","file":"schedulers/TestScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should be monkey patchable","suites":["timeoutProvider"],"updatePoint":{"line":14,"column":32},"line":14,"code":"  it('should be monkey patchable', () => {\n    let setCalled = false;\n    let clearCalled = false;\n\n    global.setTimeout = (() => {\n      setCalled = true;\n      return 0 as any;\n    }) as any;\n    global.clearTimeout = () => {\n      clearCalled = true;\n    };\n\n    const handle = timeoutProvider.setTimeout(() => {\n      /* noop */\n    });\n    timeoutProvider.clearTimeout(handle);\n\n    expect(setCalled).to.be.true;\n    expect(clearCalled).to.be.true;\n  });","file":"schedulers/timeoutProvider-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["VirtualTimeScheduler"],"updatePoint":{"line":6,"column":18},"line":6,"code":"  it('should exist', () => {\n    expect(VirtualTimeScheduler).exist;\n    expect(VirtualTimeScheduler).to.be.a('function');\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things in order when flushed if each this is scheduled synchrously","suites":["VirtualTimeScheduler"],"updatePoint":{"line":11,"column":88},"line":11,"code":"  it('should schedule things in order when flushed if each this is scheduled synchrously', () => {\n    const v = new VirtualTimeScheduler();\n    const invoked: number[] = [];\n    const invoke: any = (state: number) => {\n      invoked.push(state);\n    };\n    v.schedule(invoke, 0, 1);\n    v.schedule(invoke, 0, 2);\n    v.schedule(invoke, 0, 3);\n    v.schedule(invoke, 0, 4);\n    v.schedule(invoke, 0, 5);\n\n    v.flush();\n\n    expect(invoked).to.deep.equal([1, 2, 3, 4, 5]);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things in order when flushed if each this is scheduled at random","suites":["VirtualTimeScheduler"],"updatePoint":{"line":28,"column":86},"line":28,"code":"  it('should schedule things in order when flushed if each this is scheduled at random', () => {\n    const v = new VirtualTimeScheduler();\n    const invoked: number[] = [];\n    const invoke: any = (state: number) => {\n      invoked.push(state);\n    };\n    v.schedule(invoke, 0, 1);\n    v.schedule(invoke, 100, 2);\n    v.schedule(invoke, 0, 3);\n    v.schedule(invoke, 500, 4);\n    v.schedule(invoke, 0, 5);\n    v.schedule(invoke, 100, 6);\n\n    v.flush();\n\n    expect(invoked).to.deep.equal([1, 3, 5, 2, 6, 4]);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule things in order when there are negative delays","suites":["VirtualTimeScheduler"],"updatePoint":{"line":46,"column":68},"line":46,"code":"  it('should schedule things in order when there are negative delays', () => {\n    const v = new VirtualTimeScheduler();\n    const invoked: number[] = [];\n    const invoke: any = (state: number) => {\n      invoked.push(state);\n    };\n    v.schedule(invoke, 0, 1);\n    v.schedule(invoke, 100, 2);\n    v.schedule(invoke, 0, 3);\n    v.schedule(invoke, -2, 4);\n    v.schedule(invoke, 0, 5);\n    v.schedule(invoke, -10, 6);\n\n    v.flush();\n\n    expect(invoked).to.deep.equal([6, 4, 1, 3, 5, 2]);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should support recursive scheduling","suites":["VirtualTimeScheduler"],"updatePoint":{"line":64,"column":41},"line":64,"code":"  it('should support recursive scheduling', () => {\n    const v = new VirtualTimeScheduler();\n    let count = 0;\n    const expected = [100, 200, 300];\n\n    v.schedule<string>(function (this: SchedulerAction<string>, state?: string) {\n      if (++count === 3) {\n        return;\n      }\n      const virtualAction = this as VirtualAction<string>;\n      expect(virtualAction.delay).to.equal(expected.shift());\n      this.schedule(state, virtualAction.delay);\n    }, 100, 'test');\n\n    v.flush();\n    expect(count).to.equal(3);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should not execute virtual actions that have been rescheduled before flush","suites":["VirtualTimeScheduler"],"updatePoint":{"line":82,"column":80},"line":82,"code":"  it('should not execute virtual actions that have been rescheduled before flush', () => {\n    const v = new VirtualTimeScheduler();\n    const messages: string[] = [];\n\n    const action: VirtualAction<string> = <VirtualAction<string>> v.schedule(\n      state => messages.push(state!),\n      10,\n      'first message'\n    );\n\n    action.schedule('second message', 10);\n    v.flush();\n\n    expect(messages).to.deep.equal(['second message']);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should execute only those virtual actions that fall into the maxFrames timespan","suites":["VirtualTimeScheduler"],"updatePoint":{"line":98,"column":85},"line":98,"code":"  it('should execute only those virtual actions that fall into the maxFrames timespan', function () {\n    const MAX_FRAMES = 50;\n    const v = new VirtualTimeScheduler(VirtualAction, MAX_FRAMES);\n    const messages: string[] = ['first message', 'second message', 'third message'];\n\n    const actualMessages: string[] = [];\n\n    messages.forEach((message, index) => {\n      v.schedule(\n        state => actualMessages.push(state!),\n        index * MAX_FRAMES,\n        message\n      );\n    });\n\n    v.flush();\n\n    expect(actualMessages).to.deep.equal(['first message', 'second message']);\n    expect(v.actions.map(a => a.state)).to.deep.equal(['third message']);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should pick up actions execution where it left off after reaching previous maxFrames limit","suites":["VirtualTimeScheduler"],"updatePoint":{"line":119,"column":96},"line":119,"code":"  it('should pick up actions execution where it left off after reaching previous maxFrames limit', function () {\n    const MAX_FRAMES = 50;\n    const v = new VirtualTimeScheduler(VirtualAction, MAX_FRAMES);\n    const messages: string[] = ['first message', 'second message', 'third message'];\n\n    const actualMessages: string[] = [];\n\n    messages.forEach((message, index) => {\n      v.schedule(\n        state => actualMessages.push(state!),\n        index * MAX_FRAMES,\n        message\n      );\n    });\n\n    v.flush();\n    v.maxFrames = 2 * MAX_FRAMES;\n    v.flush();\n\n    expect(actualMessages).to.deep.equal(messages);\n  });","file":"schedulers/VirtualTimeScheduler-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow next with undefined or any when created with no type","suites":["Subject"],"updatePoint":{"line":16,"column":71},"line":16,"code":"  it('should allow next with undefined or any when created with no type', (done) => {\n    const subject = new Subject();\n    subject.subscribe(\n      { next: (x) => {\n        expect(x).to.be.a('undefined');\n      }, complete: done }\n    );\n\n    const data: any = undefined;\n    subject.next(undefined);\n    subject.next(data);\n    subject.complete();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow empty next when created with void type","suites":["Subject"],"updatePoint":{"line":30,"column":57},"line":30,"code":"  it('should allow empty next when created with void type', (done) => {\n    const subject = new Subject<void>();\n    subject.subscribe(\n      { next: (x) => {\n        expect(x).to.be.a('undefined');\n      }, complete: done }\n    );\n\n    subject.next();\n    subject.complete();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should pump values right on through itself","suites":["Subject"],"updatePoint":{"line":42,"column":48},"line":42,"code":"  it('should pump values right on through itself', (done) => {\n    const subject = new Subject<string>();\n    const expected = ['foo', 'bar'];\n\n    subject.subscribe(\n      { next: (x: string) => {\n        expect(x).to.equal(expected.shift());\n      }, complete: done }\n    );\n\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should pump values to multiple subscribers","suites":["Subject"],"updatePoint":{"line":57,"column":48},"line":57,"code":"  it('should pump values to multiple subscribers', (done) => {\n    const subject = new Subject<string>();\n    const expected = ['foo', 'bar'];\n\n    let i = 0;\n    let j = 0;\n\n    subject.subscribe(function (x) {\n      expect(x).to.equal(expected[i++]);\n    });\n\n    subject.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected[j++]);\n      }, complete: done }\n    );\n\n    expect(subject.observers.length).to.equal(2);\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should disallow new subscriber once subject has been disposed","suites":["Subject"],"updatePoint":{"line":311,"column":67},"line":311,"code":"  it('should disallow new subscriber once subject has been disposed', () => {\n    const subject = new Subject<number>();\n    const results1: (number | string)[] = [];\n    const results2: (number | string)[] = [];\n    const results3: (number | string)[] = [];\n\n    const subscription1 = subject.subscribe(\n      { next: function (x) {\n        results1.push(x);\n      }, error: function (e) {\n        results1.push('E');\n      }, complete: () => {\n        results1.push('C');\n      } }\n    );\n\n    subject.next(1);\n    subject.next(2);\n\n    const subscription2 = subject.subscribe(\n      { next: function (x) {\n        results2.push(x);\n      }, error: function (e) {\n        results2.push('E');\n      }, complete: () => {\n        results2.push('C');\n      } }\n    );\n\n    subject.next(3);\n    subject.next(4);\n    subject.next(5);\n\n    subscription1.unsubscribe();\n    subscription2.unsubscribe();\n    subject.unsubscribe();\n\n    expect(() => {\n      subject.subscribe(\n        { next: function (x) {\n          results3.push(x);\n        }, error: function (err) {\n          expect(false).to.equal('should not throw error: ' + err.toString());\n        } }\n      );\n    }).to.throw(ObjectUnsubscribedError);\n\n    expect(results1).to.deep.equal([1, 2, 3, 4, 5]);\n    expect(results2).to.deep.equal([3, 4, 5]);\n    expect(results3).to.deep.equal([]);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not allow values to be nexted after it is unsubscribed","suites":["Subject"],"updatePoint":{"line":363,"column":67},"line":363,"code":"  it('should not allow values to be nexted after it is unsubscribed', (done) => {\n    const subject = new Subject<string>();\n    const expected = ['foo'];\n\n    subject.subscribe(function (x) {\n      expect(x).to.equal(expected.shift());\n    });\n\n    subject.next('foo');\n    subject.unsubscribe();\n    expect(() => subject.next('bar')).to.throw(ObjectUnsubscribedError);\n    done();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should clean out unsubscribed subscribers","suites":["Subject"],"updatePoint":{"line":377,"column":47},"line":377,"code":"  it('should clean out unsubscribed subscribers', (done) => {\n    const subject = new Subject();\n\n    const sub1 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    const sub2 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    sub1.unsubscribe();\n    expect(subject.observers.length).to.equal(1);\n    sub2.unsubscribe();\n    expect(subject.observers.length).to.equal(0);\n    done();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should expose observed status","suites":["Subject"],"updatePoint":{"line":396,"column":35},"line":396,"code":"  it('should expose observed status', () => {\n    const subject = new Subject();\n\n    expect(subject.observed).to.equal(false);\n\n    const sub1 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observed).to.equal(true);\n\n    const sub2 = subject.subscribe(function (x) {\n      //noop\n    });\n\n    expect(subject.observed).to.equal(true);\n    sub1.unsubscribe();\n    expect(subject.observed).to.equal(true);\n    sub2.unsubscribe();\n    expect(subject.observed).to.equal(false);\n    subject.unsubscribe();\n    expect(subject.observed).to.equal(false);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should have a static create function that works","suites":["Subject"],"updatePoint":{"line":420,"column":53},"line":420,"code":"  it('should have a static create function that works', () => {\n    expect(Subject.create).to.be.a('function');\n    const source = of(1, 2, 3, 4, 5);\n    const nexts: number[] = [];\n    const output: number[] = [];\n\n    let error: any;\n    let complete = false;\n    let outputComplete = false;\n\n    const destination = {\n      closed: false,\n      next: function (x: number) {\n        nexts.push(x);\n      },\n      error: function (err: any) {\n        error = err;\n        this.closed = true;\n      },\n      complete: function () {\n        complete = true;\n        this.closed = true;\n      },\n    };\n\n    const sub = Subject.create(destination, source);\n\n    sub.subscribe(\n      function (x: number) {\n        output.push(x);\n      },\n      null,\n      () => {\n        outputComplete = true;\n      }\n    );\n\n    sub.next('a');\n    sub.next('b');\n    sub.next('c');\n    sub.complete();\n\n    expect(nexts).to.deep.equal(['a', 'b', 'c']);\n    expect(complete).to.be.true;\n    expect(error).to.be.a('undefined');\n\n    expect(output).to.deep.equal([1, 2, 3, 4, 5]);\n    expect(outputComplete).to.be.true;\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should have a static create function that works also to raise errors","suites":["Subject"],"updatePoint":{"line":470,"column":74},"line":470,"code":"  it('should have a static create function that works also to raise errors', () => {\n    expect(Subject.create).to.be.a('function');\n    const source = of(1, 2, 3, 4, 5);\n    const nexts: number[] = [];\n    const output: number[] = [];\n\n    let error: any;\n    let complete = false;\n    let outputComplete = false;\n\n    const destination = {\n      closed: false,\n      next: function (x: number) {\n        nexts.push(x);\n      },\n      error: function (err: any) {\n        error = err;\n        this.closed = true;\n      },\n      complete: function () {\n        complete = true;\n        this.closed = true;\n      },\n    };\n\n    const sub = Subject.create(destination, source);\n\n    sub.subscribe(\n      function (x: number) {\n        output.push(x);\n      },\n      null,\n      () => {\n        outputComplete = true;\n      }\n    );\n\n    sub.next('a');\n    sub.next('b');\n    sub.next('c');\n    sub.error('boom');\n\n    expect(nexts).to.deep.equal(['a', 'b', 'c']);\n    expect(complete).to.be.false;\n    expect(error).to.equal('boom');\n\n    expect(output).to.deep.equal([1, 2, 3, 4, 5]);\n    expect(outputComplete).to.be.true;\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be an Observer which can be given to Observable.subscribe","suites":["Subject"],"updatePoint":{"line":520,"column":70},"line":520,"code":"  it('should be an Observer which can be given to Observable.subscribe', (done) => {\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new Subject<number>();\n    const expected = [1, 2, 3, 4, 5];\n\n    subject.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: (x) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n\n    source.subscribe(subject);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be usable as an Observer of a finite delayed Observable","suites":["Subject"],"updatePoint":{"line":538,"column":68},"line":538,"code":"  it('should be usable as an Observer of a finite delayed Observable', (done) => {\n    const source = of(1, 2, 3).pipe(delay(50));\n    const subject = new Subject<number>();\n\n    const expected = [1, 2, 3];\n\n    subject.subscribe(\n      { next: function (x) {\n        expect(x).to.equal(expected.shift());\n      }, error: (x) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n\n    source.subscribe(subject);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw ObjectUnsubscribedError when emit after unsubscribed","suites":["Subject"],"updatePoint":{"line":557,"column":71},"line":557,"code":"  it('should throw ObjectUnsubscribedError when emit after unsubscribed', () => {\n    const subject = new Subject<string>();\n    subject.unsubscribe();\n\n    expect(() => {\n      subject.next('a');\n    }).to.throw(ObjectUnsubscribedError);\n\n    expect(() => {\n      subject.error('a');\n    }).to.throw(ObjectUnsubscribedError);\n\n    expect(() => {\n      subject.complete();\n    }).to.throw(ObjectUnsubscribedError);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not next after completed","suites":["Subject"],"updatePoint":{"line":574,"column":37},"line":574,"code":"  it('should not next after completed', () => {\n    const subject = new Subject<string>();\n    const results: string[] = [];\n    subject.subscribe(\n      { next: (x) => results.push(x), complete: () => results.push('C') }\n    );\n    subject.next('a');\n    subject.complete();\n    subject.next('b');\n    expect(results).to.deep.equal(['a', 'C']);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not next after error","suites":["Subject"],"updatePoint":{"line":586,"column":33},"line":586,"code":"  it('should not next after error', () => {\n    const error = new Error('wut?');\n    const subject = new Subject<string>();\n    const results: string[] = [];\n    subject.subscribe(\n      { next: (x) => results.push(x), error: (err) => results.push(err) }\n    );\n    subject.next('a');\n    subject.error(error);\n    subject.next('b');\n    expect(results).to.deep.equal(['a', error]);\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should hide subject","suites":["Subject","asObservable"],"updatePoint":{"line":600,"column":27},"line":600,"code":"    it('should hide subject', () => {\n      const subject = new Subject();\n      const observable = subject.asObservable();\n\n      expect(subject).not.to.equal(observable);\n\n      expect(observable instanceof Observable).to.be.true;\n      expect(observable instanceof Subject).to.be.false;\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle subject never emits","suites":["Subject","asObservable"],"updatePoint":{"line":610,"column":41},"line":610,"code":"    it('should handle subject never emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('-').asObservable();\n\n        expectObservable(observable).toBe('-');\n      });\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle subject completes without emits","suites":["Subject","asObservable"],"updatePoint":{"line":618,"column":53},"line":618,"code":"    it('should handle subject completes without emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--|').asObservable();\n        const expected = '        ---|';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle subject throws","suites":["Subject","asObservable"],"updatePoint":{"line":627,"column":36},"line":627,"code":"    it('should handle subject throws', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--#').asObservable();\n        const expected = '        ---#';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should handle subject emits","suites":["Subject","asObservable"],"updatePoint":{"line":636,"column":35},"line":636,"code":"    it('should handle subject emits', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const observable = hot('--^--x--|').asObservable();\n        const expected = '        ---x--|';\n\n        expectObservable(observable).toBe(expected);\n      });\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should work with inherited subject","suites":["Subject","asObservable"],"updatePoint":{"line":645,"column":42},"line":645,"code":"    it('should work with inherited subject', () => {\n      const results: (number | string)[] = [];\n      const subject = new AsyncSubject<number>();\n\n      subject.next(42);\n      subject.complete();\n\n      const observable = subject.asObservable();\n\n      observable.subscribe(\n        { next: (x) => results.push(x), complete: () => results.push('done') }\n      );\n\n      expect(results).to.deep.equal([42, 'done']);\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not synchronously error when nexted into","suites":["Subject","error thrown scenario"],"updatePoint":{"line":667,"column":55},"line":667,"code":"    it('should not synchronously error when nexted into', (done) => {\n      config.onUnhandledError = (err) => {\n        expect(err.message).to.equal('Boom!');\n        done();\n      };\n      \n      const source = new Subject<number>();\n      source.subscribe();\n      source.subscribe(() => {\n        throw new Error('Boom!');\n      });\n      source.subscribe();\n      try {\n        source.next(42);\n      } catch (err) {\n        // This should not happen!\n        expect(true).to.be.false;\n      }\n      expect(true).to.be.true;\n    });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be exposed","suites":["AnonymousSubject"],"updatePoint":{"line":691,"column":23},"line":691,"code":"  it('should be exposed', () => {\n    expect(AnonymousSubject).to.be.a('function');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be eager","suites":["AnonymousSubject"],"updatePoint":{"line":695,"column":25},"line":695,"code":"  it('should not be eager', () => {\n    let subscribed = false;\n\n    const subject = Subject.create(\n      null,\n      new Observable((observer: Observer<any>) => {\n        subscribed = true;\n        const subscription = of('x').subscribe(observer);\n        return () => {\n          subscription.unsubscribe();\n        };\n      })\n    );\n\n    const observable = subject.asObservable();\n    expect(subscribed).to.be.false;\n\n    observable.subscribe();\n    expect(subscribed).to.be.true;\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when nexting with a flattened, erroring inner observable","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":726,"column":84},"line":726,"code":"  it('should throw an error when nexting with a flattened, erroring inner observable', () => {\n    const subject = new Subject<string>();\n    subject.pipe(mergeMap(() => throwError(() => new Error('bad')))).subscribe();\n\n    expect(() => {\n      subject.next('wee');\n    }).to.throw(Error, 'bad');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when nexting with a flattened, erroring inner observable with more than one operator","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":735,"column":112},"line":735,"code":"  it('should throw an error when nexting with a flattened, erroring inner observable with more than one operator', () => {\n    const subject = new Subject<string>();\n    subject.pipe(mergeMap(() => throwError(() => new Error('bad'))), map(x => x)).subscribe();\n\n    expect(() => {\n      subject.next('wee');\n    }).to.throw(Error, 'bad');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when notifying an error with catchError returning an erroring inner observable","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":744,"column":106},"line":744,"code":"  it('should throw an error when notifying an error with catchError returning an erroring inner observable', () => {\n    const subject = new Subject<string>();\n    subject.pipe(catchError(() => throwError(() => new Error('bad')))).subscribe();\n\n    expect(() => {\n      subject.error('wee');\n    }).to.throw(Error, 'bad');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when nexting with an operator that errors synchronously","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":753,"column":83},"line":753,"code":"  it('should throw an error when nexting with an operator that errors synchronously', () => {\n    const subject = new Subject<string>();\n    subject.pipe(mergeMap(() => {\n      throw new Error('lol');\n    })).subscribe();\n\n    expect(() => {\n      subject.next('wee');\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when notifying an error with a catchError that errors synchronously","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":765,"column":95},"line":765,"code":"  it('should throw an error when notifying an error with a catchError that errors synchronously', () => {\n    const subject = new Subject<string>();\n    subject.pipe(catchError(() => {\n      throw new Error('lol');\n    })).subscribe();\n\n    expect(() => {\n      subject.error('wee');\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when nexting with an erroring next handler","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":776,"column":70},"line":776,"code":"  it('should throw an error when nexting with an erroring next handler', () => {\n    const subject = new Subject<string>();\n    subject.subscribe(() => {\n      throw new Error('lol');\n    });\n\n    expect(() => {\n      subject.next('wee');\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when notifying with an erroring error handler","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":787,"column":73},"line":787,"code":"  it('should throw an error when notifying with an erroring error handler', () => {\n    const subject = new Subject<string>();\n    subject.subscribe({\n      error: () => {\n        throw new Error('lol');\n      }\n    });\n\n    expect(() => {\n      subject.error('wee');\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when notifying with an erroring complete handler","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":800,"column":76},"line":800,"code":"  it('should throw an error when notifying with an erroring complete handler', () => {\n    const subject = new Subject<string>();\n    subject.subscribe({\n      complete: () => {\n        throw new Error('lol');\n      }\n    });\n\n    expect(() => {\n      subject.complete();\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw an error when notifying an complete, and concatenated with another observable that synchronously errors","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":813,"column":122},"line":813,"code":"  it('should throw an error when notifying an complete, and concatenated with another observable that synchronously errors', () => {\n    const subject = new Subject<string>();\n    concat(subject, throwError(new Error('lol'))).subscribe();\n\n    expect(() => {\n      subject.complete();\n    }).to.throw(Error, 'lol');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not throw on second error passed","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":822,"column":45},"line":822,"code":"  it('should not throw on second error passed', () => {\n    const subject = new Subject();\n\n    subject.subscribe();\n    \n    expect(() => {\n      subject.error(new Error('one'));\n    }).to.throw(Error, 'one');\n\n    expect(() => {\n      subject.error(new Error('two'));\n    }).not.to.throw(Error, 'two');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not throw on second error passed, even after having been operated on","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":836,"column":81},"line":836,"code":"  it('should not throw on second error passed, even after having been operated on', () => {\n    const subject = new Subject();\n\n    subject.pipe(mergeMap(x => [x])).subscribe();\n    \n    expect(() => {\n      subject.error(new Error('one'));\n    }).to.throw(Error, 'one');\n\n    expect(() => {\n      subject.error('two');\n    }).not.to.throw();\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"deep rethrowing 1","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":850,"column":23},"line":850,"code":"  it('deep rethrowing 1', () => {\n    const subject1 = new Subject();\n    const subject2 = new Subject();\n\n    subject2.subscribe();\n\n    subject1.subscribe({\n      next: () => subject2.error(new Error('hahaha'))\n    });\n\n    expect(() => {\n      subject1.next('test');\n    }).to.throw(Error, 'hahaha');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"deep rethrowing 2","suites":["useDeprecatedSynchronousErrorHandling"],"updatePoint":{"line":865,"column":23},"line":865,"code":"  it('deep rethrowing 2', () => {\n    const subject1 = new Subject();\n\n    subject1.subscribe({\n      next: () => {\n        throwError(new Error('hahaha')).subscribe();\n      }\n    });\n\n    expect(() => {\n      subject1.next('test');\n    }).to.throw(Error, 'hahaha');\n  });","file":"Subject-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last value when complete","suites":["AsyncSubject"],"updatePoint":{"line":22,"column":46},"line":22,"code":"  it('should emit the last value when complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit the last value when subscribing after complete","suites":["AsyncSubject"],"updatePoint":{"line":35,"column":64},"line":35,"code":"  it('should emit the last value when subscribing after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n\n    subject.next(1);\n    subject.next(2);\n    subject.complete();\n\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should keep emitting the last value to subsequent subscriptions","suites":["AsyncSubject"],"updatePoint":{"line":47,"column":69},"line":47,"code":"  it('should keep emitting the last value to subsequent subscriptions', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([2, 'done']);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit values after complete","suites":["AsyncSubject"],"updatePoint":{"line":66,"column":43},"line":66,"code":"  it('should not emit values after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    subject.next(3);\n    expect(observer.results).to.deep.equal([2, 'done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not allow change value after complete","suites":["AsyncSubject"],"updatePoint":{"line":81,"column":50},"line":81,"code":"  it('should not allow change value after complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const otherObserver = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([1, 'done']);\n    subject.next(2);\n    subject.subscribe(otherObserver);\n    expect(otherObserver.results).to.deep.equal([1, 'done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not emit values if unsubscribed before complete","suites":["AsyncSubject"],"updatePoint":{"line":96,"column":60},"line":96,"code":"  it('should not emit values if unsubscribed before complete', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n    subject.next(2);\n    expect(observer.results).to.deep.equal([]);\n\n    subscription.unsubscribe();\n\n    subject.next(3);\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal([]);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should just complete if no value has been nexted into it","suites":["AsyncSubject"],"updatePoint":{"line":114,"column":62},"line":114,"code":"  it('should just complete if no value has been nexted into it', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal(['done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should keep emitting complete to subsequent subscriptions","suites":["AsyncSubject"],"updatePoint":{"line":124,"column":63},"line":124,"code":"  it('should keep emitting complete to subsequent subscriptions', () => {\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    expect(observer.results).to.deep.equal([]);\n    subject.complete();\n    expect(observer.results).to.deep.equal(['done']);\n\n    subscription.unsubscribe();\n    observer.results = [];\n\n    subject.error(new Error(''));\n\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal(['done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should only error if an error is passed into it","suites":["AsyncSubject"],"updatePoint":{"line":142,"column":53},"line":142,"code":"  it('should only error if an error is passed into it', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should keep emitting error to subsequent subscriptions","suites":["AsyncSubject"],"updatePoint":{"line":155,"column":60},"line":155,"code":"  it('should keep emitting error to subsequent subscriptions', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([expected]);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not allow send complete after error","suites":["AsyncSubject"],"updatePoint":{"line":174,"column":48},"line":174,"code":"  it('should not allow send complete after error', () => {\n    const expected = new Error('bad');\n    const subject = new AsyncSubject<number>();\n    const observer = new TestObserver();\n    const subscription = subject.subscribe(observer);\n\n    subject.next(1);\n    expect(observer.results).to.deep.equal([]);\n\n    subject.error(expected);\n    expect(observer.results).to.deep.equal([expected]);\n\n    subscription.unsubscribe();\n\n    observer.results = [];\n\n    subject.complete();\n    subject.subscribe(observer);\n    expect(observer.results).to.deep.equal([expected]);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be reentrant via complete","suites":["AsyncSubject"],"updatePoint":{"line":195,"column":42},"line":195,"code":"  it('should not be reentrant via complete', () => {\n    const subject = new AsyncSubject<number>();\n    let calls = 0;\n    subject.subscribe({\n      next: value => {\n        calls++;\n        if (calls < 2) {\n          // if this is more than 1, we're reentrant, and that's bad.\n          subject.complete();\n        }\n      }\n    });\n\n    subject.next(1);\n    subject.complete();\n\n    expect(calls).to.equal(1);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be reentrant via next","suites":["AsyncSubject"],"updatePoint":{"line":214,"column":38},"line":214,"code":"  it('should not be reentrant via next', () => {\n    const subject = new AsyncSubject<number>();\n    let calls = 0;\n    subject.subscribe({\n      next: value => {\n        calls++;\n        if (calls < 2) {\n          // if this is more than 1, we're reentrant, and that's bad.\n          subject.next(value + 1);\n        }\n      }\n    });\n\n    subject.next(1);\n    subject.complete();\n\n    expect(calls).to.equal(1);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow reentrant subscriptions","suites":["AsyncSubject"],"updatePoint":{"line":233,"column":42},"line":233,"code":"  it('should allow reentrant subscriptions', () => {\n    const subject = new AsyncSubject<number>()\n    let results: any[] = [];\n\n    subject.subscribe({\n      next: (value) => {\n        subject.subscribe({\n          next: value => results.push('inner: ' + (value + value)),\n          complete: () => results.push('inner: done')\n        });\n        results.push('outer: ' + value);\n      },\n      complete: () => results.push('outer: done')\n    });\n\n    subject.next(1);\n    expect(results).to.deep.equal([]);\n    subject.complete();\n    expect(results).to.deep.equal(['inner: 2', 'inner: done', 'outer: 1', 'outer: done']);\n  });","file":"subjects/AsyncSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should extend Subject","suites":["BehaviorSubject"],"updatePoint":{"line":9,"column":27},"line":9,"code":"  it('should extend Subject', () => {\n    const subject = new BehaviorSubject(null);\n    expect(subject).to.be.instanceof(Subject);\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should throw if it has received an error and getValue() is called","suites":["BehaviorSubject"],"updatePoint":{"line":14,"column":71},"line":14,"code":"  it('should throw if it has received an error and getValue() is called', () => {\n    const subject = new BehaviorSubject(null);\n    subject.error(new Error('derp'));\n    expect(() => {\n      subject.getValue();\n    }).to.throw(Error, 'derp');\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should have a getValue() method to retrieve the current value","suites":["BehaviorSubject"],"updatePoint":{"line":31,"column":67},"line":31,"code":"  it('should have a getValue() method to retrieve the current value', () => {\n    const subject = new BehaviorSubject('staltz');\n    expect(subject.getValue()).to.equal('staltz');\n\n    subject.next('oj');\n\n    expect(subject.getValue()).to.equal('oj');\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not allow you to set `value` directly","suites":["BehaviorSubject"],"updatePoint":{"line":40,"column":50},"line":40,"code":"  it('should not allow you to set `value` directly', () => {\n    const subject = new BehaviorSubject('flibberty');\n\n    try {\n      // XXX: escape from readonly restriction for testing.\n      (subject as any).value = 'jibbets';\n    } catch (e) {\n      //noop\n    }\n\n    expect(subject.getValue()).to.equal('flibberty');\n    expect(subject.value).to.equal('flibberty');\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should still allow you to retrieve the value from the value property","suites":["BehaviorSubject"],"updatePoint":{"line":54,"column":74},"line":54,"code":"  it('should still allow you to retrieve the value from the value property', () => {\n    const subject = new BehaviorSubject('fuzzy');\n    expect(subject.value).to.equal('fuzzy');\n    subject.next('bunny');\n    expect(subject.value).to.equal('bunny');\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should start with an initialization value","suites":["BehaviorSubject"],"updatePoint":{"line":61,"column":47},"line":61,"code":"  it('should start with an initialization value', (done) => {\n    const subject = new BehaviorSubject('foo');\n    const expected = ['foo', 'bar'];\n    let i = 0;\n\n    subject.subscribe({ next: (x: string) => {\n      expect(x).to.equal(expected[i++]);\n    }, complete: done });\n\n    subject.next('bar');\n    subject.complete();\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should pump values to multiple subscribers","suites":["BehaviorSubject"],"updatePoint":{"line":74,"column":48},"line":74,"code":"  it('should pump values to multiple subscribers', (done) => {\n    const subject = new BehaviorSubject('init');\n    const expected = ['init', 'foo', 'bar'];\n    let i = 0;\n    let j = 0;\n\n    subject.subscribe((x: string) => {\n      expect(x).to.equal(expected[i++]);\n    });\n\n    subject.subscribe({ next: (x: string) => {\n      expect(x).to.equal(expected[j++]);\n    }, complete: done });\n\n    expect(subject.observers.length).to.equal(2);\n    subject.next('foo');\n    subject.next('bar');\n    subject.complete();\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not pass values nexted after a complete","suites":["BehaviorSubject"],"updatePoint":{"line":94,"column":52},"line":94,"code":"  it('should not pass values nexted after a complete', () => {\n    const subject = new BehaviorSubject('init');\n    const results: string[] = [];\n\n    subject.subscribe((x: string) => {\n      results.push(x);\n    });\n    expect(results).to.deep.equal(['init']);\n\n    subject.next('foo');\n    expect(results).to.deep.equal(['init', 'foo']);\n\n    subject.complete();\n    expect(results).to.deep.equal(['init', 'foo']);\n\n    subject.next('bar');\n    expect(results).to.deep.equal(['init', 'foo']);\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should clean out unsubscribed subscribers","suites":["BehaviorSubject"],"updatePoint":{"line":113,"column":47},"line":113,"code":"  it('should clean out unsubscribed subscribers', (done) => {\n    const subject = new BehaviorSubject('init');\n\n    const sub1 = subject.subscribe((x: string) => {\n      expect(x).to.equal('init');\n    });\n\n    const sub2 = subject.subscribe((x: string) => {\n      expect(x).to.equal('init');\n    });\n\n    expect(subject.observers.length).to.equal(2);\n    sub1.unsubscribe();\n    expect(subject.observers.length).to.equal(1);\n    sub2.unsubscribe();\n    expect(subject.observers.length).to.equal(0);\n    done();\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay the previous value when subscribed","suites":["BehaviorSubject"],"updatePoint":{"line":132,"column":54},"line":132,"code":"  it('should replay the previous value when subscribed', () => {\n    const behaviorSubject = new BehaviorSubject('0');\n    function feedNextIntoSubject(x: string) { behaviorSubject.next(x); }\n    function feedErrorIntoSubject(err: any) { behaviorSubject.error(err); }\n    function feedCompleteIntoSubject() { behaviorSubject.complete(); }\n\n    const sourceTemplate =  '-1-2-3----4------5-6---7--8----9--|';\n    const subscriber1 = hot('      (a|)                         ').pipe(mergeMapTo(behaviorSubject));\n    const unsub1 =          '                     !             ';\n    const expected1   =     '      3---4------5-6--             ';\n    const subscriber2 = hot('            (b|)                   ').pipe(mergeMapTo(behaviorSubject));\n    const unsub2 =          '                         !         ';\n    const expected2   =     '            4----5-6---7--         ';\n    const subscriber3 = hot('                           (c|)    ').pipe(mergeMapTo(behaviorSubject));\n    const expected3   =     '                           8---9--|';\n\n    expectObservable(hot(sourceTemplate).pipe(\n      tap(\n      { next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }\n      )\n    )).toBe(sourceTemplate);\n    expectObservable(subscriber1, unsub1).toBe(expected1);\n    expectObservable(subscriber2, unsub2).toBe(expected2);\n    expectObservable(subscriber3).toBe(expected3);\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should emit complete when subscribed after completed","suites":["BehaviorSubject"],"updatePoint":{"line":158,"column":58},"line":158,"code":"  it('should emit complete when subscribed after completed', () => {\n    const behaviorSubject = new BehaviorSubject('0');\n    function feedNextIntoSubject(x: string) { behaviorSubject.next(x); }\n    function feedErrorIntoSubject(err: any) { behaviorSubject.error(err); }\n    function feedCompleteIntoSubject() { behaviorSubject.complete(); }\n\n    const sourceTemplate =  '-1-2-3--4--|';\n    const subscriber1 = hot('               (a|)').pipe(\n      mergeMapTo(behaviorSubject)\n    );\n    const expected1   =     '               |   ';\n\n    expectObservable(hot(sourceTemplate).pipe(\n      tap(\n        { next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }\n      )\n    )).toBe(sourceTemplate);\n    expectObservable(subscriber1).toBe(expected1);\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be an Observer which can be given to Observable.subscribe","suites":["BehaviorSubject"],"updatePoint":{"line":178,"column":70},"line":178,"code":"  it('should be an Observer which can be given to Observable.subscribe', (done) => {\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new BehaviorSubject(0);\n    const expected = [0, 1, 2, 3, 4, 5];\n\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      }, error: (x) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(subject.value).to.equal(5);\n        done();\n      } });\n\n    source.subscribe(subject);\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be an Observer which can be given to an interop source","suites":["BehaviorSubject"],"updatePoint":{"line":196,"column":67},"line":196,"code":"  it('should be an Observer which can be given to an interop source', (done) => {\n    // This test reproduces a bug reported in this issue:\n    // https://github.com/ReactiveX/rxjs/issues/5105\n    // However, it cannot easily be fixed. See this comment:\n    // https://github.com/ReactiveX/rxjs/issues/5105#issuecomment-578405446\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new BehaviorSubject(0);\n    const expected = [0, 1, 2, 3, 4, 5];\n\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expected.shift());\n      }, error: (x) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        expect(subject.value).to.equal(5);\n        done();\n      } });\n\n      source.subscribe(asInteropSubject(subject));\n  });","file":"subjects/BehaviorSubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should extend Subject","suites":["ReplaySubject"],"updatePoint":{"line":15,"column":27},"line":15,"code":"  it('should extend Subject', () => {\n    const subject = new ReplaySubject();\n    expect(subject).to.be.instanceof(Subject);\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should add the observer before running subscription code","suites":["ReplaySubject"],"updatePoint":{"line":20,"column":62},"line":20,"code":"  it('should add the observer before running subscription code', () => {\n    const subject = new ReplaySubject<number>();\n    subject.next(1);\n    const results: number[] = [];\n\n    subject.subscribe((value) => {\n      results.push(value);\n      if (value < 3) {\n        subject.next(value + 1);\n      }\n    });\n\n    expect(results).to.deep.equal([1, 2, 3]);\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay values upon subscription","suites":["ReplaySubject"],"updatePoint":{"line":35,"column":44},"line":35,"code":"  it('should replay values upon subscription', (done) => {\n    const subject = new ReplaySubject<number>();\n    const expects = [1, 2, 3];\n    let i = 0;\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expects[i++]);\n        if (i === 3) {\n          subject.complete();\n        }\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay values and complete","suites":["ReplaySubject"],"updatePoint":{"line":56,"column":39},"line":56,"code":"  it('should replay values and complete', (done) => {\n    const subject = new ReplaySubject<number>();\n    const expects = [1, 2, 3];\n    let i = 0;\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.complete();\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expects[i++]);\n      }, complete: done }\n    );\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay values and error","suites":["ReplaySubject"],"updatePoint":{"line":71,"column":36},"line":71,"code":"  it('should replay values and error', (done) => {\n    const subject = new ReplaySubject<number>();\n    const expects = [1, 2, 3];\n    let i = 0;\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.error('fooey');\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expects[i++]);\n      }, error: (err: any) => {\n        expect(err).to.equal('fooey');\n        done();\n      } }\n    );\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should only replay values within its buffer size","suites":["ReplaySubject"],"updatePoint":{"line":89,"column":54},"line":89,"code":"  it('should only replay values within its buffer size', (done) => {\n    const subject = new ReplaySubject<number>(2);\n    const expects = [2, 3];\n    let i = 0;\n    subject.next(1);\n    subject.next(2);\n    subject.next(3);\n    subject.subscribe(\n      { next: (x: number) => {\n        expect(x).to.equal(expects[i++]);\n        if (i === 2) {\n          subject.complete();\n        }\n      }, error: (err: any) => {\n        done(new Error('should not be called'));\n      }, complete: () => {\n        done();\n      } }\n    );\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay 2 previous values when subscribed","suites":["ReplaySubject","with bufferSize=2"],"updatePoint":{"line":111,"column":55},"line":111,"code":"    it('should replay 2 previous values when subscribed', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const replaySubject = new ReplaySubject<string>(2);\n        function feedNextIntoSubject(x: string) {\n          replaySubject.next(x);\n        }\n        function feedErrorIntoSubject(err: string) {\n          replaySubject.error(err);\n        }\n        function feedCompleteIntoSubject() {\n          replaySubject.complete();\n        }\n\n        const sourceTemplate = ' -1-2-3----4------5-6---7--8----9--|';\n        const subscriber1 = hot('------(a|)                         ').pipe(mergeMapTo(replaySubject));\n        const unsub1 = '         ---------------------!             ';\n        const expected1 = '      ------(23)4------5-6--             ';\n        const subscriber2 = hot('------------(b|)                   ').pipe(mergeMapTo(replaySubject));\n        const unsub2 = '         -------------------------!         ';\n        const expected2 = '      ------------(34)-5-6---7--         ';\n        const subscriber3 = hot('---------------------------(c|)    ').pipe(mergeMapTo(replaySubject));\n        const expected3 = '      ---------------------------(78)9--|';\n\n        expectObservable(hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))).toBe(\n          sourceTemplate\n        );\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n      });\n    });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay 2 last values for when subscribed after completed","suites":["ReplaySubject","with bufferSize=2"],"updatePoint":{"line":143,"column":71},"line":143,"code":"    it('should replay 2 last values for when subscribed after completed', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const replaySubject = new ReplaySubject<string>(2);\n        function feedNextIntoSubject(x: string) {\n          replaySubject.next(x);\n        }\n        function feedErrorIntoSubject(err: string) {\n          replaySubject.error(err);\n        }\n        function feedCompleteIntoSubject() {\n          replaySubject.complete();\n        }\n\n        const sourceTemplate = ' -1-2-3--4--|';\n        const subscriber1 = hot('---------------(a|) ').pipe(mergeMapTo(replaySubject));\n        const expected1 = '      ---------------(34|)';\n\n        expectObservable(hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))).toBe(\n          sourceTemplate\n        );\n        expectObservable(subscriber1).toBe(expected1);\n      });\n    });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay previous values since 4 time units ago when subscribed","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":235,"column":76},"line":235,"code":"    it('should replay previous values since 4 time units ago when subscribed', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const replaySubject = new ReplaySubject<string>(Infinity, 4, rxTestScheduler);\n        function feedNextIntoSubject(x: string) {\n          replaySubject.next(x);\n        }\n        function feedErrorIntoSubject(err: any) {\n          replaySubject.error(err);\n        }\n        function feedCompleteIntoSubject() {\n          replaySubject.complete();\n        }\n\n        const sourceTemplate = ' -1-2-3----4------5-6----7-8----9--|';\n        const subscriber1 = hot('------(a|)                         ').pipe(mergeMapTo(replaySubject));\n        const unsub1 = '         ---------------------!             ';\n        const expected1 = '      ------(23)4------5-6--             ';\n        const subscriber2 = hot('------------(b|)                   ').pipe(mergeMapTo(replaySubject));\n        const unsub2 = '         -------------------------!         ';\n        const expected2 = '      ------------4----5-6----7-         ';\n        const subscriber3 = hot('---------------------------(c|)    ').pipe(mergeMapTo(replaySubject));\n        const expected3 = '      ---------------------------(78)9--|';\n\n        expectObservable(hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))).toBe(\n          sourceTemplate\n        );\n        expectObservable(subscriber1, unsub1).toBe(expected1);\n        expectObservable(subscriber2, unsub2).toBe(expected2);\n        expectObservable(subscriber3).toBe(expected3);\n      });\n    });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should replay last values since 4 time units ago when subscribed","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":267,"column":72},"line":267,"code":"    it('should replay last values since 4 time units ago when subscribed', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const replaySubject = new ReplaySubject<string>(Infinity, 4, rxTestScheduler);\n        function feedNextIntoSubject(x: string) {\n          replaySubject.next(x);\n        }\n        function feedErrorIntoSubject(err: any) {\n          replaySubject.error(err);\n        }\n        function feedCompleteIntoSubject() {\n          replaySubject.complete();\n        }\n\n        const sourceTemplate = ' -1-2-3----4|';\n        const subscriber1 = hot('-------------(a|)').pipe(mergeMapTo(replaySubject));\n        const expected1 = '      -------------(4|)';\n\n        expectObservable(hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))).toBe(\n          sourceTemplate\n        );\n        expectObservable(subscriber1).toBe(expected1);\n      });\n    });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should only replay bufferSize items when 4 time units ago more were emited","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":291,"column":82},"line":291,"code":"    it('should only replay bufferSize items when 4 time units ago more were emited', () => {\n      rxTestScheduler.run(({ hot, expectObservable }) => {\n        const replaySubject = new ReplaySubject<string>(2, 4, rxTestScheduler);\n        function feedNextIntoSubject(x: string) {\n          replaySubject.next(x);\n        }\n        function feedErrorIntoSubject(err: any) {\n          replaySubject.error(err);\n        }\n        function feedCompleteIntoSubject() {\n          replaySubject.complete();\n        }\n\n        const sourceTemplate = ' 1234-------|';\n        const subscriber1 = hot('----(a|)').pipe(mergeMapTo(replaySubject));\n        const expected1 = '      ----(34)---|';\n\n        expectObservable(hot(sourceTemplate).pipe(tap({ next: feedNextIntoSubject, error: feedErrorIntoSubject, complete: feedCompleteIntoSubject }))).toBe(\n          sourceTemplate\n        );\n        expectObservable(subscriber1).toBe(expected1);\n      });\n    });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should be an Observer which can be given to Observable.subscribe","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":316,"column":70},"line":316,"code":"  it('should be an Observer which can be given to Observable.subscribe', () => {\n    const source = of(1, 2, 3, 4, 5);\n    const subject = new ReplaySubject<number>(3);\n    let results: (number | string)[] = [];\n\n    subject.subscribe(\n      { next: (x) => results.push(x), complete: () => results.push('done') }\n    );\n\n    source.subscribe(subject);\n\n    expect(results).to.deep.equal([1, 2, 3, 4, 5, 'done']);\n\n    results = [];\n\n    subject.subscribe(\n      { next: (x) => results.push(x), complete: () => results.push('done') }\n    );\n\n    expect(results).to.deep.equal([3, 4, 5, 'done']);\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not buffer nexted values after complete","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":338,"column":52},"line":338,"code":"  it('should not buffer nexted values after complete', () => {\n    const results: (number | string)[] = [];\n    const subject = new ReplaySubject<number>();\n    subject.next(1);\n    subject.next(2);\n    subject.complete();\n    subject.next(3);\n    subject.subscribe({\n      next: value => results.push(value),\n      complete: () => results.push('C'),\n    });\n    expect(results).to.deep.equal([1, 2, 'C']);\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should not buffer nexted values after error","suites":["ReplaySubject","with windowTime=4"],"updatePoint":{"line":352,"column":49},"line":352,"code":"  it('should not buffer nexted values after error', () => {\n    const results: (number | string)[] = [];\n    const subject = new ReplaySubject<number>();\n    subject.next(1);\n    subject.next(2);\n    subject.error(new Error('Boom!'));\n    subject.next(3);\n    subject.subscribe({\n      next: value => results.push(value),\n      error: () => results.push('E'),\n    });\n    expect(results).to.deep.equal([1, 2, 'E']);\n  });","file":"subjects/ReplaySubject-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore next messages after unsubscription","suites":["SafeSubscriber"],"updatePoint":{"line":9,"column":54},"line":9,"code":"  it('should ignore next messages after unsubscription', () => {\n    let times = 0;\n\n    const sub = new SafeSubscriber({\n      next() { times += 1; }\n    });\n\n    sub.next();\n    sub.next();\n    sub.unsubscribe();\n    sub.next();\n\n    expect(times).to.equal(2);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore error messages after unsubscription","suites":["SafeSubscriber"],"updatePoint":{"line":24,"column":55},"line":24,"code":"  it('should ignore error messages after unsubscription', () => {\n    let times = 0;\n    let errorCalled = false;\n\n    const sub = new SafeSubscriber({\n      next() { times += 1; },\n      error() { errorCalled = true; }\n    });\n\n    sub.next();\n    sub.next();\n    sub.unsubscribe();\n    sub.next();\n    sub.error();\n\n    expect(times).to.equal(2);\n    expect(errorCalled).to.be.false;\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should ignore complete messages after unsubscription","suites":["SafeSubscriber"],"updatePoint":{"line":43,"column":58},"line":43,"code":"  it('should ignore complete messages after unsubscription', () => {\n    let times = 0;\n    let completeCalled = false;\n\n    const sub = new SafeSubscriber({\n      next() { times += 1; },\n      complete() { completeCalled = true; }\n    });\n\n    sub.next();\n    sub.next();\n    sub.unsubscribe();\n    sub.next();\n    sub.complete();\n\n    expect(times).to.equal(2);\n    expect(completeCalled).to.be.false;\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should not be closed when other subscriber with same observer instance completes","suites":["SafeSubscriber"],"updatePoint":{"line":62,"column":86},"line":62,"code":"  it('should not be closed when other subscriber with same observer instance completes', () => {\n    const observer = {\n      next: function () { /*noop*/ }\n    };\n\n    const sub1 = new SafeSubscriber(observer);\n    const sub2 = new SafeSubscriber(observer);\n\n    sub2.complete();\n\n    expect(sub1.closed).to.be.false;\n    expect(sub2.closed).to.be.true;\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should call complete observer without any arguments","suites":["SafeSubscriber"],"updatePoint":{"line":76,"column":57},"line":76,"code":"  it('should call complete observer without any arguments', () => {\n    let argument: Array<any> | null = null;\n\n    const observer = {\n      complete: (...args: Array<any>) => {\n        argument = args;\n      }\n    };\n\n    const sub1 = new SafeSubscriber(observer);\n    sub1.complete();\n\n    expect(argument).to.have.lengthOf(0);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should chain interop unsubscriptions","suites":["SafeSubscriber"],"updatePoint":{"line":91,"column":42},"line":91,"code":"  it('should chain interop unsubscriptions', () => {\n    let observableUnsubscribed = false;\n    let subscriberUnsubscribed = false;\n    let subscriptionUnsubscribed = false;\n\n    const subscriber = new SafeSubscriber<void>();\n    subscriber.add(() => subscriberUnsubscribed = true);\n\n    const source = new Observable<void>(() => () => observableUnsubscribed = true);\n    const subscription = source.subscribe(asInteropSubscriber(subscriber));\n    subscription.add(() => subscriptionUnsubscribed = true);\n    subscriber.unsubscribe();\n\n    expect(observableUnsubscribed).to.be.true;\n    expect(subscriberUnsubscribed).to.be.true;\n    expect(subscriptionUnsubscribed).to.be.true;\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should have idempotent unsubscription","suites":["SafeSubscriber"],"updatePoint":{"line":109,"column":43},"line":109,"code":"  it('should have idempotent unsubscription', () => {\n    let count = 0;\n    const subscriber = new SafeSubscriber();\n    subscriber.add(() => ++count);\n    expect(count).to.equal(0);\n\n    subscriber.unsubscribe();\n    expect(count).to.equal(1);\n\n    subscriber.unsubscribe();\n    expect(count).to.equal(1);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should close, unsubscribe, and unregister all finalizers after complete","suites":["SafeSubscriber"],"updatePoint":{"line":122,"column":77},"line":122,"code":"  it('should close, unsubscribe, and unregister all finalizers after complete', () => {\n    let isUnsubscribed = false;\n    const subscriber = new SafeSubscriber();\n    subscriber.add(() => isUnsubscribed = true);\n    subscriber.complete();\n    expect(isUnsubscribed).to.be.true;\n    expect(subscriber.closed).to.be.true;\n    expect(getRegisteredFinalizers(subscriber).length).to.equal(0);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should close, unsubscribe, and unregister all finalizers after error","suites":["SafeSubscriber"],"updatePoint":{"line":132,"column":74},"line":132,"code":"  it('should close, unsubscribe, and unregister all finalizers after error', () => {\n    let isTornDown = false;\n    const subscriber = new SafeSubscriber({\n      error: () => {\n        // Mischief managed!\n        // Adding this handler here to prevent the call to error from\n        // throwing, since it will have an error handler now.\n      }\n    });\n    subscriber.add(() => isTornDown = true);\n    subscriber.error(new Error('test'));\n    expect(isTornDown).to.be.true;\n    expect(subscriber.closed).to.be.true;\n    expect(getRegisteredFinalizers(subscriber).length).to.equal(0);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should finalize and unregister all finalizers after complete","suites":["Subscriber"],"updatePoint":{"line":150,"column":66},"line":150,"code":"  it('should finalize and unregister all finalizers after complete', () => {\n    let isTornDown = false;\n    const subscriber = new Subscriber();\n    subscriber.add(() => { isTornDown = true });\n    subscriber.complete();\n    expect(isTornDown).to.be.true;\n    expect(getRegisteredFinalizers(subscriber).length).to.equal(0);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT break this context on next methods from unfortunate consumers","suites":["Subscriber"],"updatePoint":{"line":159,"column":78},"line":159,"code":"  it('should NOT break this context on next methods from unfortunate consumers', () => {\n    // This is a contrived class to illustrate that we can pass another\n    // object that is \"observer shaped\" and not have it lose its context\n    // as it would have in v5 - v6.\n    class CustomConsumer {\n      valuesProcessed: string[] = [];\n\n      // In here, we access instance state and alter it.\n      next(value: string) {\n        if (value === 'reset') {\n          this.valuesProcessed = [];\n        } else {\n          this.valuesProcessed.push(value);\n        }\n      }\n    };\n\n    const consumer = new CustomConsumer();\n\n    of('old', 'old', 'reset', 'new', 'new').subscribe(consumer);\n\n    expect(consumer.valuesProcessed).not.to.equal(['new', 'new']);\n  });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should allow changing the context of `this` in a POJO subscriber","suites":["Subscriber","deprecated next context mode"],"updatePoint":{"line":192,"column":72},"line":192,"code":"    it('should allow changing the context of `this` in a POJO subscriber', () => {\n      const results: any[] = [];\n\n      const source = new Observable<number>(subscriber => {\n        for (let i = 0; i < 10 && !subscriber.closed; i++) {\n          subscriber.next(i);\n        }\n        subscriber.complete();\n\n        return () => {\n          results.push('finalizer');\n        };\n      });\n\n      source.subscribe({\n        next: function (this: any, value) {\n          expect(this.unsubscribe).to.be.a('function');\n          results.push(value);\n          if (value === 3) {\n            this.unsubscribe();\n          }\n        },\n        complete() {\n          throw new Error('should not be called');\n        }\n      });\n\n      expect(results).to.deep.equal([0, 1, 2, 3, 'finalizer']);\n    });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT break this context on next methods from unfortunate consumers","suites":["Subscriber","deprecated next context mode"],"updatePoint":{"line":222,"column":80},"line":222,"code":"    it('should NOT break this context on next methods from unfortunate consumers', () => {\n      // This is a contrived class to illustrate that we can pass another\n      // object that is \"observer shaped\"\n      class CustomConsumer {\n        valuesProcessed: string[] = [];\n\n        // In here, we access instance state and alter it.\n        next(value: string) {\n          if (value === 'reset') {\n            this.valuesProcessed = [];\n          } else {\n            this.valuesProcessed.push(value);\n          }\n        }\n      };\n\n      const consumer = new CustomConsumer();\n\n      of('old', 'old', 'reset', 'new', 'new').subscribe(consumer);\n\n      expect(consumer.valuesProcessed).not.to.equal(['new', 'new']);\n    });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should not leak the destination","suites":["Subscriber","deprecated next context mode"],"updatePoint":{"line":249,"column":39},"line":249,"code":"    it('should not leak the destination', (done) => {\n      let observer: Observer<number> | undefined = {\n        next() { /* noop */ },\n        error() { /* noop */ },\n        complete() { /* noop */ }\n      };\n\n      const registry = new FinalizationRegistry((value: any) => {\n        expect(value).to.equal('observer');\n        done();\n      });\n      registry.register(observer, 'observer');\n\n      const subscription = of(42).subscribe(observer);\n\n      observer = undefined;\n      global.gc?.();\n    });","file":"Subscriber-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe child subscriptions","suites":["Subscription","add()"],"updatePoint":{"line":7,"column":46},"line":7,"code":"    it('should unsubscribe child subscriptions', () => {\n      const main = new Subscription();\n\n      let isCalled = false;\n      const child = new Subscription(() => {\n        isCalled = true;\n      });\n      main.add(child);\n      main.unsubscribe();\n\n      expect(isCalled).to.equal(true);\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe child subscriptions if it has already been unsubscribed","suites":["Subscription","add()"],"updatePoint":{"line":20,"column":82},"line":20,"code":"    it('should unsubscribe child subscriptions if it has already been unsubscribed', () => {\n      const main = new Subscription();\n      main.unsubscribe();\n\n      let isCalled = false;\n      const child = new Subscription(() => {\n        isCalled = true;\n      });\n      main.add(child);\n\n      expect(isCalled).to.equal(true);\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe a finalizer function that was passed","suites":["Subscription","add()"],"updatePoint":{"line":33,"column":63},"line":33,"code":"    it('should unsubscribe a finalizer function that was passed', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      main.add(() => {\n        isCalled = true;\n      });\n      main.unsubscribe();\n      expect(isCalled).to.be.true;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe a finalizer function that was passed immediately if it has been unsubscribed","suites":["Subscription","add()"],"updatePoint":{"line":43,"column":103},"line":43,"code":"    it('should unsubscribe a finalizer function that was passed immediately if it has been unsubscribed', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      main.unsubscribe();\n      main.add(() => {\n        isCalled = true;\n      });\n      expect(isCalled).to.be.true;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe an Unsubscribable when unsubscribed","suites":["Subscription","add()"],"updatePoint":{"line":53,"column":62},"line":53,"code":"    it('should unsubscribe an Unsubscribable when unsubscribed', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      main.add({\n        unsubscribe() {\n          isCalled = true;\n        }\n      });\n      main.unsubscribe();\n      expect(isCalled).to.be.true;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe an Unsubscribable if it is already unsubscribed","suites":["Subscription","add()"],"updatePoint":{"line":65,"column":74},"line":65,"code":"    it('should unsubscribe an Unsubscribable if it is already unsubscribed', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      main.unsubscribe();\n      main.add({\n        unsubscribe() {\n          isCalled = true;\n        }\n      });\n      expect(isCalled).to.be.true;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should remove added Subscriptions","suites":["Subscription","remove()"],"updatePoint":{"line":79,"column":41},"line":79,"code":"    it('should remove added Subscriptions', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      const child = new Subscription(() => {\n        isCalled = true;\n      });\n      main.add(child);\n      main.remove(child);\n      main.unsubscribe();\n      expect(isCalled).to.be.false;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should remove added functions","suites":["Subscription","remove()"],"updatePoint":{"line":91,"column":37},"line":91,"code":"    it('should remove added functions', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      const finalizer = () => {\n        isCalled = true;\n      };\n      main.add(finalizer);\n      main.remove(finalizer);\n      main.unsubscribe();\n      expect(isCalled).to.be.false;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should remove added unsubscribables","suites":["Subscription","remove()"],"updatePoint":{"line":103,"column":43},"line":103,"code":"    it('should remove added unsubscribables', () => {\n      let isCalled = false;\n      const main = new Subscription();\n      const unsubscribable = {\n        unsubscribe() {\n          isCalled = true;\n        }\n      }\n      main.add(unsubscribable);\n      main.remove(unsubscribable);\n      main.unsubscribe();\n      expect(isCalled).to.be.false;\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from all subscriptions, when some of them throw","suites":["Subscription","unsubscribe()"],"updatePoint":{"line":119,"column":74},"line":119,"code":"    it('should unsubscribe from all subscriptions, when some of them throw', (done) => {\n      const finalizers: number[] = [];\n\n      const source1 = new Observable(() => {\n        return () => {\n          finalizers.push(1);\n        };\n      });\n\n      const source2 = new Observable(() => {\n        return () => {\n          finalizers.push(2);\n          throw new Error('oops, I am a bad unsubscribe!');\n        };\n      });\n\n      const source3 = new Observable(() => {\n        return () => {\n          finalizers.push(3);\n        };\n      });\n\n      const subscription = merge(source1, source2, source3).subscribe();\n\n      setTimeout(() => {\n        expect(() => {\n          subscription.unsubscribe();\n        }).to.throw(UnsubscriptionError);\n        expect(finalizers).to.deep.equal([1, 2, 3]);\n        done();\n      });\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from all subscriptions, when adding a bad custom subscription to a subscription","suites":["Subscription","unsubscribe()"],"updatePoint":{"line":152,"column":106},"line":152,"code":"    it('should unsubscribe from all subscriptions, when adding a bad custom subscription to a subscription', (done) => {\n      const finalizers: number[] = [];\n\n      const sub = new Subscription();\n\n      const source1 = new Observable(() => {\n        return () => {\n          finalizers.push(1);\n        };\n      });\n\n      const source2 = new Observable(() => {\n        return () => {\n          finalizers.push(2);\n          sub.add(<any>({\n            unsubscribe: () => {\n              expect(sub.closed).to.be.true;\n              throw new Error('Who is your daddy, and what does he do?');\n            }\n          }));\n        };\n      });\n\n      const source3 = new Observable(() => {\n        return () => {\n          finalizers.push(3);\n        };\n      });\n\n      sub.add(merge(source1, source2, source3).subscribe());\n\n      setTimeout(() => {\n        expect(() => {\n          sub.unsubscribe();\n        }).to.throw(UnsubscriptionError);\n        expect(finalizers).to.deep.equal([1, 2, 3]);\n        done();\n      });\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should have idempotent unsubscription","suites":["Subscription","unsubscribe()"],"updatePoint":{"line":192,"column":45},"line":192,"code":"    it('should have idempotent unsubscription', () => {\n      let count = 0;\n      const subscription = new Subscription(() => ++count);\n      expect(count).to.equal(0);\n\n      subscription.unsubscribe();\n      expect(count).to.equal(1);\n\n      subscription.unsubscribe();\n      expect(count).to.equal(1);\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should unsubscribe from all parents","suites":["Subscription","unsubscribe()"],"updatePoint":{"line":204,"column":43},"line":204,"code":"    it('should unsubscribe from all parents', () => {\n      // https://github.com/ReactiveX/rxjs/issues/6351\n      const a = new Subscription(() => { /* noop */});\n      const b = new Subscription(() => { /* noop */});\n      const c = new Subscription(() => { /* noop */});\n      const d = new Subscription(() => { /* noop */});\n      a.add(d);\n      b.add(d);\n      c.add(d);\n      // When d is added to the subscriptions, it's added as a finalizer. The\n      // length is 1 because the finalizers passed to the ctors are stored in a\n      // separate property.\n      expect((a as any)._finalizers).to.have.length(1);\n      expect((b as any)._finalizers).to.have.length(1);\n      expect((c as any)._finalizers).to.have.length(1);\n      d.unsubscribe();\n      // When d is unsubscribed, it should remove itself from each of its\n      // parents.\n      expect((a as any)._finalizers).to.have.length(0);\n      expect((b as any)._finalizers).to.have.length(0);\n      expect((c as any)._finalizers).to.have.length(0);\n    });","file":"Subscription-spec.ts","skipped":false,"dir":"spec"},{"name":"should export TestScheduler","suites":["index"],"updatePoint":{"line":5,"column":33},"line":5,"code":"  it('should export TestScheduler', () => {\n    expect(index.TestScheduler).to.exist;\n  });","file":"testing/index-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a name","suites":["ArgumentOutOfRangeError"],"updatePoint":{"line":7,"column":24},"line":7,"code":"  it('Should have a name', () => {\n    expect(error.name).to.be.equal('ArgumentOutOfRangeError');\n  });","file":"util/ArgumentOutOfRangeError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a message","suites":["ArgumentOutOfRangeError"],"updatePoint":{"line":10,"column":27},"line":10,"code":"  it('Should have a message', () => {\n    expect(error.message).to.be.equal('argument out of range');\n  });","file":"util/ArgumentOutOfRangeError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a stack","suites":["ArgumentOutOfRangeError"],"updatePoint":{"line":13,"column":25},"line":13,"code":"  it('Should have a stack', () => {\n    expect(error.stack).to.be.a('string');\n  });","file":"util/ArgumentOutOfRangeError-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a class that subclasses error and has the right properties","suites":["createErrorClass"],"updatePoint":{"line":6,"column":78},"line":6,"code":"  it('should create a class that subclasses error and has the right properties', () => {\n    const MySpecialError: any = createErrorClass(\n      (_super) =>\n        function MySpecialError(this: any, arg1: number, arg2: string) {\n          _super(this);\n          this.message = 'Super special error!';\n          this.arg1 = arg1;\n          this.arg2 = arg2;\n        }\n    );\n\n    expect(MySpecialError).to.be.a('function');\n    const err = new MySpecialError(123, 'Test');\n    expect(err).to.be.an.instanceOf(Error);\n    expect(err).to.be.an.instanceOf(MySpecialError);\n    expect(err.constructor).to.equal(MySpecialError);\n    expect(err.stack).to.be.a('string');\n    expect(err.message).to.equal('Super special error!');\n    expect(err.arg1).to.equal(123);\n    expect(err.arg2).to.equal('Test');\n  });","file":"util/createErrorClass-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a name","suites":["EmptyError"],"updatePoint":{"line":7,"column":24},"line":7,"code":"  it('Should have a name', () => {\n    expect(error.name).to.be.equal('EmptyError');\n  });","file":"util/EmptyError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a message","suites":["EmptyError"],"updatePoint":{"line":10,"column":27},"line":10,"code":"  it('Should have a message', () => {\n    expect(error.message).to.be.equal('no elements in sequence');\n  });","file":"util/EmptyError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a stack","suites":["EmptyError"],"updatePoint":{"line":13,"column":25},"line":13,"code":"  it('Should have a stack', () => {\n    expect(error.stack).to.be.a('string');\n  });","file":"util/EmptyError-spec.ts","skipped":false,"dir":"spec"},{"name":"should schedule on the next microtask","suites":["Immediate"],"updatePoint":{"line":6,"column":43},"line":6,"code":"  it('should schedule on the next microtask', (done) => {\n    const results: number[] = [];\n    results.push(1);\n    setTimeout(() => results.push(5));\n    Immediate.setImmediate(() => results.push(3));\n    results.push(2);\n    Promise.resolve().then(() => results.push(4));\n\n    setTimeout(() => {\n      expect(results).to.deep.equal([1, 2, 3, 4, 5]);\n      done();\n    });\n  });","file":"util/Immediate-spec.ts","skipped":false,"dir":"spec"},{"name":"should cancel the task with clearImmediate","suites":["Immediate"],"updatePoint":{"line":20,"column":48},"line":20,"code":"  it('should cancel the task with clearImmediate', (done) => {\n    const results: number[] = [];\n    results.push(1);\n    setTimeout(() => results.push(5));\n    const handle = Immediate.setImmediate(() => results.push(3));\n    Immediate.clearImmediate(handle);\n    results.push(2);\n    Promise.resolve().then(() => results.push(4));\n\n    setTimeout(() => {\n      expect(results).to.deep.equal([1, 2, 4, 5]);\n      done();\n    });\n  });","file":"util/Immediate-spec.ts","skipped":false,"dir":"spec"},{"name":"should clear the task after execution","suites":["Immediate"],"updatePoint":{"line":35,"column":43},"line":35,"code":"  it('should clear the task after execution', (done) => {\n    const results: number[] = [];\n    Immediate.setImmediate(() => results.push(1));\n    Immediate.setImmediate(() => results.push(2));\n\n    setTimeout(() => {\n      const number = TestTools.pending();\n      expect(number).to.equal(0);\n      done();\n    });\n  });","file":"util/Immediate-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for RxJS Observable","suites":["isObservable"],"updatePoint":{"line":5,"column":44},"line":5,"code":"  it('should return true for RxJS Observable', () => {\n    const o = new Observable<any>();\n    expect(isObservable(o)).to.be.true;\n  });","file":"util/isObservable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for an observable that comes from another RxJS 5+ library","suites":["isObservable"],"updatePoint":{"line":10,"column":82},"line":10,"code":"  it('should return true for an observable that comes from another RxJS 5+ library', () => {\n    const o: any = {\n      lift() { /* noop */ },\n      subscribe() { /* noop */ },\n    };\n\n    expect(isObservable(o)).to.be.true;\n  });","file":"util/isObservable-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT return true for any old subscribable","suites":["isObservable"],"updatePoint":{"line":19,"column":53},"line":19,"code":"  it('should NOT return true for any old subscribable', () => {\n    const o: any = {\n      subscribe() { /* noop */ },\n    };\n\n    expect(isObservable(o)).to.be.false;\n  });","file":"util/isObservable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for null","suites":["isObservable"],"updatePoint":{"line":27,"column":34},"line":27,"code":"  it('should return false for null', () => {\n    expect(isObservable(null)).to.be.false;\n  });","file":"util/isObservable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for a number","suites":["isObservable"],"updatePoint":{"line":31,"column":38},"line":31,"code":"  it('should return false for a number', () => {\n    expect(isObservable(1)).to.be.false;\n  });","file":"util/isObservable-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for new Promise","suites":["isPromise"],"updatePoint":{"line":6,"column":40},"line":6,"code":"  it('should return true for new Promise', () => {\n    const o = new Promise<any>(() => null);\n    expect(isPromise(o)).to.be.true;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should return true for a Promise that comes from an Observable","suites":["isPromise"],"updatePoint":{"line":11,"column":68},"line":11,"code":"  it('should return true for a Promise that comes from an Observable', () => {\n    const o: any = of(null).toPromise();\n    expect(isPromise(o)).to.be.true;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should NOT return true for any Observable","suites":["isPromise"],"updatePoint":{"line":16,"column":47},"line":16,"code":"  it('should NOT return true for any Observable', () => {\n    const o: any = of(null);\n\n    expect(isPromise(o)).to.be.false;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for null","suites":["isPromise"],"updatePoint":{"line":22,"column":34},"line":22,"code":"  it('should return false for null', () => {\n    expect(isPromise(null)).to.be.false;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for undefined","suites":["isPromise"],"updatePoint":{"line":26,"column":39},"line":26,"code":"  it('should return false for undefined', () => {\n    expect(isPromise(undefined)).to.be.false;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for a number","suites":["isPromise"],"updatePoint":{"line":30,"column":38},"line":30,"code":"  it('should return false for a number', () => {\n    expect(isPromise(1)).to.be.false;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"should return false for a string","suites":["isPromise"],"updatePoint":{"line":34,"column":38},"line":34,"code":"  it('should return false for a string', () => {\n    expect(isPromise('1')).to.be.false;\n  });","file":"util/isPromise-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a name","suites":["ObjectUnsubscribedError"],"updatePoint":{"line":7,"column":24},"line":7,"code":"  it('Should have a name', () => {\n    expect(error.name).to.be.equal('ObjectUnsubscribedError');\n  });","file":"util/ObjectUnsubscribedError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a message","suites":["ObjectUnsubscribedError"],"updatePoint":{"line":10,"column":27},"line":10,"code":"  it('Should have a message', () => {\n    expect(error.message).to.be.equal('object unsubscribed');\n  });","file":"util/ObjectUnsubscribedError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a stack","suites":["ObjectUnsubscribedError"],"updatePoint":{"line":13,"column":25},"line":13,"code":"  it('Should have a stack', () => {\n    expect(error.stack).to.be.a('string');\n  });","file":"util/ObjectUnsubscribedError-spec.ts","skipped":false,"dir":"spec"},{"name":"should exist","suites":["pipe"],"updatePoint":{"line":5,"column":18},"line":5,"code":"  it('should exist', () => {\n    expect(pipe).to.be.a('function');\n  });","file":"util/pipe-spec.ts","skipped":false,"dir":"spec"},{"name":"should pipe two functions together","suites":["pipe"],"updatePoint":{"line":9,"column":40},"line":9,"code":"  it('should pipe two functions together', () => {\n    const a = (x: number) => x + x;\n    const b = (x: number) => x - 1;\n\n    const c = pipe(a, b);\n    expect(c).to.be.a('function');\n    expect(c(1)).to.equal(1);\n    expect(c(10)).to.equal(19);\n  });","file":"util/pipe-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the same function if only one is passed","suites":["pipe"],"updatePoint":{"line":19,"column":59},"line":19,"code":"  it('should return the same function if only one is passed', () => {\n    const a = <T>(x: T) => x;\n    const c = pipe(a);\n\n    expect(c).to.equal(a);\n  });","file":"util/pipe-spec.ts","skipped":false,"dir":"spec"},{"name":"should return the identity if not passed any functions","suites":["pipe"],"updatePoint":{"line":26,"column":60},"line":26,"code":"  it('should return the identity if not passed any functions', () => {\n    const c = pipe();\n\n    expect(c('whatever')).to.equal('whatever');\n    const someObj = {};\n    expect(c(someObj)).to.equal(someObj);\n  });","file":"util/pipe-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a name","suites":["TimeoutError"],"updatePoint":{"line":7,"column":24},"line":7,"code":"  it('Should have a name', () => {\n    expect(error.name).to.be.equal('TimeoutError');\n  });","file":"util/TimeoutError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a message","suites":["TimeoutError"],"updatePoint":{"line":10,"column":27},"line":10,"code":"  it('Should have a message', () => {\n    expect(error.message).to.be.equal('Timeout has occurred');\n  });","file":"util/TimeoutError-spec.ts","skipped":false,"dir":"spec"},{"name":"Should have a stack","suites":["TimeoutError"],"updatePoint":{"line":13,"column":25},"line":13,"code":"  it('Should have a stack', () => {\n    expect(error.stack).to.be.a('string');\n  });","file":"util/TimeoutError-spec.ts","skipped":false,"dir":"spec"},{"name":"should create a message that is a clear indication of its internal errors","suites":["UnsubscriptionError"],"updatePoint":{"line":6,"column":79},"line":6,"code":"  it('should create a message that is a clear indication of its internal errors', () => {\n    const err1 = new Error('Swiss cheese tastes amazing but smells like socks');\n    const err2 = new Error('User too big to fit in tiny European elevator');\n    const source1 = new Observable(() => () => { throw err1; });\n    const source2 = timer(1000);\n    const source3 = new Observable(() => () => { throw err2; });\n    const source = merge(source1, source2, source3);\n\n    const subscription = source.subscribe();\n\n    try {\n      subscription.unsubscribe();\n    } catch (err) {\n      if (err instanceof UnsubscriptionError) {\n        expect(err.errors).to.deep.equal([err1, err2]);\n        expect(err.name).to.equal('UnsubscriptionError');\n        expect(err.stack).to.be.a('string');\n      } else {\n        throw new TypeError('Invalid error type');\n      }\n    }\n  });","file":"util/UnsubscriptionError-spec.ts","skipped":false,"dir":"spec"},{"name":"should export static websocket subject creator functions","suites":["index"],"updatePoint":{"line":5,"column":62},"line":5,"code":"  it('should export static websocket subject creator functions', () => {\n    expect(index.webSocket).to.exist;\n  });","file":"websocket/index-spec.ts","skipped":false,"dir":"spec"}]}