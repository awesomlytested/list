{
    "repo": "antvis/G6",
    "url": "https://github.com/antvis/G6",
    "branch": "master",
    "configs": [
        {
            "package": "@antv/g6-core",
            "lang": "js",
            "dir": "packages/core/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@antv/g6-element",
            "lang": "js",
            "dir": "packages/element/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@antv/g6-pc",
            "lang": "js",
            "dir": "packages/pc/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@antv/g6-plugin",
            "lang": "js",
            "dir": "packages/plugin/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@antv/g6-react-node",
            "lang": "js",
            "dir": "packages/react-node/test",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        }
    ],
    "tests": [
        {
            "name": "register single behavior",
            "suites": [
                "Behavior"
            ],
            "updatePoint": {
                "line": 3,
                "column": 30,
                "index": 115
            },
            "line": 3,
            "code": "  it('register single behavior', () => {\n    Behavior.registerBehavior('first-behavior', {\n      getEvents() {\n        return {\n          click: 'onClick'\n        };\n      },\n\n      onClick() {// console.log('trigger click');\n      },\n\n      shouldBegin() {\n        return false;\n      }\n\n    });\n    expect(Behavior.hasBehavior('first-behavior')).toBe(true);\n    expect(Behavior.hasBehavior('test')).toBe(false);\n    const BehaviorInstance = Behavior.getBehavior('first-behavior');\n    const instance = new BehaviorInstance();\n    const events = instance.getEvents();\n    expect(Object.keys(events)).toEqual(['click']);\n    expect(instance.shouldBegin()).toEqual(false);\n  });",
            "file": "unit/behavior/index-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "register multiple behavior",
            "suites": [
                "Behavior"
            ],
            "updatePoint": {
                "line": 27,
                "column": 32,
                "index": 795
            },
            "line": 27,
            "code": "  it('register multiple behavior', () => {\n    Behavior.registerBehavior('first', {\n      getEvents() {\n        return {\n          click: 'onClick',\n          'edge:click': 'onEdgeClick',\n          contextmenu: 'onContextMenu'\n        };\n      },\n\n      onClick() {\n        return 'onclick';\n      },\n\n      onContextMenu() {\n        return 'onContextMenu';\n      }\n\n    });\n    Behavior.registerBehavior('second', {\n      getDefaultCfg() {\n        return {\n          style: {\n            fill: 'red'\n          }\n        };\n      },\n\n      getEvents() {\n        return {\n          drag: 'onDrag'\n        };\n      },\n\n      onDrag() {\n        return 'drag';\n      }\n\n    });\n    const FirstInstance = Behavior.getBehavior('first');\n    const SecondBehavior = Behavior.getBehavior('second');\n    const firstInstance = new FirstInstance();\n    const secondBehavior = new SecondBehavior();\n    expect(firstInstance).not.toBe(undefined);\n    expect(secondBehavior).not.toBe(undefined);\n    expect(Behavior.getBehavior('three')).toBe(undefined);\n    expect(Behavior.hasBehavior('first')).toBe(true);\n    expect(Behavior.hasBehavior('three')).toBe(false);\n    const config1 = firstInstance.getDefaultCfg();\n    expect(config1.style).toBe(undefined);\n    const events1 = firstInstance.getEvents();\n    expect(Object.keys(events1).length).toEqual(3);\n    expect(Object.keys(events1)).toEqual(['click', 'edge:click', 'contextmenu']);\n    const config = secondBehavior.getDefaultCfg();\n    expect(config.style.fill).toEqual('red');\n    expect(config.style.fill).not.toEqual('blue');\n    const drag = secondBehavior.onDrag();\n    expect(drag).toEqual('drag');\n  });",
            "file": "unit/behavior/index-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "register behavior without object",
            "suites": [
                "Behavior"
            ],
            "updatePoint": {
                "line": 86,
                "column": 38,
                "index": 2455
            },
            "line": 86,
            "code": "  it('register behavior without object', () => {\n    expect(() => {\n      Behavior.registerBehavior('first', undefined);\n    }).toThrow();\n  });",
            "file": "unit/behavior/index-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "not default behavior",
            "suites": [
                "Default Behavior"
            ],
            "updatePoint": {
                "line": 93,
                "column": 26,
                "index": 2629
            },
            "line": 93,
            "code": "  it('not default behavior', () => {\n    const DragCanvas = Behavior.getBehavior('drag-canvas');\n    expect(DragCanvas).toBe(undefined);\n  });",
            "file": "unit/behavior/index-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "initial animate",
            "suites": [
                "collapse combo initially"
            ],
            "updatePoint": {
                "line": 176,
                "column": 21,
                "index": 3202
            },
            "line": 176,
            "code": "  it('initial animate', done => {\n    const data2 = {\n      nodes: [{\n        id: 'node1',\n        x: 250,\n        y: 150,\n        comboId: 'combo'\n      }, {\n        id: 'node2',\n        x: 350,\n        y: 150,\n        comboId: 'combo'\n      }],\n      combos: [{\n        id: 'combo',\n        label: 'Combo1',\n        collapsed: true\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      fitCenter: true,\n      groupByTypes: false,\n      modes: {\n        default: ['drag-canvas', 'drag-node', 'drag-combo', 'collapse-expand-combo']\n      },\n      defaultCombo: {\n        type: 'circle',\n        labelCfg: {\n          position: 'top'\n        }\n      }\n    });\n    graph.read(data2);\n    expect(graph.get('vedges').length).toBe(0);\n    setTimeout(() => {\n      expect(graph.get('edges').filter(e => e.isVisible()).length).toBe(0);\n      done();\n    }, 16);\n  });",
            "file": "unit/combo-animate-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "collapse combo initially and no animation",
            "suites": [
                "collapse combo initially"
            ],
            "updatePoint": {
                "line": 218,
                "column": 47,
                "index": 4146
            },
            "line": 218,
            "code": "  it('collapse combo initially and no animation', done => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      groupByTypes: false,\n      modes: ['collapse-expand-combo'],\n      fitView: true,\n      defaultCombo: {\n        type: 'rect'\n      }\n    });\n    graph.read(data);\n    expect(graph.get('vedges').length).toBe(0);\n    expect(graph.findById('empty').getModel().x).toBe(100);\n    expect(graph.findById('empty').getModel().y).toBe(100);\n    setTimeout(() => {\n      graph.collapseExpandCombo('ROOT-1');\n      graph.collapseExpandCombo('CHILD-101-4-1');\n      expect(graph.get('edges').length).toBe(5);\n      expect(graph.get('edges').filter(e => e.isVisible()).length).toBe(2);\n      expect(graph.get('vedges').length).toBe(3);\n      setTimeout(() => {\n        graph.collapseExpandCombo('CHILD-92-5-1');\n        expect(graph.get('edges').filter(e => e.isVisible()).length).toBe(1);\n        expect(graph.get('vedges').length).toBe(4); // graph.destroy()\n\n        done();\n      }, 201);\n    }, 201);\n  });",
            "file": "unit/combo-animate-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "uncombo with id",
            "suites": [
                "collapse combo initially"
            ],
            "updatePoint": {
                "line": 249,
                "column": 21,
                "index": 5173
            },
            "line": 249,
            "code": "  it('uncombo with id', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      fitCenter: true,\n      groupByTypes: false\n    });\n    graph.read({\n      nodes: [{\n        id: 'node1',\n        x: 250,\n        y: 150,\n        comboId: 'combo'\n      }, {\n        id: 'node2',\n        x: 350,\n        y: 150,\n        comboId: 'combo2'\n      }],\n      combos: [{\n        id: 'combo',\n        label: 'Combo'\n      }, {\n        id: 'combo2',\n        label: 'Combo2'\n      }]\n    });\n    graph.uncombo('combo');\n    const newData = graph.save();\n    expect(newData.combos.length).toBe(1);\n  });",
            "file": "unit/combo-animate-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "changeData",
            "suites": [
                "combo changeData"
            ],
            "updatePoint": {
                "line": 99,
                "column": 16,
                "index": 1376
            },
            "line": 99,
            "code": "  it('changeData', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      groupByTypes: false\n    });\n    graph.read(data);\n    setTimeout(() => {\n      console.log('data changed');\n      graph.changeData(newData);\n      expect(graph.getNodes().length).toBe(8);\n      expect(graph.getEdges().length).toBe(3);\n      expect(graph.getCombos().length).toBe(1);\n    }, 200);\n  });",
            "file": "unit/combo-changeData-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "init item controller",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 15,
                "column": 26,
                "index": 359
            },
            "line": 15,
            "code": "  it('init item controller', () => {\n    const itemController = graph.get('itemController');\n    expect(itemController).not.toBe(false);\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "add & remove node",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 19,
                "column": 23,
                "index": 499
            },
            "line": 19,
            "code": "  it('add & remove node', () => {\n    const node = graph.addItem('node', {\n      type: 'circle',\n      color: '#ccc',\n      style: {\n        x: 50,\n        y: 50,\n        r: 20,\n        lineWidth: 2\n      }\n    });\n    expect(node).not.toBe(undefined);\n    const nodes = graph.get('nodes');\n    expect(nodes.length).toBe(1);\n    expect(nodes[0]).toEqual(node);\n    const node2 = graph.addItem('node', {\n      type: 'rect',\n      id: 'node0',\n      color: '#666',\n      style: {\n        x: 100,\n        y: 100,\n        width: 100,\n        height: 70\n      }\n    });\n    expect(node2).not.toBe(undefined);\n    expect(nodes.length).toBe(2);\n    expect(nodes[1]).toEqual(node2);\n    graph.removeItem(node);\n    expect(nodes.length).toBe(1);\n    expect(nodes[0]).toEqual(node2);\n    graph.removeItem(node2);\n    expect(nodes.length).toBe(0);\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "remove node with multiple edges",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 54,
                "column": 37,
                "index": 1356
            },
            "line": 54,
            "code": "  it('remove node with multiple edges', () => {\n    const node1 = graph.addItem('node', {\n      id: 'node1',\n      color: '#ccc',\n      style: {\n        x: 50,\n        y: 50,\n        r: 20,\n        lineWidth: 2\n      }\n    });\n    const node2 = graph.addItem('node', {\n      id: 'node2',\n      type: 'circle',\n      color: '#ccc',\n      style: {\n        x: 50,\n        y: 150,\n        r: 20,\n        lineWidth: 2\n      }\n    });\n    graph.addItem('node', {\n      id: 'node3',\n      type: 'circle',\n      color: '#ccc',\n      style: {\n        x: 50,\n        y: 200,\n        r: 20,\n        lineWidth: 2\n      }\n    });\n    graph.addItem('edge', {\n      id: 'edge1',\n      source: 'node1',\n      target: 'node2',\n      type: 'line'\n    });\n    graph.addItem('edge', {\n      id: 'edge2',\n      source: 'node1',\n      target: 'node3'\n    });\n    expect(node1.getEdges().length).toBe(2);\n    expect(node2.getEdges().length).toBe(1);\n    expect(graph.findById('edge1')).not.toBe(undefined);\n    expect(graph.findById('edge2')).not.toBe(undefined);\n    graph.removeItem(node1);\n    expect(graph.findById('edge1')).toBe(undefined);\n    expect(graph.findById('edge2')).toBe(undefined);\n    expect(node2.getEdges().length).toBe(0);\n    graph.clear();\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "add & remove edge",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 108,
                "column": 23,
                "index": 2588
            },
            "line": 108,
            "code": "  it('add & remove edge', () => {\n    graph.set('itemMap', {});\n    const node1 = graph.addItem('node', {\n      type: 'circle',\n      color: '#ccc',\n      x: 50,\n      y: 50,\n      size: 20,\n      style: {\n        lineWidth: 2\n      }\n    });\n    const node2 = graph.addItem('node', {\n      type: 'rect',\n      id: 'node4',\n      x: 100,\n      y: 100,\n      color: '#666',\n      size: [100, 70]\n    });\n    const edge = graph.addItem('edge', {\n      id: 'edge3',\n      source: node1.getID(),\n      target: 'node4'\n    });\n    expect(graph.get('edges').length).toEqual(1);\n    expect(graph.get('edges')[0]).toEqual(edge);\n    expect(Object.keys(graph.get('itemMap')).length).toEqual(3);\n    expect(graph.get('itemMap').edge3).toEqual(edge);\n    expect(node1.getEdges().length).toEqual(1);\n    expect(node2.getEdges().length).toEqual(1);\n    graph.removeItem(edge);\n    expect(graph.get('edges').length).toEqual(0);\n  }); // it('add edge of nodes that do not exist', () => {",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 145,
                "column": 12,
                "index": 3679
            },
            "line": 145,
            "code": "  it('update', () => {\n    const node = graph.addItem('node', {\n      id: 'node5',\n      x: 100,\n      y: 100,\n      size: 50,\n      color: '#ccc',\n      type: 'circle'\n    });\n    const group = node.get('group');\n    let matrix = group.getMatrix();\n    expect(matrix[6]).toBe(100);\n    expect(matrix[7]).toBe(100);\n    graph.update('node5', {\n      x: 150,\n      y: 150\n    });\n    matrix = node.get('group').getMatrix();\n    expect(matrix[6]).toBe(150);\n    expect(matrix[7]).toBe(150);\n    graph.update(node, {\n      style: {\n        fill: '#ccc'\n      }\n    });\n    const shape = node.get('keyShape');\n    expect(shape.attr('fill')).toEqual('#ccc');\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "fresh graph",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 173,
                "column": 17,
                "index": 4344
            },
            "line": 173,
            "code": "  it('fresh graph', done => {\n    graph.clear();\n    const node = graph.addItem('node', {\n      id: 'node6',\n      x: 100,\n      y: 100,\n      size: 50\n    });\n    const node2 = graph.addItem('node', {\n      id: 'node7',\n      x: 100,\n      y: 200,\n      size: 50\n    });\n    const node3 = graph.addItem('node', {\n      id: 'node8',\n      x: 300,\n      y: 100,\n      size: 50\n    });\n    const edge = graph.addItem('edge', {\n      id: 'edge4',\n      source: 'node6',\n      target: 'node7'\n    });\n    graph.paint();\n    let path = edge.get('keyShape').attr('path');\n    expect(path[0][1]).toBe(100);\n    expect(path[0][2]).toBe(125.5);\n    expect(path[1][1]).toBe(100);\n    expect(path[1][2]).toBe(174.5);\n    edge.setTarget(node3);\n    graph.refresh();\n    setTimeout(() => {\n      path = edge.get('keyShape').attr('path');\n      expect(path[0][1]).toBe(125.5);\n      expect(path[0][2]).toBe(100);\n      expect(path[1][1]).toBe(274.5);\n      expect(path[1][2]).toBe(100);\n      done();\n    }, 800);\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "show & hide item",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 215,
                "column": 22,
                "index": 5355
            },
            "line": 215,
            "code": "  it('show & hide item', () => {\n    const node = graph.addItem('node', {\n      id: 'node9',\n      x: 100,\n      y: 100,\n      size: 50\n    });\n    const node2 = graph.addItem('node', {\n      id: 'node10',\n      x: 100,\n      y: 100,\n      size: 50\n    });\n    const edge = graph.addItem('edge', {\n      id: 'edge5',\n      source: 'node9',\n      target: 'node10'\n    });\n    graph.hideItem('node9');\n    expect(node.isVisible()).toBe(false);\n    expect(edge.isVisible()).toBe(false);\n    graph.showItem(node);\n    expect(node.isVisible()).toBe(true);\n    expect(edge.isVisible()).toBe(true);\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "setItemState & clearItemStates",
            "suites": [
                "item controller"
            ],
            "updatePoint": {
                "line": 240,
                "column": 36,
                "index": 5967
            },
            "line": 240,
            "code": "  it('setItemState & clearItemStates', () => {\n    const node = graph.addItem('node', {\n      id: 'node11',\n      x: 100,\n      y: 100,\n      size: 50\n    });\n    const node2 = graph.addItem('node', {\n      id: 'node12',\n      x: 100,\n      y: 100,\n      size: 50\n    });\n    graph.setItemState(node, 'select', true);\n    expect(node.hasState('select')).toBe(true);\n    expect(node2.hasState('select')).toBe(false);\n    graph.clearItemStates(node, ['select']);\n    expect(node.hasState('select')).toBe(false);\n    graph.setItemState(node2, 'hover', true);\n    expect(node2.hasState('hover')).toBe(true);\n    graph.clearItemStates(node2, ['hover']);\n    expect(node2.hasState('hover')).toBe(false);\n  });",
            "file": "unit/graph/controller/item-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "set item state",
            "suites": [
                "graph state controller"
            ],
            "updatePoint": {
                "line": 48,
                "column": 20,
                "index": 886
            },
            "line": 48,
            "code": "  it('set item state', done => {\n    let graphCount = 0;\n    let itemCount = 0;\n    graph.on('graphstatechange', () => {\n      graphCount += 1;\n    });\n    graph.on('beforeitemstatechange', () => {\n      itemCount += 1;\n    });\n    graph.setItemState('node1', 'selected', true);\n    graph.setItemState('node2', 'selected', true);\n    expect(itemCount).toBe(2);\n    setTimeout(() => {\n      expect(graphCount).toBe(1);\n      done();\n    }, 100);\n  });",
            "file": "unit/graph/controller/state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "state with activate-relations",
            "suites": [
                "graph state controller"
            ],
            "updatePoint": {
                "line": 65,
                "column": 35,
                "index": 1352
            },
            "line": 65,
            "code": "  it('state with activate-relations', done => {\n    graph.off();\n    graph.addBehaviors('activate-relations', 'default');\n    const modes = graph.get('modes');\n    expect(Object.keys(modes)).toEqual(['default']);\n    expect(modes.default[0].type).toEqual('activate-relations');\n    graph.removeBehaviors('activate-relations', 'default');\n    expect(Object.keys(modes)).toEqual(['default']);\n    expect(modes.default).toEqual([]);\n    done();\n  });",
            "file": "unit/graph/controller/state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateGraphStates",
            "suites": [
                "graph state controller"
            ],
            "updatePoint": {
                "line": 76,
                "column": 23,
                "index": 1788
            },
            "line": 76,
            "code": "  it('updateGraphStates', done => {\n    graph.getNodes().forEach(node => {\n      graph.clearItemStates(node);\n    });\n    const node1 = graph.findById('node1');\n    graph.setItemState(node1, 'selected', true);\n    graph.setItemState(node1, 'hover', true);\n    graph.setItemState('node2', 'hover', true);\n    setTimeout(() => {\n      const states2 = graph.get('states');\n      expect(states2.selected.length).toBe(1);\n      expect(states2.hover.length).toBe(2);\n      done();\n    }, 100);\n  });",
            "file": "unit/graph/controller/state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default fit view",
            "suites": [
                "view"
            ],
            "updatePoint": {
                "line": 18,
                "column": 22,
                "index": 419
            },
            "line": 18,
            "code": "  it('default fit view', () => {\n    const data = {\n      nodes: [{\n        id: 'node',\n        x: 100,\n        y: 100,\n        size: [150, 100],\n        type: 'simple-rect',\n        color: '#333',\n        style: {\n          fill: '#666'\n        }\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const canvas = graph.get('canvas');\n    let bbox = canvas.getCanvasBBox();\n    expect(numberEqual(bbox.x, 10, 1)).toBe(true);\n    expect(numberEqual(bbox.y, 89, 1)).toBe(true);\n    expect(numberEqual(bbox.maxX, 490, 1)).toBe(true);\n    expect(numberEqual(bbox.width, 480, 1)).toBe(true);\n    expect(numberEqual(bbox.height, 321, 1)).toBe(true);\n    data.nodes[0].size = [200, 300];\n    graph.changeData(data);\n    graph.render();\n    bbox = graph.get('canvas').getCanvasBBox();\n    expect(numberEqual(bbox.x, 90, 1)).toBe(true);\n    expect(numberEqual(bbox.maxX, 410, 1)).toBe(true);\n    expect(numberEqual(bbox.y, 10, 1)).toBe(true);\n    expect(numberEqual(bbox.width, 320, 1)).toBe(true);\n    expect(numberEqual(bbox.height, 480, 1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "modify padding",
            "suites": [
                "view"
            ],
            "updatePoint": {
                "line": 51,
                "column": 20,
                "index": 1481
            },
            "line": 51,
            "code": "  it('modify padding', () => {\n    const data = {\n      nodes: [{\n        id: 'node',\n        x: 100,\n        y: 100,\n        size: [1000, 1500],\n        type: 'simple-rect',\n        color: '#333',\n        style: {\n          fill: '#666'\n        }\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    graph.fitView([50, 50]);\n    const bbox = graph.get('canvas').getCanvasBBox();\n    expect(numberEqual(bbox.x, 116, 1)).toBe(true);\n    expect(numberEqual(bbox.y, 50)).toBe(true);\n    expect(numberEqual(bbox.width, 266, 1)).toBe(true);\n    expect(numberEqual(bbox.height, 400, 1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "focus item",
            "suites": [
                "view"
            ],
            "updatePoint": {
                "line": 74,
                "column": 16,
                "index": 2085
            },
            "line": 74,
            "code": "  it('focus item', () => {\n    graph.clear();\n    graph.zoom(2, {\n      x: 250,\n      y: 250\n    });\n    const node = graph.addItem('node', {\n      id: 'focus-node',\n      type: 'circle',\n      x: 50,\n      y: 50,\n      size: 60,\n      color: '#666'\n    });\n    graph.focusItem(node);\n    let centerPoint = graph.getPointByCanvas(250, 250);\n    expect(centerPoint.x).toBe(50);\n    expect(centerPoint.y).toBe(50);\n    graph.zoom(0.1, {\n      x: 50,\n      y: 50\n    });\n    centerPoint = graph.getPointByCanvas(250, 250);\n    expect(centerPoint.x).not.toBe(50);\n    expect(centerPoint.y).not.toBe(50);\n    graph.focusItem('focus-node');\n    centerPoint = graph.getPointByCanvas(250, 250);\n    expect(centerPoint.x - 50 < 0.1).toBe(true);\n    expect(centerPoint.y - 50 < 0.1).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "focus edge",
            "suites": [
                "view"
            ],
            "updatePoint": {
                "line": 104,
                "column": 16,
                "index": 2876
            },
            "line": 104,
            "code": "  it('focus edge', () => {\n    const data = {\n      nodes: [{\n        id: '1',\n        x: 10,\n        y: 10\n      }, {\n        id: '2',\n        x: 25,\n        y: 40\n      }, {\n        id: '3',\n        x: -50,\n        y: 80\n      }],\n      edges: [{\n        source: '1',\n        target: '2'\n      }, {\n        source: '1',\n        target: '3'\n      }]\n    };\n    const g = new Graph({\n      container: div,\n      width: 500,\n      height: 500\n    });\n    g.read(data);\n    g.get('canvas').get('el').style.backgroundColor = '#ccc';\n    g.zoom(2, {\n      x: 10,\n      y: 10\n    });\n    g.focusItem(g.getEdges()[0]);\n    let centerPoint = g.getPointByCanvas(250, 250);\n    expect(centerPoint.x).toBe(17.5);\n    expect(centerPoint.y).toBe(25);\n    g.focusItem(g.getEdges()[1]);\n    centerPoint = g.getPointByCanvas(250, 250);\n    expect(centerPoint.x).toBe(-20);\n    expect(centerPoint.y).toBe(45);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getPointByCanvas",
            "suites": [
                "view"
            ],
            "updatePoint": {
                "line": 147,
                "column": 22,
                "index": 3782
            },
            "line": 147,
            "code": "  it('getPointByCanvas', () => {\n    const point = graph.getPointByCanvas(250, 250);\n    expect(numberEqual(point.x, 50, 0.1)).toBe(true);\n    expect(numberEqual(point.y, 50, 0.1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "fitViewByRules, not out of viewport, default rules",
            "suites": [
                "fitViewByRules, not out of viewport"
            ],
            "updatePoint": {
                "line": 176,
                "column": 56,
                "index": 4476
            },
            "line": 176,
            "code": "  it('fitViewByRules, not out of viewport, default rules', () => {\n    graph.fitView(0, {});\n    const bboxAfterFitView = graph.get('canvas').getCanvasBBox();\n    expect(numberEqual(graph.getZoom(), 1.59, 0.01)).toBe(true);\n    expect(numberEqual(bboxAfterFitView.x, 10, 1)).toBe(true);\n    expect(numberEqual(bboxAfterFitView.y, 90, 1)).toBe(true);\n    expect(numberEqual(bboxAfterFitView.width, 480, 1)).toBe(true);\n    expect(numberEqual(bboxAfterFitView.height, 321, 1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "fitViewByRules, not out of viewport, custom rules",
            "suites": [
                "fitViewByRules, not out of viewport"
            ],
            "updatePoint": {
                "line": 185,
                "column": 55,
                "index": 4968
            },
            "line": 185,
            "code": "  it('fitViewByRules, not out of viewport, custom rules', () => {\n    graph.fitView(0, {\n      onlyOutOfViewPort: true\n    });\n    const bboxAfterFitView = graph.get('canvas').getCanvasBBox();\n    expect(graph.getZoom()).toEqual(1);\n    expect(numberEqual(bboxAfterFitView.x, 100, 1)).toBe(true);\n    expect(numberEqual(bboxAfterFitView.y, 150, 1)).toBe(true);\n    expect(bboxAfterFitView.width).toEqual(bbox.width);\n    expect(bboxAfterFitView.height).toEqual(bbox.height);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "fitViewByRules, out of viewport, default rules",
            "suites": [
                "fitViewByRules, out of viewport"
            ],
            "updatePoint": {
                "line": 229,
                "column": 52,
                "index": 6029
            },
            "line": 229,
            "code": "  it('fitViewByRules, out of viewport, default rules', () => {\n    graph.fitView(0, {});\n    const bbox = graph.get('canvas').getCanvasBBox();\n    expect(numberEqual(graph.getZoom(), 0.25, 0.01)).toBe(true);\n    expect(numberEqual(bbox.x, 10, 1)).toBe(true);\n    expect(numberEqual(bbox.y, 35, 1)).toBe(true);\n    expect(numberEqual(bbox.width, 480, 1)).toBe(true);\n    expect(numberEqual(bbox.height, 430, 1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "fitViewByRules, out of viewport, custom rules",
            "suites": [
                "fitViewByRules, out of viewport"
            ],
            "updatePoint": {
                "line": 238,
                "column": 51,
                "index": 6457
            },
            "line": 238,
            "code": "  it('fitViewByRules, out of viewport, custom rules', () => {\n    graph.fitView(0, {\n      onlyOutOfViewPort: true,\n      direction: 'y'\n    });\n    const bbox = graph.get('canvas').getCanvasBBox();\n    expect(numberEqual(graph.getZoom(), 0.28, 0.01)).toBe(true);\n    expect(numberEqual(bbox.x, -18, 1)).toBe(true);\n    expect(numberEqual(bbox.y, 10, 1)).toBe(true);\n    expect(numberEqual(bbox.width, 536, 1)).toBe(true);\n    expect(numberEqual(bbox.height, 480, 1)).toBe(true);\n  });",
            "file": "unit/graph/controller/view-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "add a convex hull",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 145,
                "column": 23,
                "index": 2332
            },
            "line": 145,
            "code": "  it('add a convex hull', () => {\n    graph.createHull({\n      id: 'hull1',\n      members,\n      type: 'round-convex'\n    });\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "add a bubble hull",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 152,
                "column": 23,
                "index": 2464
            },
            "line": 152,
            "code": "  it('add a bubble hull', () => {\n    graph.createHull({\n      id: 'hull2',\n      nonMembers: members,\n      members: nonMembers,\n      type: 'bubble',\n      padding: 10,\n      style: {\n        fill: 'pink',\n        stroke: 'red'\n      }\n    });\n    const hulls = Object.values(graph.getHulls());\n    expect(hulls.length).toEqual(2);\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update a convex hull",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 167,
                "column": 26,
                "index": 2807
            },
            "line": 167,
            "code": "  it('update a convex hull', () => {\n    const convexHull = graph.getHullById('hull1');\n    convexHull.updateCfg({\n      style: {\n        fill: 'lightgreen',\n        stroke: 'green'\n      },\n      // TODO 如果这里设置为 15，会导致 convexHull.contain('4') 结果为 true\n      padding: 5\n    });\n    expect(convexHull.contain('4')).toEqual(false);\n    convexHull.addMember('4');\n    expect(convexHull.contain('4')).toEqual(true);\n    convexHull.updateCfg({\n      type: 'bubble'\n    });\n    expect(convexHull.contain('4')).toEqual(true);\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update a bubble hull",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 185,
                "column": 26,
                "index": 3332
            },
            "line": 185,
            "code": "  it('update a bubble hull', () => {\n    const bubbleHull = graph.getHullById('hull2');\n    expect(bubbleHull.contain('6')).toEqual(false);\n    bubbleHull.removeNonMember('6');\n    expect(bubbleHull.nonMembers.indexOf(graph.findById('6')) === -1).toEqual(true);\n    expect(bubbleHull.contain('4')).toEqual(true);\n    bubbleHull.removeMember('4');\n    expect(bubbleHull.contain('4')).toEqual(false);\n    bubbleHull.updateStyle({\n      opacity: 0.4,\n      fill: 'white'\n    });\n    bubbleHull.updateData(members, nonMembers);\n    expect(bubbleHull.contain('5')).toEqual(true);\n    bubbleHull.addNonMember('5');\n    expect(bubbleHull.contain('5')).toEqual(false);\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "hull with one member node",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 202,
                "column": 31,
                "index": 4004
            },
            "line": 202,
            "code": "  it('hull with one member node', () => {\n    graph.createHull({\n      id: 'hull3',\n      members: [graph.getNodes()[0]],\n      type: 'round-convex'\n    });\n    const hulls = Object.values(graph.getHulls());\n    expect(hulls.length).toEqual(3);\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "remove hull",
            "suites": [
                "graph hull"
            ],
            "updatePoint": {
                "line": 211,
                "column": 17,
                "index": 4241
            },
            "line": 211,
            "code": "  it('remove hull', () => {\n    let hullShapes = graph.get('hullGroup').get('children');\n    expect(hullShapes.length).toEqual(3);\n    expect(graph.getHulls()['hull2']).toBeDefined();\n    graph.removeHull('hull2');\n    hullShapes = graph.get('hullGroup').get('children');\n    expect(hullShapes.length).toEqual(2);\n    expect(graph.getHulls()['hull2']).not.toBeDefined();\n  });",
            "file": "unit/graph/graph-hull-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "new & destroy graph",
            "suites": [
                "graph"
            ],
            "updatePoint": {
                "line": 45,
                "column": 25,
                "index": 853
            },
            "line": 45,
            "code": "  it('new & destroy graph', () => {\n    const inst = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      modes: {\n        default: ['drag-node']\n      }\n    });\n    const length = div.childNodes.length;\n    data.nodes.forEach(node => {\n      node.x = Math.random() * 100;\n      node.y = Math.random() * 100;\n    });\n    inst.positionsAnimate();\n  });",
            "file": "unit/graph/positions-animate-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "export",
            "suites": [
                "G6 version"
            ],
            "updatePoint": {
                "line": 4,
                "column": 12,
                "index": 129
            },
            "line": 4,
            "code": "  it('export', () => {\n    expect(Global.version).toBe(version);\n  });",
            "file": "unit/index-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update arrow",
            "suites": [
                "issues"
            ],
            "updatePoint": {
                "line": 37,
                "column": 18,
                "index": 625
            },
            "line": 37,
            "code": "  it('update arrow', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      groupByTypes: false\n    });\n    graph.data(data);\n    graph.render();\n    graph.updateItem('edge1', {\n      style: {\n        endArrow: false,\n        startArrow: false\n      }\n    });\n    graph.setItemState('edge1', 'selected', true);\n    graph.setItemState('edge1', 'selected', false);\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "create combo with node",
            "suites": [
                "issues"
            ],
            "updatePoint": {
                "line": 55,
                "column": 28,
                "index": 1052
            },
            "line": 55,
            "code": "  it('create combo with node', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      groupByTypes: false\n    });\n    graph.data(data);\n    graph.render();\n    graph.createCombo('combo1', ['node1', 'node2']);\n    const combo = graph.getCombos();\n    expect(combo.length).toBe(1);\n    const comboIds = graph.getNodes().map(node => node.getModel().comboId);\n    expect(comboIds).toEqual(['combo1', 'combo1']);\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "create combo with node and combo",
            "suites": [
                "issues"
            ],
            "updatePoint": {
                "line": 70,
                "column": 38,
                "index": 1524
            },
            "line": 70,
            "code": "  it('create combo with node and combo', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 600,\n      groupByTypes: false\n    });\n    const combos = [{\n      id: 'combo'\n    }];\n    const data = {\n      nodes,\n      edges,\n      combos\n    };\n    graph.data(data);\n    graph.render();\n    graph.createCombo('combo1', ['node1', 'node2', 'combo']);\n    const comboIds = graph.getNodes().map(node => node.getModel().comboId); // combo1中包含两个节点\n\n    expect(comboIds).toEqual(['combo1', 'combo1']); // id 为 combo 的 combo 中应该添加一个 parentId，值为 combo1\n\n    const comboItems = graph.getCombos();\n    expect(comboItems.length).toBe(2);\n    const current = comboItems.filter(combo => combo.getModel().parentId);\n    expect(current.length).toBe(1);\n    expect(current[0].getModel().parentId).toEqual('combo1');\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "triangle arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 41,
                "column": 21,
                "index": 799
            },
            "line": 41,
            "code": "  it('triangle arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.triangle(10, 20, 25),\n          d: 25\n        }\n      }\n    });\n    const arrow = G6.Arrow.triangle(10, 20, 25);\n    expect(arrow).toEqual(`M 50,0 L 70,-5 L 70,5 Z`);\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "vee arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 53,
                "column": 16,
                "index": 1088
            },
            "line": 53,
            "code": "  it('vee arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.vee(15, 20, 25),\n          d: 25\n        }\n      }\n    });\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 63,
                "column": 19,
                "index": 1272
            },
            "line": 63,
            "code": "  it('circle arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.circle(5, 25),\n          d: 25\n        }\n      }\n    });\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "diamond arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 73,
                "column": 20,
                "index": 1455
            },
            "line": 73,
            "code": "  it('diamond arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.diamond(15, 15, 25),\n          d: 25\n        }\n      }\n    });\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "rect arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 83,
                "column": 17,
                "index": 1641
            },
            "line": 83,
            "code": "  it('rect arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.rect(15, 15, 25),\n          d: 25\n        }\n      }\n    });\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "triangle rect arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 93,
                "column": 26,
                "index": 1833
            },
            "line": 93,
            "code": "  it('triangle rect arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: {\n          path: G6.Arrow.triangleRect(15, 15, 15, 3, 5, 25),\n          d: 25\n        }\n      }\n    });\n  });",
            "file": "unit/shape/arrow/arrow-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "triangle arrow ",
            "suites": [
                "arrow test"
            ],
            "updatePoint": {
                "line": 43,
                "column": 21,
                "index": 824
            },
            "line": 43,
            "code": "  it('triangle arrow ', () => {\n    graph.updateItem(edge, {\n      style: {\n        endArrow: false\n      }\n    });\n    const keyShape = graph.getEdges()[0].getKeyShape();\n    graph.setItemState(edge, 'selected', true);\n    expect(keyShape.attr('endArrow').path).toBe('');\n    graph.setItemState(edge, 'selected', false);\n    expect(keyShape.attr('endArrow').path).toBe('');\n  });",
            "file": "unit/shape/arrow/state-update-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "render: combos and nodes with pos",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 92,
                "column": 39,
                "index": 1644
            },
            "line": 92,
            "code": "  it('render: combos and nodes with pos', () => {\n    const comboModels = graph.getCombos().map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(400);\n    expect(comboModels[1].x).toBe(400);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(300);\n    expect(comboModels[2].y).toBe(300);\n    const nodeModels = graph.getNodes().map(node => node.getModel());\n    expect(nodeModels[0].x).toBe(100 - 75 + 50);\n    expect(nodeModels[0].y).toBe(400 - 20 + 20);\n    expect(nodeModels[1].x).toBe(100 - 75 + 100);\n    expect(nodeModels[1].y).toBe(400 - 20 + 20);\n    expect(nodeModels[2].x).toBe(400 - 175 + 150);\n    expect(nodeModels[2].y).toBe(400 - 30 + 30);\n    expect(nodeModels[3].x).toBe(400 - 175 + 200);\n    expect(nodeModels[3].y).toBe(400 - 30 + 30);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "render: combos without pos, nodes with pos",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 110,
                "column": 48,
                "index": 2490
            },
            "line": 110,
            "code": "  it('render: combos without pos, nodes with pos', () => {\n    graph.destroy();\n    const testData = clone(simpleData);\n    testData.combos.forEach(combo => {\n      delete combo.x;\n      delete combo.y;\n    });\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    const comboModels = graph.getCombos().map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(75);\n    expect(comboModels[0].y).toBe(20);\n    expect(comboModels[1].x).toBe(175);\n    expect(comboModels[1].y).toBe(30);\n    expect(comboModels[2].x).not.toBe(undefined);\n    expect(comboModels[2].y).not.toBe(undefined);\n    const nodeModels = graph.getNodes().map(node => node.getModel());\n    expect(nodeModels[0].x).toBe(50);\n    expect(nodeModels[0].y).toBe(20);\n    expect(nodeModels[1].x).toBe(100);\n    expect(nodeModels[1].y).toBe(20);\n    expect(nodeModels[2].x).toBe(150);\n    expect(nodeModels[2].y).toBe(30);\n    expect(nodeModels[3].x).toBe(200);\n    expect(nodeModels[3].y).toBe(30);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateItem: combos from no pos update to pos",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 136,
                "column": 50,
                "index": 3476
            },
            "line": 136,
            "code": "  it('updateItem: combos from no pos update to pos', () => {\n    const testData = clone(simpleData);\n    testData.combos.forEach(combo => {\n      delete combo.x;\n      delete combo.y;\n    });\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    graph.updateItem('a', { ...poses[0]\n    });\n    graph.updateItem('b', { ...poses[1]\n    });\n    graph.updateItem('c', { ...poses[2]\n    });\n    const comboModels = graph.getCombos().map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(400);\n    expect(comboModels[1].x).toBe(400);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(300);\n    expect(comboModels[2].y).toBe(300);\n    const nodeModels = graph.getNodes().map(node => node.getModel());\n    expect(nodeModels[0].x).toBe(100 - 75 + 50);\n    expect(nodeModels[0].y).toBe(400 - 20 + 20);\n    expect(nodeModels[1].x).toBe(100 - 75 + 100);\n    expect(nodeModels[1].y).toBe(400 - 20 + 20);\n    expect(nodeModels[2].x).toBe(400 - 175 + 150);\n    expect(nodeModels[2].y).toBe(400 - 30 + 30);\n    expect(nodeModels[3].x).toBe(400 - 175 + 200);\n    expect(nodeModels[3].y).toBe(400 - 30 + 30);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateItem: update the nodes inside expanded/collapsed combo",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 168,
                "column": 66,
                "index": 4695
            },
            "line": 168,
            "code": "  it('updateItem: update the nodes inside expanded/collapsed combo', () => {\n    const nodes = graph.getNodes();\n    const newNodePoses = [{\n      x: 50,\n      y: 50\n    }, {\n      x: 150,\n      y: 150\n    }, {\n      x: 450,\n      y: 450\n    }, {\n      x: 450,\n      y: 400\n    }];\n    graph.updateItem(nodes[0], newNodePoses[0]);\n    graph.updateItem(nodes[1], newNodePoses[1]);\n    graph.updateItem(nodes[2], newNodePoses[2]);\n    graph.updateItem(nodes[3], newNodePoses[3]); // 上面手动更新单个节点是不会触发相关 combo 更新的，需要调用下面方法。但是下面方法是根据数据绘制的位置，如何控制根据内部元素位置还是 combo 数据位置\n    // 是否加参数，内部更新 combo 或渲染 combo 时才用 combo 数据位置\n\n    graph.updateCombos();\n    const expectComboPoses = [{\n      x: (newNodePoses[0].x + newNodePoses[1].x) / 2,\n      y: (newNodePoses[0].y + newNodePoses[1].y) / 2\n    }, {\n      x: (newNodePoses[2].x + newNodePoses[3].x) / 2,\n      y: (newNodePoses[2].y + newNodePoses[3].y) / 2\n    }];\n    const comboModels = graph.getCombos().map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(expectComboPoses[0].x);\n    expect(comboModels[0].y).toBe(expectComboPoses[0].y);\n    expect(comboModels[1].x).toBe(expectComboPoses[1].x);\n    expect(comboModels[1].y).toBe(expectComboPoses[1].y);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "1 initial collapsed with pos, 2 expand, 3 move combo, 4 move node, 5 collapse, 6 move combo, 7 move node",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 203,
                "column": 110,
                "index": 5951
            },
            "line": 203,
            "code": "  it('1 initial collapsed with pos, 2 expand, 3 move combo, 4 move node, 5 collapse, 6 move combo, 7 move node', done => {\n    graph.destroy();\n    const testData = clone(simpleData);\n    graph = new Graph(graphCfg);\n    graph.read(testData); // initial collapsed with pos\n\n    const combo = graph.findById('b');\n    const model = combo.getModel();\n    expect(model.x).toBe(400);\n    expect(model.y).toBe(400);\n    setTimeout(() => {\n      // 2 epxand\n      graph.collapseExpandCombo('b');\n      expect(model.x).toBe(400);\n      expect(model.y).toBe(400); // 3 move combo\n\n      graph.updateItem(combo, {\n        x: 200,\n        y: 100\n      });\n      expect(model.x).toBe(200);\n      expect(model.y).toBe(100); // 4 move node\n\n      const node = graph.findById('2');\n      graph.updateItem(node, {\n        x: 300,\n        y: 200\n      });\n      graph.updateCombos();\n      expect(node.getModel().x).toBe(300);\n      expect(node.getModel().y).toBe(200);\n      expect(model.x).toBe(262.5);\n      expect(model.y).toBe(150);\n      setTimeout(() => {\n        expect(Math.abs(combo.getKeyShape().attr('r') - 102) < 1).toBe(true); // 5 collapse\n\n        graph.collapseExpandCombo('b');\n        expect(model.x).toBe(262.5);\n        expect(model.y).toBe(150);\n        setTimeout(() => {\n          expect(Math.abs(combo.getKeyShape().attr('r') - 35) < 1).toBe(true); // 6 move combo\n\n          graph.updateItem(combo, {\n            x: 400,\n            y: 50\n          });\n          expect(model.x).toBe(400);\n          expect(model.y).toBe(50);\n          expect(Math.abs(combo.getKeyShape().attr('r') - 35) < 1).toBe(true); // 7 move node\n\n          const node = graph.findById('3');\n          graph.updateItem(node, {\n            x: 150,\n            y: 400\n          });\n          graph.updateCombos();\n          expect(node.getModel().x).toBe(150);\n          expect(node.getModel().y).toBe(400); // 收起状态下移动内部节点，combo 不会更新位置，因为计算 bbox 的时候忽略了隐藏元素\n\n          expect(model.x).toBe(400);\n          expect(model.y).toBe(50);\n          graph.collapseExpandCombo('b');\n          setTimeout(() => {\n            expect(model.x).toBe(293.75);\n            expect(model.y).toBe(250);\n            done();\n          }, 500);\n        }, 500);\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "1 initial collapsed without pos, 2 expand, 3 move combo, 4 move node, 5 collapse, 6 move combo, 7 move node",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 274,
                "column": 113,
                "index": 8208
            },
            "line": 274,
            "code": "  it('1 initial collapsed without pos, 2 expand, 3 move combo, 4 move node, 5 collapse, 6 move combo, 7 move node', done => {\n    const testData = clone(simpleData);\n    testData.combos.forEach(combo => {\n      delete combo.x;\n      delete combo.y;\n    });\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData); // initial collapsed with pos\n\n    const combo = graph.findById('b');\n    const model = combo.getModel();\n    expect(model.x).toBe(175);\n    expect(model.y).toBe(30);\n    setTimeout(() => {\n      // 2 epxand\n      graph.collapseExpandCombo('b');\n      setTimeout(() => {\n        expect(model.x).toBe(175);\n        expect(model.y).toBe(30); // 3 move combo\n\n        graph.updateItem(combo, {\n          x: 200,\n          y: 100\n        });\n        expect(model.x).toBe(200);\n        expect(model.y).toBe(100); // 4 move node\n\n        const node = graph.findById('2');\n        graph.updateItem(node, {\n          x: 300,\n          y: 200\n        });\n        graph.updateCombos();\n        expect(node.getModel().x).toBe(300);\n        expect(node.getModel().y).toBe(200);\n        expect(model.x).toBe(262.5);\n        expect(model.y).toBe(150);\n        setTimeout(() => {\n          expect(Math.abs(combo.getKeyShape().attr('r') - 102) < 1).toBe(true); // 5 collapse\n\n          graph.collapseExpandCombo('b');\n          setTimeout(() => {\n            expect(model.x).toBe(262.5);\n            expect(model.y).toBe(150);\n            expect(Math.abs(combo.getKeyShape().attr('r') - 35) < 1).toBe(true); // 6 7 与上一个 it 内容相同，不再重复\n\n            done();\n          }, 500);\n        }, 500);\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "1 initial expand with pos, 2 move node, 3 move combo, 4 collapse, 5 move node, 6 expand",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 327,
                "column": 93,
                "index": 9833
            },
            "line": 327,
            "code": "  it('1 initial expand with pos, 2 move node, 3 move combo, 4 collapse, 5 move node, 6 expand', done => {\n    graph.destroy();\n    const testData = clone(simpleData);\n    graph = new Graph(graphCfg);\n    graph.read(testData); // 1 initial expand with pos\n\n    const combo = graph.findById('a');\n    const model = combo.getModel();\n    expect(model.x).toBe(100);\n    expect(model.y).toBe(400); // 2 move node\n\n    const node = graph.findById('1');\n    const node1Model = node.getModel();\n    const node0Model = graph.findById('0').getModel();\n    graph.updateItem(node, {\n      x: 100,\n      y: 100\n    });\n    graph.updateCombos();\n    expect(node.getModel().x).toBe(100);\n    expect(node.getModel().y).toBe(100);\n    expect(model.x).toBe(87.5);\n    expect(model.y).toBe(250);\n    setTimeout(() => {\n      expect(Math.abs(combo.getKeyShape().attr('r') - 187) < 1).toBe(true); // 3 move combo\n\n      graph.updateItem(combo, {\n        x: 300,\n        y: 400\n      });\n      expect(model.x).toBe(300);\n      expect(model.y).toBe(400);\n      expect(node1Model.x).toBe(300 - 87.5 + 100);\n      expect(node1Model.y).toBe(400 - 250 + 100);\n      expect(node0Model.x).toBe(287.5);\n      expect(node0Model.y).toBe(550); // 4 collapse\n\n      graph.collapseExpandCombo('a');\n      setTimeout(() => {\n        expect(Math.abs(combo.getKeyShape().attr('r') - 35) < 1).toBe(true);\n        expect(model.x).toBe(300);\n        expect(model.y).toBe(400); // 5 move node, collapse 状态下移动节点，combo 位置不变\n\n        graph.updateItem('0', {\n          x: 50,\n          y: 50\n        });\n        expect(node0Model.x).toBe(50);\n        expect(node0Model.y).toBe(50);\n        expect(model.x).toBe(300);\n        expect(model.y).toBe(400); // 6 expand\n\n        graph.collapseExpandCombo('a');\n        setTimeout(() => {\n          expect(Math.abs(combo.getKeyShape().attr('r') - 204) < 1).toBe(true);\n          expect(model.x).toBe(181.25);\n          expect(model.y).toBe(150);\n          done();\n        }, 500);\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "1 initial expand without pos, 2 move node, 3 move combo, 4 collapse, 5 move node, 6 expand",
            "suites": [
                "simple data"
            ],
            "updatePoint": {
                "line": 389,
                "column": 96,
                "index": 11848
            },
            "line": 389,
            "code": "  it('1 initial expand without pos, 2 move node, 3 move combo, 4 collapse, 5 move node, 6 expand', done => {\n    const testData = clone(simpleData);\n    testData.combos.forEach(combo => {\n      delete combo.x;\n      delete combo.y;\n    });\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData); // 1 initial collapsed without pos\n\n    const combo = graph.findById('a');\n    const model = combo.getModel();\n    expect(model.x).toBe(75);\n    expect(model.y).toBe(20);\n    setTimeout(() => {\n      // 2 move node\n      const node = graph.findById('1');\n      const node1Model = node.getModel();\n      const node0Model = graph.findById('0').getModel();\n      graph.updateItem(node, {\n        x: 300,\n        y: 200\n      });\n      graph.updateCombos();\n      expect(node1Model.x).toBe(300);\n      expect(node1Model.y).toBe(200);\n      expect(model.x).toBe(175);\n      expect(model.y).toBe(110);\n      setTimeout(() => {\n        expect(Math.abs(combo.getKeyShape().attr('r') - 193) < 1).toBe(true); // 3 move combo\n\n        graph.updateItem(combo, {\n          x: 50,\n          y: 350\n        });\n        expect(model.x).toBe(50);\n        expect(model.y).toBe(350);\n        expect(node1Model.x).toBe(50 - 175 + 300);\n        expect(node1Model.y).toBe(350 - 110 + 200);\n        expect(node0Model.x).toBe(-75);\n        expect(node0Model.y).toBe(260); // 4 collapse\n\n        graph.collapseExpandCombo('a');\n        setTimeout(() => {\n          expect(Math.abs(combo.getKeyShape().attr('r') - 35) < 1).toBe(true);\n          expect(model.x).toBe(50);\n          expect(model.y).toBe(350); // 5 expand\n\n          graph.collapseExpandCombo('a');\n          setTimeout(() => {\n            expect(Math.abs(combo.getKeyShape().attr('r') - 193) < 1).toBe(true);\n            expect(model.x).toBe(50);\n            expect(model.y).toBe(350);\n            graph.destroy();\n            done();\n          }, 500);\n        }, 500);\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 471,
                "column": 44,
                "index": 14248
            },
            "line": 471,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // the child combo follow the parent\n\n    expect(comboBModel.x).toBe(100);\n    expect(comboBModel.y).toBe(200);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child empty combo B",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 478,
                "column": 30,
                "index": 14481
            },
            "line": 478,
            "code": "  it('move child empty combo B', done => {\n    graph.updateItem('B', {\n      x: 330,\n      y: 120\n    });\n    expect(comboBModel.x).toBe(330);\n    expect(comboBModel.y).toBe(120); // the parent combo follow the child\n\n    graph.updateCombos();\n    expect(comboAModel.x).toBe(330);\n    expect(comboAModel.y).toBe(120); // collpase combo B\n\n    graph.collapseExpandCombo('B');\n    setTimeout(() => {\n      // move combo B\n      graph.updateItem('B', {\n        x: 430,\n        y: 200\n      });\n      expect(comboBModel.x).toBe(430);\n      expect(comboBModel.y).toBe(200); // the parrent follow the child\n\n      graph.updateCombos();\n      expect(comboAModel.x).toBe(430);\n      expect(comboAModel.y).toBe(200);\n      done();\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 506,
                "column": 25,
                "index": 15217
            },
            "line": 506,
            "code": "  it('move parent combo A', done => {\n    graph.updateItem('A', {\n      x: 50,\n      y: 50\n    });\n    expect(comboAModel.x).toBe(50);\n    expect(comboAModel.y).toBe(50); // the child follow the parent\n\n    expect(comboBModel.x).toBe(50);\n    expect(comboBModel.y).toBe(50); // expand B\n\n    graph.collapseExpandCombo('B');\n    setTimeout(() => {\n      // no changes\n      expect(comboAModel.x).toBe(50);\n      expect(comboAModel.y).toBe(50);\n      expect(comboBModel.x).toBe(50);\n      expect(comboBModel.y).toBe(50);\n      done();\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, child combo with pos",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 527,
                "column": 52,
                "index": 15796
            },
            "line": 527,
            "code": "  it('parent combo without pos, child combo with pos', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    expect(comboBModel.x).toBe(300);\n    expect(comboBModel.y).toBe(400); // A has no position, follows the child\n\n    expect(comboAModel.x).toBe(300);\n    expect(comboAModel.y).toBe(400); // move B\n\n    graph.updateItem('B', {\n      x: 300,\n      y: 100\n    });\n    expect(comboBModel.x).toBe(300);\n    expect(comboBModel.y).toBe(100); // A follows the child\n\n    graph.updateCombos();\n    expect(comboAModel.x).toBe(300);\n    expect(comboAModel.y).toBe(100); // move A\n\n    graph.updateItem('A', {\n      x: 400,\n      y: 120\n    });\n    expect(comboBModel.x).toBe(400);\n    expect(comboBModel.y).toBe(120); // B follows the parent\n\n    expect(comboAModel.x).toBe(400);\n    expect(comboAModel.y).toBe(120);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo with pos, child combo without",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 565,
                "column": 48,
                "index": 16891
            },
            "line": 565,
            "code": "  it('parent combo with pos, child combo without', () => {\n    const testData = clone(data);\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    expect(comboBModel.x).toBe(100);\n    expect(comboBModel.y).toBe(200); // A has no position, follows the child\n\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data 1: combo A has one child: an empty combo B"
            ],
            "updatePoint": {
                "line": 582,
                "column": 59,
                "index": 17478
            },
            "line": 582,
            "code": "  it('parent combo collapsed with pos, child combo with pos', done => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    expect(comboBModel.x).toBe(100);\n    expect(comboBModel.y).toBe(200); // A has no position, follows the child\n\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // move A\n\n    graph.updateItem('A', {\n      x: 300,\n      y: 350\n    });\n    expect(comboAModel.x).toBe(300);\n    expect(comboAModel.y).toBe(350); // child follows A\n\n    expect(comboBModel.x).toBe(300);\n    expect(comboBModel.y).toBe(350); // expand A\n\n    graph.collapseExpandCombo('A');\n    setTimeout(() => {\n      expect(comboAModel.x).toBe(300);\n      expect(comboAModel.y).toBe(350); // child follows A\n\n      expect(comboBModel.x).toBe(300);\n      expect(comboBModel.y).toBe(350);\n      graph.destroy();\n      done();\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 649,
                "column": 44,
                "index": 19215
            },
            "line": 649,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // the child combo follow the parent\n\n    expect(comboBModel.x).toBe(232.75);\n    expect(comboBModel.y).toBe(377.75);\n    expect(nodeModel.x).toBe(-57.25);\n    expect(nodeModel.y).toBe(-2.25);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child empty combo B",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 658,
                "column": 30,
                "index": 19529
            },
            "line": 658,
            "code": "  it('move child empty combo B', () => {\n    graph.updateItem('B', {\n      x: 330,\n      y: 120\n    });\n    expect(comboBModel.x).toBe(330);\n    expect(comboBModel.y).toBe(120); // the sibling node is not changed\n\n    expect(nodeModel.x).toBe(-57.25);\n    expect(nodeModel.y).toBe(-2.25); // the parent combo follows the children\n\n    graph.updateCombos();\n    expect(comboAModel.x).toBe(148.625);\n    expect(comboAModel.y).toBe(71.125);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 673,
                "column": 25,
                "index": 19968
            },
            "line": 673,
            "code": "  it('move parent combo A', () => {\n    // done\n    graph.updateItem('A', {\n      x: 450,\n      y: 350\n    });\n    expect(comboAModel.x).toBe(450);\n    expect(comboAModel.y).toBe(350); // the child follow the parent\n\n    expect(comboBModel.x).toBe(450 - 148.625 + 330);\n    expect(comboBModel.y).toBe(350 - 71.125 + 120);\n    expect(nodeModel.x).toBe(450 - 148.625 - 57.25);\n    expect(nodeModel.y).toBe(350 - 71.125 - 2.25);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, children with pos",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 687,
                "column": 49,
                "index": 20424
            },
            "line": 687,
            "code": "  it('parent combo without pos, children with pos', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    node = graph.findById('0');\n    nodeModel = node.getModel();\n    expect(comboBModel.x).toBe(300);\n    expect(comboBModel.y).toBe(400);\n    expect(nodeModel.x).toBe(10);\n    expect(nodeModel.y).toBe(20); // A has no position, follows the child\n\n    expect(comboAModel.x).toBe(167.25);\n    expect(comboAModel.y).toBe(222.25);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo with pos, child combo without pos",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 708,
                "column": 52,
                "index": 21143
            },
            "line": 708,
            "code": "  it('parent combo with pos, child combo without pos', () => {\n    const testData = clone(data);\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    delete testData.nodes[0].x;\n    delete testData.nodes[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    node = graph.findById('0');\n    nodeModel = node.getModel();\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // B and 0 have no position, follow the parent\n    // the position is randomed, but inside the parent parent\n\n    expect(comboBModel.x).not.toBe(NaN);\n    expect(comboBModel.y).not.toBe(NaN);\n    expect(nodeModel.x).not.toBe(NaN);\n    expect(nodeModel.y).not.toBe(NaN);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data 2: combo A has 2 children: an empty combo B, a node"
            ],
            "updatePoint": {
                "line": 732,
                "column": 59,
                "index": 22014
            },
            "line": 732,
            "code": "  it('parent combo collapsed with pos, child combo with pos', () => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200);\n    expect(comboBModel.x).not.toBe(NaN);\n    expect(comboBModel.y).not.toBe(NaN);\n    expect(nodeModel.x).not.toBe(NaN);\n    expect(nodeModel.y).not.toBe(NaN);\n    graph.destroy();\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 796,
                "column": 44,
                "index": 23564
            },
            "line": 796,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // the child combo follow the parent\n\n    expect(comboBModel.x).toBe(161.7898448916085);\n    expect(comboBModel.y).toBe(321.7898448916085);\n    expect(nodeModels[0].x).toBe(1.7898448916085101);\n    expect(nodeModels[0].y).toBe(41.78984489160848);\n    expect(nodeModels[1].x).toBe(11.78984489160851);\n    expect(nodeModels[1].y).toBe(51.78984489160848);\n    expect(nodeModels[2].x).toBe(156.7898448916085);\n    expect(nodeModels[2].y).toBe(316.7898448916085);\n    expect(nodeModels[3].x).toBe(166.7898448916085);\n    expect(nodeModels[3].y).toBe(326.7898448916085);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child combo B",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 811,
                "column": 24,
                "index": 24244
            },
            "line": 811,
            "code": "  it('move child combo B', () => {\n    graph.updateItem('B', {\n      x: 330,\n      y: 120\n    });\n    graph.updateCombos();\n    expect(comboBModel.x).toBe(330);\n    expect(comboBModel.y).toBe(120); // the sibling node is not changed\n\n    expect(nodeModels[0].x).toBe(1.7898448916085101);\n    expect(nodeModels[0].y).toBe(41.78984489160848);\n    expect(nodeModels[1].x).toBe(11.78984489160851);\n    expect(nodeModels[1].y).toBe(51.78984489160848); // the children nodes of combo B follow B\n\n    expect(nodeModels[2].x).toBe(325);\n    expect(nodeModels[2].y).toBe(115);\n    expect(nodeModels[3].x).toBe(335);\n    expect(nodeModels[3].y).toBe(125); // the parent combo follows the children\n\n    expect(comboAModel.x).toBe(184.10507755419576);\n    expect(comboAModel.y).toBe(99.10507755419573);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 833,
                "column": 25,
                "index": 25042
            },
            "line": 833,
            "code": "  it('move parent combo A', done => {\n    graph.updateItem('A', {\n      x: 150,\n      y: 150\n    });\n    expect(comboAModel.x).toBe(150);\n    expect(comboAModel.y).toBe(150); // the child follow the parent\n\n    const dx = 150 - 184.10507755419576,\n          dy = 150 - 99.10507755419573;\n    expect(comboBModel.x).toBe(dx + 330);\n    expect(comboBModel.y).toBe(dy + 120);\n    expect(nodeModels[0].x).toBe(dx + 1.7898448916085101);\n    expect(nodeModels[0].y).toBe(dy + 41.78984489160848);\n    expect(nodeModels[1].x).toBe(dx + 11.78984489160851);\n    expect(nodeModels[1].y).toBe(dy + 51.78984489160848);\n    expect(nodeModels[2].x).toBe(dx + 325);\n    expect(nodeModels[2].y).toBe(dy + 115);\n    expect(nodeModels[3].x).toBe(dx + 335);\n    expect(nodeModels[3].y).toBe(dy + 125); // collapse B\n\n    graph.collapseExpandCombo('B');\n    setTimeout(() => {\n      // move B\n      graph.updateItem('B', {\n        x: 50,\n        y: 50\n      });\n      expect(comboBModel.x).toBe(50);\n      expect(comboBModel.y).toBe(50);\n      graph.updateCombos();\n      setTimeout(() => {\n        expect(Math.abs(comboA.getKeyShape().attr('r') - 105) < 1).toBe(true);\n        expect(comboAModel.x).toBe(21.092383668706375);\n        expect(comboAModel.y).toBe(64.09238366870638);\n        done();\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, children with pos",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 872,
                "column": 49,
                "index": 26375
            },
            "line": 872,
            "code": "  it('parent combo without pos, children with pos', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    nodes = graph.getNodes();\n    nodeModels = nodes.map(node => node.getModel());\n    expect(comboBModel.x).toBe(300);\n    expect(comboBModel.y).toBe(400);\n    expect(nodeModels[0].x).toBe(data.nodes[0].x);\n    expect(nodeModels[0].y).toBe(data.nodes[0].y);\n    expect(nodeModels[1].x).toBe(data.nodes[1].x);\n    expect(nodeModels[1].y).toBe(data.nodes[1].y); // 2 3 follows B\n\n    expect(nodeModels[2].x).toBe(295);\n    expect(nodeModels[2].y).toBe(395);\n    expect(nodeModels[3].x).toBe(305);\n    expect(nodeModels[3].y).toBe(405); // A has no position, follows the child\n\n    expect(comboAModel.x).toBe(238.2101551083915);\n    expect(comboAModel.y).toBe(278.2101551083915);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo with pos, child combo without pos",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 900,
                "column": 52,
                "index": 27444
            },
            "line": 900,
            "code": "  it('parent combo with pos, child combo without pos', () => {\n    const testData = clone(data);\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    testData.nodes.forEach(node => {\n      delete node.x;\n      delete node.y;\n    });\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    nodes = graph.getNodes();\n    nodeModels = nodes.map(node => node.getModel());\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200); // B and nodes have no position, follow the parent\n\n    expect(comboBModel.x).toBe(100);\n    expect(comboBModel.y).toBe(200);\n    nodeModels.forEach(nodeModel => {\n      expect(nodeModel.x).toBe(100);\n      expect(nodeModel.y).toBe(200);\n    }); // move node 3\n\n    graph.updateItem('3', {\n      x: 300,\n      y: 400\n    });\n    expect(nodeModels[3].x).toBe(300);\n    expect(nodeModels[3].y).toBe(400);\n    graph.updateCombos(); // B and A follow the change\n\n    expect(comboBModel.x).toBe((100 + 300) / 2);\n    expect(comboBModel.y).toBe((200 + 400) / 2);\n    expect(comboAModel.x).toBe((100 + 300) / 2);\n    expect(comboAModel.y).toBe((200 + 400) / 2);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data3: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 940,
                "column": 59,
                "index": 28741
            },
            "line": 940,
            "code": "  it('parent combo collapsed with pos, child combo with pos', done => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    comboA = graph.findById('A');\n    comboAModel = comboA.getModel();\n    comboB = graph.findById('B');\n    comboBModel = comboB.getModel();\n    nodes = graph.getNodes();\n    nodeModels = nodes.map(node => node.getModel());\n    expect(comboAModel.x).toBe(100);\n    expect(comboAModel.y).toBe(200);\n    setTimeout(() => {\n      // expand A\n      graph.collapseExpandCombo('A');\n      setTimeout(() => {\n        expect(comboB.isVisible()).toBe(true); // the child combo follow the parent\n\n        expect(comboBModel.x).toBe(161.7898448916085);\n        expect(comboBModel.y).toBe(321.7898448916085);\n        expect(nodeModels[0].x).toBe(1.7898448916085101);\n        expect(nodeModels[0].y).toBe(41.78984489160848);\n        expect(nodeModels[1].x).toBe(11.78984489160851);\n        expect(nodeModels[1].y).toBe(51.78984489160848);\n        expect(nodeModels[2].x).toBe(156.7898448916085);\n        expect(nodeModels[2].y).toBe(316.7898448916085);\n        expect(nodeModels[3].x).toBe(166.7898448916085);\n        expect(nodeModels[3].y).toBe(326.7898448916085);\n        graph.destroy();\n        done();\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1002,
                "column": 44,
                "index": 30693
            },
            "line": 1002,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200); // the child combo follow the parent\n\n    expect(comboModels[1].x).toBe(175);\n    expect(comboModels[1].y).toBe(350);\n    expect(comboModels[2].x).toBe(25);\n    expect(comboModels[2].y).toBe(50);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child combo B",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1011,
                "column": 24,
                "index": 31010
            },
            "line": 1011,
            "code": "  it('move child combo B', () => {\n    graph.updateItem('B', {\n      x: 130,\n      y: 120\n    });\n    graph.updateCombos();\n    expect(comboModels[1].x).toBe(130);\n    expect(comboModels[1].y).toBe(120); // the sibling node is not changed\n\n    expect(comboModels[2].x).toBe(25);\n    expect(comboModels[2].y).toBe(50); // the parent combo follows the children\n\n    expect(comboModels[0].x).toBe(77.5);\n    expect(comboModels[0].y).toBe(85);\n    expect(Math.abs(combos[0].getKeyShape().attr('r') - 240) < 1).toBe(true);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1027,
                "column": 25,
                "index": 31535
            },
            "line": 1027,
            "code": "  it('move parent combo A', () => {\n    graph.updateItem('A', {\n      x: 150,\n      y: 150\n    });\n    expect(comboModels[0].x).toBe(150);\n    expect(comboModels[0].y).toBe(150); // the child follow the parent\n\n    const dx = 150 - 77.5,\n          dy = 150 - 85;\n    expect(comboModels[1].x).toBe(dx + 130);\n    expect(comboModels[1].y).toBe(dy + 120);\n    expect(comboModels[2].x).toBe(dx + 25);\n    expect(comboModels[2].y).toBe(dy + 50);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, children with pos",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1042,
                "column": 49,
                "index": 32006
            },
            "line": 1042,
            "code": "  it('parent combo without pos, children with pos', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[1].x).toBe(300);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(150);\n    expect(comboModels[2].y).toBe(100); // A has no position, follows the child\n\n    expect(comboModels[0].x).toBe((300 + 150) / 2);\n    expect(comboModels[0].y).toBe((400 + 100) / 2);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo with pos, child combo without pos",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1059,
                "column": 52,
                "index": 32695
            },
            "line": 1059,
            "code": "  it('parent combo with pos, child combo without pos', () => {\n    const testData = clone(data);\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    delete testData.combos[2].x;\n    delete testData.combos[2].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200);\n    expect(comboModels[1].x).not.toBe(NaN);\n    expect(comboModels[1].y).not.toBe(NaN);\n    expect(comboModels[2].x).not.toBe(NaN);\n    expect(comboModels[2].y).not.toBe(NaN); // move node B and C\n\n    graph.updateItem('B', {\n      x: 300,\n      y: 400\n    });\n    graph.updateItem('C', {\n      x: 200,\n      y: 400\n    });\n    expect(comboModels[1].x).toBe(300);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(200);\n    expect(comboModels[2].y).toBe(400);\n    graph.updateCombos();\n    expect(comboModels[0].x).toBe((300 + 200) / 2);\n    expect(comboModels[0].y).toBe((400 + 400) / 2);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data4: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1093,
                "column": 59,
                "index": 33846
            },
            "line": 1093,
            "code": "  it('parent combo collapsed with pos, child combo with pos', done => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200);\n    setTimeout(() => {\n      // expand A\n      graph.collapseExpandCombo('A');\n      setTimeout(() => {\n        expect(combos[1].isVisible()).toBe(true);\n        expect(combos[2].isVisible()).toBe(true); // the child combo follow the parent\n\n        expect(comboModels[1].x).toBe(175);\n        expect(comboModels[1].y).toBe(350);\n        expect(comboModels[2].x).toBe(25);\n        expect(comboModels[2].y).toBe(50);\n        graph.destroy();\n        done();\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1161,
                "column": 44,
                "index": 35664
            },
            "line": 1161,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200); // the child combo follow the parent\n\n    expect(comboModels[1].x).toBe(100);\n    expect(comboModels[1].y).toBe(224.29780138165995);\n    expect(comboModels[2].x).toBe(50);\n    expect(comboModels[2].y).toBe(124.29780138165995);\n    expect(node0Model.x).toBe(50);\n    expect(node0Model.y).toBe(224.29780138165995);\n    expect(node1Model.x).toBe(150);\n    expect(node1Model.y).toBe(224.29780138165995);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child combo B",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1174,
                "column": 24,
                "index": 36185
            },
            "line": 1174,
            "code": "  it('move child combo B', done => {\n    graph.updateItem('B', {\n      x: 130,\n      y: 120\n    });\n    graph.updateCombos();\n    expect(comboModels[1].x).toBe(130);\n    expect(comboModels[1].y).toBe(120); // the sibling node is not changed\n\n    expect(comboModels[2].x).toBe(50);\n    expect(comboModels[2].y).toBe(124.29780138165995); // the parent combo follows the children\n\n    setTimeout(() => {\n      expect(comboModels[0].x).toBe(115.70219861834002);\n      expect(comboModels[0].y).toBe(120);\n      expect(Math.abs(combos[0].getKeyShape().attr('r') - 157) < 1).toBe(true);\n      done();\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1193,
                "column": 25,
                "index": 36799
            },
            "line": 1193,
            "code": "  it('move parent combo A', () => {\n    graph.updateItem('A', {\n      x: 150,\n      y: 150\n    });\n    expect(comboModels[0].x).toBe(150);\n    expect(comboModels[0].y).toBe(150); // the child follow the parent\n\n    const dx = 150 - 115.70219861834002,\n          dy = 150 - 120;\n    expect(comboModels[1].x).toBe(dx + 130);\n    expect(comboModels[1].y).toBe(dy + 120);\n    expect(comboModels[2].x).toBe(dx + 50);\n    expect(comboModels[2].y).toBe(dy + 124.29780138165995);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, children with pos",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1208,
                "column": 49,
                "index": 37301
            },
            "line": 1208,
            "code": "  it('parent combo without pos, children with pos', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[1].x).toBe(300);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(250);\n    expect(comboModels[2].y).toBe(300); // A has no position, follows the child\n\n    expect(comboModels[0].x).toBe(300);\n    expect(comboModels[0].y).toBe(375.70219861834005);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo with pos, child combo without pos",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1225,
                "column": 52,
                "index": 37981
            },
            "line": 1225,
            "code": "  it('parent combo with pos, child combo without pos', () => {\n    const testData = clone(data);\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    delete testData.combos[2].x;\n    delete testData.combos[2].y;\n    testData.nodes.forEach(node => {\n      delete node.x;\n      delete node.y;\n    });\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200);\n    expect(comboModels[1].x).not.toBe(NaN);\n    expect(comboModels[1].y).not.toBe(NaN);\n    expect(comboModels[2].x).not.toBe(NaN);\n    expect(comboModels[2].y).not.toBe(NaN); // move node B and C\n\n    graph.updateItem('B', {\n      x: 300,\n      y: 400\n    });\n    graph.updateItem('C', {\n      x: 200,\n      y: 400\n    });\n    expect(comboModels[1].x).toBe(300);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(200);\n    expect(comboModels[2].y).toBe(400);\n    graph.updateCombos();\n    expect(comboModels[0].x).toBe(252.42462120245875);\n    expect(comboModels[0].y).toBe(400);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data5: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1263,
                "column": 59,
                "index": 39210
            },
            "line": 1263,
            "code": "  it('parent combo collapsed with pos, child combo with pos', done => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200);\n    setTimeout(() => {\n      // expand A\n      graph.collapseExpandCombo('A');\n      setTimeout(() => {\n        expect(combos[1].isVisible()).toBe(true);\n        expect(combos[2].isVisible()).toBe(true); // the child combo follow the parent\n\n        expect(comboModels[1].x).toBe(100);\n        expect(comboModels[1].y).toBe(224.29780138165995);\n        expect(comboModels[2].x).toBe(50);\n        expect(comboModels[2].y).toBe(124.29780138165995);\n        graph.destroy();\n        done();\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "nested combo has different initial pos",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1316,
                "column": 44,
                "index": 40769
            },
            "line": 1316,
            "code": "  it('nested combo has different initial pos', () => {\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200); // the child combo follow the parent\n\n    expect(comboModels[1].x).toBe(100);\n    expect(comboModels[1].y).toBe(200);\n    expect(comboModels[2].x).toBe(100);\n    expect(comboModels[2].y).toBe(200);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move child combo B",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1325,
                "column": 24,
                "index": 41088
            },
            "line": 1325,
            "code": "  it('move child combo B', done => {\n    graph.updateItem('B', {\n      x: 130,\n      y: 120\n    });\n    graph.updateCombos();\n    expect(comboModels[1].x).toBe(130);\n    expect(comboModels[1].y).toBe(120); // child follows\n\n    expect(comboModels[2].x).toBe(130);\n    expect(comboModels[2].y).toBe(120); // the parent combo follows the children\n\n    setTimeout(() => {\n      expect(comboModels[0].x).toBe(130);\n      expect(comboModels[0].y).toBe(120);\n      expect(Math.abs(combos[0].getKeyShape().attr('r') - 130) < 1).toBe(true);\n      done();\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "move parent combo A",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1344,
                "column": 25,
                "index": 41655
            },
            "line": 1344,
            "code": "  it('move parent combo A', () => {\n    graph.updateItem('A', {\n      x: 150,\n      y: 150\n    });\n    expect(comboModels[0].x).toBe(150);\n    expect(comboModels[0].y).toBe(150); // the child follow the parent\n\n    expect(comboModels[1].x).toBe(150);\n    expect(comboModels[1].y).toBe(150);\n    expect(comboModels[2].x).toBe(150);\n    expect(comboModels[2].y).toBe(150);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo without pos, B and C has position",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1357,
                "column": 52,
                "index": 42059
            },
            "line": 1357,
            "code": "  it('parent combo without pos, B and C has position', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel()); // follow B\n\n    expect(comboModels[1].x).toBe(300);\n    expect(comboModels[1].y).toBe(400);\n    expect(comboModels[2].x).toBe(300);\n    expect(comboModels[2].y).toBe(400); // A has no position, follows the child\n\n    expect(comboModels[0].x).toBe(300);\n    expect(comboModels[0].y).toBe(400);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "A and B combo without pos, C has position",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1375,
                "column": 47,
                "index": 42732
            },
            "line": 1375,
            "code": "  it('A and B combo without pos, C has position', () => {\n    const testData = clone(data);\n    delete testData.combos[0].x;\n    delete testData.combos[0].y;\n    delete testData.combos[1].x;\n    delete testData.combos[1].y;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel()); // follow C\n\n    expect(comboModels[1].x).toBe(400);\n    expect(comboModels[1].y).toBe(500);\n    expect(comboModels[2].x).toBe(400);\n    expect(comboModels[2].y).toBe(500); // A has no position, follows the child\n\n    expect(comboModels[0].x).toBe(400);\n    expect(comboModels[0].y).toBe(500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "parent combo collapsed with pos, child combo with pos",
            "suites": [
                "hierarchy data6: combo A has 2 children: combo B with 2 nodes, 2 nodes"
            ],
            "updatePoint": {
                "line": 1395,
                "column": 59,
                "index": 43483
            },
            "line": 1395,
            "code": "  it('parent combo collapsed with pos, child combo with pos', done => {\n    const testData = clone(data);\n    testData.combos[0].collapsed = true;\n    graph.destroy();\n    graph = new Graph(graphCfg);\n    graph.read(testData);\n    combos = [graph.findById('A'), graph.findById('B'), graph.findById('C')];\n    comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[0].x).toBe(100);\n    expect(comboModels[0].y).toBe(200);\n    setTimeout(() => {\n      // expand A\n      graph.collapseExpandCombo('A');\n      setTimeout(() => {\n        expect(combos[1].isVisible()).toBe(true);\n        expect(combos[2].isVisible()).toBe(true); // the child combo follow the parent\n\n        expect(comboModels[1].x).toBe(100);\n        expect(comboModels[1].y).toBe(200);\n        expect(comboModels[2].x).toBe(100);\n        expect(comboModels[2].y).toBe(200);\n        graph.destroy();\n        done();\n      }, 500);\n    }, 500);\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "grid",
            "suites": [
                "placea grid combo and nodes"
            ],
            "updatePoint": {
                "line": 1486,
                "column": 10,
                "index": 45379
            },
            "line": 1486,
            "code": "  it('grid', () => {\n    const testData = clone(data);\n    const groupNodes = groupBy(testData.nodes, node => node.comboId);\n    Object.keys(groupNodes).forEach(key => {\n      groupNodes[key].forEach((node, i) => {\n        node.x = i * 50;\n        node.y = 0;\n      });\n    });\n    testData.combos[0].x = 250;\n    testData.combos[0].y = 250;\n    testData.combos[1].x = 0;\n    testData.combos[1].y = 100;\n    testData.combos[2].x = 250;\n    testData.combos[2].y = 450;\n    testData.combos[3].x = 250;\n    testData.combos[3].y = 550;\n    graph.read(testData);\n    const combos = testData.combos.map(cdata => graph.findById(cdata.id));\n    const comboModels = combos.map(combo => combo.getModel());\n    expect(comboModels[2].x).toBe(comboModels[0].x);\n    expect(comboModels[2].x).toBe(comboModels[1].x);\n    expect(comboModels[2].x).toBe(comboModels[3].x);\n    graph.destroy();\n  });",
            "file": "unit/shape/combo-collapsed-pos-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "get factory",
            "suites": [
                "combo node test",
                "basic method test"
            ],
            "updatePoint": {
                "line": 21,
                "column": 19,
                "index": 604
            },
            "line": 21,
            "code": "    it('get factory', () => {\n      const factory = Shape.getFactory('combo');\n      expect(factory).not.toBe(undefined);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "get default",
            "suites": [
                "combo node test",
                "basic method test"
            ],
            "updatePoint": {
                "line": 25,
                "column": 19,
                "index": 734
            },
            "line": 25,
            "code": "    it('get default', () => {\n      const factory = Shape.getFactory('combo');\n      const shape = factory.getShape();\n      expect(shape.type).toBe('circle');\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle no label",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 33,
                "column": 23,
                "index": 992
            },
            "line": 33,
            "code": "    it('circle no label', () => {\n      const group = canvas.addGroup();\n      translate(group, {\n        x: 50,\n        y: 50\n      });\n      const shape = factory.draw('circle', {\n        size: 40,\n        color: 'red'\n      }, group);\n      canvas.draw();\n      expect(shape.attr('r')).toBe(45); // size / 2 + padding\n\n      expect(group.getCount()).toBe(1);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle with label",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 48,
                "column": 25,
                "index": 1364
            },
            "line": 48,
            "code": "    it('circle with label', () => {\n      const group = canvas.addGroup();\n      translate(group, {\n        x: 150,\n        y: 100\n      });\n      factory.draw('circle', {\n        size: 200,\n        color: 'blue',\n        label: '你好，我好，大家好'\n      }, group);\n      canvas.draw();\n      expect(group.getCount()).toBe(2);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "rect",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 62,
                "column": 12,
                "index": 1678
            },
            "line": 62,
            "code": "    it('rect', () => {\n      const group = canvas.addGroup({\n        id: 'rect'\n      });\n      translate(group, {\n        x: 100,\n        y: 100\n      });\n      const shape = factory.draw('rect', {\n        size: [200, 120],\n        label: 'rect'\n      }, group);\n      canvas.draw(); // expect(shape.attr('x')).toBe(-20);\n      // expect(shape.attr('y')).toBe(-10);\n      // const label = group.get('children')[1];\n      // expect(label.attr('fill')).toBe('white');\n      // expect(group.getCount()).toBe(2);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 80,
                "column": 14,
                "index": 2198
            },
            "line": 80,
            "code": "    it('update', done => {\n      const group = canvas.addGroup({\n        id: 'rect'\n      }); // 伪造 item, 仅测试接口和图形的变化，不测试一致性\n\n      const item = new Combo({\n        model: {\n          size: [40, 20],\n          color: 'yellow',\n          type: 'rect',\n          labelCfg: {\n            style: {\n              fill: 'white'\n            }\n          },\n          style: {\n            fill: 'red'\n          }\n        },\n        group\n      });\n      factory.baseUpdate('rect', {\n        style: {\n          fill: 'red'\n        }\n      }, item);\n      const shape = group.get('children')[0];\n      expect(shape.attr('fill')).toBe('red');\n      expect(shape.attr('width')).toBe(80);\n      expect(group.getCount()).toBe(1);\n      factory.baseUpdate('rect', {\n        style: {\n          fill: 'blue'\n        },\n        label: 'new rect'\n      }, item);\n      expect(group.getCount()).toBe(2);\n      const label = group.get('children')[1];\n      expect(label.attr('text')).toBe('new rect');\n      factory.baseUpdate('rect', {\n        style: {\n          fill: 'red'\n        },\n        label: 'old rect'\n      }, item);\n      expect(label.attr('text')).toBe('old rect');\n      item.update({\n        style: {\n          fill: 'steelblue'\n        }\n      }); // since the update is animated, check it after 300ms\n\n      setTimeout(() => {\n        expect(shape.attr('fill')).toBe('steelblue');\n        done();\n      }, 300);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "active",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 137,
                "column": 14,
                "index": 3614
            },
            "line": 137,
            "code": "    it('active', () => {\n      const rectGroup = canvas.addGroup({\n        id: 'rect-active'\n      }); // 伪造 item, 仅测试接口和图形的变化，不测试一致性\n\n      const item = new Combo({\n        model: {\n          id: 'rectnode',\n          type: 'rect',\n          stateStyles: {\n            active: {\n              fillOpacity: 0.8\n            }\n          }\n        },\n        group: rectGroup\n      });\n      const shape = rectGroup.get('children')[0];\n      expect(shape.attr('fillOpacity')).toBe(1);\n      factory.setState('rectnode', 'active', true, item);\n      expect(shape.attr('fillOpacity')).not.toBe(1);\n      factory.setState('rectnode', 'active', false, item);\n      expect(shape.attr('fillOpacity')).toBe(1);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "label position",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 161,
                "column": 22,
                "index": 4331
            },
            "line": 161,
            "code": "    it('label position', () => {\n      const group = canvas.addGroup();\n      translate(group, {\n        x: 200,\n        y: 200\n      });\n      const model = {\n        color: 'green',\n        label: 'circle position',\n        labelCfg: {\n          position: 'top',\n          offset: 5\n        }\n      };\n      factory.draw('circle', model, group); // 伪造 item\n\n      const item = new Combo({\n        model,\n        group\n      });\n      const label = group.get('children')[1];\n      expect(label.attr('x')).toBe(0);\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "clear",
            "suites": [
                "combo node test",
                "nodes test"
            ],
            "updatePoint": {
                "line": 184,
                "column": 13,
                "index": 4845
            },
            "line": 184,
            "code": "    it('clear', () => {\n      canvas.destroy();\n    });",
            "file": "unit/shape/combo-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "node: hide by data and update",
            "suites": [
                "node: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 25,
                "column": 35,
                "index": 634
            },
            "line": 25,
            "code": "  it('node: hide by data and update', () => {\n    graph.data(data);\n    graph.render();\n    const node = graph.getNodes()[0];\n    expect(node.isVisible()).toEqual(false);\n    graph.updateItem(node, {\n      visible: true\n    });\n    expect(node.isVisible()).toEqual(true);\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "node: hide by data and show by graph",
            "suites": [
                "node: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 35,
                "column": 42,
                "index": 919
            },
            "line": 35,
            "code": "  it('node: hide by data and show by graph', () => {\n    data.nodes[0].visible = false;\n    graph.data(data);\n    graph.render();\n    const node = graph.getNodes()[0];\n    expect(node.isVisible()).toEqual(false);\n    graph.showItem(node);\n    expect(node.isVisible()).toEqual(true);\n    graph.destroy();\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "edge: hide by data and update",
            "suites": [
                "edge: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 70,
                "column": 35,
                "index": 1626
            },
            "line": 70,
            "code": "  it('edge: hide by data and update', () => {\n    graph.data(data);\n    graph.render();\n    const edge = graph.getEdges()[0];\n    expect(edge.isVisible()).toEqual(false);\n    graph.updateItem(edge, {\n      visible: true\n    });\n    expect(edge.isVisible()).toEqual(true);\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "edge: hide by data and show by graph",
            "suites": [
                "edge: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 80,
                "column": 42,
                "index": 1911
            },
            "line": 80,
            "code": "  it('edge: hide by data and show by graph', () => {\n    data.edges[0].visible = false;\n    graph.data(data);\n    graph.render();\n    const edge = graph.getEdges()[0];\n    expect(edge.isVisible()).toEqual(false);\n    graph.showItem(edge);\n    expect(edge.isVisible()).toEqual(true);\n    graph.destroy();\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "combo: hide by data and update",
            "suites": [
                "combo: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 119,
                "column": 36,
                "index": 2679
            },
            "line": 119,
            "code": "  it('combo: hide by data and update', () => {\n    graph.data(data);\n    graph.render();\n    const combo = graph.getCombos()[0];\n    expect(combo.isVisible()).toEqual(false);\n    graph.updateItem(combo, {\n      visible: true\n    });\n    expect(combo.isVisible()).toEqual(true);\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "combo: hide by data and show by graph",
            "suites": [
                "combo: hide by assigning visibile in data"
            ],
            "updatePoint": {
                "line": 129,
                "column": 43,
                "index": 2970
            },
            "line": 129,
            "code": "  it('combo: hide by data and show by graph', () => {\n    data.combos[0].visible = false;\n    graph.data(data);\n    graph.render();\n    const combo = graph.getCombos()[0];\n    expect(combo.isVisible()).toEqual(false);\n    graph.showItem(combo);\n    expect(combo.isVisible()).toEqual(true);\n    graph.destroy();\n  });",
            "file": "unit/shape/data-visible-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "get factory",
            "suites": [
                "shape edge test",
                "basic method test"
            ],
            "updatePoint": {
                "line": 18,
                "column": 19,
                "index": 551
            },
            "line": 18,
            "code": "    it('get factory', () => {\n      const factory = Shape.getFactory('edge');\n      expect(factory).not.toEqual(undefined);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "get default",
            "suites": [
                "shape edge test",
                "basic method test"
            ],
            "updatePoint": {
                "line": 22,
                "column": 19,
                "index": 683
            },
            "line": 22,
            "code": "    it('get default', () => {\n      const factory = Shape.getFactory('edge');\n      const shape = factory.getShape();\n      expect(shape.type).toEqual('line');\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "line without label",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 30,
                "column": 26,
                "index": 942
            },
            "line": 30,
            "code": "    it('line without label', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('line', {\n        startPoint: {\n          x: 50,\n          y: 50\n        },\n        endPoint: {\n          x: 100,\n          y: 100\n        },\n        color: 'red'\n      }, group);\n      canvas.draw();\n      const path = shape.attr('path');\n      expect(shape.attr('stroke')).toEqual('red');\n      expect(path.length).toEqual(2);\n      expect(path[0]).toEqual(['M', 50, 50]);\n      expect(group.getCount()).toEqual(1);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "line with label",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 50,
                "column": 23,
                "index": 1474
            },
            "line": 50,
            "code": "    it('line with label', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('line', {\n        startPoint: {\n          x: 150,\n          y: 50\n        },\n        endPoint: {\n          x: 100,\n          y: 100\n        },\n        color: 'blue',\n        label: '这是一条线'\n      }, group);\n      expect(shape.attr('path').length).toEqual(2);\n      const label = group.get('children')[1];\n      expect(shape.attr('path').length).toEqual(2);\n      expect(label.attr('x')).toEqual((100 + 150) / 2);\n      expect(label.attr('y')).toEqual((100 + 50) / 2);\n      expect(group.getCount()).toEqual(2);\n      const item = {\n        getContainer() {\n          return group;\n        },\n\n        get() {\n          return '';\n        }\n\n      };\n      factory.baseUpdate('shape', {\n        startPoint: {\n          x: 150,\n          y: 50\n        },\n        endPoint: {\n          x: 100,\n          y: 100\n        },\n        color: 'blue',\n        label: '这是一条线',\n        labelCfg: {\n          position: 'start'\n        }\n      }, item);\n      canvas.draw();\n      expect(label.attr('x')).toEqual(150);\n      expect(label.attr('y')).toEqual(50);\n      factory.baseUpdate('shape', {\n        startPoint: {\n          x: 150,\n          y: 50\n        },\n        endPoint: {\n          x: 100,\n          y: 100\n        },\n        color: 'blue',\n        label: '这是一条线',\n        labelCfg: {\n          position: 'end'\n        }\n      }, item);\n      canvas.draw();\n      expect(label.attr('x')).toEqual(100);\n      expect(label.attr('y')).toEqual(100);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "line with overlapped nodes and label",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 117,
                "column": 44,
                "index": 3053
            },
            "line": 117,
            "code": "    it('line with overlapped nodes and label', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('line', {\n        startPoint: {\n          x: 150,\n          y: 150\n        },\n        endPoint: {\n          x: 150,\n          y: 150\n        },\n        color: 'blue',\n        label: '这是一条线'\n      }, group);\n      expect(shape.attr('path').length).toEqual(2);\n      const label = group.get('children')[1];\n      expect(shape.attr('path').length).toEqual(2);\n      expect(label.attr('x')).toEqual(150);\n      expect(label.attr('y')).toEqual(150);\n      expect(group.getCount()).toEqual(2);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update points",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 139,
                "column": 21,
                "index": 3674
            },
            "line": 139,
            "code": "    it('update points', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('line', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 150,\n          y: 100\n        },\n        color: 'yellow',\n        label: '这是另一条线'\n      }, group);\n      expect(shape.attr('path')[0]).toEqual(['M', 200, 200]);\n      expect(group.getCount()).toEqual(2);\n      const item = {\n        getContainer() {\n          return group;\n        },\n\n        get() {\n          return '';\n        }\n\n      };\n      factory.baseUpdate('line', {\n        startPoint: {\n          x: 300,\n          y: 300\n        },\n        endPoint: {\n          x: 250,\n          y: 200\n        },\n        color: 'pink',\n        label: '这是不是另一条线'\n      }, item);\n      expect(shape.attr('path')[0]).toEqual(['M', 300, 300]);\n      const label = group.get('children')[1];\n      expect(label.attr('x')).toEqual((300 + 250) / 2);\n      expect(label.attr('y')).toEqual((300 + 200) / 2);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "quadratic",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 183,
                "column": 17,
                "index": 4711
            },
            "line": 183,
            "code": "    it('quadratic', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('quadratic', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 150,\n          y: 100\n        },\n        controlPoints: [{\n          x: 220,\n          y: 160\n        }],\n        color: 'green',\n        label: '这是一条曲线'\n      }, group);\n      const path = shape.attr('path');\n      expect(path.length).toEqual(2);\n      expect(path[1]).toEqual(['Q', 220, 160, 150, 100]);\n      const group1 = canvas.addGroup();\n      const shape1 = factory.draw('quadratic', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 100,\n          y: 100\n        },\n        color: 'red',\n        label: 'xxxx',\n        labelCfg: {\n          autoRotate: true\n        }\n      }, group1);\n      expect(shape1.attr('path').length).toEqual(2);\n      const sqrt2 = Math.sqrt(2);\n      expect(shape1.attr('path')[1]).toEqual(['Q', 150 - 20 * sqrt2 / 2, 150 + 20 * sqrt2 / 2, 100, 100]);\n      canvas.draw(); // update with control points\n\n      const item = {\n        getContainer() {\n          return group1;\n        },\n\n        get() {\n          return '';\n        }\n\n      };\n      factory.baseUpdate('quadratic', {\n        startPoint: {\n          x: 300,\n          y: 300\n        },\n        endPoint: {\n          x: 250,\n          y: 200\n        },\n        controlPoints: {\n          x: 350,\n          y: 350\n        },\n        color: 'pink',\n        label: '这是不是另一条线'\n      }, item);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "cubic",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 252,
                "column": 13,
                "index": 6276
            },
            "line": 252,
            "code": "    it('cubic', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('cubic', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 150,\n          y: 100\n        },\n        controlPoints: [{\n          x: 220,\n          y: 200\n        }, {\n          x: 170,\n          y: 100\n        }],\n        color: 'red'\n      }, group);\n      const path = shape.attr('path');\n      expect(path.length).toEqual(2);\n      expect(path[1]).toEqual(['C', 220, 200, 170, 100, 150, 100]);\n      const shape1 = factory.draw('cubic', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 150,\n          y: 100\n        },\n        color: 'blue'\n      }, group);\n      expect(shape1.attr('path').length).toEqual(2);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "cubic vertical",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 289,
                "column": 22,
                "index": 7130
            },
            "line": 289,
            "code": "    it('cubic vertical', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('cubic-vertical', {\n        startPoint: {\n          x: 0,\n          y: 0\n        },\n        endPoint: {\n          x: 150,\n          y: 150\n        },\n        color: 'red'\n      }, group);\n      expect(shape.attr('path')[1]).toEqual(['C', 0, 75, 150, 75, 150, 150]);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "cubic horizontal",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 305,
                "column": 24,
                "index": 7532
            },
            "line": 305,
            "code": "    it('cubic horizontal', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('cubic-horizontal', {\n        startPoint: {\n          x: 0,\n          y: 0\n        },\n        endPoint: {\n          x: 150,\n          y: 150\n        },\n        color: 'red'\n      }, group);\n      expect(shape.attr('path')[1]).toEqual(['C', 75, 0, 75, 150, 150, 150]);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "arc",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 321,
                "column": 11,
                "index": 7923
            },
            "line": 321,
            "code": "    it('arc', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('arc', {\n        startPoint: {\n          x: 0,\n          y: 0\n        },\n        endPoint: {\n          x: 150,\n          y: 150\n        },\n        color: 'red',\n        curveOffset: 10\n      }, group);\n      expect(shape.attr('path')[1]).toEqual(['A', 567.4999999999995, 567.4999999999995, 0, 0, 1, 150, 150]); // update curveOffset to nagtive\n\n      const item = {\n        getContainer() {\n          return group;\n        },\n\n        get() {\n          return '';\n        }\n\n      };\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 0,\n          y: 0\n        },\n        endPoint: {\n          x: 150,\n          y: 150\n        },\n        curveOffset: -10\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 567.4999999999995, 567.4999999999995, 0, 0, 0, 150, 150]); // update to add controlpoints\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 50,\n          y: 50\n        },\n        endPoint: {\n          x: 200,\n          y: 200\n        },\n        controlPoints: [{\n          x: 150,\n          y: 250\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 111.80339887498948, 111.80339887498948, 0, 0, 0, 200, 200]); // update with controlpoints and different clockwise\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 50,\n          y: 50\n        },\n        endPoint: {\n          x: 200,\n          y: 200\n        },\n        controlPoints: [{\n          x: 100,\n          y: 180\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 125.54879529489719, 125.54879529489719, 0, 0, 1, 200, 200]); // update with controlpoints and different clockwise\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 50,\n          y: 200\n        },\n        endPoint: {\n          x: 200,\n          y: 50\n        },\n        controlPoints: [{\n          x: 150,\n          y: 250\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 108.65337342004415, 108.65337342004415, 0, 0, 1, 200, 50]); // update with controlpoints and different clockwise\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 50,\n          y: 50\n        },\n        controlPoints: [{\n          x: 100,\n          y: 180\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 125.54879529489719, 125.54879529489719, 0, 0, 1, 50, 50]); // update with controlpoints and different clockwise\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 200,\n          y: 50\n        },\n        endPoint: {\n          x: 50,\n          y: 200\n        },\n        controlPoints: [{\n          x: 100,\n          y: 180\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 208.17994353176505, 208.17994353176505, 0, 0, 0, 50, 200]); // update with controlpoints and different clockwise\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 50,\n          y: 50\n        },\n        controlPoints: [{\n          x: 100,\n          y: 180\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['A', 125.54879529489719, 125.54879529489719, 0, 0, 1, 50, 50]); // update with controlpoint to on the same line of start and end, cannot generate a circle, but a line\n\n      factory.baseUpdate('arc', {\n        startPoint: {\n          x: 200,\n          y: 200\n        },\n        endPoint: {\n          x: 50,\n          y: 50\n        },\n        controlPoints: [{\n          x: 100,\n          y: 100\n        }]\n      }, item);\n      expect(shape.attr('path')[1]).toEqual(['L', 50, 50]);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "loop",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 472,
                "column": 12,
                "index": 11728
            },
            "line": 472,
            "code": "    it('loop', () => {\n      const div = document.createElement('div');\n      div.id = 'graph-spec';\n      document.body.appendChild(div);\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node0',\n          x: 100,\n          y: 100\n        }],\n        edges: [{\n          source: 'node0',\n          target: 'node0',\n          type: 'loop'\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const node = graph.getNodes()[0];\n      const edge = graph.getEdges()[0];\n      const path = edge.get('group').get('children')[0];\n      let bbox = path.getBBox(); // console.log(bbox);\n\n      expect(bbox.minX).toEqual(90.60845891791658);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "clear",
            "suites": [
                "shape edge test",
                "line test"
            ],
            "updatePoint": {
                "line": 502,
                "column": 13,
                "index": 12497
            },
            "line": 502,
            "code": "    it('clear', () => {\n      canvas.clear();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "auto rotate with arrow",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 516,
                "column": 30,
                "index": 12828
            },
            "line": 516,
            "code": "    it('auto rotate with arrow', () => {\n      const center = {\n        x: 100,\n        y: 100\n      };\n      const canvasGroup = canvas.addGroup();\n\n      for (let i = 0; i < 360; i += 45) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 20, angle);\n        const endPoint = getPoint(center, 60, angle);\n        const group = canvasGroup.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            autoRotate: true,\n            style: {\n              stroke: 'white',\n              lineWidth: 5\n            }\n          }\n        }, group);\n        group.setMatrix([0.5, 0, 0, 0, 0.5, 0, 0, 0, 1]);\n        group.setMatrix([0.5, 0, 0, 0, 0.5, 0, 100, 100, 1]);\n      }\n\n      canvasGroup.setMatrix([0.8, 0, 0, 0, 0.8, 0, 0, 0, 1]);\n      canvasGroup.setMatrix([0.8, 0, 0, 0, 0.8, 0, 200, 200, 1]);\n      canvas.draw();\n      const label = canvasGroup.get('children')[1].get('children')[1];\n      expect(label.attr('rotate')).toBe(undefined);\n      expect(label.attr('matrix')[0]).toBe(0.7071067811865476);\n      expect(label.attr('matrix')[3]).toBe(-0.7071067811865475);\n      expect(label.attr('matrix')[6]).toBe(128.2842712474619);\n      expect(label.attr('matrix')[7]).toBe(-53.13708498984761);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "not auto rotate, middle",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 558,
                "column": 31,
                "index": 14246
            },
            "line": 558,
            "code": "    it('not auto rotate, middle', () => {\n      const center = {\n        x: 100,\n        y: 100\n      };\n\n      for (let i = 0; i < 360; i += 45) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 20, angle);\n        const endPoint = getPoint(center, 60, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            style: {\n              stroke: 'white',\n              lineWidth: 5\n            }\n          }\n        }, group);\n        const label = group.get('children')[1]; // expect(label.attr('textAlign')).toEqual('center');\n        // expect(label.attr('stroke')).toEqual('white');\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "not auto rotate, start",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 590,
                "column": 30,
                "index": 15116
            },
            "line": 590,
            "code": "    it('not auto rotate, start', () => {\n      const center = {\n        x: 250,\n        y: 100\n      };\n      canvas.addShape('circle', {\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: 40,\n          stroke: 'blue'\n        }\n      });\n\n      for (let i = 0; i < 360; i += 30) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 40, angle);\n        const endPoint = getPoint(center, 80, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          labelCfg: {\n            position: 'start'\n          },\n          style: {\n            endArrow: true\n          }\n        }, group);\n        const label = group.get('children')[1];\n\n        if (angle < 1 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('start');\n        }\n\n        if (angle > 1 / 2 * Math.PI && angle < 3 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('end');\n        } // expect(label.attr('textAlign')).toEqual('center');\n\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "not auto rotate, end",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 635,
                "column": 28,
                "index": 16268
            },
            "line": 635,
            "code": "    it('not auto rotate, end', () => {\n      const center = {\n        x: 450,\n        y: 100\n      };\n      canvas.addShape('circle', {\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: 40,\n          stroke: 'blue'\n        }\n      });\n\n      for (let i = 0; i < 360; i += 30) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 40, angle);\n        const endPoint = getPoint(center, 80, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            position: 'end'\n          }\n        }, group);\n        const label = group.get('children')[1];\n\n        if (angle < 1 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('end');\n        }\n\n        if (angle > 1 / 2 * Math.PI && angle < 3 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('start');\n        } // expect(label.attr('textAlign')).toEqual('center');\n\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "auto rotate, middle",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 680,
                "column": 27,
                "index": 17417
            },
            "line": 680,
            "code": "    it('auto rotate, middle', () => {\n      const center = {\n        x: 100,\n        y: 300\n      };\n\n      for (let i = 0; i < 360; i += 45) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 20, angle);\n        const endPoint = getPoint(center, 60, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            autoRotate: true\n          }\n        }, group);\n        const label = group.get('children')[1];\n        expect(label.attr('textAlign')).toEqual('center');\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "auto rotate, start",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 709,
                "column": 26,
                "index": 18166
            },
            "line": 709,
            "code": "    it('auto rotate, start', () => {\n      const center = {\n        x: 250,\n        y: 300\n      };\n      canvas.addShape('circle', {\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: 40,\n          stroke: 'blue'\n        }\n      });\n\n      for (let i = 0; i < 360; i += 30) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 40, angle);\n        const endPoint = getPoint(center, 80, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            position: 'start',\n            autoRotate: true\n          }\n        }, group);\n        const label = group.get('children')[1];\n\n        if (angle < 1 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('start');\n        }\n\n        if (angle > 1 / 2 * Math.PI && angle < 3 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('end');\n        } // expect(label.attr('textAlign')).toEqual('center');\n\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "auto rotate, end",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 755,
                "column": 24,
                "index": 19344
            },
            "line": 755,
            "code": "    it('auto rotate, end', () => {\n      const center = {\n        x: 450,\n        y: 300\n      };\n      canvas.addShape('circle', {\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: 40,\n          stroke: 'blue'\n        }\n      });\n\n      for (let i = 0; i < 360; i += 30) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 40, angle);\n        const endPoint = getPoint(center, 80, angle);\n        const group = canvas.addGroup();\n        const shape = factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            position: 'end',\n            autoRotate: true\n          }\n        }, group);\n        const label = group.get('children')[1];\n\n        if (angle < 1 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('end');\n        }\n\n        if (angle > 1 / 2 * Math.PI && angle < 3 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('start');\n        }\n\n        const point = shape.getPoint(1);\n        expect(label.attr('x')).toEqual(point.x);\n        expect(label.attr('y')).toEqual(point.y);\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "curve rotate center",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 804,
                "column": 27,
                "index": 20624
            },
            "line": 804,
            "code": "    it('curve rotate center', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('cubic', {\n        startPoint: {\n          x: 100,\n          y: 400\n        },\n        endPoint: {\n          x: 200,\n          y: 400\n        },\n        controlPoints: [{\n          x: 120,\n          y: 380\n        }, {\n          x: 160,\n          y: 420\n        }],\n        color: 'blue',\n        label: 'curve in center',\n        labelCfg: {\n          autoRotate: true\n        }\n      }, group);\n      const path = shape.attr('path');\n      const label = group.get('children')[1];\n      expect(path.length).toEqual(2);\n      const point = shape.getPoint(0.5);\n      expect(point.x).toEqual(label.attr('x'));\n      expect(point.y).toEqual(label.attr('y'));\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "curve rotate start",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 836,
                "column": 26,
                "index": 21419
            },
            "line": 836,
            "code": "    it('curve rotate start', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('cubic', {\n        startPoint: {\n          x: 220,\n          y: 400\n        },\n        endPoint: {\n          x: 320,\n          y: 400\n        },\n        controlPoints: [{\n          x: 230,\n          y: 380\n        }, {\n          x: 280,\n          y: 420\n        }],\n        color: 'blue',\n        label: 'start',\n        labelCfg: {\n          position: 'start',\n          autoRotate: true\n        }\n      }, group);\n      const path = shape.attr('path');\n      const label = group.get('children')[1];\n      expect(path.length).toEqual(2);\n      const point = shape.getPoint(0);\n      expect(point.x).toEqual(label.attr('x'));\n      expect(point.y).toEqual(label.attr('y'));\n      expect(label.attr('rotate')).not.toEqual(0);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "text on line, text refX and refY",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 870,
                "column": 40,
                "index": 22296
            },
            "line": 870,
            "code": "    it('text on line, text refX and refY', () => {\n      const center = {\n        x: 250,\n        y: 500\n      };\n      canvas.addShape('circle', {\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: 40,\n          stroke: 'blue'\n        }\n      });\n\n      for (let i = 0; i < 360; i += 30) {\n        const angle = i / 180 * Math.PI;\n        const startPoint = getPoint(center, 40, angle);\n        const endPoint = getPoint(center, 80, angle);\n        const group = canvas.addGroup();\n        factory.draw('line', {\n          startPoint,\n          endPoint,\n          color: 'red',\n          label: i.toString(),\n          style: {\n            endArrow: true\n          },\n          labelCfg: {\n            position: 'start',\n            autoRotate: true,\n            refX: 4,\n            refY: 5\n          }\n        }, group);\n        const label = group.get('children')[1];\n\n        if (angle < 1 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('start');\n        }\n\n        if (angle > 1 / 2 * Math.PI && angle < 3 / 2 * Math.PI) {\n          expect(label.attr('textAlign')).toEqual('end');\n        } // expect(label.attr('textAlign')).toEqual('center');\n\n      }\n\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "text on curve, text refX and refY",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 927,
                "column": 41,
                "index": 23727
            },
            "line": 927,
            "code": "    it('text on curve, text refX and refY', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('spline', {\n        startPoint: {\n          x: 220,\n          y: 400\n        },\n        endPoint: {\n          x: 320,\n          y: 400\n        },\n        controlPoints: [{\n          x: 230,\n          y: 380\n        }, {\n          x: 280,\n          y: 420\n        }],\n        color: 'pink',\n        label: 'center',\n        labelCfg: {\n          position: 'center',\n          autoRotate: true,\n          refX: 3,\n          refY: 4\n        }\n      }, group);\n      const point = shape.getPoint(0.5);\n      const label = group.get('children')[1]; // 3*3 + 4*4 = 5*5\n\n      expect(equal(distance(point, {\n        x: label.attr('x'),\n        y: label.attr('y')\n      }), 5)).toEqual(true);\n      canvas.draw();\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "text offset only one dim",
            "suites": [
                "shape edge test",
                "label align"
            ],
            "updatePoint": {
                "line": 963,
                "column": 32,
                "index": 24556
            },
            "line": 963,
            "code": "    it('text offset only one dim', () => {\n      const group = canvas.addGroup();\n      const shape = factory.draw('line', {\n        startPoint: {\n          x: 220,\n          y: 400\n        },\n        endPoint: {\n          x: 320,\n          y: 400\n        },\n        color: 'pink',\n        label: 'center',\n        labelCfg: {\n          position: 'center',\n          autoRotate: true,\n          refX: 5\n        }\n      }, group);\n      const point = shape.getPoint(0.5);\n      const label = group.get('children')[1];\n      expect(equal(distance(point, {\n        x: label.attr('x'),\n        y: label.attr('y')\n      }), 5)).toEqual(true);\n    });",
            "file": "unit/shape/edge-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getCustomConfig return new size",
            "suites": [
                "register node with getCustomConfig function, extend image"
            ],
            "updatePoint": {
                "line": 7,
                "column": 37,
                "index": 305
            },
            "line": 7,
            "code": "  it('getCustomConfig return new size', () => {\n    const data = {\n      nodes: [{\n        id: 'node',\n        x: 100,\n        y: 100\n      }]\n    };\n    registerNode('custom-node', {\n      getCustomConfig() {\n        return {\n          size: 300\n        };\n      }\n\n    }, 'image');\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        type: 'custom-node'\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const nodes = graph.getNodes();\n    expect(nodes.length).toEqual(1);\n    const node = nodes[0];\n    const keyShape = node.getKeyShape();\n    expect(keyShape.attr('width')).toEqual(300);\n    expect(keyShape.attr('img')).toEqual('https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ');\n    graph.destroy();\n  });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getCustomConfig return new labelCfg style",
            "suites": [
                "register node with getCustomConfig function, extend image"
            ],
            "updatePoint": {
                "line": 41,
                "column": 47,
                "index": 1143
            },
            "line": 41,
            "code": "  it('getCustomConfig return new labelCfg style', () => {\n    const data = {\n      nodes: [{\n        id: 'node',\n        label: 'image',\n        x: 200,\n        y: 100\n      }]\n    };\n    registerNode('custom-node', {\n      getCustomConfig() {\n        return {\n          labelCfg: {\n            style: {\n              fill: 'red'\n            }\n          }\n        };\n      }\n\n    }, 'image');\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        type: 'custom-node'\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const nodes = graph.getNodes();\n    expect(nodes.length).toEqual(1);\n    const node = nodes[0];\n    const group = node.get('group');\n    expect(group.getCount()).toEqual(2);\n    const label = group.find(g => {\n      return g.get('className') === 'node-label';\n    });\n    expect(label).not.toBe(undefined);\n    expect(label.attr('fill')).toEqual('red');\n    const type = label.get('type');\n    expect(type).toEqual('text');\n    graph.destroy();\n    expect(graph.destroyed).toBe(true);\n  });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default clip",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 88,
                "column": 20,
                "index": 2227
            },
            "line": 88,
            "code": "    it('default clip', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            size: 150,\n            clipCfg: {\n              show: true\n            },\n            style: {\n              shadowColor: '#ccc',\n              shadowBlur: 10\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node'\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('r')).toEqual(50);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle clip and update",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 129,
                "column": 30,
                "index": 3203
            },
            "line": 129,
            "code": "    it('circle clip and update', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            clipCfg: {\n              show: true,\n              type: 'circle',\n              r: 10\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          size: 150\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('r')).toEqual(10);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "rect clip and update",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 168,
                "column": 28,
                "index": 4126
            },
            "line": 168,
            "code": "    it('rect clip and update', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            clipCfg: {\n              show: true,\n              type: 'rect',\n              width: 100,\n              height: 50,\n              x: -50\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          size: 150\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('width')).toEqual(100);\n      expect(nodeShape.get('clipShape').attr('height')).toEqual(50);\n      expect(nodeShape.get('clipShape').attr('x')).toEqual(-100);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "ellipse clip and update",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 211,
                "column": 31,
                "index": 5243
            },
            "line": 211,
            "code": "    it('ellipse clip and update', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            clipCfg: {\n              show: true,\n              type: 'ellipse',\n              rx: 100,\n              ry: 50,\n              x: -50\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          size: 150\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('rx')).toEqual(100);\n      expect(nodeShape.get('clipShape').attr('ry')).toEqual(50);\n      expect(nodeShape.get('clipShape').attr('x')).toEqual(-50);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "polygon clip and update",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 254,
                "column": 31,
                "index": 6348
            },
            "line": 254,
            "code": "    it('polygon clip and update', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            clipCfg: {\n              show: true,\n              type: 'polygon',\n              points: [[10, 20], [15, 15], [30, 12], [40, 50], [10, 20]]\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          size: 150\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('points')).toEqual([[10, 20], [15, 15], [30, 12], [40, 50], [10, 20]]);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "path clip and update",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "clip"
            ],
            "updatePoint": {
                "line": 293,
                "column": 28,
                "index": 7378
            },
            "line": 293,
            "code": "    it('path clip and update', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      const clipPath = [['M', 0, 0], ['L', -75, 200], ['L', 75, 200], ['Z']];\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            clipCfg: {\n              show: true,\n              type: 'path',\n              path: clipPath\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          size: 150\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('path')).toEqual(clipPath);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update style",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "update"
            ],
            "updatePoint": {
                "line": 335,
                "column": 20,
                "index": 8422
            },
            "line": 335,
            "code": "    it('update style', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            size: 150,\n            style: {\n              shadowColor: '#ccc',\n              shadowBlur: 10\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node',\n          style: {\n            shadowColor: '#ccc',\n            shadowBlur: 10\n          }\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('width')).toBe(150);\n      expect(keyShape.attr('height')).toBe(150);\n      expect(keyShape.attr('shadowColor')).toBe('#ccc');\n      node.update({\n        size: 30,\n        style: {\n          shadowColor: '#f00'\n        }\n      });\n      expect(keyShape.attr('width')).toBe(30);\n      expect(keyShape.attr('height')).toBe(30);\n      expect(keyShape.attr('shadowColor')).toBe('#f00');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "update"
            ],
            "updatePoint": {
                "line": 390,
                "column": 20,
                "index": 9827
            },
            "line": 390,
            "code": "    it('update label', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'old image label',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            labelCfg: {\n              style: {\n                fill: 'red'\n              }\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node'\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('old image label');\n      expect(label.attr('fill')).toEqual('red');\n      node.update({\n        label: 'new image label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('fill')).toEqual('#ff0'); // test if it will keep the current fill without setting\n\n      node.update({\n        labelCfg: {\n          position: 'center',\n          style: {\n            stroke: 'black',\n            lineWidth: 3\n          }\n        }\n      });\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('lineWidth')).toEqual(3);\n      expect(label.attr('stroke')).toEqual('black');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label from none",
            "suites": [
                "register node with getCustomConfig function, extend image",
                "update"
            ],
            "updatePoint": {
                "line": 457,
                "column": 30,
                "index": 11592
            },
            "line": 457,
            "code": "    it('update label from none', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          x: 200,\n          y: 100\n        }]\n      };\n      registerNode('custom-node', {\n        getCustomConfig() {\n          return {\n            labelCfg: {\n              style: {\n                fill: 'red'\n              }\n            }\n          };\n        }\n\n      }, 'image');\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'custom-node'\n        }\n      });\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new image label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/extend/extend-image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "test genBubbleSet",
            "suites": [
                "test bubble hull"
            ],
            "updatePoint": {
                "line": 195,
                "column": 23,
                "index": 3047
            },
            "line": 195,
            "code": "  it('test genBubbleSet', () => {\n    let centerNodes = graph.getNodes().filter(node => !node.getModel().isLeaf);\n    let leafGroup = graph.getNodes().filter(node => node.getModel().isLeaf);\n    const hull = graph.createHull({\n      id: 'centerNode-hull',\n      type: 'bubble',\n      members: centerNodes,\n      nonMembers: leafGroup,\n      padding: 10,\n      bubbleCfg: {\n        morphBuffer: 10,\n        pixelGroupSize: 4,\n        maxMarchingIterations: 1000,\n        maxRoutingIterations: 100,\n        nodeR0: 10,\n        nodeR1: 15,\n        edgeR0: 5,\n        edgeR1: 10,\n        nodeInfluenceFactor: 5,\n        negativeNodeInfluenceFactor: 5,\n        edgeInfluenceFactor: 5,\n        memberInfluenceFactor: 5,\n        nonMemberInfluenceFactor: 1\n      }\n    });\n    expect(hull.members.length).toEqual(4);\n    expect(hull.nonMembers.length).toEqual(13);\n  });",
            "file": "unit/shape/hull/bubble-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "edge label background with overlapped end nodes ",
            "suites": [
                "edge label with background"
            ],
            "updatePoint": {
                "line": 6,
                "column": 54,
                "index": 239
            },
            "line": 6,
            "code": "  it('edge label background with overlapped end nodes ', () => {\n    const graph = new Graph({\n      container: 'container',\n      width: 500,\n      height: 500,\n      defaultNode: {\n        style: {\n          opacity: 0\n        }\n      },\n      defaultEdge: {\n        type: 'line',\n        labelCfg: {\n          autoRotate: true,\n          style: {\n            fill: '#1890ff',\n            fontSize: 14,\n            fontFamily: 'Arial',\n            background: {\n              fill: '#ffffff',\n              stroke: '#9EC9FF',\n              padding: [2, 2, 2, 2],\n              radius: 2\n            }\n          }\n        }\n      }\n    });\n    graph.read({\n      nodes: [{\n        id: '1',\n        x: 100,\n        y: 100\n      }, {\n        id: '2',\n        x: 100,\n        y: 100\n      }],\n      edges: [{\n        source: '1',\n        target: '2',\n        label: 'abc'\n      }]\n    });\n    const edge = graph.getEdges()[0];\n    const group = edge.getContainer();\n    const bgRect = group.find(e => e.get('name') === 'text-bg-shape');\n    expect(Math.abs(bgRect.attr('x') - 86) < 1).toBe(true);\n    expect(Math.abs(bgRect.attr('y') - 91) < 2).toBe(true);\n    expect(Math.abs(bgRect.attr('width') - 27) < 3).toBe(true);\n    expect(Math.abs(bgRect.attr('height') - 18) < 3).toBe(true);\n    graph.destroy();\n  });",
            "file": "unit/shape/label-background-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "collapse and expand arrow ",
            "suites": [
                "marker test"
            ],
            "updatePoint": {
                "line": 23,
                "column": 32,
                "index": 486
            },
            "line": 23,
            "code": "  it('collapse and expand arrow ', () => {\n    G6.registerNode('marker-node', {\n      afterDraw: (cfg, group) => {\n        group.addShape('marker', {\n          attrs: {\n            x: 20,\n            y: 0,\n            r: 6,\n            symbol: G6.Marker.collapse,\n            stroke: '#666',\n            fill: '#fff',\n            lineWidth: 1\n          },\n          name: 'collapse-icon'\n        });\n        group.addShape('marker', {\n          attrs: {\n            x: -20,\n            y: 0,\n            r: 6,\n            symbol: G6.Marker.expand,\n            stroke: '#666',\n            fill: '#fff',\n            lineWidth: 1\n          },\n          name: 'collapse-icon'\n        });\n        group.addShape('marker', {\n          attrs: {\n            x: 0,\n            y: -20,\n            r: 6,\n            symbol: G6.Marker.downTriangle,\n            stroke: '#666',\n            fill: '#fff',\n            lineWidth: 1\n          },\n          name: 'collapse-icon'\n        });\n        group.addShape('marker', {\n          attrs: {\n            x: 0,\n            y: 20,\n            r: 6,\n            symbol: G6.Marker.upTriangle,\n            stroke: '#666',\n            fill: '#fff',\n            lineWidth: 1\n          },\n          name: 'collapse-icon'\n        });\n      }\n    }, 'circle');\n    const cfg = {\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        type: 'marker-node',\n        style: {\n          r: 20\n        } // size: [20, 20]\n        // style: {\n        //   opacity: 0.1\n        // }\n\n      }\n    };\n    const graph = new Graph(cfg);\n    graph.data(data);\n    graph.render();\n  });",
            "file": "unit/shape/marker/marker-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default circle config",
            "suites": [
                "circle test",
                "default circle test"
            ],
            "updatePoint": {
                "line": 18,
                "column": 29,
                "index": 494
            },
            "line": 18,
            "code": "    it('default circle config', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          x: 100,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('r')).toEqual(10);\n      expect(keyShape.attr('stroke')).toEqual('rgb(95, 149, 255)');\n      expect(keyShape.attr('fill')).toEqual('rgb(239, 244, 255)');\n    });",
            "file": "unit/shape/nodes/circle-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle with label",
            "suites": [
                "circle test",
                "default circle test"
            ],
            "updatePoint": {
                "line": 36,
                "column": 25,
                "index": 1030
            },
            "line": 36,
            "code": "    it('circle with label', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'circle',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toBe(undefined);\n      expect(label.attr('fill')).toEqual('#000');\n      const type = label.get('type');\n      expect(type).toEqual('text');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/circle-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update styles",
            "suites": [
                "circle test",
                "update"
            ],
            "updatePoint": {
                "line": 64,
                "column": 21,
                "index": 1812
            },
            "line": 64,
            "code": "    it('update styles', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'circle',\n          size: 50,\n          style: {\n            fill: 'red',\n            stroke: '#ccc',\n            lineWidth: 5\n          },\n          icon: {\n            show: true\n          }\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'circle',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      node.update({\n        size: 30,\n        color: 'black',\n        style: {\n          fill: 'steelblue'\n        }\n      });\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(3);\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('r')).toBe(15);\n      expect(keyShape.attr('fill')).toBe('steelblue');\n      expect(keyShape.attr('lineWidth')).toBe(5);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/circle-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label",
            "suites": [
                "circle test",
                "update"
            ],
            "updatePoint": {
                "line": 110,
                "column": 20,
                "index": 2921
            },
            "line": 110,
            "code": "    it('update label', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'old circle label',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: '',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('');\n      expect(label.attr('fill')).toEqual('#ff0');\n      node.update({\n        label: 'new circle label'\n      }); // test if it will keep the current fill without setting\n\n      node.update({\n        labelCfg: {\n          position: 'center',\n          style: {\n            stroke: 'black',\n            lineWidth: 3\n          }\n        }\n      });\n      expect(label.attr('text')).toEqual('new circle label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      expect(label.attr('stroke')).toEqual('black');\n      expect(label.attr('lineWidth')).toEqual(3);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/circle-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label from none",
            "suites": [
                "circle test",
                "update"
            ],
            "updatePoint": {
                "line": 163,
                "column": 30,
                "index": 4328
            },
            "line": 163,
            "code": "    it('update label from none', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new circle label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new circle label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/circle-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default image config",
            "suites": [
                "image test",
                "default image test"
            ],
            "updatePoint": {
                "line": 19,
                "column": 28,
                "index": 529
            },
            "line": 19,
            "code": "    it('default image config', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          x: 100,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('width')).toEqual(200);\n      expect(keyShape.attr('img')).toEqual('https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ');\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "image with label",
            "suites": [
                "image test",
                "default image test"
            ],
            "updatePoint": {
                "line": 36,
                "column": 24,
                "index": 1067
            },
            "line": 36,
            "code": "    it('image with label', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toBe(undefined);\n      expect(label.attr('fill')).toEqual('#000');\n      const type = label.get('type');\n      expect(type).toEqual('text');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default clip",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 64,
                "column": 20,
                "index": 1845
            },
            "line": 64,
            "code": "    it('default clip', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150,\n          style: {\n            shadowColor: '#ccc',\n            shadowBlur: 10\n          }\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('r')).toEqual(50);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "circle clip and update",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 98,
                "column": 30,
                "index": 2674
            },
            "line": 98,
            "code": "    it('circle clip and update', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true,\n            type: 'circle',\n            r: 10\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('r')).toEqual(10); // node.update({\n      //   clipCfg: {\n      //     r: 50,\n      //     x: -100\n      //   }\n      // })\n\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "rect clip and update",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 136,
                "column": 28,
                "index": 3562
            },
            "line": 136,
            "code": "    it('rect clip and update', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true,\n            type: 'rect',\n            width: 100,\n            height: 50,\n            x: -50\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('width')).toEqual(100);\n      expect(nodeShape.get('clipShape').attr('height')).toEqual(50);\n      expect(nodeShape.get('clipShape').attr('x')).toEqual(-100); // node.update({\n      //   clipCfg: {\n      //   }\n      // })\n\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "ellipse clip and update",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 176,
                "column": 31,
                "index": 4599
            },
            "line": 176,
            "code": "    it('ellipse clip and update', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true,\n            type: 'ellipse',\n            rx: 100,\n            ry: 50,\n            x: -50\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('rx')).toEqual(100);\n      expect(nodeShape.get('clipShape').attr('ry')).toEqual(50);\n      expect(nodeShape.get('clipShape').attr('x')).toEqual(-50); // node.update({\n      //   clipCfg: {\n      //   }\n      // })\n\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "polygon clip and update",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 216,
                "column": 31,
                "index": 5624
            },
            "line": 216,
            "code": "    it('polygon clip and update', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true,\n            type: 'polygon',\n            points: [[10, 20], [15, 15], [30, 12], [40, 50], [10, 20]]\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('points')).toEqual([[10, 20], [15, 15], [30, 12], [40, 50], [10, 20]]); // node.update({\n      //   clipCfg: {\n      //   }\n      // })\n\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "path clip and update",
            "suites": [
                "image test",
                "clip"
            ],
            "updatePoint": {
                "line": 252,
                "column": 28,
                "index": 6578
            },
            "line": 252,
            "code": "    it('path clip and update', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150\n        }\n      });\n      const clipPath = [['M', 0, 0], ['L', -75, 200], ['L', 75, 200], ['Z']];\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100,\n          clipCfg: {\n            show: true,\n            type: 'path',\n            path: clipPath\n          }\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const nodeShape = node.get('group').get('children')[0];\n      expect(nodeShape.get('clipShape').attr('path')).toEqual(clipPath); // node.update({\n      //   clipCfg: {\n      //   }\n      // })\n\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update style",
            "suites": [
                "image test",
                "update"
            ],
            "updatePoint": {
                "line": 291,
                "column": 20,
                "index": 7546
            },
            "line": 291,
            "code": "    it('update style', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'image',\n          size: 150,\n          style: {\n            shadowColor: '#ccc',\n            shadowBlur: 10\n          }\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      node.update({\n        size: 30,\n        style: {\n          shadowColor: '#f00'\n        }\n      });\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('width')).toBe(30);\n      expect(keyShape.attr('height')).toBe(30);\n      expect(keyShape.attr('shadowColor')).toBe('#f00');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label",
            "suites": [
                "image test",
                "update"
            ],
            "updatePoint": {
                "line": 332,
                "column": 20,
                "index": 8564
            },
            "line": 332,
            "code": "    it('update label', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'old image label',\n          type: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new image label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('fill')).toEqual('#ff0'); // test if it will keep the current fill without setting\n\n      node.update({\n        labelCfg: {\n          position: 'center',\n          style: {\n            stroke: 'black',\n            lineWidth: 3\n          }\n        }\n      });\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('lineWidth')).toEqual(3);\n      expect(label.attr('stroke')).toEqual('black');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label from none",
            "suites": [
                "image test",
                "update"
            ],
            "updatePoint": {
                "line": 382,
                "column": 30,
                "index": 9910
            },
            "line": 382,
            "code": "    it('update label from none', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          type: 'image',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new image label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new image label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/image-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "default rect config",
            "suites": [
                "rect test",
                "default rect test"
            ],
            "updatePoint": {
                "line": 18,
                "column": 27,
                "index": 493
            },
            "line": 18,
            "code": "    it('default rect config', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          x: 100,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('width')).toEqual(100);\n      expect(keyShape.attr('stroke')).toEqual('rgb(95, 149, 255)');\n      expect(keyShape.attr('fill')).toEqual('rgb(239, 244, 255)');\n    });",
            "file": "unit/shape/nodes/rect-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "rect with label",
            "suites": [
                "rect test",
                "default rect test"
            ],
            "updatePoint": {
                "line": 36,
                "column": 23,
                "index": 1032
            },
            "line": 36,
            "code": "    it('rect with label', () => {\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'simple-rect',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      expect(nodes.length).toEqual(1);\n      const node = nodes[0];\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toBe(undefined);\n      expect(label.attr('fill')).toEqual('#000');\n      const type = label.get('type');\n      expect(type).toEqual('text');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/rect-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update styles",
            "suites": [
                "rect test",
                "update"
            ],
            "updatePoint": {
                "line": 64,
                "column": 21,
                "index": 1819
            },
            "line": 64,
            "code": "    it('update styles', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500,\n        defaultNode: {\n          type: 'simple-rect',\n          size: 50,\n          style: {\n            fill: 'red',\n            stroke: '#ccc',\n            lineWidth: 5\n          }\n        }\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'simple-rect',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      node.update({\n        size: 30,\n        color: 'black',\n        style: {\n          fill: 'steelblue'\n        }\n      });\n      const group = node.get('group');\n      expect(group.getCount()).toEqual(2);\n      const keyShape = node.getKeyShape();\n      expect(keyShape.attr('width')).toBe(30);\n      expect(keyShape.attr('height')).toBe(30);\n      expect(keyShape.attr('fill')).toBe('steelblue');\n      expect(keyShape.attr('lineWidth')).toBe(5);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/rect-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label",
            "suites": [
                "rect test",
                "update"
            ],
            "updatePoint": {
                "line": 108,
                "column": 20,
                "index": 2936
            },
            "line": 108,
            "code": "    it('update label', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          label: 'old rect label',\n          type: 'simple-rect',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new rect label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new rect label');\n      expect(label.attr('fill')).toEqual('#ff0'); // test if it will keep the current fill without setting\n\n      node.update({\n        labelCfg: {\n          position: 'center',\n          style: {\n            stroke: 'black',\n            lineWidth: 3\n          }\n        }\n      });\n      expect(label.attr('text')).toEqual('new rect label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      expect(label.attr('stroke')).toEqual('black');\n      expect(label.attr('lineWidth')).toEqual(3);\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/rect-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update label from none",
            "suites": [
                "rect test",
                "update"
            ],
            "updatePoint": {
                "line": 159,
                "column": 30,
                "index": 4334
            },
            "line": 159,
            "code": "    it('update label from none', () => {\n      const graph = new Graph({\n        container: div,\n        width: 500,\n        height: 500\n      });\n      const data = {\n        nodes: [{\n          id: 'node',\n          type: 'simple-rect',\n          x: 200,\n          y: 100\n        }]\n      };\n      graph.data(data);\n      graph.render();\n      const nodes = graph.getNodes();\n      const node = nodes[0];\n      const group = node.get('group');\n      node.update({\n        label: 'new rect label',\n        labelCfg: {\n          style: {\n            fill: '#ff0'\n          }\n        }\n      });\n      const label = group.find(g => {\n        return g.get('className') === 'node-label';\n      });\n      expect(label).not.toEqual(null);\n      expect(label.attr('text')).toEqual('new rect label');\n      expect(label.attr('fill')).toEqual('#ff0');\n      graph.destroy();\n      expect(graph.destroyed).toBe(true);\n    });",
            "file": "unit/shape/nodes/rect-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "shape test without extended shape and draw function, update the node",
            "suites": [
                "register node"
            ],
            "updatePoint": {
                "line": 26,
                "column": 74,
                "index": 552
            },
            "line": 26,
            "code": "  it('shape test without extended shape and draw function, update the node', () => {\n    G6.registerNode('custom-node', {\n      drawShape(cfg, group) {\n        let fill = '#87e8de';\n\n        if (cfg.style && cfg.style.fill) {\n          fill = cfg.style.fill;\n        }\n\n        const keyShape = group.addShape('circle', {\n          attrs: {\n            x: 0,\n            y: 0,\n            r: 30,\n            fill\n          }\n        });\n        return keyShape;\n      }\n\n    });\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        type: 'custom-node'\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const node = graph.getNodes()[0];\n    expect(node.getModel().x).not.toBe(undefined);\n    expect(node.getModel().y).not.toBe(undefined);\n    node.update({\n      style: {\n        fill: 'steelblue'\n      }\n    });\n    expect(node.get('group').get('children')[0].attr('fill')).toBe('steelblue');\n    graph.destroy();\n  });",
            "file": "unit/shape/register-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "register node without draw and drawShape, extend circle",
            "suites": [
                "register node"
            ],
            "updatePoint": {
                "line": 68,
                "column": 61,
                "index": 1537
            },
            "line": 68,
            "code": "  it('register node without draw and drawShape, extend circle', () => {\n    G6.registerNode('custom-node', {\n      setState(name, value, item) {\n        const group = item.getContainer();\n        const shape = group.get('children')[0]; // 顺序根据 draw 时确定\n\n        if (name === 'active') {\n          if (value) {\n            shape.attr('stroke', 'red');\n          } else {\n            shape.attr('stroke', '#333');\n          }\n        }\n      }\n\n    }, 'circle');\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        type: 'custom-node'\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('node:click', evt => {\n      const {\n        item\n      } = evt;\n      graph.setItemState(item, 'active', true);\n    });\n    graph.on('canvas:click', evt => {\n      graph.getNodes().forEach(node => {\n        graph.setItemState(node, 'active', false);\n      });\n    });\n    expect(graph.getNodes()[0].getModel().x).not.toBe(undefined);\n    expect(graph.getNodes()[0].getModel().y).not.toBe(undefined);\n    graph.destroy();\n  });",
            "file": "unit/shape/register-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "register edge without draw and drawShape function, extend quadratic",
            "suites": [
                "register node"
            ],
            "updatePoint": {
                "line": 109,
                "column": 73,
                "index": 2647
            },
            "line": 109,
            "code": "  it('register edge without draw and drawShape function, extend quadratic', () => {\n    G6.registerEdge('custom-edge', {\n      getControlPoints(cfg) {\n        const controlPoints = []; // 指定controlPoints\n\n        const level = -5; // 从 -10， 10\n\n        const offset = level * -25; // 根据不同的level 计算不同的偏移\n\n        const {\n          startPoint,\n          endPoint\n        } = cfg;\n        const innerPoint = G6.Util.getControlPoint(startPoint, endPoint, 0.5, offset);\n        controlPoints.push(innerPoint);\n        return controlPoints;\n      }\n\n    }, 'quadratic');\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        type: 'custom-edge'\n      }\n    });\n    graph.data(data);\n    graph.render();\n    expect(graph.getNodes()[0].getModel().x).not.toBe(undefined);\n    expect(graph.getNodes()[0].getModel().y).not.toBe(undefined);\n    graph.destroy();\n  });",
            "file": "unit/shape/register-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "register factory",
            "suites": [
                "shape test"
            ],
            "updatePoint": {
                "line": 8,
                "column": 22,
                "index": 199
            },
            "line": 8,
            "code": "  it('register factory', () => {\n    Shape.registerFactory('test', {\n      defaultShapeType: 't1'\n    });\n    expect(Shape['Test']).not.toBe(undefined);\n  });",
            "file": "unit/shape/shape-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "get factory",
            "suites": [
                "shape test"
            ],
            "updatePoint": {
                "line": 14,
                "column": 17,
                "index": 353
            },
            "line": 14,
            "code": "  it('get factory', () => {\n    const factory = Shape.getFactory('test');\n    expect(factory).not.toBe(undefined);\n  });",
            "file": "unit/shape/shape-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "clear",
            "suites": [
                "shape test"
            ],
            "updatePoint": {
                "line": 18,
                "column": 11,
                "index": 468
            },
            "line": 18,
            "code": "  it('clear', () => {\n    delete Shape['Test'];\n    expect(Shape.getFactory('test')).toBe(undefined);\n  });",
            "file": "unit/shape/shape-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global edgeStateStyles and defaultEdge, state change with opacity changed",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 6,
                "column": 79,
                "index": 257
            },
            "line": 6,
            "code": "  it('global edgeStateStyles and defaultEdge, state change with opacity changed', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }],\n      edges: [{\n        source: 'node1',\n        target: 'node2'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'polyline'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'quadratic'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'cubic'\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      edgeStateStyles: {\n        hover: {\n          opacity: 0.3,\n          lineWidth: 5\n        }\n      },\n      defaultEdge: {\n        style: {\n          stroke: 'steelblue',\n          lineWidth: 3\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n      expect(item.hasState('hover')).toEqual(true);\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('opacity')).toEqual(0.3);\n      expect(keyShape.attr('lineWidth')).toEqual(5);\n      expect(keyShape.attr('stroke')).toEqual('steelblue');\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n      expect(item.hasState('hover')).toEqual(false);\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('opacity')).toEqual(1);\n      expect(keyShape.attr('lineWidth')).toEqual(3);\n      expect(keyShape.attr('stroke')).toEqual('steelblue');\n    });\n    const lineEdge = graph.getEdges()[0];\n    const polylineEdge = graph.getEdges()[1];\n    const quadraticEdge = graph.getEdges()[2];\n    const cubicEdge = graph.getEdges()[3];\n    graph.emit('edge:mouseenter', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: cubicEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: cubicEdge\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global edgeStateStyles and defaultEdge, state change with fill/r/width/height/stroke changed",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 101,
                "column": 98,
                "index": 2729
            },
            "line": 101,
            "code": "  it('global edgeStateStyles and defaultEdge, state change with fill/r/width/height/stroke changed', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }],\n      edges: [{\n        source: 'node1',\n        target: 'node2'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'polyline'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'quadratic'\n      }, {\n        source: 'node1',\n        target: 'node2',\n        type: 'cubic'\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      edgeStateStyles: {\n        hover: {\n          shadowColor: '#f00',\n          shadowBlur: 10,\n          shadowOffsetX: 10,\n          shadowOffsetY: 20,\n          lineWidth: 10\n        }\n      },\n      defaultEdge: {\n        size: 10\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('shadowColor')).toEqual('#f00');\n      expect(keyShape.attr('shadowBlur')).toEqual(10);\n      expect(keyShape.attr('shadowOffsetX')).toEqual(10);\n      expect(keyShape.attr('shadowOffsetY')).toEqual(20);\n      expect(keyShape.attr('lineWidth')).toEqual(10);\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('shadowColor')).toEqual(undefined);\n      expect(keyShape.attr('shadowBlur')).toEqual(0);\n      expect(keyShape.attr('shadowOffsetX')).toEqual(0);\n      expect(keyShape.attr('shadowOffsetY')).toEqual(0);\n      expect(keyShape.attr('lineWidth')).toEqual(10);\n    });\n    const lineEdge = graph.getEdges()[0];\n    const polylineEdge = graph.getEdges()[1];\n    const quadraticEdge = graph.getEdges()[2];\n    const cubicEdge = graph.getEdges()[3];\n    graph.emit('edge:mouseenter', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: cubicEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: cubicEdge\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global defaultEdgeand stateStyle in data, state change with fill/r/width/height/stroke changed",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 198,
                "column": 100,
                "index": 5366
            },
            "line": 198,
            "code": "  it('global defaultEdgeand stateStyle in data, state change with fill/r/width/height/stroke changed', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }],\n      edges: [{\n        id: 'line',\n        source: 'node1',\n        target: 'node2',\n        stateStyles: {\n          hover: {\n            lineWidth: 5\n          }\n        }\n      }, {\n        id: 'polyline',\n        source: 'node1',\n        target: 'node2',\n        type: 'polyline',\n        stateStyles: {\n          hover: {\n            stroke: '#0f0'\n          }\n        }\n      }, {\n        id: 'quadratic',\n        source: 'node1',\n        target: 'node2',\n        type: 'quadratic',\n        stateStyles: {\n          hover: {\n            opacity: 0.3\n          }\n        }\n      }, {\n        id: 'cubic',\n        source: 'node1',\n        target: 'node2',\n        type: 'cubic',\n        stateStyles: {\n          hover: {\n            shadowColor: '#00f',\n            shadowBlur: 15,\n            shadowOffsetX: 5,\n            shadowOffsetY: 25\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        style: {\n          lineAppendWidth: 5,\n          stroke: '#aaa',\n          lineWidth: 1\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n      expect(item.hasState('hover')).toEqual(true);\n      const keyShape = item.getKeyShape();\n      const model = item.getModel();\n\n      switch (model.id) {\n        case 'line':\n          expect(keyShape.attr('lineWidth')).toEqual(5);\n          expect(keyShape.attr('stroke')).toEqual('#aaa');\n          break;\n\n        case 'polyline':\n          expect(keyShape.attr('lineWidth')).toEqual(1);\n          expect(keyShape.attr('stroke')).toEqual('#0f0');\n          break;\n\n        case 'quadratic':\n          expect(keyShape.attr('opacity')).toEqual(0.3);\n          expect(keyShape.attr('lineWidth')).toEqual(1);\n          break;\n\n        case 'cubic':\n          expect(keyShape.attr('shadowColor')).toEqual('#00f');\n          expect(keyShape.attr('shadowBlur')).toEqual(15);\n          expect(keyShape.attr('shadowOffsetX')).toEqual(5);\n          expect(keyShape.attr('shadowOffsetY')).toEqual(25);\n          expect(keyShape.attr('lineWidth')).toEqual(1);\n          break;\n      }\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n      expect(item.hasState('hover')).toEqual(false);\n      const keyShape = item.getKeyShape();\n      const curOpacity = keyShape.attr('shadowColor');\n      const curShadowBlur = keyShape.attr('shadowBlur');\n      const curShadowOffsetX = keyShape.attr('shadowBlur');\n      const curShadowOffsetY = keyShape.attr('shadowBlur');\n      expect(curOpacity === undefined || curOpacity === null).toEqual(true);\n      expect(curShadowBlur === 0 || curShadowBlur === undefined || curShadowBlur === null).toEqual(true);\n      expect(curShadowOffsetX === 0 || curShadowOffsetX === undefined || curShadowOffsetX === null).toEqual(true);\n      expect(curShadowOffsetY === 0 || curShadowOffsetY === undefined || curShadowOffsetY === null).toEqual(true);\n      expect(keyShape.attr('lineWidth')).toEqual(1);\n      expect(keyShape.attr('stroke')).toEqual('#aaa');\n    });\n    const lineEdge = graph.getEdges()[0];\n    const polylineEdge = graph.getEdges()[1];\n    const quadraticEdge = graph.getEdges()[2];\n    const cubicEdge = graph.getEdges()[3];\n    graph.emit('edge:mouseenter', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseenter', {\n      item: cubicEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: lineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: polylineEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: quadraticEdge\n    });\n    graph.emit('edge:mouseleave', {\n      item: cubicEdge\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global defaultNode and multiple stateStyle in data",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 345,
                "column": 56,
                "index": 9570
            },
            "line": 345,
            "code": "  it('global defaultNode and multiple stateStyle in data', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }],\n      edges: [{\n        id: 'edge1',\n        source: 'node1',\n        target: 'node2',\n        stateStyles: {\n          state1: {\n            lineWidth: 3\n          },\n          state2: {\n            lineWidth: 5,\n            stroke: '#f00'\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        style: {\n          lineWidth: 1,\n          lineAppendWidth: 5\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const edge = graph.getEdges()[0];\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n      const keyShape = edge.getKeyShape();\n      expect(keyShape.attr('lineWidth')).toEqual(3);\n      expect(keyShape.attr('stroke')).toEqual('rgb(224, 224, 224)');\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', false);\n      expect(item.hasState('state2')).toEqual(true);\n      expect(item.hasState('state1')).toEqual(false);\n      const keyShape = edge.getKeyShape();\n      expect(keyShape.attr('lineWidth')).toEqual(5);\n      expect(keyShape.attr('stroke')).toEqual('#f00');\n    });\n    graph.on('edge:click', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state2', !item.hasState('state2'));\n      expect(item.hasState('state2')).toEqual(true);\n      const keyShape = edge.getKeyShape();\n      expect(keyShape.attr('lineWidth')).toEqual(5);\n      expect(keyShape.attr('stroke')).toEqual('#f00');\n    });\n    graph.on('canvas:click', () => {\n      graph.getEdges().forEach(edge => {\n        graph.setItemState(edge, 'state2', false);\n        expect(edge.hasState('state2')).toEqual(false);\n        const keyShape = edge.getKeyShape();\n        expect(keyShape.attr('lineWidth')).toEqual(1);\n        expect(keyShape.attr('stroke')).toEqual('rgb(224, 224, 224)');\n      });\n    });\n    graph.emit('edge:mouseenter', {\n      item: edge\n    });\n    graph.emit('edge:click', {\n      item: edge\n    });\n    graph.emit('edge:mouseleave', {\n      item: edge\n    });\n    graph.emit('canvas:click', {});\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateItem and state",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 431,
                "column": 26,
                "index": 12009
            },
            "line": 431,
            "code": "  it('updateItem and state', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }],\n      edges: [{\n        id: 'edge1',\n        source: 'node1',\n        target: 'node2',\n        stateStyles: {\n          state1: {\n            lineWidth: 3,\n            stroke: '#f00'\n          },\n          state2: {\n            lineWidth: 5,\n            stroke: '#00f'\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        style: {\n          lineWidth: 1\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const edge = graph.getEdges()[0];\n    graph.updateItem(edge, {\n      type: 'cubic',\n      style: {\n        stroke: '#0f0'\n      }\n    });\n    expect(edge.getKeyShape().attr('stroke')).toEqual('#0f0');\n    expect(edge.getKeyShape().attr('lineWidth')).toEqual(1);\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', false);\n      expect(item.hasState('state1')).toEqual(false);\n      expect(item.hasState('state2')).toEqual(true);\n    });\n    graph.on('edge:click', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state2', true);\n      expect(item.hasState('state1')).toEqual(true);\n      expect(item.hasState('state2')).toEqual(true);\n    });\n    graph.on('canvas:click', () => {\n      graph.getEdges().forEach(edge => {\n        graph.setItemState(edge, 'state2', false);\n        expect(edge.hasState('state1')).toEqual(false);\n        expect(edge.hasState('state2')).toEqual(false);\n      });\n    });\n    graph.emit('node:mouseenter', {\n      item: edge\n    });\n    graph.emit('node:click', {\n      item: edge\n    });\n    graph.emit('node:mouseleave', {\n      item: edge\n    });\n    graph.emit('canvas:click', {});\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "combine edgeStateStyles on Graph and stateStyles in data",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 515,
                "column": 62,
                "index": 14161
            },
            "line": 515,
            "code": "  it('combine edgeStateStyles on Graph and stateStyles in data', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 300,\n        y: 300\n      }, {\n        id: 'node3',\n        x: 400,\n        y: 100\n      }],\n      edges: [{\n        id: 'edge1',\n        source: 'node1',\n        target: 'node2',\n        stateStyles: {\n          state1: {\n            lineWidth: 3,\n            stroke: '#f00',\n            shadowColor: '#0f0',\n            shadowBlur: 10\n          }\n        }\n      }, {\n        id: 'edge2',\n        source: 'node2',\n        target: 'node3'\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      edgeStateStyles: {\n        state1: {\n          lineWidth: 7\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const edge = graph.getEdges()[0];\n    graph.on('edge:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n      const keyShape = item.getKeyShape();\n      const id = item.getModel().id;\n\n      switch (id) {\n        case 'edge1':\n          expect(keyShape.attr('lineWidth')).toEqual(3);\n          expect(keyShape.attr('stroke')).toEqual('#f00');\n          expect(keyShape.attr('shadowColor')).toEqual('#0f0');\n          expect(keyShape.attr('shadowBlur')).toEqual(10);\n          break;\n\n        case 'edge2':\n          expect(keyShape.attr('lineWidth')).toEqual(7);\n          expect(keyShape.attr('stroke')).toEqual('rgb(150, 150, 150)');\n          break;\n      }\n    });\n    graph.on('edge:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', false);\n      expect(item.hasState('state1')).toEqual(false);\n    });\n    graph.emit('edge:mouseenter', {\n      item: edge\n    });\n    graph.emit('edge:mouseleave', {\n      item: edge\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update edge states with updateItem",
            "suites": [
                "graph edge states"
            ],
            "updatePoint": {
                "line": 595,
                "column": 40,
                "index": 16117
            },
            "line": 595,
            "code": "  it('update edge states with updateItem', () => {\n    const data = {\n      // 点集\n      nodes: [{\n        id: 'node1',\n        // String，该节点存在则必须，节点的唯一标识\n        x: 100,\n        // Number，可选，节点位置的 x 值\n        y: 200 // Number，可选，节点位置的 y 值\n\n      }, {\n        id: 'node2',\n        // String，该节点存在则必须，节点的唯一标识\n        x: 300,\n        // Number，可选，节点位置的 x 值\n        y: 200 // Number，可选，节点位置的 y 值\n\n      }],\n      // 边集\n      edges: [{\n        id: 'node1-node2',\n        source: 'node1',\n        // String，必须，起始点 id\n        target: 'node2' // String，必须，目标点 id\n\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      // String | HTMLElement，必须，在 Step 1 中创建的容器 id 或容器本身\n      width: 800,\n      // Number，必须，图的宽度\n      height: 500,\n      // Number，必须，图的高度\n      modes: {\n        default: ['drag-canvas', 'zoom-canvas', 'drag-node', {\n          type: 'brush-select',\n          trigger: 'ctrl',\n          includeEdges: false,\n          selectedState: 'click'\n        }]\n      },\n      defaultNode: {\n        size: 50,\n        // 节点大小\n        style: {\n          opacity: 0.8,\n          lineWidth: 1,\n          stroke: '#999'\n        },\n        labelCfg: {\n          style: {\n            fill: '#fff'\n          }\n        }\n      },\n      defaultEdge: {\n        labelCfg: {\n          autoRotate: true,\n          style: {\n            fontSize: 14,\n            fill: '#333'\n          }\n        },\n        style: {\n          stroke: '#808080',\n          lineWidth: 1,\n          endArrow: true,\n          lineAppendWidth: 10\n        }\n      },\n      // 边不同状态下的样式集合\n      edgeStateStyles: {\n        // 鼠标点击边，即 click 状态为 true 时的样式\n        click: {\n          stroke: 'red',\n          lineWidth: 2\n        }\n      }\n    });\n    graph.data(data);\n    graph.render(); // 验证 edge 的初始样式\n\n    const currentEdge = graph.findById('node1-node2');\n    let states = currentEdge.getStates();\n    expect(states.length).toBe(0);\n    let keyShape = currentEdge.getKeyShape();\n    expect(keyShape.attr('stroke')).toEqual('#808080'); // 先设置 edge click states\n\n    graph.setItemState(currentEdge, 'click', true);\n    states = currentEdge.getStates();\n    expect(states.length).toBe(1);\n    let stateStyle = currentEdge.getStateStyle('click');\n    expect(stateStyle).toEqual({\n      lineWidth: 2,\n      stroke: 'red'\n    });\n    keyShape = currentEdge.getKeyShape();\n    expect(keyShape.attr('stroke')).toEqual('red'); // 验证此时 edge 的样式状态\n    // 再使用 updateItem 更新 click states\n\n    const model = {\n      style: {\n        stroke: '#808080',\n        lineWidth: 1,\n        endArrow: true,\n        lineAppendWidth: 10\n      },\n      stateStyles: {\n        click: {\n          stroke: '#333',\n          lineWidth: 2\n        }\n      }\n    };\n    graph.updateItem('node1-node2', model); // updateItem 以后，edge click states 的值以及变化了\n\n    stateStyle = currentEdge.getStateStyle('click');\n    expect(stateStyle).toEqual({\n      lineWidth: 2,\n      stroke: '#333'\n    });\n    graph.destroy();\n    expect(graph.destroyed).toBe(true);\n  });",
            "file": "unit/state/edge-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global nodeStateStyles and defaultNode, state change with opacity changed",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 17,
                "column": 79,
                "index": 401
            },
            "line": 17,
            "code": "  it('global nodeStateStyles and defaultNode, state change with opacity changed', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        'comCircle:selected': {\n          keyShape: {\n            fill: 'red'\n          },\n          'circle-icon': {\n            stroke: 'green'\n          }\n        },\n        hover: {\n          opacity: 0.3\n        }\n      },\n      defaultNode: {\n        size: 25,\n        style: {\n          fill: 'steelblue',\n          opacity: 1\n        },\n        icon: {\n          show: true\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.addItem('node', {\n      id: 'node3',\n      x: 100,\n      y: 200\n    });\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true); // graph.setItemState(item, 'comCircle', 'selected')\n\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('opacity')).toEqual(0.8);\n      expect(keyShape.attr('fill')).toEqual('steelblue');\n    });\n    graph.on('node:click', e => {\n      const item = e.item; // graph.setItemState(item, 'hover', false);\n\n      graph.clearItemStates(item, 'hover');\n      const keyShape = item.getKeyShape();\n      expect(keyShape.attr('opacity')).toEqual(1);\n      expect(keyShape.attr('fill')).toEqual('steelblue');\n    }); // graph.destroy();\n  }); // setState to change the height, when the state is restored, the height can not be restored though the attrs are correct.",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global nodeStateStyles and defaultNode, state change with fill/r/width/height/stroke changed",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 72,
                "column": 98,
                "index": 1985
            },
            "line": 72,
            "code": "  it('global nodeStateStyles and defaultNode, state change with fill/r/width/height/stroke changed', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        hover: {// fill: '#f00',\n          // stroke: '#0f0',\n          // lineWidth: 3,\n          // r: 50,\n          // width: 50,\n          // height: 20\n        }\n      },\n      defaultNode: {\n        // size: 25,\n        style: {\n          // lineWdith: 1,\n          width: 30,\n          height: 30\n        }\n      }\n    }); // const canvas = graph.get('canvas');\n    // canvas.set('localRefresh', false);\n\n    graph.data(data);\n    graph.render();\n    const node3 = graph.addItem('node', {\n      id: 'node3',\n      x: 100,\n      y: 150,\n      type: 'rect'\n    });\n    graph.paint();\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n    });\n    graph.on('node:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global defaultNode and stateStyle in data, state change with fill/r/width/height/stroke changed",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 116,
                "column": 101,
                "index": 3070
            },
            "line": 116,
            "code": "  it('global defaultNode and stateStyle in data, state change with fill/r/width/height/stroke changed', () => {\n    const data2 = {\n      nodes: [{\n        id: 'circle',\n        x: 100,\n        y: 100,\n        stateStyles: {\n          hover: {\n            lineWidth: 3\n          }\n        }\n      }, {\n        id: 'rect',\n        x: 200,\n        y: 100,\n        type: 'rect',\n        stateStyles: {\n          hover: {\n            lineWidth: 3,\n            stroke: '#0f0'\n          }\n        }\n      }, {\n        id: 'triangle',\n        x: 300,\n        y: 100,\n        type: 'triangle'\n      }, {\n        id: 'ellipse',\n        x: 400,\n        y: 100,\n        type: 'ellipse',\n        stateStyles: {\n          hover: {\n            lineWidth: 3,\n            fillOpacity: 0.5\n          }\n        }\n      }, {\n        id: 'diamond',\n        x: 100,\n        y: 200,\n        type: 'diamond',\n        stateStyles: {\n          hover: {\n            strokeOpacity: 0.3\n          }\n        }\n      }, {\n        // when there is stroke, shadow layer error - G\n        id: 'star',\n        x: 200,\n        y: 200,\n        type: 'star',\n        stateStyles: {\n          hover: {\n            lineWidth: 3,\n            shadowColor: '#00f',\n            shadowBlur: 10,\n            shadowOffsetX: 10,\n            shadowOffsetY: -10\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        style: {\n          stroke: '#f00',\n          lineWidth: 1\n        }\n      }\n    });\n    graph.data(data2);\n    graph.render();\n    graph.paint();\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n      const id = item.getModel().id;\n      const keyShape = item.getKeyShape();\n      const attrs = keyShape.attr();\n\n      switch (id) {\n        case 'circle':\n          expect(attrs.lineWidth).toEqual(3);\n          expect(attrs.stroke).toEqual('#f00');\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n\n        case 'rect':\n          expect(attrs.lineWidth).toEqual(3);\n          expect(attrs.stroke).toEqual('#0f0');\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n\n        case 'triangle':\n          expect(attrs.lineWidth).toEqual(1);\n          expect(attrs.stroke).toEqual('#f00');\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n\n        case 'ellipse':\n          expect(attrs.lineWidth).toEqual(3);\n          expect(attrs.fillOpacity).toEqual(0.5);\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n\n        case 'diamond':\n          expect(attrs.lineWidth).toEqual(1);\n          expect(attrs.strokeOpacity).toEqual(0.3);\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n\n        case 'star':\n          expect(attrs.lineWidth).toEqual(3);\n          expect(attrs.shadowColor).toEqual('#00f');\n          expect(attrs.shadowBlur).toEqual(10);\n          expect(attrs.shadowOffsetX).toEqual(10);\n          expect(attrs.shadowOffsetY).toEqual(-10);\n          expect(attrs.fill).toEqual('rgb(239, 244, 255)');\n          break;\n      }\n    });\n    graph.on('node:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n    });\n    graph.getNodes().forEach(node => {\n      graph.emit('node:mouseenter', {\n        item: node\n      });\n      graph.emit('node:mouseleave', {\n        item: node\n      });\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "global defaultNode and multiple stateStyle in data",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 257,
                "column": 56,
                "index": 6568
            },
            "line": 257,
            "code": "  it('global defaultNode and multiple stateStyle in data', () => {\n    const data2 = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100,\n        stateStyles: {\n          hover: {\n            lineWidth: 3\n          },\n          state1: {\n            lineWidth: 5,\n            fill: '#f00'\n          },\n          state2: {\n            stroke: '#0f0'\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        style: {\n          stroke: '#f00',\n          lineWidth: 1\n        }\n      }\n    });\n    graph.data(data2);\n    graph.render();\n    const node = graph.getNodes()[0];\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', true);\n      expect(item.hasState('hover')).toEqual(true);\n    });\n    graph.on('node:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'hover', false);\n      expect(item.hasState('state1')).toEqual(true);\n      expect(item.hasState('hover')).toEqual(false);\n    });\n    graph.on('node:click', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n    });\n    graph.on('canvas:click', () => {\n      graph.getNodes().forEach(node => {\n        graph.setItemState(node, 'state1', false);\n        expect(node.hasState('state1')).toEqual(false);\n      });\n    });\n    graph.emit('node:mouseenter', {\n      item: node\n    });\n    graph.emit('node:click', {\n      item: node\n    });\n    graph.emit('node:mouseleave', {\n      item: node\n    });\n    graph.emit('canvas:click', {});\n    graph.destroy();\n  });",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateItem and state",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 325,
                "column": 26,
                "index": 8241
            },
            "line": 325,
            "code": "  it('updateItem and state', () => {\n    const data2 = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100,\n        stateStyles: {\n          state1: {\n            lineWidth: 5,\n            fill: '#00f',\n            stroke: '#0ff',\n            width: 30\n          }\n        }\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      defaultNode: {\n        style: {\n          stroke: '#f00',\n          lineWidth: 1\n        }\n      }\n    });\n    graph.data(data2);\n    graph.render();\n    const node = graph.getNodes()[0];\n    graph.updateItem(node, {\n      type: 'rect',\n      size: [50, 30],\n      style: {\n        fill: '#0f0'\n      }\n    });\n    expect(node.getKeyShape().attr('fill')).toEqual('#0f0');\n    expect(node.getKeyShape().attr('lineWidth')).toEqual(1);\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n    });\n    graph.on('node:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', false);\n      expect(item.hasState('state1')).toEqual(false);\n    });\n    graph.emit('node:mouseenter', {\n      item: node\n    });\n    graph.emit('node:mouseleave', {\n      item: node\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "combine nodeStateStyles on Graph and stateStyles in data",
            "suites": [
                "graph node states"
            ],
            "updatePoint": {
                "line": 382,
                "column": 62,
                "index": 9615
            },
            "line": 382,
            "code": "  it('combine nodeStateStyles on Graph and stateStyles in data', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100,\n        stateStyles: {\n          state1: {\n            fill: '#f00',\n            shadowColor: '#0f0',\n            shadowBlur: 10\n          }\n        }\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        state1: {\n          fill: '#0f0'\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('node:mouseenter', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', true);\n      expect(item.hasState('state1')).toEqual(true);\n      const keyShape = item.getKeyShape();\n      const id = item.getModel().id;\n\n      switch (id) {\n        case 'node1':\n          expect(keyShape.attr('lineWidth')).toEqual(1);\n          expect(keyShape.attr('fill')).toEqual('#f00');\n          expect(keyShape.attr('shadowColor')).toEqual('#0f0');\n          expect(keyShape.attr('shadowBlur')).toEqual(10);\n          break;\n\n        case 'node2':\n          expect(keyShape.attr('lineWidth')).toEqual(1);\n          expect(keyShape.attr('fill')).toEqual('#0f0');\n          expect(keyShape.attr('shadowColor')).toEqual(undefined);\n          expect(keyShape.attr('shadowBlur')).toEqual(undefined);\n          break;\n      }\n    });\n    graph.on('node:mouseleave', e => {\n      const item = e.item;\n      graph.setItemState(item, 'state1', false);\n      expect(item.hasState('state1')).toEqual(false);\n    });\n    graph.getNodes().forEach(node => {\n      graph.emit('node:mouseenter', {\n        item: node\n      });\n      graph.emit('node:mouseleave', {\n        item: node\n      });\n    });\n    graph.destroy();\n  });",
            "file": "unit/state/node-state-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "without second params, clear all states",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 53,
                "column": 45,
                "index": 1126
            },
            "line": 53,
            "code": "  it('without second params, clear all states', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        hover: {\n          opacity: 0.3\n        },\n        'body:health': {\n          fill: 'red'\n        }\n      },\n      defaultNode: {\n        size: 25,\n        style: {\n          fill: 'steelblue',\n          opacity: 1\n        }\n      }\n    });\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const item = graph.findById('node1');\n    graph.setItemState(item, 'hover', true);\n    expect(item.hasState('hover')).toBe(true);\n    const keyShape = item.getKeyShape();\n    expect(keyShape.attr('fill')).toEqual('steelblue');\n    graph.setItemState(item, 'body', 'health');\n    expect(item.getStates().length).toBe(2);\n    expect(item.hasState('body:health')).toBe(true);\n    expect(item.getKeyShape().attr('fill')).toEqual('red');\n    graph.clearItemStates(item);\n    expect(item.hasState('hover')).toBe(false);\n    expect(item.hasState('body:health')).toBe(false);\n    expect(item.getStates().length).toBe(0);\n    graph.destroy();\n  });",
            "file": "unit/state/update-element-states-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "setItemState, then updateItem",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 102,
                "column": 35,
                "index": 2387
            },
            "line": 102,
            "code": "  it('setItemState, then updateItem', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        hover: {\n          opacity: 0.3\n        }\n      },\n      defaultNode: {\n        size: 25,\n        style: {\n          fill: 'steelblue',\n          opacity: 1\n        }\n      }\n    });\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const item = graph.findById('node1');\n    graph.setItemState(item, 'hover', true);\n    expect(item.hasState('hover')).toBe(true);\n    const keyShape = item.getKeyShape();\n    expect(keyShape.attr('fill')).toEqual('steelblue');\n    graph.updateItem(item, {\n      style: {\n        stroke: 'green',\n        opacity: 0.5\n      }\n    });\n    expect(keyShape.attr('stroke')).toEqual('green'); // updateItem 后还存在 hover 状态\n\n    expect(item.hasState('hover')).toBe(true);\n    expect(item.getStates().length).toBe(1);\n    expect(keyShape.attr('opacity')).toEqual(0.3);\n    graph.clearItemStates(item, 'hover');\n    expect(item.hasState('hover')).toBe(false);\n    expect(item.getStates().length).toBe(0);\n    expect(keyShape.attr('opacity')).toEqual(0.5);\n    graph.destroy();\n  });",
            "file": "unit/state/update-element-states-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "updateItem, then setItemState",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 155,
                "column": 35,
                "index": 3722
            },
            "line": 155,
            "code": "  it('updateItem, then setItemState', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        'comCircle:selected': {\n          fill: 'red'\n        },\n        hover: {\n          opacity: 0.3,\n          fill: 'blue'\n        }\n      },\n      defaultNode: {\n        size: 25,\n        style: {\n          fill: 'steelblue',\n          opacity: 1\n        },\n        icon: {\n          show: true\n        }\n      }\n    });\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const item = graph.findById('node1');\n    graph.setItemState(item, 'comCircle', 'selected');\n    expect(item.hasState('comCircle:selected')).toBe(true);\n    expect(item.getStates().length).toBe(1); // state: conCircle:selected\n    // fill: red\n\n    const keyShape = item.getKeyShape();\n    expect(keyShape.attr('fill')).toEqual('red');\n    graph.clearItemStates(item, 'comCircle:selected');\n    expect(item.hasState('comCircle:selected')).toBe(false);\n    expect(item.getStates().length).toBe(0); // 内置 circle 默认的 stroke\n\n    expect(keyShape.attr('stroke')).toEqual('rgb(95, 149, 255)');\n    expect(keyShape.attr('fill')).toEqual('steelblue');\n    graph.updateItem(item, {\n      style: {\n        fill: 'green',\n        stroke: 'green',\n        opacity: 0.5\n      },\n      stateStyles: {\n        hover: {\n          opacity: 0.6,\n          stroke: '#ccc'\n        }\n      }\n    }); // 此时没有 states，以 update 样式为准\n\n    expect(keyShape.attr('fill')).toEqual('green');\n    expect(keyShape.attr('stroke')).toEqual('green');\n    expect(keyShape.attr('opacity')).toEqual(0.5); // 设置 hover states\n\n    graph.setItemState(item, 'hover', true);\n    expect(item.hasState('hover')).toBe(true);\n    expect(item.getStates().length).toBe(1);\n    expect(keyShape.attr('stroke')).toEqual('#ccc');\n    expect(keyShape.attr('opacity')).toEqual(0.6); // setItemState 之前，已经设置了fill\n\n    expect(keyShape.attr('fill')).toEqual('green'); // 清除 hover states 后，无任何 states，恢复 update 后的样式\n\n    graph.clearItemStates(item, 'hover');\n    expect(item.hasState('hover')).toBe(false);\n    expect(item.getStates().length).toBe(0);\n    expect(keyShape.attr('stroke')).toEqual('green');\n    expect(keyShape.attr('opacity')).toEqual(0.5);\n    expect(keyShape.attr('fill')).toEqual('green');\n    graph.destroy();\n    expect(graph.destroyed).toBe(true);\n  });",
            "file": "unit/state/update-element-states-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "many times setItemState & updateItem width default node",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 242,
                "column": 61,
                "index": 6264
            },
            "line": 242,
            "code": "  it('many times setItemState & updateItem width default node', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        'comCircle:selected': {\n          fill: 'red',\n          'circle-icon': {\n            stroke: 'green'\n          }\n        },\n        hover: {\n          opacity: 0.3,\n          fill: 'blue'\n        }\n      },\n      defaultNode: {\n        size: 25,\n        style: {\n          fill: 'steelblue',\n          opacity: 1\n        },\n        icon: {\n          show: true\n        }\n      }\n    });\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const item = graph.findById('node1');\n    graph.setItemState(item, 'hover', true);\n    graph.setItemState(item, 'comCircle', 'selected');\n    expect(item.hasState('hover')).toBe(true);\n    expect(item.hasState('comCircle:selected')).toBe(true);\n    expect(item.getStates().length).toBe(2); // state: hover -> conCircle:selected\n    // opacity: 0.3 fill: red\n\n    const keyShape = item.getKeyShape();\n    expect(keyShape.attr('opacity')).toEqual(0.3);\n    expect(keyShape.attr('fill')).toEqual('red');\n    graph.updateItem(item, {\n      style: {\n        fill: 'green',\n        stroke: 'green',\n        opacity: 0.5\n      },\n      stateStyles: {\n        hover: {\n          opacity: 0.6,\n          stroke: '#ccc'\n        }\n      }\n    }); // updateItem 后 由于存在 hover 及 conCircle:selected 两个 state，\n    // 本来应该只有 stroke: green 生效，但由于更新了 hover state，则 update 的所有都不生效\n\n    const hoverState = item.getStateStyle('hover');\n    expect(hoverState.opacity).toBe(0.6);\n    expect(hoverState.stroke).toEqual('#ccc');\n    expect(keyShape.attr('stroke')).toEqual('#ccc');\n    expect(keyShape.attr('opacity')).toEqual(0.6);\n    expect(keyShape.attr('fill')).toEqual('red'); // 清除 hover state，只剩一个 conCircle:selected，\n    // 则 update 后的 stroke 和 opacity 会生效，而 fill 则使用 conCircle:selected 的值\n\n    graph.clearItemStates(item, 'hover');\n    expect(item.hasState('hover')).toBe(false);\n    expect(item.hasState('comCircle:selected')).toBe(true);\n    expect(item.getStates().length).toBe(1);\n    expect(keyShape.attr('stroke')).toEqual('green');\n    expect(keyShape.attr('opacity')).toEqual(0.5);\n    expect(keyShape.attr('fill')).toEqual('red'); // 清除 comCircle:selected 状态后，则没有任何状态，样式以 update 的为准\n\n    graph.clearItemStates(item, 'comCircle:selected');\n    expect(item.hasState('comCircle:selected')).toBe(false);\n    expect(item.getStates().length).toBe(0);\n    expect(keyShape.attr('fill')).toEqual('green');\n    expect(keyShape.attr('opacity')).toEqual(0.5);\n    graph.destroy();\n    expect(graph.destroyed).toBe(true);\n  });",
            "file": "unit/state/update-element-states-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "many times setItemState & updateItem width register node",
            "suites": [
                "update"
            ],
            "updatePoint": {
                "line": 333,
                "column": 62,
                "index": 9067
            },
            "line": 333,
            "code": "  it('many times setItemState & updateItem width register node', () => {\n    const graph = new Graph({\n      container: div,\n      width: 500,\n      height: 500,\n      nodeStateStyles: {\n        'register:selected': {\n          'main-node': {\n            fill: 'red',\n            opacity: 0.7\n          },\n          'sub-node': {\n            fill: '#000',\n            opacity: 0.2\n          },\n          'node-text': {\n            stroke: 'black',\n            // green\n            fontSize: 20\n          }\n        },\n        hover: {\n          opacity: 0.3,\n          fill: 'blue'\n        }\n      },\n      defaultNode: {\n        size: 25,\n        type: 'self-node',\n        style: {\n          opacity: 1\n        }\n      }\n    });\n    const data = {\n      nodes: [{\n        id: 'node1',\n        x: 100,\n        y: 100\n      }, {\n        id: 'node2',\n        x: 200,\n        y: 100\n      }]\n    };\n    graph.data(data);\n    graph.render();\n    const item = graph.findById('node1');\n    const keyShape = item.getKeyShape();\n    expect(keyShape.attr('fill')).toEqual('pink');\n    expect(keyShape.attr('opacity')).toBe(1);\n    const group = item.getContainer();\n    const subNode = group.find(ele => ele.get('name') === 'sub-node');\n    expect(subNode.attr('fill')).toEqual('blue');\n    const text = group.find(ele => ele.get('name') === 'node-text');\n    expect(text.attr('stroke')).toEqual('green');\n    graph.setItemState(item, 'hover', true);\n    expect(item.hasState('hover')).toBe(true);\n    expect(item.getStates().length).toBe(1); // state: hover\n    // opacity: 0.3 fill: blue\n\n    expect(keyShape.attr('opacity')).toEqual(0.3);\n    expect(keyShape.attr('fill')).toEqual('blue'); // 更新 item 之前已有 hover 状态\n\n    graph.updateItem(item, {\n      style: {\n        fill: 'green',\n        stroke: 'green',\n        opacity: 0.5,\n        'node-text': {\n          stroke: 'yellow'\n        }\n      },\n      stateStyles: {\n        hover: {\n          opacity: 0.6,\n          stroke: '#ccc'\n        },\n        xxx: {\n          opacity: 0.1,\n          'node-text': {\n            stroke: 'blue'\n          }\n        }\n      }\n    }); // updateItem 后 由于存在 hover state，\n    // 本来应该生效的 opacity 和 stroke 都不生效，update 中的 hover state 会覆盖 实例化 graph 时候定义的\n\n    const hoverState = item.getStateStyle('hover');\n    expect(hoverState.opacity).toBe(0.6);\n    expect(hoverState.stroke).toEqual('#ccc');\n    expect(item.getStates().length).toBe(1);\n    expect(keyShape.attr('stroke')).toEqual('#ccc');\n    expect(keyShape.attr('opacity')).toEqual(0.6); // update item 时的 fill 生效\n\n    expect(keyShape.attr('fill')).toEqual('green'); // 更新以后，text-node 的 stroke 发生了改变\n\n    expect(text.attr('stroke')).toEqual('yellow'); // sub-node 不发生改变\n\n    expect(subNode.attr('fill')).toEqual('blue'); // 设置 register:selected states，会覆盖 hover states 中的以下属性：\n    // main-node：fill、opacity\n    // sub-node：fill、opacity\n    // text-node：fontSize、stroke\n\n    graph.setItemState(item, 'register', 'selected');\n    expect(item.hasState('register:selected')).toBe(true);\n    expect(item.getStates().length).toBe(2);\n    expect(keyShape.attr('fill')).toEqual('red');\n    expect(keyShape.attr('opacity')).toEqual(0.7);\n    expect(subNode.attr('fill')).toEqual('#000');\n    expect(subNode.attr('opacity')).toEqual(0.2);\n    expect(text.attr('fontSize')).toBe(20);\n    expect(text.attr('stroke')).toEqual('black'); // 清除 hover 和 register:selected，则 update 后的属性生效\n\n    graph.clearItemStates(item, ['register:selected', 'hover']); // graph.setItemState(item, 'register:selected', false);\n    // graph.setItemState(item, 'hover', false);\n\n    expect(item.hasState('register:selected')).toBe(false);\n    expect(item.getStates().length).toBe(0);\n    expect(keyShape.attr('fill')).toEqual('green');\n    expect(keyShape.attr('stroke')).toEqual('green');\n    expect(keyShape.attr('opacity')).toEqual(0.5);\n    expect(text.attr('stroke')).toEqual('yellow');\n    graph.setItemState(item, 'xxx', true);\n    expect(keyShape.attr('opacity')).toEqual(0.1);\n    expect(text.attr('stroke')).toEqual('blue');\n    graph.destroy();\n    expect(graph.destroyed).toBe(true);\n  });",
            "file": "unit/state/update-element-states-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "div content",
            "suites": [
                "template"
            ],
            "updatePoint": {
                "line": 6,
                "column": 17,
                "index": 195
            },
            "line": 6,
            "code": "  it('div content', () => {\n    expect(document.querySelector('#test-div-id').innerHTML).toBe('hello g6');\n  });",
            "file": "unit/template-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "update node",
            "suites": [
                "graph"
            ],
            "updatePoint": {
                "line": 80,
                "column": 17,
                "index": 1413
            },
            "line": 80,
            "code": "  it('update node', () => {\n    // graph.updateItem(graph.getNodes()[0], {\n    //     label: 'abc',\n    //     size: 10,\n    //     labelCfg: {\n    //       style: {\n    //         fill:'#f00',\n    //         lineWidth: 1,\n    //         background: {\n    //           fill: '#ffffff',\n    //           stroke: '#9EC9FF',\n    //           padding: 2,\n    //           radius: 2,\n    //         },\n    //       }\n    //     }\n    //   })\n    // })\n    // fps monitor loops\n    let count = 0;\n    const stats = new Stats();\n    stats.showPanel(0);\n    document.body.appendChild(stats.dom);\n    let currentPos = 150;\n\n    function animate() {\n      stats.update();\n      graph.getNodes().forEach((node, i) => {\n        graph.updateItem(node, {\n          label: 'abc',\n          size: 10 + (count + i) % 5,\n          labelCfg: {\n            style: {\n              fill: '#f00',\n              lineWidth: (count + i) % 5,\n              background: {\n                fill: '#ffffff',\n                stroke: '#9EC9FF',\n                padding: (count + i) % 5,\n                radius: 2\n              }\n            }\n          }\n        });\n      });\n      count++;\n      requestAnimationFrame(animate);\n    }\n\n    requestAnimationFrame(animate); // setInterval(() => {\n    //   count++\n    //   graph.getNodes().forEach((node, i) => {\n    //     graph.updateItem(node, {\n    //       label: 'abc',\n    //       size: 10 + (count + i) % 5,\n    //       labelCfg: {\n    //         style: {\n    //           fill:'#f00',\n    //           lineWidth: (count + i) % 5,\n    //           background: {\n    //             fill: '#ffffff',\n    //             stroke: '#9EC9FF',\n    //             padding: (count + i) % 5,\n    //             radius: 2,\n    //           },\n    //         }\n    //       }\n    //     })\n    //   })\n    // }, 100)\n  });",
            "file": "unit/update/test-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "traverseTree",
            "suites": [
                "graphic unit test"
            ],
            "updatePoint": {
                "line": 3,
                "column": 18,
                "index": 144
            },
            "line": 3,
            "code": "  it('traverseTree', () => {\n    const data = {\n      id: 'root',\n      children: [{\n        id: 'subroot1',\n        label: 'xxx'\n      }, {\n        id: 'subroot2',\n        children: [{\n          id: 'yyy'\n        }]\n      }]\n    };\n    const trees = [];\n    traverseTree(data, node => {\n      trees.push(node);\n      return true;\n    });\n    expect(trees[0].id).toBe('root');\n    expect(trees[0].children.length).toBe(2);\n    expect(trees[1].id).toBe('subroot2');\n    expect(trees[1].label).toBe(undefined);\n    expect(trees[2].id).toBe('yyy');\n    expect(trees[3].id).toBe('subroot1');\n  });",
            "file": "unit/util/graphic-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "traverseTree end with returning false",
            "suites": [
                "graphic unit test"
            ],
            "updatePoint": {
                "line": 28,
                "column": 43,
                "index": 763
            },
            "line": 28,
            "code": "  it('traverseTree end with returning false', () => {\n    const data = {\n      id: 'root',\n      children: [{\n        id: 'A',\n        label: 'A',\n        children: [{\n          id: 'A1'\n        }]\n      }, {\n        id: 'B',\n        children: [{\n          id: 'B1'\n        }, {\n          id: 'B2'\n        }]\n      }]\n    };\n    let trees = [];\n    traverseTree(data, node => {\n      trees.push(node);\n      if (node.id === 'A') return false;\n      return true;\n    });\n    expect(trees.length).toBe(5);\n    trees = [];\n    traverseTreeUp(data, node => {\n      trees.push(node);\n      if (node.id === 'B') return false;\n      return true;\n    });\n    expect(trees.length).toBe(3);\n  });",
            "file": "unit/util/graphic-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getTextSize",
            "suites": [
                "graphic unit test"
            ],
            "updatePoint": {
                "line": 61,
                "column": 17,
                "index": 1424
            },
            "line": 61,
            "code": "  it('getTextSize', () => {\n    let result = getTextSize('abc', 12);\n    expect(result).toEqual([20.303961181640624, 12]);\n    result = getTextSize('体验技术', 14);\n    expect(result).toEqual([56, 14]);\n  });",
            "file": "unit/util/graphic-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getSpline",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 4,
                "column": 15,
                "index": 235
            },
            "line": 4,
            "code": "  it('getSpline', () => {\n    const points = [{\n      x: 10,\n      y: 12\n    }, {\n      x: 5,\n      y: 5\n    }, {\n      x: 2,\n      y: 7\n    }];\n    const splinePath = getSpline(points);\n    expect(splinePath.length).toEqual(3);\n    const first = splinePath[0];\n    expect(first.length).toEqual(3);\n    expect(first[0]).toEqual('M');\n    expect(first[1]).toEqual(10);\n    expect(first[2]).toEqual(12);\n    const second = splinePath[1];\n    expect(second.length).toEqual(7);\n    expect(second[0]).toEqual('C');\n    expect(second[1]).toEqual(10);\n    expect(second[2]).toEqual(12);\n    expect(second[5]).toEqual(5);\n    const three = splinePath[2];\n    expect(three.length).toEqual(7);\n    expect(three[2]).toEqual(5);\n    expect(three[6]).toEqual(7);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getSpline thorw new error",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 33,
                "column": 31,
                "index": 1007
            },
            "line": 33,
            "code": "  it('getSpline thorw new error', () => {\n    const points = [{\n      x: 10,\n      y: 12\n    }];\n    expect(() => getSpline(points)).toThrowError(`point length must largn than 2, now it's ${points.length}`);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getControlPoint horizontal",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 40,
                "column": 32,
                "index": 1222
            },
            "line": 40,
            "code": "  it('getControlPoint horizontal', () => {\n    const start = {\n      x: 0,\n      y: 0\n    };\n    const end = {\n      x: 100,\n      y: 0\n    };\n    const controlPoint = getControlPoint(start, end, 0.5, 10);\n    expect(controlPoint.x).toEqual(50);\n    expect(controlPoint.y).toEqual(10);\n    const points = getControlPoint(start, end, 0.2, -2);\n    expect(points).toEqual({\n      x: 20,\n      y: -2\n    });\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getControlPoint vertical",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 58,
                "column": 30,
                "index": 1631
            },
            "line": 58,
            "code": "  it('getControlPoint vertical', () => {\n    const start = {\n      x: 0,\n      y: 0\n    };\n    const end = {\n      x: 0,\n      y: 100\n    };\n    const point = getControlPoint(start, end, 0.5);\n    expect(point).toEqual({\n      x: 0,\n      y: 50\n    });\n    const point2 = getControlPoint(start, end, 0.2, -2);\n    expect(point2).toEqual({\n      x: 2,\n      y: 20\n    });\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getControlPoint 45",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 78,
                "column": 24,
                "index": 2002
            },
            "line": 78,
            "code": "  it('getControlPoint 45', () => {\n    const start = {\n      x: 0,\n      y: 0\n    };\n    const end = {\n      x: 100,\n      y: 100\n    };\n    const point = getControlPoint(start, end, 0.5, 10);\n    const sqrt2 = Math.sqrt(2);\n    expect(point.x).toEqual(50 - sqrt2 * 10 / 2);\n    expect(point.y).toEqual(50 + sqrt2 * 10 / 2);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getControlPoint 135",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 92,
                "column": 25,
                "index": 2334
            },
            "line": 92,
            "code": "  it('getControlPoint 135', () => {\n    const start = {\n      x: 100,\n      y: 100\n    };\n    const end = {\n      x: 0,\n      y: 0\n    };\n    const point = getControlPoint(start, end, 0.5, 10);\n    const sqrt2 = Math.sqrt(2);\n    expect(point.x).toEqual(50 + sqrt2 * 10 / 2);\n    expect(point.y).toEqual(50 - sqrt2 * 10 / 2);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getControlPoint percent is 0",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 106,
                "column": 34,
                "index": 2675
            },
            "line": 106,
            "code": "  it('getControlPoint percent is 0', () => {\n    const start = {\n      x: 100,\n      y: 100\n    };\n    const end = {\n      x: 50,\n      y: 20\n    };\n    const point = getControlPoint(start, end);\n    expect(point.x).toEqual(100);\n    expect(point.y).toEqual(100);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "pointsToPolygon points.length = 0",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 119,
                "column": 39,
                "index": 2950
            },
            "line": 119,
            "code": "  it('pointsToPolygon points.length = 0', () => {\n    const polygonPoint = pointsToPolygon([]);\n    expect(polygonPoint).toEqual('');\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "pointsToPolygon z = false",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 123,
                "column": 31,
                "index": 3082
            },
            "line": 123,
            "code": "  it('pointsToPolygon z = false', () => {\n    const points = [{\n      x: 1,\n      y: 2\n    }, {\n      x: 5,\n      y: 5\n    }];\n    const polygonPoint = pointsToPolygon(points, false);\n    expect(polygonPoint).toEqual('M1 2L5 5');\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "pointsToPolygon z = true",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 134,
                "column": 30,
                "index": 3317
            },
            "line": 134,
            "code": "  it('pointsToPolygon z = true', () => {\n    const points = [{\n      x: 1,\n      y: 2\n    }, {\n      x: 5,\n      y: 5\n    }];\n    const polygonPoint = pointsToPolygon(points, true);\n    expect(polygonPoint).toEqual('M1 2L5 5Z');\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "pointsToPolygon substitute",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 145,
                "column": 32,
                "index": 3554
            },
            "line": 145,
            "code": "  it('pointsToPolygon substitute', () => {\n    const points = [{\n      x: 1,\n      y: 2\n    }, ''];\n    const polygonPoint = pointsToPolygon(points, true);\n    expect(polygonPoint).toEqual('M1 2L{x} {y}Z');\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "pathToPoints",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 153,
                "column": 18,
                "index": 3753
            },
            "line": 153,
            "code": "  it('pathToPoints', () => {\n    const path = [['M', 0, 0], ['L', 10, 10], ['L', 100, 40]];\n    const points = pathToPoints(path);\n    expect(points[0][0]).toBe(0);\n    expect(points[1][0]).toBe(10);\n    expect(points[2][0]).toBe(100);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "getClosedSpline",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 160,
                "column": 21,
                "index": 3998
            },
            "line": 160,
            "code": "  it('getClosedSpline', () => {\n    const points = [{\n      x: 0,\n      y: 0\n    }, {\n      x: 10,\n      y: 10\n    }, {\n      x: 100,\n      y: 40\n    }];\n    const res = getClosedSpline(points);\n    expect(res[0][0]).toBe('M');\n    expect(res[0][1]).toBe(100);\n    expect(res[0][2]).toBe(40);\n    expect(res[1][0]).toBe('C');\n    expect(res[1][3]).toBe(15);\n    expect(res[1][4]).toBe(5);\n    expect(res[2][0]).toBe('C');\n    expect(res[2][1]).toBe(-15);\n    expect(res[2][2]).toBe(-5);\n    expect(res[4][0]).toBe('C');\n    expect(res[4][3]).toBe(15);\n    expect(res[4][4]).toBe(5);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "roundedHull",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 185,
                "column": 17,
                "index": 4583
            },
            "line": 185,
            "code": "  it('roundedHull', () => {\n    const points = [[0, 0], [10, 10], [100, 40]];\n    const res = roundedHull(points, 10);\n    const splits = res.split(' ');\n    expect(splits[0]).toEqual('M');\n    expect(splits[1]).toEqual('96.83772233983161,49.48683298050514');\n    expect(splits[2]).toEqual('A');\n    expect(splits[3]).toEqual('10,10,0,0,0,103.71390676354103,30.715233091147407');\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "paddedHull",
            "suites": [
                "Path Util Test"
            ],
            "updatePoint": {
                "line": 194,
                "column": 16,
                "index": 4968
            },
            "line": 194,
            "code": "  it('paddedHull', () => {\n    const points = [[0, 0], [10, 10], [100, 40]];\n    const res = paddedHull(points, 10);\n    expect(res[0].x).toEqual(-8.348410922382678);\n    expect(res[0].y).toEqual(-5.504910087462066);\n    expect(res[1].x).toEqual(4.742688878808661);\n    expect(res[1].y).toEqual(18.506508083520398);\n    expect(res[2].x).toEqual(109.38985166381534);\n    expect(res[2].y).toEqual(43.439576388386264);\n  });",
            "file": "unit/util/path-spec.ts",
            "skipped": false,
            "dir": "packages/core/tests"
        },
        {
            "name": "edge ",
            "suites": [
                "edge click state"
            ],
            "updatePoint": {
                "line": 6,
                "column": 11,
                "index": 173
            },
            "line": 6,
            "code": "  it('edge ', () => {\n    G6.registerBehavior('active-edge', {\n      getEvents() {\n        return {\n          'edge:click': 'onEdgeSelect',\n          'edge:mouseenter': 'onEdgeHover',\n          'edge:mouseleave': 'onEdgeLeave',\n          'canvas:mousedown': 'clearSelectedEdge'\n        };\n      },\n\n      onEdgeSelect(evt) {\n        const item = evt.item;\n\n        if (item.hasState('select')) {\n          this.graph.setItemState(item, 'select', false);\n          return;\n        }\n\n        this.graph.setItemState(item, 'select', true);\n      },\n\n      onEdgeHover(evt) {\n        const item = evt.item;\n\n        if (item.hasState('select')) {\n          return false;\n        }\n\n        this.graph.setItemState(item, 'hover', true);\n      },\n\n      onEdgeLeave(evt) {\n        const item = evt.item;\n        this.graph.setItemState(item, 'hover', false);\n      },\n\n      clearSelectedEdge(evt) {\n        const edges = this.graph.findAllByState('edge', 'select');\n        edges.forEach(edge => {\n          this.graph.setItemState(edge, 'select', false);\n        });\n      }\n\n    });\n    const graph = new G6.Graph({\n      container: 'container',\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        type: 'line',\n        style: {\n          stroke: '#24A0FF',\n          radius: 4,\n          offset: 15,\n          lineWidth: 2,\n          lineAppendWidth: 4,\n          cursor: 'pointer',\n          endArrow: {\n            path: 'M 0,0 L 7,3 L 5,0 L 7,-3 Z',\n            fill: '#24A0FF'\n          }\n        }\n      },\n      edgeStateStyles: {\n        hover: {\n          stroke: '#0ff',\n          endArrow: {\n            fill: '#FF7868'\n          }\n        },\n        select: {\n          stroke: '#FF7868',\n          endArrow: {\n            fill: '#FF7868'\n          }\n        }\n      },\n      modes: {\n        default: ['drag-node', 'active-edge']\n      }\n    });\n    graph.read({\n      nodes: [{\n        id: '1',\n        x: 100,\n        y: 100\n      }, {\n        id: '2',\n        x: 100,\n        y: 220\n      }],\n      edges: [{\n        source: '1',\n        target: '2'\n      }]\n    });\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "dragenter",
            "suites": [
                "dragenter dragleave"
            ],
            "updatePoint": {
                "line": 128,
                "column": 15,
                "index": 2665
            },
            "line": 128,
            "code": "  it('dragenter', () => {\n    graph.on('node:dragenter', e => {// console.log('dragenter');\n    });\n    graph.on('node:dragleave', e => {// console.log('dragleave');\n    });\n    graph.on('node:mouseenter', e => {// console.log('mouseenter');\n    });\n    graph.on('node:mouseleave', e => {// console.log('mouseleave');\n    });\n    graph.on('node:dragover', e => {// console.log('dragover');\n    });\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "empty data array + fitview",
            "suites": [
                "empty data array + fitview"
            ],
            "updatePoint": {
                "line": 155,
                "column": 32,
                "index": 3361
            },
            "line": 155,
            "code": "  it('empty data array + fitview', () => {\n    graph.render();\n    graph.destroy();\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "change data",
            "suites": [
                "change data with rect node"
            ],
            "updatePoint": {
                "line": 184,
                "column": 17,
                "index": 3878
            },
            "line": 184,
            "code": "  it('change data', () => {\n    graph.render();\n    graph.changeData(data);\n    graph.destroy();\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "change data",
            "suites": [
                "cubic with layout"
            ],
            "updatePoint": {
                "line": 267,
                "column": 17,
                "index": 5680
            },
            "line": 267,
            "code": "  it('change data', () => {\n    graph.data(data);\n    graph.render();\n    graph.destroy();\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "changeData",
            "suites": [
                "changdata states"
            ],
            "updatePoint": {
                "line": 274,
                "column": 16,
                "index": 5817
            },
            "line": 274,
            "code": "  it('changeData', () => {\n    const data = {\n      nodes: [{\n        id: '0',\n        label: '0'\n      }, {\n        id: '1',\n        label: '1'\n      }, {\n        id: '2',\n        label: '2'\n      }, {\n        id: '3',\n        label: '3'\n      }, {\n        id: '4',\n        label: '4'\n      }, {\n        id: '5',\n        label: '5'\n      }, {\n        id: '6',\n        label: '6'\n      }, {\n        id: '7',\n        label: '7'\n      }, {\n        id: '8',\n        label: '8'\n      }, {\n        id: '9',\n        label: '9'\n      }, {\n        id: '10',\n        label: '10'\n      }, {\n        id: '11',\n        label: '11'\n      }, {\n        id: '12',\n        label: '12'\n      }, {\n        id: '13',\n        label: '13'\n      }, {\n        id: '14',\n        label: '14'\n      }, {\n        id: '15',\n        label: '15'\n      }, {\n        id: '16',\n        label: '16'\n      }, {\n        id: '17',\n        label: '17'\n      }, {\n        id: '18',\n        label: '18'\n      }, {\n        id: '19',\n        label: '19'\n      }, {\n        id: '20',\n        label: '20'\n      }, {\n        id: '21',\n        label: '21'\n      }, {\n        id: '22',\n        label: '22'\n      }, {\n        id: '23',\n        label: '23'\n      }, {\n        id: '24',\n        label: '24'\n      }, {\n        id: '25',\n        label: '25'\n      }, {\n        id: '26',\n        label: '26'\n      }, {\n        id: '27',\n        label: '27'\n      }, {\n        id: '28',\n        label: '28'\n      }, {\n        id: '29',\n        label: '29'\n      }, {\n        id: '30',\n        label: '30'\n      }, {\n        id: '31',\n        label: '31'\n      }, {\n        id: '32',\n        label: '32'\n      }, {\n        id: '33',\n        label: '33'\n      }],\n      edges: [{\n        source: '0',\n        target: '1'\n      }, {\n        source: '0',\n        target: '2'\n      }, {\n        source: '0',\n        target: '3'\n      }, {\n        source: '0',\n        target: '4'\n      }, {\n        source: '0',\n        target: '5'\n      }, {\n        source: '0',\n        target: '7'\n      }, {\n        source: '0',\n        target: '8'\n      }, {\n        source: '0',\n        target: '9'\n      }, {\n        source: '0',\n        target: '10'\n      }, {\n        source: '0',\n        target: '11'\n      }, {\n        source: '0',\n        target: '13'\n      }, {\n        source: '0',\n        target: '14'\n      }, {\n        source: '0',\n        target: '15'\n      }, {\n        source: '0',\n        target: '16'\n      }, {\n        source: '2',\n        target: '3'\n      }, {\n        source: '4',\n        target: '5'\n      }, {\n        source: '4',\n        target: '6'\n      }, {\n        source: '5',\n        target: '6'\n      }, {\n        source: '7',\n        target: '13'\n      }, {\n        source: '8',\n        target: '14'\n      }, {\n        source: '9',\n        target: '10'\n      }, {\n        source: '10',\n        target: '22'\n      }, {\n        source: '10',\n        target: '14'\n      }, {\n        source: '10',\n        target: '12'\n      }, {\n        source: '10',\n        target: '24'\n      }, {\n        source: '10',\n        target: '21'\n      }, {\n        source: '10',\n        target: '20'\n      }, {\n        source: '11',\n        target: '24'\n      }, {\n        source: '11',\n        target: '22'\n      }, {\n        source: '11',\n        target: '14'\n      }, {\n        source: '12',\n        target: '13'\n      }, {\n        source: '16',\n        target: '17'\n      }, {\n        source: '16',\n        target: '18'\n      }, {\n        source: '16',\n        target: '21'\n      }, {\n        source: '16',\n        target: '22'\n      }, {\n        source: '17',\n        target: '18'\n      }, {\n        source: '17',\n        target: '20'\n      }, {\n        source: '18',\n        target: '19'\n      }, {\n        source: '19',\n        target: '20'\n      }, {\n        source: '19',\n        target: '33'\n      }, {\n        source: '19',\n        target: '22'\n      }, {\n        source: '19',\n        target: '23'\n      }, {\n        source: '20',\n        target: '21'\n      }, {\n        source: '21',\n        target: '22'\n      }, {\n        source: '22',\n        target: '24'\n      }, {\n        source: '22',\n        target: '25'\n      }, {\n        source: '22',\n        target: '26'\n      }, {\n        source: '22',\n        target: '23'\n      }, {\n        source: '22',\n        target: '28'\n      }, {\n        source: '22',\n        target: '30'\n      }, {\n        source: '22',\n        target: '31'\n      }, {\n        source: '22',\n        target: '32'\n      }, {\n        source: '22',\n        target: '33'\n      }, {\n        source: '23',\n        target: '28'\n      }, {\n        source: '23',\n        target: '27'\n      }, {\n        source: '23',\n        target: '29'\n      }, {\n        source: '23',\n        target: '30'\n      }, {\n        source: '23',\n        target: '31'\n      }, {\n        source: '23',\n        target: '33'\n      }, {\n        source: '32',\n        target: '33'\n      }]\n    };\n    const width = 500;\n    const height = 500;\n    const graph = new G6.Graph({\n      container: 'container',\n      width,\n      height,\n      modes: {\n        default: ['activate-relations', 'drag-canvas', 'drag-node']\n      },\n      layout: {\n        type: 'circular'\n      },\n      nodeStateStyles: {\n        active: {\n          stroke: 'red'\n        }\n      },\n      edgeStateStyles: {\n        active: {\n          stroke: '#000',\n          opacity: 1\n        },\n        inactive: {\n          color: '#969696',\n          opacity: 0.5\n        }\n      },\n      animate: true,\n      defaultNode: {\n        size: 20,\n        style: {\n          lineWidth: 2,\n          fill: 'rgb(239, 244, 255)',\n          stroke: 'rgb(95, 149, 255)'\n        }\n      },\n      defaultEdge: {\n        size: 1,\n        color: 'rgb(150, 150, 150)',\n        style: {\n          endArrow: {\n            path: 'M 0,0 L 8,4 L 8,-4 Z',\n            fill: 'rgb(150, 150, 150)'\n          }\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    const node1 = graph.findById('1');\n    graph.setItemState(node1, 'active', true);\n    const edge1 = graph.getEdges()[0];\n    graph.setItemState(edge1, 'active', true);\n    expect(graph.findAllByState('node', 'active').length).toBe(1);\n    expect(graph.findAllByState('edge', 'active').length).toBe(1);\n    graph.changeData(data);\n    expect(graph.findAllByState('node', 'active').length).toBe(0);\n    expect(graph.findAllByState('edge', 'active').length).toBe(0);\n    graph.destroy();\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "label",
            "suites": [
                "defaultStyle states"
            ],
            "updatePoint": {
                "line": 623,
                "column": 11,
                "index": 12313
            },
            "line": 623,
            "code": "  it('label', () => {\n    const data = {\n      nodes: [{\n        id: 'node1',\n        label: 'node1',\n        x: 100,\n        y: 100\n      }]\n    };\n    const graph = new G6.Graph({\n      container: 'container',\n      width: 500,\n      height: 500,\n      defaultEdge: {\n        color: 'rgb(150, 150, 150)',\n        lineAppendWidth: 3\n      },\n      defaultNode: {\n        style: {\n          fill: '#DEE9FF',\n          stroke: 'rgb(95, 149, 255)'\n        }\n      },\n      nodeStateStyles: {\n        hover: {\n          lineWidth: 5,\n          fillOpacity: 1,\n          'text-shape': {\n            fontSize: 20,\n            fill: '#003a8c'\n          }\n        }\n      },\n      edgeStateStyles: {\n        hover: {\n          lineWidth: 3\n        }\n      }\n    });\n    graph.data(data);\n    graph.render();\n    graph.on('node:mouseenter', function (evt) {\n      const node = evt.item;\n      const model = node.getModel();\n      model.oriLabel = model.label;\n      graph.setItemState(node, 'hover', true);\n      graph.updateItem(node, {\n        label: 'hover 后 ' + model.id,\n        labelCfg: {\n          style: {\n            fill: 'blue'\n          }\n        }\n      });\n    });\n    graph.on('node:mouseleave', function (evt) {\n      const node = evt.item;\n      const model = node.getModel();\n      graph.setItemState(node, 'hover', false);\n      graph.updateItem(node, {\n        label: model.oriLabel,\n        style: {\n          'text-shape': {\n            fill: 'red'\n          }\n        },\n        labelCfg: {\n          style: {\n            fill: 'red'\n          }\n        }\n      });\n    });\n    graph.on('edge:mouseenter', function (evt) {\n      const edge = evt.item;\n      const model = edge.getModel();\n      model.oriLabel = model.label;\n      graph.setItemState(edge, 'hover', true);\n      graph.updateItem(edge, {\n        label: 'hover 后',\n        labelCfg: {\n          style: {\n            fill: '#003a8c'\n          }\n        }\n      });\n    });\n    graph.on('edge:mouseleave', function (evt) {\n      const edge = evt.item;\n      graph.setItemState(edge, 'hover', false);\n      graph.updateItem(edge, {\n        label: 'hover 前的边文本',\n        labelCfg: {\n          style: {\n            fill: '#555'\n          }\n        }\n      });\n    }); // graph.destroy()\n  });",
            "file": "unit/issues-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        },
        {
            "name": "div content",
            "suites": [
                "template"
            ],
            "updatePoint": {
                "line": 6,
                "column": 17,
                "index": 195
            },
            "line": 6,
            "code": "  it('div content', () => {\n    expect(document.querySelector('#test-div-id').innerHTML).toBe('hello g6');\n  });",
            "file": "unit/template-spec.ts",
            "skipped": false,
            "dir": "packages/element/tests"
        }
    ],
    "error": "Exclusive tests detected. `.only` call found in unit/combo-issue-spec.ts:284\nRemove `.only` to restore test checks"
}