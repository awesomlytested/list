{"repo":"directus/directus","url":"https://github.com/directus/directus","branch":"main","configs":[{"package":"directus-monorepo","lang":"js","dir":"tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@directus/drive-azure","lang":"ts","dir":"packages/drive-azure/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@directus/drive-gcs","lang":"ts","dir":"packages/drive-gcs/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@directus/drive-s3","lang":"ts","dir":"packages/drive-s3/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@directus/drive","lang":"ts","dir":"packages/drive/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"@directus/sdk","lang":"ts","dir":"packages/sdk/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"%s","suites":["Common","createRole()","Creates default admin role"],"line":10,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const roleName = common.ROLE.ADMIN.NAME;\n        const options = {\n          name: roleName,\n          appAccessEnabled: true,\n          adminAccessEnabled: true\n        };\n\n        // Action\n        await common.CreateRole(vendor, options);\n\n        // Assert\n        const response = await request(getUrl(vendor)).get(`/roles`).query({\n          filter: {\n            name: {\n              _eq: roleName\n            }\n          },\n          fields: ['id', 'name', 'app_access', 'admin_access'],\n          limit: 1\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          name: roleName,\n          app_access: true,\n          admin_access: true\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createRole()","Creates default app access role"],"line":41,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const roleName = common.ROLE.APP_ACCESS.NAME;\n        const options = {\n          name: roleName,\n          appAccessEnabled: true,\n          adminAccessEnabled: false\n        };\n\n        // Action\n        await common.CreateRole(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/roles`).query({\n          filter: {\n            name: {\n              _eq: roleName\n            }\n          },\n          fields: ['id', 'name', 'app_access', 'admin_access'],\n          limit: 1\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          name: roleName,\n          app_access: true,\n          admin_access: false\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createRole()","Creates default API only role"],"line":72,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const roleName = common.ROLE.API_ONLY.NAME;\n        const options = {\n          name: roleName,\n          appAccessEnabled: false,\n          adminAccessEnabled: false\n        };\n\n        // Action\n        await common.CreateRole(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/roles`).query({\n          filter: {\n            name: {\n              _eq: roleName\n            }\n          },\n          fields: ['id', 'name', 'app_access', 'admin_access'],\n          limit: 1\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          name: roleName,\n          app_access: false,\n          admin_access: false\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createUser()","Creates default admin user"],"line":105,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const token = common.USER.ADMIN.TOKEN;\n        const email = common.USER.ADMIN.EMAIL;\n        const password = common.USER.ADMIN.PASSWORD;\n        const name = common.USER.ADMIN.NAME;\n        const roleName = common.ROLE.ADMIN.NAME;\n        const options = {\n          token,\n          email,\n          password,\n          name,\n          roleName\n        };\n\n        // Action\n        await common.CreateUser(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/users`).query({\n          filter: {\n            email: {\n              _eq: email\n            }\n          },\n          fields: ['id', 'email', 'token', 'role']\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          email: email,\n          token: expect.any(String),\n          role: expect.any(String)\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createUser()","Creates default app access user"],"line":141,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const token = common.USER.APP_ACCESS.TOKEN;\n        const email = common.USER.APP_ACCESS.EMAIL;\n        const password = common.USER.APP_ACCESS.PASSWORD;\n        const name = common.USER.APP_ACCESS.NAME;\n        const roleName = common.ROLE.APP_ACCESS.NAME;\n        const options = {\n          token,\n          email,\n          password,\n          name,\n          roleName\n        };\n\n        // Action\n        await common.CreateUser(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/users`).query({\n          filter: {\n            email: {\n              _eq: email\n            }\n          },\n          fields: ['id', 'email', 'token', 'role']\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          email: email,\n          token: expect.any(String),\n          role: expect.any(String)\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createUser()","Creates default API only user"],"line":177,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const token = common.USER.API_ONLY.TOKEN;\n        const email = common.USER.API_ONLY.EMAIL;\n        const password = common.USER.API_ONLY.PASSWORD;\n        const name = common.USER.API_ONLY.NAME;\n        const roleName = common.ROLE.API_ONLY.NAME;\n        const options = {\n          token,\n          email,\n          password,\n          name,\n          roleName\n        };\n\n        // Action\n        await common.CreateUser(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/users`).query({\n          filter: {\n            email: {\n              _eq: email\n            }\n          },\n          fields: ['id', 'email', 'token', 'role']\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          email: email,\n          token: expect.any(String),\n          role: expect.any(String)\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createUser()","Creates default no-role user"],"line":213,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const token = common.USER.NO_ROLE.TOKEN;\n        const email = common.USER.NO_ROLE.EMAIL;\n        const password = common.USER.NO_ROLE.PASSWORD;\n        const name = common.USER.NO_ROLE.NAME;\n        const options = {\n          token,\n          email,\n          password,\n          name\n        };\n\n        // Action\n        await common.CreateUser(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/users`).query({\n          filter: {\n            email: {\n              _eq: email\n            }\n          },\n          fields: ['id', 'email', 'token', 'role']\n        }).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual([{\n          id: expect.any(String),\n          email: email,\n          token: expect.any(String),\n          role: null\n        }]);\n      });","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createCollection()","Creates a new collection"],"line":249,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const options = {\n          collection: collectionName\n        };\n        const options2 = {\n          collection: collectionNameM2O\n        };\n        const options3 = {\n          collection: collectionNameO2M\n        };\n\n        // Action\n        await common.CreateCollection(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/collections/${collectionName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n        await common.CreateCollection(vendor, options2);\n        const response2 = await request(getUrl(vendor)).get(`/collections/${collectionNameM2O}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n        await common.CreateCollection(vendor, options3);\n        const response3 = await request(getUrl(vendor)).get(`/collections/${collectionNameO2M}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual({\n          collection: collectionName,\n          meta: expect.objectContaining({\n            collection: collectionName\n          }),\n          schema: expect.objectContaining({\n            name: collectionName\n          })\n        });\n        expect(response2.body.data).toEqual({\n          collection: collectionNameM2O,\n          meta: expect.objectContaining({\n            collection: collectionNameM2O\n          }),\n          schema: expect.objectContaining({\n            name: collectionNameM2O\n          })\n        });\n        expect(response3.body.data).toEqual({\n          collection: collectionNameO2M,\n          meta: expect.objectContaining({\n            collection: collectionNameO2M\n          }),\n          schema: expect.objectContaining({\n            name: collectionNameO2M\n          })\n        });\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createField()","Creates a new field"],"line":302,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'sample_field';\n        const fieldType = 'string';\n        const options = {\n          collection: collectionName,\n          field: fieldName,\n          type: fieldType\n        };\n\n        // Action\n        await common.CreateField(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}/${fieldName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual({\n          collection: collectionName,\n          field: fieldName,\n          type: fieldType,\n          meta: expect.anything(),\n          schema: expect.anything()\n        });\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createFieldM2O()","Creates a new M2O field"],"line":329,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'm2o_field';\n        const primaryKeyType = 'integer';\n        const collectionOptions = {\n          collection: collectionNameM2O,\n          primaryKeyType\n        };\n        await common.CreateCollection(vendor, collectionOptions);\n        const options = {\n          collection: collectionName,\n          field: fieldName,\n          otherCollection: collectionNameM2O,\n          primaryKeyType: primaryKeyType\n        };\n\n        // Action\n        await common.CreateFieldM2O(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}/${fieldName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual({\n          collection: collectionName,\n          field: fieldName,\n          type: primaryKeyType,\n          meta: expect.objectContaining({\n            special: expect.arrayContaining(['m2o'])\n          }),\n          schema: expect.anything()\n        });\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createFieldO2M()","Creates a new O2M field"],"line":364,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'o2m_field';\n        const otherFieldName = 'm2o_field';\n        const primaryKeyType = 'integer';\n        const collectionOptions = {\n          collection: collectionNameO2M,\n          primaryKeyType\n        };\n        await common.CreateCollection(vendor, collectionOptions);\n        const options = {\n          collection: collectionName,\n          field: fieldName,\n          otherField: otherFieldName,\n          otherCollection: collectionNameO2M,\n          primaryKeyType: primaryKeyType\n        };\n\n        // Action\n        await common.CreateFieldO2M(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}/${fieldName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual({\n          collection: collectionName,\n          field: fieldName,\n          type: 'alias',\n          meta: expect.anything(),\n          schema: null\n        });\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createItem()","Creates a new item"],"line":399,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const options = {\n          collection: collectionName,\n          item: {\n            sample_field: 'sample_value'\n          }\n        };\n\n        // Action\n        const createdItem = await common.CreateItem(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/items/${collectionName}/${createdItem.id}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual(expect.objectContaining({\n          id: createdItem.id,\n          sample_field: 'sample_value'\n        }));\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createItem()","Creates a new M2O item"],"line":420,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const options = {\n          collection: collectionName,\n          item: {\n            sample_field: 'sample_value',\n            m2o_field: {}\n          }\n        };\n\n        // Action\n        const createdItem = await common.CreateItem(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/items/${collectionName}/${createdItem.id}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual(expect.objectContaining({\n          id: createdItem.id,\n          sample_field: 'sample_value',\n          m2o_field: expect.any(Number)\n        }));\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","createItem()","Creates a new O2M item"],"line":443,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const options = {\n          collection: collectionName,\n          item: {\n            sample_field: 'sample_value',\n            o2m_field: {\n              create: [{}],\n              update: [],\n              delete: []\n            }\n          }\n        };\n\n        // Action\n        const createdItem = await common.CreateItem(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/items/${collectionName}/${createdItem.id}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        expect(response.body.data).toEqual(expect.objectContaining({\n          id: createdItem.id,\n          sample_field: 'sample_value',\n          o2m_field: [expect.any(Number)]\n        }));\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","deleteField()","Deletes an O2M field"],"line":472,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'o2m_field';\n        const options = {\n          collection: collectionName,\n          field: fieldName\n        };\n\n        // Action\n        await common.DeleteField(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        for (const child of response.body.data) {\n          expect(child.field).not.toEqual(fieldName);\n        }\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","deleteField()","Deletes other M2O field"],"line":491,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'm2o_field';\n        const options = {\n          collection: collectionNameO2M,\n          field: fieldName\n        };\n\n        // Action\n        await common.DeleteField(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionNameO2M}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        for (const child of response.body.data) {\n          expect(child.field).not.toEqual(fieldName);\n        }\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","deleteField()","Deletes an M2O field"],"line":510,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'm2o_field';\n        const options = {\n          collection: collectionName,\n          field: fieldName\n        };\n\n        // Action\n        await common.DeleteField(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        for (const child of response.body.data) {\n          expect(child.field).not.toEqual(fieldName);\n        }\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","deleteField()","Deletes a field"],"line":529,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const fieldName = 'sample_field';\n        const options = {\n          collection: collectionName,\n          field: fieldName\n        };\n\n        // Action\n        await common.DeleteField(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/fields/${collectionName}`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        for (const child of response.body.data) {\n          expect(child.field).not.toEqual(fieldName);\n        }\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Common","deleteCollection()","Deletes a collection"],"line":550,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const options = {\n          collection: collectionName\n        };\n\n        // Action\n        await common.DeleteCollection(vendor, options);\n        const response = await request(getUrl(vendor)).get(`/collections`).set('Authorization', `Bearer ${common.USER.TESTS_FLOW.TOKEN}`).expect('Content-Type', /application\\/json/).expect(200);\n\n        // Assert\n        for (const child of response.body.data) {\n          expect(child.collection).not.toEqual(collectionName);\n        }\n      }, 30000);","file":"blackbox/common/common.test.ts","skipped":false,"dir":"tests"},{"name":"No seed files found","suites":["Seed Database Structure"],"updatePoint":{"line":10,"column":29,"index":333},"line":10,"code":"    test('No seed files found', () => {\n      expect(true).toBe(true);\n    });","file":"blackbox/common/seed-database.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id","Concurrent file requests"],"line":15,"code":"      describe.each(storages)('Storage: %s', storage => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const spawnCountTarget = 5;\n          let spawnCount = 0;\n          let hasErrors = false;\n          let isSpawnRunning = false;\n          const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n          // Action\n          spawnAutoCannon();\n          function spawnAutoCannon() {\n            const url = `${getUrl(vendor)}/assets/${insertResponse.body.data.id}?access_token=${common.USER.ADMIN.TOKEN}`;\n            const options = ['exec', 'autocannon', '-c', '100', url];\n            const child = spawn('pnpm', options);\n            isSpawnRunning = true;\n            child.stderr.on('data', data => {\n              if (String(data).includes('errors')) {\n                hasErrors = true;\n              }\n            });\n            child.on('close', () => {\n              spawnCount++;\n              if (spawnCount < spawnCountTarget && !hasErrors) {\n                spawnAutoCannon();\n              } else {\n                isSpawnRunning = false;\n              }\n            });\n          }\n          while (isSpawnRunning) {\n            await sleep(1000 * spawnCountTarget);\n          }\n\n          // Assert\n          expect(hasErrors).toBe(false);\n        }, 600000);\n      });","file":"blackbox/routes/assets/concurrency.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id","Concurrent file requests"],"line":16,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const spawnCountTarget = 5;\n          let spawnCount = 0;\n          let hasErrors = false;\n          let isSpawnRunning = false;\n          const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n          // Action\n          spawnAutoCannon();\n          function spawnAutoCannon() {\n            const url = `${getUrl(vendor)}/assets/${insertResponse.body.data.id}?access_token=${common.USER.ADMIN.TOKEN}`;\n            const options = ['exec', 'autocannon', '-c', '100', url];\n            const child = spawn('pnpm', options);\n            isSpawnRunning = true;\n            child.stderr.on('data', data => {\n              if (String(data).includes('errors')) {\n                hasErrors = true;\n              }\n            });\n            child.on('close', () => {\n              spawnCount++;\n              if (spawnCount < spawnCountTarget && !hasErrors) {\n                spawnAutoCannon();\n              } else {\n                isSpawnRunning = false;\n              }\n            });\n          }\n          while (isSpawnRunning) {\n            await sleep(1000 * spawnCountTarget);\n          }\n\n          // Assert\n          expect(hasErrors).toBe(false);\n        }, 600000);","file":"blackbox/routes/assets/concurrency.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id","format=auto Tests","without Accept request header"],"line":19,"code":"        describe.each(storages)('Storage: %s', storage => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n            // Action\n            const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}?format=auto`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.headers['content-type']).toBe('image/jpeg'); // Expect fallback to jpg as default\n          });\n        });","file":"blackbox/routes/assets/format.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id","format=auto Tests","without Accept request header"],"line":20,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n            // Action\n            const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}?format=auto`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.headers['content-type']).toBe('image/jpeg'); // Expect fallback to jpg as default\n          });","file":"blackbox/routes/assets/format.test.ts","skipped":false,"dir":"tests"},{"name":"with \"$requestHeaderAccept\" Accept request header","suites":["/assets","GET /assets/:id","format=auto Tests","without Accept request header"],"line":34,"code":"      describe.each([{\n        requestHeaderAccept: 'image/avif,image/webp,image/*,*/*;q=0.8',\n        responseHeaderContentType: 'image/avif'\n      }, {\n        requestHeaderAccept: 'image/avif',\n        responseHeaderContentType: 'image/avif'\n      }, {\n        requestHeaderAccept: 'image/webp',\n        responseHeaderContentType: 'image/webp'\n      }, {\n        requestHeaderAccept: '*/*',\n        responseHeaderContentType: 'image/jpeg'\n      }])('with \"$requestHeaderAccept\" Accept request header', ({\n        requestHeaderAccept,\n        responseHeaderContentType\n      }) => {\n        describe.each(storages)('Storage: %s', storage => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n            // Action\n            const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}?format=auto`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).set('Accept', requestHeaderAccept);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.headers['content-type']).toBe(responseHeaderContentType);\n          });\n        });\n      });","file":"blackbox/routes/assets/format.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id","format=auto Tests","without Accept request header"],"line":50,"code":"        describe.each(storages)('Storage: %s', storage => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n            // Action\n            const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}?format=auto`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).set('Accept', requestHeaderAccept);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.headers['content-type']).toBe(responseHeaderContentType);\n          });\n        });","file":"blackbox/routes/assets/format.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id","format=auto Tests","without Accept request header"],"line":51,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n            // Action\n            const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}?format=auto`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).set('Accept', requestHeaderAccept);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.headers['content-type']).toBe(responseHeaderContentType);\n          });","file":"blackbox/routes/assets/format.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id","ASSETS_TRANSFORM_MAX_CONCURRENT Tests","passes when below limit"],"line":19,"code":"        describe.each(storages)('Storage: %s', storage => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].ASSETS_TRANSFORM_MAX_CONCURRENT);\n            const uploadedFileID = (await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath))).body.data.id;\n\n            // Action\n            const responses = await Promise.all(Array(count).fill(0).map((_, index) => request(getUrl(vendor)).get(`/assets/${uploadedFileID}?width=${4000 + index}&height=${4000 + index}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)));\n\n            // Assert\n            for (const response of responses) {\n              expect(response.statusCode).toBe(200);\n            }\n          }, 60000);\n        });","file":"blackbox/routes/assets/limit.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id","ASSETS_TRANSFORM_MAX_CONCURRENT Tests","passes when below limit"],"line":20,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].ASSETS_TRANSFORM_MAX_CONCURRENT);\n            const uploadedFileID = (await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath))).body.data.id;\n\n            // Action\n            const responses = await Promise.all(Array(count).fill(0).map((_, index) => request(getUrl(vendor)).get(`/assets/${uploadedFileID}?width=${4000 + index}&height=${4000 + index}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)));\n\n            // Assert\n            for (const response of responses) {\n              expect(response.statusCode).toBe(200);\n            }\n          }, 60000);","file":"blackbox/routes/assets/limit.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id","ASSETS_TRANSFORM_MAX_CONCURRENT Tests","errors when above limit"],"line":36,"code":"        describe.each(storages)('Storage: %s', storage => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const attempts = 100;\n            const uploadedFileID = (await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath))).body.data.id;\n\n            // Action\n            const responses = await Promise.all(Array(attempts).fill(0).map((_, index) => request(getUrl(vendor)).get(`/assets/${uploadedFileID}?width=${4000 + index}&height=${4000 + index}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)));\n\n            // Assert\n            const unavailableCount = responses.filter(response => response.statusCode === 503).length;\n            expect(unavailableCount).toBeGreaterThanOrEqual(1);\n            expect(responses.filter(response => response.statusCode === 200).length).toBe(attempts - unavailableCount);\n          }, 1200000);\n        });","file":"blackbox/routes/assets/limit.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id","ASSETS_TRANSFORM_MAX_CONCURRENT Tests","errors when above limit"],"line":37,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const attempts = 100;\n            const uploadedFileID = (await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath))).body.data.id;\n\n            // Action\n            const responses = await Promise.all(Array(attempts).fill(0).map((_, index) => request(getUrl(vendor)).get(`/assets/${uploadedFileID}?width=${4000 + index}&height=${4000 + index}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)));\n\n            // Assert\n            const unavailableCount = responses.filter(response => response.statusCode === 503).length;\n            expect(unavailableCount).toBeGreaterThanOrEqual(1);\n            expect(responses.filter(response => response.statusCode === 200).length).toBe(attempts - unavailableCount);\n          }, 1200000);","file":"blackbox/routes/assets/limit.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/assets","GET /assets/:id"],"line":17,"code":"    describe.each(storages)('Storage: %s', storage => {\n      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n        // Action\n        const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.headers['content-type']).toBe(imageFile.type);\n        expect(response.headers['content-length']).toBe(imageFile.filesize);\n        expect(Buffer.compare(response.body, await readFileSync(imageFilePath))).toBe(0);\n      });\n    });","file":"blackbox/routes/assets/read.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/assets","GET /assets/:id"],"line":18,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n        // Action\n        const response = await request(getUrl(vendor)).get(`/assets/${insertResponse.body.data.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.headers['content-type']).toBe(imageFile.type);\n        expect(response.headers['content-length']).toBe(imageFile.filesize);\n        expect(Buffer.compare(response.body, await readFileSync(imageFilePath))).toBe(0);\n      });","file":"blackbox/routes/assets/read.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth","POST /login","when correct credentials are provided","returns an access_token, expires and a refresh_token"],"line":12,"code":"            it.each(vendors)('%s', async vendor => {\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/);\n              const mutationKey = 'auth_login';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.statusCode).toBe(200);\n              expect(response.body).toMatchObject({\n                data: {\n                  access_token: expect.any(String),\n                  expires: expect.any(Number),\n                  refresh_token: expect.any(String)\n                }\n              });\n              expect(gqlResponse.statusCode).toBe(200);\n              expect(gqlResponse.body).toMatchObject({\n                data: {\n                  [mutationKey]: {\n                    access_token: expect.any(String),\n                    expires: expect.any(String),\n                    refresh_token: expect.any(String)\n                  }\n                }\n              });\n            });","file":"blackbox/routes/auth/login.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth","POST /login","when incorrect credentials are provided","returns code: UNAUTHORIZED for incorrect password"],"line":61,"code":"            it.each(vendors)('%s', async vendor => {\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD + 'typo'\n              }).expect('Content-Type', /application\\/json/).expect(401);\n              const mutationKey = 'auth_login';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD + 'typo'\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.body).toMatchObject({\n                errors: [{\n                  message: 'Invalid user credentials.',\n                  extensions: {\n                    code: 'INVALID_CREDENTIALS'\n                  }\n                }]\n              });\n              expect(gqlResponse.body).toMatchObject({\n                errors: [{\n                  message: 'Invalid user credentials.',\n                  extensions: {\n                    code: 'INVALID_CREDENTIALS'\n                  }\n                }]\n              });\n            });","file":"blackbox/routes/auth/login.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth","POST /login","when incorrect credentials are provided","returns code: UNAUTHORIZED for unregistered email"],"line":106,"code":"            it.each(vendors)('%s', async vendor => {\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: 'test@fake.com',\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/).expect(401);\n              const mutationKey = 'auth_login';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      email: 'test@fake.com',\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.body).toMatchObject({\n                errors: [{\n                  message: 'Invalid user credentials.',\n                  extensions: {\n                    code: 'INVALID_CREDENTIALS'\n                  }\n                }]\n              });\n              expect(gqlResponse.body).toMatchObject({\n                errors: [{\n                  message: 'Invalid user credentials.',\n                  extensions: {\n                    code: 'INVALID_CREDENTIALS'\n                  }\n                }]\n              });\n            });","file":"blackbox/routes/auth/login.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth","POST /login","when incorrect credentials are provided","returns code: INVALID_CREDENTIALS for invalid email"],"line":151,"code":"            it.each(vendors)('%s', async vendor => {\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: 'invalidEmail',\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/).expect(400);\n              const mutationKey = 'auth_login';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      email: 'invalidEmail',\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.body).toMatchObject({\n                errors: [{\n                  message: '\"email\" must be a valid email',\n                  extensions: {\n                    code: 'INVALID_PAYLOAD'\n                  }\n                }]\n              });\n              expect(gqlResponse.body).toMatchObject({\n                errors: [{\n                  message: 'Invalid user credentials.',\n                  extensions: {\n                    code: 'INVALID_CREDENTIALS'\n                  }\n                }]\n              });\n            });","file":"blackbox/routes/auth/login.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth","POST /login","when incorrect credentials are provided","returns message: \"password is required\" when no password is provided"],"line":196,"code":"            it.each(vendors)('%s', async vendor => {\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL\n              }).expect('Content-Type', /application\\/json/).expect(400);\n              const mutationKey = 'auth_login';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      email: 'invalidEmail'\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.body).toMatchObject({\n                errors: [{\n                  message: '\"password\" is required',\n                  extensions: {\n                    code: 'INVALID_PAYLOAD'\n                  }\n                }]\n              });\n              expect(gqlResponse.body).toMatchObject({\n                errors: [{\n                  message: 'GraphQL validation error.',\n                  extensions: {\n                    code: 'GRAPHQL_VALIDATION_EXCEPTION'\n                  }\n                }]\n              });\n            });","file":"blackbox/routes/auth/login.test.ts","skipped":false,"dir":"tests"},{"name":"for %s mode","suites":["Authentication Refresh Tests","POST /refresh","refreshes with refresh_token in the body"],"line":11,"code":"      describe.each(authModes)('for %s mode', mode => {\n        common.TEST_USERS.forEach(userKey => {\n          describe(common.USER[userKey].NAME, () => {\n            it.each(vendors)('%s', async vendor => {\n              // Setup\n              const refreshToken = (await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/)).body.data.refresh_token;\n              const refreshToken2 = (await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  auth_login: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    refresh_token: true\n                  }\n                }\n              })).body.data.auth_login.refresh_token;\n\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/refresh`).send({\n                refresh_token: refreshToken,\n                mode\n              }).expect('Content-Type', /application\\/json/);\n              const mutationKey = 'auth_refresh';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      refresh_token: refreshToken2,\n                      mode: new EnumType(mode)\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.statusCode).toBe(200);\n              if (mode === 'cookie') {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number)\n                  }\n                });\n              } else {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number),\n                    refresh_token: expect.any(String)\n                  }\n                });\n              }\n              expect(gqlResponse.statusCode).toBe(200);\n              expect(gqlResponse.body).toMatchObject({\n                data: {\n                  [mutationKey]: {\n                    access_token: expect.any(String),\n                    expires: expect.any(String),\n                    refresh_token: expect.any(String)\n                  }\n                }\n              });\n            });\n          });\n        });\n      });","file":"blackbox/routes/auth/refresh.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Authentication Refresh Tests","POST /refresh","refreshes with refresh_token in the body"],"line":14,"code":"            it.each(vendors)('%s', async vendor => {\n              // Setup\n              const refreshToken = (await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/)).body.data.refresh_token;\n              const refreshToken2 = (await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  auth_login: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    refresh_token: true\n                  }\n                }\n              })).body.data.auth_login.refresh_token;\n\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/refresh`).send({\n                refresh_token: refreshToken,\n                mode\n              }).expect('Content-Type', /application\\/json/);\n              const mutationKey = 'auth_refresh';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      refresh_token: refreshToken2,\n                      mode: new EnumType(mode)\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              });\n\n              // Assert\n              expect(response.statusCode).toBe(200);\n              if (mode === 'cookie') {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number)\n                  }\n                });\n              } else {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number),\n                    refresh_token: expect.any(String)\n                  }\n                });\n              }\n              expect(gqlResponse.statusCode).toBe(200);\n              expect(gqlResponse.body).toMatchObject({\n                data: {\n                  [mutationKey]: {\n                    access_token: expect.any(String),\n                    expires: expect.any(String),\n                    refresh_token: expect.any(String)\n                  }\n                }\n              });\n            });","file":"blackbox/routes/auth/refresh.test.ts","skipped":false,"dir":"tests"},{"name":"for %s mode","suites":["Authentication Refresh Tests","POST /refresh","refreshes with refresh_token in the cookie"],"line":86,"code":"      describe.each(authModes)('for %s mode', mode => {\n        common.TEST_USERS.forEach(userKey => {\n          describe(common.USER[userKey].NAME, () => {\n            it.each(vendors)('%s', async vendor => {\n              // Setup\n              const cookieName = 'directus_refresh_token';\n              const refreshToken = (await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/)).body.data.refresh_token;\n              const refreshToken2 = (await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  auth_login: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    refresh_token: true\n                  }\n                }\n              })).body.data.auth_login.refresh_token;\n\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/refresh`).set('Cookie', `${cookieName}=${refreshToken}`).send({\n                mode\n              }).expect('Content-Type', /application\\/json/);\n              const mutationKey = 'auth_refresh';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      refresh_token: refreshToken2,\n                      mode: new EnumType(mode)\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              }, {\n                cookies: [`${cookieName}=${refreshToken2}`]\n              });\n\n              // Assert\n              expect(response.statusCode).toBe(200);\n              if (mode === 'cookie') {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number)\n                  }\n                });\n              } else {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number),\n                    refresh_token: expect.any(String)\n                  }\n                });\n              }\n              expect(gqlResponse.statusCode).toBe(200);\n              expect(gqlResponse.body).toMatchObject({\n                data: {\n                  [mutationKey]: {\n                    access_token: expect.any(String),\n                    expires: expect.any(String),\n                    refresh_token: expect.any(String)\n                  }\n                }\n              });\n            });\n          });\n        });\n      });","file":"blackbox/routes/auth/refresh.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Authentication Refresh Tests","POST /refresh","refreshes with refresh_token in the cookie"],"line":89,"code":"            it.each(vendors)('%s', async vendor => {\n              // Setup\n              const cookieName = 'directus_refresh_token';\n              const refreshToken = (await request(getUrl(vendor)).post(`/auth/login`).send({\n                email: common.USER[userKey].EMAIL,\n                password: common.USER[userKey].PASSWORD\n              }).expect('Content-Type', /application\\/json/)).body.data.refresh_token;\n              const refreshToken2 = (await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  auth_login: {\n                    __args: {\n                      email: common.USER[userKey].EMAIL,\n                      password: common.USER[userKey].PASSWORD\n                    },\n                    refresh_token: true\n                  }\n                }\n              })).body.data.auth_login.refresh_token;\n\n              // Action\n              const response = await request(getUrl(vendor)).post(`/auth/refresh`).set('Cookie', `${cookieName}=${refreshToken}`).send({\n                mode\n              }).expect('Content-Type', /application\\/json/);\n              const mutationKey = 'auth_refresh';\n              const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n                mutation: {\n                  [mutationKey]: {\n                    __args: {\n                      refresh_token: refreshToken2,\n                      mode: new EnumType(mode)\n                    },\n                    access_token: true,\n                    expires: true,\n                    refresh_token: true\n                  }\n                }\n              }, {\n                cookies: [`${cookieName}=${refreshToken2}`]\n              });\n\n              // Assert\n              expect(response.statusCode).toBe(200);\n              if (mode === 'cookie') {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number)\n                  }\n                });\n              } else {\n                expect(response.body).toMatchObject({\n                  data: {\n                    access_token: expect.any(String),\n                    expires: expect.any(Number),\n                    refresh_token: expect.any(String)\n                  }\n                });\n              }\n              expect(gqlResponse.statusCode).toBe(200);\n              expect(gqlResponse.body).toMatchObject({\n                data: {\n                  [mutationKey]: {\n                    access_token: expect.any(String),\n                    expires: expect.any(String),\n                    refresh_token: expect.any(String)\n                  }\n                }\n              });\n            });","file":"blackbox/routes/auth/refresh.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth/login/saml","GET /","when incorrect credential is provided","returns no authenticated cookie"],"line":9,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const loginPage = await request('http://127.0.0.1:8880').get(`/simplesaml/module.php/core/authenticate.php?as=example-userpass`).expect(302);\n          const cookies = loginPage.headers['set-cookie'].map(cookie => cookie.split(';')[0]).join(';');\n          const AuthState = decodeURIComponent(String(loginPage.headers.location)).split('AuthState=')[1];\n          const response = await request('http://127.0.0.1:8880').post(`/simplesaml/module.php/core/loginuserpass.php?`).set('Cookie', cookies).set('Content-Type', 'application/x-www-form-urlencoded').send({\n            username: 'user1',\n            password: 'user2pass',\n            AuthState\n          }).expect(200);\n          authCookies[vendor] = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]).join(';');\n\n          // Assert\n          expect(authCookies[vendor]).toMatch(/PHPSESSIDIDP/);\n          expect(authCookies[vendor]).not.toMatch(/SimpleSAMLAuthTokenIdp/);\n        });","file":"blackbox/routes/auth/saml.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth/login/saml","GET /","when correct credential is provided","returns authenticated cookie"],"line":29,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const loginPage = await request('http://127.0.0.1:8880').get(`/simplesaml/module.php/core/authenticate.php?as=example-userpass`).expect(302);\n          const cookies = loginPage.headers['set-cookie'].map(cookie => cookie.split(';')[0]).join(';');\n          const AuthState = decodeURIComponent(String(loginPage.headers.location)).split('AuthState=')[1];\n          const response = await request('http://127.0.0.1:8880').post(`/simplesaml/module.php/core/loginuserpass.php?`).set('Cookie', cookies).set('Content-Type', 'application/x-www-form-urlencoded').send({\n            username: 'user1',\n            password: 'user1pass',\n            AuthState\n          }).expect(303);\n          authCookies[vendor] = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]).join(';');\n\n          // Assert\n          expect(authCookies[vendor]).toMatch(/PHPSESSIDIDP/);\n          expect(authCookies[vendor]).toMatch(/SimpleSAMLAuthTokenIdp/);\n        });","file":"blackbox/routes/auth/saml.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth/login/saml","POST /acs","when no redirect is provided","returns directus refresh token in JSON"],"line":51,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const samlLogin = await request(getUrl(vendor)).get('/auth/login/saml').expect(302);\n          const samlRedirectUrl = String(samlLogin.headers.location).split('/simplesaml/');\n          const authResponse = await request(samlRedirectUrl[0]).get(`/simplesaml/${samlRedirectUrl[1]}`).set('Cookie', authCookies[vendor]);\n          expect(authResponse.statusCode).toBe(200);\n          const SAMLResponse = authResponse.text.split('<input type=\"hidden\" name=\"SAMLResponse\" value=\"')[1].split('\" />')[0];\n          const acsResponse = await request(getUrl(vendor)).post('/auth/login/saml/acs').send({\n            SAMLResponse\n          }).expect(200);\n\n          // Assert\n          expect(acsResponse.body.data).toEqual(expect.objectContaining({\n            access_token: expect.any(String),\n            expires: expect.any(Number),\n            refresh_token: expect.any(String)\n          }));\n        });","file":"blackbox/routes/auth/saml.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/auth/login/saml","POST /acs","when redirect is provided","returns directus refresh token in cookie"],"line":73,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const samlLogin = await request(getUrl(vendor)).get(`/auth/login/saml?redirect=${getUrl(vendor)}/admin/login?continue`).expect(302);\n          const samlRedirectUrl = String(samlLogin.headers.location).split('/simplesaml/');\n          const authResponse = await request(samlRedirectUrl[0]).get(`/simplesaml/${samlRedirectUrl[1]}`).set('Cookie', authCookies[vendor]);\n          expect(authResponse.statusCode).toBe(200);\n          const SAMLResponse = authResponse.text.split('<input type=\"hidden\" name=\"SAMLResponse\" value=\"')[1].split('\" />')[0];\n          const RelayState = authResponse.text.split('<input type=\"hidden\" name=\"RelayState\" value=\"')[1].split('\" />')[0];\n          const acsResponse = await request(getUrl(vendor)).post('/auth/login/saml/acs').send({\n            SAMLResponse,\n            RelayState\n          }).expect(302);\n          const cookies = acsResponse.headers['set-cookie'].map(cookie => cookie.split(';')[0]).join(';');\n\n          // Assert\n          expect(cookies).toMatch(/directus_refresh_token/);\n        });","file":"blackbox/routes/auth/saml.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/files","POST /","when only request body is provided without any multipart files","returns created file when required properties are included"],"line":9,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const payload = {\n            title: 'Test File',\n            storage: 'local',\n            filename_download: 'test_file',\n            type: 'application/octet-stream'\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).post(`/files`).send(payload).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body).toMatchObject({\n            data: {\n              title: payload.title,\n              storage: payload.storage,\n              filename_download: payload.filename_download\n            }\n          });\n        });","file":"blackbox/routes/collections/files.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/files","POST /","when only request body is provided without any multipart files","returns code: FAILED_VALIDATION when required property \"storage\" is not included"],"line":33,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const payload = {\n            title: 'Test File',\n            filename_download: 'test_file',\n            type: 'application/octet-stream'\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).post(`/files`).send(payload).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toBe(400);\n          expect(response.body).toMatchObject({\n            errors: [{\n              message: '\"storage\" is required',\n              extensions: {\n                code: 'FAILED_VALIDATION'\n              }\n            }]\n          });\n        });","file":"blackbox/routes/collections/files.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/files","POST /files"],"line":19,"code":"    describe.each(storages)('Storage: %s', storage => {\n      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).field('title', imageFile.title).field('description', imageFile.description).attach('file', createReadStream(imageFilePath));\n\n        // Normalize filesize to string as bigint returns as a string\n        response.body.data.filesize = String(response.body.data.filesize);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data).toEqual(expect.objectContaining({\n          filesize: imageFile.filesize,\n          type: imageFile.type,\n          filename_download: imageFile.name,\n          filename_disk: expect.any(String),\n          storage: storage,\n          title: imageFile.title,\n          description: imageFile.description,\n          id: expect.any(String)\n        }));\n      });\n    });","file":"blackbox/routes/files/storage.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/files","POST /files"],"line":20,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).field('title', imageFile.title).field('description', imageFile.description).attach('file', createReadStream(imageFilePath));\n\n        // Normalize filesize to string as bigint returns as a string\n        response.body.data.filesize = String(response.body.data.filesize);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data).toEqual(expect.objectContaining({\n          filesize: imageFile.filesize,\n          type: imageFile.type,\n          filename_download: imageFile.name,\n          filename_disk: expect.any(String),\n          storage: storage,\n          title: imageFile.title,\n          description: imageFile.description,\n          id: expect.any(String)\n        }));\n      });","file":"blackbox/routes/files/storage.test.ts","skipped":false,"dir":"tests"},{"name":"Storage: %s","suites":["/files","DELETE /files/:id"],"line":43,"code":"    describe.each(storages)('Storage: %s', storage => {\n      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n        // Action\n        const response = await request(getUrl(vendor)).delete(`/files/${insertResponse.body.data.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n        expect(response.body.data).toBe(undefined);\n      });\n    });","file":"blackbox/routes/files/storage.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/files","DELETE /files/:id"],"line":44,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const insertResponse = await request(getUrl(vendor)).post('/files').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`).field('storage', storage).attach('file', createReadStream(imageFilePath));\n\n        // Action\n        const response = await request(getUrl(vendor)).delete(`/files/${insertResponse.body.data.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n        expect(response.body.data).toBe(undefined);\n      });","file":"blackbox/routes/files/storage.test.ts","skipped":false,"dir":"tests"},{"name":"Seed Database Values","suites":[],"updatePoint":{"line":10,"column":26,"index":371},"line":10,"code":"test('Seed Database Values', () => {\n  expect(isSeeded).toStrictEqual(true);\n});","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"/items","suites":[],"line":13,"code":"describe.each(common.PRIMARY_KEY_TYPES)('/items', pkType => {\n  const localCollectionFirst = `${collectionFirst}_${pkType}`;\n  const localCollectionSecond = `${collectionSecond}_${pkType}`;\n  describe(`pkType: ${pkType}`, () => {\n    describe(`GET /${localCollectionFirst}`, () => {\n      describe('retrieves items without filters', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(2);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(2);\n        });\n      });\n      describe('retrieves items with filters (non-relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });\n      });\n      describe('errors with invalid filters (non-relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _contains: 'a'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _eq: 'b'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _starts_with: 'c'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _ends_with: 'd'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });\n      });\n      describe('retrieves items with filters (relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });\n      });\n      describe('errors with invalid filters (relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _contains: 'a'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _eq: 'b'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _starts_with: 'c'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _ends_with: 'd'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });\n      });\n    });\n  });\n});","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items without filters"],"line":19,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(2);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(2);\n        });","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items with filters (non-relational)"],"line":32,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","errors with invalid filters (non-relational)"],"line":75,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _contains: 'a'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _eq: 'b'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _starts_with: 'c'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              string_field: {\n                _ends_with: 'd'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items with filters (relational)"],"line":114,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","errors with invalid filters (relational)"],"line":165,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _contains: 'a'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                string_field: {\n                  _eq: 'b'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _starts_with: 'c'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                string_field: {\n                  _ends_with: 'd'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });","file":"blackbox/routes/items/conceal-filter.test.ts","skipped":false,"dir":"tests"},{"name":"Seed Database Values","suites":[],"updatePoint":{"line":10,"column":26,"index":368},"line":10,"code":"test('Seed Database Values', () => {\n  expect(isSeeded).toStrictEqual(true);\n});","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"/items","suites":[],"line":13,"code":"describe.each(common.PRIMARY_KEY_TYPES)('/items', pkType => {\n  const localCollectionFirst = `${collectionFirst}_${pkType}`;\n  const localCollectionSecond = `${collectionSecond}_${pkType}`;\n  describe(`pkType: ${pkType}`, () => {\n    describe(`GET /${localCollectionFirst}`, () => {\n      describe('retrieves items without filters', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(2);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(2);\n        });\n      });\n      describe('retrieves items with filters (non-relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });\n      });\n      describe('errors with invalid filters (non-relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _contains: 'a'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _eq: 'b'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _starts_with: 'c'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _ends_with: 'd'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });\n      });\n      describe('retrieves items with filters (relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });\n      });\n      describe('errors with invalid filters (relational)', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _contains: 'a'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _eq: 'b'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _starts_with: 'c'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _ends_with: 'd'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });\n      });\n    });\n  });\n});","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items without filters"],"line":19,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(2);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(2);\n        });","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items with filters (non-relational)"],"line":32,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _null: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _nnull: true\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","errors with invalid filters (non-relational)"],"line":75,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _contains: 'a'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _eq: 'b'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _starts_with: 'c'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              hash_field: {\n                _ends_with: 'd'\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","retrieves items with filters (relational)"],"line":114,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _null: true\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBe(1);\n          expect(response2.statusCode).toEqual(200);\n          expect(response2.body.data.length).toBe(1);\n          expect(response3.statusCode).toEqual(200);\n          expect(response3.body.data.length).toBe(1);\n          expect(response4.statusCode).toEqual(200);\n          expect(response4.body.data.length).toBe(1);\n        });","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /","errors with invalid filters (relational)"],"line":165,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _contains: 'a'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionFirst}`).query({\n            filter: JSON.stringify({\n              second_ids: {\n                hash_field: {\n                  _eq: 'b'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response3 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _starts_with: 'c'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const response4 = await request(getUrl(vendor)).get(`/items/${localCollectionSecond}`).query({\n            filter: JSON.stringify({\n              first_id: {\n                hash_field: {\n                  _ends_with: 'd'\n                }\n              }\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n          // Assert\n          expect(response.statusCode).toEqual(400);\n          expect(response2.statusCode).toEqual(400);\n          expect(response3.statusCode).toEqual(400);\n          expect(response4.statusCode).toEqual(400);\n        });","file":"blackbox/routes/items/hash-filter.test.ts","skipped":false,"dir":"tests"},{"name":"/items","suites":[],"line":18,"code":"describe.each(common.PRIMARY_KEY_TYPES)('/items', pkType => {\n  const localCollectionArtists = `${collectionArtists}_${pkType}`;\n  describe(`pkType: ${pkType}`, () => {\n    describe('GET /:collection/:id', () => {\n      describe('retrieves one artist', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artist = createArtist(pkType);\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artist\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}/${insertedArtist.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _eq: insertedArtist.id\n                    }\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: artist.name\n          });\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data).toMatchObject({\n            [localCollectionArtists]: [{\n              name: artist.name\n            }]\n          });\n        });\n      });\n      describe('Error handling', () => {\n        describe('returns an error when an invalid id is used', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}/invalid_id`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                [localCollectionArtists]: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 'invalid_id'\n                      }\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(200);\n            switch (vendor) {\n              case 'sqlite3':\n                expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                break;\n              case 'postgres':\n              case 'postgres10':\n              case 'mssql':\n              case 'cockroachdb':\n                if (pkType === 'string') {\n                  expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                } else {\n                  expect(gqlResponse.body.errors).toBeDefined();\n                }\n                break;\n              default:\n                if (pkType !== 'integer') {\n                  expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                } else {\n                  expect(gqlResponse.body.errors).toBeDefined();\n                }\n                break;\n            }\n          });\n        });\n        describe('returns an error when an invalid table is used', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/invalid_table/1`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                invalid_table: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 1\n                      }\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.status).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });\n        });\n      });\n    });\n    describe('PATCH /:collection/:id', () => {\n      describe(`updates one artist's name`, () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n          const body = {\n            name: 'Tommy Cash'\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}/${insertedArtist.id}`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionArtists}_item`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  id: insertedArtist.id,\n                  data: {\n                    name: 'updated'\n                  }\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            id: insertedArtist.id,\n            name: 'Tommy Cash'\n          });\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[mutationKey]).toEqual({\n            id: String(insertedArtist.id),\n            name: 'updated'\n          });\n        });\n      });\n    });\n    describe('DELETE /:collection/:id', () => {\n      describe('deletes an artist', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n          const insertedArtist2 = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}/${insertedArtist.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `delete_${localCollectionArtists}_item`;\n          await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  id: insertedArtist2.id\n                },\n                id: true\n              }\n            }\n          });\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _eq: insertedArtist2.id\n                    }\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(204);\n          expect(response.body.data).toBe(undefined);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n        });\n      });\n    });\n    describe('GET /:collection', () => {\n      describe('retrieves all items from artist table', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artistsCount = 50;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBeGreaterThanOrEqual(artistsCount);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toBeGreaterThanOrEqual(artistsCount);\n        });\n      });\n      describe('Error handling', () => {\n        describe('returns an error when an invalid table is used', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/invalid_table`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                invalid_table: {\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });\n        });\n      });\n    });\n    describe('POST /:collection', () => {\n      describe('createOne', () => {\n        describe('creates one artist', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artist = createArtist(pkType);\n            artist.name = 'one-' + artist.name;\n            const artist2 = createArtist(pkType);\n            artist2.name = 'one-' + artist2.name;\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artist).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_item`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artist2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toEqual(200);\n            expect(response.body.data).toMatchObject({\n              name: artist.name\n            });\n            expect(gqlResponse.statusCode).toEqual(200);\n            expect(gqlResponse.body.data[mutationKey]).toMatchObject({\n              name: artist2.name\n            });\n          });\n        });\n      });\n      describe('createMany', () => {\n        describe('creates 5 artists', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artists = [];\n            const artists2 = [];\n            const artistsCount = 5;\n            for (let i = 0; i < artistsCount; i++) {\n              const artist = createArtist(pkType);\n              artists.push(artist);\n              artist.name = 'many-' + artist.name;\n              const artist2 = createArtist(pkType);\n              artist2.name = 'many-' + artist2.name;\n              artists2.push(artist2);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toEqual(200);\n            expect(response.body.data.length).toBe(artistsCount);\n            expect(gqlResponse.statusCode).toEqual(200);\n            expect(gqlResponse.body.data[mutationKey].length).toBe(artistsCount);\n          });\n        });\n      });\n      describe('Error handling', () => {\n        describe('returns an error when an invalid table is used', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artist = createArtist(pkType);\n            const artist2 = createArtist(pkType);\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/invalid_table`).send(artist).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_invalid_table_item`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artist2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });\n        });\n      });\n    });\n    describe('PATCH /:collection', () => {\n      describe('updates many artists to a different name', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artistsCount = 5;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n          }\n          const insertedArtists = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n          const keys = Object.values(insertedArtists ?? []).map(item => item.id);\n          const body = {\n            keys: keys,\n            data: {\n              name: 'Johnny Cash'\n            }\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}?fields=name`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionArtists}_items`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  ids: keys,\n                  data: {\n                    name: 'updated'\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          for (let row = 0; row < response.body.data.length; row++) {\n            expect(response.body.data[row]).toMatchObject({\n              name: 'Johnny Cash'\n            });\n          }\n          expect(response.body.data.length).toBe(keys.length);\n          expect(gqlResponse.statusCode).toEqual(200);\n          for (let row = 0; row < gqlResponse.body.data[mutationKey].length; row++) {\n            expect(gqlResponse.body.data[mutationKey][row]).toMatchObject({\n              name: 'updated'\n            });\n          }\n          expect(gqlResponse.body.data[mutationKey].length).toBe(keys.length);\n        });\n      });\n    });\n    describe('DELETE /:collection', () => {\n      describe('deletes many artists', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artists2 = [];\n          const artistsCount = 10;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n            artists2.push(createArtist(pkType));\n          }\n          const insertedArtists = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n          const keys = Object.values(insertedArtists ?? []).map(item => item.id);\n          const insertedArtists2 = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists2\n          });\n          const keys2 = Object.values(insertedArtists2 ?? []).map(item => item.id);\n\n          // Action\n          const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send(keys).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `delete_${localCollectionArtists}_items`;\n          await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  ids: keys2\n                },\n                ids: true\n              }\n            }\n          });\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _in: keys2\n                    }\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(204);\n          expect(response.body.data).toBe(undefined);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n        });\n      });\n    });\n    describe('Verify createOne action hook run', () => {\n      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/items/tests_extensions_log').query({\n          filter: JSON.stringify({\n            key: {\n              _starts_with: `action-verify-create/${collectionArtists}_${pkType}/one`\n            }\n          })\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data.length).toBe(2);\n        for (const log of response.body.data) {\n          expect(log.value).toBe('1');\n        }\n      });\n    });\n    describe('Verify createMany action hook run', () => {\n      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/items/tests_extensions_log').query({\n          filter: JSON.stringify({\n            key: {\n              _starts_with: `action-verify-create/${collectionArtists}_${pkType}/many`\n            }\n          })\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data.length).toBe(10);\n        for (const log of response.body.data) {\n          expect(log.value).toBe('1');\n        }\n      });\n    });\n    describe('Logical Filters', () => {\n      describe('retrieves artists with name equality _AND company equality', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 6;\n          const artistName = 'logical-filter-and';\n          const artistCompany = 'and-equality';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artist.company = artistCompany;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              _and: [{\n                name: {\n                  _eq: artistName\n                }\n              }, {\n                company: {\n                  _eq: artistCompany\n                }\n              }]\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    _and: [{\n                      name: {\n                        _eq: artistName\n                      }\n                    }, {\n                      company: {\n                        _eq: artistCompany\n                      }\n                    }]\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count);\n        });\n      });\n      describe('retrieves artists with name equality _OR company equality', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 5;\n          const artistName = 'logical-filter-or';\n          const artistCompany = 'or-equality';\n          const artists1 = [];\n          const artists2 = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists1.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists1\n          });\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.company = artistCompany;\n            artists2.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists2\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              _or: [{\n                name: {\n                  _eq: artistName\n                }\n              }, {\n                company: {\n                  _eq: artistCompany\n                }\n              }]\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    _or: [{\n                      name: {\n                        _eq: artistName\n                      }\n                    }, {\n                      company: {\n                        _eq: artistCompany\n                      }\n                    }]\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count * 2);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count * 2);\n        });\n      });\n    });\n    describe('Aggregation Tests', () => {\n      describe('retrieves count correctly', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const artistName = 'aggregate-count';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: {\n              name: {\n                _eq: artistName\n              }\n            }\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _eq: artistName\n                    }\n                  }\n                },\n                count: {\n                  id: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data[0].count.id == count).toBeTruthy();\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[queryKey][0].count.id).toEqual(count);\n        });\n      });\n    });\n    describe('Offset Tests', () => {\n      describe('retrieves offset correctly', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 7;\n          const offset = 3;\n          const artistName = 'offset-test';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _eq: artistName\n              }\n            }),\n            offset\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _eq: artistName\n                    }\n                  },\n                  offset\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count - offset);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count - offset);\n        });\n      });\n      describe('retrieves offset with limit and sort correctly', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 9;\n          const offset = 4;\n          const limit = 3;\n          const sort = 'name';\n          const artistName = 'offset-limit-sort-test';\n          const artists = [];\n          const expectedResultAsc = Array.from(Array(count).keys()).slice(offset, offset + limit);\n          const expectedResultDesc = Array.from(Array(count).keys()).sort(v => -v).slice(offset, offset + limit);\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const responseAsc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseAsc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n          const responseDesc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort: `-${sort}`\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseDesc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort: `-${sort}`\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(responseAsc.statusCode).toBe(200);\n          expect(responseAsc.body.data.length).toBe(limit);\n          expect(responseAsc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(gqlResponseAsc.statusCode).toBe(200);\n          expect(gqlResponseAsc.body.data[localCollectionArtists].length).toEqual(limit);\n          expect(gqlResponseAsc.body.data[localCollectionArtists].map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(responseDesc.statusCode).toBe(200);\n          expect(responseDesc.body.data.length).toBe(limit);\n          expect(responseDesc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n          expect(gqlResponseDesc.statusCode).toBe(200);\n          expect(gqlResponseDesc.body.data[localCollectionArtists].length).toEqual(limit);\n          expect(gqlResponseDesc.body.data[localCollectionArtists].map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n        });\n      });\n      describe('retrieves offset in aggregation with limit correctly', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const offset = 3;\n          const limit = 3;\n          const groupBy = ['id', 'name'];\n          const artistName = 'offset-aggregation-limit-test';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset: offset * 2,\n            limit,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset: offset * 2,\n                  limit,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(limit);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[queryKey].length).toEqual(limit);\n          expect(response2.statusCode).toBe(200);\n          expect(response2.body.data.length).toBe(limit);\n          expect(gqlResponse2.statusCode).toBe(200);\n          expect(gqlResponse2.body.data[queryKey].length).toEqual(limit);\n          for (const item of response.body.data) {\n            expect(response2.body.data).not.toContain(item);\n          }\n          const gqlResults = gqlResponse.body.data[queryKey].map(v => v.group.id);\n          const gqlResults2 = gqlResponse2.body.data[queryKey].map(v => v.group.id);\n          for (const item of gqlResults) {\n            expect(gqlResults2).not.toContain(item);\n          }\n        });\n      });\n      describe('retrieves offset in aggregation with limit and sort correctly', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const offset = 3;\n          const limit = 6;\n          const sort = 'name';\n          const groupBy = ['id', 'name'];\n          const artistName = 'offset-aggregation-limit-sort-test';\n          const artists = [];\n          const expectedResultAsc = Array.from(Array(count).keys()).slice(offset, offset + limit);\n          const expectedResultDesc = Array.from(Array(count).keys()).sort(v => -v).slice(offset, offset + limit);\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const responseAsc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponseAsc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n          const responseDesc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort: `-${sort}`,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseDesc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort: `-${sort}`,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n\n          // Assert\n          expect(responseAsc.statusCode).toBe(200);\n          expect(responseAsc.body.data.length).toBe(limit);\n          expect(responseAsc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(gqlResponseAsc.statusCode).toBe(200);\n          expect(gqlResponseAsc.body.data[queryKey].length).toEqual(limit);\n          expect(gqlResponseAsc.body.data[queryKey].map(v => parseInt(v.group.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(responseDesc.statusCode).toBe(200);\n          expect(responseDesc.body.data.length).toBe(limit);\n          expect(responseDesc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n          expect(gqlResponseDesc.statusCode).toBe(200);\n          expect(gqlResponseDesc.body.data[queryKey].length).toEqual(limit);\n          expect(gqlResponseDesc.body.data[queryKey].map(v => parseInt(v.group.name.split('-')[0]))).toEqual(expectedResultDesc);\n        });\n      });\n    });\n    describe('MAX_BATCH_MUTATION Tests', () => {\n      describe('createMany', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(createArtist(pkType));\n              artists2.push(createArtist(pkType));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(createArtist(pkType));\n              artists2.push(createArtist(pkType));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n      describe('updateBatch', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n              artists2.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_batch`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n              artists2.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_batch`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n      describe('updateMany', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artistIDs = [];\n            const artistIDs2 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs,\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs2,\n                    data: {\n                      name: 'updated'\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artistIDs = [];\n            const artistIDs2 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs,\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs2,\n                    data: {\n                      name: 'updated'\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n      describe('updateByQuery', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              },\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              },\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n      describe('deleteMany', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artistIDs = [];\n            const artistIDs2 = [];\n            const artistIDs3 = [];\n            const artistIDs4 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs3.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs4.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const response2 = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs2\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `delete_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs3\n                  },\n                  ids: true\n                }\n              }\n            });\n            const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs4\n                  },\n                  ids: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(204);\n            expect(response2.statusCode).toBe(204);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].ids.length).toEqual(count);\n            expect(gqlResponse2.statusCode).toBe(200);\n            expect(gqlResponse2.body.data[mutationKey].ids.length).toEqual(count);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artistIDs = [];\n            const artistIDs2 = [];\n            const artistIDs3 = [];\n            const artistIDs4 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs3.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs4.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const response2 = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs2\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `delete_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs3\n                  },\n                  ids: true\n                }\n              }\n            });\n            const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs4\n                  },\n                  ids: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(response2.statusCode).toBe(400);\n            expect(response2.body.errors).toBeDefined();\n            expect(response2.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse2.statusCode).toBe(200);\n            expect(gqlResponse2.body.errors).toBeDefined();\n            expect(gqlResponse2.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n      describe('deleteByQuery', () => {\n        describe('passes when below limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(204);\n          }, 120000);\n        });\n        describe('errors when above limit', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);\n        });\n      });\n    });\n  });\n});","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection/:id","retrieves one artist"],"line":23,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artist = createArtist(pkType);\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artist\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}/${insertedArtist.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _eq: insertedArtist.id\n                    }\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: artist.name\n          });\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data).toMatchObject({\n            [localCollectionArtists]: [{\n              name: artist.name\n            }]\n          });\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection/:id","Error handling","returns an error when an invalid id is used"],"line":63,"code":"          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}/invalid_id`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                [localCollectionArtists]: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 'invalid_id'\n                      }\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(200);\n            switch (vendor) {\n              case 'sqlite3':\n                expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                break;\n              case 'postgres':\n              case 'postgres10':\n              case 'mssql':\n              case 'cockroachdb':\n                if (pkType === 'string') {\n                  expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                } else {\n                  expect(gqlResponse.body.errors).toBeDefined();\n                }\n                break;\n              default:\n                if (pkType !== 'integer') {\n                  expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n                } else {\n                  expect(gqlResponse.body.errors).toBeDefined();\n                }\n                break;\n            }\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection/:id","Error handling","returns an error when an invalid table is used"],"line":109,"code":"          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/invalid_table/1`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                invalid_table: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 1\n                      }\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.status).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","PATCH /:collection/:id","updates one artist's name"],"line":137,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n          const body = {\n            name: 'Tommy Cash'\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}/${insertedArtist.id}`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionArtists}_item`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  id: insertedArtist.id,\n                  data: {\n                    name: 'updated'\n                  }\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            id: insertedArtist.id,\n            name: 'Tommy Cash'\n          });\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[mutationKey]).toEqual({\n            id: String(insertedArtist.id),\n            name: 'updated'\n          });\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","DELETE /:collection/:id","deletes an artist"],"line":181,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const insertedArtist = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n          const insertedArtist2 = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: createArtist(pkType)\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}/${insertedArtist.id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `delete_${localCollectionArtists}_item`;\n          await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  id: insertedArtist2.id\n                },\n                id: true\n              }\n            }\n          });\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _eq: insertedArtist2.id\n                    }\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(204);\n          expect(response.body.data).toBe(undefined);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection","retrieves all items from artist table"],"line":230,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artistsCount = 50;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.length).toBeGreaterThanOrEqual(artistsCount);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toBeGreaterThanOrEqual(artistsCount);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection","Error handling","returns an error when an invalid table is used"],"line":261,"code":"          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/invalid_table`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                invalid_table: {\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","POST /:collection","createOne","creates one artist"],"line":283,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artist = createArtist(pkType);\n            artist.name = 'one-' + artist.name;\n            const artist2 = createArtist(pkType);\n            artist2.name = 'one-' + artist2.name;\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artist).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_item`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artist2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toEqual(200);\n            expect(response.body.data).toMatchObject({\n              name: artist.name\n            });\n            expect(gqlResponse.statusCode).toEqual(200);\n            expect(gqlResponse.body.data[mutationKey]).toMatchObject({\n              name: artist2.name\n            });\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","POST /:collection","createMany","creates 5 artists"],"line":318,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artists = [];\n            const artists2 = [];\n            const artistsCount = 5;\n            for (let i = 0; i < artistsCount; i++) {\n              const artist = createArtist(pkType);\n              artists.push(artist);\n              artist.name = 'many-' + artist.name;\n              const artist2 = createArtist(pkType);\n              artist2.name = 'many-' + artist2.name;\n              artists2.push(artist2);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toEqual(200);\n            expect(response.body.data.length).toBe(artistsCount);\n            expect(gqlResponse.statusCode).toEqual(200);\n            expect(gqlResponse.body.data[mutationKey].length).toBe(artistsCount);\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","POST /:collection","Error handling","returns an error when an invalid table is used"],"line":356,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const artist = createArtist(pkType);\n            const artist2 = createArtist(pkType);\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/invalid_table`).send(artist).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_invalid_table_item`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artist2\n                  },\n                  name: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n            expect(gqlResponse.body.errors).toBeDefined();\n          });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","PATCH /:collection","updates many artists to a different name"],"line":385,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artistsCount = 5;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n          }\n          const insertedArtists = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n          const keys = Object.values(insertedArtists ?? []).map(item => item.id);\n          const body = {\n            keys: keys,\n            data: {\n              name: 'Johnny Cash'\n            }\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}?fields=name`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionArtists}_items`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  ids: keys,\n                  data: {\n                    name: 'updated'\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          for (let row = 0; row < response.body.data.length; row++) {\n            expect(response.body.data[row]).toMatchObject({\n              name: 'Johnny Cash'\n            });\n          }\n          expect(response.body.data.length).toBe(keys.length);\n          expect(gqlResponse.statusCode).toEqual(200);\n          for (let row = 0; row < gqlResponse.body.data[mutationKey].length; row++) {\n            expect(gqlResponse.body.data[mutationKey][row]).toMatchObject({\n              name: 'updated'\n            });\n          }\n          expect(gqlResponse.body.data[mutationKey].length).toBe(keys.length);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","DELETE /:collection","deletes many artists"],"line":441,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const artists = [];\n          const artists2 = [];\n          const artistsCount = 10;\n          for (let i = 0; i < artistsCount; i++) {\n            artists.push(createArtist(pkType));\n            artists2.push(createArtist(pkType));\n          }\n          const insertedArtists = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n          const keys = Object.values(insertedArtists ?? []).map(item => item.id);\n          const insertedArtists2 = await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists2\n          });\n          const keys2 = Object.values(insertedArtists2 ?? []).map(item => item.id);\n\n          // Action\n          const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send(keys).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `delete_${localCollectionArtists}_items`;\n          await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  ids: keys2\n                },\n                ids: true\n              }\n            }\n          });\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    id: {\n                      _in: keys2\n                    }\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(204);\n          expect(response.body.data).toBe(undefined);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(0);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Verify createOne action hook run"],"line":498,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/items/tests_extensions_log').query({\n          filter: JSON.stringify({\n            key: {\n              _starts_with: `action-verify-create/${collectionArtists}_${pkType}/one`\n            }\n          })\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data.length).toBe(2);\n        for (const log of response.body.data) {\n          expect(log.value).toBe('1');\n        }\n      });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Verify createMany action hook run"],"line":517,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/items/tests_extensions_log').query({\n          filter: JSON.stringify({\n            key: {\n              _starts_with: `action-verify-create/${collectionArtists}_${pkType}/many`\n            }\n          })\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toBe(200);\n        expect(response.body.data.length).toBe(10);\n        for (const log of response.body.data) {\n          expect(log.value).toBe('1');\n        }\n      });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Logical Filters","retrieves artists with name equality _AND company equality"],"line":537,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 6;\n          const artistName = 'logical-filter-and';\n          const artistCompany = 'and-equality';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artist.company = artistCompany;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              _and: [{\n                name: {\n                  _eq: artistName\n                }\n              }, {\n                company: {\n                  _eq: artistCompany\n                }\n              }]\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    _and: [{\n                      name: {\n                        _eq: artistName\n                      }\n                    }, {\n                      company: {\n                        _eq: artistCompany\n                      }\n                    }]\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Logical Filters","retrieves artists with name equality _OR company equality"],"line":597,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 5;\n          const artistName = 'logical-filter-or';\n          const artistCompany = 'or-equality';\n          const artists1 = [];\n          const artists2 = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists1.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists1\n          });\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.company = artistCompany;\n            artists2.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists2\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              _or: [{\n                name: {\n                  _eq: artistName\n                }\n              }, {\n                company: {\n                  _eq: artistCompany\n                }\n              }]\n            })\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    _or: [{\n                      name: {\n                        _eq: artistName\n                      }\n                    }, {\n                      company: {\n                        _eq: artistCompany\n                      }\n                    }]\n                  }\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count * 2);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count * 2);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Aggregation Tests","retrieves count correctly"],"line":668,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const artistName = 'aggregate-count';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: {\n              name: {\n                _eq: artistName\n              }\n            }\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _eq: artistName\n                    }\n                  }\n                },\n                count: {\n                  id: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data[0].count.id == count).toBeTruthy();\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[queryKey][0].count.id).toEqual(count);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Offset Tests","retrieves offset correctly"],"line":722,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 7;\n          const offset = 3;\n          const artistName = 'offset-test';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = artistName;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _eq: artistName\n              }\n            }),\n            offset\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _eq: artistName\n                    }\n                  },\n                  offset\n                },\n                id: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(count - offset);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[localCollectionArtists].length).toEqual(count - offset);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Offset Tests","retrieves offset with limit and sort correctly"],"line":771,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 9;\n          const offset = 4;\n          const limit = 3;\n          const sort = 'name';\n          const artistName = 'offset-limit-sort-test';\n          const artists = [];\n          const expectedResultAsc = Array.from(Array(count).keys()).slice(offset, offset + limit);\n          const expectedResultDesc = Array.from(Array(count).keys()).sort(v => -v).slice(offset, offset + limit);\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const responseAsc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseAsc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n          const responseDesc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort: `-${sort}`\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseDesc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionArtists]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort: `-${sort}`\n                },\n                id: true,\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(responseAsc.statusCode).toBe(200);\n          expect(responseAsc.body.data.length).toBe(limit);\n          expect(responseAsc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(gqlResponseAsc.statusCode).toBe(200);\n          expect(gqlResponseAsc.body.data[localCollectionArtists].length).toEqual(limit);\n          expect(gqlResponseAsc.body.data[localCollectionArtists].map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(responseDesc.statusCode).toBe(200);\n          expect(responseDesc.body.data.length).toBe(limit);\n          expect(responseDesc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n          expect(gqlResponseDesc.statusCode).toBe(200);\n          expect(gqlResponseDesc.body.data[localCollectionArtists].length).toEqual(limit);\n          expect(gqlResponseDesc.body.data[localCollectionArtists].map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Offset Tests","retrieves offset in aggregation with limit correctly"],"line":865,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const offset = 3;\n          const limit = 3;\n          const groupBy = ['id', 'name'];\n          const artistName = 'offset-aggregation-limit-test';\n          const artists = [];\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n          const response2 = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset: offset * 2,\n            limit,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset: offset * 2,\n                  limit,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(response.body.data.length).toBe(limit);\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[queryKey].length).toEqual(limit);\n          expect(response2.statusCode).toBe(200);\n          expect(response2.body.data.length).toBe(limit);\n          expect(gqlResponse2.statusCode).toBe(200);\n          expect(gqlResponse2.body.data[queryKey].length).toEqual(limit);\n          for (const item of response.body.data) {\n            expect(response2.body.data).not.toContain(item);\n          }\n          const gqlResults = gqlResponse.body.data[queryKey].map(v => v.group.id);\n          const gqlResults2 = gqlResponse2.body.data[queryKey].map(v => v.group.id);\n          for (const item of gqlResults) {\n            expect(gqlResults2).not.toContain(item);\n          }\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","Offset Tests","retrieves offset in aggregation with limit and sort correctly"],"line":972,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const count = 10;\n          const offset = 3;\n          const limit = 6;\n          const sort = 'name';\n          const groupBy = ['id', 'name'];\n          const artistName = 'offset-aggregation-limit-sort-test';\n          const artists = [];\n          const expectedResultAsc = Array.from(Array(count).keys()).slice(offset, offset + limit);\n          const expectedResultDesc = Array.from(Array(count).keys()).sort(v => -v).slice(offset, offset + limit);\n          for (let i = 0; i < count; i++) {\n            const artist = createArtist(pkType);\n            artist.name = `${i}-${artistName}`;\n            artists.push(artist);\n          }\n          await CreateItem(vendor, {\n            collection: localCollectionArtists,\n            item: artists\n          });\n\n          // Action\n          const responseAsc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const queryKey = `${localCollectionArtists}_aggregated`;\n          const gqlResponseAsc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n          const responseDesc = await request(getUrl(vendor)).get(`/items/${localCollectionArtists}`).query({\n            aggregate: {\n              count: 'id'\n            },\n            filter: JSON.stringify({\n              name: {\n                _contains: artistName\n              }\n            }),\n            offset,\n            limit,\n            sort: `-${sort}`,\n            groupBy\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponseDesc = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [queryKey]: {\n                __args: {\n                  filter: {\n                    name: {\n                      _contains: artistName\n                    }\n                  },\n                  offset,\n                  limit,\n                  sort: `-${sort}`,\n                  groupBy\n                },\n                count: {\n                  id: true\n                },\n                group: true\n              }\n            }\n          });\n\n          // Assert\n          expect(responseAsc.statusCode).toBe(200);\n          expect(responseAsc.body.data.length).toBe(limit);\n          expect(responseAsc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(gqlResponseAsc.statusCode).toBe(200);\n          expect(gqlResponseAsc.body.data[queryKey].length).toEqual(limit);\n          expect(gqlResponseAsc.body.data[queryKey].map(v => parseInt(v.group.name.split('-')[0]))).toEqual(expectedResultAsc);\n          expect(responseDesc.statusCode).toBe(200);\n          expect(responseDesc.body.data.length).toBe(limit);\n          expect(responseDesc.body.data.map(v => parseInt(v.name.split('-')[0]))).toEqual(expectedResultDesc);\n          expect(gqlResponseDesc.statusCode).toBe(200);\n          expect(gqlResponseDesc.body.data[queryKey].length).toEqual(limit);\n          expect(gqlResponseDesc.body.data[queryKey].map(v => parseInt(v.group.name.split('-')[0]))).toEqual(expectedResultDesc);\n        });","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","createMany","passes when below limit"],"line":1085,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(createArtist(pkType));\n              artists2.push(createArtist(pkType));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","createMany","errors when above limit"],"line":1117,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(createArtist(pkType));\n              artists2.push(createArtist(pkType));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).post(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `create_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateBatch","passes when below limit"],"line":1153,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n              artists2.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_batch`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateBatch","errors when above limit"],"line":1191,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artists = [];\n            const artists2 = [];\n            for (let i = 0; i < count; i++) {\n              artists.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n              artists2.push(await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              }));\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send(artists).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_batch`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    data: artists2\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateMany","passes when below limit"],"line":1233,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artistIDs = [];\n            const artistIDs2 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs,\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs2,\n                    data: {\n                      name: 'updated'\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].length).toEqual(count);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateMany","errors when above limit"],"line":1279,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artistIDs = [];\n            const artistIDs2 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs,\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `update_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs2,\n                    data: {\n                      name: 'updated'\n                    }\n                  },\n                  id: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateByQuery","passes when below limit"],"line":1329,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              },\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(200);\n            expect(response.body.data.length).toBe(count);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","updateByQuery","errors when above limit"],"line":1363,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).patch(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              },\n              data: {\n                name: 'updated'\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","deleteMany","passes when below limit"],"line":1400,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const artistIDs = [];\n            const artistIDs2 = [];\n            const artistIDs3 = [];\n            const artistIDs4 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs3.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs4.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const response2 = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs2\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `delete_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs3\n                  },\n                  ids: true\n                }\n              }\n            });\n            const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs4\n                  },\n                  ids: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(204);\n            expect(response2.statusCode).toBe(204);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.data[mutationKey].ids.length).toEqual(count);\n            expect(gqlResponse2.statusCode).toBe(200);\n            expect(gqlResponse2.body.data[mutationKey].ids.length).toEqual(count);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","deleteMany","errors when above limit"],"line":1465,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const artistIDs = [];\n            const artistIDs2 = [];\n            const artistIDs3 = [];\n            const artistIDs4 = [];\n            for (let i = 0; i < count; i++) {\n              artistIDs.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs2.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs3.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n              artistIDs4.push((await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: createArtist(pkType)\n              })).id);\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const response2 = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              keys: artistIDs2\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const mutationKey = `delete_${localCollectionArtists}_items`;\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs3\n                  },\n                  ids: true\n                }\n              }\n            });\n            const gqlResponse2 = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              mutation: {\n                [mutationKey]: {\n                  __args: {\n                    ids: artistIDs4\n                  },\n                  ids: true\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(response2.statusCode).toBe(400);\n            expect(response2.body.errors).toBeDefined();\n            expect(response2.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse.statusCode).toBe(200);\n            expect(gqlResponse.body.errors).toBeDefined();\n            expect(gqlResponse.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n            expect(gqlResponse2.statusCode).toBe(200);\n            expect(gqlResponse2.body.errors).toBeDefined();\n            expect(gqlResponse2.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","deleteByQuery","passes when below limit"],"line":1538,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION);\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(204);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","MAX_BATCH_MUTATION Tests","deleteByQuery","errors when above limit"],"line":1568,"code":"          it.each(vendors)('%s', async vendor => {\n            // Setup\n            const count = Number(config.envs[vendor].MAX_BATCH_MUTATION) + 1;\n            const company = uuid();\n            for (let i = 0; i < count; i++) {\n              const artist = createArtist(pkType);\n              artist.company = company;\n              await CreateItem(vendor, {\n                collection: localCollectionArtists,\n                item: artist\n              });\n            }\n\n            // Action\n            const response = await request(getUrl(vendor)).delete(`/items/${localCollectionArtists}`).send({\n              query: {\n                filter: JSON.stringify({\n                  company: {\n                    _eq: company\n                  }\n                }),\n                limit: -1\n              }\n            }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n            // Assert\n            expect(response.statusCode).toBe(400);\n            expect(response.body.errors).toBeDefined();\n            expect(response.body.errors[0].message).toBe(`Exceeded max batch mutation limit of ${config.envs[vendor].MAX_BATCH_MUTATION}.`);\n          }, 120000);","file":"blackbox/routes/items/no-relation.test.ts","skipped":false,"dir":"tests"},{"name":"Seed Database Values","suites":[],"updatePoint":{"line":11,"column":26,"index":439},"line":11,"code":"test('Seed Database Values', () => {\n  expect(isSeeded).toStrictEqual(true);\n});","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"/items","suites":[],"line":14,"code":"describe.each(common.PRIMARY_KEY_TYPES)('/items', pkType => {\n  const localCollectionSingleton = `${collectionSingleton}_${pkType}`;\n  const localCollectionSingletonO2M = `${collectionSingletonO2M}_${pkType}`;\n  describe(`pkType: ${pkType}`, () => {\n    describe('GET /:collection', () => {\n      describe('retrieves singleton', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionSingleton]: {\n                name: true,\n                o2m: {\n                  id: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: 'parent',\n            o2m: expect.anything()\n          });\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data).toMatchObject({\n            [localCollectionSingleton]: {\n              name: 'parent',\n              o2m: expect.anything()\n            }\n          });\n        });\n      });\n      describe('Error handling', () => {\n        describe('returns an error when an invalid id is used', () => {\n          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}/invalid_id`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                [localCollectionSingleton]: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 'invalid_id'\n                      }\n                    }\n                  },\n                  name: true,\n                  o2m: {\n                    id: true\n                  }\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n          });\n        });\n      });\n    });\n    describe('PATCH /:collection', () => {\n      describe(`updates singleton's name with no relations`, () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const newName = 'parent_updated';\n          const newName2 = 'parent_updated2';\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionSingleton}`).send({\n            name: newName\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionSingleton}`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  data: {\n                    name: newName2\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: newName\n          });\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[mutationKey]).toEqual({\n            name: newName2\n          });\n        });\n      });\n      describe('updates o2m items', () => {\n        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const existingItem = (await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n          const o2mNameNew = 'child_o2m_new';\n          const o2mNameNew2 = 'child_o2m_new2';\n          const o2mNameUpdated = 'child_o2m_updated';\n          const o2mNameUpdated2 = 'child_o2m_updated2';\n          const body = {\n            o2m: {\n              create: [{\n                id: pkType === 'string' ? SeedFunctions.generatePrimaryKeys(pkType, {\n                  quantity: 1,\n                  seed: `${localCollectionSingletonO2M}_update_o2m`\n                })[0] : undefined,\n                name: o2mNameNew\n              }],\n              update: [{\n                id: existingItem.o2m[0],\n                name: o2mNameUpdated\n              }],\n              delete: []\n            }\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionSingleton}?fields=*.*`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponsePre = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionSingleton]: {\n                o2m: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          });\n          const updatedO2M = gqlResponsePre.body.data[localCollectionSingleton].o2m;\n          const newO2mItem = {\n            name: o2mNameNew2\n          };\n          if (pkType === 'string') {\n            newO2mItem.id = SeedFunctions.generatePrimaryKeys(pkType, {\n              quantity: 1,\n              seed: `${localCollectionSingletonO2M}_update_o2m2`\n            })[0];\n          }\n          updatedO2M.push(newO2mItem);\n          updatedO2M[0].name = o2mNameUpdated2;\n          const mutationKey = `update_${localCollectionSingleton}`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  data: {\n                    o2m: updatedO2M\n                  }\n                },\n                o2m: {\n                  name: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.o2m).toBeDefined();\n          expect(response.body.data.o2m.length).toBe(2);\n          expect(response.body.data.o2m.map(item => item.name)).toEqual(expect.arrayContaining([o2mNameNew, o2mNameUpdated]));\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data[mutationKey].o2m).toBeDefined();\n          expect(gqlResponse.body.data[mutationKey].o2m.length).toBe(3);\n          expect(gqlResponse.body.data[mutationKey].o2m.map(item => item.name)).toEqual(expect.arrayContaining([o2mNameNew2, o2mNameUpdated2]));\n        });\n      });\n    });\n  });\n});","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection","retrieves singleton"],"line":20,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionSingleton]: {\n                name: true,\n                o2m: {\n                  id: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: 'parent',\n            o2m: expect.anything()\n          });\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data).toMatchObject({\n            [localCollectionSingleton]: {\n              name: 'parent',\n              o2m: expect.anything()\n            }\n          });\n        });","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","GET /:collection","Error handling","returns an error when an invalid id is used"],"line":51,"code":"          it.each(vendors)('%s', async vendor => {\n            // Action\n            const response = await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}/invalid_id`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n            const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n              query: {\n                [localCollectionSingleton]: {\n                  __args: {\n                    filter: {\n                      id: {\n                        _eq: 'invalid_id'\n                      }\n                    }\n                  },\n                  name: true,\n                  o2m: {\n                    id: true\n                  }\n                }\n              }\n            });\n\n            // Assert\n            expect(response.statusCode).toBe(403);\n            expect(gqlResponse.statusCode).toBe(400);\n          });","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","PATCH /:collection","updates singleton's name with no relations"],"line":81,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const newName = 'parent_updated';\n          const newName2 = 'parent_updated2';\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionSingleton}`).send({\n            name: newName\n          }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const mutationKey = `update_${localCollectionSingleton}`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  data: {\n                    name: newName2\n                  }\n                },\n                name: true\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data).toMatchObject({\n            name: newName\n          });\n          expect(gqlResponse.statusCode).toBe(200);\n          expect(gqlResponse.body.data[mutationKey]).toEqual({\n            name: newName2\n          });\n        });","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["pkType: ","PATCH /:collection","updates o2m items"],"line":116,"code":"        it.each(vendors)('%s', async vendor => {\n          // Setup\n          const existingItem = (await request(getUrl(vendor)).get(`/items/${localCollectionSingleton}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n          const o2mNameNew = 'child_o2m_new';\n          const o2mNameNew2 = 'child_o2m_new2';\n          const o2mNameUpdated = 'child_o2m_updated';\n          const o2mNameUpdated2 = 'child_o2m_updated2';\n          const body = {\n            o2m: {\n              create: [{\n                id: pkType === 'string' ? SeedFunctions.generatePrimaryKeys(pkType, {\n                  quantity: 1,\n                  seed: `${localCollectionSingletonO2M}_update_o2m`\n                })[0] : undefined,\n                name: o2mNameNew\n              }],\n              update: [{\n                id: existingItem.o2m[0],\n                name: o2mNameUpdated\n              }],\n              delete: []\n            }\n          };\n\n          // Action\n          const response = await request(getUrl(vendor)).patch(`/items/${localCollectionSingleton}?fields=*.*`).send(body).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n          const gqlResponsePre = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            query: {\n              [localCollectionSingleton]: {\n                o2m: {\n                  id: true,\n                  name: true\n                }\n              }\n            }\n          });\n          const updatedO2M = gqlResponsePre.body.data[localCollectionSingleton].o2m;\n          const newO2mItem = {\n            name: o2mNameNew2\n          };\n          if (pkType === 'string') {\n            newO2mItem.id = SeedFunctions.generatePrimaryKeys(pkType, {\n              quantity: 1,\n              seed: `${localCollectionSingletonO2M}_update_o2m2`\n            })[0];\n          }\n          updatedO2M.push(newO2mItem);\n          updatedO2M[0].name = o2mNameUpdated2;\n          const mutationKey = `update_${localCollectionSingleton}`;\n          const gqlResponse = await requestGraphQL(getUrl(vendor), false, common.USER.ADMIN.TOKEN, {\n            mutation: {\n              [mutationKey]: {\n                __args: {\n                  data: {\n                    o2m: updatedO2M\n                  }\n                },\n                o2m: {\n                  name: true\n                }\n              }\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toEqual(200);\n          expect(response.body.data.o2m).toBeDefined();\n          expect(response.body.data.o2m.length).toBe(2);\n          expect(response.body.data.o2m.map(item => item.name)).toEqual(expect.arrayContaining([o2mNameNew, o2mNameUpdated]));\n          expect(gqlResponse.statusCode).toEqual(200);\n          expect(gqlResponse.body.data[mutationKey].o2m).toBeDefined();\n          expect(gqlResponse.body.data[mutationKey].o2m.length).toBe(3);\n          expect(gqlResponse.body.data[mutationKey].o2m.map(item => item.name)).toEqual(expect.arrayContaining([o2mNameNew2, o2mNameUpdated2]));\n        });","file":"blackbox/routes/items/singleton.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","GET /schema/snapshot","denies non-admin users"],"line":18,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.APP_ACCESS.TOKEN}`);\n        const response2 = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.API_ONLY.TOKEN}`);\n        const response3 = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.NO_ROLE.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(403);\n        expect(response2.statusCode).toEqual(403);\n        expect(response3.statusCode).toEqual(403);\n      });","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","GET /schema/snapshot","retrieves a snapshot (JSON)"],"line":31,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(200);\n        snapshotsCacheOriginal[vendor] = response.body.data;\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","GET /schema/snapshot","retrieves a snapshot (YAML)"],"line":41,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).get('/schema/snapshot').query({\n          export: 'yaml'\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(200);\n        snapshotsCacheOriginalYaml[vendor] = response.text;\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s primary keys","suites":["Schema Snapshots","GET /schema/snapshot","remove tables"],"line":53,"code":"      describe.each(common.PRIMARY_KEY_TYPES)('%s primary keys', pkType => {\n        it.each(vendors)('%s', async vendor => {\n          for (const setDefaultValues of [false, true]) {\n            // Delete existing collections\n            await deleteAllCollections(vendor, pkType, setDefaultValues);\n          }\n          await assertCollectionsDeleted(vendor, pkType);\n        }, 1200000);\n      });","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","GET /schema/snapshot","remove tables"],"line":54,"code":"        it.each(vendors)('%s', async vendor => {\n          for (const setDefaultValues of [false, true]) {\n            // Delete existing collections\n            await deleteAllCollections(vendor, pkType, setDefaultValues);\n          }\n          await assertCollectionsDeleted(vendor, pkType);\n        }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","retrieves empty snapshot"],"line":66,"code":"    it.each(vendors)('%s', async vendor => {\n      // Action\n      const response = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n      // Assert\n      expect(response.statusCode).toEqual(200);\n      expect(snapshotsCacheEmpty[vendor]).not.toEqual(snapshotsCacheOriginal[vendor]);\n      snapshotsCacheEmpty[vendor] = response.body.data;\n    }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/diff","denies non-admin users"],"line":78,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const currentVendor = vendor.replace(/[0-9]/g, '');\n        const response = await request(getUrl(vendor)).post('/schema/diff').send({\n          version: 1,\n          directus: currentDirectusVersion,\n          vendor: currentVendor,\n          collections: [],\n          fields: [],\n          relations: []\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.APP_ACCESS.TOKEN}`);\n        const response2 = await request(getUrl(vendor)).post('/schema/diff').send({\n          version: 1,\n          directus: currentDirectusVersion,\n          vendor: currentVendor,\n          collections: [],\n          fields: [],\n          relations: []\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.API_ONLY.TOKEN}`);\n        const response3 = await request(getUrl(vendor)).post('/schema/diff').send({\n          version: 1,\n          directus: currentDirectusVersion,\n          vendor: currentVendor,\n          collections: [],\n          fields: [],\n          relations: []\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.NO_ROLE.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(403);\n        expect(response2.statusCode).toEqual(403);\n        expect(response3.statusCode).toEqual(403);\n      });","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/diff","returns diffs with empty snapshot"],"line":113,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheEmpty[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        expect(response.statusCode).toEqual(204);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/diff","returns diffs with original snapshot"],"line":120,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        const collectionsCount = snapshotsCacheOriginal[vendor].collections.length - snapshotsCacheEmpty[vendor].collections.length;\n        const fieldsCount = snapshotsCacheOriginal[vendor].fields.length - snapshotsCacheEmpty[vendor].fields.length;\n        const relationsCount = snapshotsCacheOriginal[vendor].relations.length - snapshotsCacheEmpty[vendor].relations.length;\n\n        // Action\n        const response = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheOriginal[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(200);\n        expect(response.body.data?.diff?.collections?.length).toBe(collectionsCount);\n        expect(response.body.data?.diff?.fields?.length).toBe(fieldsCount);\n        expect(response.body.data?.diff?.relations?.length).toBe(relationsCount);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","denies non-admin users"],"line":139,"code":"      it.each(vendors)('%s', async vendor => {\n        // Action\n        const response = await request(getUrl(vendor)).post('/schema/apply').send({\n          data: true\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.APP_ACCESS.TOKEN}`);\n        const response2 = await request(getUrl(vendor)).post('/schema/apply').send({\n          data: true\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.API_ONLY.TOKEN}`);\n        const response3 = await request(getUrl(vendor)).post('/schema/apply').send({\n          data: true\n        }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.NO_ROLE.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(403);\n        expect(response2.statusCode).toEqual(403);\n        expect(response3.statusCode).toEqual(403);\n      });","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies a snapshot (JSON)"],"line":158,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheOriginal[vendor]).toBeDefined();\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheOriginal[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","retrieves the same snapshot after applying a snapshot (JSON)"],"line":170,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheOriginal[vendor]).toBeDefined();\n\n        // Action\n        const response = await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const curSnapshot = cloneDeep(response.body.data);\n        const oldSnapshot = cloneDeep(snapshotsCacheOriginal[vendor]);\n        parseSnapshot(vendor, curSnapshot);\n        parseSnapshot(vendor, oldSnapshot);\n\n        // Assert\n        expect(response.statusCode).toEqual(200);\n        expect(curSnapshot).toStrictEqual(oldSnapshot);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies empty snapshot"],"line":186,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheEmpty[vendor]).toBeDefined();\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheEmpty[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s primary keys","suites":["Schema Snapshots","POST /schema/apply","ensure that tables are removed"],"line":198,"code":"      describe.each(common.PRIMARY_KEY_TYPES)('%s primary keys', pkType => {\n        it.each(vendors)('%s', async vendor => {\n          await assertCollectionsDeleted(vendor, pkType);\n        }, 600000);\n      });","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","ensure that tables are removed"],"line":199,"code":"        it.each(vendors)('%s', async vendor => {\n          await assertCollectionsDeleted(vendor, pkType);\n        }, 600000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies a snapshot (YAML) with multipart/form-data requests"],"line":205,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheOriginalYaml[vendor]).toBeDefined();\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').attach('file', Buffer.from(snapshotsCacheOriginalYaml[vendor])).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').attach('file', Buffer.from(JSON.stringify(responseDiff.body.data))).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","retrieves the same snapshot after applying a snapshot (YAML)"],"line":217,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheOriginalYaml[vendor]).toBeDefined();\n\n        // Action\n        const response = await request(getUrl(vendor)).get('/schema/snapshot').query({\n          export: 'yaml'\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const curSnapshot = await loadYaml(response.text);\n        const oldSnapshot = cloneDeep(snapshotsCacheOriginal[vendor]);\n        parseSnapshot(vendor, curSnapshot);\n        parseSnapshot(vendor, oldSnapshot);\n\n        // Assert\n        expect(response.statusCode).toEqual(200);\n        expect(curSnapshot).toStrictEqual(oldSnapshot);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies lhs that is not an object"],"line":235,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheOriginal[vendor]).toBeDefined();\n\n        // Setup\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          await request(getUrl(vendor)).patch(`/collections/${collectionAll}_${pkType}`).send({\n            meta: {\n              icon: 'abc',\n              color: '#E35169'\n            }\n          }).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheOriginal[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies Array type diffs"],"line":257,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const nameField = (await request(getUrl(vendor)).get(`/fields/${collectionAll}_${pkType}/name`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n          nameField.meta.translations = [{\n            language: 'en-US',\n            translation: `${pkType} name`\n          }, {\n            language: 'nl-NL',\n            translation: `${pkType} naam`\n          }];\n          await request(getUrl(vendor)).patch(`/fields/${collectionAll}_${pkType}/name`).send(nameField).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n        const newSnapshot = (await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const nameField = (await request(getUrl(vendor)).get(`/fields/${collectionAll}_${pkType}/name`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n          nameField.meta.translations = [{\n            language: 'en-US',\n            translation: `${pkType} name`\n          }, {\n            language: 'es-ES',\n            translation: `${pkType} nombre`\n          }, {\n            language: 'nl-NL',\n            translation: `${pkType} naam`\n          }];\n          await request(getUrl(vendor)).patch(`/fields/${collectionAll}_${pkType}/name`).send(nameField).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(newSnapshot).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","applies with field meta changes"],"line":295,"code":"      it.each(vendors)('%s', async vendor => {\n        // Setup\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const fields = (await request(getUrl(vendor)).get(`/fields/${collectionAll}_${pkType}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data.map(field => {\n            return field.field;\n          });\n          fields.sort();\n          const payload = fields.map((field, index) => {\n            return {\n              field,\n              meta: {\n                sort: index + 1\n              }\n            };\n          });\n          await request(getUrl(vendor)).patch(`/fields/${collectionAll}_${pkType}`).send(payload).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n        const newSnapshot = (await request(getUrl(vendor)).get('/schema/snapshot').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const fields = (await request(getUrl(vendor)).get(`/fields/${collectionAll}_${pkType}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data.map(field => {\n            return field.field;\n          });\n          fields.sort().reverse();\n          const payload = fields.map((field, index) => {\n            return {\n              field,\n              meta: {\n                sort: index + 1\n              }\n            };\n          });\n          await request(getUrl(vendor)).patch(`/fields/${collectionAll}_${pkType}`).send(payload).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(newSnapshot).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","POST /schema/apply","confirm deletion of relational field does not nullify existing relational fields"],"line":338,"code":"      it.each(vendors)('%s', async vendor => {\n        // TODO: Fix cockroachdb requiring schema changes to be applied first when in a transaction\n        if (vendor === 'cockroachdb') {\n          expect(true).toBe(true);\n          return;\n        }\n        expect(snapshotsCacheOriginal[vendor]).toBeDefined();\n\n        // Setup\n        const childrenIDs = {};\n        const tempRelationalField = 'temp_relational';\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const item = await common.CreateItem(vendor, {\n            collection: `${collectionAll}_${pkType}`,\n            item: {\n              id: pkType === 'string' ? uuid() : undefined,\n              all_id: {\n                id: pkType === 'string' ? uuid() : undefined\n              },\n              o2m: [{\n                id: pkType === 'string' ? uuid() : undefined\n              }]\n            }\n          });\n          childrenIDs[pkType] = {\n            id: item.id,\n            m2o_id: item.all_id,\n            o2m_id: item.o2m[0]\n          };\n          await common.CreateFieldM2O(vendor, {\n            collection: `${collectionAll}_${pkType}`,\n            field: tempRelationalField,\n            otherCollection: collectionSelf\n          });\n        }\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheOriginal[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(204);\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          const item = (await request(getUrl(vendor)).get(`/items/${collectionAll}_${pkType}/${childrenIDs[pkType].id}`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`)).body.data;\n          expect(item.all_id).toBe(childrenIDs[pkType].m2o_id);\n          expect(item.o2m).toHaveLength(1);\n          expect(item.o2m[0]).toBe(childrenIDs[pkType].o2m_id);\n        }\n      }, 300000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","Hash Tests","with deleted fields"],"line":392,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheEmpty[vendor]).toBeDefined();\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheEmpty[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        for (const pkType of PRIMARY_KEY_TYPES) {\n          await request(getUrl(vendor)).delete(`/fields/${collectionSelf}_${pkType}/self_id`).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        }\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(400);\n        expect(response.text).toContain('Please generate a new diff and try again.');\n      }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["Schema Snapshots","Hash Tests","with new collection"],"line":408,"code":"      it.each(vendors)('%s', async vendor => {\n        expect(snapshotsCacheEmpty[vendor]).toBeDefined();\n\n        // Action\n        const responseDiff = await request(getUrl(vendor)).post('/schema/diff').send(snapshotsCacheEmpty[vendor]).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        await request(getUrl(vendor)).post(`/collections`).send({\n          collection: tempTestCollection,\n          fields: [{\n            field: 'id',\n            type: 'integer',\n            meta: {\n              hidden: true,\n              interface: 'input',\n              readonly: true\n            },\n            schema: {\n              is_primary_key: true,\n              has_auto_increment: true\n            }\n          }],\n          schema: {},\n          meta: {\n            singleton: false\n          }\n        }).set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n        const response = await request(getUrl(vendor)).post('/schema/apply').send(responseDiff.body.data).set('Content-type', 'application/json').set('Authorization', `Bearer ${common.USER.ADMIN.TOKEN}`);\n\n        // Assert\n        expect(response.statusCode).toEqual(400);\n        expect(response.text).toContain('Please generate a new diff and try again.');\n      }, 1200000);","file":"blackbox/routes/schema/schema.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/server","GET /health"],"line":10,"code":"        it.each(vendors)('%s', async vendor => {\n          // Action\n          const response = await request(getUrl(vendor)).get('/server/health').set('Authorization', `Bearer ${common.USER[userKey].TOKEN}`);\n          const gqlResponse = await requestGraphQL(getUrl(vendor), true, common.USER[userKey].TOKEN, {\n            query: {\n              server_health: true\n            }\n          });\n\n          // Assert\n          expect(response.statusCode).toBe(200);\n          expect(gqlResponse.statusCode).toBe(200);\n          if (userKey === common.USER.ADMIN.KEY) {\n            const adminResult = {\n              status: 'ok',\n              releaseId: expect.any(String),\n              serviceId: expect.any(String),\n              checks: expect.anything()\n            };\n            expect(response.body).toEqual(adminResult);\n            expect(gqlResponse.body.data.server_health).toEqual(adminResult);\n          } else {\n            const nonAdminResult = {\n              status: 'ok'\n            };\n            expect(response.body).toEqual(nonAdminResult);\n            expect(gqlResponse.body.data.server_health).toEqual(nonAdminResult);\n          }\n        });","file":"blackbox/routes/server/health.test.ts","skipped":false,"dir":"tests"},{"name":"%s","suites":["/server","GET /ping"],"line":7,"code":"    it.each(vendors)('%s', async vendor => {\n      // Action\n      const response = await request(getUrl(vendor)).get('/server/ping').expect('Content-Type', /text\\/html/).expect(200);\n      const gqlResponse = await requestGraphQL(getUrl(vendor), true, null, {\n        query: {\n          server_ping: true\n        }\n      });\n\n      // Assert\n      expect(response.text).toBe('pong');\n      expect(gqlResponse.body.data.server_ping).toBe('pong');\n    });","file":"blackbox/routes/server/ping.test.ts","skipped":false,"dir":"tests"}]}