{"repo":"supabase/supabase","url":"https://github.com/supabase/supabase","branch":"master","configs":[{"lang":"js","dir":"examples/sveltejs-todo-list/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"supabase","lang":"js","dir":"tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"},{"package":"studio","lang":"ts","dir":"studio/tests","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should validate typical URLs","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":4,"column":36},"line":4,"code":"  test('should validate typical URLs', () => {\n    const mockInput1 = 'http://domain.com'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(true)\n\n    const mockInput2 = 'https://supabase.io'\n    const output2 = domainRegex.test(mockInput2)\n    expect(output2).toBe(true)\n\n    const mockInput3 = 'https://new-domain-vercel.com'\n    const output3 = domainRegex.test(mockInput3)\n    expect(output3).toBe(true)\n\n    const mockInput4 = 'www.test-domain.com'\n    const output4 = domainRegex.test(mockInput4)\n    expect(output4).toBe(true)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should validate subdomains","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":21,"column":34},"line":21,"code":"  test('should validate subdomains', () => {\n    const mockInput1 = 'https://app.supabase.com'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(true)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should validate localhost URLs","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":26,"column":38},"line":26,"code":"  test('should validate localhost URLs', () => {\n    const mockInput1 = 'http://localhost:3000'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(true)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should validate URLs with query params","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":31,"column":46},"line":31,"code":"  test('should validate URLs with query params', () => {\n    const mockInput1 = 'https://supabase.com?name=test'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(true)\n\n    const mockInput2 = 'https://supabase.com?name=test&description=hello&page=2'\n    const output2 = domainRegex.test(mockInput2)\n    expect(output2).toBe(true)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should validate URLs with wildcards","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":40,"column":43},"line":40,"code":"  test('should validate URLs with wildcards', () => {\n    const mockInput1 = 'https://supabase*.com'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(true)\n\n    const mockInput2 = 'https://supabase.com/*'\n    const output2 = domainRegex.test(mockInput2)\n    expect(output2).toBe(true)\n\n    const mockInput3 = 'https://new-*-domain.com/*'\n    const output3 = domainRegex.test(mockInput3)\n    expect(output3).toBe(true)\n\n    const mockInput4 = 'https://new-*-domain.com/*/*/*'\n    const output4 = domainRegex.test(mockInput4)\n    expect(output4).toBe(true)\n\n    const mockInput5 = 'https://sub-*-domain.new-*-domain.com/*/*/*'\n    const output5 = domainRegex.test(mockInput5)\n    expect(output5).toBe(true)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should invalidate invalid URLs","suites":["Auth.constants: domainRegex"],"updatePoint":{"line":61,"column":38},"line":61,"code":"  test('should invalidate invalid URLs', () => {\n    const mockInput1 = 'supabase'\n    const output1 = domainRegex.test(mockInput1)\n    expect(output1).toBe(false)\n\n    const mockInput2 = 'mailto:test@gmail.com'\n    const output2 = domainRegex.test(mockInput2)\n    expect(output2).toBe(false)\n\n    const mockInput4 = 'hello world.com'\n    const output4 = domainRegex.test(mockInput4)\n    expect(output4).toBe(false)\n\n    const mockInput5 = 'email@domain.com'\n    const output5 = domainRegex.test(mockInput5)\n    expect(output5).toBe(false)\n  })","file":"components/Auth/Auth.constants.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return varchar properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":4,"column":38},"line":4,"code":"  test('should return varchar properly', () => {\n    const mockInput = \"'potato'::character varying\"\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('potato')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return text properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":9,"column":35},"line":9,"code":"  test('should return text properly', () => {\n    const mockInput = \"'tomato'::text\"\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('tomato')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return null properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":14,"column":35},"line":14,"code":"  test('should return null properly', () => {\n    const mockInput = null\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual(null)\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return empty string properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":19,"column":43},"line":19,"code":"  test('should return empty string properly', () => {\n    const mockInput = `''::text`\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return numerical arrays properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":24,"column":47},"line":24,"code":"  test('should return numerical arrays properly', () => {\n    const mockInput = \"'{1,2,3,4}'::integer[]\"\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('[1,2,3,4]')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return string arrays properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":29,"column":44},"line":29,"code":"  test('should return string arrays properly', () => {\n    const mockInput = \"'{apple,orange}'::text[]\"\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('[\"apple\",\"orange\"]')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return single word functions as they are","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":34,"column":55},"line":34,"code":"  test('should return single word functions as they are', () => {\n    const mockInput = 'uuid_generate_v4()'\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual(mockInput)\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return functions beyond one word properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":39,"column":56},"line":39,"code":"  test('should return functions beyond one word properly', () => {\n    const mockInput = \"(now() AT TIME ZONE 'utc'::text)\"\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual(\"(now() at time zone 'utc')\")\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return expressions that combine values properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":44,"column":62},"line":44,"code":"  test('should return expressions that combine values properly', () => {\n    const mockInput1 = \"('hi_'::text || uuid_generate_v4())\"\n    const value1 = unescapeLiteral(mockInput1)\n    expect(value1).toStrictEqual(\"('hi_' || uuid_generate_v4())\")\n\n    const mockInput2 = \"(('hi'::text || 'bye'::text) || 'hello'::text)\"\n    const value2 = unescapeLiteral(mockInput2)\n    expect(value2).toStrictEqual(\"(('hi' || 'bye') || 'hello')\")\n\n    const mockInput3 = \"(uuid_generate_v4() || 'hello'::text)\"\n    const value3 = unescapeLiteral(mockInput3)\n    expect(value3).toStrictEqual(\"(uuid_generate_v4() || 'hello')\")\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return json object properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":57,"column":42},"line":57,"code":"  test('should return json object properly', () => {\n    const mockInput = `'{\\\"version\\\": 10, \\\"dimensions\\\": {\\\"width\\\": 50, \\\"height\\\": 20}}'::jsonb`\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('{\"version\": 10, \"dimensions\": {\"width\": 50, \"height\": 20}}')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return json array properly","suites":["ColumnEditor.utils: unescapeLiteral"],"updatePoint":{"line":62,"column":41},"line":62,"code":"  test('should return json array properly', () => {\n    const mockInput = `'[{\\\"version\\\": 10}, {\\\"version\\\": 11}]'::jsonb`\n    const value = unescapeLiteral(mockInput)\n    expect(value).toStrictEqual('[{\"version\": 10}, {\"version\": 11}]')\n  })","file":"components/Editor/ColumnEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should validate for non-nullable fields correctly","suites":["RowEditor.utils: validateFields"],"updatePoint":{"line":4,"column":57},"line":4,"code":"  test('should validate for non-nullable fields correctly', () => {\n    const mockFields = [\n      {\n        name: 'name',\n        value: '',\n        format: 'text',\n        defaultValue: null,\n        isNullable: false,\n      },\n      {\n        name: 'age',\n        value: 0,\n        format: 'int8',\n        defaultValue: null,\n        isNullable: false,\n      },\n      {\n        name: 'height',\n        value: '',\n        format: 'int2',\n        defaultValue: null,\n        isNullable: false,\n      },\n      {\n        name: 'weight',\n        value: '',\n        format: 'int2',\n        defaultValue: null,\n        isNullable: true,\n      },\n    ]\n    const res = validateFields(mockFields)\n    expect(res).toHaveProperty('name')\n    expect(res).not.toHaveProperty('age')\n    expect(res).toHaveProperty('height')\n    expect(res).not.toHaveProperty('weight')\n  })","file":"components/Editor/RowEditor.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should default column type to text if no rows to infer from","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":4,"column":67},"line":4,"code":"  test('should default column type to text if no rows to infer from', () => {\n    const mockData = []\n    const type = inferColumnType('id', mockData)\n    expect(type).toBe('text')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should default column type to text if the first row has no data to infer from","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":9,"column":85},"line":9,"code":"  test('should default column type to text if the first row has no data to infer from', () => {\n    const mockData = [{ name: 'bob', age: '42' }]\n    const type = inferColumnType('id', mockData)\n    expect(type).toBe('text')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should default column type to text if the first row data value is null","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":14,"column":78},"line":14,"code":"  test('should default column type to text if the first row data value is null', () => {\n    const mockData = [{ id: 'null', name: 'bob', age: '42' }]\n    const type = inferColumnType('id', mockData)\n    expect(type).toBe('text')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should infer integer types correctly","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":19,"column":44},"line":19,"code":"  test('should infer integer types correctly', () => {\n    const mockData = [{ name: 'bob', age: '42' }]\n    const type = inferColumnType('age', mockData)\n    expect(type).toBe('int8')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should infer float types correctly","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":24,"column":42},"line":24,"code":"  test('should infer float types correctly', () => {\n    const mockData = [{ name: 'bob', height: '161.72' }]\n    const type = inferColumnType('height', mockData)\n    expect(type).toBe('float8')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should infer boolean types correctly","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":29,"column":44},"line":29,"code":"  test('should infer boolean types correctly', () => {\n    const mockData1 = [{ name: 'bob', height: '161.72', isWorking: 'true' }]\n    const type1 = inferColumnType('isWorking', mockData1)\n    expect(type1).toBe('boolean')\n\n    const mockData2 = [{ name: 'bob', height: '161.72', isRetired: 'false' }]\n    const type2 = inferColumnType('isRetired', mockData2)\n    expect(type2).toBe('boolean')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should infer boolean type for a supposed boolean column if one of the rows has a null value","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":38,"column":99},"line":38,"code":"  test('should infer boolean type for a supposed boolean column if one of the rows has a null value', () => {\n    const mockData3 = [\n      { name: 'bob', height: '161.72', isRetired: 'false' },\n      { name: 'bob', height: '161.72', isRetired: 'true' },\n      { name: 'bob', height: '161.72', isRetired: null },\n    ]\n    const type3 = inferColumnType('isRetired', mockData3)\n    expect(type3).toBe('boolean')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should infer objects as jsonb types correctly","suites":["SpreadsheedImport.utils: inferColumnType"],"updatePoint":{"line":47,"column":53},"line":47,"code":"  test('should infer objects as jsonb types correctly', () => {\n    const mockData = [{ name: 'bob', metadata: '{}' }]\n    const type = inferColumnType('metadata', mockData)\n    expect(type).toBe('jsonb')\n  })","file":"components/Editor/SpreadsheetImport.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return an array of sort options based on URL params","suites":["SupabaseGrid.utils: formatSortURLParams"],"updatePoint":{"line":6,"column":66},"line":6,"code":"  test('should return an array of sort options based on URL params', () => {\n    const mockInput = ['id:asc', 'name:desc']\n    const output = formatSortURLParams(mockInput)\n    expect(output).toStrictEqual([\n      {\n        column: 'id',\n        ascending: true,\n      },\n      {\n        column: 'name',\n        ascending: false,\n      },\n    ])\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should reject any malformed sort options based on URL params","suites":["SupabaseGrid.utils: formatSortURLParams"],"updatePoint":{"line":20,"column":68},"line":20,"code":"  test('should reject any malformed sort options based on URL params', () => {\n    const mockInput = ['id', 'name:asc', ':asc']\n    const output = formatSortURLParams(mockInput)\n    expect(output).toStrictEqual([\n      {\n        column: 'name',\n        ascending: true,\n      },\n    ])\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should return an array of filter options based on URL params","suites":["SupabaseGrid.utils: formatFilterURLParams"],"updatePoint":{"line":34,"column":68},"line":34,"code":"  test('should return an array of filter options based on URL params', () => {\n    const mockInput = ['id:gte:20', 'id:lte:40']\n    const output = formatFilterURLParams(mockInput)\n    expect(output).toHaveLength(2)\n    expect(output[0]).toStrictEqual({\n      column: 'id',\n      operator: '>=',\n      value: '20',\n    })\n    expect(output[1]).toStrictEqual({\n      column: 'id',\n      operator: '<=',\n      value: '40',\n    })\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should format filters for timestamps correctly","suites":["SupabaseGrid.utils: formatFilterURLParams"],"updatePoint":{"line":49,"column":54},"line":49,"code":"  test('should format filters for timestamps correctly', () => {\n    const mockInput = ['created_at:gte:2022-05-30 03:00:00']\n    const output = formatFilterURLParams(mockInput)\n    expect(output[0]).toStrictEqual({\n      column: 'created_at',\n      operator: '>=',\n      value: '2022-05-30 03:00:00',\n    })\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should reject any malformed filter options based on URL params","suites":["SupabaseGrid.utils: formatFilterURLParams"],"updatePoint":{"line":58,"column":70},"line":58,"code":"  test('should reject any malformed filter options based on URL params', () => {\n    const mockInput = ['id', ':gte', ':50', 'id:eq:10']\n    const output = formatFilterURLParams(mockInput)\n    expect(output).toHaveLength(1)\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should reject any filter options with unrecognized operator","suites":["SupabaseGrid.utils: formatFilterURLParams"],"updatePoint":{"line":63,"column":67},"line":63,"code":"  test('should reject any filter options with unrecognized operator', () => {\n    const mockInput = ['id:meme:40', 'name:eq:town']\n    const output = formatFilterURLParams(mockInput)\n    expect(output).toHaveLength(1)\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should allow filter options to have empty value based on URL params","suites":["SupabaseGrid.utils: formatFilterURLParams"],"updatePoint":{"line":68,"column":75},"line":68,"code":"  test('should allow filter options to have empty value based on URL params', () => {\n    const mockInput = ['id:ilike:']\n    const output = formatFilterURLParams(mockInput)\n    expect(output).toHaveLength(1)\n    expect(output[0]).toStrictEqual({\n      column: 'id',\n      operator: '~~*',\n      value: '',\n    })\n  })","file":"components/Grid/Grid.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"mounts correctly","suites":[],"updatePoint":{"line":62,"column":22},"line":62,"code":"test('mounts correctly', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('usage')) return {}\n    if (url.includes('subscription')) return {}\n    return { data: MOCK_CHART_DATA }\n  })\n  render(<ProjectUsage project=\"12345\" />)\n  await waitFor(() => screen.getByText(/Statistics for past 24 hours/))\n  await waitFor(() => screen.getByText(/123/))\n  await waitFor(() => screen.getByText(/223/))\n  await waitFor(() => screen.getByText(/323/))\n  await waitFor(() => screen.getByText(/333/))\n})","file":"components/Home/ProjectUsage.test.js","skipped":false,"dir":"studio/tests"},{"name":"dropdown options changes chart query","suites":[],"updatePoint":{"line":76,"column":42},"line":76,"code":"test('dropdown options changes chart query', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('usage')) return {}\n    return { data: MOCK_CHART_DATA }\n  })\n  render(<ProjectUsage project=\"12345\" />)\n  await waitFor(() => screen.getByText(/Statistics for past 24 hours/))\n  await waitFor(() => screen.getAllByRole('button', { name: '24 hours' }))\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('interval=hourly'))\n  })\n  // find button that has radix id\n  const [btn] = screen.getAllByRole('button', { name: '24 hours' }).filter((e) => e.id)\n  clickDropdown(btn)\n  await waitFor(() => screen.getByText(/7 days/))\n  await waitFor(() => screen.getByText(/60 minutes/))\n\n  // simulate changing of dropdown\n  userEvent.click(screen.getByText(/60 minutes/))\n  await waitFor(() => screen.getByText(/Statistics for past 60 minutes/))\n  expect(get).toHaveBeenCalledWith(expect.stringContaining('interval=minutely'))\n})","file":"components/Home/ProjectUsage.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert 1024 to 1KB","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":8,"column":34},"line":8,"code":"  test('should convert 1024 to 1KB', () => {\n    const mockInput = 1024\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 1, unit: StorageSizeUnits.KB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert 5242880 to 50MB","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":13,"column":38},"line":13,"code":"  test('should convert 5242880 to 50MB', () => {\n    const mockInput = 52428800\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 50, unit: StorageSizeUnits.MB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert 100 to 100 bytes","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":18,"column":39},"line":18,"code":"  test('should convert 100 to 100 bytes', () => {\n    const mockInput = 100\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 100, unit: StorageSizeUnits.BYTES })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert 5712306503.68 to 5.32GB","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":23,"column":46},"line":23,"code":"  test('should convert 5712306503.68 to 5.32GB', () => {\n    const mockInput = 5712306503.68\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 5.32, unit: StorageSizeUnits.GB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert 9123162431 to 8.496607123874128GB","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":28,"column":56},"line":28,"code":"  test('should convert 9123162431 to 8.496607123874128GB', () => {\n    const mockInput = 9123162431\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 8.496607123874128, unit: StorageSizeUnits.GB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert negative inputs to just 0","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":33,"column":48},"line":33,"code":"  test('should convert negative inputs to just 0', () => {\n    const mockInput = -1000\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 0, unit: StorageSizeUnits.BYTES })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should convert up to GB","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":38,"column":31},"line":38,"code":"  test('should convert up to GB', () => {\n    const mockInput = 10737418240000\n    const output = convertFromBytes(mockInput)\n    expect(output).toStrictEqual({ value: 10000, unit: StorageSizeUnits.GB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert given input into specific output unit","suites":["StorageSettings.utils: convertFromBytes"],"updatePoint":{"line":43,"column":71},"line":43,"code":"  test('should be able to convert given input into specific output unit', () => {\n    const mockInput1 = 5368709120\n    const output1 = convertFromBytes(mockInput1, StorageSizeUnits.GB)\n    expect(output1).toStrictEqual({ value: 5, unit: StorageSizeUnits.GB })\n\n    const mockInput2 = 5368709120\n    const output2 = convertFromBytes(mockInput2, StorageSizeUnits.MB)\n    expect(output2).toStrictEqual({ value: 5120, unit: StorageSizeUnits.MB })\n\n    const mockInput3 = 5368709120\n    const output3 = convertFromBytes(mockInput3, StorageSizeUnits.KB)\n    expect(output3).toStrictEqual({ value: 5242880, unit: StorageSizeUnits.KB })\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert to bytes","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":59,"column":42},"line":59,"code":"  test('should be able to convert to bytes', () => {\n    const mockInput = 100\n    const output = convertToBytes(mockInput)\n    expect(output).toStrictEqual(100)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert to KB","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":64,"column":39},"line":64,"code":"  test('should be able to convert to KB', () => {\n    const output = convertToBytes(10, StorageSizeUnits.KB)\n    expect(output).toStrictEqual(10240)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert to MB","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":68,"column":39},"line":68,"code":"  test('should be able to convert to MB', () => {\n    const output = convertToBytes(51.2, StorageSizeUnits.MB)\n    expect(output).toStrictEqual(53687091.2)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert to GB","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":72,"column":39},"line":72,"code":"  test('should be able to convert to GB', () => {\n    const output = convertToBytes(10.21, StorageSizeUnits.GB)\n    expect(output).toStrictEqual(10962904023.04)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to convert up to GB only","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":76,"column":47},"line":76,"code":"  test('should be able to convert up to GB only', () => {\n    const output = convertToBytes(1.21, 'ZB')\n    expect(output).toStrictEqual(0)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"should be able to handle negative inputs","suites":["StorageSettings.utils: convertToBytes"],"updatePoint":{"line":80,"column":48},"line":80,"code":"  test('should be able to handle negative inputs', () => {\n    const output = convertToBytes(-12312, StorageSizeUnits.KB)\n    expect(output).toStrictEqual(0)\n  })","file":"components/Storage/StorageSettings.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"renders chart","suites":[],"updatePoint":{"line":16,"column":19},"line":16,"code":"test('renders chart', async () => {\n  const mockFn = jest.fn()\n  const tsMicro = new Date().getTime() * 1000\n  render(\n    <LogEventChart\n      data={[{ timestamp: tsMicro }, { timestamp: tsMicro + 1 }]}\n      onBarClick={mockFn}\n    />\n  )\n  // TODO: figure out how to test rechart bar chart rendering, svg does not get rendered for some reason.\n  // should only have one bar rendered\n  // await waitFor(\n  //   () => {\n  //     const paths = container.querySelectorAll('path')\n  //     console.log(paths)\n  //     expect(paths.length).toBe(1)\n  //   },\n  //   { timeout: 1000 }\n  // )\n  // userEvent.click(paths[0])\n  // expect(mock).toBeCalledTimes(1)\n  await screen.findByText('Events')\n})","file":"pages/projects/LogEventChart.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display log data","suites":[],"updatePoint":{"line":85,"column":26},"line":85,"code":"test('can display log data', async () => {\n  get.mockResolvedValue({\n    result: [\n      logDataFixture({\n        id: 'some-event-happened',\n        metadata: {\n          my_key: 'something_value',\n        },\n      }),\n    ],\n  })\n  const { container } = render(<LogsExplorerPage />)\n  let editor = container.querySelector('.monaco-editor')\n  await waitFor(() => {\n    editor = container.querySelector('.monaco-editor')\n    expect(editor).toBeTruthy()\n  })\n  // type new query\n  userEvent.type(editor, 'select \\ncount(*) as my_count \\nfrom edge_logs')\n\n  userEvent.click(await screen.findByText(/Run/))\n  const row = await screen.findByText('some-event-happened')\n  userEvent.click(row)\n  await screen.findByText(/something_value/)\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"q= query param will populate the query input","suites":[],"updatePoint":{"line":111,"column":50},"line":111,"code":"test('q= query param will populate the query input', async () => {\n  const router = defaultRouterMock()\n  router.query = { ...router.query, type: 'api', q: 'some_query' }\n  useRouter.mockReturnValue(router)\n  render(<LogsExplorerPage />)\n  // should populate editor with the query param\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('sql=some_query'))\n  })\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"ite= and its= query param will populate the datepicker","suites":[],"updatePoint":{"line":122,"column":60},"line":122,"code":"test('ite= and its= query param will populate the datepicker', async () => {\n  const router = defaultRouterMock()\n  const start = dayjs().subtract(1, 'day')\n  const end = dayjs()\n  router.query = {\n    ...router.query,\n    type: 'api',\n    q: 'some_query',\n    its: start.toISOString(),\n    ite: end.toISOString(),\n  }\n  useRouter.mockReturnValue(router)\n  render(<LogsExplorerPage />)\n  // should populate editor with the query param\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(\n      expect.stringContaining(encodeURIComponent(start.toISOString()))\n    )\n    expect(get).toHaveBeenCalledWith(expect.stringContaining(encodeURIComponent(end.toISOString())))\n  })\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"custom sql querying","suites":[],"updatePoint":{"line":144,"column":25},"line":144,"code":"test('custom sql querying', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('sql=') && url.includes('select')) {\n      return {\n        result: [\n          {\n            my_count: 12345,\n          },\n        ],\n      }\n    }\n    return { result: [] }\n  })\n  const { container } = render(<LogsExplorerPage />)\n  let editor = container.querySelector('.monaco-editor')\n  expect(editor).toBeTruthy()\n\n  // type into the query editor\n  await waitFor(() => {\n    editor = container.querySelector('.monaco-editor')\n    expect(editor).toBeTruthy()\n  })\n  editor = container.querySelector('.monaco-editor')\n  // type new query\n  userEvent.type(editor, 'select \\ncount(*) as my_count \\nfrom edge_logs')\n\n  // run query by button\n  userEvent.click(await screen.findByText('Run'))\n\n  // run query by editor\n  userEvent.type(editor, '\\nlimit 123{ctrl}{enter}')\n  await waitFor(\n    () => {\n      expect(get).toHaveBeenCalledWith(expect.stringContaining(encodeURI('\\n')))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('sql='))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('select'))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('edge_logs'))\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('iso_timestamp_start'))\n      expect(get).not.toHaveBeenCalledWith(expect.stringContaining('iso_timestamp_end')) // should not have an end date\n      expect(get).not.toHaveBeenCalledWith(expect.stringContaining('where'))\n      expect(get).not.toHaveBeenCalledWith(expect.stringContaining(encodeURIComponent('limit 123')))\n    },\n    { timeout: 1000 }\n  )\n\n  await screen.findByText(/my_count/) //column header\n  const rowValue = await screen.findByText(/12345/) // row value\n\n  // clicking on the row value should not show log selection panel\n  userEvent.click(rowValue)\n  await expect(screen.findByText(/Metadata/)).rejects.toThrow()\n\n  // should not see chronological features\n  await expect(screen.findByText(/Load older/)).rejects.toThrow()\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"datepicker interaction updates query params","suites":[],"updatePoint":{"line":200,"column":49},"line":200,"code":"test('datepicker interaction updates query params', async () => {\n  render(<LogsExplorerPage />)\n  clickDropdown(await screen.findByText(/Last day/))\n  userEvent.click(await screen.findByText(/Last 3 days/))\n\n  const router = useRouter()\n  expect(router.push).toBeCalledWith(\n    expect.objectContaining({\n      query: expect.objectContaining({\n        its: expect.any(String),\n      }),\n    })\n  )\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"query warnings","suites":[],"updatePoint":{"line":215,"column":20},"line":215,"code":"test('query warnings', async () => {\n  const router = defaultRouterMock()\n  router.query = {\n    ...router.query,\n    q: 'some_query',\n    its: dayjs().subtract(10, 'days').toISOString(),\n    ite: dayjs().toISOString(),\n  }\n  useRouter.mockReturnValue(router)\n  render(<LogsExplorerPage />)\n  await screen.findByText('1 warning')\n})","file":"pages/projects/logs-query.test.js","skipped":false,"dir":"studio/tests"},{"name":"renders warning","suites":[],"updatePoint":{"line":7,"column":21},"line":7,"code":"test('renders warning', async () => {\n  const from = dayjs().subtract(60, 'days')\n  const to = dayjs()\n  render(\n    <DatePickers\n      helpers={PREVIEWER_DATEPICKER_HELPERS}\n      to={to.toISOString()}\n      from={from.toISOString()}\n    />\n  )\n  userEvent.click(await screen.findByText(RegExp(from.format('DD MMM'))))\n  await screen.findByText(/memory errors/)\n})","file":"pages/projects/Logs.Datepickers.test.js","skipped":false,"dir":"studio/tests"},{"name":"%s","suites":[],"line":7,"code":"describe.each(Object.values(LogsTableName))('%s', (table) => {\n  const templates = SQL_FILTER_TEMPLATES[table]\n  const stringTemplateKey = Object.keys(templates).find((key) => {\n    if (typeof templates[key] === 'string' && key.split('.').length === 2) {\n      return true\n    } else {\n      false\n    }\n  })\n  const [root, child] = (stringTemplateKey || '').split('.')\n  describe.each([\n    { filter: { search_query: '' } },\n    { filter: { search_query: undefined } },\n    { filter: {} },\n    { filter: { search_query: '123test' }, contains: ['123test'] },\n    //   test behaviour with overrides\n    {\n      filter: { search_query: '123test', override: 'something' },\n      contains: ['123test', 'override', 'something'],\n    },\n    {\n      filter: { search_query: '', override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { search_query: undefined, override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { 'override.nested': 'something' },\n      contains: ['override.nested', 'something'],\n    },\n    // check for when string templates are set to false.\n    ...(stringTemplateKey\n      ? [\n          {\n            filter: { search_query: 'some-search-query', [root]: { [child]: false } },\n            excludes: [templates[stringTemplateKey], '()'],\n            contains: ['some-search-query'],\n          },\n        ]\n      : []),\n  ])('generates sql for filter $filter', ({ filter, contains = [], excludes = [] }) => {\n    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n      contains.forEach((str) => expect(generated).toContain(str))\n      excludes.forEach((str) => expect(generated).not.toContain(str))\n    })\n  })\n})","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"generates sql for filter $filter","suites":[],"line":17,"code":"  describe.each([\n    { filter: { search_query: '' } },\n    { filter: { search_query: undefined } },\n    { filter: {} },\n    { filter: { search_query: '123test' }, contains: ['123test'] },\n    //   test behaviour with overrides\n    {\n      filter: { search_query: '123test', override: 'something' },\n      contains: ['123test', 'override', 'something'],\n    },\n    {\n      filter: { search_query: '', override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { search_query: undefined, override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { override: 'something' },\n      contains: ['override', 'something'],\n    },\n    {\n      filter: { 'override.nested': 'something' },\n      contains: ['override.nested', 'something'],\n    },\n    // check for when string templates are set to false.\n    ...(stringTemplateKey\n      ? [\n          {\n            filter: { search_query: 'some-search-query', [root]: { [child]: false } },\n            excludes: [templates[stringTemplateKey], '()'],\n            contains: ['some-search-query'],\n          },\n        ]\n      : []),\n  ])('generates sql for filter $filter', ({ filter, contains = [], excludes = [] }) => {\n    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n      contains.forEach((str) => expect(generated).toContain(str))\n      excludes.forEach((str) => expect(generated).not.toContain(str))\n    })\n  })","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"generates query correctly","suites":[],"updatePoint":{"line":54,"column":35},"line":54,"code":"    test('generates query correctly', async () => {\n      const generated = genDefaultQuery(table, filter)\n      //   should not contain functions\n      expect(generated).not.toMatch(/function[ A-Za-z_-]+\\(.+\\).+\\{.+return.+\\}/)\n      expect(generated).not.toMatch(/\\=\\>|\\$\\{.+\\}/)\n      expect(generated).not.toContain('return')\n      contains.forEach((str) => expect(generated).toContain(str))\n      excludes.forEach((str) => expect(generated).not.toContain(str))\n    })","file":"pages/projects/Logs.utils.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display log data and metadata","suites":[],"updatePoint":{"line":85,"column":39},"line":85,"code":"test('can display log data and metadata', async () => {\n  get.mockResolvedValue({\n    result: [\n      logDataFixture({\n        id: 'some-event-happened-id',\n        metadata: {\n          my_key: 'something_value',\n        },\n      }),\n    ],\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('iso_timestamp_start'))\n    expect(get).not.toHaveBeenCalledWith(expect.stringContaining('iso_timestamp_end'))\n  })\n\n  fireEvent.click(await screen.findByText(/some-event-happened-id/))\n  await screen.findByText(/my_key/)\n  await screen.findByText(/something_value/)\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"Refresh page","suites":[],"updatePoint":{"line":108,"column":18},"line":108,"code":"test('Refresh page', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('count')) return { result: { count: 0 } }\n    return {\n      result: [\n        logDataFixture({\n          id: 'some-event-id',\n          metadata: { my_key: 'something_value' },\n        }),\n      ],\n    }\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  const row = await screen.findByText(/some-event-id/)\n  fireEvent.click(row)\n  await screen.findByText(/my_key/)\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"Search will trigger a log refresh","suites":[],"updatePoint":{"line":127,"column":39},"line":127,"code":"test('Search will trigger a log refresh', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('something')) {\n      return {\n        result: [logDataFixture({ id: 'some-event-id' })],\n      }\n    }\n    return { result: [] }\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  userEvent.type(screen.getByPlaceholderText(/Search events/), 'something{enter}')\n\n  await waitFor(\n    () => {\n      expect(get).toHaveBeenCalledWith(expect.stringContaining('something'))\n\n      // updates router query params\n      const router = useRouter()\n      expect(router.push).toHaveBeenCalledWith(\n        expect.objectContaining({\n          pathname: expect.any(String),\n          query: expect.objectContaining({\n            s: expect.stringContaining('something'),\n          }),\n        })\n      )\n    },\n    { timeout: 1500 }\n  )\n  await screen.findByText(/some-event-id/)\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"poll count for new messages","suites":[],"updatePoint":{"line":160,"column":33},"line":160,"code":"test('poll count for new messages', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('count')) {\n      return { result: [{ count: 125 }] }\n    }\n    return {\n      result: [logDataFixture({ id: 'some-uuid123' })],\n    }\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  await waitFor(() => screen.queryByText(/some-uuid123/) === null)\n  // should display new logs count\n  await waitFor(() => screen.getByText(/125/))\n\n  userEvent.click(screen.getByText(/Refresh/))\n  await waitFor(() => screen.queryByText(/125/) === null)\n  await screen.findByText(/some-uuid123/)\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"s= query param will populate the search bar","suites":[],"updatePoint":{"line":179,"column":49},"line":179,"code":"test('s= query param will populate the search bar', async () => {\n  const router = defaultRouterMock()\n  router.query = { ...router.query, s: 'someSearch' }\n  useRouter.mockReturnValue(router)\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  // should populate search input with the search param\n  await screen.findByDisplayValue('someSearch')\n  expect(get).toHaveBeenCalledWith(expect.stringContaining('someSearch'))\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"te= query param will populate the timestamp to input","suites":[],"updatePoint":{"line":189,"column":58},"line":189,"code":"test('te= query param will populate the timestamp to input', async () => {\n  // get time 20 mins before\n  const newDate = new Date()\n  newDate.setMinutes(new Date().getMinutes() - 20)\n  const iso = newDate.toISOString()\n  const router = defaultRouterMock()\n  router.query = { ...router.query, ite: iso }\n  useRouter.mockReturnValue(router)\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(\n      expect.stringContaining(`iso_timestamp_end=${encodeURIComponent(iso)}`)\n    )\n  })\n  userEvent.click(await screen.findByText('Custom'))\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"ts= query param will populate the timestamp from input","suites":[],"updatePoint":{"line":206,"column":60},"line":206,"code":"test('ts= query param will populate the timestamp from input', async () => {\n  // get time 20 mins before\n  const newDate = new Date()\n  newDate.setMinutes(new Date().getMinutes() - 20)\n  const iso = newDate.toISOString()\n  const router = defaultRouterMock()\n  router.query = { ...router.query, its: iso }\n  useRouter.mockReturnValue(router)\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(\n      expect.stringContaining(`iso_timestamp_start=${encodeURIComponent(iso)}`)\n    )\n  })\n  userEvent.click(await screen.findByText('Custom'))\n  await screen.findByText(new RegExp(newDate.getFullYear()))\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"load older btn will fetch older logs","suites":[],"updatePoint":{"line":225,"column":42},"line":225,"code":"test('load older btn will fetch older logs', async () => {\n  get.mockImplementation((url) => {\n    if (url.includes('count')) {\n      return {}\n    }\n    return {\n      result: [logDataFixture({ id: 'first event' })],\n    }\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  // should display first log but not second\n  await waitFor(() => screen.getByText('first event'))\n  await expect(screen.findByText('second event')).rejects.toThrow()\n\n  get.mockResolvedValueOnce({\n    result: [logDataFixture({ id: 'second event' })],\n  })\n  // should display first and second log\n  userEvent.click(await screen.findByText('Load older'))\n  await screen.findByText('first event')\n  await screen.findByText('second event')\n  expect(get).toHaveBeenCalledWith(expect.stringContaining('timestamp_end='))\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"bug: load older btn does not error out when previous page is empty","suites":[],"updatePoint":{"line":249,"column":72},"line":249,"code":"test('bug: load older btn does not error out when previous page is empty', async () => {\n  // bugfix for https://sentry.io/organizations/supabase/issues/2903331460/?project=5459134&referrer=slack\n  get.mockImplementation((url) => {\n    if (url.includes('count')) {\n      return {}\n    }\n    return { result: [] }\n  })\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  userEvent.click(await screen.findByText('Load older'))\n  // NOTE: potential race condition, since we are asserting that something DOES NOT EXIST\n  // wait for 500s to make sure all ui logic is complete\n  // need to wrap in act because internal react state is changing during this time.\n  await act(async () => await wait(100))\n\n  // clicking load older multiple times should not give error\n  await waitFor(() => {\n    expect(screen.queryByText(/Sorry/)).toBeNull()\n    expect(screen.queryByText(/An error occured/)).toBeNull()\n    expect(screen.queryByText(/undefined/)).toBeNull()\n  })\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"log event chart hide","suites":[],"updatePoint":{"line":273,"column":26},"line":273,"code":"test('log event chart hide', async () => {\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  await screen.findByText('Events')\n  const toggle = await screen.findByText(/Chart/)\n  userEvent.click(toggle)\n  await expect(screen.findByText('Events')).rejects.toThrow()\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"bug: nav backwards with params change results in ui changing","suites":[],"updatePoint":{"line":281,"column":66},"line":281,"code":"test('bug: nav backwards with params change results in ui changing', async () => {\n  // bugfix for https://sentry.io/organizations/supabase/issues/2903331460/?project=5459134&referrer=slack\n  get.mockImplementation((url) => {\n    if (url.includes('count')) {\n      return {}\n    }\n    return { data: [] }\n  })\n  const { container, rerender } = render(\n    <LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />\n  )\n\n  await expect(screen.findByDisplayValue('simple-query')).rejects.toThrow()\n\n  const router = defaultRouterMock()\n  router.query = { ...router.query, s: 'simple-query' }\n  useRouter.mockReturnValue(router)\n  rerender(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n\n  await screen.findByDisplayValue('simple-query')\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"bug: nav to explorer preserves newlines","suites":[],"updatePoint":{"line":303,"column":45},"line":303,"code":"test('bug: nav to explorer preserves newlines', async () => {\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  const router = useRouter()\n  userEvent.click(await screen.findByText(/Explore/))\n  await expect(router.push).toBeCalledWith(expect.stringContaining(encodeURIComponent('\\n')))\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"filters alter generated query","suites":[],"updatePoint":{"line":309,"column":35},"line":309,"code":"test('filters alter generated query', async () => {\n  render(<LogsPreviewer projectRef=\"123\" tableName={LogsTableName.EDGE} />)\n  userEvent.click(await screen.findByRole('button', { name: 'Status' }))\n  userEvent.click(await screen.findByText(/500 error codes/))\n  userEvent.click(await screen.findByText(/200 codes/))\n  userEvent.click(await screen.findByText(/Save/))\n\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('select'))\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('500'))\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('200'))\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('where'))\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('and'))\n  })\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"filters accept filterOverride","suites":[],"updatePoint":{"line":324,"column":35},"line":324,"code":"test('filters accept filterOverride', async () => {\n  render(\n    <LogsPreviewer\n      projectRef=\"123\"\n      tableName={LogsTableName.FUNCTIONS}\n      filterOverride={{ 'my.nestedkey': 'myvalue' }}\n    />\n  )\n\n  await waitFor(() => {\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('my.nestedkey'))\n    expect(get).toHaveBeenCalledWith(expect.stringContaining('myvalue'))\n  })\n})","file":"pages/projects/LogsPreviewer.test.js","skipped":false,"dir":"studio/tests"},{"name":"templates","suites":[],"line":12,"code":"test.todo('templates')","file":"pages/projects/LogsQueryPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"run and clear","suites":[],"updatePoint":{"line":14,"column":19},"line":14,"code":"test('run and clear', async () => {\n  const mockRun = jest.fn()\n  const mockClear = jest.fn()\n  render(<LogsQueryPanel warnings={[]} onRun={mockRun} onClear={mockClear} hasEditorValue />)\n  await expect(screen.findByPlaceholderText(/Search/)).rejects.toThrow()\n  const run = await screen.findByText(/Run/)\n  userEvent.click(run)\n  expect(mockRun).toBeCalled()\n  const clear = await screen.findByText(/Clear/)\n  userEvent.click(clear)\n  expect(mockClear).toBeCalled()\n})","file":"pages/projects/LogsQueryPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display log data","suites":[],"updatePoint":{"line":4,"column":26},"line":4,"code":"test('can display log data', async () => {\n  render(\n    <LogTable\n      data={[\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {\n            my_key: 'something_value',\n          },\n        },\n      ]}\n    />\n  )\n\n  const row = await screen.findByText(/some-uuid/)\n  userEvent.click(row)\n  await waitFor(() => screen.getByText(/my_key/))\n  await waitFor(() => screen.getByText(/something_value/))\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"dedupes log lines with exact id","suites":[],"updatePoint":{"line":26,"column":37},"line":26,"code":"test('dedupes log lines with exact id', async () => {\n  // chronological mode requires 4 columns\n  render(\n    <LogTable\n      data={[\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {},\n        },\n        {\n          id: 'some-uuid',\n          timestamp: 1621323232312,\n          event_message: 'some event happened',\n          metadata: {},\n        },\n      ]}\n    />\n  )\n\n  // should only have one element, this line will fail if there are >1 element\n  await screen.findByText(/some-uuid/)\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"can display custom columns and headers based on data input","suites":[],"updatePoint":{"line":51,"column":64},"line":51,"code":"test('can display custom columns and headers based on data input', async () => {\n  render(<LogTable data={[{ some_header: 'some_data', kinda: 123456 }]} />)\n  await waitFor(() => screen.getByText(/some_header/))\n  await waitFor(() => screen.getByText(/some_data/))\n  await waitFor(() => screen.getByText(/kinda/))\n  await waitFor(() => screen.getByText(/123456/))\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"toggle histogram","suites":[],"updatePoint":{"line":59,"column":22},"line":59,"code":"test('toggle histogram', async () => {\n  const mockFn = jest.fn()\n  render(<LogTable onHistogramToggle={mockFn} isHistogramShowing={true} />)\n  const toggle = await screen.getByText(/Histogram/)\n  userEvent.click(toggle)\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"error message handling","suites":[],"updatePoint":{"line":67,"column":28},"line":67,"code":"test('error message handling', async () => {\n  const { rerender } = render(<LogTable error=\"some \\nstring\" />)\n  await expect(screen.findByText('some \\nstring')).rejects.toThrow()\n  await screen.findByDisplayValue(/some/)\n  await screen.findByDisplayValue(/string/)\n\n  rerender(<LogTable error={{ my_error: 'some \\nstring' }} />)\n  await screen.findByText(/some \\\\nstring/)\n  await screen.findByText(/some/)\n  await screen.findByText(/string/)\n  await screen.findByText(/my_error/)\n})","file":"pages/projects/LogTable.test.js","skipped":false,"dir":"studio/tests"},{"name":"templates","suites":[],"line":13,"code":"test.todo('templates')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"filter input change and submit","suites":[],"updatePoint":{"line":30,"column":36},"line":30,"code":"test('filter input change and submit', async () => {\n  const mockFn = jest.fn()\n  render(<PreviewFilterPanel onSearch={mockFn} />)\n  expect(mockFn).not.toBeCalled()\n  const search = screen.getByPlaceholderText(/Search/)\n  userEvent.type(search, '12345{enter}')\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"filter input value","suites":[],"updatePoint":{"line":39,"column":24},"line":39,"code":"test('filter input value', async () => {\n  render(<PreviewFilterPanel defaultSearchValue={'1234'} />)\n  await screen.findByDisplayValue('1234')\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"Manual refresh","suites":[],"updatePoint":{"line":44,"column":20},"line":44,"code":"test('Manual refresh', async () => {\n  const mockFn = jest.fn()\n  render(<PreviewFilterPanel onRefresh={mockFn} />)\n  const btn = await screen.findByText(/Refresh/)\n  userEvent.click(btn)\n  expect(mockFn).toBeCalled()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"Datepicker dropdown","suites":[],"updatePoint":{"line":51,"column":25},"line":51,"code":"test('Datepicker dropdown', async () => {\n  render(<PreviewFilterPanel />)\n  clickDropdown(await screen.findByText(/Last day/))\n  userEvent.click(await screen.findByText(/Last 3 hours/))\n  await screen.findByText(/Last 3 hours/)\n  await expect(screen.findByText(/Last day/)).rejects.toThrow()\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"},{"name":"timestamp to/from filter default value","suites":[],"line":59,"code":"test.todo('timestamp to/from filter default value')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"timestamp to/from filter value change","suites":[],"line":69,"code":"test.todo('timestamp to/from filter value change')","file":"pages/projects/PreviewFilterPanel.test.js","skipped":true,"dir":"studio/tests"},{"name":"shortened count to K","suites":[],"updatePoint":{"line":97,"column":26},"line":97,"code":"test('shortened count to K', async () => {\n  render(<PreviewFilterPanel newCount={1234} />)\n  await screen.findByText(/1\\.2K/)\n})","file":"pages/projects/PreviewFilterPanel.test.js","skipped":false,"dir":"studio/tests"}]}