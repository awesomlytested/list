{"repo":"atlassian/react-beautiful-dnd","url":"https://github.com/atlassian/react-beautiful-dnd","branch":"master","configs":[{"package":"react-beautiful-dnd","lang":"js","dir":"cypress","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should reorder a list without a nonce","suites":["content security policy"],"updatePoint":{"line":32,"column":43},"line":32,"code":"  it('should reorder a list without a nonce', () => {\n    commonTest(`http://localhost:${ports.cspServer}`, 'contain');\n  });","file":"integration/content-security-policy.spec.js","skipped":false,"dir":"cypress"},{"name":"should reorder a list with a nonce","suites":["content security policy"],"updatePoint":{"line":35,"column":40},"line":35,"code":"  it('should reorder a list with a nonce', () => {\n    commonTest(`http://localhost:${ports.cspServer}/nonce`, 'contain');\n  });","file":"integration/content-security-policy.spec.js","skipped":false,"dir":"cypress"},{"name":"should reorder a list with a wrong nonce","suites":["content security policy"],"updatePoint":{"line":38,"column":46},"line":38,"code":"  it('should reorder a list with a wrong nonce', () => {\n    commonTest(`http://localhost:${ports.cspServer}/wrong-nonce`, 'not.contain');\n  });","file":"integration/content-security-policy.spec.js","skipped":false,"dir":"cypress"},{"name":"should not steal focus if not already focused when lifting","suites":["focus"],"updatePoint":{"line":4,"column":64},"line":4,"code":"  it('should not steal focus if not already focused when lifting', () => {\n    cy.visit('/iframe.html?id=board--dragging-a-clone'); // focusing on another handle\n\n    cy.get(getHandleSelector('1')).focus();\n    cy.focused().should('contain', 'id:1');\n    cy.get(getHandleSelector('2')).as('id:2').trigger('mousedown', {\n      button: 0\n    }).trigger('mousemove', {\n      button: 0,\n      clientX: 200,\n      clientY: 300,\n      force: true\n    }); // asserting id:2 is now dragging\n\n    cy.get(getHandleSelector('2')).should('have.attr', 'data-is-dragging', 'true'); // focus not stolen\n\n    cy.focused().should('contain', 'id:1');\n    cy.get(getHandleSelector('2')).trigger('mouseup', {\n      force: true\n    }) // clone will be unmounting during drop\n    .should('not.exist'); // getting post clone handle\n\n    cy.get(getHandleSelector('2')).should('have.attr', 'data-is-dragging', 'false'); // focus not stolen\n\n    cy.focused().should('contain', 'id:1');\n  });","file":"integration/focus.spec.js","skipped":false,"dir":"cypress"},{"name":"should maintain focus if dragging a clone","suites":["focus"],"updatePoint":{"line":30,"column":47},"line":30,"code":"  it('should maintain focus if dragging a clone', () => {\n    cy.visit('/iframe.html?id=board--dragging-a-clone'); // focusing on another handle\n\n    cy.get(getHandleSelector('2')).focus();\n    cy.focused().should('contain', 'id:2');\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.space\n    }); // asserting id:2 is now dragging\n\n    cy.get(getHandleSelector('2')).should('have.attr', 'data-is-dragging', 'true'); // focus maintained\n\n    cy.focused().should('contain', 'id:2');\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.arrowRight,\n      force: true\n    }).trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }) // clone will be unmounting during drop\n    .should('not.exist'); // getting post clone handle\n\n    cy.get(getHandleSelector('2')) // no longer dragging\n    .should('have.attr', 'data-is-dragging', 'false') // is in the second column (normally would loose focus moving between lists)\n    .closest(getDraggableSelector('BMO')); // focus maintained\n\n    cy.focused().should('contain', 'id:2');\n  });","file":"integration/focus.spec.js","skipped":false,"dir":"cypress"},{"name":"should give focus to a combine target","suites":["focus"],"updatePoint":{"line":57,"column":43},"line":57,"code":"  it('should give focus to a combine target', () => {\n    cy.visit('/iframe.html?id=board--with-combining-and-cloning');\n    cy.get(getHandleSelector('2')).focus();\n    cy.focused().should('contain', 'id:2');\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.space\n    }); // asserting id:2 is now dragging\n\n    cy.get(getHandleSelector('2')).should('have.attr', 'data-is-dragging', 'true'); // focus maintained\n\n    cy.focused().should('contain', 'id:2');\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.arrowRight,\n      force: true\n    }) // combining with item:1\n    .trigger('keydown', {\n      keyCode: keyCodes.arrowUp,\n      force: true\n    }) // dropping\n    .trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }) // clone will be unmounting during drop\n    .should('not.exist'); // focus giving to item:1 the combine target\n\n    cy.focused().should('contain', 'id:1');\n  });","file":"integration/focus.spec.js","skipped":false,"dir":"cypress"},{"name":"should not give focus to a combine target if source did not have focus at start of drag","suites":["focus"],"updatePoint":{"line":84,"column":93},"line":84,"code":"  it('should not give focus to a combine target if source did not have focus at start of drag', () => {\n    cy.visit('/iframe.html?id=board--with-combining-and-cloning'); // focusing on something unrelated to the drag\n\n    cy.get(getHandleSelector('3')).focus();\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.space\n    }); // asserting id:2 is now dragging\n\n    cy.get(getHandleSelector('2')).should('have.attr', 'data-is-dragging', 'true'); // focus not stolen\n\n    cy.focused().should('contain', 'id:3');\n    cy.get(getHandleSelector('2')).trigger('keydown', {\n      keyCode: keyCodes.arrowRight,\n      force: true\n    }) // combining with item:1\n    .trigger('keydown', {\n      keyCode: keyCodes.arrowUp,\n      force: true\n    }) // dropping\n    .trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }) // clone will be unmounting during drop\n    .should('not.exist'); // focus not given to the combine target\n\n    cy.focused().should('contain', 'id:3');\n  });","file":"integration/focus.spec.js","skipped":false,"dir":"cypress"},{"name":"should move between lists","suites":["move between lists"],"updatePoint":{"line":8,"column":31},"line":8,"code":"  it('should move between lists', () => {\n    // first list has item with id:2\n    cy.get(getDroppableSelector()).eq(1).as('first-list').should('contain', 'id:2'); // second list does not have item with id:2\n\n    cy.get(getDroppableSelector()).eq(2).as('second-list').should('not.contain', 'id:2');\n    cy.get('@first-list').find(getHandleSelector()).first().should('contain', 'id:2').focus().trigger('keydown', {\n      keyCode: keyCodes.space\n    }).trigger('keydown', {\n      keyCode: keyCodes.arrowRight,\n      force: true\n    }) // finishing before the movement time is fine - but this looks nice\n    .wait(timings.outOfTheWay * 1000).trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }); // no longer in the first list\n\n    cy.get('@first-list').should('not.contain', 'id:2'); // now in the second list\n\n    cy.get('@second-list').should('contain', 'id:2');\n  });","file":"integration/move-between-lists.spec.js","skipped":false,"dir":"cypress"},{"name":"should reorder lists","suites":["reorder lists"],"updatePoint":{"line":8,"column":26},"line":8,"code":"  it('should reorder lists', () => {\n    // order: Jake, BMO\n    cy.get('h4').eq(0).as('first').should('contain', 'Jake');\n    cy.get('h4').eq(1).should('contain', 'BMO'); // reorder operation\n\n    cy.get('@first').closest(getHandleSelector()).focus().trigger('keydown', {\n      keyCode: keyCodes.space\n    }).trigger('keydown', {\n      keyCode: keyCodes.arrowRight,\n      force: true\n    }) // finishing before the movement time is fine - but this looks nice\n    .wait(timings.outOfTheWay * 1000).trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }); // order now 2, 1\n    // note: not using get aliases as they where returning incorrect results\n\n    cy.get('h4').eq(0).should('contain', 'BMO'); // index of the drag handle has changed\n\n    cy.get('h4').eq(1).should('contain', 'Jake');\n  });","file":"integration/reorder-lists.spec.js","skipped":false,"dir":"cypress"},{"name":"should reorder within a list","suites":["reorder: virtual"],"updatePoint":{"line":8,"column":34},"line":8,"code":"  it('should reorder within a list', () => {\n    const movements = 12;\n    cy.get(getHandleSelector()).first().as('item');\n    cy.get('@item').invoke('attr', 'data-testid').as('item-id');\n    cy.get('@item').invoke('attr', 'data-index').as('item-index').should('equal', '0'); // lift\n\n    cy.get('@item').focus().trigger('keydown', {\n      keyCode: keyCodes.space\n    }) // need to re-query for a clone\n    .get('@item');\n    cy.wrap(Array.from({\n      length: movements\n    })).each(() => {\n      cy.get('@item').trigger('keydown', {\n        keyCode: keyCodes.arrowDown,\n        force: true\n      }) // finishing before the movement time is fine - but this looks nice\n      // waiting longer than we should (timings.outOfTheWay * 1000) as electron is being strange\n      .wait(timings.outOfTheWay * 1000 * 2);\n    }); // drop\n\n    cy.get('@item').trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }); // This is setting up a chain of commands and this test will not wait\n    // for a 'promise' to resolve. Linting is getting confused by .then\n    // eslint-disable-next-line jest/valid-expect-in-promise\n\n    cy.get('@item-id').then(id => {\n      cy.get(getHandleSelector(id)).invoke('attr', 'data-index').should('equal', `${movements}`);\n    });\n  });","file":"integration/reorder-virtual.spec.js","skipped":false,"dir":"cypress"},{"name":"should reorder within a list","suites":["reorder"],"updatePoint":{"line":8,"column":34},"line":8,"code":"  it('should reorder within a list', () => {\n    // order: 1, 2\n    cy.get(getHandleSelector()).eq(0).as('first').should('contain', 'id:1');\n    cy.get(getHandleSelector()).eq(1).should('contain', 'id:2'); // reorder operation\n\n    cy.get('@first').focus().trigger('keydown', {\n      keyCode: keyCodes.space\n    }) // need to re-query for a clone\n    .get('@first').trigger('keydown', {\n      keyCode: keyCodes.arrowDown,\n      force: true\n    }) // finishing before the movement time is fine - but this looks nice\n    .wait(timings.outOfTheWay * 1000).trigger('keydown', {\n      keyCode: keyCodes.space,\n      force: true\n    }); // order now 2, 1\n    // note: not using get aliases as they where returning incorrect results\n\n    cy.get(getHandleSelector()).eq(0).should('contain', 'id:2');\n    cy.get(getHandleSelector()).eq(1).should('contain', 'id:1'); // element should maintain focus post drag\n\n    cy.focused().should('contain', 'id:1');\n  });","file":"integration/reorder.spec.js","skipped":false,"dir":"cypress"}]}