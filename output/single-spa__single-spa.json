{"repo":"single-spa/single-spa","url":"https://github.com/single-spa/single-spa","branch":"master","configs":[{"package":"single-spa","lang":"js","dir":"spec","framework":"jest","pattern":"**/*[._-]{test,spec,unittest,unit}.{ts,js}"}],"tests":[{"name":"should return all registered app names up to this point regardless of activity","suites":["app-names"],"updatePoint":{"line":26,"column":84},"line":26,"code":"  it(`should return all registered app names up to this point regardless of activity`, () => {\n    expect(singleSpa.getAppNames()).toEqual([\"usingArgumentAPI\", \"usingObjectAPI\"]);\n  });","file":"apis/app-names.spec.js","skipped":false,"dir":"spec"},{"name":"uses the window.location by default","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":89,"column":41},"line":89,"code":"  it(`uses the window.location by default`, () => {\n    window.location.hash = \"#one\";\n    expect(singleSpa.checkActivityFunctions()).toEqual([\"test1\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns 'test1' when the location contains 'one'","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":93,"column":54},"line":93,"code":"  it(`returns 'test1' when the location contains 'one'`, () => {\n    const wLocation = mockWindowLocation(\"http://google.com/one\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test1\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns 'test2' when the location contains 'two'","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":97,"column":54},"line":97,"code":"  it(`returns 'test2' when the location contains 'two'`, () => {\n    const wLocation = mockWindowLocation(\"http://google.com/two\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test2\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns 'test3' when the location contains 'three'","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":101,"column":56},"line":101,"code":"  it(`returns 'test3' when the location contains 'three'`, () => {\n    const wLocation = mockWindowLocation(\"http://google.com/three\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test3\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns 'test4' when the location contains 'four'","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":105,"column":55},"line":105,"code":"  it(`returns 'test4' when the location contains 'four'`, () => {\n    const wLocation = mockWindowLocation(\"http://google.com/four\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test4\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns 'test4' when the activeWhen contains 'pathname' strings","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":109,"column":69},"line":109,"code":"  it(`returns 'test4' when the activeWhen contains 'pathname' strings`, () => {\n    const wLocation = mockWindowLocation(\"http://google.com/pathname\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test4\"]);\n    const wLocationWithTrailingSlash = mockWindowLocation(\"http://google.com/pathname/\");\n    expect(singleSpa.checkActivityFunctions(wLocationWithTrailingSlash)).toEqual([\"test4\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"returns both when the location contains all","suites":["checkActivityFunctionsApi"],"updatePoint":{"line":115,"column":49},"line":115,"code":"  it(`returns both when the location contains all`, () => {\n    const wLocation = mockWindowLocation(\"http://something.com/two/one/three/four\");\n    expect(singleSpa.checkActivityFunctions(wLocation)).toEqual([\"test1\", \"test2\", \"test3\", \"test4\"]);\n  });","file":"apis/check-activity-functions.spec.js","skipped":false,"dir":"spec"},{"name":"fires artificial popstate events only after start() is called","suites":["delayed-start-popstate"],"updatePoint":{"line":21,"column":67},"line":21,"code":"  it(`fires artificial popstate events only after start() is called`, async () => {\n    await triggerAppChange();\n    expect(numPopstates).toBe(0);\n    history.pushState(history.state, document.title, \"/delayed1\");\n    await triggerAppChange();\n    expect(numPopstates).toBe(0);\n    start();\n    await triggerAppChange();\n    expect(numPopstates).toBe(0);\n    history.pushState(history.state, document.title, \"/delayed2\");\n    await triggerAppChange();\n    expect(numPopstates).toBe(1);\n  });","file":"apis/delayed-start-popstate.spec.js","skipped":false,"dir":"spec"},{"name":"reports an error during load","suites":["error handlers api"],"updatePoint":{"line":19,"column":34},"line":19,"code":"  it(`reports an error during load`, () => {\n    singleSpa.registerApplication(\"load-error\", () => Promise.reject(\"Could not load this one\"), location => location.hash === \"#load-error\");\n    location.hash = \"#load-error\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBe(1);\n      expect(errs[0].appOrParcelName).toBe(\"load-error\");\n      expect(errs[0].message).toMatch(`'load-error' died in status LOADING_SOURCE_CODE: \"Could not load this one\"`);\n      expect(singleSpa.getAppStatus(\"load-error\")).toBe(singleSpa.LOAD_ERROR);\n    });\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"reports an error during bootstrap","suites":["error handlers api"],"updatePoint":{"line":29,"column":39},"line":29,"code":"  it(`reports an error during bootstrap`, () => {\n    const app = {\n      bootstrap() {\n        return Promise.reject(new Error(`couldn't bootstrap`));\n      },\n\n      mount() {\n        return Promise.resolve();\n      },\n\n      unmount() {\n        return Promise.resolve();\n      }\n\n    };\n    singleSpa.registerApplication(\"bootstrap-error\", app, location => location.hash === \"#bootstrap-error\");\n    location.hash = \"#bootstrap-error\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBe(1);\n      expect(errs[0].appOrParcelName).toBe(\"bootstrap-error\");\n      expect(errs[0].message).toMatch(`'bootstrap-error' died in status BOOTSTRAPPING: couldn't bootstrap`);\n      expect(singleSpa.getAppStatus(\"bootstrap-error\")).toBe(singleSpa.SKIP_BECAUSE_BROKEN);\n    });\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"reports an error during mount","suites":["error handlers api"],"updatePoint":{"line":53,"column":35},"line":53,"code":"  it(`reports an error during mount`, () => {\n    const app = {\n      bootstrap() {\n        return Promise.resolve();\n      },\n\n      mount() {\n        return Promise.reject(`couldn't mount`);\n      },\n\n      unmount() {\n        return Promise.resolve();\n      }\n\n    };\n    singleSpa.registerApplication(\"mount-error\", app, location => location.hash === \"#mount-error\");\n    location.hash = \"#mount-error\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBe(1);\n      expect(errs[0].appOrParcelName).toBe(\"mount-error\");\n      expect(errs[0].message.indexOf(`'mount-error' died in status NOT_MOUNTED: \"couldn't mount\"`)).toBeGreaterThan(-1);\n    });\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"reports an error during unmount","suites":["error handlers api"],"updatePoint":{"line":76,"column":37},"line":76,"code":"  it(`reports an error during unmount`, () => {\n    const app = {\n      bootstrap() {\n        return Promise.resolve();\n      },\n\n      mount() {\n        return Promise.resolve();\n      },\n\n      unmount() {\n        return Promise.reject(new Error(`couldn't unmount`));\n      }\n\n    };\n    singleSpa.registerApplication(\"unmount-error\", app, location => location.hash === \"#unmount-error\");\n    location.hash = \"#unmount-error\";\n    return singleSpa.triggerAppChange().then(() => {\n      location.hash = \"#something-else\";\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      expect(errs.length).toBe(1);\n      expect(errs[0].appOrParcelName).toBe(\"unmount-error\");\n      expect(errs[0].message.indexOf(`'unmount-error' died in status UNMOUNTING: couldn't unmount`)).toBeGreaterThan(-1);\n    });\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"reports an error during activity functions","suites":["error handlers api"],"updatePoint":{"line":102,"column":48},"line":102,"code":"  it(`reports an error during activity functions`, () => {\n    const app = {\n      bootstrap() {\n        return Promise.resolve();\n      },\n\n      mount() {\n        return Promise.resolve();\n      },\n\n      unmount() {\n        return Promise.resolve();\n      }\n\n    };\n    singleSpa.registerApplication(\"activity-error\", app, location => {\n      throw new Error(\"bad activity function\");\n    });\n    location.hash = \"#activity-error\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBe(1);\n      expect(errs[0].appOrParcelName).toBe(\"activity-error\");\n      expect(errs[0].message.indexOf(`'activity-error' died in status NOT_LOADED: bad activity function`)).toBeGreaterThan(-1);\n    });\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"only throws one error when the application or parcel fails to mount","suites":["error handlers api"],"updatePoint":{"line":127,"column":73},"line":127,"code":"  it(`only throws one error when the application or parcel fails to mount`, async () => {\n    const app = {\n      async bootstrap() {},\n\n      async mount() {\n        throw Error(\"the mount failed\");\n      },\n\n      async unmount() {\n        throw Error(\"the unmount failed\");\n      }\n\n    };\n    location.hash = \"#\";\n    await singleSpa.triggerAppChange();\n    singleSpa.registerApplication(\"one-error-only\", app, location => location.hash.startsWith(\"#one-error-only\"));\n    location.hash = \"#one-error-only\";\n    await singleSpa.triggerAppChange();\n    expect(errs.length).toBe(1);\n    expect(errs[0].message).toMatch(\"the mount failed\");\n    expect(errs[0].message).not.toMatch(\"the unmount\");\n  });","file":"apis/error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"calls hashchange and popstate event listeners even when single-spa is not started","suites":["event listeners before single-spa is started :"],"updatePoint":{"line":4,"column":87},"line":4,"code":"  it(`calls hashchange and popstate event listeners even when single-spa is not started`, done => {\n    let hashchangeCalled = false,\n        popstateCalled = false;\n\n    function hashchange() {\n      if (window.location.hash === \"#/a-new-hash\") hashchangeCalled = true;\n      checkTestComplete();\n    }\n\n    function popstate() {\n      if (window.location.hash === \"#/a-new-hash\") popstateCalled = true;\n      checkTestComplete();\n    }\n\n    window.addEventListener(\"hashchange\", hashchange);\n    window.addEventListener(\"popstate\", popstate);\n    window.location.hash = \"#/a-new-hash\";\n\n    function checkTestComplete() {\n      if (isIE()) {\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/\n        cleanupAndFinish();\n      } else if (hashchangeCalled && popstateCalled) {\n        // Wait for both hashchange and popstate events\n        cleanupAndFinish();\n      }\n    }\n\n    function cleanupAndFinish() {\n      window.removeEventListener(\"hashchange\", hashchange);\n      window.removeEventListener(\"popstate\", popstate);\n      done();\n    }\n  });","file":"apis/event-listeners.spec.js","skipped":false,"dir":"spec"},{"name":"calls all of the enqueued hashchange listeners even when the first event given to singleSpa is a popstate event","suites":["event listeners after single-spa is started"],"updatePoint":{"line":44,"column":117},"line":44,"code":"  it(`calls all of the enqueued hashchange listeners even when the first event given to singleSpa is a popstate event`, done => {\n    let hashchangeCalled = false,\n        popstateCalled = false;\n\n    function hashchange() {\n      hashchangeCalled = true;\n      checkTestComplete();\n    }\n\n    function popstate() {\n      popstateCalled = true;\n      checkTestComplete();\n    }\n\n    window.addEventListener(\"hashchange\", hashchange);\n    window.addEventListener(\"popstate\", popstate);\n    /* This will first trigger a PopStateEvent, and then a HashChangeEvent. The\n     * hashchange event will be queued and not actually given to any event listeners\n     * until single-spa is sure that those event listeners won't screw anything up.\n     * The bug described in https://github.com/single-spa/single-spa/issues/74 explains\n     * why this test is necessary.\n     */\n\n    window.location.hash = \"#/a-hash-single-spa-is-started\";\n\n    function checkTestComplete() {\n      if (isIE()) {\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/3740423/\n        cleanupAndFinish(); // popstate isn't ever going to be called\n      } else if (hashchangeCalled && popstateCalled) {\n        // Wait for both hashchange and popstate events\n        cleanupAndFinish();\n      }\n    }\n\n    function cleanupAndFinish() {\n      window.removeEventListener(\"hashchange\", hashchange);\n      window.removeEventListener(\"popstate\", popstate);\n      done();\n    }\n  });","file":"apis/event-listeners.spec.js","skipped":false,"dir":"spec"},{"name":"window.removeEventListener only removes exactly one event listener, which must === the originally added listener. Even if the listener is a bound function","suites":["event listeners after single-spa is started"],"updatePoint":{"line":93,"column":160},"line":93,"code":"  it(`window.removeEventListener only removes exactly one event listener, which must === the originally added listener. Even if the listener is a bound function`, done => {\n    const boundListener1 = listener1.bind(null);\n    const boundListener2 = listener2.bind(null);\n    window.addEventListener(\"hashchange\", boundListener1);\n    window.addEventListener(\"hashchange\", boundListener2);\n    window.removeEventListener(\"hashchange\", boundListener1); // This should trigger listener2 to be called\n\n    window.location.hash = `#/nowhere`;\n\n    function listener1() {\n      fail(\"listener1 should not be called, since it was removed\");\n    }\n\n    function listener2() {\n      window.removeEventListener(\"hashchange\", boundListener2); // cleanup after ourselves\n\n      done();\n    }\n  });","file":"apis/event-listeners.spec.js","skipped":false,"dir":"spec"},{"name":"Does trigger a reroute when the URL changes and urlRerouteOnly is set to false","suites":["event listeners after single-spa is started"],"updatePoint":{"line":112,"column":84},"line":112,"code":"  it(`Does trigger a reroute when the URL changes and urlRerouteOnly is set to false`, async () => {\n    let activeWhenCalls = 0,\n        popstateCalls = 0;\n\n    const activeWhen = () => activeWhenCalls++;\n\n    const popstateListener = () => popstateCalls++;\n\n    const app = {\n      async bootstrap() {},\n\n      async mount() {},\n\n      async unmount() {}\n\n    };\n    window.addEventListener(\"popstate\", popstateListener);\n    singleSpa.registerApplication(\"urlRerouteOnly test\", app, activeWhen);\n    await singleSpa.triggerAppChange();\n    const numPopstatesBefore = popstateCalls;\n    const numActiveWhensBefore = activeWhenCalls;\n    history.replaceState({\n      some: \"state\"\n    }, document.title); // calling triggerAppChange forcibly increments the counters which is weird for this test\n    // but it also ensures we wait for the reroute to finish (if it's taking place)\n\n    await singleSpa.triggerAppChange(); // The 1 comes from replaceState\n\n    expect(numPopstatesBefore).toBe(popstateCalls - 1); // The 2 comes from triggerAppChange and from replaceState\n\n    expect(numActiveWhensBefore).toBe(activeWhenCalls - 2);\n  });","file":"apis/event-listeners.spec.js","skipped":false,"dir":"spec"},{"name":"Fires artificial popstate events with correct target","suites":["event listeners after single-spa is started"],"updatePoint":{"line":144,"column":58},"line":144,"code":"  it(`Fires artificial popstate events with correct target`, done => {\n    window.addEventListener(\"popstate\", popstateListener);\n    history.pushState(history.state, document.title, \"/new-url\");\n\n    function popstateListener(evt) {\n      expect(evt.target).toBe(window);\n      window.removeEventListener(\"popstate\", popstateListener);\n      done();\n    }\n  });","file":"apis/event-listeners.spec.js","skipped":false,"dir":"spec"},{"name":"fires first-mount exactly once when the first app is mounted","suites":["single-spa:first-mount events"],"updatePoint":{"line":21,"column":66},"line":21,"code":"  it(`fires first-mount exactly once when the first app is mounted`, () => {\n    singleSpa.registerApplication(\"firstMount\", dummyApp, () => {\n      return window.location.hash.indexOf(\"#/firstMount\") === 0;\n    });\n    singleSpa.start();\n    let numFirstMounts = 0,\n        numBeforeFirstMounts = 0;\n    window.addEventListener(\"single-spa:first-mount\", () => {\n      numBeforeFirstMounts++;\n    });\n    window.addEventListener(\"single-spa:first-mount\", () => {\n      numFirstMounts++;\n    });\n    window.location.hash = `#/firstMount`;\n    return singleSpa.triggerAppChange().then(() => {\n      // Unmount\n      window.location.hash = `#/`;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      // Remount (shouldn't trigger an event)\n      window.location.hash = `#/firstMount`;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      expect(numBeforeFirstMounts).toBe(1);\n      expect(numFirstMounts).toBe(1);\n    });\n  });","file":"apis/first-mount.spec.js","skipped":false,"dir":"spec"},{"name":"should log a warning to the console when you load single-spa on a page that already has loaded single-spa","suites":["multiple instances of single-spa"],"updatePoint":{"line":9,"column":111},"line":9,"code":"  it(`should log a warning to the console when you load single-spa on a page that already has loaded single-spa`, async () => {\n    // This is how we \"fool\" single-spa into thinking it was already loaded on the page\n    window.singleSpaNavigate = function () {};\n\n    expect(consoleWarnSpy).not.toHaveBeenCalled();\n    await import(\"single-spa\");\n    expect(consoleWarnSpy).toHaveBeenCalledWith(\"single-spa minified message #41: single-spa has been loaded twice on the page. This can result in unexpected behavior. See https://single-spa.js.org/error/?code=41\");\n  });","file":"apis/multiple-instances.spec.js","skipped":false,"dir":"spec"},{"name":"should navigate with a string","suites":["navigateToUrl"],"updatePoint":{"line":26,"column":35},"line":26,"code":"  it(\"should navigate with a string\", function () {\n    singleSpa.navigateToUrl(hrefWithoutHash() + \"#a/other\");\n    expect(location.hash).toBe(\"#a/other\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should navigate with an event","suites":["navigateToUrl"],"updatePoint":{"line":30,"column":35},"line":30,"code":"  it(\"should navigate with an event\", function () {\n    const a = document.createElement(\"a\");\n    a.setAttribute(\"href\", hrefWithoutHash() + \"#a/other\");\n    a.addEventListener(\"click\", singleSpa.navigateToUrl); // IE requires an element to be on the dom before click events will be fired.\n\n    document.body.appendChild(a);\n    a.click();\n    expect(location.hash).toBe(\"#a/other\");\n    document.body.removeChild(a);\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should navigate with an anchor tag as its context","suites":["navigateToUrl"],"updatePoint":{"line":40,"column":55},"line":40,"code":"  it(\"should navigate with an anchor tag as its context\", function () {\n    const a = document.createElement(\"a\");\n    a.setAttribute(\"href\", hrefWithoutHash() + \"#a/other\");\n    singleSpa.navigateToUrl.call(a);\n    expect(location.hash).toBe(\"#a/other\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should update hash when destination starts with a hash","suites":["navigateToUrl"],"updatePoint":{"line":46,"column":60},"line":46,"code":"  it(\"should update hash when destination starts with a hash\", function () {\n    singleSpa.navigateToUrl(\"#a/other\");\n    expect(location.hash).toBe(\"#a/other\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should update hash when destination doesn't contain domain, but same path","suites":["navigateToUrl"],"updatePoint":{"line":50,"column":79},"line":50,"code":"  it(`should update hash when destination doesn't contain domain, but same path`, function () {\n    window.history.pushState(null, null, \"/start-path#a/other\");\n    singleSpa.navigateToUrl(\"/start-path#a/other\");\n    expectPathAndHashToEqual(\"/start-path#a/other\");\n    location.hash = \"#not-the-start-path\";\n    singleSpa.navigateToUrl(\"/start-path#a/other\");\n    expectPathAndHashToEqual(\"/start-path#a/other\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should update hash when destination doesn't contain domain, but same path and same query","suites":["navigateToUrl"],"updatePoint":{"line":58,"column":94},"line":58,"code":"  it(`should update hash when destination doesn't contain domain, but same path and same query`, function () {\n    window.history.pushState(null, null, \"/start-path?yoshi=best#a/other\");\n    singleSpa.navigateToUrl(\"/start-path?yoshi=best#a/other\");\n    location.hash = \"#not-the-start-hash\";\n    singleSpa.navigateToUrl(\"/start-path?yoshi=best#a/other\");\n    expect(location.hash).toBe(\"#a/other\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should call push state when the destination doesn't contain domain and has different path 1","suites":["navigateToUrl"],"updatePoint":{"line":65,"column":97},"line":65,"code":"  it(`should call push state when the destination doesn't contain domain and has different path 1`, function () {\n    singleSpa.navigateToUrl(\"somethinger#b/my-route\"); // If pushState wasn't called, karma will barf because the page will have reloaded if the href was changed directly\n\n    expectPathAndHashToEqual(\"somethinger#b/my-route\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should reload the page to a new url when the origin's don't match, since that's the only way to navigate to a different domain/origin","suites":["navigateToUrl"],"updatePoint":{"line":70,"column":139},"line":70,"code":"  it(`should reload the page to a new url when the origin's don't match, since that's the only way to navigate to a different domain/origin`, function () {\n    const url = \"https://other-app.com/something#b/my-route\";\n    const returnValue = singleSpa.navigateToUrl(url);\n    expect(returnValue).toEqual({\n      wouldHaveReloadedThePage: true\n    });\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should call push state when the url has no hash","suites":["navigateToUrl"],"updatePoint":{"line":77,"column":53},"line":77,"code":"  it(`should call push state when the url has no hash`, function () {\n    singleSpa.navigateToUrl(hrefWithoutHash() + \"/some-other-path-without-hash\");\n    expectPathAndHashToEqual(\"/some-other-path-without-hash\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should reroute if query params have changed","suites":["navigateToUrl"],"updatePoint":{"line":81,"column":49},"line":81,"code":"  it(\"should reroute if query params have changed\", function () {\n    singleSpaNavigate(\"/route?yoshi=best\");\n    spyOn(window.history, \"pushState\");\n    singleSpaNavigate(\"/route?yoshi=criminal\");\n    expect(window.history.pushState).toHaveBeenCalledWith(null, null, \"/route?yoshi=criminal\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should reroute if query params have changed with hash based routing","suites":["navigateToUrl"],"updatePoint":{"line":87,"column":73},"line":87,"code":"  it(\"should reroute if query params have changed with hash based routing\", function () {\n    singleSpaNavigate(\"#/route?yoshi=criminal\");\n    spyOn(window.history, \"pushState\");\n    singleSpaNavigate(\"#/route?yoshi=freeanimal\");\n    expect(location.hash).toBe(\"#/route?yoshi=freeanimal\");\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should error if not called with appropriate args","suites":["navigateToUrl"],"updatePoint":{"line":93,"column":54},"line":93,"code":"  it(\"should error if not called with appropriate args\", function () {\n    const errors = [null, undefined, 1234];\n    errors.forEach(arg => {\n      expect(() => makeError(null, arg)).toThrow();\n    });\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should error if not called with appropriate context","suites":["navigateToUrl"],"updatePoint":{"line":99,"column":57},"line":99,"code":"  it(\"should error if not called with appropriate context\", function () {\n    expect(makeError).toThrow();\n\n    function makeError(err) {\n      singleSpa.navigateToUrl.call({});\n    }\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should fire a popstate event when history.pushState is called","suites":["window.history.pushState"],"updatePoint":{"line":112,"column":67},"line":112,"code":"  it(\"should fire a popstate event when history.pushState is called\", function () {\n    return singleSpa.triggerAppChange().then(() => {\n      return new Promise((resolve, reject) => {\n        const newHistoryState = {\n          why: \"hello\"\n        };\n        window.addEventListener(\"popstate\", popstateListener);\n        window.history.pushState(newHistoryState, \"title\", \"/new-url\");\n\n        function popstateListener(evt) {\n          expect(evt instanceof PopStateEvent).toBe(true);\n          expect(window.location.pathname).toBe(\"/new-url\");\n          expect(evt.state).toBe(newHistoryState);\n          expect(evt.singleSpa).toBe(true);\n          expect(evt.singleSpaTrigger).toBe(\"pushState\");\n          window.removeEventListener(\"popstate\", popstateListener);\n          resolve();\n        }\n      });\n    });\n  }); // https://github.com/single-spa/single-spa/issues/224 and https://github.com/single-spa/single-spa-angular/issues/49","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"should fire a popstate event when history.replaceState is called","suites":["window.history.pushState"],"updatePoint":{"line":137,"column":70},"line":137,"code":"  it(\"should fire a popstate event when history.replaceState is called\", function () {\n    return singleSpa.triggerAppChange().then(() => {\n      return new Promise((resolve, reject) => {\n        const newHistoryState = {\n          yoshi: \"best\"\n        };\n        window.addEventListener(\"popstate\", popstateListener);\n        window.history.replaceState(newHistoryState, \"title\", \"/new-url\");\n\n        function popstateListener(evt) {\n          expect(evt instanceof PopStateEvent).toBe(true);\n          expect(window.location.pathname).toBe(\"/new-url\");\n          expect(evt.state).toBe(newHistoryState);\n          expect(evt.singleSpa).toBe(true);\n          expect(evt.singleSpaTrigger).toBe(\"replaceState\");\n          window.removeEventListener(\"popstate\", popstateListener);\n          resolve();\n        }\n      });\n    });\n  });","file":"apis/navigate-to-url.spec.js","skipped":false,"dir":"spec"},{"name":"expects path  to match ","suites":["pathToActiveWhen","exact matches"],"updatePoint":{"line":139,"column":91},"line":139,"code":"    it(`expects path ${print(dynamicPath)} to${expectTo ? \"\" : \" not\"} match ${print(path)}`, () => {\n      expect(pathToActiveWhen(dynamicPath, exactMatch)(new URL(path))).toBe(expectTo);\n    });","file":"apis/path-to-active-when.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error if the name isn't a non empty string","suites":["registerApplication","Application name errors"],"updatePoint":{"line":41,"column":66},"line":41,"code":"    it(`should throw an error if the name isn't a non empty string`, () => {\n      expect(() => {\n        singleSpa.registerApplication(null);\n      }).toThrowError(errorsMessages.name.invalidConfig);\n      expect(() => {\n        singleSpa.registerApplication();\n      }).toThrowError(errorsMessages.name.args);\n      expect(() => {\n        singleSpa.registerApplication(\"\");\n      }).toThrowError(errorsMessages.name.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: null\n        });\n      }).toThrowError(errorsMessages.name.config);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"\"\n        });\n      }).toThrowError(errorsMessages.name.config);\n      expect(() => {\n        singleSpa.registerApplication({});\n      }).toThrowError(errorsMessages.name.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when I register the same application name twice","suites":["registerApplication","Application name errors"],"updatePoint":{"line":65,"column":68},"line":65,"code":"    it(\"should throw when I register the same application name twice\", () => {\n      singleSpa.registerApplication(\"duplicateApp\", app, () => true);\n      expect(() => {\n        singleSpa.registerApplication(\"duplicateApp\", app, () => true);\n      }).toThrowError(errorsMessages.duplicateApp);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when I register the same application name twice using config","suites":["registerApplication","Application name errors"],"updatePoint":{"line":71,"column":81},"line":71,"code":"    it(\"should throw when I register the same application name twice using config\", () => {\n      singleSpa.registerApplication({\n        name: \"duplicateUsingConfigApp\",\n        app,\n        activeWhen: () => true\n      });\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"duplicateUsingConfigApp\",\n          app,\n          activeWhen: () => true\n        });\n      }).toThrowError(errorsMessages.duplicateApp);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when I attempt to register an application without the application or loading function","suites":["registerApplication","application or loading function errors"],"updatePoint":{"line":87,"column":115},"line":87,"code":"    it(`should throw an error when I attempt to register an application without the application or loading function`, () => {\n      expect(() => {\n        singleSpa.registerApplication(\"no-app-will-throw-error-app\");\n      }).toThrowError(errorsMessages.app.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"no-app-will-throw-error-app\"\n        });\n      }).toThrowError(errorsMessages.app.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when I attempt to register an application without the activeWhen function","suites":["registerApplication","activeWhen errors"],"updatePoint":{"line":99,"column":103},"line":99,"code":"    it(`should throw an error when I attempt to register an application without the activeWhen function`, () => {\n      expect(() => {\n        singleSpa.registerApplication(\"no-active-when-throw-error-app\", app);\n      }).toThrowError(errorsMessages.activeWhen.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"no-active-when-throw-error-app\",\n          app\n        });\n      }).toThrowError(errorsMessages.activeWhen.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when activeWhen isn't a function","suites":["registerApplication","activeWhen errors"],"updatePoint":{"line":110,"column":62},"line":110,"code":"    it(`should throw an error when activeWhen isn't a function`, () => {\n      expect(() => {\n        singleSpa.registerApplication(\"bad-active-when-args-throw-error-app\", app, app);\n      }).toThrowError(errorsMessages.activeWhen.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"bad-active-when-config-throw-error-app\",\n          app,\n          activeWhen: app\n        });\n      }).toThrowError(errorsMessages.activeWhen.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when activeWhen is given not a function","suites":["registerApplication","activeWhen errors"],"updatePoint":{"line":122,"column":69},"line":122,"code":"    it(`should throw an error when activeWhen is given not a function`, () => {\n      expect(() => {\n        singleSpa.registerApplication(\"bad-active-when-throw-error-app\", app, [\"/valid-only-in-object-config\"]);\n      }).toThrowError(errorsMessages.activeWhen.args);\n      expect(() => {\n        singleSpa.registerApplication(\"bad-active-when-throw-error-app\", app, \"/valid-only-in-object-config\");\n      }).toThrowError(errorsMessages.activeWhen.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"bad-active-when-throw-error-app\",\n          app,\n          activeWhen: [\"/valid\", true]\n        });\n      }).toThrowError(errorsMessages.activeWhen.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed when activeWhen is given correct values","suites":["registerApplication","activeWhen errors"],"updatePoint":{"line":137,"column":62},"line":137,"code":"    it(`should succeed when activeWhen is given correct values`, () => {\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"valid-active-when-single-throw-error-app\",\n          app,\n          activeWhen: () => true\n        });\n      }).not.toThrow();\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"valid-active-when-multiple-throw-error-app\",\n          app,\n          activeWhen: [\"/valid\", () => true]\n        });\n      }).not.toThrow();\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should succeed when I pass in a function for custom props","suites":["registerApplication","custom prop errors"],"updatePoint":{"line":155,"column":65},"line":155,"code":"    it(\"should succeed when I pass in a function for custom props\", () => {\n      expect(() => {\n        singleSpa.registerApplication(\"custom-props-fn-1\", app, () => true, () => {});\n      }).not.toThrow();\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"custom-props-fn-2\",\n          app,\n          activeWhen: () => true,\n          customProps: () => {}\n        });\n      }).not.toThrow();\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when I pass in an array for custom props","suites":["registerApplication","custom prop errors"],"updatePoint":{"line":168,"column":61},"line":168,"code":"    it(\"should throw when I pass in an array for custom props\", () => {\n      expect(() => {\n        singleSpa.registerApplication(\"bad-custom-props-will-throw-error-app\", app, () => true, []);\n      }).toThrowError(errorsMessages.customProps.args);\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"bad-custom-props-will-throw-error-app\",\n          app,\n          activeWhen: () => true,\n          customProps: []\n        });\n      }).toThrowError(errorsMessages.customProps.config);\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"should throw when I pass invalid keys to object configuration ","suites":["registerApplication","custom prop errors"],"updatePoint":{"line":181,"column":70},"line":181,"code":"    it(\"should throw when I pass invalid keys to object configuration \", () => {\n      expect(() => {\n        singleSpa.registerApplication({\n          name: \"invalid-key-in-object-config\",\n          app,\n          activeWhen: () => true,\n          invalidKey: \"invalidKey\",\n          superInvalidKey: {}\n        });\n      }).toThrowError(\"Invalid keys: invalidKey, superInvalidKey.\");\n    });","file":"apis/register-application.spec.js","skipped":false,"dir":"spec"},{"name":"is fired on the window whenever the hash changes","suites":["events api :","single-spa:routing-event"],"updatePoint":{"line":63,"column":56},"line":63,"code":"    it(`is fired on the window whenever the hash changes`, done => {\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        window.addEventListener(\"single-spa:routing-event\", finishTest);\n        window.location.hash = `#/hash-was-changed`;\n\n        function finishTest() {\n          window.removeEventListener(\"single-spa:routing-event\", finishTest);\n          done();\n        }\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired on the window whenever the url changes","suites":["events api :","single-spa:routing-event"],"updatePoint":{"line":75,"column":55},"line":75,"code":"    it(`is fired on the window whenever the url changes`, done => {\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        window.addEventListener(\"single-spa:routing-event\", finishTest);\n        window.history.pushState({}, null, `#/push-state-called`);\n\n        function finishTest() {\n          window.removeEventListener(\"single-spa:routing-event\", finishTest);\n          done();\n        }\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't destroy single-spa when you throw an error inside of an event listener","suites":["events api :","single-spa:routing-event"],"updatePoint":{"line":87,"column":86},"line":87,"code":"    it(`doesn't destroy single-spa when you throw an error inside of an event listener`, done => {\n      const ogOnError = window.onerror;\n      const counterFn = jest.fn();\n\n      window.onerror = function (err) {\n        counterFn();\n        console.error(err);\n        doneIfAllListenerHadBeenInvoked();\n      }; // If the counterFn had been called thrice, it means all listener be invoked.\n\n\n      function doneIfAllListenerHadBeenInvoked() {\n        if (counterFn.mock.calls.length === 3) {\n          window.onerror = ogOnError;\n          done();\n        }\n      }\n\n      function listener() {\n        window.removeEventListener(\"single-spa:routing-event\", listener);\n        throw Error(\"Mwahaha I threw an error in an event listener\");\n      }\n\n      window.addEventListener(\"single-spa:routing-event\", listener);\n\n      function hashchangeListenerWithErr() {\n        window.removeEventListener(\"hashchange\", hashchangeListenerWithErr);\n        throw Error(\"Mwahaha I threw an error in an hashchange event listener\");\n      }\n\n      window.addEventListener(\"hashchange\", hashchangeListenerWithErr);\n\n      function hashchangeListener() {\n        counterFn();\n        window.removeEventListener(\"hashchange\", hashchangeListener);\n        doneIfAllListenerHadBeenInvoked();\n      }\n\n      window.addEventListener(\"hashchange\", hashchangeListener);\n      singleSpa.triggerAppChange().then(() => window.location.hash = \"#/hashchange\").catch(err => {\n        // If single-spa died because of the thrown error above, we've got a problem\n        window.removeEventListener(\"single-spa:routing-event\", listener);\n        window.removeEventListener(\"hashchange\", hashchangeListener);\n        window.removeEventListener(\"hashchange\", hashchangeListenerWithErr);\n        window.onerror = ogOnError;\n        fail(err);\n      });\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired after before-routing-event but before routing-event","suites":["events api :","single-spa:before-mount-routing-event"],"updatePoint":{"line":137,"column":68},"line":137,"code":"    it(`is fired after before-routing-event but before routing-event`, async () => {\n      let firedEvents = [];\n      await singleSpa.triggerAppChange(); // start with a clean slate (no previous tests doing anything)\n\n      window.addEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n      window.addEventListener(\"single-spa:before-mount-routing-event\", beforeMountRoutingEvent);\n      window.addEventListener(\"single-spa:routing-event\", afterRoutingEvent);\n      window.location.hash = `#/hash-was-changed`;\n      await singleSpa.triggerAppChange();\n      expect(firedEvents).toEqual([\"before-routing-event\", \"before-mount-routing-event\", \"routing-event\"]);\n\n      function beforeRoutingEvent() {\n        window.removeEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n        firedEvents.push(\"before-routing-event\");\n      }\n\n      function beforeMountRoutingEvent() {\n        window.removeEventListener(\"single-spa:before-mount-routing-event\", beforeMountRoutingEvent);\n        firedEvents.push(\"before-mount-routing-event\");\n      }\n\n      function afterRoutingEvent() {\n        window.removeEventListener(\"single-spa:routing-event\", afterRoutingEvent);\n        firedEvents.push(\"routing-event\");\n      }\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired after all applications have been unmounted, and before any have been mounted","suites":["events api :","single-spa:before-mount-routing-event"],"updatePoint":{"line":163,"column":93},"line":163,"code":"    it(`is fired after all applications have been unmounted, and before any have been mounted`, async () => {\n      await singleSpa.triggerAppChange(); // start with a clean slate (no previous tests doing anything)\n      // make sure boomApp is not mounted\n\n      boom = false;\n      location.hash = \"#/russell\";\n      await singleSpa.triggerAppChange();\n      window.addEventListener(\"single-spa:before-mount-routing-event\", listener);\n      expect(singleSpa.getAppStatus(\"russell\")).toBe(singleSpa.MOUNTED);\n      expect(russellApp.unmountCount).toBe(0);\n      expect(boomApp.mountCount).toBe(0); // now mount boomApp\n\n      boom = true;\n      location.hash = \"#/other\";\n      await singleSpa.triggerAppChange();\n      expect(singleSpa.getAppStatus(\"russell\")).toBe(singleSpa.NOT_MOUNTED);\n      expect(russellApp.unmountCount).toBe(1);\n      expect(boomApp.mountCount).toBe(1);\n\n      function listener() {\n        window.removeEventListener(\"single-spa:before-mount-routing-event\", listener); // unmounts have been called\n\n        expect(russellApp.unmountCount).toBe(1); // but mounts have not\n\n        expect(boomApp.mountCount).toBe(0);\n      }\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired when an app is mounted","suites":["events api :","single-spa:app-change"],"updatePoint":{"line":192,"column":39},"line":192,"code":"    it(`is fired when an app is mounted`, done => {\n      window.location.hash = `#`;\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        window.addEventListener(\"single-spa:app-change\", finishTest);\n        window.location.hash = `#/russell`;\n\n        function finishTest(evt) {\n          const {\n            detail: {\n              appsByNewStatus,\n              newAppStatuses,\n              totalAppChanges\n            }\n          } = evt;\n          window.removeEventListener(\"single-spa:app-change\", finishTest);\n          expect(appsByNewStatus[singleSpa.NOT_LOADED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.SKIP_BECAUSE_BROKEN].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.NOT_MOUNTED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.MOUNTED].sort()).toEqual([\"russell\"].sort());\n          expect(totalAppChanges).toBe(1);\n          expect(newAppStatuses).toEqual({\n            russell: singleSpa.MOUNTED\n          });\n          done();\n        }\n\n        return singleSpa.triggerAppChange();\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired with multiple apps that changed","suites":["events api :","single-spa:app-change"],"updatePoint":{"line":222,"column":48},"line":222,"code":"    it(`is fired with multiple apps that changed`, done => {\n      window.location.hash = `#`;\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        boom = true; // turn on the boom application\n\n        window.addEventListener(\"single-spa:app-change\", finishTest);\n        window.location.hash = `#/russell`;\n\n        function finishTest(evt) {\n          window.removeEventListener(\"single-spa:app-change\", finishTest);\n          const {\n            detail: {\n              appsByNewStatus,\n              newAppStatuses,\n              totalAppChanges\n            }\n          } = evt;\n          expect(appsByNewStatus[singleSpa.NOT_LOADED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.SKIP_BECAUSE_BROKEN].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.NOT_MOUNTED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.MOUNTED].sort()).toEqual([\"russell\", \"boom\"].sort());\n          expect(totalAppChanges).toBe(2);\n          expect(newAppStatuses).toEqual({\n            russell: singleSpa.MOUNTED,\n            boom: singleSpa.MOUNTED\n          });\n          done();\n        }\n\n        return singleSpa.triggerAppChange();\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired for unmounts","suites":["events api :","single-spa:app-change"],"updatePoint":{"line":255,"column":29},"line":255,"code":"    it(`is fired for unmounts`, done => {\n      window.location.hash = `#/russell`;\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        window.addEventListener(\"single-spa:app-change\", finishTest);\n        window.location.hash = `#`;\n\n        function finishTest(evt) {\n          window.removeEventListener(\"single-spa:app-change\", finishTest);\n          const {\n            detail: {\n              appsByNewStatus,\n              newAppStatuses,\n              totalAppChanges\n            }\n          } = evt;\n          expect(appsByNewStatus[singleSpa.NOT_LOADED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.SKIP_BECAUSE_BROKEN].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.MOUNTED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.NOT_MOUNTED].sort()).toEqual([\"russell\"].sort());\n          expect(totalAppChanges).toBe(1);\n          expect(newAppStatuses).toEqual({\n            russell: singleSpa.NOT_MOUNTED\n          });\n          done();\n        }\n\n        return singleSpa.triggerAppChange();\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"fires with multiple statuses when things are both mounted and unmounted","suites":["events api :","single-spa:app-change"],"updatePoint":{"line":285,"column":79},"line":285,"code":"    it(`fires with multiple statuses when things are both mounted and unmounted`, done => {\n      window.location.hash = `#`; // unmount russell\n\n      boom = true; // mount boom\n\n      singleSpa.triggerAppChange() // start with a clean slate (no previous tests doing anything)\n      .then(() => {\n        window.addEventListener(\"single-spa:app-change\", finishTest);\n        window.location.hash = `#/russell`; // mount russell\n\n        boom = false; // unmount boom\n\n        function finishTest(evt) {\n          const {\n            detail: {\n              appsByNewStatus,\n              newAppStatuses,\n              totalAppChanges\n            }\n          } = evt;\n          window.removeEventListener(\"single-spa:app-change\", finishTest);\n          expect(appsByNewStatus[singleSpa.NOT_LOADED].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.SKIP_BECAUSE_BROKEN].sort()).toEqual([]);\n          expect(appsByNewStatus[singleSpa.NOT_MOUNTED].sort()).toEqual([\"boom\"].sort());\n          expect(appsByNewStatus[singleSpa.MOUNTED].sort()).toEqual([\"russell\"].sort());\n          expect(totalAppChanges).toBe(2);\n          expect(newAppStatuses).toEqual({\n            boom: singleSpa.NOT_MOUNTED,\n            russell: singleSpa.MOUNTED\n          });\n          done();\n        }\n\n        return singleSpa.triggerAppChange();\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is not fired when no app is mounted","suites":["events api :","single-spa:app-change"],"updatePoint":{"line":321,"column":43},"line":321,"code":"    it(`is not fired when no app is mounted`, done => {\n      function failTest() {\n        window.removeEventListener(\"single-spa:app-change\", failTest);\n        fail(`single-spa:app-change should not be called when no apps change`);\n      }\n\n      window.location.hash = `#`;\n      singleSpa.triggerAppChange().then(() => singleSpa.triggerAppChange()).then(() => {\n        window.addEventListener(\"single-spa:app-change\", failTest);\n        window.location.hash = `#/not-a-real-app`;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        window.removeEventListener(\"single-spa:app-change\", failTest); // If failTest wasn't called, then we're good\n\n        done();\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired when no app is loaded, bootstrapped, mounted, unmounted, or unloaded","suites":["events api :","single-spa:no-app-change"],"updatePoint":{"line":340,"column":85},"line":340,"code":"    it(`is fired when no app is loaded, bootstrapped, mounted, unmounted, or unloaded`, done => {\n      window.location.hash = `#`;\n      singleSpa.triggerAppChange().then(() => {\n        window.addEventListener(\"single-spa:no-app-change\", finishTest);\n        window.location.hash = `#not-a-real-app`;\n\n        function finishTest() {\n          window.removeEventListener(\"single-spa:no-app-change\", finishTest);\n          done();\n        }\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired before apps will change, and not fired if no apps are changing","suites":["events api :","single-spa:before-app-change"],"updatePoint":{"line":354,"column":79},"line":354,"code":"    it(`is fired before apps will change, and not fired if no apps are changing`, done => {\n      window.location.hash = `#/russell`;\n      singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"boom\")).toMatch(/NOT_MOUNTED|NOT_LOADED/);\n        expect(singleSpa.getAppStatus(\"russell\")).toBe(singleSpa.MOUNTED);\n        window.addEventListener(\"single-spa:before-app-change\", finishTest);\n        window.addEventListener(\"single-spa:before-no-app-change\", finishTest);\n        boom = true;\n        window.location.hash = `#not-a-real-app`;\n\n        function finishTest(evt) {\n          window.removeEventListener(\"single-spa:before-app-change\", finishTest);\n          window.removeEventListener(\"single-spa:before-no-app-change\", finishTest);\n          expect(evt.type).toBe(\"single-spa:before-app-change\");\n          expect(singleSpa.getAppStatus(\"boom\")).toMatch(/NOT_MOUNTED|NOT_LOADED/);\n          expect(singleSpa.getAppStatus(\"russell\")).toBe(singleSpa.MOUNTED);\n          expect(evt.detail.appsByNewStatus[singleSpa.MOUNTED]).toEqual([\"boom\"]);\n          expect(evt.detail.appsByNewStatus[singleSpa.NOT_MOUNTED]).toEqual([\"russell\"]);\n          done();\n        }\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"is fired before apps will not change, and not fired if apps are changing","suites":["events api :","single-spa:before-no-app-change"],"updatePoint":{"line":378,"column":80},"line":378,"code":"    it(`is fired before apps will not change, and not fired if apps are changing`, done => {\n      window.location.hash = `#/russell`;\n      singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"boom\")).toMatch(/NOT_MOUNTED|NOT_LOADED/);\n        expect(singleSpa.getAppStatus(\"russell\")).toBe(singleSpa.MOUNTED);\n        window.addEventListener(\"single-spa:before-no-app-change\", finishTest);\n        window.addEventListener(\"single-spa:before-app-change\", finishTest);\n        singleSpa.triggerAppChange();\n\n        function finishTest(evt) {\n          window.removeEventListener(\"single-spa:before-no-app-change\", finishTest);\n          window.removeEventListener(\"single-spa:before-app-change\", finishTest);\n          expect(evt.type).toEqual(\"single-spa:before-no-app-change\");\n          expect(evt.detail.appsByNewStatus[singleSpa.MOUNTED]).toEqual([]);\n          expect(evt.detail.appsByNewStatus[singleSpa.NOT_MOUNTED]).toEqual([]);\n          done();\n        }\n      }).catch(fail);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to cancel a hash navigation event in the before-routing-event handler","suites":["events api :","cancelNavigation"],"updatePoint":{"line":399,"column":88},"line":399,"code":"    it(`allows you to cancel a hash navigation event in the before-routing-event handler`, done => {\n      const beforeRoutingEvent = evt => {\n        expect(evt.detail.oldUrl).toMatch(/http:\\/\\/localhost\\/(#\\/)?/);\n        expect(evt.detail.newUrl).toBe(\"http://localhost/#/russell\");\n\n        if (new URL(evt.detail.newUrl).hash === \"#/russell\") {\n          evt.detail.cancelNavigation();\n        }\n      };\n\n      window.addEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n      const originalStatus = singleSpa.getAppStatus(\"russell\");\n      const originalUrl = window.location.href;\n      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);\n      window.location.hash = `#/russell`;\n      singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"russell\")).toBe(originalStatus);\n        expect(window.location.href).toBe(originalUrl);\n      }).catch(fail).finally(() => {\n        window.removeEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n        done();\n      });\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to cancel a pushState navigation event in the before-routing-event handler","suites":["events api :","cancelNavigation"],"updatePoint":{"line":422,"column":93},"line":422,"code":"    it(`allows you to cancel a pushState navigation event in the before-routing-event handler`, async () => {\n      await singleSpa.triggerAppChange(\"/\");\n      const app = {\n        async mount() {},\n\n        async unmount() {}\n\n      };\n      singleSpa.registerApplication({\n        name: \"cancel-pushstate\",\n        app,\n        activeWhen: \"/cancel-pushstate\"\n      });\n\n      const beforeRoutingEvent = evt => {\n        window.removeEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n        expect(evt.detail.oldUrl).toMatch(/http:\\/\\/localhost\\/(#\\/)?/);\n        expect(evt.detail.newUrl).toBe(\"http://localhost/cancel-pushstate\");\n\n        if (new URL(evt.detail.newUrl).pathname === \"/cancel-pushstate\") {\n          evt.detail.cancelNavigation();\n        }\n      };\n\n      await singleSpa.triggerAppChange();\n      window.addEventListener(\"single-spa:before-routing-event\", beforeRoutingEvent);\n      const originalStatus = singleSpa.getAppStatus(\"russell\");\n      const originalUrl = window.location.href;\n      expect(originalStatus).toMatch(/NOT_MOUNTED|NOT_LOADED/);\n      singleSpa.navigateToUrl(\"/cancel-pushstate\");\n      await singleSpa.triggerAppChange();\n      expect(singleSpa.getAppStatus(\"russell\")).toBe(originalStatus);\n      expect(window.location.href).toBe(originalUrl);\n    });","file":"apis/single-spa-events-api.spec.js","skipped":false,"dir":"spec"},{"name":"respects the millis configuration option","suites":["global timeout configuration","setBootstrapMaxTime"],"updatePoint":{"line":24,"column":48},"line":24,"code":"    it(`respects the millis configuration option`, async () => {\n      singleSpa.setBootstrapMaxTime(5, false, 1000);\n      await controlledParcelActions(parcel => parcel.bootstrapPromise, \"bootstrap-0\", 3);\n      expect(consoleErrSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(parcel => parcel.bootstrapPromise, \"bootstrap-1\", 10);\n      expectError(`single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-1&arg=5`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"respects warningMillis configuration option","suites":["global timeout configuration","setBootstrapMaxTime"],"updatePoint":{"line":31,"column":51},"line":31,"code":"    it(`respects warningMillis configuration option`, async () => {\n      singleSpa.setBootstrapMaxTime(15, false, 5);\n      await controlledParcelActions(parcel => parcel.bootstrapPromise, \"bootstrap-2\", 0);\n      expect(consoleWarnSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(parcel => parcel.bootstrapPromise, \"bootstrap-3\", 10);\n      expectWarning(`single-spa minified message #31: Lifecycle function bootstrap for parcel bootstrap-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=parcel&arg=bootstrap-3&arg=15`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"respects the millis configuration option","suites":["global timeout configuration","setMountMaxTime"],"updatePoint":{"line":43,"column":48},"line":43,"code":"    it(`respects the millis configuration option`, async () => {\n      singleSpa.setMountMaxTime(5, false, 1000);\n      await controlledParcelActions(parcel => parcel.mountPromise, \"mount-0\", 0, 3);\n      expect(consoleErrSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(parcel => parcel.mountPromise, \"mount-1\", 0, 10);\n      expectError(`single-spa minified message #31: Lifecycle function mount for parcel mount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-1&arg=5`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"respects warningMillis configuration option","suites":["global timeout configuration","setMountMaxTime"],"updatePoint":{"line":50,"column":51},"line":50,"code":"    it(`respects warningMillis configuration option`, async () => {\n      singleSpa.setMountMaxTime(15, false, 5);\n      await controlledParcelActions(parcel => parcel.mountPromise, \"mount-2\", 0, 3);\n      expect(consoleWarnSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(parcel => parcel.mountPromise, \"mount-3\", 0, 10);\n      expectWarning(`single-spa minified message #31: Lifecycle function mount for parcel mount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=parcel&arg=mount-3&arg=15`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"respects the millis configuration option","suites":["global timeout configuration","setUnmountMaxTime"],"updatePoint":{"line":67,"column":48},"line":67,"code":"    it(`respects the millis configuration option`, async () => {\n      singleSpa.setUnmountMaxTime(5, false, 1000);\n      await controlledParcelActions(unmount, \"unmount-0\", 0, 0, 0, 3);\n      expect(consoleErrSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(unmount, \"unmount-1\", 0, 0, 0, 10);\n      expectError(`single-spa minified message #31: Lifecycle function unmount for parcel unmount-1 lifecycle did not resolve or reject for 5 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-1&arg=5`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"respects warningMillis configuration option","suites":["global timeout configuration","setUnmountMaxTime"],"updatePoint":{"line":74,"column":51},"line":74,"code":"    it(`respects warningMillis configuration option`, async () => {\n      singleSpa.setUnmountMaxTime(15, false, 5);\n      await controlledParcelActions(unmount, \"unmount-2\", 0, 0, 0, 3);\n      expect(consoleWarnSpy).not.toHaveBeenCalled();\n      await controlledParcelActions(unmount, \"unmount-3\", 0, 0, 0, 10);\n      expectWarning(`single-spa minified message #31: Lifecycle function unmount for parcel unmount-3 lifecycle did not resolve or reject for 15 ms. See https://single-spa.js.org/error/?code=31&arg=unmount&arg=parcel&arg=unmount-3&arg=15`);\n    });","file":"apis/timeout-apis.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error if no such application exists","suites":["unregisterApplication"],"updatePoint":{"line":20,"column":57},"line":20,"code":"  it(`should throw an error if no such application exists`, () => {\n    expect(() => {\n      window.__SINGLE_SPA_DEVTOOLS__.exposedMethods.unregisterApplication(`app that doesn't exist`);\n    }).toThrow();\n  });","file":"apis/unregister-application.spec.js","skipped":false,"dir":"spec"},{"name":"should remove the application so it can be re-registered","suites":["unregisterApplication"],"updatePoint":{"line":25,"column":62},"line":25,"code":"  it(`should remove the application so it can be re-registered`, () => {\n    singleSpa.registerApplication(\"about to unregister\", app, () => false);\n    expect(singleSpa.getAppStatus(\"about to unregister\")).toBeTruthy();\n    expect(() => {\n      singleSpa.registerApplication(\"about to unregister\", app, () => false);\n    }).toThrow();\n    return window.__SINGLE_SPA_DEVTOOLS__.exposedMethods.unregisterApplication(\"about to unregister\").then(() => {\n      expect(singleSpa.getAppStatus(\"about to unregister\")).toBeFalsy();\n    });\n  });","file":"apis/unregister-application.spec.js","skipped":false,"dir":"spec"},{"name":"Doesn't trigger a reroute when the URL changes and urlRerouteOnly is set to true","suites":["urlRerouteOnly option"],"updatePoint":{"line":8,"column":86},"line":8,"code":"  it(`Doesn't trigger a reroute when the URL changes and urlRerouteOnly is set to true`, async () => {\n    let activeWhenCalls = 0,\n        popstateCalls = 0;\n\n    const activeWhen = () => activeWhenCalls++;\n\n    const popstateListener = () => popstateCalls++;\n\n    const app = {\n      async bootstrap() {},\n\n      async mount() {},\n\n      async unmount() {}\n\n    };\n    window.addEventListener(\"popstate\", popstateListener);\n    singleSpa.registerApplication(\"urlRerouteOnly test\", app, activeWhen);\n    await singleSpa.triggerAppChange();\n    const numPopstatesBefore = popstateCalls;\n    const numActiveWhensBefore = activeWhenCalls;\n    history.replaceState({\n      some: \"state\"\n    }, document.title); // calling triggerAppChange forcibly increments the counters which is weird for this test\n    // but it also ensures we wait for the reroute to finish (if it's taking place)\n\n    await singleSpa.triggerAppChange();\n    expect(numPopstatesBefore).toBe(popstateCalls); // The 1 comes from triggerAppChange\n\n    expect(numActiveWhensBefore).toBe(activeWhenCalls - 1);\n  });","file":"apis/url-reroute-only.spec.js","skipped":false,"dir":"spec"},{"name":"puts the app into SKIP_BECAUSE_BROKEN, fires a window event, and doesn't mount it","suites":["bootstrap-rejects"],"updatePoint":{"line":22,"column":87},"line":22,"code":"  it(`puts the app into SKIP_BECAUSE_BROKEN, fires a window event, and doesn't mount it`, () => {\n    location.hash = \"#bootstrap-rejects\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBe(1);\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(false);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./bootstrap-rejects.app.js\")).toEqual(singleSpa.SKIP_BECAUSE_BROKEN);\n    });\n  });","file":"apps/bootstrap-rejects/bootstrap-rejects.spec.js","skipped":false,"dir":"spec"},{"name":"is put into SKIP_BECAUSE_BROKEN if dieOnTimeout is true","suites":["bootstrap-times-out-dies"],"updatePoint":{"line":23,"column":61},"line":23,"code":"  it(`is put into SKIP_BECAUSE_BROKEN if dieOnTimeout is true`, () => {\n    location.hash = \"#bootstrap-times-out-dies\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(false);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./bootstrap-times-out-dies.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      expect(errs.length).toBeGreaterThan(0);\n    });\n  });","file":"apps/bootstrap-times-out-dies/bootstrap-times-out-dies.spec.js","skipped":false,"dir":"spec"},{"name":"is just waited for if dieOnTimeout is false","suites":["bootstrap-times-out"],"updatePoint":{"line":23,"column":49},"line":23,"code":"  it(`is just waited for if dieOnTimeout is false`, () => {\n    location.hash = \"#bootstrap-times-out\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([\"./bootstrap-times-out.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./bootstrap-times-out.app.js\")).toEqual(singleSpa.MOUNTED);\n      expect(errs.length).toBe(0);\n    });\n  });","file":"apps/bootstrap-times-out/bootstrap-times-out.spec.js","skipped":false,"dir":"spec"},{"name":"will mount an application that began loading before start() was called","suites":["delayed-start"],"updatePoint":{"line":5,"column":76},"line":5,"code":"  it(\"will mount an application that began loading before start() was called\", async () => {\n    let loadPromise;\n    singleSpa.registerApplication({\n      name: \"delayed-start\",\n      app: () => loadPromise = (async () => {\n        // wait a tick before resolving the promise\n        await tick();\n        return await import(\"./delayed-start.app\");\n      })(),\n      activeWhen: () => true\n    });\n    expect(singleSpa.getAppStatus(\"delayed-start\")).toBe(singleSpa.NOT_LOADED);\n    await tick();\n    expect(singleSpa.getAppStatus(\"delayed-start\")).toBe(singleSpa.LOADING_SOURCE_CODE);\n    await singleSpa.triggerAppChange();\n    expect(singleSpa.getAppStatus(\"delayed-start\")).toBe(singleSpa.NOT_BOOTSTRAPPED);\n    singleSpa.start();\n    await Promise.all([loadPromise, routingEvent()]); // Before fixing https://github.com/single-spa/single-spa/issues/555,\n    // this assertion failed - status was NOT_BOOTSTRAPPED\n\n    expect(singleSpa.getAppStatus(\"delayed-start\")).toBe(singleSpa.MOUNTED);\n  });","file":"apps/delayed-start/delayed-start.spec.js","skipped":false,"dir":"spec"},{"name":"works just fine even though it's got empty arrays","suites":["empty-array-lifecycles"],"updatePoint":{"line":12,"column":55},"line":12,"code":"  it(`works just fine even though it's got empty arrays`, () => {\n    return singleSpa.triggerAppChange().then(() => {\n      expect(singleSpa.getMountedApps()).toEqual([\"./empty-array-lifecycles.app.js\"]);\n      location.hash = \"#not-empty-array-lifecycles\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getMountedApps()).toEqual([]);\n      });\n    });\n  });","file":"apps/empty-array-lifecycles/empty-array-lifecycles.spec.js","skipped":false,"dir":"spec"},{"name":"goes through the whole lifecycle successfully on multiple activeWhen conditions","suites":["happy-active-when"],"updatePoint":{"line":14,"column":85},"line":14,"code":"  it(`goes through the whole lifecycle successfully on multiple activeWhen conditions`, async () => {\n    singleSpa.start();\n    expect(myApp.isMounted()).toEqual(false);\n    expect(singleSpa.getMountedApps()).toEqual([]);\n    const validPaths = [\"/pathname\", \"/#/appWithRegularPrefix\", \"/specificCriteria\", \"/resource/1/subresource/1\", \"/#/hashResource/1/hashSubResource/1\", \"pathname/#/subpath/1/another\"];\n\n    for (let index = 0; index < validPaths.length; index++) {\n      singleSpa.navigateToUrl(validPaths[index] + \"/anything/everything\");\n      await singleSpa.triggerAppChange();\n      expectMyAppToBeMounted();\n      singleSpa.navigateToUrl(\"/#/unregisteredPath\");\n      await singleSpa.triggerAppChange();\n      expectMyAppToBeUnmounted();\n    }\n  });","file":"apps/happy-active-when/happy-active-when.spec.js","skipped":false,"dir":"spec"},{"name":"goes through the whole lifecycle successfully","suites":["happy-basic"],"updatePoint":{"line":12,"column":51},"line":12,"code":"  it(`goes through the whole lifecycle successfully`, () => {\n    expect(myApp.isMounted()).toEqual(false);\n    expect(singleSpa.getMountedApps()).toEqual([]);\n    location.hash = \"happy-basic\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.isMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([\"./happy-basic.app.js\"]);\n      location.hash = \"#not-happy-basic\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.wasBootstrapped()).toEqual(true);\n        expect(myApp.isMounted()).toEqual(false);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n      });\n    });\n  });","file":"apps/happy-basic/happy-basic.spec.js","skipped":false,"dir":"spec"},{"name":"goes through the whole lifecycle successfully","suites":["happy-register-object"],"updatePoint":{"line":16,"column":51},"line":16,"code":"  it(`goes through the whole lifecycle successfully`, () => {\n    expect(myApp.isMounted()).toEqual(false);\n    expect(singleSpa.getMountedApps()).toEqual([]);\n    location.hash = \"#happy-register-object\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.isMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([\"./happy-register-object.app.js\"]);\n      location.hash = \"#not-happy-register-object\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.wasBootstrapped()).toEqual(true);\n        expect(myApp.isMounted()).toEqual(false);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n      });\n    });\n  });","file":"apps/happy-register-object/happy-register-object.spec.js","skipped":false,"dir":"spec"},{"name":"unloads an app that is mounted, and then remounts it","suites":["happy-unload app :","when waitForUnmount = false :"],"updatePoint":{"line":14,"column":60},"line":14,"code":"    it(`unloads an app that is mounted, and then remounts it`, () => {\n      location.hash = activeHash;\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        location.hash = \"#\";\n        return singleSpa.unloadApplication(\"./happy-unload.app.js\");\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        window.location.hash = activeHash;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(2);\n        expect(myApp.getNumMountCalls()).toBe(2);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n      });\n    });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"unloads an app that isn't loaded, and then keeps it in NOT_LOADED status","suites":["happy-unload app :","when waitForUnmount = false :"],"updatePoint":{"line":42,"column":80},"line":42,"code":"    it(`unloads an app that isn't loaded, and then keeps it in NOT_LOADED status`, () => {\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(0);\n        expect(myApp.getNumMountCalls()).toBe(0);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        window.location.hash = activeHash;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        window.location.hash = \"#\";\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        return singleSpa.unloadApplication(\"./happy-unload.app.js\");\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n      });\n    });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"is a no-op if the app is NOT_LOADED when you call unloadApplication on it","suites":["happy-unload app :","when waitForUnmount = false :"],"updatePoint":{"line":74,"column":81},"line":74,"code":"    it(`is a no-op if the app is NOT_LOADED when you call unloadApplication on it`, () => {\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(0);\n        expect(myApp.getNumMountCalls()).toBe(0);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n      }).then(() => singleSpa.unloadApplication(\"./happy-unload.app.js\")).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(0);\n        expect(myApp.getNumMountCalls()).toBe(0);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n      });\n    });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"immediately unloads apps in NOT_MOUNTED status, and then puts them into NOT_LOADED status (ready for next time they are activated)","suites":["happy-unload app :","when waitForUnmount = false :"],"updatePoint":{"line":89,"column":138},"line":89,"code":"    it(`immediately unloads apps in NOT_MOUNTED status, and then puts them into NOT_LOADED status (ready for next time they are activated)`, () => {\n      window.location.hash = activeHash;\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        window.location.hash = \"#\";\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        return singleSpa.unloadApplication(\"./happy-unload.app.js\");\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n        window.location.hash = activeHash;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(2);\n        expect(myApp.getNumMountCalls()).toBe(2);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n      });\n    });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"delays unloading the app until the app is no longer active","suites":["happy-unload app :","when waitForUnmount = true :"],"updatePoint":{"line":124,"column":66},"line":124,"code":"    it(`delays unloading the app until the app is no longer active`, () => {\n      window.location.hash = activeHash;\n      let originalUnloadPromise;\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        originalUnloadPromise = singleSpa.unloadApplication(\"./happy-unload.app.js\", {\n          waitForUnmount: true\n        }).then(() => {\n          /* This will get called only once the app is unloaded. And it will not\n           * wait for the app to get remounted before it is called.\n           */\n          expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n          expect(myApp.getNumBootstrapCalls()).toBe(1);\n          expect(myApp.getNumMountCalls()).toBe(1);\n          expect(myApp.getNumUnmountCalls()).toBe(1);\n          expect(myApp.getNumUnloadCalls()).toBe(1);\n        });\n        /* Triggering an app change after calling unloadApplication will\n         * not cause the app to unload, since it is still mounted and we set\n         * waitForUnmount: true.\n         */\n\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(0);\n        expect(myApp.getNumUnloadCalls()).toBe(0);\n        window.location.hash = `#`;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"NOT_LOADED\");\n        expect(myApp.getNumBootstrapCalls()).toBe(1);\n        expect(myApp.getNumMountCalls()).toBe(1);\n        expect(myApp.getNumUnmountCalls()).toBe(1);\n        expect(myApp.getNumUnloadCalls()).toBe(1);\n        return originalUnloadPromise;\n      });\n    });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"resolves the promise for all callers to unloadApplication when the app is unloaded","suites":["happy-unload app :","when waitForUnmount = true :"],"updatePoint":{"line":169,"column":88},"line":169,"code":"  it(`resolves the promise for all callers to unloadApplication when the app is unloaded`, () => {\n    window.location.hash = activeHash;\n    let firstCallerResolved = false,\n        secondCallerResolved = false;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(singleSpa.getAppStatus(\"./happy-unload.app.js\")).toEqual(\"MOUNTED\");\n      expect(myApp.getNumBootstrapCalls()).toBe(1);\n      expect(myApp.getNumMountCalls()).toBe(1);\n      expect(myApp.getNumUnmountCalls()).toBe(0);\n      expect(myApp.getNumUnloadCalls()).toBe(0);\n    }).then(() => {\n      // First caller to unloadApplication wants to waitForUnmount\n      const promise1 = singleSpa.unloadApplication(\"./happy-unload.app.js\", {\n        waitForUnmount: true\n      }); // Second caller to unloadApplication doesn't want to waitForUnmount\n\n      const promise2 = singleSpa.unloadApplication(\"./happy-unload.app.js\", {\n        waitForUnmount: false\n      });\n      return Promise.all([promise1, promise2]);\n    });\n  });","file":"apps/happy-unload/happy-unload.spec.js","skipped":false,"dir":"spec"},{"name":"is never bootstrapped, mounted, or unmounted","suites":["invalid-bootstrap app"],"updatePoint":{"line":24,"column":50},"line":24,"code":"  it(`is never bootstrapped, mounted, or unmounted`, () => {\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.mountWasCalled()).toEqual(false);\n      expect(myApp.unmountWasCalled()).toEqual(false);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./invalid-bootstrap.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      expect(errs.length).toBeGreaterThan(0);\n    });\n  });","file":"apps/invalid-bootstrap/invalid-bootstrap.spec.js","skipped":false,"dir":"spec"},{"name":"Dies if the load function returns nothing","suites":["invalid-load-function"],"updatePoint":{"line":18,"column":47},"line":18,"code":"  it(\"Dies if the load function returns nothing\", () => {\n    function loadFunction() {// return nothing\n    }\n\n    singleSpa.registerApplication(\"invalid-load-1\", loadFunction, location => location.hash === \"#invalid-load-function\");\n    location.hash = \"#invalid-load-function\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBeGreaterThan(0);\n      expect(errs[0].appOrParcelName).toBe(\"invalid-load-1\");\n      expect(errs[0].message.indexOf(\"single-spa loading function did not return a promise. Check the second argument to registerApplication\")).toBeGreaterThan(-1);\n      expect(singleSpa.getAppStatus(\"invalid-load-1\")).toBe(singleSpa.SKIP_BECAUSE_BROKEN);\n    });\n  });","file":"apps/invalid-load-function/invalid-load-function.spec.js","skipped":false,"dir":"spec"},{"name":"Dies if the load function returns a function instead of a promise","suites":["invalid-load-function"],"updatePoint":{"line":31,"column":71},"line":31,"code":"  it(\"Dies if the load function returns a function instead of a promise\", () => {\n    function loadFunction() {// return nothing\n    }\n\n    singleSpa.registerApplication(\"invalid-load-2\", loadFunction, location => location.hash === \"#invalid-load-function\");\n    location.hash = \"#invalid-load-function\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBeGreaterThan(0);\n      expect(errs[0].appOrParcelName).toBe(\"invalid-load-2\");\n      expect(errs[0].message.indexOf(\"single-spa loading function did not return a promise. Check the second argument to registerApplication\")).toBeGreaterThan(-1);\n      expect(singleSpa.getAppStatus(\"invalid-load-2\")).toBe(singleSpa.SKIP_BECAUSE_BROKEN);\n    });\n  });","file":"apps/invalid-load-function/invalid-load-function.spec.js","skipped":false,"dir":"spec"},{"name":"Dies if the load function returns a non-thenable object","suites":["invalid-load-function"],"updatePoint":{"line":44,"column":61},"line":44,"code":"  it(\"Dies if the load function returns a non-thenable object\", () => {\n    function loadFunction() {// return nothing\n    }\n\n    singleSpa.registerApplication(\"invalid-load-3\", loadFunction, location => location.hash === \"#invalid-load-function\");\n    location.hash = \"#invalid-load-function\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBeGreaterThan(0);\n      expect(errs[0].appOrParcelName).toBe(\"invalid-load-3\");\n      expect(errs[0].message.indexOf(\"single-spa loading function did not return a promise. Check the second argument to registerApplication\")).toBeGreaterThan(-1);\n      expect(singleSpa.getAppStatus(\"invalid-load-3\")).toBe(singleSpa.SKIP_BECAUSE_BROKEN);\n    });\n  });","file":"apps/invalid-load-function/invalid-load-function.spec.js","skipped":false,"dir":"spec"},{"name":"It retries loading an application that previously failed","suites":["invalid-load-function"],"updatePoint":{"line":57,"column":62},"line":57,"code":"  it(\"It retries loading an application that previously failed\", () => {\n    let count = 0;\n\n    function loadFunction() {\n      count++;\n      if (count === 1) return Promise.reject(`It didn't load`);else return Promise.resolve({\n        bootstrap: () => new Promise(),\n        mount: () => new Promise(),\n        unmount: () => new Promise()\n      });\n    }\n\n    singleSpa.registerApplication(\"invalid-load-4\", loadFunction, location => location.hash.includes(\"#invalid-load-function\"));\n    location.hash = \"#invalid-load-function\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(errs.length).toBeGreaterThan(0);\n      expect(errs[0].appOrParcelName).toBe(\"invalid-load-4\");\n      expect(errs[0].message.indexOf(`It didn't load`)).toBeGreaterThan(-1);\n      location.hash = \"#invalid-load-function-1\";\n      return new Promise(resolve => setTimeout(resolve, 201)).then(() => singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getAppStatus(\"invalid-load-4\")).toBe(singleSpa.NOT_BOOTSTRAPPED);\n      }));\n    });\n  });","file":"apps/invalid-load-function/invalid-load-function.spec.js","skipped":false,"dir":"spec"},{"name":"is bootstrapped and mounted, but then put in a broken state","suites":["invalid-mount app"],"updatePoint":{"line":22,"column":65},"line":22,"code":"  it(`is bootstrapped and mounted, but then put in a broken state`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./invalid-mount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      location.hash = \"not-invalid-mount\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./invalid-mount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      });\n    });\n  });","file":"apps/invalid-mount/invalid-mount.spec.js","skipped":false,"dir":"spec"},{"name":"is never bootstrapped","suites":["invalid-no-mount app"],"updatePoint":{"line":21,"column":27},"line":21,"code":"  it(`is never bootstrapped`, () => {\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.isBootstrapped()).toEqual(false);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./invalid-no-mount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n    });\n  });","file":"apps/invalid-no-mount/invalid-no-mount.spec.js","skipped":false,"dir":"spec"},{"name":"is never bootstrapped","suites":["invalid-no-unmount app"],"updatePoint":{"line":22,"column":27},"line":22,"code":"  it(`is never bootstrapped`, () => {\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.isBootstrapped()).toEqual(false);\n      expect(myApp.isMounted()).toEqual(false);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./invalid-no-unmount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n    });\n  });","file":"apps/invalid-no-unmount/invalid-no-unmount.spec.js","skipped":false,"dir":"spec"},{"name":"throws an error if you call unloadApplication incorrectly","suites":["invalid-unload app :"],"updatePoint":{"line":21,"column":63},"line":21,"code":"  it(`throws an error if you call unloadApplication incorrectly`, () => {\n    expect(() => {\n      // The parameters are in the reverse order\n      singleSpa.unloadApplication({\n        waitForUnmount\n      }, \"./invalid-unload.app.js\");\n    }).toThrow();\n    expect(() => {\n      // Trying to unload an app that doesn't exist\n      singleSpa.unloadApplication(\"App that doesn't exist\");\n    }).toThrow();\n  });","file":"apps/invalid-unload/invalid-unload.spec.js","skipped":false,"dir":"spec"},{"name":"puts the app into SKIP_BECAUSE_BROKEN because it has an incorrect unload lifecycle","suites":["invalid-unload app :"],"updatePoint":{"line":33,"column":88},"line":33,"code":"  it(`puts the app into SKIP_BECAUSE_BROKEN because it has an incorrect unload lifecycle`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      // The unload lifecycle hasn't been called yet, so single-spa doesn't know it is a bad impl yet.\n      expect(singleSpa.getAppStatus(\"./invalid-unload.app.js\")).toBe(\"MOUNTED\");\n      return singleSpa.unloadApplication(\"./invalid-unload.app.js\");\n    }).then(() => {\n      fail(`unloadApplication() should have rejected the promise it returned because the app has a bad implementation of the unload lifecycle`);\n    }).catch(err => {\n      // Now the unload lifecycle has been called and has been determined to be invalid\n      expect(singleSpa.getAppStatus(\"./invalid-unload.app.js\")).toBe(\"SKIP_BECAUSE_BROKEN\");\n    });\n  });","file":"apps/invalid-unload/invalid-unload.spec.js","skipped":false,"dir":"spec"},{"name":"is bootstrapped, mounted, and unmounted, but then put in a broken state and never again mounted","suites":["invalid-unmount app"],"updatePoint":{"line":25,"column":101},"line":25,"code":"  it(`is bootstrapped, mounted, and unmounted, but then put in a broken state and never again mounted`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.numBootstraps()).toEqual(1);\n      expect(myApp.numMounts()).toEqual(1);\n      expect(singleSpa.getMountedApps()).toEqual([\"./invalid-unmount.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./invalid-unmount.app.js\")).toEqual(\"MOUNTED\"); // now unmount, which will be the first time it enters a broken state\n\n      location.hash = \"#not-invalid-unmount\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.numBootstraps()).toEqual(1);\n        expect(myApp.numMounts()).toEqual(1);\n        expect(myApp.numUnmounts()).toEqual(1);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./invalid-unmount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\"); // now remount and check if it tries to mount despite being in a broken state\n\n        location.hash = activeHash;\n        return singleSpa.triggerAppChange().then(() => {\n          expect(myApp.numBootstraps()).toEqual(1);\n          expect(myApp.numMounts()).toEqual(1); // hasn't increased\n\n          expect(myApp.numUnmounts()).toEqual(1);\n          expect(singleSpa.getMountedApps()).toEqual([]);\n          expect(singleSpa.getAppStatus(\"./invalid-unmount.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n        });\n      });\n    });\n  });","file":"apps/invalid-unmount/invalid-unmount.spec.js","skipped":false,"dir":"spec"},{"name":"is given dynamic props from a function for each lifecycle function","suites":["lifecycle-props-function app"],"updatePoint":{"line":21,"column":72},"line":21,"code":"  it(`is given dynamic props from a function for each lifecycle function`, async () => {\n    customProps = {\n      dynamically: \"set\"\n    }; // This mounts the app\n\n    window.location.hash = activeHash;\n    await singleSpa.triggerAppChange(); // This unmounts the app\n\n    window.location.hash = `#/no-app`;\n    await singleSpa.triggerAppChange();\n    await singleSpa.unloadApplication(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().singleSpa).toBeDefined();\n    expect(myApp.getUnmountProps().singleSpa).toBeDefined();\n    expect(myApp.getUnloadProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnmountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnloadProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getBootstrapProps().dynamically).toEqual(\"set\");\n    expect(myApp.getMountProps().dynamically).toEqual(\"set\");\n    expect(myApp.getUnmountProps().dynamically).toEqual(\"set\");\n    expect(myApp.getUnloadProps().dynamically).toEqual(\"set\");\n    expect(console.warn).not.toHaveBeenCalled();\n  });","file":"apps/lifecycle-props-function/lifecycle-props-function.spec.js","skipped":false,"dir":"spec"},{"name":"logs a warning if the custom props function returns null","suites":["lifecycle-props-function app"],"updatePoint":{"line":46,"column":62},"line":46,"code":"  it(`logs a warning if the custom props function returns null`, async () => {\n    customProps = null; // This mounts the app\n\n    window.location.hash = activeHash;\n    await singleSpa.triggerAppChange(); // This unmounts the app\n\n    window.location.hash = `#/no-app`;\n    await singleSpa.triggerAppChange();\n    await singleSpa.unloadApplication(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().singleSpa).toBeDefined();\n    expect(myApp.getUnmountProps().singleSpa).toBeDefined();\n    expect(myApp.getUnloadProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnmountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnloadProps().name).toEqual(\"lifecycle-props-function\");\n    expect(console.warn).toHaveBeenCalled();\n    expect(console.warn.mock.calls[0][0]).toMatch(`lifecycle-props-function's customProps function must return an object`);\n  });","file":"apps/lifecycle-props-function/lifecycle-props-function.spec.js","skipped":false,"dir":"spec"},{"name":"logs a warning if the custom props function doesn't return an object","suites":["lifecycle-props-function app"],"updatePoint":{"line":66,"column":74},"line":66,"code":"  it(`logs a warning if the custom props function doesn't return an object`, async () => {\n    customProps = \"string\"; // This mounts the app\n\n    window.location.hash = activeHash;\n    await singleSpa.triggerAppChange(); // This unmounts the app\n\n    window.location.hash = `#/no-app`;\n    await singleSpa.triggerAppChange();\n    await singleSpa.unloadApplication(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().singleSpa).toBeDefined();\n    expect(myApp.getUnmountProps().singleSpa).toBeDefined();\n    expect(myApp.getUnloadProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnmountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnloadProps().name).toEqual(\"lifecycle-props-function\");\n    expect(console.warn).toHaveBeenCalled();\n    expect(console.warn.mock.calls[0][0]).toMatch(`lifecycle-props-function's customProps function must return an object`);\n  });","file":"apps/lifecycle-props-function/lifecycle-props-function.spec.js","skipped":false,"dir":"spec"},{"name":"logs a warning if the custom props function returns an array","suites":["lifecycle-props-function app"],"updatePoint":{"line":86,"column":66},"line":86,"code":"  it(`logs a warning if the custom props function returns an array`, async () => {\n    customProps = []; // This mounts the app\n\n    window.location.hash = activeHash;\n    await singleSpa.triggerAppChange(); // This unmounts the app\n\n    window.location.hash = `#/no-app`;\n    await singleSpa.triggerAppChange();\n    await singleSpa.unloadApplication(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().singleSpa).toBeDefined();\n    expect(myApp.getUnmountProps().singleSpa).toBeDefined();\n    expect(myApp.getUnloadProps().singleSpa).toBeDefined();\n    expect(myApp.getBootstrapProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getMountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnmountProps().name).toEqual(\"lifecycle-props-function\");\n    expect(myApp.getUnloadProps().name).toEqual(\"lifecycle-props-function\");\n    expect(console.warn).toHaveBeenCalled();\n    expect(console.warn.mock.calls[0][0]).toMatch(`lifecycle-props-function's customProps function must return an object`);\n  });","file":"apps/lifecycle-props-function/lifecycle-props-function.spec.js","skipped":false,"dir":"spec"},{"name":"is given the correct props for each lifecycle function","suites":["lifecycle-props app"],"updatePoint":{"line":11,"column":60},"line":11,"code":"  it(`is given the correct props for each lifecycle function`, () => {\n    singleSpa.registerApplication(\"lifecycle-props\", () => import(\"./lifecycle-props.app.js\"), location => location.hash === activeHash); // This mounts the app\n\n    window.location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      // This unmounts the app\n      window.location.hash = `#/no-app`;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      return singleSpa.unloadApplication(\"lifecycle-props\");\n    }).then(() => {\n      expect(myApp.getMountProps().singleSpa).toBeDefined();\n      expect(myApp.getBootstrapProps().singleSpa).toBeDefined();\n      expect(myApp.getUnmountProps().singleSpa).toBeDefined();\n      expect(myApp.getUnloadProps().singleSpa).toBeDefined();\n      expect(myApp.getBootstrapProps().name).toEqual(\"lifecycle-props\");\n      expect(myApp.getMountProps().name).toEqual(\"lifecycle-props\");\n      expect(myApp.getUnmountProps().name).toEqual(\"lifecycle-props\");\n      expect(myApp.getUnloadProps().name).toEqual(\"lifecycle-props\");\n    });\n  });","file":"apps/lifecycle-props/lifecycle-props.spec.js","skipped":false,"dir":"spec"},{"name":"is given the correct props for each lifecycle function if customProps are passed","suites":["lifecycle-props app"],"updatePoint":{"line":32,"column":86},"line":32,"code":"  it(`is given the correct props for each lifecycle function if customProps are passed`, () => {\n    singleSpa.registerApplication(\"lifecycle-props-customProps\", () => import(\"./lifecycle-props.app.js\"), location => location.hash === activeHash, {\n      test: \"test\"\n    }); // This mounts the app\n\n    window.location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      // This unmounts the app\n      window.location.hash = `#/no-app`;\n      return singleSpa.triggerAppChange();\n    }).then(() => singleSpa.unloadApplication(\"lifecycle-props-customProps\")).then(() => {\n      expect(myApp.getBootstrapProps().test).toEqual(\"test\");\n      expect(myApp.getMountProps().test).toEqual(\"test\");\n      expect(myApp.getUnmountProps().test).toEqual(\"test\");\n      expect(myApp.getUnloadProps().test).toEqual(\"test\");\n    });\n  });","file":"apps/lifecycle-props/lifecycle-props.spec.js","skipped":false,"dir":"spec"},{"name":"will mount an application before loading another application finishes","suites":["load-error"],"updatePoint":{"line":3,"column":75},"line":3,"code":"  it(`will mount an application before loading another application finishes`, async () => {\n    singleSpa.addErrorHandler(handleError);\n    singleSpa.registerApplication(\"load-error\", () => Promise.reject(Error(`load failed`)), location => location.hash === \"#load-error\");\n    location.hash = \"#load-error\";\n    await singleSpa.triggerAppChange();\n    expect(singleSpa.getAppStatus(\"load-error\")).toBe(singleSpa.LOAD_ERROR);\n    singleSpa.removeErrorHandler(handleError);\n\n    function handleError(err) {\n      console.error(err);\n    }\n  });","file":"apps/load-error/load-error.spec.js","skipped":false,"dir":"spec"},{"name":"puts app into LOAD_ERROR status before firing error event","suites":["load-error"],"updatePoint":{"line":15,"column":63},"line":15,"code":"  it(`puts app into LOAD_ERROR status before firing error event`, async () => {\n    let numErrs = 0;\n    await singleSpa.triggerAppChange();\n    singleSpa.addErrorHandler(handleError);\n    singleSpa.registerApplication(\"load-error-2\", () => Promise.reject(Error(`load failed`)), location => location.hash === \"#load-error-2\");\n    location.hash = \"#load-error-2\";\n    await singleSpa.triggerAppChange();\n    singleSpa.removeErrorHandler(handleError);\n    expect(numErrs).toBe(1);\n\n    function handleError(evt) {\n      numErrs++;\n      const appName = evt.appOrParcelName;\n      expect(singleSpa.getAppStatus(appName)).toBe(singleSpa.LOAD_ERROR);\n    }\n  });","file":"apps/load-error/load-error.spec.js","skipped":false,"dir":"spec"},{"name":"lets you unload an application that is in LOAD_ERROR status","suites":["load-error"],"updatePoint":{"line":31,"column":65},"line":31,"code":"  it(`lets you unload an application that is in LOAD_ERROR status`, async () => {\n    await singleSpa.triggerAppChange();\n    singleSpa.addErrorHandler(errHandler);\n    singleSpa.registerApplication({\n      name: \"load-error-unload\",\n      app: () => Promise.reject(Error(\"load failed\")),\n      activeWhen: [\"#load-error-unload\"]\n    });\n    location.hash = \"#load-error-unload\";\n    await singleSpa.triggerAppChange();\n    expect(singleSpa.getAppStatus(\"load-error-unload\")).toBe(singleSpa.LOAD_ERROR);\n    const unloadPromise = singleSpa.unloadApplication(\"load-error-unload\");\n    location.hash = \"#no-longer-active\";\n    await singleSpa.triggerAppChange();\n    await unloadPromise;\n    expect(singleSpa.getAppStatus(\"load-error-unload\")).toBe(singleSpa.NOT_LOADED);\n\n    function errHandler() {\n      singleSpa.removeErrorHandler(errHandler);\n    }\n  });","file":"apps/load-error/load-error.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't try to reload an application that should not be active","suites":["load-error"],"updatePoint":{"line":52,"column":68},"line":52,"code":"  it(`doesn't try to reload an application that should not be active`, async () => {\n    let numLoads = 0;\n    await singleSpa.triggerAppChange();\n    singleSpa.addErrorHandler(handleError);\n    singleSpa.registerApplication({\n      name: \"load-error-3\",\n      app: async () => {\n        numLoads++;\n        throw Error(\"this app never loads\");\n      },\n      activeWhen: [\"#load-error-3\"]\n    });\n    location.hash = \"#load-error-3\";\n    expect(numLoads).toBe(0);\n    await singleSpa.triggerAppChange();\n    expect(numLoads).toBe(1);\n    location.hash = \"#something-else\";\n    await singleSpa.triggerAppChange();\n    expect(numLoads).toBe(1); // single-spa retries loading apps in LOAD_ERROR state after 200ms\n\n    await twoHundredMs();\n    await singleSpa.triggerAppChange();\n    expect(numLoads).toBe(1);\n    singleSpa.removeErrorHandler(handleError);\n\n    function handleError(err) {\n      console.error(err);\n    }\n  });","file":"apps/load-error/load-error.spec.js","skipped":false,"dir":"spec"},{"name":"will mount an application before loading another application finishes","suites":["mount-before-other-loads"],"updatePoint":{"line":16,"column":75},"line":16,"code":"  it(`will mount an application before loading another application finishes`, async () => {\n    location.hash = \"#mount-before-other-loads\";\n    const appChangeResultBeforeStart = await singleSpa.triggerAppChange();\n    expect(appChangeResultBeforeStart).toEqual([]);\n    let order = [];\n    const slowApp = {\n      bootstrap: async () => {\n        order.push(\"slow:bootstrap\");\n      },\n      mount: async () => {\n        order.push(\"slow:mount\");\n      },\n      unmount: async () => {\n        order.push(\"slow:unmount\");\n      }\n    };\n    const fastApp = {\n      bootstrap: async () => {\n        order.push(\"fast:bootstrap\");\n      },\n      mount: async () => {\n        order.push(\"fast:mount\");\n      },\n      unmount: async () => {\n        order.push(\"fast:unmount\");\n      }\n    };\n    singleSpa.registerApplication(\"slow-load\", () => new Promise(resolve => {\n      setTimeout(() => {\n        order.push(\"slow:load\");\n        resolve(slowApp);\n      }, 30);\n    }), location => location.hash.startsWith(\"#mount-before-other-loads\"));\n    singleSpa.registerApplication(\"fast-load\", async () => {\n      order.push(\"fast:load\");\n      return fastApp;\n    }, location => location.hash.startsWith(\"#mount-before-other-loads\"));\n    expect(errs.length).toBe(0);\n    expect(order).toEqual([]);\n    singleSpa.start();\n    await singleSpa.triggerAppChange();\n    expect(errs.length).toBe(0);\n    expect(order).toEqual([\"fast:load\", \"fast:bootstrap\", \"fast:mount\", \"slow:load\", \"slow:bootstrap\", \"slow:mount\"]);\n  });","file":"apps/mount-before-other-loads/mount-before-other-loads.spec.js","skipped":false,"dir":"spec"},{"name":"bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN and unmounts as a last effort","suites":["mount-fails app"],"updatePoint":{"line":21,"column":99},"line":21,"code":"  it(`bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN and unmounts as a last effort`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(true);\n      expect(myApp.wasUnmounted()).toEqual(true); // We try to unmount an application if it fails to mount.\n\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./mount-fails.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      location.hash = \"#not-mount-fails\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.wasUnmounted()).toEqual(true);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./mount-fails.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      });\n    });\n  });","file":"apps/mount-fails/mount-fails.spec.js","skipped":false,"dir":"spec"},{"name":"bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN and never unmounts","suites":["mount-rejects app"],"updatePoint":{"line":21,"column":88},"line":21,"code":"  it(`bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN and never unmounts`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./mount-rejects.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      location.hash = \"#not-mount-rejects\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./mount-rejects.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      });\n    });\n  });","file":"apps/mount-rejects/mount-rejects.spec.js","skipped":false,"dir":"spec"},{"name":"is put into SKIP_BECAUSE_BROKEN if dieOnTimeout is true","suites":["mount-times-out-dies app"],"updatePoint":{"line":21,"column":61},"line":21,"code":"  it(`is put into SKIP_BECAUSE_BROKEN if dieOnTimeout is true`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.bootstraps()).toEqual(1);\n      expect(myApp.mounts()).toEqual(1);\n      expect(singleSpa.getMountedApps()).toEqual([]);\n      expect(singleSpa.getAppStatus(\"./mount-times-out-dies.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n    });\n  });","file":"apps/mount-times-out-dies/mount-times-out-dies.spec.js","skipped":false,"dir":"spec"},{"name":"is just waited for if dieOnTimeout is false","suites":["mount-times-out app"],"updatePoint":{"line":21,"column":49},"line":21,"code":"  it(`is just waited for if dieOnTimeout is false`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.bootstraps()).toEqual(1);\n      expect(myApp.mounts()).toEqual(1);\n      expect(singleSpa.getMountedApps()).toEqual([\"./mount-times-out.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./mount-times-out.app.js\")).toEqual(\"MOUNTED\");\n    });\n  });","file":"apps/mount-times-out/mount-times-out.spec.js","skipped":false,"dir":"spec"},{"name":"waits for each of the functions one by one, in order","suites":["multiple-lifecycle-functions app"],"updatePoint":{"line":13,"column":58},"line":13,"code":"  it(`waits for each of the functions one by one, in order`, () => {\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.bootstrapsCalledOutOfOrder()).toEqual(undefined);\n      expect(myApp.bootstrap1Called()).toEqual(true);\n      expect(myApp.bootstrap2Called()).toEqual(true);\n      expect(myApp.bootstrap3Called()).toEqual(true);\n      expect(myApp.mountsCalledOutOfOrder()).toEqual(undefined);\n      expect(myApp.mount1Called()).toEqual(true);\n      expect(myApp.mount2Called()).toEqual(true);\n      expect(myApp.mount3Called()).toEqual(true);\n      location.hash = \"#not-multiple-lifecycle-functions\";\n      singleSpa.triggerAppChange().then(() => {\n        expect(myApp.unmountsCalledOutOfOrder()).toEqual(undefined);\n        expect(myApp.unmount1Called()).toEqual(true);\n        expect(myApp.unmount2Called()).toEqual(true);\n        expect(myApp.unmount3Called()).toEqual(true);\n      });\n    });\n  });","file":"apps/multiple-lifecycle-functions/multiple-lifecycle-functions.spec.js","skipped":false,"dir":"spec"},{"name":"allows an application to omit the bootstrap lifecycle","suites":["no-bootstrap app"],"updatePoint":{"line":16,"column":59},"line":16,"code":"  it(`allows an application to omit the bootstrap lifecycle`, async () => {\n    expect(singleSpa.getAppStatus(\"no-bootstrap\")).toBe(singleSpa.NOT_LOADED);\n    location.hash = activeHash;\n    await singleSpa.triggerAppChange();\n    expect(singleSpa.getAppStatus(\"no-bootstrap\")).toBe(singleSpa.MOUNTED);\n  });","file":"apps/no-bootstrap/no-bootstrap.spec.js","skipped":false,"dir":"spec"},{"name":"works when the application doesn't have the Object prototype","suites":["no-object-prototype app"],"updatePoint":{"line":25,"column":66},"line":25,"code":"  it(`works when the application doesn't have the Object prototype`, async () => {\n    expect(singleSpa.getAppStatus(\"no-object-prototype\")).toBe(singleSpa.NOT_LOADED);\n    location.hash = activeHash;\n    await singleSpa.triggerAppChange();\n    expect(singleSpa.getAppStatus(\"no-object-prototype\")).toBe(singleSpa.MOUNTED);\n  });","file":"apps/no-object-prototype/no-object-prototype.spec.js","skipped":false,"dir":"spec"},{"name":"shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully","suites":["partial rerouting"],"updatePoint":{"line":11,"column":174},"line":11,"code":"  it(\"shouldn't bootstrap and mount app if the route has been changed while app was loading, but if the user navigates back it should be bootstrapped and mounted successfully\", async () => {\n    const activeHash = \"#partial-rerouting\";\n    let bootstrapped = false;\n    let mounted = false;\n    let unmounted = false;\n    const app = {\n      async bootstrap() {\n        bootstrapped = true;\n      },\n\n      async mount() {\n        mounted = true;\n      },\n\n      async unmount() {\n        unmounted = true;\n      }\n\n    };\n    singleSpa.registerApplication(\"partial-rerouting\", () => delay().then(() => app), location => location.hash === activeHash);\n    location.hash = activeHash;\n    const promise = singleSpa.triggerAppChange();\n    singleSpa.navigateToUrl(\"#another-url\");\n    await Promise.all([singleSpa.triggerAppChange(), promise]);\n    expect(bootstrapped).toBeFalsy();\n    expect(mounted).toBeFalsy();\n    expect(unmounted).toBeFalsy();\n    singleSpa.navigateToUrl(activeHash);\n    await singleSpa.triggerAppChange();\n    expect(bootstrapped).toBeTruthy();\n    expect(mounted).toBeTruthy();\n    singleSpa.navigateToUrl(\"#another-url\");\n    await singleSpa.triggerAppChange();\n    expect(unmounted).toBeTruthy();\n  });","file":"apps/partial-rerouting/partial-rerouting.spec.js","skipped":false,"dir":"spec"},{"name":"should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed","suites":["partial rerouting"],"updatePoint":{"line":46,"column":141},"line":46,"code":"  it(\"should bootstrap and mount second app succcessfully, but should skip bootstrapping and mounting first app if the route has been changed\", async () => {\n    let firstAppBootstrapped = false,\n        firstAppMounted = false,\n        firstAppUnmounted = false;\n    const firstApp = {\n      async bootstrap() {\n        firstAppBootstrapped = true;\n      },\n\n      async mount() {\n        firstAppMounted = true;\n      },\n\n      async unmount() {\n        firstAppUnmounted = true;\n      }\n\n    };\n    let secondAppBootstrapped = false,\n        secondAppMounted = false,\n        secondAppUnmounted = false;\n    const secondApp = {\n      async bootstrap() {\n        secondAppBootstrapped = true;\n      },\n\n      async mount() {\n        secondAppMounted = true;\n      },\n\n      async unmount() {\n        secondAppUnmounted = true;\n      }\n\n    };\n    const firstAppActiveHash = \"#first-app\";\n    const secondAppActiveHash = \"#second-app\";\n    singleSpa.registerApplication(\"first-app\", () => delay().then(() => firstApp), location => location.hash === firstAppActiveHash);\n    singleSpa.registerApplication(\"second-app\", () => Promise.resolve(secondApp), location => location.hash === secondAppActiveHash);\n    location.hash = firstAppActiveHash;\n    const promise = singleSpa.triggerAppChange();\n    singleSpa.navigateToUrl(secondAppActiveHash);\n    await Promise.all([singleSpa.triggerAppChange(), promise]);\n    expect(firstAppBootstrapped).toBeFalsy();\n    expect(secondAppBootstrapped).toBeTruthy();\n    expect(secondAppMounted).toBeTruthy();\n    expect(secondAppUnmounted).toBeFalsy();\n    singleSpa.navigateToUrl(firstAppActiveHash);\n    await singleSpa.triggerAppChange();\n    expect(secondAppUnmounted).toBeTruthy();\n    expect(firstAppBootstrapped).toBeTruthy();\n    expect(firstAppMounted).toBeTruthy();\n  });","file":"apps/partial-rerouting/partial-rerouting.spec.js","skipped":false,"dir":"spec"},{"name":"goes through the whole lifecycle successfully","suites":["register-with-object"],"updatePoint":{"line":30,"column":51},"line":30,"code":"  it(`goes through the whole lifecycle successfully`, () => {\n    expect(mounted).toEqual(false);\n    expect(singleSpa.getMountedApps()).toEqual([]);\n    location.hash = \"#register-with-object\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(bootstrapped).toEqual(true);\n      expect(mounted).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([\"register-with-object\"]);\n      location.hash = \"#not-register-with-object\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(bootstrapped).toEqual(true);\n        expect(mounted).toEqual(false);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n      });\n    });\n  });","file":"apps/register-with-object/register-with-object.spec.js","skipped":false,"dir":"spec"},{"name":"goes through the whole lifecycle successfully","suites":["returns-non-native-promise"],"updatePoint":{"line":12,"column":51},"line":12,"code":"  it(`goes through the whole lifecycle successfully`, () => {\n    expect(myApp.wasMounted()).toEqual(false);\n    expect(singleSpa.getMountedApps()).toEqual([]);\n    location.hash = \"#returns-non-native-promise\";\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.wasBootstrapped()).toEqual(true);\n      expect(myApp.wasMounted()).toEqual(true);\n      expect(singleSpa.getMountedApps()).toEqual([\"./returns-non-native-promise.app.js\"]);\n      location.hash = \"#something-else\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.wasBootstrapped()).toEqual(true);\n        expect(myApp.wasUnmounted()).toEqual(true);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n      });\n    });\n  });","file":"apps/returns-non-native-promise/returns-non-native-promise.spec.js","skipped":false,"dir":"spec"},{"name":"bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN once it unmounts","suites":["unmount-rejects app"],"updatePoint":{"line":21,"column":86},"line":21,"code":"  it(`bootstraps and mounts, but then is put into SKIP_BECAUSE_BROKEN once it unmounts`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.numBootstraps()).toEqual(1);\n      expect(myApp.numMounts()).toEqual(1);\n      expect(myApp.numUnmounts()).toEqual(0);\n      expect(singleSpa.getMountedApps()).toEqual([\"./unmount-rejects.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./unmount-rejects.app.js\")).toEqual(\"MOUNTED\");\n      location.hash = \"#not-unmount-rejects\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.numUnmounts()).toEqual(1);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./unmount-rejects.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n        location.hash = \"#unmount-rejects\";\n        return singleSpa.triggerAppChange().then(() => {\n          // it shouldn't be mounted again\n          expect(myApp.numMounts()).toEqual(1);\n          expect(singleSpa.getMountedApps()).toEqual([]);\n          expect(singleSpa.getAppStatus(\"./unmount-rejects.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n        });\n      });\n    });\n  });","file":"apps/unmount-rejects/unmount-rejects.spec.js","skipped":false,"dir":"spec"},{"name":"is put into SKIP_BECAUSE_BROKEN when dieOnTimeout is true","suites":["unmount-times-out-dies app"],"updatePoint":{"line":21,"column":63},"line":21,"code":"  it(`is put into SKIP_BECAUSE_BROKEN when dieOnTimeout is true`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.numBootstraps()).toEqual(1);\n      expect(myApp.numMounts()).toEqual(1);\n      expect(singleSpa.getMountedApps()).toEqual([\"./unmount-times-out-dies.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./unmount-times-out-dies.app.js\")).toEqual(\"MOUNTED\");\n      location.hash = \"#not-unmount-times-out\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.numUnmounts()).toEqual(1);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./unmount-times-out-dies.app.js\")).toEqual(\"SKIP_BECAUSE_BROKEN\");\n      });\n    });\n  });","file":"apps/unmount-times-out-dies/unmount-times-out-dies.spec.js","skipped":false,"dir":"spec"},{"name":"is just waited for if dieOnTimeout is false","suites":["unmount-times-out app"],"updatePoint":{"line":30,"column":49},"line":30,"code":"  it(`is just waited for if dieOnTimeout is false`, () => {\n    location.hash = activeHash;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(myApp.numBootstraps()).toEqual(1);\n      expect(myApp.numMounts()).toEqual(1);\n      expect(singleSpa.getMountedApps()).toEqual([\"./unmount-times-out.app.js\"]);\n      expect(singleSpa.getAppStatus(\"./unmount-times-out.app.js\")).toEqual(\"MOUNTED\");\n      location.hash = \"#not-unmount-times-out\";\n      return singleSpa.triggerAppChange().then(() => {\n        expect(myApp.numUnmounts()).toEqual(1);\n        expect(singleSpa.getMountedApps()).toEqual([]);\n        expect(singleSpa.getAppStatus(\"./unmount-times-out.app.js\")).toEqual(\"NOT_MOUNTED\");\n      });\n    });\n  });","file":"apps/unmount-times-out/unmount-times-out.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't warn if everything resolves before the default warning setting","suites":["warning-timeouts app"],"updatePoint":{"line":30,"column":76},"line":30,"code":"  it(`doesn't warn if everything resolves before the default warning setting`, async () => {\n    location.hash = activeHash;\n    await controlledAppChange();\n    expect(singleSpa.getAppStatus(\"warning-timeouts\")).toEqual(\"MOUNTED\");\n    expect(errs.length).toBe(0);\n    expect(consoleWarnSpy).not.toHaveBeenCalled();\n    location.hash = \"#not-warning-timeouts\";\n    await controlledAppChange();\n    expect(singleSpa.getAppStatus(\"warning-timeouts\")).toEqual(\"NOT_MOUNTED\");\n    expect(errs.length).toBe(0);\n    expect(consoleWarnSpy).not.toHaveBeenCalled();\n  });","file":"apps/warning-timeouts/warning-timeouts.spec.js","skipped":false,"dir":"spec"},{"name":"does warn if things don't resolve until after the default warning setting","suites":["warning-timeouts app"],"updatePoint":{"line":42,"column":79},"line":42,"code":"  it(`does warn if things don't resolve until after the default warning setting`, async () => {\n    myApp.setDelay(3);\n    location.hash = activeHash;\n    await controlledAppChange();\n    expect(singleSpa.getAppStatus(\"warning-timeouts\")).toEqual(\"MOUNTED\");\n    expect(errs.length).toBe(0);\n    expectWarning(`single-spa minified message #31: Lifecycle function bootstrap for application warning-timeouts lifecycle did not resolve or reject for 4000 ms. See https://single-spa.js.org/error/?code=31&arg=bootstrap&arg=application&arg=warning-timeouts&arg=4000`);\n    expectWarning(`single-spa minified message #31: Lifecycle function mount for application warning-timeouts lifecycle did not resolve or reject for 3000 ms. See https://single-spa.js.org/error/?code=31&arg=mount&arg=application&arg=warning-timeouts&arg=3000`);\n    location.hash = \"#not-warning-timeouts\";\n    await controlledAppChange();\n    expect(singleSpa.getAppStatus(\"warning-timeouts\")).toEqual(\"NOT_MOUNTED\");\n    expect(errs.length).toBe(0);\n  });","file":"apps/warning-timeouts/warning-timeouts.spec.js","skipped":false,"dir":"spec"},{"name":"can mount and unmount a parcel (happy path)","suites":["applications mounting parcels :"],"updatePoint":{"line":36,"column":49},"line":36,"code":"  it(`can mount and unmount a parcel (happy path)`, () => {\n    let shouldAppBeMounted = false;\n    singleSpa.registerApplication(\"parcel-happy-1\", app, () => shouldAppBeMounted);\n    parcelConfig = createParcelConfig();\n    shouldAppBeMounted = true;\n    expect(app.bootstrapCalls).toBe(0);\n    expect(app.mountCalls).toBe(0);\n    expect(app.unmountCalls).toBe(0);\n    expect(parcelConfig.bootstrapCalls).toBe(0);\n    expect(parcelConfig.mountCalls).toBe(0);\n    expect(parcelConfig.unmountCalls).toBe(0);\n    let parcel,\n        unmountPromiseHasResolved = false;\n    return singleSpa.triggerAppChange().then(() => {\n      expect(app.bootstrapCalls).toBe(1);\n      expect(app.mountCalls).toBe(1);\n      expect(app.unmountCalls).toBe(0);\n      parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      parcel.unmountPromise.then(() => unmountPromiseHasResolved = true);\n      expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);\n      expect(unmountPromiseHasResolved).toBe(false);\n      return parcel.bootstrapPromise.then(() => {\n        expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n        expect(unmountPromiseHasResolved).toBe(false);\n        return parcel.mountPromise.then(() => {\n          expect(parcel.getStatus()).toBe(singleSpa.MOUNTED);\n          expect(unmountPromiseHasResolved).toBe(false);\n          expect(parcelConfig.bootstrapCalls).toBe(1);\n          expect(parcelConfig.mountCalls).toBe(1);\n          expect(parcelConfig.unmountCalls).toBe(0);\n          shouldAppBeMounted = false;\n          return singleSpa.triggerAppChange();\n        });\n      });\n    }).then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n      expect(unmountPromiseHasResolved).toBe(true);\n      expect(app.bootstrapCalls).toBe(1);\n      expect(app.mountCalls).toBe(1);\n      expect(app.unmountCalls).toBe(1);\n      expect(parcelConfig.bootstrapCalls).toBe(1);\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig.unmountCalls).toBe(1);\n    });\n  });","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"can mount and unmount a parcel some time after the app is mounted (happy path)","suites":["applications mounting parcels :"],"updatePoint":{"line":83,"column":84},"line":83,"code":"  it(`can mount and unmount a parcel some time after the app is mounted (happy path)`, () => {\n    let shouldAppBeMounted = false;\n    singleSpa.registerApplication(\"parcel-happy-2\", app, () => shouldAppBeMounted);\n    parcelConfig = createParcelConfig();\n    shouldAppBeMounted = true;\n    expect(app.bootstrapCalls).toBe(0);\n    expect(app.mountCalls).toBe(0);\n    expect(app.unmountCalls).toBe(0);\n    expect(parcelConfig.bootstrapCalls).toBe(0);\n    expect(parcelConfig.mountCalls).toBe(0);\n    expect(parcelConfig.unmountCalls).toBe(0);\n    return singleSpa.triggerAppChange().then(() => {\n      expect(app.bootstrapCalls).toBe(1);\n      expect(app.mountCalls).toBe(1);\n      expect(app.unmountCalls).toBe(0);\n    }).then(() => new Promise((resolve, reject) => {\n      setTimeout(resolve, 30);\n    })).then(() => {\n      const parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.mountPromise;\n    }).then(() => {\n      expect(parcelConfig.bootstrapCalls).toBe(1);\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig.unmountCalls).toBe(0);\n    }).then(() => {\n      shouldAppBeMounted = false;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      expect(app.bootstrapCalls).toBe(1);\n      expect(app.mountCalls).toBe(1);\n      expect(app.unmountCalls).toBe(1);\n      expect(parcelConfig.bootstrapCalls).toBe(1);\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig.unmountCalls).toBe(1);\n    });\n  });","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't unmount parcels twice if they are forcibly unmounted before the app is unmounted","suites":["applications mounting parcels :"],"updatePoint":{"line":121,"column":94},"line":121,"code":"  it(`doesn't unmount parcels twice if they are forcibly unmounted before the app is unmounted`, () => {\n    let shouldAppBeMounted = false;\n    singleSpa.registerApplication(\"parcel-force-unmount\", app, () => shouldAppBeMounted);\n    parcelConfig = createParcelConfig();\n    shouldAppBeMounted = true;\n    return singleSpa.triggerAppChange().then(() => {\n      const parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.mountPromise.then(() => parcel.unmount());\n    }).then(() => {\n      expect(parcelConfig.unmountCalls).toBe(1);\n      shouldAppBeMounted = false;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      expect(parcelConfig.unmountCalls).toBe(1);\n    });\n  });","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"lets you remount the parcel after forcibly unmounting it","suites":["applications mounting parcels :"],"updatePoint":{"line":139,"column":62},"line":139,"code":"  it(`lets you remount the parcel after forcibly unmounting it`, () => {\n    let shouldAppBeMounted = false,\n        parcel;\n    singleSpa.registerApplication(\"remount-parcel\", app, () => shouldAppBeMounted);\n    parcelConfig = createParcelConfig();\n    shouldAppBeMounted = true;\n    return singleSpa.triggerAppChange().then(() => {\n      parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.mountPromise;\n    }).then(() => parcel.unmount().then(value => {\n      // The mount promise isn't resolved with anything in particular\n      expect(value).toBe(null);\n    })).then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n      return parcel.mount().then(value => {\n        // The mount promise isn't resolved with anything in particular\n        expect(value).toBe(null);\n      });\n    }).then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.MOUNTED);\n      shouldAppBeMounted = false;\n      return singleSpa.triggerAppChange();\n    }).then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n      expect(app.unmountCalls).toBe(1);\n    });\n  });","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"correctly unmounts multiple parcels","suites":["applications mounting parcels :"],"updatePoint":{"line":168,"column":41},"line":168,"code":"  it(`correctly unmounts multiple parcels`, () => {\n    let shouldAppBeMounted = false,\n        parcel,\n        parcel2;\n    singleSpa.registerApplication(\"multiple-parcels\", app, () => shouldAppBeMounted);\n    parcelConfig = createParcelConfig();\n    const parcelConfig2 = createParcelConfig();\n    shouldAppBeMounted = true;\n    return singleSpa.triggerAppChange().then(() => {\n      parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      parcel2 = app.mountProps.mountParcel(parcelConfig2, {\n        domElement: document.createElement(\"div\")\n      });\n      expect(parcelConfig.mountCalls).toBe(0);\n      expect(parcelConfig2.mountCalls).toBe(0);\n      return Promise.all([parcel.mountPromise, parcel2.mountPromise]).then(() => [parcel, parcel2]);\n    }).then(([p, p2]) => {\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig2.mountCalls).toBe(1);\n      expect(p.getStatus()).toBe(singleSpa.MOUNTED);\n      expect(p2.getStatus()).toBe(singleSpa.MOUNTED);\n      return [p, p2];\n    }).then(([p, p2]) => {\n      shouldAppBeMounted = false;\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig2.mountCalls).toBe(1);\n      expect(parcelConfig.unmountCalls).toBe(0);\n      expect(parcelConfig2.unmountCalls).toBe(0);\n      expect(p.getStatus()).toBe(singleSpa.MOUNTED);\n      expect(p2.getStatus()).toBe(singleSpa.MOUNTED);\n      return singleSpa.triggerAppChange().then(() => {\n        return Promise.all([p.unmountPromise, p2.unmountPromise]);\n      }).then(() => [p, p2]);\n    }).then(([p, p2]) => {\n      expect(parcelConfig.mountCalls).toBe(1);\n      expect(parcelConfig2.mountCalls).toBe(1);\n      expect(parcelConfig.unmountCalls).toBe(1);\n      expect(parcelConfig2.unmountCalls).toBe(1);\n      expect(p.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n      expect(p2.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n    });\n  }); // https://github.com/single-spa/single-spa/issues/656","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"successfully unmounts a parcel that is unmounted before mount finishes","suites":["applications mounting parcels :"],"updatePoint":{"line":213,"column":76},"line":213,"code":"  it(`successfully unmounts a parcel that is unmounted before mount finishes`, async () => {\n    let shouldAppBeMounted = false,\n        parcel;\n    singleSpa.registerApplication(\"immediate-unmount\", app, () => shouldAppBeMounted);\n    parcelConfig = {\n      mount: () => new Promise(resolve => {\n        setTimeout(resolve, 50);\n      }),\n\n      async unmount() {}\n\n    };\n    shouldAppBeMounted = true;\n    return singleSpa.triggerAppChange().then(() => {\n      parcel = app.mountProps.mountParcel(parcelConfig, {\n        domElement: document.createElement(\"div\")\n      });\n      shouldAppBeMounted = false;\n      return singleSpa.triggerAppChange();\n    });\n  });","file":"parcels/app-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"can mount and unmount root parcels","suites":["root parcels"],"updatePoint":{"line":3,"column":40},"line":3,"code":"  it(`can mount and unmount root parcels`, () => {\n    const parcelConfig = createParcelConfig();\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);\n    return parcel.mountPromise.then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.MOUNTED);\n    }).then(() => new Promise((resolve, reject) => {\n      setTimeout(resolve, 20);\n    })).then(parcel.unmount).then(() => {\n      expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED);\n    });\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values","suites":["root parcels"],"updatePoint":{"line":17,"column":87},"line":17,"code":"  it(`doesn't resolve bootstrapPromise, mountPromise, or unmountPromise with any values`, () => {\n    const parcelConfig = createParcelConfig();\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    expect(parcel.getStatus()).toBe(singleSpa.NOT_BOOTSTRAPPED);\n    return parcel.bootstrapPromise.then(value => {\n      expect(value).toBe(null);\n      return parcel.mountPromise;\n    }).then(value => {\n      expect(value).toBe(null);\n      return Promise.all([parcel.unmountPromise, parcel.unmount()]);\n    }).then(values => {\n      const [unmountPromiseValue, unmountValue] = values;\n      expect(unmountPromiseValue).toBe(null);\n      expect(unmountValue).toBe(null);\n    });\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"lets you call mountParcel with a config loading function instead of an actual parcel config","suites":["root parcels"],"updatePoint":{"line":35,"column":97},"line":35,"code":"  it(`lets you call mountParcel with a config loading function instead of an actual parcel config`, () => {\n    const parcelConfig = createParcelConfig();\n    let resolveConfigLoading;\n\n    const configLoadingFunction = () => new Promise(resolve => {\n      resolveConfigLoading = () => resolve(parcelConfig);\n    });\n\n    const parcel = singleSpa.mountRootParcel(configLoadingFunction, {\n      domElement: document.createElement(\"div\")\n    });\n    expect(parcel.getStatus()).toBe(singleSpa.LOADING_SOURCE_CODE);\n    return Promise.resolve().then(() => expect(parcel.getStatus()).toBe(singleSpa.LOADING_SOURCE_CODE)).then(() => resolveConfigLoading()).then(() => parcel.loadPromise).then(() => expect(parcel.getStatus()).not.toBe(singleSpa.LOADING_SOURCE_CODE)).then(() => parcel.mountPromise).then(() => expect(parcel.getStatus()).toBe(singleSpa.MOUNTED)).then(() => parcel.unmount()).then(() => expect(parcel.getStatus()).toBe(singleSpa.NOT_MOUNTED)).then(() => parcel.unmountPromise);\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"allows you to update a parcel that has implemented the update lifecycle","suites":["root parcels"],"updatePoint":{"line":49,"column":77},"line":49,"code":"  it(`allows you to update a parcel that has implemented the update lifecycle`, () => {\n    const parcelConfig = createParcelConfig({\n      withUpdate: true\n    });\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    return parcel.mountPromise.then(() => expect(typeof parcel.update).toBe(\"function\")).then(() => expect(parcelConfig.updateCalls).toBe(0)).then(() => parcel.update({})).then(resolvedVal => expect(resolvedVal).toBe(null)).then(() => expect(parcelConfig.updateCalls).toBe(1));\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"does not allow you to call update on a parcel that does not implement the update lifecycle","suites":["root parcels"],"updatePoint":{"line":58,"column":96},"line":58,"code":"  it(`does not allow you to call update on a parcel that does not implement the update lifecycle`, () => {\n    const parcelConfig = createParcelConfig();\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    return parcel.mountPromise.then(() => expect(parcel.update).toBeUndefined());\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"can mount a parcel missing the bootstrap lifecycle","suites":["root parcels"],"updatePoint":{"line":65,"column":56},"line":65,"code":"  it(`can mount a parcel missing the bootstrap lifecycle`, async () => {\n    const parcelConfig = {\n      async mount() {},\n\n      async unmount() {}\n\n    };\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    await parcel.mountPromise;\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"can mount a parcel that doesn't have the Object prototype","suites":["root parcels"],"updatePoint":{"line":77,"column":63},"line":77,"code":"  it(`can mount a parcel that doesn't have the Object prototype`, async () => {\n    // Simulate an ES module, which doesn't have the object prototype\n    const parcelConfig = Object.create(null);\n\n    parcelConfig.mount = async function () {};\n\n    parcelConfig.unmount = async function () {};\n\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    await parcel.mountPromise;\n  }); // https://github.com/single-spa/single-spa/issues/656","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"can unmount a parcel that is still waiting for mount to finish","suites":["root parcels"],"updatePoint":{"line":91,"column":68},"line":91,"code":"  it(`can unmount a parcel that is still waiting for mount to finish`, async () => {\n    const parcelConfig = createParcelConfig();\n    const parcel = singleSpa.mountRootParcel(parcelConfig, {\n      domElement: document.createElement(\"div\")\n    });\n    await parcel.unmount();\n  });","file":"parcels/mount-root-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when bootstrapping fails","suites":["parcel errors","lifecycle errors","bootstrap errors"],"updatePoint":{"line":8,"column":56},"line":8,"code":"      it(`should throw an error when bootstrapping fails`, async () => {\n        const app = createApp();\n        let shouldAppBeMounted = true;\n        singleSpa.registerApplication(\"parcel-bootstrap-errors\", app, () => shouldAppBeMounted);\n        await singleSpa.triggerAppChange();\n        expect(app.mountCalls).toBe(1);\n        const parcelConfig1 = createParcelConfig(\"bootstrap\");\n        parcelConfig1.name = \"bootstrap-error\";\n        const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n          domElement: document.createElement(\"div\")\n        });\n        await parcel1.bootstrapPromise.catch(err => {\n          expect(err.appOrParcelName).toBe(\"bootstrap-error\");\n          expect(err.message).toMatch(`BOOTSTRAPPING`);\n          expect(err.message.indexOf(`bootstrap-error`)).toBeGreaterThan(-1);\n          expect(parcel1.getStatus()).toBe(\"SKIP_BECAUSE_BROKEN\");\n        });\n      });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when mounting fails","suites":["parcel errors","lifecycle errors","mount errors"],"updatePoint":{"line":28,"column":51},"line":28,"code":"      it(`should throw an error when mounting fails`, () => {\n        const app = createApp();\n        let shouldAppBeMounted = true;\n        singleSpa.registerApplication(\"parcel-mount-errors\", app, () => shouldAppBeMounted);\n        return singleSpa.triggerAppChange().then(() => {\n          expect(app.mountCalls).toBe(1);\n          const parcelConfig1 = createParcelConfig(\"mount\");\n          parcelConfig1.name = \"mount-error\";\n          const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n            domElement: document.createElement(\"div\")\n          });\n          return parcel1.mountPromise.catch(err => {\n            expect(err.appOrParcelName).toBe(\"mount-error\");\n            expect(err.message).toMatch(\"NOT_MOUNTED\");\n            expect(parcel1.getStatus()).toBe(singleSpa.SKIP_BECAUSE_BROKEN);\n          });\n        });\n      });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error if you call update on a parcel does not implement the 'update' lifecycle","suites":["parcel errors","lifecycle errors","update errors"],"updatePoint":{"line":48,"column":104},"line":48,"code":"      it(`should throw an error if you call update on a parcel does not implement the 'update' lifecycle`, () => {\n        const parcelConfig = createParcelConfig();\n        const parcel = singleSpa.mountRootParcel(parcelConfig, {\n          domElement: document.createElement(\"div\")\n        });\n        return parcel.mountPromise.then(() => {\n          expect(() => parcel.update({})).toThrow();\n        });\n      });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error that you can catch when a parcel fails to unmount outside an app lifecycle","suites":["parcel errors","lifecycle errors","ummount errors","parcel unmount itself errors"],"updatePoint":{"line":60,"column":108},"line":60,"code":"        it(`should throw an error that you can catch when a parcel fails to unmount outside an app lifecycle`, () => {\n          const app = createApp();\n          let shouldAppBeMounted = true;\n          singleSpa.registerApplication(\"parcel-unmount-parcel-errors\", app, () => shouldAppBeMounted);\n          return singleSpa.triggerAppChange().then(() => {\n            expect(app.mountCalls).toBe(1);\n            const parcelConfig1 = createParcelConfig(\"unmount\");\n            parcelConfig1.name = \"unmount-error\";\n            const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n              domElement: document.createElement(\"div\")\n            });\n            return parcel1.mountPromise.then(() => {\n              expect(parcel1.getStatus()).toBe(\"MOUNTED\");\n              expect(parcelConfig1.bootstrapCalls).toBe(1);\n              expect(parcelConfig1.mountCalls).toBe(1);\n              expect(parcelConfig1.unmountCalls).toBe(0);\n              parcel1.unmount();\n              expect(parcelConfig1.unmountCalls).toBe(0);\n              return parcel1.unmountPromise.catch(err => {\n                expect(err.appOrParcelName).toBe(\"unmount-error\");\n                expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);\n                expect(err.message.indexOf(`unmount-error`)).toBeGreaterThan(-1);\n              }).then(() => {\n                expect(parcel1.getStatus()).toBe(\"SKIP_BECAUSE_BROKEN\");\n              });\n            });\n          });\n        });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"should throw an error when unmounting a parcel fails during app unmount","suites":["parcel errors","lifecycle errors","ummount errors","parcel unmounted by app unmount errors"],"updatePoint":{"line":103,"column":83},"line":103,"code":"        it(`should throw an error when unmounting a parcel fails during app unmount`, () => {\n          const app = createApp();\n          let shouldAppBeMounted = true;\n          singleSpa.registerApplication(\"app-parcel-unmount-errors\", app, () => shouldAppBeMounted);\n          return singleSpa.triggerAppChange().then(() => {\n            expect(app.mountCalls).toBe(1);\n            const parcelConfig1 = createParcelConfig(\"unmount\");\n            parcelConfig1.name = \"unmount-error\";\n            const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n              domElement: document.createElement(\"div\")\n            });\n            return parcel1.mountPromise.then(results => {\n              expect(parcelConfig1.bootstrapCalls).toBe(1);\n              expect(parcelConfig1.mountCalls).toBe(1);\n              expect(parcelConfig1.unmountCalls).toBe(0);\n            }).then(() => {\n              shouldAppBeMounted = false;\n              return singleSpa.triggerAppChange();\n            }).then(() => {\n              return parcel1.unmountPromise.catch(err => {\n                expect(err.appOrParcelName).toBe(\"unmount-error\");\n                expect(err.message.indexOf(`UNMOUNTING`)).toBeGreaterThan(-1);\n                expect(err.message.indexOf(`unmount-error`)).toBeGreaterThan(-1);\n              });\n            }).then(() => {\n              expect(errs.length).toBe(1);\n              expect(errs[0].appOrParcelName).toBe(\"app-parcel-unmount-errors\");\n              expect(errs[0].message).toMatch(/application 'app-parcel-unmount-errors' died in status NOT_MOUNTED: parcel 'unmount-error' died in status UNMOUNTING: unmount error/);\n            });\n          });\n        });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"throws an error immediately if you don't provide a config object","suites":["parcel errors","invalid config"],"updatePoint":{"line":138,"column":72},"line":138,"code":"    it(`throws an error immediately if you don't provide a config object`, () => {\n      expect(() => {\n        singleSpa.mountRootParcel(null, {\n          domElement: document.createElement(\"div\")\n        });\n      }).toThrow();\n    });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"throws if your loading function doesn't return a valid config promise","suites":["parcel errors","invalid config"],"updatePoint":{"line":145,"column":77},"line":145,"code":"    it(`throws if your loading function doesn't return a valid config promise`, () => {\n      expect(() => {\n        // loading function should return promise\n        singleSpa.mountRootParcel(() => createParcelConfig(), {\n          domElement: document.createElement(\"div\")\n        });\n      }).toThrow();\n    });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"rejects the load promise if loading function returns a promise that resolves with undefined","suites":["parcel errors","invalid config"],"updatePoint":{"line":153,"column":99},"line":153,"code":"    it(`rejects the load promise if loading function returns a promise that resolves with undefined`, () => {\n      const parcel = singleSpa.mountRootParcel(() => Promise.resolve(), {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.loadPromise.then(() => {\n        throw new Error(\"load promise should not have succeeded\");\n      }, err => {\n        expect(err.message.indexOf(\"did not resolve with a parcel config\")).toBeGreaterThan(-1);\n      });\n    });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"rejects the load promise if the config doesn't have a valid mount function","suites":["parcel errors","invalid config"],"updatePoint":{"line":163,"column":82},"line":163,"code":"    it(`rejects the load promise if the config doesn't have a valid mount function`, () => {\n      const parcel = singleSpa.mountRootParcel({\n        bootstrap() {},\n\n        unmount() {}\n\n      }, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.loadPromise.then(() => {\n        throw new Error(\"load promise should not have succeeded\");\n      }, err => {\n        expect(err.message.indexOf(\"must have a valid mount function\")).toBeGreaterThan(-1);\n      });\n    });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"rejects the load promise if the config doesn't have a valid unmount function","suites":["parcel errors","invalid config"],"updatePoint":{"line":178,"column":84},"line":178,"code":"    it(`rejects the load promise if the config doesn't have a valid unmount function`, () => {\n      const parcel = singleSpa.mountRootParcel({\n        bootstrap() {},\n\n        mount() {}\n\n      }, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel.loadPromise.then(() => {\n        throw new Error(\"load promise should not have succeeded\");\n      }, err => {\n        expect(err.message.indexOf(\"must have a valid unmount function\")).toBeGreaterThan(-1);\n      });\n    });","file":"parcels/parcel-error-handlers.spec.js","skipped":false,"dir":"spec"},{"name":"can mount a parcel as a child of a parcel and unmount both together","suites":["parcels mounting parcels"],"updatePoint":{"line":6,"column":73},"line":6,"code":"  it(\"can mount a parcel as a child of a parcel and unmount both together\", () => {\n    const app = createApp();\n    let shouldAppBeMounted = true;\n    singleSpa.registerApplication(\"parcel-mounts-parcels\", app, () => shouldAppBeMounted);\n    return singleSpa.triggerAppChange().then(() => {\n      expect(app.mountCalls).toBe(1);\n      const parcelConfig1 = createParcelConfig();\n      const parcelConfig2 = createParcelConfig();\n      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel1.mountPromise.then(() => {\n        expect(parcelConfig1.bootstrapCalls).toBe(1);\n        expect(parcelConfig1.mountCalls).toBe(1);\n        expect(parcelConfig1.unmountCalls).toBe(0);\n        const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {\n          domElement: document.createElement(\"div\")\n        });\n        return parcel2.mountPromise.then(() => {\n          expect(parcelConfig2.bootstrapCalls).toBe(1);\n          expect(parcelConfig2.mountCalls).toBe(1);\n          expect(parcelConfig2.unmountCalls).toBe(0);\n        });\n      }).then(() => parcel1.unmount()).then(() => {\n        {\n          expect(parcelConfig1.unmountCalls).toBe(1);\n          expect(parcelConfig2.unmountCalls).toBe(1);\n        }\n      });\n    });\n  });","file":"parcels/parcel-mounts-parcel.spec.js","skipped":false,"dir":"spec"},{"name":"unmounts parcels recursively deep when an app unmounts","suites":["parcels mounting parcels"],"updatePoint":{"line":37,"column":60},"line":37,"code":"  it(\"unmounts parcels recursively deep when an app unmounts\", () => {\n    const app = createApp();\n    let shouldAppBeMounted = true;\n    singleSpa.registerApplication(\"parcel-unmounts-recursive\", app, () => shouldAppBeMounted);\n    return singleSpa.triggerAppChange().then(() => {\n      expect(app.mountCalls).toBe(1);\n      const parcelConfig1 = createParcelConfig();\n      const parcelConfig2 = createParcelConfig();\n      const parcelConfig3 = createParcelConfig();\n      const parcel1 = app.mountProps.mountParcel(parcelConfig1, {\n        domElement: document.createElement(\"div\")\n      });\n      return parcel1.mountPromise.then(() => {\n        const parcel2 = parcelConfig1.mountProps.mountParcel(parcelConfig2, {\n          domElement: document.createElement(\"div\")\n        });\n        return parcel2.mountPromise.then(() => {\n          const parcel3 = parcelConfig2.mountProps.mountParcel(parcelConfig3, {\n            domElement: document.createElement(\"div\")\n          });\n          return parcel3.mountPromise;\n        });\n      }).then(() => {\n        shouldAppBeMounted = false;\n        return singleSpa.triggerAppChange();\n      }).then(() => {\n        expect(app.unmountCalls).toBe(1);\n        expect(parcelConfig1.unmountCalls).toBe(1);\n        expect(parcelConfig2.unmountCalls).toBe(1);\n        expect(parcelConfig3.unmountCalls).toBe(1);\n      });\n    });\n  });","file":"parcels/parcel-mounts-parcel.spec.js","skipped":false,"dir":"spec"}]}