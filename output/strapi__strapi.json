{
    "repo": "strapi/strapi",
    "url": "https://github.com/strapi/strapi",
    "branch": "master",
    "configs": [
        {
            "package": "strapi",
            "lang": "js",
            "dir": "test",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/plugin-content-type-builder",
            "lang": "js",
            "dir": "packages/core/content-type-builder/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/strapi",
            "lang": "js",
            "dir": "packages/core/strapi/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/plugin-upload",
            "lang": "js",
            "dir": "packages/core/upload/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/plugin-graphql",
            "lang": "js",
            "dir": "packages/plugins/graphql/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/plugin-i18n",
            "lang": "js",
            "dir": "packages/plugins/i18n/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@strapi/plugin-users-permissions",
            "lang": "js",
            "dir": "packages/plugins/users-permissions/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        }
    ],
    "tests": [
        {
            "name": "Successful creation of a collection type",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 46,
                "column": 50,
                "index": 1359
            },
            "line": 46,
            "code": "    test('Successful creation of a collection type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            displayName: 'Test Collection Type',\n            singularName: 'test-collection-type',\n            pluralName: 'test-collection-types',\n            pluginOptions: {\n              i18n: {\n                localized: true\n              }\n            },\n            attributes: {\n              title: {\n                type: 'string',\n                pluginOptions: {\n                  i18n: {\n                    localized: true\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: testCollectionTypeUID\n        }\n      });\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Get collection type returns full schema and information",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 80,
                "column": 65,
                "index": 2279
            },
            "line": 80,
            "code": "    test('Get collection type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${testCollectionTypeUID}`\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Successfull creation of a collection type with draftAndPublish enabled",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 88,
                "column": 80,
                "index": 2604
            },
            "line": 88,
            "code": "    test('Successfull creation of a collection type with draftAndPublish enabled', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            displayName: 'CT with DP',\n            singularName: 'ct-with-dp',\n            pluralName: 'ct-with-dps',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: ctWithDpUID\n        }\n      });\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Get collection type returns full schema and informations with draftAndPublish",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 113,
                "column": 87,
                "index": 3293
            },
            "line": 113,
            "code": "    test('Get collection type returns full schema and informations with draftAndPublish', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${ctWithDpUID}`\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Cannot use same string for singularName and pluralName",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 121,
                "column": 64,
                "index": 3592
            },
            "line": 121,
            "code": "    test('Cannot use same string for singularName and pluralName', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            displayName: 'same string',\n            singularName: 'same-string',\n            pluralName: 'same-string',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          details: {\n            errors: [{\n              message: 'contentType: singularName and pluralName should be different',\n              name: 'ValidationError',\n              path: ['contentType']\n            }]\n          },\n          message: 'contentType: singularName and pluralName should be different',\n          name: 'ValidationError'\n        }\n      });\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "displayName, singularName and pluralName are required",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 154,
                "column": 63,
                "index": 4584
            },
            "line": 154,
            "code": "    test('displayName, singularName and pluralName are required', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          details: {\n            errors: [{\n              message: 'contentType.displayName is a required field',\n              name: 'ValidationError',\n              path: ['contentType', 'displayName']\n            }, {\n              message: 'Content Type name `undefined` is already being used.',\n              name: 'ValidationError',\n              path: ['contentType', 'singularName']\n            }, {\n              message: 'contentType.singularName is a required field',\n              name: 'ValidationError',\n              path: ['contentType', 'singularName']\n            }, {\n              message: 'Content Type name `undefined` is already being used.',\n              name: 'ValidationError',\n              path: ['contentType', 'pluralName']\n            }, {\n              message: 'contentType.pluralName is a required field',\n              name: 'ValidationError',\n              path: ['contentType', 'pluralName']\n            }, {\n              message: 'contentType: singularName and pluralName should be different',\n              name: 'ValidationError',\n              path: ['contentType']\n            }]\n          },\n          message: '6 errors occurred',\n          name: 'ValidationError'\n        }\n      });\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Can edit displayName but singularName and pluralName are ignored",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "updatePoint": {
                "line": 204,
                "column": 74,
                "index": 6327
            },
            "line": 204,
            "code": "    test('Can edit displayName but singularName and pluralName are ignored', async () => {\n      const uid = 'api::ct-with-dp.ct-with-dp';\n      let res = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${uid}`,\n        body: {\n          contentType: {\n            displayName: 'new displayName',\n            singularName: 'ct-with-dp-new',\n            pluralName: 'ct-with-dps-new',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      await restart();\n      res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${uid}`\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          uid,\n          schema: {\n            displayName: 'new displayName',\n            singularName: 'ct-with-dp',\n            // no change\n            pluralName: 'ct-with-dps',\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Are \"%s\" and \"%s\" valid: %s",
            "suites": [
                "Content Type Builder - Content types",
                "Collection Types"
            ],
            "line": 248,
            "code": "    test.each([['kebab-case', 'kebab-cases', true], ['Kebab-case', 'Kebab-cases', false], ['kebab case', 'kebab cases', false], ['kebabCase', 'kebabCases', false], ['kebab@case', 'kebab@cases', false], ['my2space', 'my2spaces', true], ['2myspace', '2myspaces', false], ['my-3-space', 'my-3-spaces', true]])('Are \"%s\" and \"%s\" valid: %s', async (singularName, pluralName, isExpectedValid) => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            displayName: 'same string',\n            singularName,\n            pluralName,\n            draftAndPublish: true,\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      if (isExpectedValid) {\n        expect(res.statusCode).toBe(201);\n      } else {\n        expect(res.statusCode).toBe(400);\n        expect(res.body).toEqual({\n          error: {\n            name: 'ValidationError',\n            message: '2 errors occurred',\n            details: {\n              errors: [{\n                message: 'contentType.singularName is not in kebab case (an-example-of-kebab-case)',\n                name: 'ValidationError',\n                path: ['contentType', 'singularName']\n              }, {\n                message: 'contentType.pluralName is not in kebab case (an-example-of-kebab-case)',\n                name: 'ValidationError',\n                path: ['contentType', 'pluralName']\n              }]\n            }\n          }\n        });\n      }\n    });",
            "file": "collection-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Validates input and return 400 in case of invalid input",
            "suites": [
                "Content Type Builder - Components",
                "POST /components"
            ],
            "updatePoint": {
                "line": 29,
                "column": 65,
                "index": 690
            },
            "line": 29,
            "code": "    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {}\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          details: {\n            errors: [{\n              message: 'attributes.required',\n              name: 'ValidationError',\n              path: ['component', 'attributes']\n            }, {\n              message: 'displayName.required',\n              name: 'ValidationError',\n              path: ['component', 'displayName']\n            }, {\n              message: 'category.required',\n              name: 'ValidationError',\n              path: ['component', 'category']\n            }]\n          },\n          message: '3 errors occurred',\n          name: 'ValidationError'\n        }\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Creates a component properly",
            "suites": [
                "Content Type Builder - Components",
                "POST /components"
            ],
            "updatePoint": {
                "line": 60,
                "column": 38,
                "index": 1602
            },
            "line": 60,
            "code": "    test('Creates a component properly', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            displayName: 'Some Component',\n            pluginOptions: {\n              pluginName: {\n                option: true\n              }\n            },\n            attributes: {\n              title: {\n                type: 'string',\n                pluginOptions: {\n                  pluginName: {\n                    option: true\n                  }\n                }\n              },\n              pic: {\n                type: 'media'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component'\n        }\n      });\n      await restart();\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Errors on already existing components",
            "suites": [
                "Content Type Builder - Components",
                "POST /components"
            ],
            "updatePoint": {
                "line": 97,
                "column": 47,
                "index": 2527
            },
            "line": 97,
            "code": "    test('Errors on already existing components', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/components',\n        body: {\n          component: {\n            category: 'default',\n            displayName: 'someComponent',\n            attributes: {}\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: 'component.alreadyExists'\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Returns valid enveloppe",
            "suites": [
                "Content Type Builder - Components",
                "Get /components"
            ],
            "updatePoint": {
                "line": 116,
                "column": 33,
                "index": 3028
            },
            "line": 116,
            "code": "    test('Returns valid enveloppe', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components'\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: expect.any(Array)\n      });\n      res.body.data.forEach(el => {\n        expect(el).toMatchObject({\n          uid: expect.any(String),\n          schema: expect.objectContaining({\n            displayName: expect.any(String),\n            description: expect.any(String),\n            collectionName: expect.any(String),\n            attributes: expect.objectContaining({})\n          })\n        });\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Returns 404 on not found",
            "suites": [
                "Content Type Builder - Components",
                "GET /components/:uid"
            ],
            "updatePoint": {
                "line": 139,
                "column": 34,
                "index": 3742
            },
            "line": 139,
            "code": "    test('Returns 404 on not found', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/nonexistent-component'\n      });\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound'\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Returns correct format",
            "suites": [
                "Content Type Builder - Components",
                "GET /components/:uid"
            ],
            "updatePoint": {
                "line": 149,
                "column": 32,
                "index": 4050
            },
            "line": 149,
            "code": "    test('Returns correct format', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component'\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          category: 'default',\n          schema: {\n            displayName: 'Some Component',\n            description: '',\n            collectionName: 'components_default_some_components',\n            pluginOptions: {\n              pluginName: {\n                option: true\n              }\n            },\n            attributes: {\n              title: {\n                type: 'string',\n                pluginOptions: {\n                  pluginName: {\n                    option: true\n                  }\n                }\n              },\n              pic: {\n                type: 'media',\n                multiple: false,\n                required: false\n              }\n            }\n          }\n        }\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Throws 404 on updating non existent component",
            "suites": [
                "Content Type Builder - Components",
                "PUT /components/:uid"
            ],
            "updatePoint": {
                "line": 189,
                "column": 55,
                "index": 5167
            },
            "line": 189,
            "code": "    test('Throws 404 on updating non existent component', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/nonexistent-components'\n      });\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound'\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Validates input and return 400 in case of invalid input",
            "suites": [
                "Content Type Builder - Components",
                "PUT /components/:uid"
            ],
            "updatePoint": {
                "line": 199,
                "column": 65,
                "index": 5509
            },
            "line": 199,
            "code": "    test('Validates input and return 400 in case of invalid input', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            attributes: {}\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toEqual({\n        error: {\n          details: {\n            errors: [{\n              message: 'displayName.required',\n              name: 'ValidationError',\n              path: ['component', 'displayName']\n            }, {\n              message: 'category.required',\n              name: 'ValidationError',\n              path: ['component', 'category']\n            }]\n          },\n          message: '2 errors occurred',\n          name: 'ValidationError'\n        }\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Updates a component properly",
            "suites": [
                "Content Type Builder - Components",
                "PUT /components/:uid"
            ],
            "updatePoint": {
                "line": 228,
                "column": 38,
                "index": 6331
            },
            "line": 228,
            "code": "    test('Updates a component properly', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: '/content-type-builder/components/default.some-component',\n        body: {\n          component: {\n            category: 'default',\n            displayName: 'New Component',\n            attributes: {\n              name: {\n                type: 'string'\n              }\n            },\n            pluginOptions: {\n              pluginName: {\n                option: false\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component'\n        }\n      });\n      await restart();\n      const getRes = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component'\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject({\n        data: {\n          uid: 'default.some-component',\n          schema: {\n            displayName: 'New Component',\n            pluginOptions: {\n              pluginName: {\n                option: false\n              }\n            }\n          }\n        }\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Throws 404 on non existent component",
            "suites": [
                "Content Type Builder - Components",
                "DELETE /components/:uid"
            ],
            "updatePoint": {
                "line": 277,
                "column": 46,
                "index": 7612
            },
            "line": 277,
            "code": "    test('Throws 404 on non existent component', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/nonexistent-components'\n      });\n      expect(res.statusCode).toBe(404);\n      expect(res.body).toEqual({\n        error: 'component.notFound'\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Deletes a component correctly",
            "suites": [
                "Content Type Builder - Components",
                "DELETE /components/:uid"
            ],
            "updatePoint": {
                "line": 287,
                "column": 39,
                "index": 7931
            },
            "line": 287,
            "code": "    test('Deletes a component correctly', async () => {\n      const res = await rq({\n        method: 'DELETE',\n        url: '/content-type-builder/components/default.some-component'\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toEqual({\n        data: {\n          uid: 'default.some-component'\n        }\n      });\n      await restart();\n      const tryGet = await rq({\n        method: 'GET',\n        url: '/content-type-builder/components/default.some-component'\n      });\n      expect(tryGet.statusCode).toBe(404);\n      expect(tryGet.body).toEqual({\n        error: 'component.notFound'\n      });\n    });",
            "file": "components.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Successful creation of a single type",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 45,
                "column": 46,
                "index": 1197
            },
            "line": 45,
            "code": "    test('Successful creation of a single type', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            displayName: 'Test Single Type',\n            singularName: 'test-single-type',\n            pluralName: 'test-single-types',\n            pluginOptions: {\n              i18n: {\n                localized: true\n              }\n            },\n            attributes: {\n              title: {\n                type: 'string',\n                pluginOptions: {\n                  i18n: {\n                    localized: true\n                  }\n                }\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID\n        }\n      });\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Get single type returns full schema and information",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 80,
                "column": 61,
                "index": 2125
            },
            "line": 80,
            "code": "    test('Get single type returns full schema and information', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body).toMatchSnapshot();\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Fails on invalid relations",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 88,
                "column": 36,
                "index": 2398
            },
            "line": 88,
            "code": "    test('Fails on invalid relations', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'singleType',\n            singularName: 'test-st',\n            pluralName: 'test-sts',\n            displayName: 'Tests-st',\n            attributes: {\n              relation: {\n                type: 'relation',\n                relation: 'oneTo',\n                target: 'plugin::users-permissions.user',\n                targetAttribute: 'test'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        error: {\n          details: {\n            errors: [{\n              message: 'must be one of the following values: oneToOne, oneToMany, morphOne, morphMany, morphToOne, morphToMany',\n              name: 'ValidationError',\n              path: ['contentType', 'attributes', 'relation', 'relation']\n            }]\n          },\n          message: 'must be one of the following values: oneToOne, oneToMany, morphOne, morphMany, morphToOne, morphToMany',\n          name: 'ValidationError'\n        }\n      });\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Cannot switch collectionType to singleType when multiple entries in DB",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 124,
                "column": 80,
                "index": 3661
            },
            "line": 124,
            "code": "    test('Cannot switch collectionType to singleType when multiple entries in DB', async () => {\n      const createRes = await rq({\n        method: 'POST',\n        url: '/content-type-builder/content-types',\n        body: {\n          contentType: {\n            kind: 'collectionType',\n            displayName: 'test-collection',\n            singularName: 'test-collection',\n            pluralName: 'test-collections',\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(createRes.statusCode).toBe(201);\n      await restart();\n      const {\n        uid\n      } = createRes.body.data;\n\n      // create data\n      for (let i = 0; i < 2; i += 1) {\n        await strapi.query(uid).create({\n          data: {\n            title: 'Test'\n          }\n        });\n      }\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${uid}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            displayName: 'test-collection',\n            singularName: 'test-collection',\n            pluralName: 'test-collections',\n            attributes: {\n              title: {\n                type: 'string'\n              }\n            }\n          }\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      expect(updateRes.body.error).toMatch('multiple entries in DB');\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Should add a relation field",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 176,
                "column": 37,
                "index": 5071
            },
            "line": 176,
            "code": "    test('Should add a relation field', async () => {\n      const res = await rq({\n        method: 'PUT',\n        url: `/content-type-builder/content-types/${singleTypeUID}`,\n        body: {\n          contentType: {\n            kind: 'singleType',\n            displayName: 'test-collection',\n            singularName: 'test-collection',\n            pluralName: 'test-collections',\n            attributes: {\n              relation: {\n                private: true,\n                type: 'relation',\n                relation: 'oneToOne',\n                target: 'plugin::users-permissions.user'\n              }\n            }\n          }\n        }\n      });\n      expect(res.statusCode).toBe(201);\n      expect(res.body).toEqual({\n        data: {\n          uid: singleTypeUID\n        }\n      });\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Should contain a private relation field",
            "suites": [
                "Content Type Builder - Content types",
                "Single Types"
            ],
            "updatePoint": {
                "line": 204,
                "column": 49,
                "index": 5884
            },
            "line": 204,
            "code": "    test('Should contain a private relation field', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: `/content-type-builder/content-types/${singleTypeUID}`\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.schema.attributes.relation).toBeDefined();\n      expect(res.body.data.schema.attributes.relation.private).toBeTruthy();\n    });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/content-type-builder/tests"
        },
        {
            "name": "Create product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 65,
                "column": 33,
                "index": 1367
            },
            "line": 65,
            "code": "  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [{\n        name: 'compo name',\n        description: 'short'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productsWithCompo.push(body.data);\n  });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 95,
                "column": 31,
                "index": 2058
            },
            "line": 95,
            "code": "  test('Read product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(1);\n    expect(body.data[0]).toMatchObject(data.productsWithCompo[0]);\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeUndefined();\n    });\n  });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 113,
                "column": 33,
                "index": 2519
            },
            "line": 113,
            "code": "  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [{\n        name: 'compo name updated',\n        description: 'update'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.productsWithCompo[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    expect(body.data.publishedAt).toBeUndefined();\n    data.productsWithCompo[0] = body.data;\n  });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 144,
                "column": 33,
                "index": 3329
            },
            "line": 144,
            "code": "  test('Delete product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.productsWithCompo[0]);\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productsWithCompo.shift();\n  });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - compo required",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 161,
                "column": 59,
                "index": 3847
            },
            "line": 161,
            "code": "    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo must be defined.',\n          details: {\n            errors: [{\n              path: ['compo'],\n              message: 'compo must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - minLength",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 190,
                "column": 54,
                "index": 4607
            },
            "line": 190,
            "code": "    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          name: 'compo name',\n          description: ''\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].description must be at least 3 characters',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'description'],\n              message: 'compo[0].description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - maxLength",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 223,
                "column": 54,
                "index": 5529
            },
            "line": 223,
            "code": "    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].description must be at most 10 characters',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'description'],\n              message: 'compo[0].description must be at most 10 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - required",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 256,
                "column": 53,
                "index": 6501
            },
            "line": 256,
            "code": "    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          description: 'short'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].name must be defined.',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'name'],\n              message: 'compo[0].name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 68,
                "column": 33,
                "index": 1429
            },
            "line": 68,
            "code": "  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short'\n      }\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-compos',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productsWithCompo.push(body.data);\n  });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 98,
                "column": 31,
                "index": 2118
            },
            "line": 98,
            "code": "  test('Read product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-compos',\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(1);\n    expect(body.data[0]).toMatchObject(data.productsWithCompo[0]);\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeUndefined();\n    });\n  });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 116,
                "column": 33,
                "index": 2579
            },
            "line": 116,
            "code": "  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update'\n      }\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.productsWithCompo[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productsWithCompo[0] = body.data;\n  });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product with compo",
            "suites": [
                "Core API - Basic + compo"
            ],
            "updatePoint": {
                "line": 146,
                "column": 33,
                "index": 3336
            },
            "line": 146,
            "code": "  test('Delete product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-compos/${data.productsWithCompo[0].id}`,\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.productsWithCompo[0]);\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productsWithCompo.shift();\n  });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - compo required",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 163,
                "column": 59,
                "index": 3854
            },
            "line": 163,
            "code": "    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo must be defined.',\n          details: {\n            errors: [{\n              path: ['compo'],\n              message: 'compo must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - minLength",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 192,
                "column": 54,
                "index": 4614
            },
            "line": 192,
            "code": "    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: ''\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.description must be at least 3 characters',\n          details: {\n            errors: [{\n              path: ['compo', 'description'],\n              message: 'compo.description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - maxLength",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 225,
                "column": 54,
                "index": 5523
            },
            "line": 225,
            "code": "    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.'\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.description must be at most 10 characters',\n          details: {\n            errors: [{\n              path: ['compo', 'description'],\n              message: 'compo.description must be at most 10 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - required",
            "suites": [
                "Core API - Basic + compo",
                "validation"
            ],
            "updatePoint": {
                "line": 258,
                "column": 53,
                "index": 6482
            },
            "line": 258,
            "code": "    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short'\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compos',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.name must be defined.',\n          details: {\n            errors: [{\n              path: ['compo', 'name'],\n              message: 'compo.name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 66,
                "column": 33,
                "index": 1446
            },
            "line": 66,
            "code": "  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: [{\n        name: 'compo name',\n        description: 'short'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP.push(body.data);\n  });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 96,
                "column": 31,
                "index": 2147
            },
            "line": 96,
            "code": "  test('Read product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(1);\n    expect(body.data[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeISODate();\n    });\n  });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 114,
                "column": 33,
                "index": 2618
            },
            "line": 114,
            "code": "  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: [{\n        name: 'compo name updated',\n        description: 'update'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.productsWithCompoAndDP[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP[0] = body.data;\n  });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 144,
                "column": 33,
                "index": 3397
            },
            "line": 144,
            "code": "  test('Delete product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - compo required",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 161,
                "column": 59,
                "index": 3935
            },
            "line": 161,
            "code": "    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo must be defined.',\n          details: {\n            errors: [{\n              path: ['compo'],\n              message: 'compo must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - minLength",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 190,
                "column": 54,
                "index": 4702
            },
            "line": 190,
            "code": "    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          name: 'compo name',\n          description: ''\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].description must be at least 3 characters',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'description'],\n              message: 'compo[0].description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - maxLength",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 223,
                "column": 54,
                "index": 5631
            },
            "line": 223,
            "code": "    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].description must be at most 10 characters',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'description'],\n              message: 'compo[0].description must be at most 10 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - required",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 256,
                "column": 53,
                "index": 6610
            },
            "line": 256,
            "code": "    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: [{\n          description: 'short'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo[0].name must be defined.',\n          details: {\n            errors: [{\n              path: ['compo', '0', 'name'],\n              message: 'compo[0].name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo-repeatable.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 65,
                "column": 33,
                "index": 1422
            },
            "line": 65,
            "code": "  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      compo: {\n        name: 'compo name',\n        description: 'short'\n      }\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-compo-and-dps',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP.push(body.data);\n  });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 95,
                "column": 31,
                "index": 2121
            },
            "line": 95,
            "code": "  test('Read product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-compo-and-dps',\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(1);\n    expect(body.data[0]).toMatchObject(data.productsWithCompoAndDP[0]);\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeISODate();\n    });\n  });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 113,
                "column": 33,
                "index": 2592
            },
            "line": 113,
            "code": "  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      compo: {\n        name: 'compo name updated',\n        description: 'update'\n      }\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.productsWithCompoAndDP[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP[0] = body.data;\n  });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product with compo",
            "suites": [
                "Core API - Basic + compo + draftAndPublish"
            ],
            "updatePoint": {
                "line": 143,
                "column": 33,
                "index": 3369
            },
            "line": 143,
            "code": "  test('Delete product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-compo-and-dps/${data.productsWithCompoAndDP[0].id}`,\n      qs: {\n        populate: ['compo']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.productsWithCompoAndDP[0]);\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.productsWithCompoAndDP.shift();\n  });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "components have been removed from the database",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "database state"
            ],
            "updatePoint": {
                "line": 160,
                "column": 56,
                "index": 3908
            },
            "line": 160,
            "code": "    test('components have been removed from the database', async () => {\n      const dbComponents = await strapi.db.query('default.compo').findMany({\n        name: 'compo name updated'\n      });\n      expect(dbComponents).toHaveLength(0);\n    });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - compo required",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 168,
                "column": 59,
                "index": 4197
            },
            "line": 168,
            "code": "    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo must be defined.',\n          details: {\n            errors: [{\n              path: ['compo'],\n              message: 'compo must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - minLength",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 197,
                "column": 54,
                "index": 4964
            },
            "line": 197,
            "code": "    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: ''\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.description must be at least 3 characters',\n          details: {\n            errors: [{\n              path: ['compo', 'description'],\n              message: 'compo.description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - maxLength",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 230,
                "column": 54,
                "index": 5880
            },
            "line": 230,
            "code": "    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.'\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.description must be at most 10 characters',\n          details: {\n            errors: [{\n              path: ['compo', 'description'],\n              message: 'compo.description must be at most 10 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - required",
            "suites": [
                "Core API - Basic + compo + draftAndPublish",
                "validation"
            ],
            "updatePoint": {
                "line": 263,
                "column": 53,
                "index": 6846
            },
            "line": 263,
            "code": "    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        compo: {\n          description: 'short'\n        }\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-compo-and-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'compo.name must be defined.',\n          details: {\n            errors: [{\n              path: ['compo', 'name'],\n              message: 'compo.name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp-compo.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create a product",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 64,
                "column": 24,
                "index": 1337
            },
            "line": 64,
            "code": "  test('Create a product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description'\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: {\n        data: product\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.products.push(body.data);\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create a product + can overwrite publishedAt",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 87,
                "column": 52,
                "index": 1903
            },
            "line": 87,
            "code": "  test('Create a product + can overwrite publishedAt', async () => {\n    const product = {\n      name: 'Product 2',\n      description: 'Product description',\n      publishedAt: '2020-08-20T10:27:55.000Z'\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-dps',\n      body: {\n        data: product\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.products.push(body.data);\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read products",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 111,
                "column": 21,
                "index": 2485
            },
            "line": 111,
            "code": "  test('Read products', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-dps'\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(2);\n    expect(body.data).toEqual(expect.arrayContaining([expect.objectContaining({\n      id: expect.anything(),\n      attributes: expect.objectContaining({\n        name: 'Product 1',\n        description: 'Product description'\n      })\n    })]));\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeISODate();\n    });\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 132,
                "column": 22,
                "index": 3057
            },
            "line": 132,
            "code": "  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description'\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: {\n        data: product\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.products[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.products[0] = body.data;\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product + can overwrite publishedAt",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 155,
                "column": 50,
                "index": 3660
            },
            "line": 155,
            "code": "  test('Update product + can overwrite publishedAt', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      publishedAt: '2020-08-27T09:50:50.000Z'\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-dps/${data.products[0].id}`,\n      body: {\n        data: product\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.products[0].id,\n      attributes: _.pick(data.products[0], ['name', 'description'])\n    });\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    expect(body.data.attributes.publishedAt).toBe(product.publishedAt);\n    data.products[0] = body.data;\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product",
            "suites": [
                "Core API - Basic + draftAndPublish"
            ],
            "updatePoint": {
                "line": 180,
                "column": 22,
                "index": 4396
            },
            "line": 180,
            "code": "  test('Delete product', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-dps/${data.products[0].id}`\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.products[0]);\n    expect(body.data.id).toEqual(data.products[0].id);\n    expect(body.data.attributes.publishedAt).toBeISODate();\n    data.products.shift();\n  });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create a product - minLength",
            "suites": [
                "Core API - Basic + draftAndPublish",
                "validators"
            ],
            "updatePoint": {
                "line": 195,
                "column": 45,
                "index": 4874
            },
            "line": 195,
            "code": "    test('Cannot create a product - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: ''\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          message: 'description must be at least 3 characters',\n          name: 'ValidationError',\n          details: {\n            errors: [{\n              path: ['description'],\n              message: 'description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create a product - required",
            "suites": [
                "Core API - Basic + draftAndPublish",
                "validators"
            ],
            "updatePoint": {
                "line": 223,
                "column": 44,
                "index": 5623
            },
            "line": 223,
            "code": "    test('Cannot create a product - required', async () => {\n      const product = {\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'name must be defined.',\n          details: {\n            errors: [{\n              path: ['name'],\n              message: 'name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create a product - maxLength",
            "suites": [
                "Core API - Basic + draftAndPublish",
                "validators"
            ],
            "updatePoint": {
                "line": 251,
                "column": 45,
                "index": 6341
            },
            "line": 251,
            "code": "    test('Cannot create a product - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: \"I'm a product description that is very long. At least thirty characters.\"\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dps',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          message: 'description must be at most 30 characters',\n          name: 'ValidationError',\n          details: {\n            errors: [{\n              path: ['description'],\n              message: 'description must be at most 30 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dp.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create product with compo",
            "suites": [
                "Core API - Basic + dz"
            ],
            "updatePoint": {
                "line": 64,
                "column": 33,
                "index": 1323
            },
            "line": 64,
            "code": "  test('Create product with compo', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description',\n      dz: [{\n        __component: 'default.compo',\n        name: 'compo name',\n        description: 'short'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'POST',\n      url: '/product-with-dzs',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['dz']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productWithDz.push(body.data);\n  });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product with compo",
            "suites": [
                "Core API - Basic + dz"
            ],
            "updatePoint": {
                "line": 95,
                "column": 31,
                "index": 2039
            },
            "line": 95,
            "code": "  test('Read product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'GET',\n      url: '/product-with-dzs',\n      qs: {\n        populate: ['dz']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toHaveLength(1);\n    expect(body.data[0]).toMatchObject(data.productWithDz[0]);\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeUndefined();\n    });\n  });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product with compo",
            "suites": [
                "Core API - Basic + dz"
            ],
            "updatePoint": {
                "line": 113,
                "column": 33,
                "index": 2490
            },
            "line": 113,
            "code": "  test('Update product with compo', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description',\n      dz: [{\n        __component: 'default.compo',\n        name: 'compo name updated',\n        description: 'update'\n      }]\n    };\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'PUT',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n      body: {\n        data: product\n      },\n      qs: {\n        populate: ['dz']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      id: data.productWithDz[0].id,\n      attributes: product\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productWithDz[0] = body.data;\n  });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product with compo",
            "suites": [
                "Core API - Basic + dz"
            ],
            "updatePoint": {
                "line": 144,
                "column": 33,
                "index": 3266
            },
            "line": 144,
            "code": "  test('Delete product with compo', async () => {\n    const {\n      statusCode,\n      body\n    } = await rq({\n      method: 'DELETE',\n      url: `/product-with-dzs/${data.productWithDz[0].id}`,\n      qs: {\n        populate: ['dz']\n      }\n    });\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.productWithDz[0]);\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.productWithDz.shift();\n  });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - compo required",
            "suites": [
                "Core API - Basic + dz",
                "validation"
            ],
            "updatePoint": {
                "line": 161,
                "column": 59,
                "index": 3766
            },
            "line": 161,
            "code": "    test('Cannot create product with compo - compo required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description'\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'dz must be defined.',\n          details: {\n            errors: [{\n              path: ['dz'],\n              message: 'dz must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - minLength",
            "suites": [
                "Core API - Basic + dz",
                "validation"
            ],
            "updatePoint": {
                "line": 190,
                "column": 54,
                "index": 4514
            },
            "line": 190,
            "code": "    test('Cannot create product with compo - minLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [{\n          __component: 'default.compo',\n          name: 'compo name',\n          description: ''\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'dz[0].description must be at least 3 characters',\n          details: {\n            errors: [{\n              path: ['dz', '0', 'description'],\n              message: 'dz[0].description must be at least 3 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - maxLength",
            "suites": [
                "Core API - Basic + dz",
                "validation"
            ],
            "updatePoint": {
                "line": 224,
                "column": 54,
                "index": 5461
            },
            "line": 224,
            "code": "    test('Cannot create product with compo - maxLength', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [{\n          __component: 'default.compo',\n          name: 'compo name',\n          description: 'A very long description that exceed the min length.'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'dz[0].description must be at most 10 characters',\n          details: {\n            errors: [{\n              path: ['dz', '0', 'description'],\n              message: 'dz[0].description must be at most 10 characters',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - required",
            "suites": [
                "Core API - Basic + dz",
                "validation"
            ],
            "updatePoint": {
                "line": 258,
                "column": 53,
                "index": 6458
            },
            "line": 258,
            "code": "    test('Cannot create product with compo - required', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [{\n          __component: 'default.compo',\n          description: 'short'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: 'dz[0].name must be defined.',\n          details: {\n            errors: [{\n              path: ['dz', '0', 'name'],\n              message: 'dz[0].name must be defined.',\n              name: 'ValidationError'\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create product with compo - missing __component",
            "suites": [
                "Core API - Basic + dz",
                "validation"
            ],
            "updatePoint": {
                "line": 291,
                "column": 64,
                "index": 7343
            },
            "line": 291,
            "code": "    test('Cannot create product with compo - missing __component', async () => {\n      const product = {\n        name: 'Product 1',\n        description: 'Product description',\n        dz: [{\n          name: 'Product 1',\n          description: 'short'\n        }]\n      };\n      const res = await rq({\n        method: 'POST',\n        url: '/product-with-dzs',\n        body: {\n          data: product\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          status: 400,\n          name: 'ValidationError',\n          message: '2 errors occurred',\n          details: {\n            errors: [{\n              path: ['dz', '0', '__component'],\n              message: 'dz[0].__component is a required field',\n              name: 'ValidationError'\n            }, {\n              message: 'Cannot build relations store from dynamiczone, component identifier is undefined',\n              name: 'ValidationError',\n              path: []\n            }]\n          }\n        }\n      });\n    });",
            "file": "api/basic-dz.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create entry without required multiple media",
            "suites": [
                "Core API - Basic + required media"
            ],
            "updatePoint": {
                "line": 67,
                "column": 52,
                "index": 1605
            },
            "line": 67,
            "code": "  test('Create entry without required multiple media', async () => {\n    const product = {\n      name: 'product',\n      description: 'description',\n      media: file.id\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-medias',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: true\n      }\n    });\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      data: null,\n      error: {\n        status: 400,\n        name: 'ValidationError',\n        message: 'multipleMedia must be defined.',\n        details: {\n          errors: [{\n            path: ['multipleMedia'],\n            message: 'multipleMedia must be defined.',\n            name: 'ValidationError'\n          }]\n        }\n      }\n    });\n  });",
            "file": "api/basic-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create entry with required multiple media as an empty array",
            "suites": [
                "Core API - Basic + required media"
            ],
            "updatePoint": {
                "line": 100,
                "column": 67,
                "index": 2402
            },
            "line": 100,
            "code": "  test('Create entry with required multiple media as an empty array', async () => {\n    const product = {\n      name: 'product',\n      description: 'description',\n      multipleMedia: [],\n      media: file.id\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-medias',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: true\n      }\n    });\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      data: null,\n      error: {\n        status: 400,\n        name: 'ValidationError',\n        message: 'multipleMedia field must have at least 1 items',\n        details: {\n          errors: [{\n            path: ['multipleMedia'],\n            message: 'multipleMedia field must have at least 1 items',\n            name: 'ValidationError'\n          }]\n        }\n      }\n    });\n  });",
            "file": "api/basic-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create entry without required single media",
            "suites": [
                "Core API - Basic + required media"
            ],
            "updatePoint": {
                "line": 134,
                "column": 50,
                "index": 3239
            },
            "line": 134,
            "code": "  test('Create entry without required single media', async () => {\n    const product = {\n      name: 'product',\n      description: 'description',\n      multipleMedia: [{\n        id: file.id\n      }]\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/product-with-medias',\n      body: {\n        data: product\n      },\n      qs: {\n        populate: true\n      }\n    });\n    expect(res.statusCode).toBe(400);\n    expect(res.body).toMatchObject({\n      data: null,\n      error: {\n        status: 400,\n        name: 'ValidationError',\n        message: 'media must be defined.',\n        details: {\n          errors: [{\n            path: ['media'],\n            message: 'media must be defined.',\n            name: 'ValidationError'\n          }]\n        }\n      }\n    });\n  });",
            "file": "api/basic-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create product",
            "suites": [
                "Core API - Basic"
            ],
            "updatePoint": {
                "line": 59,
                "column": 22,
                "index": 1163
            },
            "line": 59,
            "code": "  test('Create product', async () => {\n    const product = {\n      name: 'Product 1',\n      description: 'Product description'\n    };\n    const res = await rq({\n      method: 'POST',\n      url: '/products',\n      body: {\n        data: product\n      }\n    });\n    const {\n      statusCode,\n      body\n    } = res;\n    expect(statusCode).toBe(200);\n    expect(body).toMatchObject({\n      data: {\n        id: expect.anything(),\n        attributes: product\n      }\n    });\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.product.push(body.data);\n  });",
            "file": "api/basic.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Read product",
            "suites": [
                "Core API - Basic"
            ],
            "updatePoint": {
                "line": 85,
                "column": 20,
                "index": 1732
            },
            "line": 85,
            "code": "  test('Read product', async () => {\n    const res = await rq({\n      method: 'GET',\n      url: '/products'\n    });\n    const {\n      statusCode,\n      body\n    } = res;\n    expect(statusCode).toBe(200);\n    expect(Array.isArray(body.data)).toBe(true);\n    expect(body.data).toHaveLength(1);\n    expect(body.data).toEqual(expect.arrayContaining([expect.objectContaining({\n      id: expect.anything(),\n      attributes: expect.objectContaining({\n        name: 'Product 1',\n        description: 'Product description'\n      })\n    })]));\n    body.data.forEach(p => {\n      expect(p.attributes.publishedAt).toBeUndefined();\n    });\n  });",
            "file": "api/basic.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update product",
            "suites": [
                "Core API - Basic"
            ],
            "updatePoint": {
                "line": 108,
                "column": 22,
                "index": 2368
            },
            "line": 108,
            "code": "  test('Update product', async () => {\n    const product = {\n      name: 'Product 1 updated',\n      description: 'Updated Product description'\n    };\n    const res = await rq({\n      method: 'PUT',\n      url: `/products/${data.product[0].id}`,\n      body: {\n        data: product\n      }\n    });\n    const {\n      statusCode,\n      body\n    } = res;\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject({\n      attributes: product\n    });\n    expect(body.data.id).toEqual(data.product[0].id);\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.product[0] = res.body.data;\n  });",
            "file": "api/basic.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete product",
            "suites": [
                "Core API - Basic"
            ],
            "updatePoint": {
                "line": 132,
                "column": 22,
                "index": 2983
            },
            "line": 132,
            "code": "  test('Delete product', async () => {\n    const res = await rq({\n      method: 'DELETE',\n      url: `/products/${data.product[0].id}`\n    });\n    const {\n      statusCode,\n      body\n    } = res;\n    expect(statusCode).toBe(200);\n    expect(body.data).toMatchObject(data.product[0]);\n    expect(body.data.id).toEqual(data.product[0].id);\n    expect(body.data.attributes.publishedAt).toBeUndefined();\n    data.product.shift();\n  });",
            "file": "api/basic.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No filters & no populate",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 198,
                "column": 34,
                "index": 4240
            },
            "line": 198,
            "code": "    test('No filters & no populate', async () => {\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.a.pluralName}`);\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(fixtures.a.length);\n      body.data.forEach(entity => {\n        expect(entity).not.toHaveProperty('fooRef');\n        expect(entity).not.toHaveProperty('barRefs');\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No filters & specific populate",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 210,
                "column": 40,
                "index": 4655
            },
            "line": 210,
            "code": "    test('No filters & specific populate', async () => {\n      const qs = {\n        populate: 'fooRef'\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.a.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(fixtures.a.length);\n      body.data.forEach(entity => {\n        expect(entity.attributes).toHaveProperty('fooRef');\n        expect(entity.attributes).not.toHaveProperty('barRefs');\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No filters & populate all",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 227,
                "column": 35,
                "index": 5160
            },
            "line": 227,
            "code": "    test('No filters & populate all', async () => {\n      const qs = {\n        populate: '*'\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.a.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(fixtures.a.length);\n      body.data.forEach(entity => {\n        expect(entity.attributes).toHaveProperty('fooRef');\n        expect(entity.attributes).toHaveProperty('barRefs');\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No filters & deep populate",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 244,
                "column": 36,
                "index": 5657
            },
            "line": 244,
            "code": "    test('No filters & deep populate', async () => {\n      const qs = {\n        populate: ['second', 'third.fooRef']\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.c.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      body.data.forEach(entity => {\n        expect(entity.attributes).toHaveProperty('second');\n        expect(entity.attributes).toHaveProperty('third');\n        expect(Array.isArray(entity.attributes.third.data)).toBe(true);\n        entity.attributes.third.data.forEach(thirdItem => {\n          const expected = data.a.find(propEq('id', thirdItem.id));\n          expect(thirdItem.attributes).toMatchObject(omit('id', expected));\n        });\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Simple filters & populate",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 266,
                "column": 35,
                "index": 6446
            },
            "line": 266,
            "code": "    test('Simple filters & populate', async () => {\n      const qs = {\n        populate: {\n          second: {\n            filters: {\n              number: {\n                $lt: 15\n              }\n            }\n          }\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.c.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      const [firstItem, secondItem] = body.data;\n      expect(firstItem.attributes.second).toBeNull();\n      expect(secondItem.attributes.second).not.toBeNull();\n      expect(secondItem.attributes.second).toMatchObject({\n        number: 14,\n        field: 'a simple string'\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Simple filters & deep populate",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 294,
                "column": 40,
                "index": 7189
            },
            "line": 294,
            "code": "    test('Simple filters & deep populate', async () => {\n      const qs = {\n        populate: {\n          third: {\n            populate: {\n              fooRef: {\n                filters: {\n                  field: {\n                    $eq: 'text'\n                  }\n                }\n              }\n            }\n          }\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.c.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      const [firstItem, secondItem] = body.data;\n      expect(firstItem.attributes.third.data[0].attributes.fooRef).not.toBeNull();\n      expect(secondItem.attributes.third.data[0].attributes.fooRef).not.toBeNull();\n      expect(secondItem.attributes.third.data[1].attributes.fooRef).toBeNull();\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Populate with object and 't'",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 323,
                "column": 38,
                "index": 8042
            },
            "line": 323,
            "code": "    test(\"Populate with object and 't'\", async () => {\n      const qs = {\n        populate: {\n          third: 't'\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.c.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      expect(body.data[0].attributes.third.data[0].attributes.fooRef).toBeUndefined();\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Don't populate with object and 'f'",
            "suites": [
                "Populate filters",
                "Populate simple relation"
            ],
            "updatePoint": {
                "line": 339,
                "column": 44,
                "index": 8480
            },
            "line": 339,
            "code": "    test(\"Don't populate with object and 'f'\", async () => {\n      const qs = {\n        populate: {\n          third: 'f'\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.c.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      expect(body.data[0].attributes.third).toBeUndefined();\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Populate every component in the dynamic zone",
            "suites": [
                "Populate filters",
                "Populate a dynamic zone"
            ],
            "updatePoint": {
                "line": 357,
                "column": 54,
                "index": 8954
            },
            "line": 357,
            "code": "    test('Populate every component in the dynamic zone', async () => {\n      const qs = {\n        populate: {\n          dz: '*'\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.b.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      fixtures.b.forEach((fixture, i) => {\n        const res = body.data[i];\n        const {\n          dz\n        } = res.attributes;\n        expect(dz).toHaveLength(fixture.dz.length);\n        expect(dz).toMatchObject(fixture.dz.map(component => ({\n          ...omit('field', component),\n          id: expect.any(Number)\n        })));\n      });\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Populate only one component type using fragment",
            "suites": [
                "Populate filters",
                "Populate a dynamic zone"
            ],
            "updatePoint": {
                "line": 383,
                "column": 57,
                "index": 9661
            },
            "line": 383,
            "code": "    test('Populate only one component type using fragment', async () => {\n      const qs = {\n        populate: {\n          dz: {\n            on: {\n              'default.foo': true\n            }\n          }\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.b.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      expect(body.data[0].attributes.dz).toHaveLength(3);\n      expect(body.data[1].attributes.dz).toHaveLength(0);\n      const expected = fixtures.b[0].dz.filter(({\n        __component\n      }) => __component === 'default.foo').map(component => ({\n        ...component,\n        id: expect.any(Number)\n      }));\n      expect(body.data[0].attributes.dz).toMatchObject(expected);\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Populate the dynamic zone with filters in fragments",
            "suites": [
                "Populate filters",
                "Populate a dynamic zone"
            ],
            "updatePoint": {
                "line": 411,
                "column": 61,
                "index": 10481
            },
            "line": 411,
            "code": "    test('Populate the dynamic zone with filters in fragments', async () => {\n      const qs = {\n        populate: {\n          dz: {\n            on: {\n              'default.foo': {\n                filters: {\n                  number: {\n                    $lt: 3\n                  }\n                }\n              },\n              'default.bar': {\n                filters: {\n                  title: {\n                    $contains: 'another'\n                  }\n                }\n              }\n            }\n          }\n        }\n      };\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.b.pluralName}`, {\n        qs\n      });\n      expect(status).toBe(200);\n      expect(body.data).toHaveLength(2);\n      expect(body.data[0].attributes.dz).toHaveLength(2);\n      expect(body.data[1].attributes.dz).toHaveLength(1);\n      const filter = (data = []) => data.filter(({\n        __component,\n        number,\n        title\n      }) => {\n        if (__component === 'default.foo') return number < 3;\n        if (__component === 'default.bar') return title.includes('another');\n        return false;\n      }).map(component => ({\n        ...(component.__component === 'default.foo' ? component : omit('field', component)),\n        id: expect.any(Number)\n      }));\n      expect(body.data[0].attributes.dz).toMatchObject(filter(fixtures.b[0].dz));\n      expect(body.data[1].attributes.dz).toMatchObject(filter(fixtures.b[1].dz));\n    });",
            "file": "api/populate/filtering/index.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Media can be populated without restricted attributes",
            "suites": [
                "Sanitize populated entries",
                "Populate simple media"
            ],
            "updatePoint": {
                "line": 67,
                "column": 62,
                "index": 1620
            },
            "line": 67,
            "code": "    test('Media can be populated without restricted attributes', async () => {\n      const {\n        status,\n        body\n      } = await rq.get(`/${schemas.contentTypes.a.pluralName}`, {\n        qs: {\n          populate: {\n            cover: {\n              populate: '*'\n            }\n          }\n        }\n      });\n      expect(status).toBe(200);\n      expect(body.data[0].attributes.cover).toBeDefined();\n      expect(body.data[0].attributes.cover.data.attributes.createdBy).toBeUndefined();\n      expect(body.data[0].attributes.cover.data.attributes.updatedBy).toBeUndefined();\n    });",
            "file": "api/populate/sanitize.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create an entity with relations using %s",
            "suites": [
                "Relations"
            ],
            "line": 322,
            "code": "  describe.each([['connect'], ['set']])('Create an entity with relations using %s', connectOrSet => {\n    describe.each([['directly in the array ([1, 2])', 'object'], ['an object in the array ([{ id: 1 }, { id: 2 }])', 'array']])('ids being %s', (name, mode) => {\n      test('In one order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id2\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });\n      test('In reversed order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        manyRelations.reverse();\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });\n    });\n  });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "ids being %s",
            "suites": [
                "Relations"
            ],
            "line": 323,
            "code": "    describe.each([['directly in the array ([1, 2])', 'object'], ['an object in the array ([{ id: 1 }, { id: 2 }])', 'array']])('ids being %s', (name, mode) => {\n      test('In one order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id2\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });\n      test('In reversed order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        manyRelations.reverse();\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "In one order",
            "suites": [
                "Relations"
            ],
            "updatePoint": {
                "line": 324,
                "column": 24,
                "index": 6665
            },
            "line": 324,
            "code": "      test('In one order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id2\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "In reversed order",
            "suites": [
                "Relations"
            ],
            "updatePoint": {
                "line": 417,
                "column": 29,
                "index": 8907
            },
            "line": 417,
            "code": "      test('In reversed order', async () => {\n        const oneRelation = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const manyRelations = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id2\n        }] : [id1, id2];\n        manyRelations.reverse();\n        const shop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            [connectOrSet]: oneRelation\n          },\n          products_oo: {\n            [connectOrSet]: oneRelation\n          },\n          products_mo: {\n            [connectOrSet]: oneRelation\n          },\n          products_om: {\n            [connectOrSet]: manyRelations\n          },\n          products_mm: {\n            [connectOrSet]: manyRelations\n          },\n          products_mw: {\n            [connectOrSet]: manyRelations\n          },\n          myCompo: {\n            compo_products_ow: {\n              [connectOrSet]: oneRelation\n            },\n            compo_products_mw: {\n              [connectOrSet]: manyRelations\n            }\n          }\n        }, populateShop);\n        expect(shop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "ids being %s",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "line": 514,
            "code": "    describe.each([['directly in the array ([3])', 'object'], ['an object in the array ([{ id: 3 }])', 'array']])('ids being %s', (name, mode) => {\n      test('Adding id3', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd\n          },\n          products_oo: {\n            connect: relationToAdd\n          },\n          products_mo: {\n            connect: relationToAdd\n          },\n          products_om: {\n            connect: relationToAdd\n          },\n          products_mm: {\n            connect: relationToAdd\n          },\n          products_mw: {\n            connect: relationToAdd\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd\n            },\n            compo_products_mw: {\n              connect: relationToAdd\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });\n      test('Adding id3 & removing id1', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const relationToRemove = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_oo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_om: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mm: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mw: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            },\n            compo_products_mw: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });\n      test('Adding id3 & removing id1, id3 (should still add id3)', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const relationToRemove = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id3\n        }] : [id1, id3];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_oo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_om: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mm: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mw: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            },\n            compo_products_mw: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });\n      test('Change relation order from id1, id2, id3 to id3, id2, id1', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: id1\n        }] : [id3, id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id3\n                }, {\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            }\n          }\n        });\n      });\n      test('Change relation order by putting id2 at the end', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id2\n        }] : [id2];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id3\n                }, {\n                  id: id2\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            }\n          }\n        });\n      });\n      test('Change relation order by putting id2, id1 at the end', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id2\n        }, {\n          id: id1\n        }] : [id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id3\n                }, {\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            }\n          }\n        });\n      });\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Adding id3",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 515,
                "column": 22,
                "index": 11386
            },
            "line": 515,
            "code": "      test('Adding id3', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd\n          },\n          products_oo: {\n            connect: relationToAdd\n          },\n          products_mo: {\n            connect: relationToAdd\n          },\n          products_om: {\n            connect: relationToAdd\n          },\n          products_mm: {\n            connect: relationToAdd\n          },\n          products_mw: {\n            connect: relationToAdd\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd\n            },\n            compo_products_mw: {\n              connect: relationToAdd\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Adding id3 & removing id1",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 641,
                "column": 37,
                "index": 14440
            },
            "line": 641,
            "code": "      test('Adding id3 & removing id1', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const relationToRemove = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_oo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_om: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mm: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mw: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            },\n            compo_products_mw: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Adding id3 & removing id1, id3 (should still add id3)",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 770,
                "column": 65,
                "index": 17780
            },
            "line": 770,
            "code": "      test('Adding id3 & removing id1, id3 (should still add id3)', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2]\n          },\n          products_mm: {\n            connect: [id1, id2]\n          },\n          products_mw: {\n            connect: [id1, id2]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2]\n            }\n          }\n        }, ['myCompo']);\n        const relationToAdd = mode === 'object' ? [{\n          id: id3\n        }] : [id3];\n        const relationToRemove = mode === 'object' ? [{\n          id: id1\n        }, {\n          id: id3\n        }] : [id1, id3];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_oo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mo: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_om: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mm: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          products_mw: {\n            connect: relationToAdd,\n            disconnect: relationToRemove\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            },\n            compo_products_mw: {\n              connect: relationToAdd,\n              disconnect: relationToRemove\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id2\n                }, {\n                  id: id3\n                }]\n              },\n              compo_products_ow: {\n                data: {\n                  id: id3\n                }\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_mo: {\n              data: {\n                id: id3\n              }\n            },\n            products_mw: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id2\n              }, {\n                id: id3\n              }]\n            },\n            products_oo: {\n              data: {\n                id: id3\n              }\n            },\n            products_ow: {\n              data: {\n                id: id3\n              }\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Change relation order from id1, id2, id3 to id3, id2, id1",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 901,
                "column": 69,
                "index": 21160
            },
            "line": 901,
            "code": "      test('Change relation order from id1, id2, id3 to id3, id2, id1', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: id1\n        }] : [id3, id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id3\n                }, {\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Change relation order by putting id2 at the end",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 987,
                "column": 59,
                "index": 23335
            },
            "line": 987,
            "code": "      test('Change relation order by putting id2 at the end', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id2\n        }] : [id2];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }, {\n                  id: id3\n                }, {\n                  id: id2\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }, {\n                id: id3\n              }, {\n                id: id2\n              }]\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Change relation order by putting id2, id1 at the end",
            "suites": [
                "Relations",
                "Update an entity relations"
            ],
            "updatePoint": {
                "line": 1069,
                "column": 64,
                "index": 25443
            },
            "line": 1069,
            "code": "      test('Change relation order by putting id2, id1 at the end', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationToChange = mode === 'object' ? [{\n          id: id2\n        }, {\n          id: id1\n        }] : [id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_om: {\n            connect: relationToChange\n          },\n          products_mm: {\n            connect: relationToChange\n          },\n          products_mw: {\n            connect: relationToChange\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_mw: {\n              connect: relationToChange\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_mw: {\n                data: [{\n                  id: id3\n                }, {\n                  id: id2\n                }, {\n                  id: id1\n                }]\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id3\n              }, {\n                id: id2\n              }, {\n                id: id1\n              }]\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "ids being %s",
            "suites": [
                "Relations",
                "Disconnect entity relations"
            ],
            "line": 1156,
            "code": "    describe.each([['directly in the array ([1, 2, 3])', 'object'], ['an object in the array ([{ id: 1 }, { id: 2 }, { id: 3 }])', 'array']])('ids being %s', (name, mode) => {\n      test('Remove all relations id1, id2, id3', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationsToDisconnectOne = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const relationsToDisconnectMany = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: id1\n        }] : [id3, id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_oo: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_mo: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_om: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mm: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mw: {\n            disconnect: relationsToDisconnectMany\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              disconnect: relationsToDisconnectOne\n            },\n            compo_products_mw: {\n              disconnect: relationsToDisconnectMany\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_ow: {\n                data: null\n              },\n              compo_products_mw: {\n                data: []\n              }\n            },\n            products_ow: {\n              data: null\n            },\n            products_oo: {\n              data: null\n            },\n            products_mo: {\n              data: null\n            },\n            products_mm: {\n              data: []\n            },\n            products_mw: {\n              data: []\n            },\n            products_om: {\n              data: []\n            }\n          }\n        });\n      });\n      test(\"Remove relations that doesn't exist doesn't fail\", async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1]\n          },\n          products_mm: {\n            connect: [id1]\n          },\n          products_mw: {\n            connect: [id1]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1]\n            }\n          }\n        }, ['myCompo']);\n        const relationsToDisconnectMany = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: 9999\n        }] : [id3, id2, 9999];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_oo: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mo: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_om: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mm: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mw: {\n            disconnect: relationsToDisconnectMany\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              disconnect: relationsToDisconnectMany\n            },\n            compo_products_mw: {\n              disconnect: relationsToDisconnectMany\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              },\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }]\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }]\n            }\n          }\n        });\n      });\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Remove all relations id1, id2, id3",
            "suites": [
                "Relations",
                "Disconnect entity relations"
            ],
            "updatePoint": {
                "line": 1157,
                "column": 46,
                "index": 27809
            },
            "line": 1157,
            "code": "      test('Remove all relations id1, id2, id3', async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1, id2, id3]\n          },\n          products_mm: {\n            connect: [id1, id2, id3]\n          },\n          products_mw: {\n            connect: [id1, id2, id3]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1, id2, id3]\n            }\n          }\n        }, ['myCompo']);\n        const relationsToDisconnectOne = mode === 'object' ? [{\n          id: id1\n        }] : [id1];\n        const relationsToDisconnectMany = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: id1\n        }] : [id3, id2, id1];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_oo: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_mo: {\n            disconnect: relationsToDisconnectOne\n          },\n          products_om: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mm: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mw: {\n            disconnect: relationsToDisconnectMany\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              disconnect: relationsToDisconnectOne\n            },\n            compo_products_mw: {\n              disconnect: relationsToDisconnectMany\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_ow: {\n                data: null\n              },\n              compo_products_mw: {\n                data: []\n              }\n            },\n            products_ow: {\n              data: null\n            },\n            products_oo: {\n              data: null\n            },\n            products_mo: {\n              data: null\n            },\n            products_mm: {\n              data: []\n            },\n            products_mw: {\n              data: []\n            },\n            products_om: {\n              data: []\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Remove relations that doesn't exist doesn't fail",
            "suites": [
                "Relations",
                "Disconnect entity relations"
            ],
            "updatePoint": {
                "line": 1258,
                "column": 60,
                "index": 30536
            },
            "line": 1258,
            "code": "      test(\"Remove relations that doesn't exist doesn't fail\", async () => {\n        const createdShop = await createEntry('shops', {\n          name: 'Cazotte Shop',\n          products_ow: {\n            connect: [id1]\n          },\n          products_oo: {\n            connect: [id1]\n          },\n          products_mo: {\n            connect: [id1]\n          },\n          products_om: {\n            connect: [id1]\n          },\n          products_mm: {\n            connect: [id1]\n          },\n          products_mw: {\n            connect: [id1]\n          },\n          myCompo: {\n            compo_products_ow: {\n              connect: [id1]\n            },\n            compo_products_mw: {\n              connect: [id1]\n            }\n          }\n        }, ['myCompo']);\n        const relationsToDisconnectMany = mode === 'object' ? [{\n          id: id3\n        }, {\n          id: id2\n        }, {\n          id: 9999\n        }] : [id3, id2, 9999];\n        const updatedShop = await updateEntry('shops', createdShop.data.id, {\n          name: 'Cazotte Shop',\n          products_ow: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_oo: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mo: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_om: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mm: {\n            disconnect: relationsToDisconnectMany\n          },\n          products_mw: {\n            disconnect: relationsToDisconnectMany\n          },\n          myCompo: {\n            id: createdShop.data.attributes.myCompo.id,\n            compo_products_ow: {\n              disconnect: relationsToDisconnectMany\n            },\n            compo_products_mw: {\n              disconnect: relationsToDisconnectMany\n            }\n          }\n        }, populateShop);\n        expect(updatedShop.data).toMatchObject({\n          attributes: {\n            myCompo: {\n              compo_products_ow: {\n                data: {\n                  id: id1\n                }\n              },\n              compo_products_mw: {\n                data: [{\n                  id: id1\n                }]\n              }\n            },\n            products_ow: {\n              data: {\n                id: id1\n              }\n            },\n            products_oo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mo: {\n              data: {\n                id: id1\n              }\n            },\n            products_mm: {\n              data: [{\n                id: id1\n              }]\n            },\n            products_mw: {\n              data: [{\n                id: id1\n              }]\n            },\n            products_om: {\n              data: [{\n                id: id1\n              }]\n            }\n          }\n        });\n      });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Connect new relation at the start",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1375,
                "column": 43,
                "index": 33491
            },
            "line": 1375,
            "code": "    test('Connect new relation at the start', async () => {\n      const createdShop = await createShop({\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            start: true\n          }\n        }, {\n          id: id2,\n          position: {\n            start: true\n          }\n        }]\n      });\n      const expectedCreatedShop = shopFactory({\n        anyToManyRel: [{\n          id: id2\n        }, {\n          id: id1\n        }]\n      });\n      expect(createdShop.data).toMatchObject(expectedCreatedShop);\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Connect new relation at the end",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1398,
                "column": 41,
                "index": 34025
            },
            "line": 1398,
            "code": "    test('Connect new relation at the end', async () => {\n      const createdShop = await createShop({\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            end: true\n          }\n        }, {\n          id: id2,\n          position: {\n            end: true\n          }\n        }]\n      });\n      const expectedCreatedShop = shopFactory({\n        anyToManyRel: [{\n          id: id1\n        }, {\n          id: id2\n        }]\n      });\n      expect(createdShop.data).toMatchObject(expectedCreatedShop);\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create relations using before and after",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1421,
                "column": 49,
                "index": 34563
            },
            "line": 1421,
            "code": "    test('Create relations using before and after', async () => {\n      const createdShop = await createShop({\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            start: true\n          }\n        }, {\n          id: id2,\n          position: {\n            start: true\n          }\n        }, {\n          id: id3,\n          position: {\n            after: id1\n          }\n        }]\n      });\n      const expectedShop = shopFactory({\n        anyToManyRel: [{\n          id: id2\n        }, {\n          id: id1\n        }, {\n          id: id3\n        }]\n      });\n      expect(createdShop.data).toMatchObject(expectedShop);\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update relations using before and after",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1451,
                "column": 49,
                "index": 35211
            },
            "line": 1451,
            "code": "    test('Update relations using before and after', async () => {\n      const shop = await createShop({\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            end: true\n          }\n        }, {\n          id: id2,\n          position: {\n            end: true\n          }\n        }]\n      });\n      const updatedShop = await updateShop(shop.data, {\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            before: id2\n          }\n        }, {\n          id: id2,\n          position: {\n            start: true\n          }\n        }, {\n          id: id3,\n          position: {\n            end: true\n          }\n        }]\n      });\n      const expectedShop = shopFactory({\n        anyToManyRel: [{\n          id: id2\n        }, {\n          id: id1\n        }, {\n          id: id3\n        }]\n      });\n      expect(updatedShop.data).toMatchObject(expectedShop);\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update relations using the same id multiple times",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1494,
                "column": 59,
                "index": 36126
            },
            "line": 1494,
            "code": "    test('Update relations using the same id multiple times', async () => {\n      const shop = await createShop({\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            end: true\n          }\n        }, {\n          id: id2,\n          position: {\n            end: true\n          }\n        }]\n      });\n      const updatedShop = await updateShop(shop.data, {\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            end: true\n          }\n        }, {\n          id: id1,\n          position: {\n            start: true\n          }\n        }, {\n          id: id1,\n          position: {\n            after: id2\n          }\n        }]\n      });\n      expect(updatedShop.error).toMatchObject({\n        status: 400,\n        name: 'ValidationError'\n      });\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update relations with invalid connect array in strict mode",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1531,
                "column": 68,
                "index": 36933
            },
            "line": 1531,
            "code": "    test('Update relations with invalid connect array in strict mode', async () => {\n      const shop = await createShop({\n        anyToManyRel: []\n      });\n\n      // Connect before an id that does not exist.\n      const updatedShop = await updateShop(shop.data, {\n        anyToManyRel: [{\n          id: id1,\n          position: {\n            after: id2\n          }\n        }]\n      });\n      expect(updatedShop.error).toMatchObject({\n        status: 400,\n        name: 'ValidationError'\n      });\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update relations with invalid connect array in non-strict mode",
            "suites": [
                "Relations",
                "Reorder entity relations"
            ],
            "updatePoint": {
                "line": 1550,
                "column": 72,
                "index": 37444
            },
            "line": 1550,
            "code": "    test('Update relations with invalid connect array in non-strict mode', async () => {\n      const shop = await createShop({\n        anyToManyRel: [{\n          id: id1\n        }]\n      });\n\n      // Connect before an id that does not exist.\n      const updatedShop = await updateShop(shop.data, {\n        anyToManyRel: [{\n          id: id2,\n          position: {\n            after: id3\n          }\n        }],\n        strict: false\n      });\n      const expectedShop = shopFactory({\n        anyToManyRel: [{\n          id: id1\n        }, {\n          id: id2\n        }]\n      });\n      expect(updatedShop.data).toMatchObject(expectedShop);\n    });",
            "file": "api/relations.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 52,
                "column": 40,
                "index": 1209
            },
            "line": 52,
            "code": "    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      })]));\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an array %p",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "line": 74,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws if the field is not an array %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending a non empty array with less then the min",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 84,
                "column": 70,
                "index": 2162
            },
            "line": 84,
            "code": "    test('Throws when sending a non empty array with less then the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'test'\n            }]\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Success when sending an empty array",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 96,
                "column": 45,
                "index": 2441
            },
            "line": 96,
            "code": "    test('Success when sending an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: []\n          }\n        }\n      });\n      expect(res.statusCode).toBe(200);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending too many items",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 106,
                "column": 44,
                "index": 2677
            },
            "line": 106,
            "code": "    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }]\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send input without the component field",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 128,
                "column": 52,
                "index": 3177
            },
            "line": 128,
            "code": "    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual([]);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Data is ordered in the order sent",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 142,
                "column": 43,
                "index": 3532
            },
            "line": 142,
            "code": "    test('Data is ordered in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'firstString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'firstString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 171,
                "column": 60,
                "index": 4349
            },
            "line": 171,
            "code": "    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      res.body.data.forEach(entry => {\n        expect(Array.isArray(entry.attributes.field)).toBe(true);\n        if (entry.attributes.field.length === 0) return;\n        expect(entry.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n          name: expect.any(String)\n        })]));\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "line": 189,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates order at each request",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 230,
                "column": 39,
                "index": 6002
            },
            "line": 230,
            "code": "    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.body.data.attributes.field[0]).toMatchObject({\n        name: 'someString'\n      });\n      expect(res.body.data.attributes.field[1]).toMatchObject({\n        name: 'otherString'\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'otherString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.data.attributes.field)).toBe(true);\n      expect(updateRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(updateRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 287,
                "column": 56,
                "index": 7662
            },
            "line": 287,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when not enough items",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 330,
                "column": 38,
                "index": 8729
            },
            "line": 330,
            "code": "    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'lala'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(res.body.data);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when too many items",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 366,
                "column": 36,
                "index": 9592
            },
            "line": 366,
            "code": "    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'test'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(res.body.data);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous components if sent without id",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 412,
                "column": 61,
                "index": 10730
            },
            "line": 412,
            "code": "    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'test'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'new String'\n            }, {\n              name: 'test'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      const oldIds = res.body.data.attributes.field.map(val => val.id);\n      updateRes.body.data.attributes.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }, {\n            name: 'test'\n          }]\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }, {\n            name: 'test'\n          }]\n        }\n      });\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 473,
                "column": 43,
                "index": 12227
            },
            "line": 473,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'test'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: 'invalid_id',\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component with ids, create new ones and removes old ones",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 503,
                "column": 74,
                "index": 12932
            },
            "line": 503,
            "code": "    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'two'\n            }, {\n              name: 'three'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: res.body.data.attributes.field[0].id,\n              // send old id to update the previous component\n              name: 'newOne'\n            }, {\n              name: 'newTwo'\n            }, {\n              id: res.body.data.attributes.field[2].id,\n              name: 'three'\n            }, {\n              name: 'four'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            id: res.body.data.attributes.field[0].id,\n            name: 'newOne'\n          }, {\n            name: 'newTwo'\n          }, {\n            id: res.body.data.attributes.field[2].id,\n            name: 'three'\n          }, {\n            name: 'four'\n          }]\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and Not required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 569,
                "column": 39,
                "index": 14640
            },
            "line": 569,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someOtherString'\n            }, {\n              name: 'otherSomeString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toMatchObject(res.body.data);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/repeatable-not-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 50,
                "column": 40,
                "index": 1180
            },
            "line": 50,
            "code": "    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      })]));\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an object %p",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "line": 70,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws if the field is not an object %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send an empty array",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 80,
                "column": 33,
                "index": 2047
            },
            "line": 80,
            "code": "    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual([]);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send input without the component field",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 94,
                "column": 52,
                "index": 2404
            },
            "line": 94,
            "code": "    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual([]);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Data is orderd in the order sent",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 108,
                "column": 42,
                "index": 2758
            },
            "line": 108,
            "code": "    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'firstString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'firstString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 137,
                "column": 60,
                "index": 3575
            },
            "line": 137,
            "code": "    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      res.body.data.forEach(entry => {\n        expect(Array.isArray(entry.attributes.field)).toBe(true);\n        if (entry.attributes.field.length === 0) return;\n        expect(entry.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n          name: expect.any(String)\n        })]));\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "line": 155,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates order at each request",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 194,
                "column": 39,
                "index": 5178
            },
            "line": 194,
            "code": "    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.body.data.attributes.field[0]).toMatchObject({\n        name: 'someString'\n      });\n      expect(res.body.data.attributes.field[1]).toMatchObject({\n        name: 'otherString'\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'otherString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.data.attributes.field)).toBe(true);\n      expect(updateRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(updateRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 251,
                "column": 56,
                "index": 6838
            },
            "line": 251,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Removes previous components if empty array sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 294,
                "column": 57,
                "index": 7924
            },
            "line": 294,
            "code": "    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: []\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectResult);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous components if sent without id",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 333,
                "column": 61,
                "index": 8902
            },
            "line": 333,
            "code": "    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      const oldIds = res.body.data.attributes.field.map(val => val.id);\n      updateRes.body.data.attributes.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 386,
                "column": 43,
                "index": 10231
            },
            "line": 386,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: 'invalid_id',\n              name: 'new String'\n            }]\n          }\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component with ids, create new ones and removes old ones",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 408,
                "column": 74,
                "index": 10782
            },
            "line": 408,
            "code": "    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'two'\n            }, {\n              name: 'three'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: res.body.data.attributes.field[0].id,\n              // send old id to update the previous component\n              name: 'newOne'\n            }, {\n              name: 'newTwo'\n            }, {\n              id: res.body.data.attributes.field[2].id,\n              name: 'three'\n            }, {\n              name: 'four'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            id: res.body.data.attributes.field[0].id,\n            name: 'newOne'\n          }, {\n            name: 'newTwo'\n          }, {\n            id: res.body.data.attributes.field[2].id,\n            name: 'three'\n          }, {\n            name: 'four'\n          }]\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and Not required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 474,
                "column": 39,
                "index": 12490
            },
            "line": 474,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someOtherString'\n            }, {\n              name: 'otherSomeString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toMatchObject(res.body.data);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/repeatable-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Then the order of both entity components is preserved",
            "suites": [
                "Given a content type with a repeatable component and two entities created",
                "When I update the order of one of the entities components"
            ],
            "updatePoint": {
                "line": 97,
                "column": 63,
                "index": 2057
            },
            "line": 97,
            "code": "    test('Then the order of both entity components is preserved', async () => {\n      const updatedEntity1 = await updateEntity(entity1.id, {\n        field: [entity1.attributes.field[1], entity1.attributes.field[0]]\n      });\n      const res = await getEntity(entity2.id);\n      expect(updatedEntity1.body.data.attributes.field).toEqual([{\n        id: expect.anything(),\n        name: 'field2'\n      }, {\n        id: expect.anything(),\n        name: 'field1'\n      }]);\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual([{\n        id: expect.anything(),\n        name: 'field1'\n      }, {\n        id: expect.anything(),\n        name: 'field2'\n      }]);\n    });",
            "file": "components/repeatable-order.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 52,
                "column": 40,
                "index": 1207
            },
            "line": 52,
            "code": "    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      })]));\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating second entry",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 72,
                "column": 31,
                "index": 1779
            },
            "line": 72,
            "code": "    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someValue'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someValue'\n      })]));\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an object %p",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "line": 92,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws if the field is not an object %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending an empty array or an array with less than the min",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 105,
                "column": 79,
                "index": 2745
            },
            "line": 105,
            "code": "    test('Throws when sending an empty array or an array with less than the min', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending too many items",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 118,
                "column": 44,
                "index": 3036
            },
            "line": 118,
            "code": "    test('Throws when sending too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }, {\n              name: 'one'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Data is orderd in the order sent",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 145,
                "column": 42,
                "index": 3621
            },
            "line": 145,
            "code": "    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'firstString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'firstString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 174,
                "column": 60,
                "index": 4438
            },
            "line": 174,
            "code": "    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      res.body.data.forEach(entry => {\n        expect(Array.isArray(entry.attributes.field)).toBe(true);\n        if (entry.attributes.field.length === 0) return;\n        expect(entry.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n          name: expect.any(String)\n        })]));\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "line": 192,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates order at each request",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 231,
                "column": 39,
                "index": 6041
            },
            "line": 231,
            "code": "    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.body.data.attributes.field[0]).toMatchObject({\n        name: 'someString'\n      });\n      expect(res.body.data.attributes.field[1]).toMatchObject({\n        name: 'otherString'\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'otherString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.data.attributes.field)).toBe(true);\n      expect(updateRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(updateRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 288,
                "column": 56,
                "index": 7701
            },
            "line": 288,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when not enough items",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 331,
                "column": 38,
                "index": 8768
            },
            "line": 331,
            "code": "    test('Throws when not enough items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(res.body.data);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when too many items",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 363,
                "column": 36,
                "index": 9539
            },
            "line": 363,
            "code": "    test('Throws when too many items', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(res.body.data);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous components if sent without id",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 407,
                "column": 61,
                "index": 10633
            },
            "line": 407,
            "code": "    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      const oldIds = res.body.data.attributes.field.map(val => val.id);\n      updateRes.body.data.attributes.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 460,
                "column": 43,
                "index": 11962
            },
            "line": 460,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: 'invalid_id',\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component with ids, create new ones and removes old ones",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 488,
                "column": 74,
                "index": 12623
            },
            "line": 488,
            "code": "    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'two'\n            }, {\n              name: 'three'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: res.body.data.attributes.field[0].id,\n              // send old id to update the previous component\n              name: 'newOne'\n            }, {\n              name: 'newTwo'\n            }, {\n              id: res.body.data.attributes.field[2].id,\n              name: 'three'\n            }, {\n              name: 'four'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            id: res.body.data.attributes.field[0].id,\n            name: 'newOne'\n          }, {\n            name: 'newTwo'\n          }, {\n            id: res.body.data.attributes.field[2].id,\n            name: 'three'\n          }, {\n            name: 'four'\n          }]\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and Not required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 554,
                "column": 39,
                "index": 14331
            },
            "line": 554,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someOtherString'\n            }, {\n              name: 'otherSomeString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toMatchObject(res.body.data);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/repeatable-required-min-max.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 50,
                "column": 40,
                "index": 1179
            },
            "line": 50,
            "code": "    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      })]));\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating second entry",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 69,
                "column": 31,
                "index": 1679
            },
            "line": 69,
            "code": "    test('Creating second entry', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someValue'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n        id: expect.anything(),\n        name: 'someValue'\n      })]));\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an object %p",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "line": 88,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws if the field is not an object %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send an empty array",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 98,
                "column": 33,
                "index": 2472
            },
            "line": 98,
            "code": "    test('Can send an empty array', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual([]);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when component is not provided",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 112,
                "column": 47,
                "index": 2824
            },
            "line": 112,
            "code": "    test('Throws when component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Data is orderd in the order sent",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 125,
                "column": 42,
                "index": 3120
            },
            "line": 125,
            "code": "    test('Data is orderd in the order sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'firstString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'firstString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 154,
                "column": 60,
                "index": 3937
            },
            "line": 154,
            "code": "    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      res.body.data.forEach(entry => {\n        expect(Array.isArray(entry.attributes.field)).toBe(true);\n        if (entry.attributes.field.length === 0) return;\n        expect(entry.attributes.field).toEqual(expect.arrayContaining([expect.objectContaining({\n          name: expect.any(String)\n        })]));\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "line": 172,
            "code": "    test.each(['someString', 128219, false, {}, null])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates order at each request",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 211,
                "column": 39,
                "index": 5540
            },
            "line": 211,
            "code": "    test('Updates order at each request', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.body.data.attributes.field[0]).toMatchObject({\n        name: 'someString'\n      });\n      expect(res.body.data.attributes.field[1]).toMatchObject({\n        name: 'otherString'\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'otherString'\n            }, {\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(Array.isArray(updateRes.body.data.attributes.field)).toBe(true);\n      expect(updateRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(updateRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(Array.isArray(getRes.body.data.attributes.field)).toBe(true);\n      expect(getRes.body.data.attributes.field[0]).toMatchObject({\n        name: 'otherString'\n      });\n      expect(getRes.body.data.attributes.field[1]).toMatchObject({\n        name: 'someString'\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 268,
                "column": 56,
                "index": 7200
            },
            "line": 268,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'otherString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Removes previous components if empty array sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 311,
                "column": 57,
                "index": 8286
            },
            "line": 311,
            "code": "    test('Removes previous components if empty array sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: []\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectResult);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous components if sent without id",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 350,
                "column": 61,
                "index": 9264
            },
            "line": 350,
            "code": "    test('Replaces the previous components if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      const oldIds = res.body.data.attributes.field.map(val => val.id);\n      updateRes.body.data.attributes.field.forEach(val => {\n        expect(oldIds.includes(val.id)).toBe(false);\n      });\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            name: 'new String'\n          }]\n        }\n      });\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 403,
                "column": 43,
                "index": 10593
            },
            "line": 403,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: 'invalid_id',\n              name: 'new String'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component with ids, create new ones and removes old ones",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 431,
                "column": 74,
                "index": 11254
            },
            "line": 431,
            "code": "    test('Updates component with ids, create new ones and removes old ones', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'one'\n            }, {\n              name: 'two'\n            }, {\n              name: 'three'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: [{\n              id: res.body.data.attributes.field[0].id,\n              // send old id to update the previous component\n              name: 'newOne'\n            }, {\n              name: 'newTwo'\n            }, {\n              id: res.body.data.attributes.field[2].id,\n              name: 'three'\n            }, {\n              name: 'four'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: [{\n            id: res.body.data.attributes.field[0].id,\n            name: 'newOne'\n          }, {\n            name: 'newTwo'\n          }, {\n            id: res.body.data.attributes.field[2].id,\n            name: 'three'\n          }, {\n            name: 'four'\n          }]\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and Not required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 497,
                "column": 39,
                "index": 12962
            },
            "line": 497,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: [{\n              name: 'someString'\n            }, {\n              name: 'someOtherString'\n            }, {\n              name: 'otherSomeString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toMatchObject(res.body.data);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/repeatable-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 50,
                "column": 40,
                "index": 1181
            },
            "line": 50,
            "code": "    test('Creating entry with JSON works', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual(expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      }));\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating second entry ",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 69,
                "column": 32,
                "index": 1654
            },
            "line": 69,
            "code": "    test('Creating second entry ', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someValue'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toEqual(expect.objectContaining({\n        id: expect.anything(),\n        name: 'someValue'\n      }));\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an object %p",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "line": 88,
            "code": "    test.each([[], 'someString', 128219, false])('Throws if the field is not an object %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send a null value",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 98,
                "column": 31,
                "index": 2411
            },
            "line": 98,
            "code": "    test('Can send a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: null\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toBe(null);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can send input without the component field",
            "suites": [
                "Non repeatable and Not required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 112,
                "column": 52,
                "index": 2769
            },
            "line": 112,
            "code": "    test('Can send input without the component field', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(res.body.data.attributes.field).toBe(null);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and Not required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 126,
                "column": 60,
                "index": 3140
            },
            "line": 126,
            "code": "    test('Should return entries with their nested components', async () => {\n      const res = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      res.body.data.forEach(entry => {\n        if (entry.attributes.field === null) return;\n        expect(entry.attributes.field).toMatchObject({\n          name: expect.any(String)\n        });\n      });\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "line": 143,
            "code": "    test.each([[], 'someString', 128219, false])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 182,
                "column": 56,
                "index": 4637
            },
            "line": 182,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Removes previous component if null sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 223,
                "column": 49,
                "index": 5662
            },
            "line": 223,
            "code": "    test('Removes previous component if null sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: null\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: null\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectResult);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous component if sent without id",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 262,
                "column": 60,
                "index": 6641
            },
            "line": 262,
            "code": "    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              name: 'new String'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data.attributes.field.id).not.toBe(res.body.data.attributes.field.id);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            name: 'new String'\n          }\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            name: 'new String'\n          }\n        }\n      });\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 312,
                "column": 43,
                "index": 7866
            },
            "line": 312,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              id: 'invalid_id',\n              name: 'new String'\n            }\n          }\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component if previsous component id is sent",
            "suites": [
                "Non repeatable and Not required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 334,
                "column": 61,
                "index": 8400
            },
            "line": 334,
            "code": "    test('Updates component if previsous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              id: res.body.data.attributes.field.id,\n              // send old id to update the previous component\n              name: 'new String'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            id: res.body.data.attributes.field.id,\n            name: 'new String'\n          }\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and Not required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 382,
                "column": 39,
                "index": 9655
            },
            "line": 382,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body.data).toMatchObject(res.body.data);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/single-not-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating entry with JSON works",
            "suites": [
                "Non repeatable and required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 50,
                "column": 40,
                "index": 1176
            },
            "line": 50,
            "code": "    test('Creating entry with JSON works', async () => {\n      const {\n        statusCode,\n        body\n      } = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(statusCode).toBe(200);\n      expect(body.data.attributes.field).toEqual(expect.objectContaining({\n        id: expect.anything(),\n        name: 'someString'\n      }));\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Creating a second entry works",
            "suites": [
                "Non repeatable and required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 72,
                "column": 39,
                "index": 1687
            },
            "line": 72,
            "code": "    test('Creating a second entry works', async () => {\n      const {\n        statusCode,\n        body\n      } = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someValue'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(statusCode).toBe(200);\n      expect(body.data.attributes.field).toEqual(expect.objectContaining({\n        id: expect.anything(),\n        name: 'someValue'\n      }));\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if the field is not an object %p",
            "suites": [
                "Non repeatable and required component",
                "POST new entry"
            ],
            "line": 94,
            "code": "    test.each([[], 'someString', 128219, false])('Throws if the field is not an object %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending a null value",
            "suites": [
                "Non repeatable and required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 107,
                "column": 42,
                "index": 2541
            },
            "line": 107,
            "code": "    test('Throws when sending a null value', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: null\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when the component is not provided",
            "suites": [
                "Non repeatable and required component",
                "POST new entry"
            ],
            "updatePoint": {
                "line": 120,
                "column": 51,
                "index": 2841
            },
            "line": 120,
            "code": "    test('Throws when the component is not provided', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return entries with their nested components",
            "suites": [
                "Non repeatable and required component",
                "GET entries"
            ],
            "updatePoint": {
                "line": 133,
                "column": 60,
                "index": 3155
            },
            "line": 133,
            "code": "    test('Should return entries with their nested components', async () => {\n      const {\n        statusCode,\n        body\n      } = await rq.get('/', {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(statusCode).toBe(200);\n      expect(Array.isArray(body.data)).toBe(true);\n      body.data.forEach(entry => {\n        if (entry.attributes.field === null) return;\n        expect(entry.attributes.field).toMatchObject({\n          name: expect.any(String)\n        });\n      });\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws when sending invalid updated field %p",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "line": 153,
            "code": "    test.each([[], 'someString', 128219, false])('Throws when sending invalid updated field %p', async value => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: value\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n\n      // shouldn't have been updated\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(res.body.data);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Keeps the previous value if component not sent",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 187,
                "column": 56,
                "index": 4573
            },
            "line": 187,
            "code": "    test('Keeps the previous value if component not sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {}\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: res.body.data.attributes.field\n        }\n      });\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if component is null",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 228,
                "column": 37,
                "index": 5586
            },
            "line": 228,
            "code": "    test('Throws if component is null', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: null\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body).toMatchObject(res.body);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Replaces the previous component if sent without id",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 260,
                "column": 60,
                "index": 6371
            },
            "line": 260,
            "code": "    test('Replaces the previous component if sent without id', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              name: 'new String'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data.attributes.field.id).not.toBe(res.body.data.attributes.field.id);\n      expect(updateRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            name: 'new String'\n          }\n        }\n      });\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject({\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            name: 'new String'\n          }\n        }\n      });\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws on invalid id in component",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 310,
                "column": 43,
                "index": 7596
            },
            "line": 310,
            "code": "    test('Throws on invalid id in component', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              id: 'invalid_id',\n              name: 'new String'\n            }\n          }\n        }\n      });\n      expect(updateRes.statusCode).toBe(400);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Updates component if previous component id is sent",
            "suites": [
                "Non repeatable and required component",
                "PUT entry"
            ],
            "updatePoint": {
                "line": 335,
                "column": 60,
                "index": 8184
            },
            "line": 335,
            "code": "    test('Updates component if previous component id is sent', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const updateRes = await rq.put(`/${res.body.data.id}`, {\n        body: {\n          data: {\n            field: {\n              id: res.body.data.attributes.field.id,\n              // send old id to update the previous component\n              name: 'new String'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const expectedResult = {\n        id: res.body.data.id,\n        attributes: {\n          field: {\n            id: res.body.data.attributes.field.id,\n            name: 'new String'\n          }\n        }\n      };\n      expect(updateRes.statusCode).toBe(200);\n      expect(updateRes.body.data).toMatchObject(expectedResult);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(200);\n      expect(getRes.body.data).toMatchObject(expectedResult);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns entry with components",
            "suites": [
                "Non repeatable and required component",
                "DELETE entry"
            ],
            "updatePoint": {
                "line": 383,
                "column": 39,
                "index": 9439
            },
            "line": 383,
            "code": "    test('Returns entry with components', async () => {\n      const res = await rq.post('/', {\n        body: {\n          data: {\n            field: {\n              name: 'someString'\n            }\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      const deleteRes = await rq.delete(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(deleteRes.statusCode).toBe(200);\n      expect(deleteRes.body).toMatchObject(res.body);\n      const getRes = await rq.get(`/${res.body.data.id}`, {\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(getRes.statusCode).toBe(404);\n    });",
            "file": "components/single-required.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return 2 results",
            "suites": [
                "Deep Filtering API",
                "Without search",
                "Filter on a manyWay relation"
            ],
            "updatePoint": {
                "line": 103,
                "column": 35,
                "index": 2333
            },
            "line": 103,
            "code": "      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              cards: {\n                name: data.card[0].attributes.name\n              }\n            }\n          }\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 2\n        });\n        expect(res.body.data.length).toBe(2);\n        expect(res.body.data[0]).toMatchObject(data.collector[0]);\n        expect(res.body.data[1]).toMatchObject(data.collector[1]);\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return 1 result",
            "suites": [
                "Deep Filtering API",
                "Without search",
                "Filter on a manyWay relation"
            ],
            "updatePoint": {
                "line": 124,
                "column": 34,
                "index": 2997
            },
            "line": 124,
            "code": "      test('Should return 1 result', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              cards: {\n                name: data.card[1].attributes.name\n              }\n            }\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 1\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.collector[0]);\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "should return 2 results when deep filtering with $or",
            "suites": [
                "Deep Filtering API",
                "Without search",
                "Filter on a manyWay relation"
            ],
            "updatePoint": {
                "line": 144,
                "column": 64,
                "index": 3624
            },
            "line": 144,
            "code": "      test('should return 2 results when deep filtering with $or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              $or: [{\n                cards: {\n                  name: data.card[0].attributes.name\n                }\n              }, {\n                cards: {\n                  name: data.card[1].attributes.name\n                }\n              }]\n            }\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 2\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(2);\n        expect(res.body.data).toEqual(expect.arrayContaining([expect.objectContaining(data.collector[0]), expect.objectContaining(data.collector[1])]));\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return 2 results",
            "suites": [
                "Deep Filtering API",
                "Without search",
                "Filter on a self manyWay relation"
            ],
            "updatePoint": {
                "line": 172,
                "column": 35,
                "index": 4534
            },
            "line": 172,
            "code": "      test('Should return 2 results', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              collector_friends: {\n                name: data.collector[0].attributes.name\n              }\n            }\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 2\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(2);\n        expect(res.body.data).toEqual(expect.arrayContaining(data.collector.slice(1, 3)));\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "cards.name + empty search",
            "suites": [
                "Deep Filtering API",
                "With search",
                "Filter on a manyWay relation"
            ],
            "updatePoint": {
                "line": 196,
                "column": 37,
                "index": 5276
            },
            "line": 196,
            "code": "      test('cards.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              cards: {\n                name: data.card[0].attributes.name\n              }\n            },\n            _q: ''\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 2\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(2);\n        expect(res.body.data).toEqual(expect.arrayContaining(data.collector.slice(0, 2)));\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "cards.name + _q=25",
            "suites": [
                "Deep Filtering API",
                "With search",
                "Filter on a manyWay relation"
            ],
            "updatePoint": {
                "line": 217,
                "column": 30,
                "index": 5913
            },
            "line": 217,
            "code": "      test('cards.name + _q=25', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              cards: {\n                name: data.card[0].attributes.name\n              }\n            },\n            _q: 25\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 1\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.collector[0]);\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "collector_friends.name + empty search",
            "suites": [
                "Deep Filtering API",
                "With search",
                "Filter on a self manyWay relation"
            ],
            "updatePoint": {
                "line": 240,
                "column": 49,
                "index": 6611
            },
            "line": 240,
            "code": "      test('collector_friends.name + empty search', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              collector_friends: {\n                name: data.collector[0].attributes.name\n              }\n            },\n            _q: ''\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 2\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(2);\n        expect(res.body.data).toEqual(expect.arrayContaining(data.collector.slice(1, 3)));\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "collector_friends.name + search isa",
            "suites": [
                "Deep Filtering API",
                "With search",
                "Filter on a self manyWay relation"
            ],
            "updatePoint": {
                "line": 261,
                "column": 47,
                "index": 7282
            },
            "line": 261,
            "code": "      test('collector_friends.name + search isa', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/collectors',\n          qs: {\n            filters: {\n              collector_friends: {\n                name: data.collector[0].attributes.name\n              }\n            },\n            _q: 'isa'\n          }\n        });\n        expect(res.body.meta.pagination).toMatchObject({\n          ...pagination,\n          total: 1\n        });\n        expect(Array.isArray(res.body.data)).toBe(true);\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.collector[1]);\n      });",
            "file": "deepFiltering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can create an entry with a dynamic zone and a nested compo",
            "suites": [
                "Not required dynamiczone",
                "Creation"
            ],
            "updatePoint": {
                "line": 93,
                "column": 68,
                "index": 1991
            },
            "line": 93,
            "code": "    test('Can create an entry with a dynamic zone and a nested compo', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.simple-compo',\n              name: 'someString'\n            }, {\n              __component: 'default.compo-with-other-compo',\n              compo: {\n                name: 'someString'\n              }\n            }]\n          }\n        },\n        qs: {\n          populate: ['field.compo']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString'\n          }, {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString'\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can create entry with empty dynamiczone if it is not required",
            "suites": [
                "Not required dynamiczone",
                "Creation"
            ],
            "updatePoint": {
                "line": 133,
                "column": 71,
                "index": 3118
            },
            "line": 133,
            "code": "    test('Can create entry with empty dynamiczone if it is not required', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field.length).toBe(0);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throw if min items is not respected",
            "suites": [
                "Not required dynamiczone",
                "Creation"
            ],
            "updatePoint": {
                "line": 150,
                "column": 45,
                "index": 3575
            },
            "line": 150,
            "code": "    test('Throw if min items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.simple-compo',\n              name: 'someString'\n            }]\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Throws if max items is not respected",
            "suites": [
                "Not required dynamiczone",
                "Creation"
            ],
            "updatePoint": {
                "line": 165,
                "column": 46,
                "index": 3944
            },
            "line": 165,
            "code": "    test('Throws if max items is not respected', async () => {\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: Array(10).fill({\n              __component: 'default.simple-compo',\n              name: 'someString'\n            })\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The entry has its dynamic zone populated",
            "suites": [
                "Not required dynamiczone",
                "Getting one entry"
            ],
            "updatePoint": {
                "line": 182,
                "column": 50,
                "index": 4377
            },
            "line": 182,
            "code": "    test('The entry has its dynamic zone populated', async () => {\n      const createRes = await createEntry();\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'GET',\n        url: `/${entryId}`,\n        qs: {\n          populate: ['field.compo']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString'\n          }, {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString'\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The entries have their dynamic zones populated",
            "suites": [
                "Not required dynamiczone",
                "Listing entries"
            ],
            "updatePoint": {
                "line": 213,
                "column": 56,
                "index": 5303
            },
            "line": 213,
            "code": "    test('The entries have their dynamic zones populated', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/',\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data)).toBe(true);\n      expect(res.body.data).toEqual(expect.arrayContaining([expect.objectContaining({\n        attributes: expect.objectContaining({\n          field: expect.arrayContaining([expect.objectContaining({\n            id: expect.anything(),\n            __component: expect.any(String)\n          })])\n        })\n      })]));\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can empty non required dynamic zone",
            "suites": [
                "Not required dynamiczone",
                "Edition"
            ],
            "updatePoint": {
                "line": 234,
                "column": 45,
                "index": 5955
            },
            "line": 234,
            "code": "    test('Can empty non required dynamic zone', async () => {\n      const createRes = await createEntry();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          data: {\n            field: []\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data.attributes.field).toEqual([]);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can add items to empty dynamic zone",
            "suites": [
                "Not required dynamiczone",
                "Edition"
            ],
            "updatePoint": {
                "line": 254,
                "column": 45,
                "index": 6555
            },
            "line": 254,
            "code": "    test('Can add items to empty dynamic zone', async () => {\n      const createRes = await createEmpty();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          data: defaultBody\n        },\n        qs: {\n          populate: ['field.compo']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'someString'\n          }, {\n            id: expect.anything(),\n            __component: 'default.compo-with-other-compo',\n            compo: {\n              id: expect.anything(),\n              name: 'someString'\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can remove items from dynamic zone",
            "suites": [
                "Not required dynamiczone",
                "Edition"
            ],
            "updatePoint": {
                "line": 287,
                "column": 44,
                "index": 7526
            },
            "line": 287,
            "code": "    test('Can remove items from dynamic zone', async () => {\n      const createRes = await createEntry();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          data: {\n            field: [{\n              __component: 'default.simple-compo',\n              name: 'otherString'\n            }, {\n              __component: 'default.simple-compo',\n              name: 'secondString'\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'otherString'\n          }, {\n            id: expect.anything(),\n            __component: 'default.simple-compo',\n            name: 'secondString'\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Respects min items",
            "suites": [
                "Not required dynamiczone",
                "Edition"
            ],
            "updatePoint": {
                "line": 325,
                "column": 28,
                "index": 8621
            },
            "line": 325,
            "code": "    test('Respects min items', async () => {\n      const createRes = await createEntry();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          data: {\n            field: [{\n              __component: 'default.simple-compo',\n              name: 'otherString'\n            }]\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Respects max items",
            "suites": [
                "Not required dynamiczone",
                "Edition"
            ],
            "updatePoint": {
                "line": 343,
                "column": 28,
                "index": 9119
            },
            "line": 343,
            "code": "    test('Respects max items', async () => {\n      const createRes = await createEntry();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'PUT',\n        url: `/${entryId}`,\n        body: {\n          data: {\n            field: Array(10).fill({\n              __component: 'default.simple-compo',\n              name: 'otherString'\n            })\n          }\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Returns the entry with its paths populated",
            "suites": [
                "Not required dynamiczone",
                "Deletion"
            ],
            "updatePoint": {
                "line": 363,
                "column": 52,
                "index": 9692
            },
            "line": 363,
            "code": "    test('Returns the entry with its paths populated', async () => {\n      const createRes = await createEntry();\n      expect(createRes.statusCode).toBe(200);\n      const entryId = createRes.body.data.id;\n      const res = await rq({\n        method: 'DELETE',\n        url: `/${entryId}`,\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toEqual(expect.objectContaining({\n        attributes: expect.objectContaining({\n          field: expect.arrayContaining([expect.objectContaining({\n            id: expect.anything(),\n            __component: expect.any(String)\n          })])\n        })\n      }));\n    });",
            "file": "dynamiczones/simple.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The medias are correctly related to the components on creation",
            "suites": [
                "Not required dynamiczone",
                "Contains components with medias"
            ],
            "updatePoint": {
                "line": 87,
                "column": 72,
                "index": 2091
            },
            "line": 87,
            "code": "    test('The medias are correctly related to the components on creation', async () => {\n      const imgRes = await uploadImg();\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.one-media',\n              media: mediaId\n            }, {\n              __component: 'default.many-media',\n              media: [mediaId, mediaId]\n            }]\n          }\n        },\n        qs: {\n          populate: ['field.media']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.one-media',\n            media: {\n              data: {\n                id: mediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              }\n            }\n          }, {\n            id: expect.anything(),\n            __component: 'default.many-media',\n            media: {\n              data: expect.arrayContaining([expect.objectContaining({\n                id: mediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              })])\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/with-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The medias are correctly related to the components on edition",
            "suites": [
                "Not required dynamiczone",
                "Contains components with medias"
            ],
            "updatePoint": {
                "line": 139,
                "column": 71,
                "index": 3623
            },
            "line": 139,
            "code": "    test('The medias are correctly related to the components on edition', async () => {\n      const imgRes = await uploadImg();\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.one-media',\n              media: mediaId\n            }, {\n              __component: 'default.many-media',\n              media: [mediaId, mediaId]\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      const newImgRes = await uploadImg();\n      expect(newImgRes.statusCode).toBe(200);\n      const newMediaId = newImgRes.body[0].id;\n      const updateRes = await rq({\n        method: 'PUT',\n        url: `/${res.body.data.id}`,\n        body: {\n          data: {\n            field: [{\n              __component: 'default.one-media',\n              media: newMediaId\n            }, {\n              __component: 'default.many-media',\n              media: [newMediaId, newMediaId]\n            }]\n          }\n        },\n        qs: {\n          populate: ['field.media']\n        }\n      });\n      expect(updateRes.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.one-media',\n            media: {\n              data: {\n                id: newMediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              }\n            }\n          }, {\n            id: expect.anything(),\n            __component: 'default.many-media',\n            media: {\n              data: expect.arrayContaining([expect.objectContaining({\n                id: newMediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              })])\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/with-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The media are populated on the components",
            "suites": [
                "Not required dynamiczone",
                "Contains components with medias"
            ],
            "updatePoint": {
                "line": 212,
                "column": 51,
                "index": 5728
            },
            "line": 212,
            "code": "    test('The media are populated on the components', async () => {\n      const imgRes = await uploadImg();\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.one-media',\n              media: mediaId\n            }, {\n              __component: 'default.many-media',\n              media: [mediaId, mediaId]\n            }]\n          }\n        },\n        qs: {\n          populate: ['field']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      const getRes = await rq({\n        method: 'GET',\n        url: `/${res.body.data.id}`,\n        qs: {\n          populate: ['field.media']\n        }\n      });\n      expect(getRes.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.one-media',\n            media: {\n              data: {\n                id: mediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              }\n            }\n          }, {\n            id: expect.anything(),\n            __component: 'default.many-media',\n            media: {\n              data: expect.arrayContaining([expect.objectContaining({\n                id: mediaId,\n                attributes: expect.objectContaining({\n                  url: expect.any(String)\n                })\n              })])\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/with-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "The medias are correctly related to the nested components on creation",
            "suites": [
                "Not required dynamiczone",
                "Contains components with nested components having medias"
            ],
            "updatePoint": {
                "line": 272,
                "column": 79,
                "index": 7440
            },
            "line": 272,
            "code": "    test('The medias are correctly related to the nested components on creation', async () => {\n      const imgRes = await uploadImg();\n      expect(imgRes.statusCode).toBe(200);\n      const mediaId = imgRes.body[0].id;\n      const res = await rq({\n        method: 'POST',\n        url: '/',\n        body: {\n          data: {\n            field: [{\n              __component: 'default.with-nested',\n              singleMedia: {\n                media: mediaId\n              },\n              multipleMedia: {\n                media: [mediaId, mediaId]\n              }\n            }]\n          }\n        },\n        qs: {\n          populate: ['field.singleMedia.media', 'field.multipleMedia.media']\n        }\n      });\n      expect(res.statusCode).toBe(200);\n      expect(Array.isArray(res.body.data.attributes.field)).toBe(true);\n      expect(res.body.data).toMatchObject({\n        attributes: {\n          field: [{\n            id: expect.anything(),\n            __component: 'default.with-nested',\n            singleMedia: {\n              media: {\n                data: {\n                  id: mediaId,\n                  attributes: expect.objectContaining({\n                    url: expect.any(String)\n                  })\n                }\n              }\n            },\n            multipleMedia: {\n              media: {\n                data: expect.arrayContaining([expect.objectContaining({\n                  id: mediaId,\n                  attributes: expect.objectContaining({\n                    url: expect.any(String)\n                  })\n                })])\n              }\n            }\n          }]\n        }\n      });\n    });",
            "file": "dynamiczones/with-media.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create tag1",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 44,
                "column": 21,
                "index": 1162
            },
            "line": 44,
            "code": "    test('Create tag1', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag1'\n          }\n        }\n      });\n      data.tags.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('tag1');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create tag2",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 60,
                "column": 21,
                "index": 1522
            },
            "line": 60,
            "code": "    test('Create tag2', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag2'\n          }\n        }\n      });\n      data.tags.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('tag2');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create tag3",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 76,
                "column": 21,
                "index": 1882
            },
            "line": 76,
            "code": "    test('Create tag3', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag3'\n          }\n        }\n      });\n      data.tags.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('tag3');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article1 without relation",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 92,
                "column": 42,
                "index": 2263
            },
            "line": 92,
            "code": "    test('Create article1 without relation', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'My super content 1'\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article2 with tag1",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 111,
                "column": 35,
                "index": 2779
            },
            "line": 111,
            "code": "    test('Create article2 with tag1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        tags: [data.tags[0].id]\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(Array.isArray(body.data.attributes.tags.data)).toBeTruthy();\n      expect(body.data.attributes.tags.data.length).toBe(1);\n      expect(body.data.attributes.tags.data[0].id).toBe(data.tags[0].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article with non existent tag",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 137,
                "column": 46,
                "index": 3593
            },
            "line": 137,
            "code": "    test('Create article with non existent tag', async () => {\n      const entry = {\n        title: 'Article 3',\n        content: 'Content 3',\n        tags: [1000]\n      };\n      const res = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(JSON.parse(res.error.text).error.message).toContain(`1 relation(s) of type api::tag.tag associated with this entity do not exist`);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 add tag2",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 156,
                "column": 34,
                "index": 4138
            },
            "line": 156,
            "code": "    test('Update article1 add tag2', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes,\n        tags: [data.tags[1].id]\n      };\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(Array.isArray(body.data.attributes.tags.data)).toBeTruthy();\n      expect(body.data.attributes.tags.data.length).toBe(1);\n      expect(body.data.attributes.tags.data[0].id).toBe(data.tags[1].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 add tag1 and tag3",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 186,
                "column": 43,
                "index": 5015
            },
            "line": 186,
            "code": "    test('Update article1 add tag1 and tag3', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes\n      };\n      entry.tags = data.tags.map(t => t.id);\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(Array.isArray(body.data.attributes.tags.data)).toBeTruthy();\n      expect(body.data.attributes.tags.data.length).toBe(3);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Error when updating article1 with some non existent tags",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 215,
                "column": 66,
                "index": 5853
            },
            "line": 215,
            "code": "    test('Error when updating article1 with some non existent tags', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes\n      };\n      entry.tags = [1000, 1001, 1002, ...data.tags.slice(-1).map(t => t.id)];\n      cleanDate(entry);\n      const res = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      expect(res.statusCode).toBe(400);\n      expect(JSON.parse(res.error.text).error.message).toContain(`3 relation(s) of type api::tag.tag associated with this entity do not exist`);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 remove one tag",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 238,
                "column": 40,
                "index": 6527
            },
            "line": 238,
            "code": "    test('Update article1 remove one tag', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes\n      };\n      entry.tags = entry.tags.data.slice(1).map(t => t.id);\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(Array.isArray(body.data.attributes.tags.data)).toBeTruthy();\n      expect(body.data.attributes.tags.data.length).toBe(2);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 remove all tag",
            "suites": [
                "Create Strapi API End to End",
                "Test manyToMany relation (article - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 267,
                "column": 40,
                "index": 7354
            },
            "line": 267,
            "code": "    test('Update article1 remove all tag', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes,\n        tags: []\n      };\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['tags']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(Array.isArray(body.data.attributes.tags.data)).toBeTruthy();\n      expect(body.data.attributes.tags.data.length).toBe(0);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create cat1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 309,
                "column": 21,
                "index": 8464
            },
            "line": 309,
            "code": "    test('Create cat1', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'cat1'\n          }\n        },\n        qs: {\n          populate: ['articles']\n        }\n      });\n      data.categories.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('cat1');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create cat2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 328,
                "column": 21,
                "index": 8894
            },
            "line": 328,
            "code": "    test('Create cat2', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'cat2'\n          }\n        },\n        qs: {\n          populate: ['articles']\n        }\n      });\n      data.categories.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('cat2');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article1 with cat1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 347,
                "column": 35,
                "index": 9338
            },
            "line": 347,
            "code": "    test('Create article1 with cat1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1',\n        category: data.categories[0].id\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['category']\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(body.data.attributes.category.data.attributes.name).toBe(data.categories[0].attributes.name);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 with cat2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 371,
                "column": 35,
                "index": 10051
            },
            "line": 371,
            "code": "    test('Update article1 with cat2', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes,\n        category: data.categories[1].id\n      };\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['category']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(body.data.attributes.category.data.attributes.name).toBe(data.categories[1].attributes.name);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 399,
                "column": 25,
                "index": 10820
            },
            "line": 399,
            "code": "    test('Create article2', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2'\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article2 with cat2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 418,
                "column": 35,
                "index": 11327
            },
            "line": 418,
            "code": "    test('Update article2 with cat2', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[1];\n      const entry = {\n        ...attributes,\n        category: data.categories[1].id\n      };\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['category']\n        }\n      });\n      data.articles[1] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(body.data.attributes.category.data.attributes.name).toBe(data.categories[1].attributes.name);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update cat1 with article1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 446,
                "column": 35,
                "index": 12106
            },
            "line": 446,
            "code": "    test('Update cat1 with article1', async () => {\n      const {\n        id,\n        attributes\n      } = data.categories[0];\n      const entry = {\n        ...attributes\n      };\n      entry.articles = data.categories[0].attributes.articles.data.map(a => a.id).concat(data.articles[0].id);\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/categories/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['articles']\n        }\n      });\n      data.categories[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(Array.isArray(body.data.attributes.articles.data)).toBeTruthy();\n      expect(body.data.attributes.articles.data.length).toBe(1);\n      expect(body.data.attributes.name).toBe(entry.name);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create cat3 with article1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 474,
                "column": 35,
                "index": 12931
            },
            "line": 474,
            "code": "    test('Create cat3 with article1', async () => {\n      const entry = {\n        name: 'cat3',\n        articles: [data.articles[0].id]\n      };\n      const {\n        body\n      } = await rq({\n        url: '/categories',\n        method: 'POST',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['articles']\n        }\n      });\n      data.categories.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(Array.isArray(body.data.attributes.articles.data)).toBeTruthy();\n      expect(body.data.attributes.articles.data.length).toBe(1);\n      expect(body.data.attributes.name).toBe(entry.name);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Get article1 with cat3",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 497,
                "column": 32,
                "index": 13579
            },
            "line": 497,
            "code": "    test('Get article1 with cat3', async () => {\n      const {\n        body\n      } = await rq({\n        url: `/articles/${data.articles[0].id}`,\n        method: 'GET',\n        qs: {\n          populate: ['category']\n        }\n      });\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.category.data.id).toBe(data.categories[2].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Get article2 with cat2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 510,
                "column": 32,
                "index": 13946
            },
            "line": 510,
            "code": "    test('Get article2 with cat2', async () => {\n      const {\n        body\n      } = await rq({\n        url: `/articles/${data.articles[1].id}`,\n        method: 'GET',\n        qs: {\n          populate: ['category']\n        }\n      });\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.category.data.id).toBe(data.categories[1].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Get cat1 without relations",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 523,
                "column": 36,
                "index": 14317
            },
            "line": 523,
            "code": "    test('Get cat1 without relations', async () => {\n      const {\n        body\n      } = await rq({\n        url: `/categories/${data.categories[0].id}`,\n        method: 'GET',\n        qs: {\n          populate: ['articles']\n        }\n      });\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.articles.data.length).toBe(0);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Get cat2 with article2",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 536,
                "column": 32,
                "index": 14672
            },
            "line": 536,
            "code": "    test('Get cat2 with article2', async () => {\n      const {\n        body\n      } = await rq({\n        url: `/categories/${data.categories[1].id}`,\n        method: 'GET',\n        qs: {\n          populate: ['articles']\n        }\n      });\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.articles.data.length).toBe(1);\n      expect(body.data.attributes.articles.data[0].id).toBe(data.articles[1].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Get cat3 with article1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToMany - manyToOne relation (article - category) with Content Manager"
            ],
            "updatePoint": {
                "line": 550,
                "column": 32,
                "index": 15109
            },
            "line": 550,
            "code": "    test('Get cat3 with article1', async () => {\n      const {\n        body\n      } = await rq({\n        url: `/categories/${data.categories[2].id}`,\n        method: 'GET',\n        qs: {\n          populate: ['articles']\n        }\n      });\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.articles.data.length).toBe(1);\n      expect(body.data.attributes.articles.data[0].id).toBe(data.articles[0].id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create ref1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToOne relation (article - reference) with Content Manager"
            ],
            "updatePoint": {
                "line": 577,
                "column": 21,
                "index": 15868
            },
            "line": 577,
            "code": "    test('Create ref1', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'ref1'\n          }\n        }\n      });\n      data.references.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.name).toBe('ref1');\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToOne relation (article - reference) with Content Manager"
            ],
            "updatePoint": {
                "line": 593,
                "column": 25,
                "index": 16244
            },
            "line": 593,
            "code": "    test('Create article1', async () => {\n      const entry = {\n        title: 'Article 1',\n        content: 'Content 1'\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update article1 with ref1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToOne relation (article - reference) with Content Manager"
            ],
            "updatePoint": {
                "line": 612,
                "column": 35,
                "index": 16751
            },
            "line": 612,
            "code": "    test('Update article1 with ref1', async () => {\n      const {\n        id,\n        attributes\n      } = data.articles[0];\n      const entry = {\n        ...attributes,\n        reference: data.references[0].id\n      };\n      cleanDate(entry);\n      const {\n        body\n      } = await rq({\n        url: `/articles/${id}`,\n        method: 'PUT',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['reference']\n        }\n      });\n      data.articles[0] = body.data;\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(body.data.attributes.reference.data.id).toBe(entry.reference);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create article2 with ref1",
            "suites": [
                "Create Strapi API End to End",
                "Test oneToOne relation (article - reference) with Content Manager"
            ],
            "updatePoint": {
                "line": 640,
                "column": 35,
                "index": 17501
            },
            "line": 640,
            "code": "    test('Create article2 with ref1', async () => {\n      const entry = {\n        title: 'Article 2',\n        content: 'Content 2',\n        reference: data.references[0].id\n      };\n      const {\n        body\n      } = await rq({\n        url: '/articles',\n        method: 'POST',\n        body: {\n          data: entry\n        },\n        qs: {\n          populate: ['reference']\n        }\n      });\n      data.articles.push(body.data);\n      expect(body.data.id).toBeDefined();\n      expect(body.data.attributes.title).toBe(entry.title);\n      expect(body.data.attributes.content).toBe(entry.content);\n      expect(body.data.attributes.reference.data.id).toBe(entry.reference);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Attach Tag to a Reference",
            "suites": [
                "Create Strapi API End to End",
                "Test oneWay relation (reference - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 677,
                "column": 35,
                "index": 18504
            },
            "line": 677,
            "code": "    test('Attach Tag to a Reference', async () => {\n      const {\n        body: {\n          data: createdTag\n        }\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag111'\n          }\n        }\n      });\n      data.tags.push(createdTag);\n      const {\n        body: {\n          data: createdReference\n        }\n      } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'cat111',\n            tag: createdTag.id\n          }\n        },\n        qs: {\n          populate: ['tag']\n        }\n      });\n      data.references.push(createdReference);\n      expect(createdReference.attributes.tag.data.id).toBe(createdTag.id);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Detach Tag from a Reference",
            "suites": [
                "Create Strapi API End to End",
                "Test oneWay relation (reference - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 712,
                "column": 37,
                "index": 19272
            },
            "line": 712,
            "code": "    test('Detach Tag from a Reference', async () => {\n      const {\n        body: {\n          data: createdTag\n        }\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag111'\n          }\n        }\n      });\n      data.tags.push(createdTag);\n      const {\n        body: {\n          data: createdReference\n        }\n      } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'cat111',\n            tag: createdTag.id\n          }\n        },\n        qs: {\n          populate: ['tag']\n        }\n      });\n      data.references.push(createdReference);\n      expect(createdReference.attributes.tag.data.id).toBe(createdTag.id);\n      const {\n        body: {\n          data: updatedReference\n        }\n      } = await rq({\n        url: `/references/${createdReference.id}`,\n        method: 'PUT',\n        body: {\n          data: {\n            tag: null\n          }\n        },\n        qs: {\n          populate: ['tag']\n        }\n      });\n      expect(updatedReference.attributes.tag.data).toBe(null);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete Tag so the relation in the Reference side should be removed",
            "suites": [
                "Create Strapi API End to End",
                "Test oneWay relation (reference - tag) with Content Manager"
            ],
            "updatePoint": {
                "line": 764,
                "column": 76,
                "index": 20451
            },
            "line": 764,
            "code": "    test('Delete Tag so the relation in the Reference side should be removed', async () => {\n      const {\n        body: {\n          data: createdTag\n        }\n      } = await rq({\n        url: '/tags',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'tag111'\n          }\n        }\n      });\n      data.tags.push(createdTag);\n      const {\n        body: {\n          data: createdReference\n        }\n      } = await rq({\n        url: '/references',\n        method: 'POST',\n        body: {\n          data: {\n            name: 'cat111',\n            tag: createdTag.id\n          }\n        },\n        qs: {\n          populate: ['tag']\n        }\n      });\n      data.references.push(createdReference);\n      await rq({\n        url: `/tags/${createdTag.id}`,\n        method: 'DELETE'\n      });\n      const {\n        body: {\n          data: foundReference\n        }\n      } = await rq({\n        url: `/references/${createdReference.id}`,\n        method: 'GET',\n        qs: {\n          populate: ['tag']\n        }\n      });\n      expect(foundReference.attributes.tag.data).toBe(null);\n    });",
            "file": "endpoint.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should be the default filter",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter equals"
            ],
            "updatePoint": {
                "line": 110,
                "column": 40,
                "index": 2516
            },
            "line": 110,
            "code": "      test('Should be the default filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: 'Product 1'\n            }\n          }\n        });\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.product[0]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should be usable with equal suffix",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter equals"
            ],
            "updatePoint": {
                "line": 123,
                "column": 46,
                "index": 2893
            },
            "line": 123,
            "code": "      test('Should be usable with equal suffix', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $eq: 'Product 1'\n              }\n            }\n          }\n        });\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.product[0]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array when no match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter equals"
            ],
            "updatePoint": {
                "line": 138,
                "column": 54,
                "index": 3317
            },
            "line": 138,
            "code": "      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $eq: 'Product non existant'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should be usable with eqi suffix",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter equals with case insensitive"
            ],
            "updatePoint": {
                "line": 154,
                "column": 44,
                "index": 3742
            },
            "line": 154,
            "code": "      test('Should be usable with eqi suffix', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $eqi: 'PRODuct 1'\n              }\n            }\n          }\n        });\n        expect(res.body.data.length).toBe(1);\n        expect(res.body.data[0]).toMatchObject(data.product[0]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array when no match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter equals with case insensitive"
            ],
            "updatePoint": {
                "line": 169,
                "column": 54,
                "index": 4167
            },
            "line": 169,
            "code": "      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $eqi: 'Product non existant'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an array with matching entities",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not equals"
            ],
            "updatePoint": {
                "line": 185,
                "column": 57,
                "index": 4588
            },
            "line": 185,
            "code": "      test('Should return an array with matching entities', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $ne: 'Non existent product '\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining(data.product.map(o => expect.objectContaining(o))));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array when no match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not equals"
            ],
            "updatePoint": {
                "line": 199,
                "column": 54,
                "index": 5027
            },
            "line": 199,
            "code": "      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $ne: 'Product 1'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return only matching items (%s)",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter null"
            ],
            "line": 215,
            "code": "      test.each([[{\n        $null: true\n      }], [{\n        $null: 'true'\n      }], [{\n        $null: '1'\n      }], [{\n        $null: 't'\n      }], [{\n        $null: 'anything'\n      }], [{\n        $null: ['anything']\n      }], [{\n        $null: {\n          anything: 'anything'\n        }\n      }], [{\n        $notNull: false\n      }], [{\n        $notNull: 'false'\n      }], [{\n        $notNull: '0'\n      }], [{\n        $notNull: 'f'\n      }], [{\n        $notNull: ''\n      }]])('Should return only matching items (%s)', async priceFilter => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: priceFilter\n            }\n          }\n        });\n        const matching = data.product.filter(x => x.attributes.price === null);\n        res.body.data.sort((a, b) => a.id > b.id ? 1 : -1);\n        expect(res.body.data.length).toBe(matching.length);\n        expect(res.body.data).toEqual(expect.arrayContaining(matching));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return three matches (%s)",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter null"
            ],
            "line": 256,
            "code": "      test.each([[{\n        $notNull: true\n      }], [{\n        $notNull: 'true'\n      }], [{\n        $notNull: '1'\n      }], [{\n        $notNull: 't'\n      }], [{\n        $notNull: 'anything'\n      }], [{\n        $notNull: ['anything']\n      }], [{\n        $notNull: {\n          anything: 'anything'\n        }\n      }], [{\n        $null: false\n      }], [{\n        $null: 'false'\n      }], [{\n        $null: '0'\n      }], [{\n        $null: 'f'\n      }], [{\n        $null: ''\n      }]])('Should return three matches (%s)', async priceFilter => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: priceFilter\n            }\n          }\n        });\n        expect(res.body.data.length).toBe(3);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should match with insensitive case",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter contains insensitive"
            ],
            "updatePoint": {
                "line": 296,
                "column": 46,
                "index": 7341
            },
            "line": 296,
            "code": "      test('Should match with insensitive case', async () => {\n        const res1 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $containsi: 'product'\n              }\n            }\n          }\n        });\n        expect(res1.body.data).toEqual(expect.arrayContaining(data.product.map(o => expect.objectContaining(o))));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $containsi: 'PrOdUct'\n              }\n            }\n          }\n        });\n        expect(res1.body.data).toEqual(res2.body.data);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array on no insensitive case match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter contains insensitive"
            ],
            "updatePoint": {
                "line": 322,
                "column": 69,
                "index": 8084
            },
            "line": 322,
            "code": "      test('Should return an empty array on no insensitive case match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $containsi: 'production'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $containsi: 'ProdUctIon'\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(res.body.data);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an array of entities on match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not contains insensitive"
            ],
            "updatePoint": {
                "line": 350,
                "column": 55,
                "index": 8809
            },
            "line": 350,
            "code": "      test('Should return an array of entities on match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $notContainsi: 'production'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining(data.product.map(o => expect.objectContaining(o))));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $notContainsi: 'ProdUctIon'\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(res.body.data);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array when no match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not contains insensitive"
            ],
            "updatePoint": {
                "line": 376,
                "column": 54,
                "index": 9546
            },
            "line": 376,
            "code": "      test('Should return an empty array when no match', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $notContainsi: 'product'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $notContainsi: 'ProDuCt'\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(res.body.data);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return empty if the case does not match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter contains sensitive"
            ],
            "line": 406,
            "code": "      test.skip('Should return empty if the case does not match', async () => {",
            "file": "filtering.test.api.js",
            "skipped": true,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return the entities if the case matches",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter contains sensitive"
            ],
            "updatePoint": {
                "line": 420,
                "column": 58,
                "index": 10749
            },
            "line": 420,
            "code": "      test('Should return the entities if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $contains: 'Product'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return the entities if the case does not match",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not contains sensitive"
            ],
            "line": 438,
            "code": "      test.skip('Should return the entities if the case does not match', async () => {",
            "file": "filtering.test.api.js",
            "skipped": true,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an empty array if the case matches",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not contains sensitive"
            ],
            "updatePoint": {
                "line": 452,
                "column": 60,
                "index": 11743
            },
            "line": 452,
            "code": "      test('Should return an empty array if the case matches', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              name: {\n                $notContains: 'Product'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return the Product with a single value",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter in"
            ],
            "updatePoint": {
                "line": 468,
                "column": 57,
                "index": 12151
            },
            "line": 468,
            "code": "      test('Should return the Product with a single value', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $in: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return the Product with an array of values",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter in"
            ],
            "updatePoint": {
                "line": 482,
                "column": 61,
                "index": 12544
            },
            "line": 482,
            "code": "      test('Should return the Product with an array of values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $in: [42, 12]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return a, empty array if no values are matching",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter in"
            ],
            "updatePoint": {
                "line": 496,
                "column": 66,
                "index": 12948
            },
            "line": 496,
            "code": "      test('Should return a, empty array if no values are matching', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $in: [43, 12]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual([]);\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an array without the values matching when a single value is provided",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not in"
            ],
            "updatePoint": {
                "line": 512,
                "column": 94,
                "index": 13387
            },
            "line": 512,
            "code": "      test('Should return an array without the values matching when a single value is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $notIn: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an array without the values matching when an array of values is provided",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not in"
            ],
            "updatePoint": {
                "line": 526,
                "column": 98,
                "index": 13824
            },
            "line": 526,
            "code": "      test('Should return an array without the values matching when an array of values is provided', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $notIn: [42, 12]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should return an array with values that do not match the filter",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter not in"
            ],
            "updatePoint": {
                "line": 540,
                "column": 75,
                "index": 14244
            },
            "line": 540,
            "code": "      test('Should return an array with values that do not match the filter', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $notIn: [43, 12]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should match values only greater than",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than"
            ],
            "updatePoint": {
                "line": 556,
                "column": 49,
                "index": 14686
            },
            "line": 556,
            "code": "      test('Should match values only greater than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gt: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gt: 40\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with integers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than"
            ],
            "updatePoint": {
                "line": 582,
                "column": 37,
                "index": 15366
            },
            "line": 582,
            "code": "      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gt: 40\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with float",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than"
            ],
            "updatePoint": {
                "line": 596,
                "column": 34,
                "index": 15732
            },
            "line": 596,
            "code": "      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: {\n                $gt: 9.3\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with decimal",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than"
            ],
            "updatePoint": {
                "line": 610,
                "column": 36,
                "index": 16102
            },
            "line": 610,
            "code": "      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              decimal_field: {\n                $gt: 1.23\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with bigintegers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than"
            ],
            "updatePoint": {
                "line": 624,
                "column": 40,
                "index": 16485
            },
            "line": 624,
            "code": "      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              big_rank: {\n                $gt: 34567891298\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work correclty on equal values",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than or equal"
            ],
            "updatePoint": {
                "line": 640,
                "column": 49,
                "index": 16940
            },
            "line": 640,
            "code": "      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gte: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gte: 43\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with integers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than or equal"
            ],
            "updatePoint": {
                "line": 666,
                "column": 37,
                "index": 17622
            },
            "line": 666,
            "code": "      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $gte: 40\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with float",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than or equal"
            ],
            "updatePoint": {
                "line": 680,
                "column": 34,
                "index": 17989
            },
            "line": 680,
            "code": "      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: {\n                $gte: 10.99\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with decimal",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than or equal"
            ],
            "updatePoint": {
                "line": 694,
                "column": 36,
                "index": 18362
            },
            "line": 694,
            "code": "      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              decimal_field: {\n                $gte: 42.43\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with bigintegers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter greater than or equal"
            ],
            "updatePoint": {
                "line": 708,
                "column": 40,
                "index": 18747
            },
            "line": 708,
            "code": "      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              big_rank: {\n                $gte: '345678912983'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should match values only less than",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than"
            ],
            "updatePoint": {
                "line": 724,
                "column": 46,
                "index": 19191
            },
            "line": 724,
            "code": "      test('Should match values only less than', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lt: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[0]]));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lt: 43\n              }\n            }\n          }\n        });\n        expect(res2.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with integers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than"
            ],
            "updatePoint": {
                "line": 750,
                "column": 37,
                "index": 19871
            },
            "line": 750,
            "code": "      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lt: 45\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with float",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than"
            ],
            "updatePoint": {
                "line": 764,
                "column": 34,
                "index": 20237
            },
            "line": 764,
            "code": "      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: {\n                $lt: 21.3\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with decimal",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than"
            ],
            "updatePoint": {
                "line": 778,
                "column": 36,
                "index": 20608
            },
            "line": 778,
            "code": "      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              decimal_field: {\n                $lt: 46.23\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with bigintegers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than"
            ],
            "updatePoint": {
                "line": 792,
                "column": 40,
                "index": 20992
            },
            "line": 792,
            "code": "      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              big_rank: {\n                $lt: 3456789129812\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work correclty on equal values",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than or equal"
            ],
            "updatePoint": {
                "line": 808,
                "column": 49,
                "index": 21446
            },
            "line": 808,
            "code": "      test('Should work correclty on equal values', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lte: 52\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n        const res2 = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lte: 21\n              }\n            }\n          }\n        });\n        expect(res2.body).toEqual(expect.not.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with integers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than or equal"
            ],
            "updatePoint": {
                "line": 834,
                "column": 37,
                "index": 22123
            },
            "line": 834,
            "code": "      test('Should work with integers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              rank: {\n                $lte: 42\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with float",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than or equal"
            ],
            "updatePoint": {
                "line": 848,
                "column": 34,
                "index": 22490
            },
            "line": 848,
            "code": "      test('Should work with float', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: {\n                $lte: 10.99\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with decimal",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than or equal"
            ],
            "updatePoint": {
                "line": 862,
                "column": 36,
                "index": 22863
            },
            "line": 862,
            "code": "      test('Should work with decimal', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              decimal_field: {\n                $lte: 42.43\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Should work with bigintegers",
            "suites": [
                "Filtering API",
                "Basic filters",
                "Filter less than or equal"
            ],
            "updatePoint": {
                "line": 876,
                "column": 40,
                "index": 23248
            },
            "line": 876,
            "code": "      test('Should work with bigintegers', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              big_rank: {\n                $lte: '345678912983'\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Supports simple or",
            "suites": [
                "Filtering API",
                "Or filtering",
                "$or filter"
            ],
            "updatePoint": {
                "line": 894,
                "column": 30,
                "index": 23711
            },
            "line": 894,
            "code": "      test('Supports simple or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              $or: [{\n                rank: 42\n              }, {\n                rank: 82\n              }]\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[1]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Supports simple or on different fields",
            "suites": [
                "Filtering API",
                "Or filtering",
                "$or filter"
            ],
            "updatePoint": {
                "line": 910,
                "column": 50,
                "index": 24156
            },
            "line": 910,
            "code": "      test('Supports simple or on different fields', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              $or: [{\n                rank: 42\n              }, {\n                price: {\n                  $gt: 28\n                }\n              }]\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[1], data.product[2]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Supports or with nested and",
            "suites": [
                "Filtering API",
                "Or filtering",
                "$or filter"
            ],
            "updatePoint": {
                "line": 928,
                "column": 39,
                "index": 24651
            },
            "line": 928,
            "code": "      test('Supports or with nested and', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              $or: [{\n                rank: 42\n              }, [{\n                price: {\n                  $gt: 28\n                }\n              }, {\n                rank: 91\n              }]]\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Supports or with nested or",
            "suites": [
                "Filtering API",
                "Or filtering",
                "$or filter"
            ],
            "updatePoint": {
                "line": 948,
                "column": 38,
                "index": 25174
            },
            "line": 948,
            "code": "      test('Supports or with nested or', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              $or: [{\n                rank: 42\n              }, [{\n                price: {\n                  $gt: 28\n                }\n              }, {\n                $or: [{\n                  rank: 91\n                }]\n              }]]\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[2]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter equals",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 973,
                "column": 23,
                "index": 25774
            },
            "line": 973,
            "code": "    test('Filter equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: [42, 43]\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter not equals",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 985,
                "column": 27,
                "index": 26078
            },
            "line": 985,
            "code": "    test('Filter not equals', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $ne: [41, 43]\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter contains insensitive",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 999,
                "column": 37,
                "index": 26427
            },
            "line": 999,
            "code": "    test('Filter contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $containsi: ['Product', '1']\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter not contains insensitive",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1013,
                "column": 41,
                "index": 26795
            },
            "line": 1013,
            "code": "    test('Filter not contains insensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $notContainsi: ['Product', 'Non existent']\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter contains sensitive",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1027,
                "column": 35,
                "index": 27171
            },
            "line": 1027,
            "code": "    test('Filter contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $contains: ['Product', 'Non existent']\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter not contains sensitive",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1041,
                "column": 39,
                "index": 27547
            },
            "line": 1041,
            "code": "    test('Filter not contains sensitive', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $notContains: ['product', 'Non existent']\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter greater than",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1055,
                "column": 29,
                "index": 27916
            },
            "line": 1055,
            "code": "    test('Filter greater than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $gt: [12, 56]\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter greater than or equal",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1069,
                "column": 38,
                "index": 28266
            },
            "line": 1069,
            "code": "    test('Filter greater than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $gte: [42, 56]\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter less than",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1083,
                "column": 26,
                "index": 28605
            },
            "line": 1083,
            "code": "    test('Filter less than', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $lt: [56, 12]\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Filter less than or equal",
            "suites": [
                "Filtering API",
                "Implict or"
            ],
            "updatePoint": {
                "line": 1097,
                "column": 35,
                "index": 28952
            },
            "line": 1097,
            "code": "    test('Filter less than or equal', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $lte: [12, 42]\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Greater than and less than at the same time",
            "suites": [
                "Filtering API",
                "Complexe filtering"
            ],
            "updatePoint": {
                "line": 1113,
                "column": 53,
                "index": 29365
            },
            "line": 1113,
            "code": "    test('Greater than and less than at the same time', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $lte: 42,\n              $gte: 42\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $lt: 43,\n              $gt: 41\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            rank: {\n              $lt: 43,\n              $gt: 431\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual([]);\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Contains and Not contains on same column",
            "suites": [
                "Filtering API",
                "Complexe filtering"
            ],
            "updatePoint": {
                "line": 1154,
                "column": 50,
                "index": 30302
            },
            "line": 1154,
            "code": "    test('Contains and Not contains on same column', async () => {\n      let res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $contains: 'Product',\n              $notContains: '1'\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining(data.product.slice(1)));\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $contains: 'Product 1',\n              $notContains: ['2', '3']\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.not.arrayContaining([data.product[1], data.product[2]]));\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $contains: '2',\n              $notContains: 'Product'\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual([]);\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Combined filters",
            "suites": [
                "Filtering API",
                "Complexe filtering"
            ],
            "updatePoint": {
                "line": 1196,
                "column": 26,
                "index": 31395
            },
            "line": 1196,
            "code": "    test('Combined filters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          filters: {\n            name: {\n              $contains: 'Product'\n            },\n            rank: {\n              $lt: 45\n            }\n          }\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Default sorting is asc",
            "suites": [
                "Filtering API",
                "Sorting"
            ],
            "updatePoint": {
                "line": 1215,
                "column": 32,
                "index": 31839
            },
            "line": 1215,
            "code": "    test('Default sorting is asc', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          sort: 'rank'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining(data.product.slice(0).sort((a, b) => a.attributes.rank - b.attributes.rank)));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Simple sorting",
            "suites": [
                "Filtering API",
                "Sorting"
            ],
            "updatePoint": {
                "line": 1225,
                "column": 24,
                "index": 32161
            },
            "line": 1225,
            "code": "    test('Simple sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          sort: 'rank:asc'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining(data.product.slice(0).sort((a, b) => a.attributes.rank - b.attributes.rank)));\n      const res2 = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          sort: 'rank:desc'\n        }\n      });\n      expect(res2.body.data).toEqual(expect.arrayContaining(data.product.slice(0).sort((a, b) => b.attributes.rank - a.attributes.rank)));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Multi column sorting",
            "suites": [
                "Filtering API",
                "Sorting"
            ],
            "updatePoint": {
                "line": 1243,
                "column": 30,
                "index": 32773
            },
            "line": 1243,
            "code": "    test('Multi column sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          sort: 'price:asc,rank:desc'\n        }\n      });\n      [data.product[3], data.product[0], data.product[2], data.product[1]].forEach(expectedPost => {\n        expect(res.body.data).toEqual(expect.arrayContaining([expectedPost]));\n      });\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Limit",
            "suites": [
                "Filtering API",
                "Limit and offset"
            ],
            "updatePoint": {
                "line": 1257,
                "column": 15,
                "index": 33198
            },
            "line": 1257,
            "code": "    test('Limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          pagination: {\n            limit: 1\n          },\n          sort: 'rank:asc'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Limit with sorting",
            "suites": [
                "Filtering API",
                "Limit and offset"
            ],
            "updatePoint": {
                "line": 1270,
                "column": 28,
                "index": 33528
            },
            "line": 1270,
            "code": "    test('Limit with sorting', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          pagination: {\n            limit: 1\n          },\n          sort: 'rank:desc'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[data.product.length - 1]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Offset",
            "suites": [
                "Filtering API",
                "Limit and offset"
            ],
            "updatePoint": {
                "line": 1283,
                "column": 16,
                "index": 33869
            },
            "line": 1283,
            "code": "    test('Offset', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          pagination: {\n            start: 1\n          },\n          sort: 'rank:asc'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining(data.product.slice(1)));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Offset with limit",
            "suites": [
                "Filtering API",
                "Limit and offset"
            ],
            "updatePoint": {
                "line": 1296,
                "column": 27,
                "index": 34202
            },
            "line": 1296,
            "code": "    test('Offset with limit', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          pagination: {\n            limit: 1,\n            start: 1\n          },\n          sort: 'rank:asc'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining(data.product.slice(1, 2)));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cyrillic query",
            "suites": [
                "Filtering API",
                "Text query"
            ],
            "updatePoint": {
                "line": 1312,
                "column": 24,
                "index": 34596
            },
            "line": 1312,
            "code": "    test('Cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: ''\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[4]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Multi word query",
            "suites": [
                "Filtering API",
                "Text query"
            ],
            "updatePoint": {
                "line": 1322,
                "column": 26,
                "index": 34860
            },
            "line": 1322,
            "code": "    test('Multi word query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: 'Product description'\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Multi word cyrillic query",
            "suites": [
                "Filtering API",
                "Text query"
            ],
            "updatePoint": {
                "line": 1332,
                "column": 35,
                "index": 35148
            },
            "line": 1332,
            "code": "    test('Multi word cyrillic query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/products',\n        qs: {\n          _q: '  '\n        }\n      });\n      expect(res.body.data).toEqual(expect.arrayContaining([data.product[4]]));\n    });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1345,
            "code": "      test.each(['1', 'true', true, 't'])('Cast truthy booleans %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: val\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[2], data.product[4]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans nested %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1357,
            "code": "      test.each(['1', 'true', true, 't'])('Cast truthy booleans nested %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: {\n                $eq: val\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[2], data.product[4]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans in arrays %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1371,
            "code": "      test.each(['1', 'true', true, 't'])('Cast truthy booleans in arrays %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: {\n                $in: [val]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0], data.product[2], data.product[4]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1385,
            "code": "      test.each(['0', 'false', false, 'f'])('Cast truthy booleans %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: val\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[1], data.product[3]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans nested %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1397,
            "code": "      test.each(['0', 'false', false, 'f'])('Cast truthy booleans nested %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: {\n                $eq: val\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[1], data.product[3]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast truthy booleans in arrays %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Booleans"
            ],
            "line": 1411,
            "code": "      test.each(['0', 'false', false, 'f'])('Cast truthy booleans in arrays %s', async val => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              isChecked: {\n                $in: [val]\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[1], data.product[3]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast number",
            "suites": [
                "Filtering API",
                "Type casting",
                "Numbers"
            ],
            "updatePoint": {
                "line": 1427,
                "column": 23,
                "index": 38083
            },
            "line": 1427,
            "code": "      test('Cast number', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: '10.99'\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining([data.product[0]]));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cast number in operator %s - %s",
            "suites": [
                "Filtering API",
                "Type casting",
                "Numbers"
            ],
            "line": 1439,
            "code": "      test.each([['$lte', '10.99', [0]], ['$lt', '12', [0]], ['$gte', '28.31', [1, 2]], ['$gt', '28.30', [1, 2]], ['$eq', '10.99', [0]], ['$ne', '10.99', [1, 2]], ['$not', '10.99', [1, 2]], ['$in', ['10.99', '28.31'], [0, 1, 2]], ['$in', '10.99', [0]], ['$notIn', ['10.99', '28.31'], []]])('Cast number in operator %s - %s', async (operator, val, expectedIds) => {\n        const res = await rq({\n          method: 'GET',\n          url: '/products',\n          qs: {\n            filters: {\n              price: {\n                [operator]: val\n              }\n            }\n          }\n        });\n        expect(res.body.data).toEqual(expect.arrayContaining(expectedIds.map(id => data.product[id])));\n      });",
            "file": "filtering.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Component data should be available",
            "suites": [
                "Lifecycle - beforeDelete"
            ],
            "updatePoint": {
                "line": 59,
                "column": 42,
                "index": 1416
            },
            "line": 59,
            "code": "  test('Component data should be available', async () => {\n    expect.assertions(4);\n    let entity;\n    const beforeDelete = jest.fn(async ctx => {\n      entity = await strapi.db.query('api::product-with-compo.product-with-compo').findOne({\n        ...ctx.params,\n        populate: {\n          compo: true\n        }\n      });\n    });\n    strapi.db.lifecycles.subscribe({\n      models: ['api::product-with-compo.product-with-compo'],\n      beforeDelete\n    });\n    await rq({\n      method: 'DELETE',\n      url: '/product-with-compos/1'\n    });\n    expect(beforeDelete.mock.calls.length).toBe(1);\n    expect(entity).toBeDefined();\n    expect(entity.compo).not.toBeNull();\n    expect(entity.compo.name).toBe('compo-1');\n  });",
            "file": "lifecycles/before-delete.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "%p",
            "suites": [
                "Migration - draft and publish"
            ],
            "line": 53,
            "code": "  describe.each([['without table modifications', {}, {}], ['with table modifications', {\n    town: {\n      type: 'string'\n    }\n  }, {\n    color: {\n      type: 'string'\n    }\n  }]])('%p', (testName, tableModification1, tableModification2) => {\n    beforeAll(async () => {\n      builder = createTestBuilder();\n      await builder.addContentType(dogModel).addFixtures(dogModel.singularName, dogs).build();\n      strapi = await createStrapiInstance();\n      rq = await createAuthRequest({\n        strapi\n      });\n      data.dogs = sortDogs(await builder.sanitizedFixturesFor(dogModel.singularName, strapi));\n    });\n    afterAll(async () => {\n      await strapi.destroy();\n      await builder.cleanup();\n    });\n    describe('Enabling D&P on a content-type', () => {\n      test('No publishedAt before enabling the feature', async () => {\n        const {\n          body\n        } = await rq({\n          url: '/content-manager/collection-types/api::dog.dog',\n          method: 'GET'\n        });\n        expect(body.results.length).toBe(2);\n        const sortedBody = sortDogs(body.results);\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.publishedAt).toBeUndefined();\n        });\n      });\n      test('Published_at is equal to created_at after enabling the feature', async () => {\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n          strapi\n        });\n        await modelsUtils.modifyContentType({\n          ...schema,\n          attributes: _.merge(schema.attributes, tableModification1),\n          draftAndPublish: true\n        }, {\n          strapi\n        });\n        await restart();\n        const {\n          body\n        } = await rq({\n          method: 'GET',\n          url: '/content-manager/collection-types/api::dog.dog'\n        });\n        expect(body.results.length).toBe(2);\n        const sortedBody = sortDogs(body.results);\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.publishedAt).toBe(dog.createdAt || dog.created_at);\n          expect(!Number.isNaN(new Date(dog.publishedAt).valueOf())).toBe(true);\n        });\n        data.dogs = sortedBody;\n      });\n    });\n    describe('Disabling D&P on a content-type', () => {\n      test('No publishedAt after disabling the feature + draft removed', async () => {\n        const res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/${data.dogs[1].id}/actions/unpublish`\n        });\n        data.dogs[1] = res.body;\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n          strapi\n        });\n        await modelsUtils.modifyContentType({\n          ...schema,\n          draftAndPublish: false,\n          attributes: _.merge(schema.attributes, tableModification2)\n        }, {\n          strapi\n        });\n        await restart();\n\n        // drafts should have been deleted with the migration, so we remove them\n        data.dogs = data.dogs.filter(dog => !_.isNil(dog.publishedAt));\n        const {\n          body\n        } = await rq({\n          url: '/content-manager/collection-types/api::dog.dog',\n          method: 'GET'\n        });\n        expect(body.results.length).toBe(1);\n        expect(body.results[0]).toMatchObject(_.pick(data.dogs[0], ['name']));\n        expect(body.results[0].publishedAt).toBeUndefined();\n      });\n      test('Unique constraint is kept after disabling the feature', async () => {\n        const dogToCreate = {\n          code: 'sameCode'\n        };\n        let res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/`,\n          body: dogToCreate\n        });\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(dogToCreate);\n        data.dogs.push(res.body);\n        res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/`,\n          body: dogToCreate\n        });\n        expect(res.statusCode).toBe(400);\n      });\n    });\n  });",
            "file": "migrations/migration-draft-publish.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No publishedAt before enabling the feature",
            "suites": [
                "Migration - draft and publish",
                "Enabling D&P on a content-type"
            ],
            "updatePoint": {
                "line": 76,
                "column": 54,
                "index": 1842
            },
            "line": 76,
            "code": "      test('No publishedAt before enabling the feature', async () => {\n        const {\n          body\n        } = await rq({\n          url: '/content-manager/collection-types/api::dog.dog',\n          method: 'GET'\n        });\n        expect(body.results.length).toBe(2);\n        const sortedBody = sortDogs(body.results);\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.publishedAt).toBeUndefined();\n        });\n      });",
            "file": "migrations/migration-draft-publish.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Published_at is equal to created_at after enabling the feature",
            "suites": [
                "Migration - draft and publish",
                "Enabling D&P on a content-type"
            ],
            "updatePoint": {
                "line": 90,
                "column": 74,
                "index": 2357
            },
            "line": 90,
            "code": "      test('Published_at is equal to created_at after enabling the feature', async () => {\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n          strapi\n        });\n        await modelsUtils.modifyContentType({\n          ...schema,\n          attributes: _.merge(schema.attributes, tableModification1),\n          draftAndPublish: true\n        }, {\n          strapi\n        });\n        await restart();\n        const {\n          body\n        } = await rq({\n          method: 'GET',\n          url: '/content-manager/collection-types/api::dog.dog'\n        });\n        expect(body.results.length).toBe(2);\n        const sortedBody = sortDogs(body.results);\n        sortedBody.forEach((dog, index) => {\n          expect(dog).toMatchObject(data.dogs[index]);\n          expect(dog.publishedAt).toBe(dog.createdAt || dog.created_at);\n          expect(!Number.isNaN(new Date(dog.publishedAt).valueOf())).toBe(true);\n        });\n        data.dogs = sortedBody;\n      });",
            "file": "migrations/migration-draft-publish.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "No publishedAt after disabling the feature + draft removed",
            "suites": [
                "Migration - draft and publish",
                "Disabling D&P on a content-type"
            ],
            "updatePoint": {
                "line": 119,
                "column": 70,
                "index": 3419
            },
            "line": 119,
            "code": "      test('No publishedAt after disabling the feature + draft removed', async () => {\n        const res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/${data.dogs[1].id}/actions/unpublish`\n        });\n        data.dogs[1] = res.body;\n        const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n          strapi\n        });\n        await modelsUtils.modifyContentType({\n          ...schema,\n          draftAndPublish: false,\n          attributes: _.merge(schema.attributes, tableModification2)\n        }, {\n          strapi\n        });\n        await restart();\n\n        // drafts should have been deleted with the migration, so we remove them\n        data.dogs = data.dogs.filter(dog => !_.isNil(dog.publishedAt));\n        const {\n          body\n        } = await rq({\n          url: '/content-manager/collection-types/api::dog.dog',\n          method: 'GET'\n        });\n        expect(body.results.length).toBe(1);\n        expect(body.results[0]).toMatchObject(_.pick(data.dogs[0], ['name']));\n        expect(body.results[0].publishedAt).toBeUndefined();\n      });",
            "file": "migrations/migration-draft-publish.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Unique constraint is kept after disabling the feature",
            "suites": [
                "Migration - draft and publish",
                "Disabling D&P on a content-type"
            ],
            "updatePoint": {
                "line": 149,
                "column": 65,
                "index": 4561
            },
            "line": 149,
            "code": "      test('Unique constraint is kept after disabling the feature', async () => {\n        const dogToCreate = {\n          code: 'sameCode'\n        };\n        let res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/`,\n          body: dogToCreate\n        });\n        expect(res.statusCode).toBe(200);\n        expect(res.body).toMatchObject(dogToCreate);\n        data.dogs.push(res.body);\n        res = await rq({\n          method: 'POST',\n          url: `/content-manager/collection-types/api::dog.dog/`,\n          body: dogToCreate\n        });\n        expect(res.statusCode).toBe(400);\n      });",
            "file": "migrations/migration-draft-publish.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can be null before migration",
            "suites": [
                "Migration - required attribute",
                "Required: false -> true"
            ],
            "updatePoint": {
                "line": 60,
                "column": 38,
                "index": 1407
            },
            "line": 60,
            "code": "    test('Can be null before migration', async () => {\n      const {\n        body\n      } = await rq({\n        method: 'GET',\n        url: '/content-manager/collection-types/api::dog.dog'\n      });\n      expect(body.results.length).toBe(2);\n      const dogWithNameNull = body.results.find(dog => dog.name === null);\n      expect(dogWithNameNull).toBeTruthy();\n    });",
            "file": "migrations/migration-required-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create an entry with null after migration",
            "suites": [
                "Migration - required attribute",
                "Required: false -> true"
            ],
            "updatePoint": {
                "line": 71,
                "column": 58,
                "index": 1795
            },
            "line": 71,
            "code": "    test('Cannot create an entry with null after migration', async () => {\n      // remove null values otherwise the migration would fail\n\n      const {\n        body\n      } = await rq({\n        method: 'PUT',\n        url: `/content-manager/collection-types/api::dog.dog/${data.dogs[0].id}`,\n        body: {\n          name: 'Nelson'\n        }\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n        strapi\n      });\n      schema.attributes.name.required = true;\n      await modelsUtils.modifyContentType(schema, {\n        strapi\n      });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/api::dog.dog',\n        body: {\n          name: null\n        }\n      });\n      expect(res.body).toMatchObject({\n        data: null,\n        error: {\n          details: {\n            errors: [{\n              message: 'name must be a `string` type, but the final value was: `null`.',\n              name: 'ValidationError',\n              path: ['name']\n            }]\n          },\n          message: 'name must be a `string` type, but the final value was: `null`.',\n          name: 'ValidationError',\n          status: 400\n        }\n      });\n    });",
            "file": "migrations/migration-required-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can create an entry with null after migration",
            "suites": [
                "Migration - required attribute",
                "Required: true -> false"
            ],
            "updatePoint": {
                "line": 121,
                "column": 55,
                "index": 3191
            },
            "line": 121,
            "code": "    test('Can create an entry with null after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n        strapi\n      });\n      schema.attributes.name.required = false;\n      await modelsUtils.modifyContentType(schema, {\n        strapi\n      });\n      await restart();\n\n      // Try to create an entry with null\n      const res = await rq({\n        url: `/content-manager/collection-types/api::dog.dog`,\n        method: 'POST',\n        body: {\n          name: null\n        }\n      });\n      expect(res.body).toMatchObject({\n        name: null\n      });\n      data.dogs.push(res.body);\n    });",
            "file": "migrations/migration-required-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can have duplicates before migration",
            "suites": [
                "Migration - unique attribute",
                "Unique: false -> true"
            ],
            "updatePoint": {
                "line": 60,
                "column": 46,
                "index": 1411
            },
            "line": 60,
            "code": "    test('Can have duplicates before migration', async () => {\n      const {\n        body\n      } = await rq({\n        url: '/content-manager/collection-types/api::dog.dog',\n        method: 'GET'\n      });\n      expect(body.results.length).toBe(2);\n      expect(body.results[0].name).toEqual(body.results[1].name);\n    });",
            "file": "migrations/migration-unique-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Cannot create a duplicated entry after migration",
            "suites": [
                "Migration - unique attribute",
                "Unique: false -> true"
            ],
            "updatePoint": {
                "line": 70,
                "column": 58,
                "index": 1746
            },
            "line": 70,
            "code": "    test('Cannot create a duplicated entry after migration', async () => {\n      // remove duplicated values otherwise the migration would fail\n      const {\n        body\n      } = await rq({\n        url: `/content-manager/collection-types/api::dog.dog/${data.dogs[0].id}`,\n        method: 'PUT',\n        body: {\n          name: 'Nelson'\n        }\n      });\n      data.dogs[0] = body;\n\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n        strapi\n      });\n      schema.attributes.name.unique = true;\n      await modelsUtils.modifyContentType(schema, {\n        strapi\n      });\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        method: 'POST',\n        url: '/content-manager/collection-types/api::dog.dog',\n        body: {\n          name: data.dogs[0].name\n        }\n      });\n      expect(res.statusCode).toBe(400);\n    });",
            "file": "migrations/migration-unique-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can create a duplicated entry after migration",
            "suites": [
                "Migration - unique attribute",
                "Unique: true -> false"
            ],
            "updatePoint": {
                "line": 105,
                "column": 55,
                "index": 2729
            },
            "line": 105,
            "code": "    test('Can create a duplicated entry after migration', async () => {\n      // migration\n      const schema = await modelsUtils.getContentTypeSchema(dogModel.singularName, {\n        strapi\n      });\n      schema.attributes.name.unique = false;\n      await modelsUtils.modifyContentType(schema, {\n        strapi\n      });\n      await restart();\n\n      // Try to create a duplicated entry\n      const res = await rq({\n        url: `/content-manager/collection-types/api::dog.dog`,\n        method: 'POST',\n        body: {\n          name: data.dogs[0].name\n        }\n      });\n      expect(res.body).toMatchObject({\n        name: data.dogs[0].name\n      });\n      data.dogs.push(res.body);\n    });",
            "file": "migrations/migration-unique-attribute.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Mode: \"%s\"",
            "suites": [
                "Publication State"
            ],
            "line": 170,
            "code": "  describe.each(['default', 'live', 'preview'])('Mode: \"%s\"', mode => {\n    describe.each(['country', 'category', 'product'])('For %s', modelName => {\n      const baseUrl = `/${contentTypes[modelName].pluralName}`;\n      const query = getQueryFromMode(mode);\n      test('Can get entries', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: `${baseUrl}${query}`\n        });\n        expect(res.body.data).toHaveLength(lengthFor(modelName, {\n          mode\n        }));\n        expect(res.body.meta.pagination.total).toBe(lengthFor(modelName, {\n          mode\n        }));\n      });\n    });\n  });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "For %s",
            "suites": [
                "Publication State"
            ],
            "line": 171,
            "code": "    describe.each(['country', 'category', 'product'])('For %s', modelName => {\n      const baseUrl = `/${contentTypes[modelName].pluralName}`;\n      const query = getQueryFromMode(mode);\n      test('Can get entries', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: `${baseUrl}${query}`\n        });\n        expect(res.body.data).toHaveLength(lengthFor(modelName, {\n          mode\n        }));\n        expect(res.body.meta.pagination.total).toBe(lengthFor(modelName, {\n          mode\n        }));\n      });\n    });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Can get entries",
            "suites": [
                "Publication State"
            ],
            "updatePoint": {
                "line": 174,
                "column": 27,
                "index": 4145
            },
            "line": 174,
            "code": "      test('Can get entries', async () => {\n        const res = await rq({\n          method: 'GET',\n          url: `${baseUrl}${query}`\n        });\n        expect(res.body.data).toHaveLength(lengthFor(modelName, {\n          mode\n        }));\n        expect(res.body.meta.pagination.total).toBe(lengthFor(modelName, {\n          mode\n        }));\n      });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Payload integrity",
            "suites": [
                "Publication State",
                "Advanced checks",
                "Nested level of relations (live mode)"
            ],
            "updatePoint": {
                "line": 201,
                "column": 29,
                "index": 4938
            },
            "line": 201,
            "code": "      test('Payload integrity', () => {\n        expect(products).toHaveLength(lengthFor(contentTypes.product.singularName));\n      });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Root level",
            "suites": [
                "Publication State",
                "Advanced checks",
                "Nested level of relations (live mode)"
            ],
            "updatePoint": {
                "line": 204,
                "column": 22,
                "index": 5066
            },
            "line": 204,
            "code": "      test('Root level', () => {\n        products.forEach(product => {\n          expect(product.attributes.publishedAt).toBeISODate();\n        });\n      });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "First level (categories) to be published only",
            "suites": [
                "Publication State",
                "Advanced checks",
                "Nested level of relations (live mode)"
            ],
            "updatePoint": {
                "line": 209,
                "column": 57,
                "index": 5258
            },
            "line": 209,
            "code": "      test('First level (categories) to be published only', () => {\n        products.forEach(({\n          attributes\n        }) => {\n          const categories = attributes.categories.data;\n          categories.forEach(category => {\n            expect(category.attributes.publishedAt).toBeISODate();\n          });\n        });\n      });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Second level through component (countries) to be published only",
            "suites": [
                "Publication State",
                "Advanced checks",
                "Nested level of relations (live mode)"
            ],
            "updatePoint": {
                "line": 219,
                "column": 75,
                "index": 5612
            },
            "line": 219,
            "code": "      test('Second level through component (countries) to be published only', () => {\n        products.forEach(({\n          attributes\n        }) => {\n          const countries = attributes.comp.countries.data;\n          countries.forEach(country => {\n            expect(country.attributes.publishedAt).toBeISODate();\n          });\n        });\n      });",
            "file": "publication-state.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search for \"id\"",
            "suites": [
                "Search query",
                "Without filters"
            ],
            "updatePoint": {
                "line": 135,
                "column": 25,
                "index": 3032
            },
            "line": 135,
            "code": "    test('search for \"id\"', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[2].id\n        }\n      });\n      expect(res.body.data.length).toBe(1);\n      expect(res.body.data[0]).toMatchObject(transformToRESTResource(data.bed[2]));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search that target column %p",
            "suites": [
                "Search query",
                "Without filters"
            ],
            "line": 146,
            "code": "    test.each(Object.keys(bedFixtures[0]))('search that target column %p', async columnName => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: bedFixtures[0][columnName]\n        }\n      });\n      expect(res.body.data.length).toBe(1);\n      expect(res.body.data[0]).toMatchObject(transformToRESTResource(data.bed[0]));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with an empty query",
            "suites": [
                "Search query",
                "Without filters"
            ],
            "updatePoint": {
                "line": 157,
                "column": 36,
                "index": 3740
            },
            "line": 157,
            "code": "    test('search with an empty query', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: ''\n        }\n      });\n      expect(res.body.data.length).toBe(5);\n      expect(res.body.data).toEqual(expect.arrayContaining(data.bed.map(bed => transformToRESTResource(bed))));\n      expect(res.body.meta).toMatchObject({\n        pagination: {\n          page: 1,\n          pageSize: 25,\n          pageCount: 1,\n          total: 5\n        }\n      });\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with special characters",
            "suites": [
                "Search query",
                "Without filters"
            ],
            "updatePoint": {
                "line": 176,
                "column": 40,
                "index": 4258
            },
            "line": 176,
            "code": "    test('search with special characters', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: data.bed[3].name\n        }\n      });\n      expect(res.body.data.length).toBe(1);\n      expect(res.body.data[0]).toMatchObject(transformToRESTResource(data.bed[3]));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with an empty query & peopleNumber > 0",
            "suites": [
                "Search query",
                "With filters"
            ],
            "updatePoint": {
                "line": 189,
                "column": 55,
                "index": 4646
            },
            "line": 189,
            "code": "    test('search with an empty query & peopleNumber > 0', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          filters: {\n            peopleNumber: {\n              $gt: 0\n            }\n          }\n        }\n      });\n      expect(res.body.data.length).toBe(3);\n      const expected = [data.bed[0], data.bed[1], data.bed[4]].map(bed => transformToRESTResource(bed));\n      expect(res.body.data).toEqual(expect.arrayContaining(expected));\n      expect(res.body.meta).toMatchObject({\n        pagination: {\n          page: 1,\n          pageSize: 25,\n          pageCount: 1,\n          total: 3\n        }\n      });\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with an empty query & peopleNumber > 1",
            "suites": [
                "Search query",
                "With filters"
            ],
            "updatePoint": {
                "line": 214,
                "column": 55,
                "index": 5340
            },
            "line": 214,
            "code": "    test('search with an empty query & peopleNumber > 1', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          filters: {\n            peopleNumber: {\n              $gt: 1\n            }\n          }\n        }\n      });\n      expect(res.body.data.length).toBe(2);\n      const expected = [data.bed[0], data.bed[4]].map(bed => transformToRESTResource(bed));\n      expect(res.body.data).toEqual(expect.arrayContaining(expected));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with an empty query & peopleNumber in [1, 6]",
            "suites": [
                "Search query",
                "With filters"
            ],
            "updatePoint": {
                "line": 231,
                "column": 61,
                "index": 5855
            },
            "line": 231,
            "code": "    test('search with an empty query & peopleNumber in [1, 6]', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: '',\n          filters: {\n            peopleNumber: [1, 6]\n          }\n        }\n      });\n      expect(res.body.data.length).toBe(2);\n      const expected = data.bed.slice(0, 2).map(bed => transformToRESTResource(bed));\n      expect(res.body.data).toEqual(expect.arrayContaining(expected));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search for \"Sleepy Bed\" & peopleNumber < 7",
            "suites": [
                "Search query",
                "With filters"
            ],
            "updatePoint": {
                "line": 246,
                "column": 52,
                "index": 6325
            },
            "line": 246,
            "code": "    test('search for \"Sleepy Bed\" & peopleNumber < 7', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: 'Sleepy Bed',\n          filters: {\n            peopleNumber: {\n              $lt: 7\n            }\n          }\n        }\n      });\n      expect(res.body.data.length).toBe(1);\n      expect(res.body.data[0]).toMatchObject(transformToRESTResource(data.bed[0]));\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "search with a backslash",
            "suites": [
                "Search query",
                "With filters"
            ],
            "updatePoint": {
                "line": 262,
                "column": 33,
                "index": 6743
            },
            "line": 262,
            "code": "    test('search with a backslash', async () => {\n      const res = await rq({\n        method: 'GET',\n        url: '/beds',\n        qs: {\n          _q: 'Sleepy Bed',\n          filters: {\n            name: {\n              $contains: 'test\\\\'\n            }\n          }\n        }\n      });\n      expect(res.body.data.length).toBe(0);\n    });",
            "file": "search.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "find single type content returns 404 when not created",
            "suites": [
                "Content Manager single types"
            ],
            "updatePoint": {
                "line": 42,
                "column": 61,
                "index": 969
            },
            "line": 42,
            "code": "  test('find single type content returns 404 when not created', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET'\n    });\n    expect(res.statusCode).toBe(404);\n  });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Create content",
            "suites": [
                "Content Manager single types"
            ],
            "updatePoint": {
                "line": 49,
                "column": 22,
                "index": 1129
            },
            "line": 49,
            "code": "  test('Create content', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        data: {\n          title: 'Title'\n        }\n      }\n    });\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: {\n        title: 'Title'\n      }\n    });\n    expect(res.body.data.attributes.publishedAt).toBeISODate();\n    data.id = res.body.data.id;\n  });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Update keeps the same data id",
            "suites": [
                "Content Manager single types"
            ],
            "updatePoint": {
                "line": 69,
                "column": 37,
                "index": 1604
            },
            "line": 69,
            "code": "  test('Update keeps the same data id', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'PUT',\n      body: {\n        data: {\n          title: 'Title'\n        }\n      }\n    });\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      id: data.id,\n      attributes: {\n        title: 'Title'\n      }\n    });\n  });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "find single type content returns an object ",
            "suites": [
                "Content Manager single types"
            ],
            "updatePoint": {
                "line": 87,
                "column": 51,
                "index": 1987
            },
            "line": 87,
            "code": "  test('find single type content returns an object ', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'GET'\n    });\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: {\n        title: 'Title'\n      }\n    });\n  });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        },
        {
            "name": "Delete single type content returns an object and makes data unavailable",
            "suites": [
                "Content Manager single types"
            ],
            "updatePoint": {
                "line": 100,
                "column": 79,
                "index": 2334
            },
            "line": 100,
            "code": "  test('Delete single type content returns an object and makes data unavailable', async () => {\n    const res = await rq({\n      url: `/${uid}`,\n      method: 'DELETE'\n    });\n    expect(res.statusCode).toBe(200);\n    expect(res.body.data).toMatchObject({\n      id: expect.anything(),\n      attributes: {\n        title: 'Title'\n      }\n    });\n    const getRes = await rq({\n      url: `/${uid}`,\n      method: 'GET'\n    });\n    expect(getRes.statusCode).toBe(404);\n  });",
            "file": "single-type.test.api.js",
            "skipped": false,
            "dir": "packages/core/strapi/tests"
        }
    ],
    "error": "Cannot read properties of undefined (reading 'name')"
}