{
    "repo": "dotansimha/graphql-code-generator",
    "url": "https://github.com/dotansimha/graphql-code-generator",
    "branch": "master",
    "configs": [
        {
            "package": "@graphql-codegen/cli",
            "lang": "ts",
            "dir": "packages/graphql-codegen-cli/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/core",
            "lang": "ts",
            "dir": "packages/graphql-codegen-core/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/c-sharp-operations",
            "lang": "ts",
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/c-sharp",
            "lang": "ts",
            "dir": "packages/plugins/c-sharp/c-sharp/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow",
            "lang": "ts",
            "dir": "packages/plugins/flow/flow/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow-operations",
            "lang": "ts",
            "dir": "packages/plugins/flow/operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/flow-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/flow/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-apollo-android",
            "lang": "ts",
            "dir": "packages/plugins/java/apollo-android/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-common",
            "lang": "ts",
            "dir": "packages/plugins/java/common/tests",
            "framework": "jest",
            "pattern": "**/*.{js,ts}"
        },
        {
            "package": "@graphql-codegen/java",
            "lang": "ts",
            "dir": "packages/plugins/java/java/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/kotlin",
            "lang": "ts",
            "dir": "packages/plugins/java/kotlin/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/java-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/java/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/fragment-matcher",
            "lang": "ts",
            "dir": "packages/plugins/other/fragment-matcher/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/introspection",
            "lang": "ts",
            "dir": "packages/plugins/other/introspection/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/jsdoc",
            "lang": "ts",
            "dir": "packages/plugins/other/jsdoc/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/schema-ast",
            "lang": "ts",
            "dir": "packages/plugins/other/schema-ast/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/time",
            "lang": "ts",
            "dir": "packages/plugins/other/time/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/urql-introspection",
            "lang": "ts",
            "dir": "packages/plugins/other/urql-introspection/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/visitor-plugin-common",
            "lang": "ts",
            "dir": "packages/plugins/other/visitor-plugin-common/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-apollo-angular",
            "lang": "ts",
            "dir": "packages/plugins/typescript/apollo-angular/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-apollo-client-helpers",
            "lang": "ts",
            "dir": "packages/plugins/typescript/apollo-client-helpers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-document-nodes",
            "lang": "ts",
            "dir": "packages/plugins/typescript/document-nodes/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-enum-array",
            "lang": "ts",
            "dir": "packages/plugins/typescript/enum-array/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-generic-sdk",
            "lang": "ts",
            "dir": "packages/plugins/typescript/generic-sdk/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-files-modules",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-files-modules/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-graphql-request",
            "lang": "ts",
            "dir": "packages/plugins/typescript/graphql-request/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-jit-sdk",
            "lang": "ts",
            "dir": "packages/plugins/typescript/jit-sdk/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-mongodb",
            "lang": "ts",
            "dir": "packages/plugins/typescript/mongodb/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-msw",
            "lang": "ts",
            "dir": "packages/plugins/typescript/msw/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/named-operations-object",
            "lang": "ts",
            "dir": "packages/plugins/typescript/named-operations-object/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-oclif",
            "lang": "ts",
            "dir": "packages/plugins/typescript/oclif/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-operations",
            "lang": "ts",
            "dir": "packages/plugins/typescript/operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-react-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/react-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-react-query",
            "lang": "ts",
            "dir": "packages/plugins/typescript/react-query/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-resolvers",
            "lang": "ts",
            "dir": "packages/plugins/typescript/resolvers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-rtk-query",
            "lang": "ts",
            "dir": "packages/plugins/typescript/rtk-query/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-stencil-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/stencil-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-type-graphql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/type-graphql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typed-document-node",
            "lang": "ts",
            "dir": "packages/plugins/typescript/typed-document-node/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript",
            "lang": "ts",
            "dir": "packages/plugins/typescript/typescript/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-urql-graphcache",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql-graphcache/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/urql-svelte-operations-store",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql-svelte-operations-store/test",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-urql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/urql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-apollo-smart-ops",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-apollo",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-apollo/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/typescript-vue-urql",
            "lang": "ts",
            "dir": "packages/plugins/typescript/vue-urql/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/gql-tag-operations-preset",
            "lang": "ts",
            "dir": "packages/presets/gql-tag-operations/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/graphql-modules-preset",
            "lang": "ts",
            "dir": "packages/presets/graphql-modules/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/import-types-preset",
            "lang": "ts",
            "dir": "packages/presets/import-types/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/near-operation-file-preset",
            "lang": "ts",
            "dir": "packages/presets/near-operation-file/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        },
        {
            "package": "@graphql-codegen/plugin-helpers",
            "lang": "ts",
            "dir": "packages/utils/plugins-helpers/tests",
            "framework": "jest",
            "pattern": "**/*[._-]{test,spec,unittest,unit}.{ts,js}"
        }
    ],
    "tests": [
        {
            "name": "should handle an Error",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 19,
                "column": 28
            },
            "line": 19,
            "code": "  it('should handle an Error', () => {\n    const msg = 'used as error';\n\n    cliError(new Error(msg));\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle string",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 27,
                "column": 26
            },
            "line": 27,
            "code": "  it('should handle string', () => {\n    const msg = 'used as string';\n\n    cliError(msg);\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle an object",
            "suites": [
                "cliError"
            ],
            "updatePoint": {
                "line": 35,
                "column": 29
            },
            "line": 35,
            "code": "  it('should handle an object', () => {\n    const obj = {\n      foo: 1,\n    };\n\n    cliError(obj);\n\n    expect(spyProcessExit).toBeCalledWith(1);\n  });",
            "file": "cli-error.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should create basic config using new yml API",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 37,
                "column": 50
            },
            "line": 37,
            "code": "  it('Should create basic config using new yml API', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv();\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toEqual('schema.graphql');\n    expect(config.generates).toEqual({ 'file.ts': ['plugin'] });\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should use different config file correctly with --config",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 51,
                "column": 62
            },
            "line": 51,
            "code": "  it('Should use different config file correctly with --config', async () => {\n    mockConfig(\n      `\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n      `,\n      'other.yml'\n    );\n    const args = createArgv('--config other.yml');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toEqual('schema.graphql');\n    expect(config.generates).toEqual({ 'file.ts': ['plugin'] });\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set --watch with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 68,
                "column": 41
            },
            "line": 68,
            "code": "  it('Should set --watch with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set watch and overwrite to default (false) with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 81,
                "column": 72
            },
            "line": 81,
            "code": "  it('Should set watch and overwrite to default (false) with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv();\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).not.toBeTruthy();\n    expect(config.overwrite).not.toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite watch config using cli flag to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 95,
                "column": 58
            },
            "line": 95,
            "code": "  it('Should overwrite watch config using cli flag to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        watch: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite watch config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 109,
                "column": 60
            },
            "line": 109,
            "code": "  it('Should overwrite watch config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        watch: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--watch=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.watch).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite ignoreNoDocuments config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 123,
                "column": 72
            },
            "line": 123,
            "code": "  it('Should overwrite ignoreNoDocuments config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        ignoreNoDocuments: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--ignore-no-documents=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.ignoreNoDocuments).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite emitLegacyCommonJSImports config using cli flags to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 137,
                "column": 79
            },
            "line": 137,
            "code": "  it('Should overwrite emitLegacyCommonJSImports config using cli flags to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        emitLegacyCommonJSImports: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--emit-legacy-common-js-imports');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.emitLegacyCommonJSImports).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite emitLegacyCommonJSImports config using cli flags to false",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 151,
                "column": 80
            },
            "line": 151,
            "code": "  it('Should overwrite emitLegacyCommonJSImports config using cli flags to false', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        emitLegacyCommonJSImports: true\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--emit-legacy-common-js-imports=false');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.emitLegacyCommonJSImports).toBeFalsy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should overwrite ignoreNoDocuments config using cli flags to true",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 165,
                "column": 71
            },
            "line": 165,
            "code": "  it('Should overwrite ignoreNoDocuments config using cli flags to true', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        ignoreNoDocuments: false\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--ignore-no-documents');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.ignoreNoDocuments).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should set --overwrite with new YML api",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 179,
                "column": 45
            },
            "line": 179,
            "code": "  it('Should set --overwrite with new YML api', async () => {\n    mockConfig(`\n        schema: schema.graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.overwrite).toBeTruthy();\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 192,
                "column": 55
            },
            "line": 192,
            "code": "  it('Should interpolate environmental variables in YML', async () => {\n    process.env.SCHEMA_PATH = 'schema-env.graphql';\n    mockConfig(`\n        schema: \\${SCHEMA_PATH}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('schema-env.graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate multiple environmental variables in YML",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 206,
                "column": 64
            },
            "line": 206,
            "code": "  it('Should interpolate multiple environmental variables in YML', async () => {\n    process.env.SCHEMA_SCHEME = 'https';\n    process.env.SCHEMA_HOST = 'localhost';\n    mockConfig(`\n        schema: \\${SCHEMA_SCHEME}://\\${SCHEMA_HOST}/graphql\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('https://localhost/graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML and support default value",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 221,
                "column": 81
            },
            "line": 221,
            "code": "  it('Should interpolate environmental variables in YML and support default value', async () => {\n    process.env.SCHEMA_PATH = '';\n\n    mockConfig(`\n        schema: \\${SCHEMA_PATH:schema.graphql}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('schema.graphql');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should interpolate environmental variables in YML and support default value containing \":\"",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 236,
                "column": 96
            },
            "line": 236,
            "code": "  it('Should interpolate environmental variables in YML and support default value containing \":\"', async () => {\n    process.env.SCHEMA_PATH = '';\n\n    mockConfig(`\n        schema: \\${SCHEMA_PATH:http://url-to-graphql-api}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--overwrite');\n    const context = await createContext(parseArgv(args));\n    const config = context.getConfig();\n    expect(config.schema).toBe('http://url-to-graphql-api');\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load require extensions provided by cli flags",
            "suites": [
                "CLI Flags"
            ],
            "updatePoint": {
                "line": 251,
                "column": 58
            },
            "line": 251,
            "code": "  it('Should load require extensions provided by cli flags', async () => {\n    process.env.SCHEMA_PATH = 'schema-env.graphql';\n    mockConfig(`\n        schema: \\${SCHEMA_PATH}\n        generates:\n            file.ts:\n                - plugin\n    `);\n    const args = createArgv('--require my-extension');\n\n    try {\n      await createContext(parseArgv(args));\n      expect(true).toBeFalsy();\n    } catch (e) {\n      expect(e.code).toEqual('MODULE_NOT_FOUND');\n    }\n  });",
            "file": "cli-flags.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should output the correct filenames",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 24,
                "column": 43
            },
            "line": 24,
            "code": "    it('Should output the correct filenames', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n          'out2.ts': { plugins: ['typescript'] },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output.map(f => f.filename)).toEqual(expect.arrayContaining(['out1.ts', 'out2.ts']));\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load require extensions",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 37,
                "column": 38
            },
            "line": 37,
            "code": "    it('Should load require extensions', async () => {\n      expect((global as any).dummyWasLoaded).toBeFalsy();\n      const output = await executeCodegen({\n        schema: join(__dirname, './test-files/schema-dir/schema-object.js'),\n        require: join(__dirname, './dummy-require.js'),\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n        },\n        cwd: __dirname,\n      });\n\n      expect(output.length).toBe(1);\n      expect((global as any).dummyWasLoaded).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when require extension is invalid",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 52,
                "column": 54
            },
            "line": 52,
            "code": "    it('Should throw when require extension is invalid', async () => {\n      try {\n        await executeCodegen({\n          schema: join(__dirname, './test-files/schema-dir/schema-object.js'),\n          require: join(__dirname, './missing.js'),\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n          cwd: __dirname,\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept plugins as object",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 69,
                "column": 39
            },
            "line": 69,
            "code": "    it('Should accept plugins as object', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {},\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept plugins as array of objects",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 88,
                "column": 49
            },
            "line": 88,
            "code": "    it('Should accept plugins as array of objects', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [{ 'typescript-operations': {} }],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when no output files has been specified",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 103,
                "column": 60
            },
            "line": 103,
            "code": "    it('Should throw when no output files has been specified', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {},\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toBe('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should work with just schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 117,
                "column": 36
            },
            "line": 117,
            "code": "    it('Should work with just schema', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should not throw when every output has a schema and there is no root schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 130,
                "column": 83
            },
            "line": 130,
            "code": "    it('Should not throw when every output has a schema and there is no root schema', async () => {\n      try {\n        const output = await executeCodegen({\n          generates: {\n            'out.ts': {\n              schema: SIMPLE_TEST_SCHEMA,\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        expect(output.length).toBe(1);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).not.toBe('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when there is no root schema and some outputs have not defined its own schema",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 148,
                "column": 98
            },
            "line": 148,
            "code": "    it('Should throw when there is no root schema and some outputs have not defined its own schema', async () => {\n      try {\n        await executeCodegen({\n          generates: {\n            'out.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).toBe('Invalid Codegen Configuration!');\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when one output has no plugins defined",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 165,
                "column": 59
            },
            "line": 165,
            "code": "    it('Should throw when one output has no plugins defined', async () => {\n      try {\n        await executeCodegen({\n          generates: {\n            'out.ts': {\n              plugins: [],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toBe('Invalid Codegen Configuration!');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle extend keyword when GraphQLSchema is used",
            "suites": [
                "Codegen Executor",
                "Generator General Options"
            ],
            "updatePoint": {
                "line": 182,
                "column": 63
            },
            "line": 182,
            "code": "    it('should handle extend keyword when GraphQLSchema is used', async () => {\n      const output = await executeCodegen({\n        schema: './tests/test-files/schema-dir/with-extend.js',\n        generates: {\n          'out.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].filename).toBe('out.ts');\n      expect(output[0].content).toContain(`hello?: Maybe<Scalars['String']>`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to specify schema extension for specific output",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 199,
                "column": 68
            },
            "line": 199,
            "code": "    it('Should allow to specify schema extension for specific output', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            schema: `\n              type OtherType { a: String }\n            `,\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type Query');\n      expect(output[0].content).toContain('export type MyType');\n      expect(output[0].content).toContain('export type OtherType');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to specify documents extension for specific output",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 218,
                "column": 71
            },
            "line": 218,
            "code": "    it('Should allow to specify documents extension for specific output', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            documents: `query q { f }`,\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type QQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should extend existing documents",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 233,
                "column": 40
            },
            "line": 233,
            "code": "    it('Should extend existing documents', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            documents: `query q { f }`,\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type QQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw on duplicated names",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 249,
                "column": 40
            },
            "line": 249,
            "code": "    it('Should throw on duplicated names', async () => {\n      try {\n        await executeCodegen({\n          schema: `\n            type RootQuery { f: String }\n            schema { query: RootQuery }\n          `,\n          documents: [`query q { e }`, `query q { f }`],\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n        });\n        throw SHOULD_NOT_THROW_STRING;\n      } catch (e) {\n        expect(e).not.toEqual(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('Not all operations have an unique name: q');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in ts with with nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 268,
                "column": 61
            },
            "line": 268,
            "code": "    it('should handle gql tag in ts with with nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/my-fragment.ts', './tests/test-documents/query-with-my-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in ts with with multiple nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 282,
                "column": 70
            },
            "line": 282,
            "code": "    it('should handle gql tag in ts with with multiple nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/my-fragment.ts', './tests/test-documents/query-with-my-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle gql tag in js with with nested fragment",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 297,
                "column": 61
            },
            "line": 297,
            "code": "    it('should handle gql tag in js with with nested fragment', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/js-query-with-my-fragment.js', './tests/test-documents/js-my-fragment.js'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle TypeScript features",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 312,
                "column": 41
            },
            "line": 312,
            "code": "    it('should handle TypeScript features', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/ts-features-with-query.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].content).toContain('MyQueryInNamespace');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle multiple fragments with the same name, but one is commented out",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 328,
                "column": 85
            },
            "line": 328,
            "code": "    it('should handle multiple fragments with the same name, but one is commented out', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/query-with-commented-fragment.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n      expect(result[0].content).toContain('MyQuery');\n      expect(result[0].filename).toEqual('out1.ts');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle graphql-tag and gatsby by default (documents)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 342,
                "column": 67
            },
            "line": 342,
            "code": "    it('should handle graphql-tag and gatsby by default (documents)', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/gatsby-and-custom-parsers.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toContain('FragmentA'); // import gql from 'graphql-tag'\n      expect(result[0].content).toContain('FragmentB'); // import { graphql } from 'gatsby'\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle custom graphql string parsers (documents)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "updatePoint": {
                "line": 357,
                "column": 63
            },
            "line": 357,
            "code": "    it('should handle custom graphql string parsers (documents)', async () => {\n      const result = await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: ['./tests/test-documents/gatsby-and-custom-parsers.ts'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n        pluckConfig: {\n          modules: [\n            {\n              name: 'custom-graphql-parser',\n              identifier: 'parser',\n            },\n          ],\n        },\n      });\n\n      expect(result[0].content).toContain('FragmentC'); // import { parser } from 'custom-graphql-parser';\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle graphql-tag and gatsby by default (schema)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "line": 380,
            "code": "    it.skip('should handle graphql-tag and gatsby by default (schema)', async () => {",
            "file": "codegen.spec.ts",
            "skipped": true,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should handle custom graphql string parsers (schema)",
            "suites": [
                "Codegen Executor",
                "Per-output options"
            ],
            "line": 396,
            "code": "    it.skip('should handle custom graphql string parsers (schema)', async () => {",
            "file": "codegen.spec.ts",
            "skipped": true,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should inherit root config",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 421,
                "column": 34
            },
            "line": 421,
            "code": "    it('Should inherit root config', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        config: {\n          namingConvention: 'change-case-all#lowerCase',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type rootquery');\n      expect(output[0].content).toContain('export type root');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept config in per-output (override)",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 440,
                "column": 53
            },
            "line": 440,
            "code": "    it('Should accept config in per-output (override)', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            config: {\n              namingConvention: 'change-case-all#lowerCase',\n            },\n            plugins: ['typescript', 'typescript-operations'],\n          },\n          'out2.ts': {\n            config: {\n              namingConvention: 'change-case-all#upperCase',\n            },\n            plugins: ['typescript', 'typescript-operations'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output[0].content).toContain('export type rootquery');\n      expect(output[1].content).toContain('export type ROOTQUERY');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should accept config in per-plugin",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 465,
                "column": 42
            },
            "line": 465,
            "code": "    it('Should accept config in per-plugin', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#lowerCase',\n                },\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('export type root');\n      expect(output[0].content).toContain('export type rootquery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow override of config in",
            "suites": [
                "Codegen Executor",
                "Plugin Configuration"
            ],
            "updatePoint": {
                "line": 487,
                "column": 42
            },
            "line": 487,
            "code": "    it('Should allow override of config in', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        documents: `query root { f }`,\n        config: {\n          namingConvention: 'change-case-all#lowerCase',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#upperCase',\n                },\n              },\n            ],\n          },\n          'out2.ts': {\n            plugins: [\n              {\n                'typescript-operations': {\n                  namingConvention: 'change-case-all#pascalCase',\n                },\n              },\n            ],\n          },\n        },\n      });\n\n      expect(output.length).toBe(2);\n      expect(output[0].content).toContain('export type ROOTQUERY');\n      expect(output[1].content).toContain('export type RootQuery');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should load custom plugin from local file",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 523,
                "column": 49
            },
            "line": 523,
            "code": "    it('Should load custom plugin from local file', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/basic.js'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toContain('plugin');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when custom plugin is not valid",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 537,
                "column": 52
            },
            "line": 537,
            "code": "    it('Should throw when custom plugin is not valid', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out1.ts': {\n              plugins: ['./tests/custom-plugins/invalid.js'],\n            },\n          },\n        });\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('Invalid Custom Plugin');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should execute custom plugin validation and throw when it fails",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 554,
                "column": 71
            },
            "line": 554,
            "code": "    it('Should execute custom plugin validation and throw when it fails', async () => {\n      try {\n        await executeCodegen({\n          schema: SIMPLE_TEST_SCHEMA,\n          generates: {\n            'out1.ts': {\n              plugins: ['./tests/custom-plugins/validation.js'],\n            },\n          },\n        });\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_NOT_THROW_STRING);\n        expect(e.message).toContain('validation failed');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 571,
                "column": 45
            },
            "line": 571,
            "code": "    it('Should allow plugins to extend schema', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema.js', './tests/custom-plugins/checks-extended-schema.js'],\n          },\n        },\n      });\n\n      expect(output[0].content).toContain('MyType,');\n      expect(output[0].content).toContain('Extension');\n      expect(output[0].content).toContain(`Should have the Extension type: 'Extension'`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema (using a function)",
            "suites": [
                "Codegen Executor",
                "Plugin loading"
            ],
            "updatePoint": {
                "line": 586,
                "column": 64
            },
            "line": 586,
            "code": "    it('Should allow plugins to extend schema (using a function)', async () => {\n      const output = await executeCodegen({\n        schema: SIMPLE_TEST_SCHEMA,\n        config: {\n          test: 'MyType',\n        },\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema-fn.js'],\n          },\n        },\n      });\n\n      expect(output[0].content).toContain('MyType');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep definitions of all directives",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 604,
                "column": 49
            },
            "line": 604,
            "code": "    it('should keep definitions of all directives', async () => {\n      const merged = buildASTSchema(\n        mergeTypeDefs([\n          buildSchema(SIMPLE_TEST_SCHEMA),\n          buildSchema(/* GraphQL */ `\n            directive @id on FIELD_DEFINITION\n\n            type Post {\n              id: String @id\n            }\n          `),\n        ])\n      );\n\n      expect(merged.getDirectives().map(({ name }) => name)).toContainEqual('id');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep directives in types",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 621,
                "column": 39
            },
            "line": 621,
            "code": "    it('should keep directives in types', async () => {\n      const merged = buildASTSchema(\n        mergeTypeDefs([\n          buildSchema(SIMPLE_TEST_SCHEMA),\n          buildSchema(/* GraphQL */ `\n            directive @id on FIELD_DEFINITION\n            directive @test on OBJECT\n\n            type Post @test {\n              id: String @id\n            }\n\n            type Query {\n              posts: [Post]\n            }\n\n            schema {\n              query: Query\n            }\n          `),\n        ])\n      );\n\n      expect(merged.getType('Post').astNode.directives.map(({ name }) => name.value)).toContainEqual('test');\n      expect(\n        (merged.getType('Post') as GraphQLObjectType).getFields().id.astNode.directives.map(({ name }) => name.value)\n      ).toContainEqual('id');\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep scalars",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 650,
                "column": 27
            },
            "line": 650,
            "code": "    it('should keep scalars', async () => {\n      const schemaA = SIMPLE_TEST_SCHEMA;\n      const schemaB = `\n        scalar UniqueID\n\n        type Post {\n          id: UniqueID\n        }\n      `;\n      const schemaC = parse(`\n        scalar NotUniqueID\n      `);\n\n      const merged = mergeTypeDefs([schemaA, schemaB, schemaC]);\n\n      expect(print(merged)).toContain('scalar UniqueID');\n      expect(print(merged)).toContain('scalar NotUniqueID');\n\n      const schema = buildASTSchema(merged);\n\n      expect(schema.getType('UniqueID')).toBeDefined();\n      expect(schema.getType('NotUniqueID')).toBeDefined();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should keep scalars when executing codegen",
            "suites": [
                "Codegen Executor",
                "Schema Merging"
            ],
            "updatePoint": {
                "line": 674,
                "column": 50
            },
            "line": 674,
            "code": "    it('should keep scalars when executing codegen', async () => {\n      const schemaA = SIMPLE_TEST_SCHEMA;\n      const schemaB = `\n        scalar UniqueID\n\n        type Post {\n          id: UniqueID\n        }\n      `;\n\n      const output = await executeCodegen({\n        schema: [schemaA, schemaB],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect(output.length).toBe(1);\n      expect(output[0].content).toBeSimilarStringTo(`export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        UniqueID: any;\n      };`);\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load schema on root level",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 706,
                "column": 64
            },
            "line": 706,
            "code": "    it('Should allow custom loaders to load schema on root level', async () => {\n      await executeCodegen({\n        schema: [\n          {\n            './tests/test-documents/schema.graphql': {\n              loader: './tests/custom-loaders/custom-schema-loader.js',\n            },\n          },\n        ],\n        generates: {\n          'out1.ts': { plugins: ['typescript'] },\n        },\n      });\n\n      expect((global as any).CUSTOM_SCHEMA_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load schema on output level",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 723,
                "column": 66
            },
            "line": 723,
            "code": "    it('Should allow custom loaders to load schema on output level', async () => {\n      await executeCodegen({\n        generates: {\n          'out1.ts': {\n            schema: [\n              {\n                './tests/test-documents/schema.graphql': {\n                  loader: './tests/custom-loaders/custom-schema-loader.js',\n                },\n              },\n            ],\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_SCHEMA_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid return value from loader",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 742,
                "column": 58
            },
            "line": 742,
            "code": "    it('Should throw when invalid return value from loader', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/invalid-return-value-schema-loader.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': { plugins: ['typescript'] },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load schema');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid module specified as loader",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 763,
                "column": 60
            },
            "line": 763,
            "code": "    it('Should throw when invalid module specified as loader', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/non-existing.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid file declaration",
            "suites": [
                "Codegen Executor",
                "Custom schema loader"
            ],
            "updatePoint": {
                "line": 786,
                "column": 50
            },
            "line": 786,
            "code": "    it('Should throw when invalid file declaration', async () => {\n      try {\n        await executeCodegen({\n          schema: [\n            {\n              './tests/test-documents/schema.graphql': {\n                loader: './tests/custom-loaders/invalid-export.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load schema');\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow to use custom documents loader on root level",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 812,
                "column": 65
            },
            "line": 812,
            "code": "    it('Should allow to use custom documents loader on root level', async () => {\n      await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        documents: [\n          {\n            './tests/test-documents/valid.graphql': {\n              loader: './tests/custom-loaders/custom-documents-loader.js',\n            },\n          },\n        ],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_DOCUMENT_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow custom loaders to load documents on output level",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 832,
                "column": 69
            },
            "line": 832,
            "code": "    it('Should allow custom loaders to load documents on output level', async () => {\n      await executeCodegen({\n        schema: ['./tests/test-documents/schema.graphql'],\n        generates: {\n          'out1.ts': {\n            documents: [\n              {\n                './tests/test-documents/valid.graphql': {\n                  loader: join(__dirname, './custom-loaders/custom-documents-loader.js'),\n                },\n              },\n            ],\n            plugins: ['typescript'],\n          },\n        },\n      });\n\n      expect((global as any).CUSTOM_DOCUMENT_LOADER_CALLED).toBeTruthy();\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid return value from custom documents loader",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 852,
                "column": 75
            },
            "line": 852,
            "code": "    it('Should throw when invalid return value from custom documents loader', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/invalid-return-value-documents-loader.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Unable to find any GraphQL type definitions for the following pointers');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid module specified as loader",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 876,
                "column": 60
            },
            "line": 876,
            "code": "    it('Should throw when invalid module specified as loader', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/non-existing.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should throw when invalid file declaration",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 900,
                "column": 50
            },
            "line": 900,
            "code": "    it('Should throw when invalid file declaration', async () => {\n      try {\n        await executeCodegen({\n          schema: ['./tests/test-documents/schema.graphql'],\n          documents: [\n            {\n              './tests/test-documents/valid.graphql': {\n                loader: './tests/custom-loaders/invalid-export.js',\n              },\n            },\n          ],\n          generates: {\n            'out1.ts': {\n              plugins: ['typescript'],\n            },\n          },\n        });\n\n        throw new Error(SHOULD_NOT_THROW_STRING);\n      } catch (error) {\n        expect(error.message).toContain('Failed to load custom loader');\n      }\n    });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should load schema with custom fetch",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 925,
                "column": 42
            },
            "line": 925,
            "code": "  it('should load schema with custom fetch', async () => {\n    try {\n      await executeCodegen({\n        schema: ['http://www.dummyschema.com/graphql'],\n        customFetch: 'some-fetch#someFetchFn',\n        documents: ['./tests/test-documents/valid.graphql'],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n    } catch (error) {\n      expect(error.message).toContain('Failed to load schema from http://www.dummyschema.com/graphql');\n    }\n    expect((global as any).CUSTOM_FETCH_FN_CALLED).toBeTruthy();\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should evaluate glob expressions correctly",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 943,
                "column": 48
            },
            "line": 943,
            "code": "  it('should evaluate glob expressions correctly', async () => {\n    try {\n      await executeCodegen({\n        schema: ['./tests/test-documents/*schema.graphql', '!./tests/test-documents/invalid-schema.graphql'],\n        documents: [\n          './tests/test-documents/*.graphql',\n          '!./tests/test-documents/invalid-*.graphql',\n          '!./tests/test-documents/unused-*.graphql',\n        ],\n        generates: {\n          'out1.ts': {\n            plugins: ['typescript'],\n          },\n        },\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n      throw new Error('This should not throw as the invalid file is excluded via glob.');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugins to extend schema with custom root",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 965,
                "column": 60
            },
            "line": 965,
            "code": "  it('Should allow plugins to extend schema with custom root', async () => {\n    try {\n      const output = await executeCodegen({\n        schema: `schema { query: RootQuery } type MyType { f: String } type RootQuery { f: String }`,\n        documents: `query root { f }`,\n        generates: {\n          'out1.ts': {\n            plugins: ['./tests/custom-plugins/extends-schema.js', './tests/custom-plugins/checks-extended-schema.js'],\n          },\n        },\n      });\n      expect(output.length).toBe(1);\n    } catch (e) {\n      expect(e.message).not.toBe('Query root type must be provided.');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should allow plugin context to be accessed and modified",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 982,
                "column": 61
            },
            "line": 982,
            "code": "  it('Should allow plugin context to be accessed and modified', async () => {\n    const output = await executeCodegen({\n      schema: [\n        {\n          './tests/test-documents/schema.graphql': {\n            loader: './tests/custom-loaders/custom-schema-loader-with-context.js',\n          },\n        },\n      ],\n      generates: {\n        'out1.ts': {\n          plugins: ['./tests/custom-plugins/context.js'],\n        },\n      },\n    });\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toContain('Hello world!');\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should sort the input schema",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1002,
                "column": 34
            },
            "line": 1002,
            "code": "  it('Should sort the input schema', async () => {\n    const nonSortedSchema = /* GraphQL */ `\n      type Query {\n        d: String\n        z: String\n        a: String\n      }\n\n      type User {\n        aa: String\n        a: String\n      }\n\n      type A {\n        s: String\n        b: String\n      }\n    `;\n    const output = await executeCodegen({\n      schema: [nonSortedSchema],\n      generates: {\n        'out1.graphql': {\n          plugins: ['schema-ast'],\n        },\n      },\n      config: {\n        sort: true,\n      },\n    });\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toBeSimilarStringTo(/* GraphQL */ `\n      type A {\n        b: String\n        s: String\n      }\n\n      type Query {\n        a: String\n        d: String\n        z: String\n      }\n\n      type User {\n        a: String\n        aa: String\n      }\n    `);\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Handles weird errors due to invalid schema",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1052,
                "column": 48
            },
            "line": 1052,
            "code": "  it('Handles weird errors due to invalid schema', async () => {\n    const schema = /* GraphQL */ `\n      type Query {\n        brrrt:1\n      }\n    `;\n    try {\n      await executeCodegen({\n        schema: [schema],\n        generates: {\n          'out1.graphql': {\n            plugins: ['schema-ast'],\n          },\n        },\n      });\n    } catch (error) {\n      expect(error.message).toContain('Failed to load schema for \"out1.graphql\"');\n    }\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should generate documents output even if prj1/documents and prj1/extensions/codegen/generate/xxx/documents are both definded with the same glob files",
            "suites": [
                "Codegen Executor",
                "Custom documents loader"
            ],
            "updatePoint": {
                "line": 1072,
                "column": 155
            },
            "line": 1072,
            "code": "  it('Should generate documents output even if prj1/documents and prj1/extensions/codegen/generate/xxx/documents are both definded with the same glob files', async () => {\n    const prj1 = await createContext({\n      config: './tests/test-files/graphql.config.js',\n      project: 'prj1',\n      errorsOnly: true,\n      overwrite: true,\n      profile: true,\n      require: [],\n      silent: false,\n      watch: false,\n    });\n    const config = prj1.getConfig();\n    const output = await executeCodegen(config);\n    expect(output[0].content).toContain('DocumentNode<MyQueryQuery, MyQueryQueryVariables>');\n  });",
            "file": "codegen.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "allow to specify overwrite for specific output (should write file)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 22,
                "column": 74
            },
            "line": 22,
            "code": "  test('allow to specify overwrite for specific output (should write file)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: false,\n        generates: {\n          [filename]: {\n            overwrite: true,\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it writes a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "allow to specify overwrite for specific output (should not write file)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 48,
                "column": 78
            },
            "line": 48,
            "code": "  test('allow to specify overwrite for specific output (should not write file)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    // forces file to exist\n    const fileExistsSpy = jest.spyOn(fs, 'fileExists');\n    fileExistsSpy.mockImplementation(async file => file === filename);\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: true,\n        generates: {\n          [filename]: {\n            overwrite: false,\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it checks if file is there\n    expect(fileExistsSpy).toHaveBeenCalledWith(filename);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).not.toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use global overwrite option and write a file",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 79,
                "column": 59
            },
            "line": 79,
            "code": "  test('should use global overwrite option and write a file', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: true,\n        generates: {\n          [filename]: {\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it writes a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use global overwrite option and not write a file",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 104,
                "column": 63
            },
            "line": 104,
            "code": "  test('should use global overwrite option and not write a file', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    // forces file to exist\n    const fileExistsSpy = jest.spyOn(fs, 'fileExists');\n    fileExistsSpy.mockImplementation(async file => file === filename);\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        overwrite: false,\n        generates: {\n          [filename]: {\n            schema: `\n            type OtherType { a: String }\n          `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it checks if file is there\n    expect(fileExistsSpy).toHaveBeenCalledWith(filename);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).not.toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should overwrite a file by default",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 134,
                "column": 42
            },
            "line": 134,
            "code": "  test('should overwrite a file by default', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n    const readSpy = jest.spyOn(fs, 'readFile').mockImplementation();\n    readSpy.mockImplementation(async _f => '');\n    // forces file to exist\n    const fileExistsSpy = jest.spyOn(fs, 'fileExists');\n    fileExistsSpy.mockImplementation(async file => file === filename);\n\n    const output = await generate(\n      {\n        schema: SIMPLE_TEST_SCHEMA,\n        generates: {\n          [filename]: {\n            schema: /* GraphQL */ `\n              type OtherType {\n                a: String\n              }\n            `,\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    // makes sure it doesn't write a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should override generated files",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 165,
                "column": 39
            },
            "line": 165,
            "code": "  test('should override generated files', async () => {\n    jest.unmock('fs');\n    const fs = await import('fs');\n\n    makeDir.sync(dirname(outputFile));\n    if (fs.existsSync(outputFile)) {\n      fs.unlinkSync(outputFile);\n    }\n    fs.writeFileSync(\n      inputFile,\n      `\n    import gql from 'graphql-tag';\n    const MyQuery = gql\\`query MyQuery { f }\\`;\n  `,\n      {}\n    );\n    const generateOnce: () => Promise<Types.FileOutput[]> = () =>\n      generate(\n        {\n          schema: SIMPLE_TEST_SCHEMA,\n          documents: inputFile,\n          generates: {\n            [outputFile]: {\n              plugins: ['typescript', 'typescript-operations', 'typescript-react-apollo'],\n            },\n          },\n        },\n        true\n      );\n    const [firstOutput] = await generateOnce();\n    fs.writeFileSync(firstOutput.filename, firstOutput.content);\n    await generateOnce();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should extract a document from the gql tag (imported from apollo-server)",
            "suites": [
                "generate-and-save"
            ],
            "updatePoint": {
                "line": 198,
                "column": 80
            },
            "line": 198,
            "code": "  test('should extract a document from the gql tag (imported from apollo-server)', async () => {\n    const filename = 'overwrite.ts';\n    const writeSpy = jest.spyOn(fs, 'writeFile').mockImplementation();\n\n    const output = await generate(\n      {\n        schema: `./tests/test-files/schema-dir/gatsby-and-custom-parsers/apollo-server.ts`,\n        generates: {\n          [filename]: {\n            plugins: ['typescript'],\n          },\n        },\n      },\n      true\n    );\n\n    expect(output.length).toBe(1);\n    expect(output[0].content).toMatch('Used apollo-server');\n    // makes sure it doesn't write a new file\n    expect(writeSpy).toHaveBeenCalled();\n  });",
            "file": "generate-and-save.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess angular projects",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 66,
                "column": 35
            },
            "line": 66,
            "code": "  it('should guess angular projects', async () => {\n    require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n    const targets = await guessTargets();\n    expect(targets.Angular).toEqual(true);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess typescript projects",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 72,
                "column": 38
            },
            "line": 72,
            "code": "  it('should guess typescript projects', async () => {\n    require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withTypescript);\n    const targets = await guessTargets();\n    expect(targets.TypeScript).toEqual(true);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess react projects",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 78,
                "column": 33
            },
            "line": 78,
            "code": "  it('should guess react projects', async () => {\n    require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n    const targets = await guessTargets();\n    expect(targets.React).toEqual(true);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess stencil projects",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 84,
                "column": 35
            },
            "line": 84,
            "code": "  it('should guess stencil projects', async () => {\n    require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withStencil);\n    const targets = await guessTargets();\n    expect(targets.Stencil).toEqual(true);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should guess flow projects",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 90,
                "column": 32
            },
            "line": 90,
            "code": "  it('should guess flow projects', async () => {\n    require('fs').__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withFlow);\n    const targets = await guessTargets();\n    expect(targets.Flow).toEqual(true);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use angular related plugins when @angular/core is found",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 96,
                "column": 68
            },
            "line": 96,
            "code": "  it('should use angular related plugins when @angular/core is found', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    // silent\n    jest.spyOn(console, 'log').mockImplementation();\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [ENTER], // use default\n      onDocuments: [ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n\n    // should use default output path\n    expect(config.generates['src/generated/graphql.ts']).toBeDefined();\n\n    const output: any = config.generates['src/generated/graphql.ts'];\n    expect(output.plugins).toContainEqual('typescript');\n    expect(output.plugins).toContainEqual('typescript-operations');\n    expect(output.plugins).toContainEqual('typescript-apollo-angular');\n    expect(output.plugins).toHaveLength(3);\n\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-operations');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-apollo-angular');\n    // should not have other plugins\n    expect(Object.keys(pkg.devDependencies)).toHaveLength(4);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use react related plugins when react is found",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 139,
                "column": 58
            },
            "line": 139,
            "code": "  it('should use react related plugins when react is found', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withReact);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    // silent\n    jest.spyOn(console, 'log').mockImplementation();\n\n    useInputs({\n      onTarget: [ENTER], // confirm react target\n      onSchema: [ENTER], // use default\n      onDocuments: [ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n\n    // should use default output path\n    expect(config.generates['src/generated/graphql.tsx']).toBeDefined();\n\n    const output: any = config.generates['src/generated/graphql.tsx'];\n    expect(output.plugins).toContainEqual('typescript');\n    expect(output.plugins).toContainEqual('typescript-operations');\n    expect(output.plugins).toContainEqual('typescript-react-apollo');\n    expect(output.plugins).toHaveLength(3);\n\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-operations');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-react-apollo');\n    // should not have other plugins\n    expect(Object.keys(pkg.devDependencies)).toHaveLength(4);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use stencil related plugins when @stencil/core is found",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 182,
                "column": 68
            },
            "line": 182,
            "code": "  it('should use stencil related plugins when @stencil/core is found', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withStencil);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    // silent\n    jest.spyOn(console, 'log').mockImplementation();\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [ENTER], // use default\n      onDocuments: [ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n\n    // should use default output path\n    expect(config.generates['src/generated/graphql.tsx']).toBeDefined();\n\n    const output: any = config.generates['src/generated/graphql.tsx'];\n    expect(output.plugins).toContainEqual('typescript');\n    expect(output.plugins).toContainEqual('typescript-operations');\n    expect(output.plugins).toContainEqual('typescript-stencil-apollo');\n    expect(output.plugins).toHaveLength(3);\n\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-operations');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-stencil-apollo');\n    // should not have other plugins\n    expect(Object.keys(pkg.devDependencies)).toHaveLength(4);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should use typescript related plugins when typescript is found (node)",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 225,
                "column": 75
            },
            "line": 225,
            "code": "  it('should use typescript related plugins when typescript is found (node)', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withTypescript);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    // silent\n    jest.spyOn(console, 'log').mockImplementation();\n\n    useInputs({\n      onTarget: [SELECT, ENTER], // confirm api target\n      onSchema: [ENTER], // use default\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n\n    // should use default output path\n    expect(config.generates['src/generated/graphql.ts']).toBeDefined();\n\n    const output: any = config.generates['src/generated/graphql.ts'];\n    expect(output.plugins).toContainEqual('typescript');\n    expect(output.plugins).toContainEqual('typescript-resolvers');\n    expect(output.plugins).toHaveLength(2);\n\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-resolvers');\n    // should not have other plugins\n    expect(Object.keys(pkg.devDependencies)).toHaveLength(4); // 3 - because we have typescript package in devDeps\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should have few default values",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 265,
                "column": 36
            },
            "line": 265,
            "code": "  it('should have few default values', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const defaults = {\n      schema: 'http://localhost:4000',\n      documents: 'src/**/*.graphql',\n      output: 'src/generated/graphql.ts',\n      config: 'codegen.yml',\n    };\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [ENTER], // use default\n      onDocuments: [ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: ['graphql', ENTER], // use custom npm script\n    });\n\n    await init();\n\n    const configFile = writeFileSpy.mock.calls[0][0] as string;\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n\n    expect(pkg.scripts.graphql).toEqual(`graphql-codegen --config ${defaults.config}`);\n    expect(configFile).toEqual(resolve(process.cwd(), defaults.config));\n    expect(config.overwrite).toEqual(true);\n    expect(config.schema).toEqual(defaults.schema);\n    expect(config.documents).toEqual(defaults.documents);\n    expect(config.generates[defaults.output]).toBeDefined();\n    expect(logSpy.mock.calls[2][0]).toContain(`Config file generated at ${bold(defaults.config)}`);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should have few default values",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 304,
                "column": 36
            },
            "line": 304,
            "code": "  it('should have few default values', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const options = {\n      script: 'graphql',\n      schema: './schema.ts',\n      documents: 'graphql/**/*.graphql',\n      output: 'graphql/index.ts',\n      config: 'app-codegen.yml',\n    };\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [options.schema, ENTER], // use default\n      onDocuments: [options.documents, ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [options.output, ENTER], // use default output path\n      onIntrospection: ['n', ENTER], // no introspection,\n      onConfig: [options.config, ENTER], // use default config path\n      onScript: [options.script, ENTER], // use custom npm script\n    });\n\n    await init();\n\n    const configFile = writeFileSpy.mock.calls[0][0] as string;\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n\n    expect(pkg.scripts[options.script]).toEqual(`graphql-codegen --config ${options.config}`);\n    expect(configFile).toEqual(resolve(process.cwd(), options.config));\n    expect(config.overwrite).toEqual(true);\n    expect(config.schema).toEqual(options.schema);\n    expect(config.documents).toEqual(options.documents);\n    expect(config.generates[options.output]).toBeDefined();\n    expect(logSpy.mock.calls[2][0]).toContain(`Config file generated at ${bold(options.config)}`);\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "custom setup",
            "suites": [
                "init"
            ],
            "updatePoint": {
                "line": 344,
                "column": 18
            },
            "line": 344,
            "code": "  it('custom setup', async () => {\n    const fs = require('fs');\n    fs.__setMockFiles(resolve(process.cwd(), 'package.json'), packageJson.withAngular);\n    // make sure we don't write stuff\n    const writeFileSpy = jest.spyOn(fs, 'writeFileSync').mockImplementation();\n    const logSpy = jest.spyOn(console, 'log').mockImplementation();\n    const documents = 'graphql/*.ts';\n    const script = 'generate:types';\n\n    useInputs({\n      onTarget: [ENTER], // confirm angular target\n      onSchema: [ENTER], // use default\n      onDocuments: [documents, ENTER],\n      onPlugins: [ENTER], // use selected packages\n      onOutput: [ENTER], // use default output path\n      onIntrospection: ['y', ENTER], // no introspection,\n      onConfig: [ENTER], // use default config path\n      onScript: [script, ENTER], // use custom npm script\n    });\n\n    await init();\n\n    expect(writeFileSpy).toHaveBeenCalledTimes(2);\n\n    const pkg = JSON.parse(writeFileSpy.mock.calls[1][1] as string);\n    const config = load(writeFileSpy.mock.calls[0][1] as string) as Record<string, any>;\n\n    // config\n    // should overwrite\n    expect(config.overwrite).toEqual(true);\n    // should match default schema\n    expect(config.schema).toEqual('http://localhost:4000');\n    // should match documents glob that we provided\n    expect(config.documents).toEqual(documents);\n    // should use default output path\n    expect(config.generates['src/generated/graphql.ts']).toBeDefined();\n    // should include introspection\n    expect(config.generates['./graphql.schema.json']).toBeDefined();\n\n    const output: any = config.generates['src/generated/graphql.ts'];\n    expect(output.plugins).toContainEqual('typescript');\n    expect(output.plugins).toContainEqual('typescript-operations');\n    expect(output.plugins).toContainEqual('typescript-apollo-angular');\n\n    // script name should match what we provided\n    expect(pkg.scripts[script]).toEqual('graphql-codegen --config codegen.yml');\n    // expected plugins\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-operations');\n    expect(pkg.devDependencies).toHaveProperty('@graphql-codegen/typescript-apollo-angular');\n    // should not have these plugins\n    expect(pkg.devDependencies).not.toHaveProperty('@graphql-codegen/typescript-resolvers');\n\n    // logs\n    const welcomeMsg = logSpy.mock.calls[0][0];\n    const doneMsg = logSpy.mock.calls[2][0];\n\n    expect(welcomeMsg).toContain(`Welcome to ${bold('GraphQL Code Generator')}`);\n    expect(doneMsg).toContain(`Config file generated at ${bold('codegen.yml')}`);\n    expect(doneMsg).toContain(bold('$ npm install'));\n    expect(doneMsg).toContain(bold(`$ npm run ${script}`));\n  });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 442,
                "column": 12
            },
            "line": 442,
            "code": "    it('node', () => {\n      const { available, selected } = getPlugins([Tags.node]);\n\n      // available\n      expect(available).toHaveLength(6);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-resolvers');\n      expect(available).toContainEqual('typescript-mongodb');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-resolvers');\n      // selected\n      expect(selected).toHaveLength(0);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node + typescript",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 457,
                "column": 25
            },
            "line": 457,
            "code": "    it('node + typescript', () => {\n      const { selected, available } = getPlugins([Tags.node, Tags.typescript]);\n\n      // available\n      expect(available).toHaveLength(4);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-resolvers');\n      expect(available).toContainEqual('typescript-mongodb');\n      expect(available).toContainEqual('typescript-document-nodes');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-resolvers');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "node + flow",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 472,
                "column": 19
            },
            "line": 472,
            "code": "    it('node + flow', () => {\n      const { selected, available } = getPlugins([Tags.node, Tags.flow]);\n\n      // available\n      expect(available).toHaveLength(2);\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-resolvers');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('flow');\n      expect(selected).toContainEqual('flow-resolvers');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "angular",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 485,
                "column": 15
            },
            "line": 485,
            "code": "    it('angular', () => {\n      const { selected, available } = getPlugins([Tags.angular]);\n\n      // available\n      expect(available).toHaveLength(7);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-apollo-angular');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(3);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-operations');\n      expect(selected).toContainEqual('typescript-apollo-angular');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "react",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 503,
                "column": 13
            },
            "line": 503,
            "code": "    it('react', () => {\n      const { selected, available } = getPlugins([Tags.react]);\n\n      // available\n      expect(available).toHaveLength(9);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-react-apollo');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-operations');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(3);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-operations');\n      expect(selected).toContainEqual('typescript-react-apollo');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "react + typescript",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 522,
                "column": 26
            },
            "line": 522,
            "code": "    it('react + typescript', () => {\n      const { selected, available } = getPlugins([Tags.react, Tags.typescript]);\n\n      // available\n      expect(available).toHaveLength(7);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-react-apollo');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(3);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-operations');\n      expect(selected).toContainEqual('typescript-react-apollo');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "react + flow",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 540,
                "column": 20
            },
            "line": 540,
            "code": "    it('react + flow', () => {\n      const { selected, available } = getPlugins([Tags.react, Tags.flow]);\n\n      // available\n      expect(available).toHaveLength(4);\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-operations');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(2);\n      expect(selected).toContainEqual('flow');\n      expect(selected).toContainEqual('flow-operations');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "stencil",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 554,
                "column": 15
            },
            "line": 554,
            "code": "    it('stencil', () => {\n      const { selected, available } = getPlugins([Tags.stencil]);\n\n      // available\n      expect(available).toHaveLength(7);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-stencil-apollo');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(3);\n      expect(selected).toContainEqual('typescript');\n      expect(selected).toContainEqual('typescript-operations');\n      expect(selected).toContainEqual('typescript-stencil-apollo');\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "vanilla",
            "suites": [
                "init",
                "plugin choices"
            ],
            "updatePoint": {
                "line": 572,
                "column": 15
            },
            "line": 572,
            "code": "    it('vanilla', () => {\n      const { selected, available } = getPlugins([Tags.browser]);\n\n      // available\n      expect(available).toHaveLength(8);\n      expect(available).toContainEqual('typescript');\n      expect(available).toContainEqual('typescript-operations');\n      expect(available).toContainEqual('typescript-graphql-files-modules');\n      expect(available).toContainEqual('typescript-document-nodes');\n      expect(available).toContainEqual('flow');\n      expect(available).toContainEqual('flow-operations');\n      expect(available).toContainEqual('fragment-matcher');\n      // selected\n      expect(selected).toHaveLength(0);\n    });",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "should have correct plugin and package names",
            "suites": [
                "init",
                "plugins"
            ],
            "updatePoint": {
                "line": 590,
                "column": 52
            },
            "line": 590,
            "code": "    it('should have correct plugin and package names', async () => {});",
            "file": "init.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-cli/tests"
        },
        {
            "name": "Should sort and use the correct order",
            "suites": [
                "sortPrependValues"
            ],
            "updatePoint": {
                "line": 3,
                "column": 43
            },
            "line": 3,
            "code": "  it('Should sort and use the correct order', () => {\n    const strings: string[] = [`import `, '/* comment */', `// This is a comment`];\n\n    const sorted = sortPrependValues(strings);\n\n    expect(sorted).toEqual(['/* comment */', `// This is a comment`, `import `]);\n  });",
            "file": "prepend.spec.ts",
            "skipped": false,
            "dir": "packages/graphql-codegen-core/tests"
        },
        {
            "name": "Should wrap generated code block in namespace using default name",
            "suites": [
                "C# Operations",
                "Namespaces"
            ],
            "updatePoint": {
                "line": 9,
                "column": 72
            },
            "line": 9,
            "code": "    it('Should wrap generated code block in namespace using default name', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('namespace GraphQLCodeGen {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should wrap generated code block in namespace using a custom name",
            "suites": [
                "C# Operations",
                "Namespaces"
            ],
            "updatePoint": {
                "line": 29,
                "column": 73
            },
            "line": 29,
            "code": "    it('Should wrap generated code block in namespace using a custom name', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n      const config: CSharpOperationsRawPluginConfig = {\n        namespaceName: 'MyCompany.MyGeneratedGql',\n      };\n      const result = (await plugin(schema, [{ location: '', document: operation }], config, {\n        outputFile: '',\n      })) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('namespace MyCompany.MyGeneratedGql {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should wrap each query operation in a class",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 51,
                "column": 51
            },
            "line": 51,
            "code": "    it('Should wrap each query operation in a class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n          you: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n        query findYou {\n          you\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('public class FindMeGQL {');\n      expect(result.content).toContain('public class FindYouGQL {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should escape string constants in c#",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 77,
                "column": 44
            },
            "line": 77,
            "code": "    it('Should escape string constants in c#', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me(a: String!): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me(a: \"test\")\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('me(a: \"\"test\"\")');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a document string containing original query operation",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 98,
                "column": 77
            },
            "line": 98,
            "code": "    it('Should generate a document string containing original query operation', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static string FindMeDocument = @\"\n          query findMe {\n            me\n          }\n        \";\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for query operations without input variables",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 125,
                "column": 83
            },
            "line": 125,
            "code": "    it('Should generate request method for query operations without input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request() {\n          return new GraphQLRequest {\n            Query = FindMeDocument,\n            OperationName = \"findMe\"\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for query operations with input variables",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 153,
                "column": 80
            },
            "line": 153,
            "code": "    it('Should generate request method for query operations with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMine($id: Int!) {\n          mine(id: $id)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request(object variables = null) {\n          return new GraphQLRequest {\n            Query = FindMineDocument,\n            OperationName = \"findMine\",\n            Variables = variables\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should mark original method signature obsolete",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 182,
                "column": 54
            },
            "line": 182,
            "code": "    it('Should mark original method signature obsolete', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <remarks>This method is obsolete. Use Request instead.</remarks>\n        public static GraphQLRequest getFindMeGQL() {\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate scalar response class",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 205,
                "column": 45
            },
            "line": 205,
            "code": "    it('Should generate scalar response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          [JsonProperty(\"me\")]\n          public int me { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate nested response class",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 229,
                "column": 45
            },
            "line": 229,
            "code": "    it('Should generate nested response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Person!\n        }\n        type Person {\n          name: String!\n          friendIds: [Int!]!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me {\n            friendIds\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          public class PersonSelection {\n            [JsonProperty(\"friendIds\")]\n            public System.Collections.Generic.List<int> friendIds { get; set; }\n          }\n          [JsonProperty(\"me\")]\n          public PersonSelection me { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate variable class",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 263,
                "column": 38
            },
            "line": 263,
            "code": "    it('Should generate variable class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMine($id: Int!) {\n          mine(id: $id)\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"id\")]\n          public int id { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method without input variables",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 287,
                "column": 60
            },
            "line": 287,
            "code": "    it('Should generate proxy method without input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.Threading.Tasks.Task<GraphQLResponse<Response>> SendQueryAsync(IGraphQLClient client, System.Threading.CancellationToken cancellationToken = default) {\n          return client.SendQueryAsync<Response>(Request(), cancellationToken);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method with input variables",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 310,
                "column": 57
            },
            "line": 310,
            "code": "    it('Should generate proxy method with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMine($id: Int!) {\n          mine(id: $id)\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.Threading.Tasks.Task<GraphQLResponse<Response>> SendQueryAsync(IGraphQLClient client, Variables variables, System.Threading.CancellationToken cancellationToken = default) {\n          return client.SendQueryAsync<Response>(Request(variables), cancellationToken);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should prefix with @ when name is a reserved keyword",
            "suites": [
                "C# Operations",
                "Query"
            ],
            "updatePoint": {
                "line": 333,
                "column": 60
            },
            "line": 333,
            "code": "    it('Should prefix with @ when name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          case(record: ID!): CourtCase!\n        }\n        type CourtCase {\n          operator: String!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findOperator($record: ID!) {\n          case(record: $record) {\n            operator\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"record\")]\n          public string @record { get; set; }\n        }\n        public class Response {\n          public class CourtCaseSelection {\n            [JsonProperty(\"operator\")]\n            public string @operator { get; set; }\n          }\n          [JsonProperty(\"case\")]\n          public CourtCaseSelection @case { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should wrap each mutation operation in a class",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 373,
                "column": 54
            },
            "line": 373,
            "code": "    it('Should wrap each mutation operation in a class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n          you: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n        mutation updateYou {\n          you\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('public class UpdateMeGQL {');\n      expect(result.content).toContain('public class UpdateYouGQL {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a document string containing original mutation operation",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 399,
                "column": 80
            },
            "line": 399,
            "code": "    it('Should generate a document string containing original mutation operation', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static string UpdateMeDocument = @\"\n          mutation updateMe {\n            me\n          }\n        \";\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for mutation operations without input variables",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 426,
                "column": 86
            },
            "line": 426,
            "code": "    it('Should generate request method for mutation operations without input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request() {\n          return new GraphQLRequest {\n            Query = UpdateMeDocument,\n            OperationName = \"updateMe\"\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for mutation operations with input variables",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 454,
                "column": 83
            },
            "line": 454,
            "code": "    it('Should generate request method for mutation operations with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMine($id: Int) {\n          mine(id: $id)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request(object variables = null) {\n          return new GraphQLRequest {\n            Query = UpdateMineDocument,\n            OperationName = \"updateMine\",\n            Variables = variables\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should mark original method signature obsolete",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 483,
                "column": 54
            },
            "line": 483,
            "code": "    it('Should mark original method signature obsolete', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <remarks>This method is obsolete. Use Request instead.</remarks>\n        public static GraphQLRequest getUpdateMeGQL() {\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate scalar response class",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 506,
                "column": 45
            },
            "line": 506,
            "code": "    it('Should generate scalar response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          [JsonProperty(\"me\")]\n          public int me { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate nested response class",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 530,
                "column": 45
            },
            "line": 530,
            "code": "    it('Should generate nested response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Person!\n        }\n        type Person {\n          name: String!\n          friendIds: [Int!]!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me {\n            friendIds\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          public class PersonSelection {\n            [JsonProperty(\"friendIds\")]\n            public System.Collections.Generic.List<int> friendIds { get; set; }\n          }\n          [JsonProperty(\"me\")]\n          public PersonSelection me { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate variable class",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 564,
                "column": 38
            },
            "line": 564,
            "code": "    it('Should generate variable class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMine($id: Int) {\n          mine(id: $id)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"id\")]\n          public int? id { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method without variables",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 589,
                "column": 54
            },
            "line": 589,
            "code": "    it('Should generate proxy method without variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMe {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.Threading.Tasks.Task<GraphQLResponse<Response>> SendMutationAsync(IGraphQLClient client, System.Threading.CancellationToken cancellationToken = default) {\n          return client.SendMutationAsync<Response>(Request(), cancellationToken);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method with input variables",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 613,
                "column": 57
            },
            "line": 613,
            "code": "    it('Should generate proxy method with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          mine(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateMine($id: Int) {\n          mine(id: $id)\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.Threading.Tasks.Task<GraphQLResponse<Response>> SendMutationAsync(IGraphQLClient client, Variables variables, System.Threading.CancellationToken cancellationToken = default) {\n          return client.SendMutationAsync<Response>(Request(variables), cancellationToken);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should prefix with @ when name is a reserved keyword",
            "suites": [
                "C# Operations",
                "Mutation"
            ],
            "updatePoint": {
                "line": 636,
                "column": 60
            },
            "line": 636,
            "code": "    it('Should prefix with @ when name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Mutation {\n          case(record: ID!): CourtCase!\n        }\n        type CourtCase {\n          operator: String!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        mutation updateCase($record: ID!) {\n          case(record: $record) {\n            operator\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"record\")]\n          public string @record { get; set; }\n        }\n        public class Response {\n          public class CourtCaseSelection {\n            [JsonProperty(\"operator\")]\n            public string @operator { get; set; }\n          }\n          [JsonProperty(\"case\")]\n          public CourtCaseSelection @case { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should wrap each subscription operation in a class",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 676,
                "column": 58
            },
            "line": 676,
            "code": "    it('Should wrap each subscription operation in a class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          you: Int!\n          them: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyYou {\n          you\n        }\n        subscription onNotifyThem {\n          them\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('public class OnNotifyYouGQL {');\n      expect(result.content).toContain('public class OnNotifyThemGQL {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a document string containing original subscription operation",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 702,
                "column": 84
            },
            "line": 702,
            "code": "    it('Should generate a document string containing original subscription operation', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          them: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThem {\n          them\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static string OnNotifyThemDocument = @\"\n          subscription onNotifyThem {\n            them\n          }\n        \";\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for subscription operations without input variables",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 729,
                "column": 90
            },
            "line": 729,
            "code": "    it('Should generate request method for subscription operations without input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          them: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThem {\n          them\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request() {\n          return new GraphQLRequest {\n            Query = OnNotifyThemDocument,\n            OperationName = \"onNotifyThem\"\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for subscription operations with input variables",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 757,
                "column": 87
            },
            "line": 757,
            "code": "    it('Should generate request method for subscription operations with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          those(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThose($id: Int!) {\n          those(id: $id)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static GraphQLRequest Request(object variables = null) {\n          return new GraphQLRequest {\n            Query = OnNotifyThoseDocument,\n            OperationName = \"onNotifyThose\",\n            Variables = variables\n          };\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should mark original method signature obsolete",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 786,
                "column": 54
            },
            "line": 786,
            "code": "    it('Should mark original method signature obsolete', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          them: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThem {\n          them\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <remarks>This method is obsolete. Use Request instead.</remarks>\n        public static GraphQLRequest getOnNotifyThemGQL() {\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate scalar response class",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 809,
                "column": 45
            },
            "line": 809,
            "code": "    it('Should generate scalar response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          you: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyYou {\n          you\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          [JsonProperty(\"you\")]\n          public int you { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate nested response class",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 833,
                "column": 45
            },
            "line": 833,
            "code": "    it('Should generate nested response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          you: Person!\n        }\n        type Person {\n          name: String!\n          friendIds: [Int!]!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyYou {\n          you {\n            friendIds\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          public class PersonSelection {\n            [JsonProperty(\"friendIds\")]\n            public System.Collections.Generic.List<int> friendIds { get; set; }\n          }\n          [JsonProperty(\"you\")]\n          public PersonSelection you { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate variable class",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 867,
                "column": 38
            },
            "line": 867,
            "code": "    it('Should generate variable class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          those(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThose($id: Int!) {\n          those(id: $id)\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"id\")]\n          public int id { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method without variables",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 891,
                "column": 54
            },
            "line": 891,
            "code": "    it('Should generate proxy method without variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          you: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyYou {\n          you\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.IObservable<GraphQLResponse<Response>> CreateSubscriptionStream(IGraphQLClient client) {\n          return client.CreateSubscriptionStream<Response>(Request());\n        }\n\n        public static System.IObservable<GraphQLResponse<Response>> CreateSubscriptionStream(IGraphQLClient client, System.Action<System.Exception> exceptionHandler) {\n          return client.CreateSubscriptionStream<Response>(Request(), exceptionHandler);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate proxy method with input variables",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 918,
                "column": 57
            },
            "line": 918,
            "code": "    it('Should generate proxy method with input variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          those(id: Int): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onNotifyThose($id: Int!) {\n          those(id: $id)\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public static System.IObservable<GraphQLResponse<Response>> CreateSubscriptionStream(IGraphQLClient client, Variables variables) {\n          return client.CreateSubscriptionStream<Response>(Request(variables));\n        }\n\n        public static System.IObservable<GraphQLResponse<Response>> CreateSubscriptionStream(IGraphQLClient client, Variables variables, System.Action<System.Exception> exceptionHandler) {\n          return client.CreateSubscriptionStream<Response>(Request(variables), exceptionHandler);\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should prefix with @ when name is a reserved keyword",
            "suites": [
                "C# Operations",
                "Subscription"
            ],
            "updatePoint": {
                "line": 945,
                "column": 60
            },
            "line": 945,
            "code": "    it('Should prefix with @ when name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Subscription {\n          case(record: ID!): CourtCase!\n        }\n        type CourtCase {\n          operator: String!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        subscription onUpdate($record: ID!) {\n          case(record: $record) {\n            operator\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"record\")]\n          public string @record { get; set; }\n        }\n        public class Response {\n          public class CourtCaseSelection {\n            [JsonProperty(\"operator\")]\n            public string @operator { get; set; }\n          }\n          [JsonProperty(\"case\")]\n          public CourtCaseSelection @case { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate request method for each subscription operation",
            "suites": [
                "C# Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 985,
                "column": 70
            },
            "line": 985,
            "code": "    it('Should generate request method for each subscription operation', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n        type Query {\n          user: User!\n          allWorking: [User!]\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query user {\n          user {\n            ...UserFields\n          }\n          allWorking {\n            ...UserFields\n          }\n        }\n\n        fragment UserFields on User {\n          id\n          username\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toContain('Query = UserDocument');\n      expect(result.content).toBeSimilarStringTo(`\n        public static string UserDocument = @\"\n          query user {\n            user {\n              ...UserFields\n            }\n            allWorking {\n              ...UserFields\n            }\n          }\n\n          fragment UserFields on User {\n            id\n            username\n          }\"\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate response class",
            "suites": [
                "C# Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 1038,
                "column": 38
            },
            "line": 1038,
            "code": "    it('Should generate response class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Person!\n        }\n        type Person {\n          name: String!\n          age: Int!\n          friends: [Friend!]!\n        }\n        type Friend {\n          id: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me {\n            name\n            ...PersonFragment1\n            ...PersonFragment2\n          }\n        }\n        fragment PersonFragment1 on Person {\n          age\n        }\n        fragment PersonFragment2 on Person {\n          friends {\n            ...FriendFragment\n          }\n        }\n        fragment FriendFragment on Friend {\n          id\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Response {\n          public class PersonSelection {\n            [JsonProperty(\"name\")]\n            public string name { get; set; }\n            [JsonProperty(\"age\")]\n            public int age { get; set; }\n\n            public class FriendSelection {\n              [JsonProperty(\"id\")]\n              public int id { get; set; }\n            }\n\n            [JsonProperty(\"friends\")]\n            public System.Collections.Generic.List<FriendSelection> friends { get; set; }\n          }\n\n          [JsonProperty(\"me\")]\n          public PersonSelection me { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should prefix with @ when name is a reserved keyword",
            "suites": [
                "C# Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 1101,
                "column": 60
            },
            "line": 1101,
            "code": "    it('Should prefix with @ when name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          case(record: ID!): CourtCase!\n        }\n        type CourtCase {\n          operator: String!\n          public: String!\n          private: String!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findCase($record: ID!) {\n          case(record: $record) {\n            private\n            ...Fragment1\n            ...Fragment2\n          }\n        }\n        fragment Fragment1 on CourtCase {\n          public\n        }\n        fragment Fragment2 on CourtCase {\n          operator\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        { typesafeOperation: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        public class Variables {\n          [JsonProperty(\"record\")]\n          public string @record { get; set; }\n        }\n        public class Response {\n          public class CourtCaseSelection {\n            [JsonProperty(\"private\")]\n            public string @private { get; set; }\n            [JsonProperty(\"public\")]\n            public string @public { get; set; }\n            [JsonProperty(\"operator\")]\n            public string @operator { get; set; }\n          }\n          [JsonProperty(\"case\")]\n          public CourtCaseSelection @case { get; set; }\n        }\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a summary with required and optional scalar variables",
            "suites": [
                "C# Operations",
                "Method summary header"
            ],
            "updatePoint": {
                "line": 1155,
                "column": 77
            },
            "line": 1155,
            "code": "    it('Should generate a summary with required and optional scalar variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          runScalar(\n            id: Int\n            idr: Int!\n            name: String\n            namer: String!\n            flag: Boolean\n            flagr: Boolean!\n            flt: Float\n            fltr: Float!\n          ): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query RunScalar(\n          $id: Int\n          $idr: Int!\n          $name: String\n          $namer: String!\n          $flag: Boolean\n          $flagr: Boolean!\n          $flt: Float\n          $fltr: Float!\n        ) {\n          runScalar(id: $id, idr: $idr, name: $name, namer: $namer, flagr: $flagr, flt: $flt, fltr: $fltr)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <summary>\n        /// RunScalarGQL.Request\n        /// <para>Required variables:<br/> { idr=(int), namer=(string), flagr=(bool), fltr=(double)  }</para>\n        /// <para>Optional variables:<br/> { id=(int), name=(string), flag=(bool), flt=(double) }</para>\n        /// </summary>\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a summary with required and optional for complex variables",
            "suites": [
                "C# Operations",
                "Method summary header"
            ],
            "updatePoint": {
                "line": 1200,
                "column": 82
            },
            "line": 1200,
            "code": "    it('Should generate a summary with required and optional for complex variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum SortBy {\n          Asc\n          Desc\n        }\n        type Data {\n          flag: Boolean\n        }\n        type Query {\n          runComplex(sort: SortBy, complex: Data, arr: [ID!]!, multi: [[[String]]]): Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query RunComplex($sort: SortBy, $complex: Data, $arr: [ID!]!, $multi: [[[String]]]) {\n          runComplex(sort: $sort, complex: $complex, arr: $arr, multi: $multi)\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <summary>\n        /// RunComplexGQL.Request\n        /// <para>Required variables:<br/> { arr=(string[]) }</para>\n        /// <para>Optional variables:<br/> { sort=(SortBy), complex=(Data), multi=(string[][][]) }</para>\n        /// </summary>\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should generate a summary without variables if query does not have variables",
            "suites": [
                "C# Operations",
                "Method summary header"
            ],
            "updatePoint": {
                "line": 1234,
                "column": 84
            },
            "line": 1234,
            "code": "    it('Should generate a summary without variables if query does not have variables', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          runSimple: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query RunSimple {\n          runSimple\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toBeSimilarStringTo(`\n        /// <summary>\n        /// RunSimpleGQL.Request\n        /// </summary>\n      `);\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "#4221 - suffix query mutation subscription",
            "suites": [
                "C# Operations",
                "Issues"
            ],
            "updatePoint": {
                "line": 1261,
                "column": 50
            },
            "line": 1261,
            "code": "    it('#4221 - suffix query mutation subscription', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n        type Mutation {\n          you: Int!\n          them: Int!\n        }\n        type Subscription {\n          them: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe {\n          me\n        }\n        mutation updateYou {\n          you\n        }\n        subscription onNotifyThem {\n          them\n        }\n      `);\n\n      const config: CSharpOperationsRawPluginConfig = {\n        querySuffix: 'Query',\n        mutationSuffix: 'Mutation',\n        subscriptionSuffix: 'Subscription',\n      };\n      const result = (await plugin(schema, [{ location: '', document: operation }], config, {\n        outputFile: '',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain('public class FindMeQuery {');\n      expect(result.content).toContain('public class UpdateYouMutation {');\n      expect(result.content).toContain('public class OnNotifyThemSubscription {');\n\n      expect(result.content).toContain('public static GraphQLRequest getFindMeQuery() {');\n      expect(result.content).toContain('public static GraphQLRequest getUpdateYouMutation() {');\n      expect(result.content).toContain('public static GraphQLRequest getOnNotifyThemSubscription() {');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "#4260 - operation name casing",
            "suites": [
                "C# Operations",
                "Issues"
            ],
            "updatePoint": {
                "line": 1304,
                "column": 37
            },
            "line": 1304,
            "code": "    it('#4260 - operation name casing', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: Int!\n        }\n      `);\n      const operation = parse(/* GraphQL */ `\n        query findMe1 {\n          me\n        }\n        query FindMe2 {\n          me\n        }\n        query findme3 {\n          me\n        }\n        query FINDME4 {\n          me\n        }\n      `);\n\n      const result = (await plugin(\n        schema,\n        [{ location: '', document: operation }],\n        {},\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain('OperationName = \"findMe1\"');\n      expect(result.content).toContain('OperationName = \"FindMe2\"');\n      expect(result.content).toContain('OperationName = \"findme3\"');\n      expect(result.content).toContain('OperationName = \"FINDME4\"');\n    });",
            "file": "c-sharp-operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp-operations/test"
        },
        {
            "name": "Should include dotnet using directives",
            "suites": [
                "C#",
                "Using directives"
            ],
            "updatePoint": {
                "line": 10,
                "column": 46
            },
            "line": 10,
            "code": "    it('Should include dotnet using directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum ns {\n          dummy\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain('using System;');\n      expect(result).toContain('using System.Collections.Generic;');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should include default JSON using directives",
            "suites": [
                "C#",
                "Using directives"
            ],
            "updatePoint": {
                "line": 22,
                "column": 52
            },
            "line": 22,
            "code": "    it('Should include default JSON using directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum ns {\n          dummy\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain('using Newtonsoft.Json;');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should include configured '%s' using directives",
            "suites": [
                "C#",
                "Using directives"
            ],
            "updatePoint": {
                "line": 33,
                "column": 47
            },
            "line": 33,
            "code": "    each(['Newtonsoft.Json', 'System.Text.Json']).it(\n      `Should include configured '%s' using directives`,\n      async source => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum ns {\n            dummy\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          jsonAttributesSource: source,\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n        const jsonConfig = getJsonAttributeSourceConfiguration(source);\n\n        expect(result).toContain(`using ${jsonConfig.namespace};`);\n      }\n    );",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should wrap generated code block in namespace using default name",
            "suites": [
                "C#",
                "Namespaces"
            ],
            "updatePoint": {
                "line": 53,
                "column": 72
            },
            "line": 53,
            "code": "    it('Should wrap generated code block in namespace using default name', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum ns {\n          dummy\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('namespace GraphQLCodeGen {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should wrap generated code block in namespace using custom name",
            "suites": [
                "C#",
                "Namespaces"
            ],
            "updatePoint": {
                "line": 63,
                "column": 71
            },
            "line": 63,
            "code": "    it('Should wrap generated code block in namespace using custom name', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum ns {\n          dummy\n        }\n      `);\n      const result = await plugin(schema, [], { namespaceName: 'MyCompany.MyGeneratedGql' }, { outputFile: '' });\n      expect(result).toContain('namespace MyCompany.MyGeneratedGql {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should convert enums to C# enums",
            "suites": [
                "C#",
                "Enums",
                "Basic conversion"
            ],
            "updatePoint": {
                "line": 76,
                "column": 42
            },
            "line": 76,
            "code": "      it('Should convert enums to C# enums', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum UserRole {\n            ADMIN\n            USER\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`\n          public enum UserRole {\n            ADMIN,\n            USER\n          }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should allow to override enum values with custom values",
            "suites": [
                "C#",
                "Enums",
                "Basic conversion"
            ],
            "updatePoint": {
                "line": 92,
                "column": 65
            },
            "line": 92,
            "code": "      it('Should allow to override enum values with custom values', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum UserRole {\n            ADMIN\n            USER\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          enumValues: {\n            UserRole: {\n              ADMIN: 'AdminRoleValue',\n            },\n          },\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n\n        expect(result).toContain('AdminRoleValue');\n        expect(result).toContain('USER');\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate summary header for the enum type",
            "suites": [
                "C#",
                "Enums",
                "Comment and directives"
            ],
            "updatePoint": {
                "line": 114,
                "column": 58
            },
            "line": 114,
            "code": "      it('Should generate summary header for the enum type', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          \"\"\"\n          Allowed user roles\n          \"\"\"\n          enum UserRole {\n            admin\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`\n          /// <summary>\n          /// Allowed user roles\n          /// </summary>\n          public enum UserRole\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate summary header for enum values",
            "suites": [
                "C#",
                "Enums",
                "Comment and directives"
            ],
            "updatePoint": {
                "line": 132,
                "column": 56
            },
            "line": 132,
            "code": "      it('Should generate summary header for enum values', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum UserRole {\n            \"\"\"\n            Administrator role\n            \"\"\"\n            admin\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`\n          /// <summary>\n          /// Administrator role\n          /// </summary>\n          admin\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate multiline summary header for enum values",
            "suites": [
                "C#",
                "Enums",
                "Comment and directives"
            ],
            "updatePoint": {
                "line": 150,
                "column": 66
            },
            "line": 150,
            "code": "      it('Should generate multiline summary header for enum values', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum UserRole {\n            \"\"\"\n            Administrator role\n            Note: normal users are not admins!\n            \"\"\"\n            admin\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`\n          /// <summary>\n          /// Administrator role\n          /// Note: normal users are not admins!\n          /// </summary>\n          admin\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should mark deprecated enum values with Obsolete attribute",
            "suites": [
                "C#",
                "Enums",
                "Comment and directives"
            ],
            "updatePoint": {
                "line": 170,
                "column": 68
            },
            "line": 170,
            "code": "      it('Should mark deprecated enum values with Obsolete attribute', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum UserRole {\n            guest @deprecated(reason: \"Guests not welcome\")\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`[Obsolete(\"Guests not welcome\")]\n          guest\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should prefix enum with @ when name is a reserved keyword",
            "suites": [
                "C#",
                "Enums",
                "Reserved keywords"
            ],
            "updatePoint": {
                "line": 184,
                "column": 67
            },
            "line": 184,
            "code": "      it('Should prefix enum with @ when name is a reserved keyword', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          enum Visibility {\n            public\n            private\n            protected\n            internal\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo(`\n          public enum Visibility {\n            @public,\n            @private,\n            @protected,\n            @internal\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# class for input type",
            "suites": [
                "C#",
                "Input Types"
            ],
            "updatePoint": {
                "line": 206,
                "column": 47
            },
            "line": 206,
            "code": "    it('Should generate C# class for input type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        input UserInput {\n          id: Int\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('public class UserInput {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for input type fields",
            "suites": [
                "C#",
                "Input Types"
            ],
            "updatePoint": {
                "line": 216,
                "column": 56
            },
            "line": 216,
            "code": "    it('Should generate properties for input type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        input UserInput {\n          id: Int\n          email: String\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toBeSimilarStringTo(`\n        public int? id { get; set; }\n        public string email { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# method for creating input object",
            "suites": [
                "C#",
                "Input Types"
            ],
            "updatePoint": {
                "line": 230,
                "column": 59
            },
            "line": 230,
            "code": "    it('Should generate C# method for creating input object', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        input UserInput {\n          id: Int\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('public dynamic GetInputObject()');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate summary header for class and properties",
            "suites": [
                "C#",
                "Input Types"
            ],
            "updatePoint": {
                "line": 240,
                "column": 63
            },
            "line": 240,
            "code": "    it('Should generate summary header for class and properties', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        User Input values\n        \"\"\"\n        input UserInput {\n          \"\"\"\n          User id\n          \"\"\"\n          id: Int!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n        /// <summary>\n        /// User Input values\n        /// </summary>\n        public class UserInput {\n      `);\n      expect(result).toBeSimilarStringTo(`\n        /// <summary>\n        /// User id\n        /// </summary>\n        [Required]\n        [JsonRequired]\n        public int id { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# class for type",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 272,
                "column": 41
            },
            "line": 272,
            "code": "    it('Should generate C# class for type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('public class User {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# record for type",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 281,
                "column": 42
            },
            "line": 281,
            "code": "    it('Should generate C# record for type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n        }\n      `);\n      const result = await plugin(schema, [], { emitRecords: true }, { outputFile: '' });\n      expect(result).toContain('public record User(int? Id) {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should wrap generated classes in Type class",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 290,
                "column": 51
            },
            "line": 290,
            "code": "    it('Should wrap generated classes in Type class', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('public class Types {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should wrap generated classes in custom Type class name",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 300,
                "column": 63
            },
            "line": 300,
            "code": "    it('Should wrap generated classes in custom Type class name', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n        }\n      `);\n      const config: CSharpResolversPluginRawConfig = {\n        className: 'MyGqlTypes',\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      expect(result).toContain('public class MyGqlTypes {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should prefix wrap name with @ when custom class name is a reserved keyword",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 313,
                "column": 83
            },
            "line": 313,
            "code": "    it('Should prefix wrap name with @ when custom class name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n        }\n      `);\n      const config: CSharpResolversPluginRawConfig = {\n        className: 'public',\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      expect(result).toContain('public class @public {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for types using '%s' source",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 326,
                "column": 47
            },
            "line": 326,
            "code": "    each(['Newtonsoft.Json', 'System.Text.Json']).it(\n      `Should generate properties for types using '%s' source`,\n      async source => {\n        const schema = buildSchema(/* GraphQL */ `\n          type User {\n            id: Int\n            email: String\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          jsonAttributesSource: source,\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n        const jsonConfig = getJsonAttributeSourceConfiguration(source);\n\n        expect(result).toBeSimilarStringTo(`\n          [${jsonConfig.propertyAttribute}(\"id\")]\n          public int? id { get; set; }\n          [${jsonConfig.propertyAttribute}(\"email\")]\n          public string email { get; set; }\n        `);\n      }\n    );",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for types without JSON attributes",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 350,
                "column": 68
            },
            "line": 350,
            "code": "    it(`Should generate properties for types without JSON attributes`, async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: Int\n          email: String\n        }\n      `);\n      const config: CSharpResolversPluginRawConfig = {\n        emitJsonAttributes: false,\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n          public int? id { get; set; }\n          public string email { get; set; }\n        `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate summary header for class and properties",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 368,
                "column": 63
            },
            "line": 368,
            "code": "    it('Should generate summary header for class and properties', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        User values\n        \"\"\"\n        type User {\n          \"\"\"\n          User id\n          \"\"\"\n          id: Int!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n        /// <summary>\n        /// User values\n        /// </summary>\n        public class User {\n      `);\n      expect(result).toBeSimilarStringTo(`\n        /// <summary>\n        /// User id\n        /// </summary>\n        [JsonProperty(\"id\")]\n        public int id { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should mark deprecated properties with Obsolete attribute",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 397,
                "column": 65
            },
            "line": 397,
            "code": "    it('Should mark deprecated properties with Obsolete attribute', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          age: Int @deprecated\n          refid: String @deprecated(reason: \"Field is obsolete, use id\")\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n        [Obsolete(\"Field no longer supported\")]\n        [JsonProperty(\"age\")]\n        public int? age { get; set; }\n      `);\n      expect(result).toBeSimilarStringTo(`\n        [Obsolete(\"Field is obsolete, use id\")]\n        [JsonProperty(\"refid\")]\n        public string refid { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should prefix class name with @ when type name is a reserved keyword",
            "suites": [
                "C#",
                "Types"
            ],
            "updatePoint": {
                "line": 418,
                "column": 76
            },
            "line": 418,
            "code": "    it('Should prefix class name with @ when type name is a reserved keyword', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type object {\n          id: Int!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain('public class @object {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# interface from gql interface",
            "suites": [
                "C#",
                "Interfaces"
            ],
            "updatePoint": {
                "line": 431,
                "column": 55
            },
            "line": 431,
            "code": "    it('Should generate C# interface from gql interface', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain('public interface Node {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate C# class that implements given interfaces",
            "suites": [
                "C#",
                "Interfaces"
            ],
            "updatePoint": {
                "line": 442,
                "column": 65
            },
            "line": 442,
            "code": "    it('Should generate C# class that implements given interfaces', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface INode {\n          id: ID!\n        }\n        interface INameNode {\n          username: String!\n        }\n\n        type User implements INode & INameNode {\n          id: ID!\n          username: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain('public interface INode {');\n      expect(result).toContain('public class User : INode, INameNode {');\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for mandatory scalar types using '%s' source",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Scalar"
            ],
            "updatePoint": {
                "line": 465,
                "column": 49
            },
            "line": 465,
            "code": "      each(['Newtonsoft.Json', 'System.Text.Json']).it(\n        `Should generate properties for mandatory scalar types using '%s' source`,\n        async source => {\n          const schema = buildSchema(/* GraphQL */ `\n            input BasicTypeInput {\n              intReq: Int!\n              fltReq: Float!\n              idReq: ID!\n              strReq: String!\n              boolReq: Boolean!\n            }\n          `);\n\n          const config: CSharpResolversPluginRawConfig = {\n            jsonAttributesSource: source,\n          };\n          const result = await plugin(schema, [], config, { outputFile: '' });\n          const jsonConfig = getJsonAttributeSourceConfiguration(source);\n          const attributes =\n            `\n            [Required]\n          ` +\n            (jsonConfig.requiredAttribute == null\n              ? ``\n              : `\n            [${jsonConfig.requiredAttribute}]\n          `);\n\n          expect(result).toBeSimilarStringTo(`\n            ${attributes}\n            public int intReq { get; set; }\n            ${attributes}\n            public double fltReq { get; set; }\n            ${attributes}\n            public string idReq { get; set; }\n            ${attributes}\n            public string strReq { get; set; }\n            ${attributes}\n            public bool boolReq { get; set; }\n          `);\n        }\n      );",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for mandatory scalar types with JSON attributes disabled",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Scalar"
            ],
            "updatePoint": {
                "line": 508,
                "column": 93
            },
            "line": 508,
            "code": "      it(`Should generate properties for mandatory scalar types with JSON attributes disabled`, async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input BasicTypeInput {\n            intReq: Int!\n            fltReq: Float!\n            idReq: ID!\n            strReq: String!\n            boolReq: Boolean!\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          emitJsonAttributes: false,\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          [Required]\n          public int intReq { get; set; }\n          [Required]\n          public double fltReq { get; set; }\n          [Required]\n          public string idReq { get; set; }\n          [Required]\n          public string strReq { get; set; }\n          [Required]\n          public bool boolReq { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should generate properties for optional scalar types",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Scalar"
            ],
            "updatePoint": {
                "line": 537,
                "column": 62
            },
            "line": 537,
            "code": "      it('Should generate properties for optional scalar types', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input BasicTypeInput {\n            intOpt: Int\n            fltOpt: Float\n            idOpt: ID\n            strOpt: String\n            boolOpt: Boolean\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          public int? intOpt { get; set; }\n          public double? fltOpt { get; set; }\n          public string idOpt { get; set; }\n          public string strOpt { get; set; }\n          public bool? boolOpt { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should properly treat DateTime nullability",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Scalar"
            ],
            "updatePoint": {
                "line": 558,
                "column": 52
            },
            "line": 558,
            "code": "      it('Should properly treat DateTime nullability', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          type Test {\n            dateOptional: Date\n            dateMandatory: Date!\n          }\n\n          scalar Date\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          [JsonProperty(\"dateOptional\")]\n          public DateTime? dateOptional { get; set; }\n          [JsonProperty(\"dateMandatory\")]\n          public DateTime dateMandatory { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should use default list type for arrays",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Array"
            ],
            "updatePoint": {
                "line": 579,
                "column": 49
            },
            "line": 579,
            "code": "      it('Should use default list type for arrays', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input ArrayInput {\n            arr: [Int!]\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result).toBeSimilarStringTo('public List<int> arr { get; set; }');\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should use custom list type for arrays when listType is specified",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Array"
            ],
            "updatePoint": {
                "line": 589,
                "column": 75
            },
            "line": 589,
            "code": "      it('Should use custom list type for arrays when listType is specified', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input ArrayInput {\n            arr: [Int!]\n          }\n        `);\n        const result1 = await plugin(schema, [], { listType: 'IEnumerable' }, { outputFile: '' });\n        expect(result1).toContain('public IEnumerable<int> arr { get; set; }');\n\n        const result2 = await plugin(schema, [], { listType: 'HashSet' }, { outputFile: '' });\n        expect(result2).toContain('public HashSet<int> arr { get; set; }');\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should use correct array inner types",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Array"
            ],
            "updatePoint": {
                "line": 602,
                "column": 46
            },
            "line": 602,
            "code": "      it('Should use correct array inner types', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input ArrayInput {\n            arr1: [Int!]\n            arr2: [Float]\n            arr3: [Int]!\n            arr4: [Boolean!]!\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          listType: 'IEnumerable',\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          public IEnumerable<int> arr1 { get; set; }\n          public IEnumerable<double?> arr2 { get; set; }\n          [Required]\n          [JsonRequired]\n          public IEnumerable<int?> arr3 { get; set; }\n          [Required]\n          [JsonRequired]\n          public IEnumerable<bool> arr4 { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should handle nested array types",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Array"
            ],
            "updatePoint": {
                "line": 628,
                "column": 42
            },
            "line": 628,
            "code": "      it('Should handle nested array types', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          type Complex {\n            arrA: [Boolean]\n          }\n          input ArrayInput {\n            arr1: [[Int!]]\n            arr2: [[[Float]!]!]!\n            arr3: [[Complex]]!\n          }\n        `);\n        const config: CSharpResolversPluginRawConfig = {\n          listType: 'IEnumerable',\n        };\n        const result = await plugin(schema, [], config, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          public IEnumerable<IEnumerable<int>> arr1 { get; set; }\n          [Required]\n          [JsonRequired]\n          public IEnumerable<IEnumerable<IEnumerable<double?>>> arr2 { get; set; }\n          [Required]\n          [JsonRequired]\n          public IEnumerable<IEnumerable<Complex>> arr3 { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should prefix with @ when name is a reserved keyword",
            "suites": [
                "C#",
                "GraphQL Value Types",
                "Reserved keywords"
            ],
            "updatePoint": {
                "line": 657,
                "column": 62
            },
            "line": 657,
            "code": "      it('Should prefix with @ when name is a reserved keyword', async () => {\n        const schema = buildSchema(/* GraphQL */ `\n          input ReservedInput {\n            int: Int\n            float: Float\n            string: String\n            bool: Boolean\n          }\n        `);\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result).toBeSimilarStringTo(`\n          public int? @int { get; set; }\n          public double? @float { get; set; }\n          public string @string { get; set; }\n          public bool? @bool { get; set; }\n        `);\n      });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should mark required fields optional when a default value is assigned",
            "suites": [
                "C#",
                "Default Values"
            ],
            "updatePoint": {
                "line": 679,
                "column": 77
            },
            "line": 679,
            "code": "    it('Should mark required fields optional when a default value is assigned', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Length {\n          None\n          Short\n          Long\n        }\n        input InitialInput {\n          val: Int! = 5\n          flt: Float! = 3.1415\n          str: ID! = \"Dummy string\"\n          flag: Boolean! = true\n          hair: Length! = Short\n        }\n      `);\n      const config: CSharpResolversPluginRawConfig = {\n        listType: 'HashSet',\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n        public int? val { get; set; }\n        public double? flt { get; set; }\n        public string str { get; set; }\n        public bool? flag { get; set; }\n        public Length? hair { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Should mark required arrays optional when a default value is assigned",
            "suites": [
                "C#",
                "Default Values"
            ],
            "updatePoint": {
                "line": 708,
                "column": 77
            },
            "line": 708,
            "code": "    it('Should mark required arrays optional when a default value is assigned', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        input InitialInput {\n          arr1: [Int] = [null, 2, 3]\n          arr2: [Int!] = [1, 2, 3]\n          arr3: [String]! = [\"a\", null, \"c\"]\n          arr4: [String!]! = [\"a\", \"b\", \"c\"]\n        }\n      `);\n      const config: CSharpResolversPluginRawConfig = {\n        listType: 'HashSet',\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n        public HashSet<int?> arr1 { get; set; }\n        public HashSet<int> arr2 { get; set; }\n        public HashSet<string> arr3 { get; set; }\n        public HashSet<string> arr4 { get; set; }\n      `);\n    });",
            "file": "c-sharp.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/c-sharp/c-sharp/test"
        },
        {
            "name": "Test for issue #1508",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 9,
                "column": 28
            },
            "line": 9,
            "code": "    it('Test for issue #1508', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        New user account input fields\n        \"\"\"\n        input SignUpDetails {\n          \"\"\"\n          First name\n          \"\"\"\n          firstName: String!\n\n          \"\"\"\n          Last name\n          \"\"\"\n          lastName: String!\n\n          \"\"\"\n          Email address\n          \"\"\"\n          email: String!\n\n          \"\"\"\n          User role\n          \"\"\"\n          role: String!\n\n          \"\"\"\n          A legit and secure password\n          \"\"\"\n          password: String!\n\n          \"\"\"\n          Repeat password\n          \"\"\"\n          passwordRepeat: String!\n\n          \"\"\"\n          Language\n          \"\"\"\n          language: String = \"en-US\"\n\n          \"\"\"\n          Timezone\n          \"\"\"\n          timezone: String = \"UTC\"\n\n          \"\"\"\n          CAPTCHA verification code\n          \"\"\"\n          captcha: String\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      /** New user account input fields */\n      export type SignUpDetails = {|\n        /** First name */\n        firstName: $ElementType<Scalars, 'String'>,\n        /** Last name */\n        lastName: $ElementType<Scalars, 'String'>,\n        /** Email address */\n        email: $ElementType<Scalars, 'String'>,\n        /** User role */\n        role: $ElementType<Scalars, 'String'>,\n        /** A legit and secure password */\n        password: $ElementType<Scalars, 'String'>,\n        /** Repeat password */\n        passwordRepeat: $ElementType<Scalars, 'String'>,\n        /** Language */\n        language?: ?$ElementType<Scalars, 'String'>,\n        /** Timezone */\n        timezone?: ?$ElementType<Scalars, 'String'>,\n        /** CAPTCHA verification code */\n        captcha?: ?$ElementType<Scalars, 'String'>,\n      |};\n      `);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should include a description for Scalars type",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 88,
                "column": 53
            },
            "line": 88,
            "code": "    it('Should include a description for Scalars type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom scalar\"\n        scalar A\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {|\n          ID: string,\n          String: string,\n          Boolean: boolean,\n          Int: number,\n          Float: number,\n          /** My custom scalar */\n          A: any,\n        |};\n      `);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should add description for input types",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 110,
                "column": 46
            },
            "line": 110,
            "code": "    it('Should add description for input types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          f: String\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should add description for input fields",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 126,
                "column": 47
            },
            "line": 126,
            "code": "    it('Should add description for input fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          \"f is something\"\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput = {|\n          /** f is something */\n          f: $ElementType<Scalars, 'String'>,\n        |}`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with multiline comment",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 146,
                "column": 42
            },
            "line": 146,
            "code": "    it('Should work with multiline comment', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        MyInput\n        multiline\n        \"\"\"\n        input MyInput {\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /**\n         * MyInput\n         * multiline\n         */\n        export type MyInput`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with unions",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 168,
                "column": 31
            },
            "line": 168,
            "code": "    it('Should work with unions', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"my union\"\n        union A = B | C\n\n        type B {\n          id: ID\n        }\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** my union */\n        export type A = `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with types",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 189,
                "column": 30
            },
            "line": 189,
            "code": "    it('Should work with types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"this is b\"\n        type B {\n          id: ID\n        }\n        \"this is c\"\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is b */\n        export type B = `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is c */\n        export type C = `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with type fields",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 213,
                "column": 36
            },
            "line": 213,
            "code": "    it('Should work with type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type B {\n          \"the id\"\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type B = {|\n        __typename?: 'B',\n        /** the id */\n        id?: ?$ElementType<Scalars, 'ID'>,\n      |};`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with inteface and inteface fields",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 232,
                "column": 53
            },
            "line": 232,
            "code": "    it('Should work with inteface and inteface fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          \"the id\"\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Node = {|\n        /** the id */\n        id: $ElementType<Scalars, 'ID'>,\n      |};`);\n      expect(result.content).toMatchSnapshot();\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should work with enum and enum values",
            "suites": [
                "Flow Plugin",
                "description to comment"
            ],
            "updatePoint": {
                "line": 251,
                "column": 45
            },
            "line": 251,
            "code": "    it('Should work with enum and enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnumValues = Object.freeze({\n        /** this is a */\n        A: 'A',\n        /** this is b */\n        B: 'B'\n      });\n\n\n      /** custom enum */\n      export type MyEnum = $Values<typeof MyEnumValues>;`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should produce valid flow code when used with useFlowExactObjects in enums",
            "suites": [
                "Flow Plugin",
                "Output options"
            ],
            "updatePoint": {
                "line": 280,
                "column": 82
            },
            "line": 280,
            "code": "    it('Should produce valid flow code when used with useFlowExactObjects in enums', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }\n        `);\n      const result = (await plugin(\n        schema,\n        [],\n        { useFlowExactObjects: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnumValues = Object.freeze({\n        A: 'A',\n        B: 'B'\n      });`);\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should respect flow option useFlowExactObjects=false",
            "suites": [
                "Flow Plugin",
                "Output options"
            ],
            "updatePoint": {
                "line": 302,
                "column": 60
            },
            "line": 302,
            "code": "    it('Should respect flow option useFlowExactObjects=false', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String\n          bar: String!\n        }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { useFlowExactObjects: false },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo?: ?$ElementType<Scalars, 'String'>,\n          bar: $ElementType<Scalars, 'String'>,\n        };\n      `);\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should respect flow option useFlowReadOnlyTypes",
            "suites": [
                "Flow Plugin",
                "Output options"
            ],
            "updatePoint": {
                "line": 324,
                "column": 55
            },
            "line": 324,
            "code": "    it('Should respect flow option useFlowReadOnlyTypes', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface MyInterface {\n          foo: String\n          bar: String!\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { useFlowReadOnlyTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {|\n          +foo?: ?$ElementType<Scalars, 'String'>,\n          +bar: $ElementType<Scalars, 'String'>,\n        |};\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export const MyEnumValues = Object.freeze({\n          A: 'A',\n          B: 'B',\n          C: 'C'\n        });\n        export type MyEnum = $Values<typeof MyEnumValues>;\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should use custom namingConvention for type name and args typename",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 365,
                "column": 74
            },
            "line": 365,
            "code": "    it('Should use custom namingConvention for type name and args typename', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should remove underscore from enum values",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 379,
                "column": 49
            },
            "line": 379,
            "code": "    it('Should remove underscore from enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          My_Value\n          _MyOtherValue\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnumValues = Object.freeze({\n        MyValue: 'My_Value',\n        MyOtherValue: '_MyOtherValue'\n      });\n\n      export type MyEnum = $Values<typeof MyEnumValues>;`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should use custom namingConvention and add custom prefix",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 400,
                "column": 64
            },
            "line": 400,
            "code": "    it('Should use custom namingConvention and add custom prefix', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase', typesPrefix: 'I' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytypefooargs = {|\n          a: $ElementType<Scalars, 'String'>,\n          b?: ?$ElementType<Scalars, 'String'>,\n          c?: ?Array<?$ElementType<Scalars, 'String'>>,\n          d: Array<$ElementType<Scalars, 'Int'>>,\n        |};\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytype = {|\n          __typename?: 'MyType',\n          foo?: ?$ElementType<Scalars, 'String'>,\n        |};\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correct values when using links between types - lowerCase",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 471,
                "column": 81
            },
            "line": 471,
            "code": "    it('Should generate correct values when using links between types - lowerCase', async () => {\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default)",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 483,
                "column": 92
            },
            "line": 483,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default)', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnumValues = Object.freeze({\n        A: 'A',\n        B: 'B',\n        C: 'C'\n      });`);\n\n      expect(result.content).toBeSimilarStringTo(`export type MyEnum = $Values<typeof MyEnumValues>;`);\n\n      expect(result.content).toBeSimilarStringTo(`export type MyType = {|\n        __typename?: 'MyType',\n        f?: ?$ElementType<Scalars, 'String'>,\n        bar?: ?MyEnum,\n        b_a_r?: ?$ElementType<Scalars, 'String'>,\n        myOtherField?: ?$ElementType<Scalars, 'String'>,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type My_Type = {|\n        __typename?: 'My_Type',\n        linkTest?: ?MyType,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type MyUnion = My_Type | MyType;`);\n\n      expect(result.content).toBeSimilarStringTo(`export type Some_Interface = {|\n        id: $ElementType<Scalars, 'ID'>,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type Impl1 = {|\n        ...Some_Interface,\n        ...{|\n          __typename?: 'Impl1',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type Impl_2 = {|\n        ...Some_Interface,\n        ...{|\n          __typename?: 'Impl_2',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type Impl_3 = {|\n        ...Some_Interface,\n        ...{|\n          __typename?: 'impl_3',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type Query = {|\n       __typename?: 'Query',\n       something?: ?MyUnion,\n       use_interface?: ?Some_Interface,\n     |};`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default) with custom prefix",
            "suites": [
                "Flow Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 548,
                "column": 111
            },
            "line": 548,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default) with custom prefix', async () => {\n      const result = await plugin(schema, [], { typesPrefix: 'I' }, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const IMyEnumValues = Object.freeze({\n        A: 'A',\n        B: 'B',\n        C: 'C'\n      });`);\n      expect(result.content).toBeSimilarStringTo(`export type IMyEnum = $Values<typeof IMyEnumValues>;`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IMyType = {|\n        __typename?: 'MyType',\n        f?: ?$ElementType<Scalars, 'String'>,\n        bar?: ?IMyEnum,\n        b_a_r?: ?$ElementType<Scalars, 'String'>,\n        myOtherField?: ?$ElementType<Scalars, 'String'>,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IMy_Type = {|\n        __typename?: 'My_Type',\n        linkTest?: ?IMyType,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IMyUnion = IMy_Type | IMyType;`);\n\n      expect(result.content).toBeSimilarStringTo(`export type ISome_Interface = {|\n        id: $ElementType<Scalars, 'ID'>,\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IImpl1 = {|\n        ...ISome_Interface,\n        ...{|\n          __typename?: 'Impl1',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IImpl_2 = {|\n        ...ISome_Interface,\n        ...{|\n          __typename?: 'Impl_2',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IImpl_3 = {|\n        ...ISome_Interface,\n        ...{|\n          __typename?: 'impl_3',\n          id: $ElementType<Scalars, 'ID'>,\n        |}\n      |};`);\n\n      expect(result.content).toBeSimilarStringTo(`export type IQuery = {|\n       __typename?: 'Query',\n       something?: ?IMyUnion,\n       use_interface?: ?ISome_Interface,\n     |};`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with basic fields",
            "suites": [
                "Flow Plugin",
                "Arguments"
            ],
            "updatePoint": {
                "line": 615,
                "column": 79
            },
            "line": 615,
            "code": "    it('Should generate correctly types for field arguments - with basic fields', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with default value",
            "suites": [
                "Flow Plugin",
                "Arguments"
            ],
            "updatePoint": {
                "line": 623,
                "column": 80
            },
            "line": 623,
            "code": "    it('Should generate correctly types for field arguments - with default value', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with input type",
            "suites": [
                "Flow Plugin",
                "Arguments"
            ],
            "updatePoint": {
                "line": 633,
                "column": 77
            },
            "line": 633,
            "code": "    it('Should generate correctly types for field arguments - with input type', async () => {\n      const schema = buildSchema(\n        `input MyInput { f: String } type MyType { foo(a: MyInput, b: MyInput!, c: [MyInput], d: [MyInput]!, e: [MyInput!]!): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should add custom prefix for mutation arguments",
            "suites": [
                "Flow Plugin",
                "Arguments"
            ],
            "updatePoint": {
                "line": 643,
                "column": 55
            },
            "line": 643,
            "code": "    it('Should add custom prefix for mutation arguments', async () => {\n      const schema = buildSchema(\n        `input Input { name: String } type Mutation { foo(id: String, input: Input): String }`\n      );\n      const result = await plugin(schema, [], { typesPrefix: 'T' }, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should add custom suffix for mutation arguments",
            "suites": [
                "Flow Plugin",
                "Arguments"
            ],
            "updatePoint": {
                "line": 653,
                "column": 55
            },
            "line": 653,
            "code": "    it('Should add custom suffix for mutation arguments', async () => {\n      const schema = buildSchema(\n        `input Input { name: String } type Mutation { foo(id: String, input: Input): String }`\n      );\n      const result = await plugin(schema, [], { typesSuffix: 'T' }, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build basic enum correctly",
            "suites": [
                "Flow Plugin",
                "Enum"
            ],
            "updatePoint": {
                "line": 665,
                "column": 41
            },
            "line": 665,
            "code": "    it('Should build basic enum correctly', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export const MyEnumValues = Object.freeze({\n          A: 'A',\n          B: 'B',\n          C: 'C'\n        });\n\n        export type MyEnum = $Values<typeof MyEnumValues>;\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build enum correctly with custom values",
            "suites": [
                "Flow Plugin",
                "Enum"
            ],
            "updatePoint": {
                "line": 682,
                "column": 54
            },
            "line": 682,
            "code": "    it('Should build enum correctly with custom values', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: { A: 'SomeValue', B: 'TEST' } } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export const MyEnumValues = Object.freeze({\n          A: 'SomeValue',\n          B: 'TEST',\n          C: 'C'\n        });\n\n        export type MyEnum = $Values<typeof MyEnumValues>;\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build enum correctly with custom values and map to external enum",
            "suites": [
                "Flow Plugin",
                "Enum"
            ],
            "updatePoint": {
                "line": 704,
                "column": 79
            },
            "line": 704,
            "code": "    it('Should build enum correctly with custom values and map to external enum', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export type MyEnum`);\n      expect(result.prepend).toContain(`import { type MyEnum } from './my-file';`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build enum correctly with custom values and map to external enum with different identifier",
            "suites": [
                "Flow Plugin",
                "Enum"
            ],
            "updatePoint": {
                "line": 719,
                "column": 105
            },
            "line": 719,
            "code": "    it('Should build enum correctly with custom values and map to external enum with different identifier', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyCustomEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export type MyEnum`);\n      expect(result.prepend).toContain(`import { type MyCustomEnum as MyEnum } from './my-file';`);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build basic scalar correctly as any",
            "suites": [
                "Flow Plugin",
                "Scalars"
            ],
            "updatePoint": {
                "line": 736,
                "column": 50
            },
            "line": 736,
            "code": "    it('Should build basic scalar correctly as any', async () => {\n      const schema = buildSchema(`scalar A`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result).not.toContain('export type A = any;');\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build enum correctly with custom values",
            "suites": [
                "Flow Plugin",
                "Scalars"
            ],
            "updatePoint": {
                "line": 746,
                "column": 54
            },
            "line": 746,
            "code": "    it('Should build enum correctly with custom values', async () => {\n      const schema = buildSchema(`scalar A`);\n      const result = (await plugin(\n        schema,\n        [],\n        { scalars: { A: 'MyCustomType' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build input types correctly, also with array, mutlti-dimensional arrays, non-null and custom types",
            "suites": [
                "Flow Plugin",
                "Input Object"
            ],
            "updatePoint": {
                "line": 762,
                "column": 113
            },
            "line": 762,
            "code": "    it('Should build input types correctly, also with array, mutlti-dimensional arrays, non-null and custom types', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n        }\n\n        input MyInput {\n          a: String!\n          b: Int\n          c: MyType\n          d: MyType!\n          e: [String]\n          f: [String]!\n          g: [String!]!\n          h: [String!]\n          i: [[String]]\n          j: [[[String]]]\n          k: [[String]]!\n          l: [[String!]!]!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build type correctly",
            "suites": [
                "Flow Plugin",
                "Object"
            ],
            "updatePoint": {
                "line": 791,
                "column": 35
            },
            "line": 791,
            "code": "    it('Should build type correctly', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build type correctly when implementing interface",
            "suites": [
                "Flow Plugin",
                "Object"
            ],
            "updatePoint": {
                "line": 803,
                "column": 63
            },
            "line": 803,
            "code": "    it('Should build type correctly when implementing interface', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface {\n          foo: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build type correctly when implementing multiple interfaces",
            "suites": [
                "Flow Plugin",
                "Object"
            ],
            "updatePoint": {
                "line": 819,
                "column": 73
            },
            "line": 819,
            "code": "    it('Should build type correctly when implementing multiple interfaces', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        interface MyOtherInterface {\n          bar: String!\n        }\n\n        type MyType implements MyInterface & MyOtherInterface {\n          foo: String!\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build type correctly with links between types",
            "suites": [
                "Flow Plugin",
                "Object"
            ],
            "updatePoint": {
                "line": 840,
                "column": 60
            },
            "line": 840,
            "code": "    it('Should build type correctly with links between types', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: MyOtherType!\n        }\n\n        type MyOtherType {\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build union as type correctly",
            "suites": [
                "Flow Plugin",
                "Union"
            ],
            "updatePoint": {
                "line": 858,
                "column": 44
            },
            "line": 858,
            "code": "    it('Should build union as type correctly', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType;\n    `);\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should build interface correctly",
            "suites": [
                "Flow Plugin",
                "Interface"
            ],
            "updatePoint": {
                "line": 882,
                "column": 40
            },
            "line": 882,
            "code": "    it('Should build interface correctly', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should handle directive declarations correctly by clearing it",
            "suites": [
                "Flow Plugin",
                "Directives"
            ],
            "updatePoint": {
                "line": 896,
                "column": 69
            },
            "line": 896,
            "code": "    it('Should handle directive declarations correctly by clearing it', async () => {\n      const schema = buildSchema(`\n        directive @simple on FIELD_DEFINITION\n        directive @withArgument(arg: Int!) on FIELD_DEFINITION\n        directive @objSimple on OBJECT\n        directive @universal on OBJECT | FIELD_DEFINITION | ENUM_VALUE\n      `);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Issue #1645 - Input type fields does not have optional sign",
            "suites": [
                "Flow Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 911,
                "column": 67
            },
            "line": 911,
            "code": "    it('Issue #1645 - Input type fields does not have optional sign', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          mutation: Mutation\n        }\n\n        type Mutation {\n          updateUser(userId: ID!, update: UpdateUser): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n\n        input UpdateUser {\n          username: String\n          email: String\n        }\n      `);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "should not contain __typename",
            "suites": [
                "Flow Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 940,
                "column": 35
            },
            "line": 940,
            "code": "  it('should not contain __typename', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const content = await plugin(schema, [], { skipTypename: true }, { outputFile: '' });\n    expect(content).not.toContain('__typename');\n\n    validateFlow(content);\n  });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "should generate arguments types correctly with args",
            "suites": [
                "Flow Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 968,
                "column": 57
            },
            "line": 968,
            "code": "  it('should generate arguments types correctly with args', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        release: String\n      }\n      type Mutation {\n        random(byteLength: Int!): String!\n      }\n      schema {\n        query: Query\n        mutation: Mutation\n      }\n    `);\n\n    const content = (await plugin(\n      schema,\n      [],\n      { addUnderscoreToArgsType: true, skipTypename: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    expect(mergeOutputs([content])).toContain(`export type Mutation_RandomArgs = {`);\n    validateFlow(content);\n  });",
            "file": "flow.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/flow/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type",
            "suites": [
                "Flow Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 77,
                "column": 64
            },
            "line": 77,
            "code": "    it('Should allow custom naming and point to the correct type', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { namingConvention: 'change-case-all#lowerCase' },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type notificationsquery = ({\n        ...{ __typename?: 'Query' },\n      ...{| notifications: Array<({\n          ...{ __typename?: 'TextNotification' },\n        ...$Pick<textnotification, {| text: *, id: * |}>\n      }) | ({\n          ...{ __typename?: 'ImageNotification' },\n        ...$Pick<imagenotification, {| imageUrl: *, id: * |}>,\n        ...{| metadata: ({\n            ...{ __typename?: 'ImageMetadata' },\n          ...$Pick<imagemetadata, {| createdBy: * |}>\n        }) |}\n      })> |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type - with custom prefix",
            "suites": [
                "Flow Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 129,
                "column": 85
            },
            "line": 129,
            "code": "    it('Should allow custom naming and point to the correct type - with custom prefix', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { typesPrefix: 'i', namingConvention: 'change-case-all#lowerCase' },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`export type inotificationsqueryvariables = {};`);\n      expect(result).toBeSimilarStringTo(`\n      export type inotificationsquery = ({\n        ...{ __typename?: 'Query' },\n      ...{| notifications: Array<({\n          ...{ __typename?: 'TextNotification' },\n        ...$Pick<itextnotification, {| text: *, id: * |}>\n      }) | ({\n          ...{ __typename?: 'ImageNotification' },\n        ...$Pick<iimagenotification, {| imageUrl: *, id: * |}>,\n        ...{| metadata: ({\n            ...{ __typename?: 'ImageMetadata' },\n          ...$Pick<iimagemetadata, {| createdBy: * |}>\n        }) |}\n      })> |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should handle \"namespacedImportName\" and add it when specified",
            "suites": [
                "Flow Operations Plugin",
                "Import namespace"
            ],
            "updatePoint": {
                "line": 184,
                "column": 70
            },
            "line": 184,
            "code": "    it('Should handle \"namespacedImportName\" and add it when specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(schema, [{ location: '', document: ast }], { namespacedImportName: 'Types' }, { outputFile: '' }),\n      ]);\n\n      expect(result).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should skip __typename when skipTypename is set to true",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 213,
                "column": 63
            },
            "line": 213,
            "code": "    it('Should skip __typename when skipTypename is set to true', async () => {\n      const ast = parse(`\n        query {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).not.toContain(`__typename`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when explicitly specified",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 236,
                "column": 71
            },
            "line": 236,
            "code": "    it('Should add __typename as non-optional when explicitly specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          {},\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = ({\n        ...{ __typename: 'Query' },\n      ...$Pick<Query, {| dummy?: * |}>\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add __typename as optional when its not specified",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 265,
                "column": 64
            },
            "line": 265,
            "code": "    it('Should add __typename as optional when its not specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          {},\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = ({\n        ...{ __typename?: 'Query' },\n      ...$Pick<Query, {| dummy?: * |}>\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when its explictly specified, even if skipTypename is true",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 293,
                "column": 104
            },
            "line": 293,
            "code": "    it('Should add __typename as non-optional when its explictly specified, even if skipTypename is true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = ({\n        ...{ __typename: 'Query' },\n      ...$Pick<Query, {| dummy?: * |}>\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add __typename correctly when unions are in use",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 322,
                "column": 62
            },
            "line": 322,
            "code": "    it('Should add __typename correctly when unions are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          {},\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UnionTestQuery = ({\n        ...{ __typename?: 'Query' },\n      ...{| unionTest?: ?({\n          ...{ __typename?: 'User' },\n        ...$Pick<User, {| id: * |}>\n      }) | ({\n          ...{ __typename?: 'Profile' },\n        ...$Pick<Profile, {| age?: * |}>\n      }) |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add non optional __typename when specified in config",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 365,
                "column": 67
            },
            "line": 365,
            "code": "    it('Should add non optional __typename when specified in config', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { nonOptionalTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UnionTestQuery = ({\n        ...{ __typename: 'Query' },\n      ...{| unionTest?: ?({\n          ...{ __typename: 'User' },\n        ...$Pick<User, {| id: * |}>\n      }) | ({\n          ...{ __typename: 'Profile' },\n        ...$Pick<Profile, {| age?: * |}>\n      }) |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should add __typename correctly when interfaces are in use",
            "suites": [
                "Flow Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 408,
                "column": 66
            },
            "line": 408,
            "code": "    it('Should add __typename correctly when interfaces are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          {},\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`\n      export type NotificationsQuery = ({\n        ...{ __typename?: 'Query' },\n      ...{| notifications: Array<({\n          ...{ __typename?: 'TextNotification' },\n        ...$Pick<TextNotification, {| text: *, id: * |}>\n      }) | ({\n          ...{ __typename?: 'ImageNotification' },\n        ...$Pick<ImageNotification, {| imageUrl: *, id: * |}>,\n        ...{| metadata: ({\n            ...{ __typename?: 'ImageMetadata' },\n          ...$Pick<ImageMetadata, {| createdBy: * |}>\n        }) |}\n      })> |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly",
            "suites": [
                "Flow Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 461,
                "column": 49
            },
            "line": 461,
            "code": "    it('Should handle unnamed documents correctly', async () => {\n      const ast = parse(`\n        query {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`export type Unnamed_1_Query = $Pick<Query, {| dummy?: * |}>;`);\n      expect(result).toBeSimilarStringTo(`export type Unnamed_1_QueryVariables = {};`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly with multiple documents",
            "suites": [
                "Flow Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 486,
                "column": 73
            },
            "line": 486,
            "code": "    it('Should handle unnamed documents correctly with multiple documents', async () => {\n      const ast = parse(`\n        query {\n          dummy\n        }\n\n        query {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`export type Unnamed_1_Query = $Pick<Query, {| dummy?: * |}>;`);\n      expect(result).toBeSimilarStringTo(`export type Unnamed_1_QueryVariables = {};`);\n      expect(result).toBeSimilarStringTo(`export type Unnamed_2_Query = $Pick<Query, {| dummy?: * |}>;`);\n      expect(result).toBeSimilarStringTo(`export type Unnamed_2_QueryVariables = {};`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with no other fields",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 518,
                "column": 86
            },
            "line": 518,
            "code": "    it('Should support fragment spread correctly with simple type with no other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n          role\n        }\n\n        query me {\n          me {\n            ...UserFields\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toMatchInlineSnapshot(`\n\"// @flow\n\ntype $Pick<Origin: Object, Keys: Object> = $ObjMapi<Keys, <Key>(k: Key) => $ElementType<Origin, Key>>;\n\nexport type UserFieldsFragment = ({\n    ...$Pick<User, {| id: *, username: *, role?: * |}>,\n  ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n});\n\nexport type MeQueryVariables = {};\n\n\nexport type MeQuery = {| me?: ?({\n      ...$Pick<User, {| id: *, username: *, role?: * |}>,\n    ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n  }) |};\n\"\n`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support fragment spread with flattenGeneratedTypes",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 571,
                "column": 65
            },
            "line": 571,
            "code": "    it('Should support fragment spread with flattenGeneratedTypes', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n          role\n        }\n\n        query me {\n          me {\n            ...UserFields\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true, flattenGeneratedTypes: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support fragment spread with flattenGeneratedTypes and preResolveTypes",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 606,
                "column": 85
            },
            "line": 606,
            "code": "    it('Should support fragment spread with flattenGeneratedTypes and preResolveTypes', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n          role\n        }\n\n        query me {\n          me {\n            ...UserFields\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true, flattenGeneratedTypes: true, preResolveTypes: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toMatchSnapshot();\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with other fields",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 641,
                "column": 83
            },
            "line": 641,
            "code": "    it('Should support fragment spread correctly with simple type with other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            username\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type MeQuery = {| me?: ?({\n            ...$Pick<User, {| username: *, id: * |}>,\n          ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n        }) |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with multiple fragment spread",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 680,
                "column": 78
            },
            "line": 680,
            "code": "    it('Should support fragment spread correctly with multiple fragment spread', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n        }\n\n        fragment UserProfile on User {\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            ...UserProfile\n            username\n          }\n        }\n      `);\n\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type MeQuery = {| me?: ?({\n        ...$Pick<User, {| username: *, id: * |}>,\n      ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n      }) |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support interfaces correctly when used with inline fragments",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 724,
                "column": 75
            },
            "line": 724,
            "code": "    it('Should support interfaces correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type NotificationsQuery = {| notifications: Array<$Pick<TextNotification, {| text: *, id: * |}> | ({\n        ...$Pick<ImageNotification, {| imageUrl: *, id: * |}>,\n      ...{| metadata: $Pick<ImageMetadata, {| createdBy: * |}> |}\n    })> |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 766,
                "column": 70
            },
            "line": 766,
            "code": "    it('Should support union correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UnionTestQuery = {| unionTest?: ?$Pick<User, {| id: * |}> | $Pick<Profile, {| age?: * |}> |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should support inline fragments",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 800,
                "column": 39
            },
            "line": 800,
            "code": "    it('Should support inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            ... on User {\n              username\n              profile {\n                age\n              }\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type CurrentUserQuery = {| me?: ?({\n        ...$Pick<User, {| username: *, id: * |}>,\n      ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n    }) |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query on GitHub schema",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 837,
                "column": 80
            },
            "line": 837,
            "code": "    it('Should build a basic selection set based on basic query on GitHub schema', async () => {\n      const ast = parse(/* GraphQL */ `\n        query me($repoFullName: String!) {\n          currentUser {\n            login\n            html_url\n          }\n          entry(repoFullName: $repoFullName) {\n            id\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          gitHuntSchema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(\n        `export type MeQueryVariables = {\n          repoFullName: $ElementType<Scalars, 'String'>,\n        };`\n      );\n      expect(result).toBeSimilarStringTo(`\n      export type MeQuery = {| currentUser?: ?$Pick<User, {| login: *, html_url: * |}>, entry?: ?({\n        ...$Pick<Entry, {| id: *, createdAt: * |}>,\n      ...{| postedBy: $Pick<User, {| login: *, html_url: * |}> |}\n    }) |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 881,
                "column": 63
            },
            "line": 881,
            "code": "    it('Should build a basic selection set based on basic query', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(`export type DummyQuery = $Pick<Query, {| dummy?: * |}>;`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query with field aliasing for basic scalar",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 904,
                "column": 100
            },
            "line": 904,
            "code": "    it('Should build a basic selection set based on basic query with field aliasing for basic scalar', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          customName: dummy\n          customName2: dummyWithType {\n            age\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type DummyQuery = ({\n        ...{| customName?: $ElementType<Query, 'dummy'> |},\n      ...{| customName2?: ?$Pick<Profile, {| age?: * |}> |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on a query with inner fields",
            "suites": [
                "Flow Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 936,
                "column": 77
            },
            "line": 936,
            "code": "    it('Should build a basic selection set based on a query with inner fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            username\n            role\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type CurrentUserQuery = {| me?: ?({\n        ...$Pick<User, {| id: *, username: *, role?: * |}>,\n      ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n    }) |};\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should build fragment definition correctly - with name and selection set",
            "suites": [
                "Flow Operations Plugin",
                "Fragment Definition"
            ],
            "updatePoint": {
                "line": 975,
                "column": 80
            },
            "line": 975,
            "code": "    it('Should build fragment definition correctly - with name and selection set', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UserFieldsFragment = ({\n        ...$Pick<User, {| id: *, username: * |}>,\n      ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n    });\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should detect Mutation correctly",
            "suites": [
                "Flow Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 1010,
                "column": 40
            },
            "line": 1010,
            "code": "    it('Should detect Mutation correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        mutation login {\n          login(username: \"1\", password: \"2\") {\n            id\n            username\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type LoginMutation = {| login?: ?({\n        ...$Pick<User, {| id: *, username: * |}>,\n      ...{| profile?: ?$Pick<Profile, {| age?: * |}> |}\n    }) |};\n      `);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should detect Query correctly",
            "suites": [
                "Flow Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 1045,
                "column": 37
            },
            "line": 1045,
            "code": "    it('Should detect Query correctly', async () => {\n      const ast = parse(`\n        query test {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`export type TestQuery = $Pick<Query, {| dummy?: * |}>;`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should detect Subscription correctly",
            "suites": [
                "Flow Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 1069,
                "column": 44
            },
            "line": 1069,
            "code": "    it('Should detect Subscription correctly', async () => {\n      const ast = parse(`\n        subscription test {\n          userCreated {\n            id\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n      expect(result).toBeSimilarStringTo(\n        `export type TestSubscription = {| userCreated?: ?$Pick<User, {| id: * |}> |};`\n      );\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should handle operation variables correctly",
            "suites": [
                "Flow Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 1096,
                "column": 51
            },
            "line": 1096,
            "code": "    it('Should handle operation variables correctly', async () => {\n      const ast = parse(`\n        query testQuery($username: String, $email: String, $password: String!, $input: InputType, $mandatoryInput: InputType!, $testArray: [String], $requireString: [String]!, $innerRequired: [String!]!) {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(\n        `export type TestQueryQueryVariables = {\n          username?: ?$ElementType<Scalars, 'String'>,\n          email?: ?$ElementType<Scalars, 'String'>,\n          password: $ElementType<Scalars, 'String'>,\n          input?: ?InputType,\n          mandatoryInput: InputType,\n          testArray?: ?Array<?$ElementType<Scalars, 'String'>> | ?$ElementType<Scalars, 'String'>,\n          requireString: Array<?$ElementType<Scalars, 'String'>> | ?$ElementType<Scalars, 'String'>,\n          innerRequired: Array<$ElementType<Scalars, 'String'>> | $ElementType<Scalars, 'String'>,\n        };`\n      );\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should create empty variables when there are no operation variables",
            "suites": [
                "Flow Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 1131,
                "column": 75
            },
            "line": 1131,
            "code": "    it('Should create empty variables when there are no operation variables', async () => {\n      const ast = parse(`\n        query testQuery {\n          dummy\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`export type TestQueryQueryVariables = {};`);\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should respect flow option useFlowExactObjects=false",
            "suites": [
                "Flow Operations Plugin",
                "Output options"
            ],
            "updatePoint": {
                "line": 1157,
                "column": 60
            },
            "line": 1157,
            "code": "    it('Should respect flow option useFlowExactObjects=false', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            username\n            role\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true, useFlowExactObjects: false },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type CurrentUserQuery = { me?: ?({\n        ...$Pick<User, { id: *, username: *, role?: * }>,\n      ...{ profile?: ?$Pick<Profile, { age?: * }> }\n    }) };\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should respect flow option useFlowReadOnlyTypes",
            "suites": [
                "Flow Operations Plugin",
                "Output options"
            ],
            "updatePoint": {
                "line": 1194,
                "column": 55
            },
            "line": 1194,
            "code": "    it('Should respect flow option useFlowReadOnlyTypes', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            username\n            adminRole: role(id: 1)\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [\n          {\n            location: '',\n            document: ast,\n          },\n        ],\n        { skipTypename: true, useFlowReadOnlyTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.content).toMatchSnapshot();\n      expect(result.content).toBeSimilarStringTo(`\n      export type CurrentUserQuery = {| +me?: ?({\n        ...$Pick<User, {| +id: *, +username: * |}>,\n        ...{| +adminRole?: $ElementType<User, 'role'> |},\n        ...{| +profile?: ?$Pick<Profile, {| +age?: * |}> |}\n    }) |};\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "@skip, @include should result in optional fields",
            "suites": [
                "Flow Operations Plugin",
                "Directives handling"
            ],
            "updatePoint": {
                "line": 1232,
                "column": 56
            },
            "line": 1232,
            "code": "    it('@skip, @include should result in optional fields', async () => {\n      const schema1 = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n        }\n\n        type Address {\n          city: String!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n      const result = mergeOutputs([\n        await plugin(\n          schema1,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { skipTypename: true, useFlowExactObjects: false },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UserQueryVariables = {\n        showAddress: $ElementType<Scalars, 'Boolean'>,\n        showName: $ElementType<Scalars, 'Boolean'>,\n      };\n      export type UserQuery = { user: ({\n            ...$MakeOptional<$Pick<User, { id: *, name: * }>, { name: * }>,\n          ...{ address?: $Pick<Address, { city: * }>, friends?: Array<$Pick<User, { id: * }>> }\n        }) };\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "@skip, @include should resolve to optional on preResolveTypes",
            "suites": [
                "Flow Operations Plugin",
                "Directives handling"
            ],
            "updatePoint": {
                "line": 1292,
                "column": 69
            },
            "line": 1292,
            "code": "    it('@skip, @include should resolve to optional on preResolveTypes', async () => {\n      const schema1 = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n        }\n        type Address {\n          city: String!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n\n      const result = mergeOutputs([\n        await plugin(\n          schema1,\n          [\n            {\n              location: '',\n              document: ast,\n            },\n          ],\n          { preResolveTypes: true },\n          { outputFile: '' }\n        ),\n      ]);\n\n      expect(result).toBeSimilarStringTo(`\n      export type UserQueryVariables = {\n        showAddress: $ElementType<Scalars, 'Boolean'>,\n        showName: $ElementType<Scalars, 'Boolean'>,\n      };\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, name?: string, address?: { __typename?: 'Address', city: string }, friends?: Array<{ __typename?: 'User', id: string }> } };\n      `);\n\n      validateFlow(result);\n    });",
            "file": "flow-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/operations/tests"
        },
        {
            "name": "Should not generate enum internal values resolvers when enum doesnt have enumValues set",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 10,
                "column": 95
            },
            "line": 10,
            "code": "    it('Should not generate enum internal values resolvers when enum doesnt have enumValues set', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {};\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      expect(result.prepend).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(result.content).not.toContain('EnumResolverSignature');\n    });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as object with explicit values",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 29,
                "column": 114
            },
            "line": 29,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as object with explicit values', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        enumValues: {\n          MyEnum: {\n            A: 'val_1',\n            B: 'val_2',\n            C: 'val_3',\n          },\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n      expect(result.prepend).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(result.content).not.toContain('EnumResolverSignature');\n      expect(result.content).toContain(`export type MyEnumResolvers = {| A: 'val_1', B: 'val_2', C: 'val_3' |};`);\n    });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as external enum",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 56,
                "column": 100
            },
            "line": 56,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        enumValues: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      expect(result.prepend).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(result.content).toContain('EnumResolverSignature');\n      expect(result.content).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{| A?: *, B?: *, C?: * |}, $ElementType<ResolversTypes, 'MyEnum'>>;`\n      );\n      expect(result.content).toContain(`MyEnum?: MyEnumResolvers,`);\n    });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has mappers pointing to external enum",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 83,
                "column": 102
            },
            "line": 83,
            "code": "    it('Should generate enum internal values resolvers when enum has mappers pointing to external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        mappers: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      expect(result.prepend).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(result.content).toContain('EnumResolverSignature');\n      expect(result.content).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{| A?: *, B?: *, C?: * |}, $ElementType<ResolversTypes, 'MyEnum'>>;`\n      );\n    });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 109,
                "column": 114
            },
            "line": 109,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        enumValues: './enums',\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      expect(result.prepend).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(result.content).toContain('EnumResolverSignature');\n      expect(result.content).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{| A?: *, B?: *, C?: * |}, $ElementType<ResolversTypes, 'MyEnum'>>;`\n      );\n    });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 134,
                "column": 42
            },
            "line": 134,
            "code": "  it('Should generate basic type resolvers', () => {\n    const result = plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result).toMatchSnapshot();\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Default values of args and compatibility with flow plugin",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 140,
                "column": 63
            },
            "line": 140,
            "code": "  it('Default values of args and compatibility with flow plugin', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        something(arg: String = \"default_value\"): String\n      }\n    `);\n\n    const config: any = { noSchemaStitching: true };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n    expect(result.prepend).toContain(\n      `export type $RequireFields<Origin, Keys> = $Diff<Origin, Keys> & $ObjMapi<Keys, <Key>(k: Key) => $NonMaybeType<$ElementType<Origin, Key>>>;`\n    );\n    expect(result.content).toContain(\n      `something?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<QuerySomethingArgs, { arg: * }>>,`\n    );\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate ResolversParentTypes",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 158,
                "column": 42
            },
            "line": 158,
            "code": "  it('Should generate ResolversParentTypes', () => {\n    const result = plugin(schema, [], {}, { outputFile: '' }) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      /** Mapping between all available schema types and the resolvers parents */\n      export type ResolversParentTypes = {\n        MyType: $Diff<MyType, { unionChild: *  }> & { unionChild: ?$ElementType<ResolversParentTypes, 'ChildUnion'> },\n        String: $ElementType<Scalars, 'String'>,\n        Child: Child,\n        MyOtherType: MyOtherType,\n        ChildUnion: $ElementType<ResolversParentTypes, 'Child'> | $ElementType<ResolversParentTypes, 'MyOtherType'>,\n        Query: {},\n        Subscription: {},\n        Node: $ElementType<ResolversParentTypes, 'SomeNode'>,\n        ID: $ElementType<Scalars, 'ID'>,\n        SomeNode: SomeNode,\n        MyUnion: $ElementType<ResolversParentTypes, 'MyType'> | $ElementType<ResolversParentTypes, 'MyOtherType'>,\n        MyScalar: $ElementType<Scalars, 'MyScalar'>,\n        Int: $ElementType<Scalars, 'Int'>,\n        Boolean: $ElementType<Scalars, 'Boolean'>,\n      };\n    `);\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has scalars",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 182,
                "column": 65
            },
            "line": 182,
            "code": "  it('Should generate the correct imports when schema has scalars', () => {\n    const result = plugin(buildSchema(`scalar MyScalar`), [], {}, { outputFile: '' }) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(\n      `import { type GraphQLResolveInfo, type GraphQLScalarType, type GraphQLScalarTypeConfig } from 'graphql';`\n    );\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has no scalars",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 190,
                "column": 68
            },
            "line": 190,
            "code": "  it('Should generate the correct imports when schema has no scalars', () => {\n    const result = plugin(\n      buildSchema(`type MyType { f: String }`),\n      [],\n      {},\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { type GraphQLResolveInfo } from 'graphql';`);\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate valid output with args",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 201,
                "column": 44
            },
            "line": 201,
            "code": "  it('Should generate valid output with args', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        release: String\n      }\n      type Mutation {\n        random(byteLength: Int!): String!\n      }\n      schema {\n        query: Query\n        mutation: Mutation\n      }\n    `);\n    const config = {\n      contextType: 'GraphQLContext',\n      skipTypename: true,\n      addUnderscoreToArgsType: true,\n    };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const o = mergeOutputs([result]);\n    expect(o).toContain(`$RequireFields<Mutation_RandomArgs, { byteLength: * }>>,`);\n    expect(o).toContain(\n      `export type $RequireFields<Origin, Keys> = $Diff<Origin, Keys> & $ObjMapi<Keys, <Key>(k: Key) => $NonMaybeType<$ElementType<Origin, Key>>>;`\n    );\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolver args type names when typesPrefix is specified",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 227,
                "column": 88
            },
            "line": 227,
            "code": "  it('Should generate the correct resolver args type names when typesPrefix is specified', () => {\n    const result = plugin(\n      buildSchema(`type MyType { f(a: String): String }`),\n      [],\n      { typesPrefix: 'T' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(\n      `f?: Resolver<?$ElementType<TResolversTypes, 'String'>, ParentType, ContextType, TMyTypeFArgs>,`\n    );\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "should use MaybePromise in ResolverTypeWrapper",
            "suites": [
                "Flow Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 240,
                "column": 52
            },
            "line": 240,
            "code": "  it('should use MaybePromise in ResolverTypeWrapper', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type MyQuery {\n        posts: [Post]\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      schema {\n        query: MyQuery\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'MyRoot',\n        asyncResolverTypes: true,\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolverTypeWrapper<T> = Promise<T> | T;\n    `);\n  });",
            "file": "flow-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes object when there are no mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 9,
                "column": 66
            },
            "line": 9,
            "code": "  it('Should build ResolversTypes object when there are no mappers', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<$Diff<MyType, { unionChild: *  }> & { unionChild: ?$ElementType<ResolversTypes, 'ChildUnion'> }>,\n      String: ResolverTypeWrapper<$ElementType<Scalars, 'String'>>,\n      Child: ResolverTypeWrapper<Child>,\n      MyOtherType: ResolverTypeWrapper<MyOtherType>,\n      ChildUnion: $ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$ElementType<Scalars, 'ID'>>,\n      SomeNode: ResolverTypeWrapper<SomeNode>,\n      MyUnion: $ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      MyScalar: ResolverTypeWrapper<$ElementType<Scalars, 'MyScalar'>>,\n      Int: ResolverTypeWrapper<$ElementType<Scalars, 'Int'>>,\n      Boolean: ResolverTypeWrapper<$ElementType<Scalars, 'Boolean'>>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with simple mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 31,
                "column": 53
            },
            "line": 31,
            "code": "  it('Should build ResolversTypes with simple mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'number',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>,\n      String: ResolverTypeWrapper<number>,\n      Child: ResolverTypeWrapper<$Diff<Child, { bar: * , parent: *  }> & { bar: $ElementType<ResolversTypes, 'String'>, parent: ?$ElementType<ResolversTypes, 'MyType'> }>,\n      MyOtherType: ResolverTypeWrapper<$Diff<MyOtherType, { bar: *  }> & { bar: $ElementType<ResolversTypes, 'String'> }>,\n      ChildUnion: $ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$ElementType<Scalars, 'ID'>>,\n      SomeNode: ResolverTypeWrapper<SomeNode>,\n      MyUnion: $ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      MyScalar: ResolverTypeWrapper<$ElementType<Scalars, 'MyScalar'>>,\n      Int: ResolverTypeWrapper<$ElementType<Scalars, 'Int'>>,\n      Boolean: ResolverTypeWrapper<$ElementType<Scalars, 'Boolean'>>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 63,
                "column": 56
            },
            "line": 63,
            "code": "  it('Should build ResolversTypes with defaultMapper set', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'string',\n        },\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>,\n      String: ResolverTypeWrapper<string>,\n      Child: ResolverTypeWrapper<any>,\n      MyOtherType: ResolverTypeWrapper<any>,\n      ChildUnion: ResolverTypeWrapper<any>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<any>,\n      SomeNode: ResolverTypeWrapper<any>,\n      MyUnion: ResolverTypeWrapper<any>,\n      MyScalar: ResolverTypeWrapper<any>,\n      Int: ResolverTypeWrapper<any>,\n      Boolean: ResolverTypeWrapper<any>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 96,
                "column": 55
            },
            "line": 96,
            "code": "  it('Should build ResolversTypes with external mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyType: './my-module#MyTypeDb',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>,\n      String: ResolverTypeWrapper<$ElementType<Scalars, 'String'>>,\n      Child: ResolverTypeWrapper<$Diff<Child, { parent: *  }> & { parent: ?$ElementType<ResolversTypes, 'MyType'> }>,\n      MyOtherType: ResolverTypeWrapper<MyOtherType>,\n      ChildUnion: $ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$ElementType<Scalars, 'ID'>>,\n      SomeNode: ResolverTypeWrapper<SomeNode>,\n      MyUnion: $ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      MyScalar: ResolverTypeWrapper<$ElementType<Scalars, 'MyScalar'>>,\n      Int: ResolverTypeWrapper<$ElementType<Scalars, 'Int'>>,\n      Boolean: ResolverTypeWrapper<$ElementType<Scalars, 'Boolean'>>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "should warn about unused mappers by default",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 127,
                "column": 49
            },
            "line": 127,
            "code": "  it('should warn about unused mappers by default', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).toHaveBeenCalledWith('Unused mappers: Post');\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "should be able not to warn about unused mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 164,
                "column": 53
            },
            "line": 164,
            "code": "  it('should be able not to warn about unused mappers', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n        showUnusedMappers: false,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).not.toHaveBeenCalled();\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 202,
                "column": 64
            },
            "line": 202,
            "code": "  it('Should generate basic type resolvers with external mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: $ElementType<Scalars, 'Int'>,\n      arg2: $ElementType<Scalars, 'String'>,\n      arg3: $ElementType<Scalars, 'Boolean'>,\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyOtherType'>> = {\n          bar?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n        };\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyScalarScalarConfig = {\n        ...GraphQLScalarTypeConfig<$ElementType<ResolversTypes, 'MyScalar'>, any>,\n        name: 'MyScalar'\n      };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyType'>> = {\n        foo?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        otherType?: Resolver<?$ElementType<ResolversTypes, 'MyOtherType'>, ParentType, ContextType>,\n        withArgs?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<MyTypeWithArgsArgs, { arg2: * }>>,\n        unionChild?: Resolver<?$ElementType<ResolversTypes, 'ChildUnion'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyUnion'>> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Node'>> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>,\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Query'>> = {\n        something?: Resolver<$ElementType<ResolversTypes, 'MyType'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'SomeNode'>> = {\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Subscription'>> = {\n        somethingChanged?: SubscriptionResolver<?$ElementType<ResolversTypes, 'MyOtherType'>, \"somethingChanged\", ParentType, ContextType>,\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers using same imported type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 284,
                "column": 89
            },
            "line": 284,
            "code": "  it('Should generate basic type resolvers with external mappers using same imported type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyType: './my-file#MyCustomOtherType',\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: $ElementType<Scalars, 'Int'>,\n      arg2: $ElementType<Scalars, 'String'>,\n      arg3: $ElementType<Scalars, 'Boolean'>,\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyOtherType'>> = {\n          bar?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n        };\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyScalarScalarConfig = {\n        ...GraphQLScalarTypeConfig<$ElementType<ResolversTypes, 'MyScalar'>, any>,\n        name: 'MyScalar'\n      };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyType'>> = {\n        foo?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        otherType?: Resolver<?$ElementType<ResolversTypes, 'MyOtherType'>, ParentType, ContextType>,\n        withArgs?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<MyTypeWithArgsArgs, { arg2: * }>>,\n        unionChild?: Resolver<?$ElementType<ResolversTypes, 'ChildUnion'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyUnion'>> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Node'>> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>,\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Query'>> = {\n        something?: Resolver<$ElementType<ResolversTypes, 'MyType'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'SomeNode'>> = {\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Subscription'>> = {\n        somethingChanged?: SubscriptionResolver<?$ElementType<ResolversTypes, 'MyOtherType'>, \"somethingChanged\", ParentType, ContextType>,\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolvers when used with mappers with interfaces",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 366,
                "column": 82
            },
            "line": 366,
            "code": "  it('Should generate the correct resolvers when used with mappers with interfaces', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          Node: 'MyNodeType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: $ElementType<Scalars, 'Int'>,\n      arg2: $ElementType<Scalars, 'String'>,\n      arg3: $ElementType<Scalars, 'Boolean'>,\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyOtherType'>> = {\n        bar?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyScalarScalarConfig = {\n      ...GraphQLScalarTypeConfig<$ElementType<ResolversTypes, 'MyScalar'>, any>,\n      name: 'MyScalar'\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyType'>> = {\n        foo?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        otherType?: Resolver<?$ElementType<ResolversTypes, 'MyOtherType'>, ParentType, ContextType>,\n        withArgs?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<MyTypeWithArgsArgs, { arg2: * }>>,\n        unionChild?: Resolver<?$ElementType<ResolversTypes, 'ChildUnion'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyUnion'>> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Node'>> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>,\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Query'>> = {\n        something?: Resolver<$ElementType<ResolversTypes, 'MyType'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'SomeNode'>> = {\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Subscription'>> = {\n        somethingChanged?: SubscriptionResolver<?$ElementType<ResolversTypes, 'MyOtherType'>, \"somethingChanged\", ParentType, ContextType>,\n      };\n    `);\n    await validate(mergeOutputs([result, `type MyNodeType = {};`]));\n\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to any",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 449,
                "column": 72
            },
            "line": 449,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to any', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: $ElementType<Scalars, 'Int'>,\n      arg2: $ElementType<Scalars, 'String'>,\n      arg3: $ElementType<Scalars, 'Boolean'>,\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyOtherType'>> = {\n        bar?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyScalarScalarConfig = {\n      ...GraphQLScalarTypeConfig<$ElementType<ResolversTypes, 'MyScalar'>, any>,\n      name: 'MyScalar'\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyType'>> = {\n        foo?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        otherType?: Resolver<?$ElementType<ResolversTypes, 'MyOtherType'>, ParentType, ContextType>,\n        withArgs?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<MyTypeWithArgsArgs, { arg2: * }>>,\n        unionChild?: Resolver<?$ElementType<ResolversTypes, 'ChildUnion'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyUnion'>> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Node'>> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>,\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Query'>> = {\n        something?: Resolver<$ElementType<ResolversTypes, 'MyType'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'SomeNode'>> = {\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Subscription'>> = {\n        somethingChanged?: SubscriptionResolver<?$ElementType<ResolversTypes, 'MyOtherType'>, \"somethingChanged\", ParentType, ContextType>,\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 527,
                "column": 88
            },
            "line": 527,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: './my-file#MyBaseType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyBaseType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: $ElementType<Scalars, 'Int'>,\n      arg2: $ElementType<Scalars, 'String'>,\n      arg3: $ElementType<Scalars, 'Boolean'>,\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyOtherType'>> = {\n        bar?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyScalarScalarConfig = {\n      ...GraphQLScalarTypeConfig<$ElementType<ResolversTypes, 'MyScalar'>, any>,\n      name: 'MyScalar'\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyType'>> = {\n        foo?: Resolver<$ElementType<ResolversTypes, 'String'>, ParentType, ContextType>,\n        otherType?: Resolver<?$ElementType<ResolversTypes, 'MyOtherType'>, ParentType, ContextType>,\n        withArgs?: Resolver<?$ElementType<ResolversTypes, 'String'>, ParentType, ContextType, $RequireFields<MyTypeWithArgsArgs, { arg2: * }>>,\n        unionChild?: Resolver<?$ElementType<ResolversTypes, 'ChildUnion'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'MyUnion'>> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Node'>> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>,\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Query'>> = {\n        something?: Resolver<$ElementType<ResolversTypes, 'MyType'>, ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'SomeNode'>> = {\n        id?: Resolver<$ElementType<ResolversTypes, 'ID'>, ParentType, ContextType>,\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>,\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType = $ElementType<ResolversParentTypes, 'Subscription'>> = {\n        somethingChanged?: SubscriptionResolver<?$ElementType<ResolversTypes, 'MyOtherType'>, \"somethingChanged\", ParentType, ContextType>,\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 607,
                "column": 79
            },
            "line": 607,
            "code": "  it('Should replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<$Diff<MyType, { otherType: * , unionChild: *  }> & { otherType: ?$ElementType<ResolversTypes, 'MyOtherType'>, unionChild: ?$ElementType<ResolversTypes, 'ChildUnion'> }>,\n      String: ResolverTypeWrapper<$ElementType<Scalars, 'String'>>,\n      Child: ResolverTypeWrapper<$Diff<Child, { parent: *  }> & { parent: ?$ElementType<ResolversTypes, 'MyType'> }>,\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>,\n      ChildUnion: $ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$ElementType<Scalars, 'ID'>>,\n      SomeNode: ResolverTypeWrapper<SomeNode>,\n      MyUnion: $ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      MyScalar: ResolverTypeWrapper<$ElementType<Scalars, 'MyScalar'>>,\n      Int: ResolverTypeWrapper<$ElementType<Scalars, 'Int'>>,\n      Boolean: ResolverTypeWrapper<$ElementType<Scalars, 'Boolean'>>,\n    };`);\n    await validate(mergeOutputs([result, `type MyOtherTypeCustom = {};`]));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should not replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 639,
                "column": 83
            },
            "line": 639,
            "code": "  it('Should not replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<$Diff<MyType, { otherType: * , unionChild: *  }> & { otherType: ?$ElementType<ResolversTypes, 'MyOtherType'>, unionChild: ?$ElementType<ResolversTypes, 'ChildUnion'> }>,\n      String: ResolverTypeWrapper<$ElementType<Scalars, 'String'>>,\n      Child: ResolverTypeWrapper<$Diff<Child, { parent: *  }> & { parent: ?$ElementType<ResolversTypes, 'MyType'> }>,\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>,\n      ChildUnion: $ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$ElementType<Scalars, 'ID'>>,\n      SomeNode: ResolverTypeWrapper<SomeNode>,\n      MyUnion: $ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>,\n      MyScalar: ResolverTypeWrapper<$ElementType<Scalars, 'MyScalar'>>,\n      Int: ResolverTypeWrapper<$ElementType<Scalars, 'Int'>>,\n      Boolean: ResolverTypeWrapper<$ElementType<Scalars, 'Boolean'>>,\n    };`);\n    await validate(mergeOutputs([result, `type MyTypeCustom = {}; type MyOtherTypeCustom = {};`]));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T}",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 671,
                "column": 66
            },
            "line": 671,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T}', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: '$Shape<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<$Shape<$Diff<MyType, { unionChild: *  }> & { unionChild: ?$ElementType<ResolversTypes, 'ChildUnion'> }>>,\n      String: ResolverTypeWrapper<$Shape<$ElementType<Scalars, 'String'>>>,\n      Child: ResolverTypeWrapper<$Shape<Child>>,\n      MyOtherType: ResolverTypeWrapper<$Shape<MyOtherType>>,\n      ChildUnion: $Shape<$ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<$Shape<$ElementType<Scalars, 'ID'>>>,\n      SomeNode: ResolverTypeWrapper<$Shape<SomeNode>>,\n      MyUnion: $Shape<$ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>>,\n      MyScalar: ResolverTypeWrapper<$Shape<$ElementType<Scalars, 'MyScalar'>>>,\n      Int: ResolverTypeWrapper<$Shape<$ElementType<Scalars, 'Int'>>>,\n      Boolean: ResolverTypeWrapper<$Shape<$ElementType<Scalars, 'Boolean'>>>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T} with external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 700,
                "column": 91
            },
            "line": 700,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T} with external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: './my-wrapper#CustomPartial<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { CustomPartial } from './my-wrapper';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<CustomPartial<$Diff<MyType, { unionChild: *  }> & { unionChild: ?$ElementType<ResolversTypes, 'ChildUnion'> }>>,\n      String: ResolverTypeWrapper<CustomPartial<$ElementType<Scalars, 'String'>>>,\n      Child: ResolverTypeWrapper<CustomPartial<Child>>,\n      MyOtherType: ResolverTypeWrapper<CustomPartial<MyOtherType>>,\n      ChildUnion: CustomPartial<$ElementType<ResolversTypes, 'Child'> | $ElementType<ResolversTypes, 'MyOtherType'>>,\n      Query: ResolverTypeWrapper<{}>,\n      Subscription: ResolverTypeWrapper<{}>,\n      Node: $ElementType<ResolversTypes, 'SomeNode'>,\n      ID: ResolverTypeWrapper<CustomPartial<$ElementType<Scalars, 'ID'>>>,\n      SomeNode: ResolverTypeWrapper<CustomPartial<SomeNode>>,\n      MyUnion: CustomPartial<$ElementType<ResolversTypes, 'MyType'> | $ElementType<ResolversTypes, 'MyOtherType'>>,\n      MyScalar: ResolverTypeWrapper<CustomPartial<$ElementType<Scalars, 'MyScalar'>>>,\n      Int: ResolverTypeWrapper<CustomPartial<$ElementType<Scalars, 'Int'>>>,\n      Boolean: ResolverTypeWrapper<CustomPartial<$ElementType<Scalars, 'Boolean'>>>,\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/flow/resolvers/tests"
        },
        {
            "name": "Should produce valid Java code",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 37,
                "column": 38
            },
            "line": 37,
            "code": "    it('Should produce valid Java code', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n      await validateJava(output);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should create a basic input type signature correctly",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 43,
                "column": 60
            },
            "line": 43,
            "code": "    it('Should create a basic input type signature correctly', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(result.prepend).toContain('import com.apollographql.apollo.api.InputType;');\n      expect(result.prepend).toContain('import javax.annotation.Generated;');\n\n      expect(output).toContain(`@Generated(\"Apollo GraphQL\")`);\n      expect(output).toBeSimilarStringTo(`public final class MyInput implements InputType {`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should create private fields correctly",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 54,
                "column": 46
            },
            "line": 54,
            "code": "    it('Should create private fields correctly', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(result.prepend).toContain('import com.apollographql.apollo.api.Input;');\n      expect(result.prepend).toContain('import java.lang.Integer;');\n      expect(result.prepend).toContain('import java.lang.String;');\n      expect(result.prepend).toContain('import java.lang.Boolean;');\n      expect(result.prepend).toContain('import com.app.generated.graphql.NestedInput;');\n      expect(result.prepend).toContain('import javax.annotation.Nonnull;');\n\n      expect(output).toContain(`private final @Nonnull Integer foo;`);\n      expect(output).toContain(`private final Input<String> bar;`);\n      expect(output).toContain(`private final @Nonnull Boolean something;`);\n      expect(output).toContain(`private final Input<NestedInput> nested;`);\n      expect(output).toContain(`private final Input<List<String>> testArr;`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should create ctor correctly",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 72,
                "column": 36
            },
            "line": 72,
            "code": "    it('Should create ctor correctly', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(output)\n        .toBeSimilarStringTo(`MyInput(@Nonnull Integer foo, Input<String> bar, @Nonnull Boolean something, Input<NestedInput> nested, Input<List<String>> testArr) {\n        this.foo = foo;\n        this.bar = bar;\n        this.something = something;\n        this.nested = nested;\n        this.testArr = testArr;\n      }\n      `);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should create getters correctly",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 87,
                "column": 39
            },
            "line": 87,
            "code": "    it('Should create getters correctly', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(result.prepend).toContain('import javax.annotation.Nullable;');\n\n      expect(output).toBeSimilarStringTo(`public @Nonnull Integer foo() { return this.foo; }`);\n      expect(output).toBeSimilarStringTo(`public @Nullable Input<String> bar() { return this.bar; }`);\n      expect(output).toBeSimilarStringTo(`public @Nonnull Boolean something() { return this.something; }`);\n      expect(output).toBeSimilarStringTo(`public @Nullable Input<NestedInput> nested() { return this.nested; }`);\n      expect(output).toBeSimilarStringTo(`public @Nullable Input<List<String>> testArr() { return this.testArr; }`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should have Builder static getter",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 100,
                "column": 41
            },
            "line": 100,
            "code": "    it('Should have Builder static getter', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(output).toBeSimilarStringTo(`public static Builder builder() { return new Builder(); }`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should have Builder nested class ",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 107,
                "column": 41
            },
            "line": 107,
            "code": "    it('Should have Builder nested class ', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      expect(output).toBeSimilarStringTo(`public static final class Builder {`);\n      expect(output).toBeSimilarStringTo(`\n        private @Nonnull Integer foo;\n        private Input<String> bar = Input.absent();\n        private @Nonnull Boolean something;\n        private Input<NestedInput> nested = Input.absent();\n        private Input<List<String>> testArr = Input.absent();\n      `);\n      expect(output).toBeSimilarStringTo(`Builder() {}`);\n      expect(output).toBeSimilarStringTo(`public Builder foo(@Nonnull Integer foo) {\n        this.foo = foo;\n        return this;\n      }`);\n      expect(output).toBeSimilarStringTo(`public Builder bar(@Nullable String bar) {\n        this.bar = Input.fromNullable(bar);\n        return this;\n      }`);\n      expect(output).toBeSimilarStringTo(`public Builder something(@Nonnull Boolean something) {\n        this.something = something;\n        return this;\n      }`);\n      expect(output).toBeSimilarStringTo(`public Builder nested(@Nullable NestedInput nested) {\n        this.nested = Input.fromNullable(nested);\n        return this;\n      }`);\n      expect(output).toBeSimilarStringTo(`public Builder testArr(@Nullable List<String> testArr) {\n        this.testArr = Input.fromNullable(testArr);\n        return this;\n      }`);\n      expect(output).toBeSimilarStringTo(`public MyInput build() {\n        Utils.checkNotNull(foo, \"foo == null\");\n        Utils.checkNotNull(something, \"something == null\");\n        return new MyInput(foo, bar, something, nested, testArr);\n      }`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should have marshaller built for the fields",
            "suites": [
                "java-apollo-android",
                "Input Types"
            ],
            "updatePoint": {
                "line": 147,
                "column": 51
            },
            "line": 147,
            "code": "    it('Should have marshaller built for the fields', async () => {\n      const result = await plugin(schema, files, config);\n      const output = mergeOutputs([result]);\n\n      // Simple, non-null\n      expect(output).toBeSimilarStringTo(`writer.writeInt(\"foo\", foo);`);\n      // simple, nullable\n      expect(output).toBeSimilarStringTo(`if(bar.defined) {\n        writer.writeString(\"bar\", bar.value);\n  }`);\n      // non null, object\n      expect(output).toBeSimilarStringTo(`if(nested.defined) {\n        writer.writeObject(\"nested\", nested.value != null ? nested.value.marshaller() : null);\n  }`);\n      // non null, list\n      expect(output).toBeSimilarStringTo(`if(testArr.defined) {\n                      \n        writer.writeList(\"testArr\", testArr.value != null ? new InputFieldWriter.ListWriter() {\n          @Override\n          public void write(InputFieldWriter.ListItemWriter listItemWriter) throws IOException {\n            for (String $item : testArr.value) {\n              listItemWriter.writeString($item);\n            }\n          }\n        } : null);\n    }`);\n    });",
            "file": "input.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should handle Query correctly",
            "suites": [
                "Operations Visitor"
            ],
            "updatePoint": {
                "line": 192,
                "column": 35
            },
            "line": 192,
            "code": "  it('Should handle Query correctly', async () => {\n    const ast = {\n      document: parse(/* GraphQL */ `\n        query ListProducts($filter: ModelProductFilterInput, $limit: Int, $nextToken: String) {\n          listProducts(filter: $filter, limit: $limit, nextToken: $nextToken) {\n            items {\n              id\n              title\n              content\n              price\n              rating\n            }\n            nextToken\n          }\n        }\n      `),\n      location: '',\n    };\n\n    const result = await plugin(schema, [ast], { package: 'app.test.generated.graphql', fileType: FileType.OPERATION });\n    const output = mergeOutputs([result]);\n\n    expect(output).toMatchSnapshot();\n\n    expect(output).toBeSimilarStringTo(`\n    public ListProductsQuery(@Nullable ModelProductFilterInput filter, @Nullable Integer limit, @Nullable String nextToken) {\n      this.variables = new ListProductsQuery.Variables(filter, limit, nextToken);\n    }\n    `);\n\n    expect(output).toContain(`public String operationId() {`);\n    expect(output).toContain(`public String queryDocument() {`);\n    expect(output).toBeSimilarStringTo(`\n    @Override\n    public ListProductsQuery.Data wrapData(ListProductsQuery.Data data) {\n      return data;\n    }\n    `);\n    expect(output).toBeSimilarStringTo(`\n    @Override\n    public ResponseFieldMapper<ListProductsQuery.Data> responseFieldMapper() {\n      return new Data.Mapper();\n    }`);\n    expect(output).toBeSimilarStringTo(`static final ResponseField[] $responseFields = {\n      ResponseField.forString(\"__typename\", \"__typename\", null, false, Collections.<ResponseField.Condition>emptyList()),\n      ResponseField.forList(\"items\", \"items\", null, true, Collections.<ResponseField.Condition>emptyList()),\n      ResponseField.forString(\"nextToken\", \"nextToken\", null, true, Collections.<ResponseField.Condition>emptyList())\n    };`);\n    expect(output).toBeSimilarStringTo(`\n    public static final class Builder {\n      private @Nullable ModelProductFilterInput filter;\n  \n      private @Nullable Integer limit;\n  \n      private @Nullable String nextToken;\n  \n      Builder() {\n      }\n  \n      public Builder filter(@Nullable ModelProductFilterInput filter) {\n        this.filter = filter;\n        return this;\n      }\n  \n      public Builder limit(@Nullable Integer limit) {\n        this.limit = limit;\n        return this;\n      }\n  \n      public Builder nextToken(@Nullable String nextToken) {\n        this.nextToken = nextToken;\n        return this;\n      }\n  \n      public ListProductsQuery build() {\n        return new ListProductsQuery(filter, limit, nextToken);\n      }\n    }`);\n  });",
            "file": "operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should handle Query correctly with fragments",
            "suites": [
                "Operations Visitor"
            ],
            "updatePoint": {
                "line": 272,
                "column": 50
            },
            "line": 272,
            "code": "  it('Should handle Query correctly with fragments', async () => {\n    const ast = {\n      document: parse(/* GraphQL */ `\n        query ListProducts($filter: ModelProductFilterInput, $limit: Int, $nextToken: String) {\n          listProducts(filter: $filter, limit: $limit, nextToken: $nextToken) {\n            items {\n              ...ProductFields\n              ...ProductFields2\n            }\n            nextToken\n          }\n        }\n\n        fragment ProductFields on Product {\n          id\n          title\n          content\n          price\n          rating\n        }\n\n        fragment ProductFields2 on Product {\n          title\n          content\n        }\n      `),\n      location: '',\n    };\n\n    const result = await plugin(schema, [ast], { package: 'app.test.generated.graphql', fileType: FileType.OPERATION });\n    const output = mergeOutputs([result]);\n    expect(output).toMatchSnapshot();\n    expect(output).toContain(\n      `final Fragments fragments = reader.readConditional($responseFields[1], new ResponseReader.ConditionalTypeReader<Fragments>() {`\n    );\n  });",
            "file": "operations.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/apollo-android/tests"
        },
        {
            "name": "Should produce valid Java code",
            "suites": [
                "Java"
            ],
            "updatePoint": {
                "line": 86,
                "column": 36
            },
            "line": 86,
            "code": "  it('Should produce valid Java code', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    validateJava(mergeOutputs([result]));\n  });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should use the correct package name by default",
            "suites": [
                "Java",
                "Config"
            ],
            "updatePoint": {
                "line": 93,
                "column": 54
            },
            "line": 93,
            "code": "    it('Should use the correct package name by default', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toContain(`package com.java.generated;`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should use the package name provided from the config",
            "suites": [
                "Java",
                "Config"
            ],
            "updatePoint": {
                "line": 99,
                "column": 60
            },
            "line": 99,
            "code": "    it('Should use the package name provided from the config', async () => {\n      const result = await plugin(schema, [], { package: 'com.my.package' }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toContain(`package com.my.package;`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should add imports that are relevant to enums",
            "suites": [
                "Java",
                "Enums"
            ],
            "updatePoint": {
                "line": 107,
                "column": 53
            },
            "line": 107,
            "code": "    it('Should add imports that are relevant to enums', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toContain(`import java.util.HashMap;`);\n      expect(result).toContain(`import java.util.Map;`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate basic enums correctly",
            "suites": [
                "Java",
                "Enums"
            ],
            "updatePoint": {
                "line": 114,
                "column": 45
            },
            "line": 114,
            "code": "    it('Should generate basic enums correctly', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`    public enum UserRole {\n        ADMIN,\n        USER,\n        EDITOR      \n                \n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should allow to override enum values with custom values",
            "suites": [
                "Java",
                "Enums"
            ],
            "updatePoint": {
                "line": 125,
                "column": 63
            },
            "line": 125,
            "code": "    it('Should allow to override enum values with custom values', async () => {\n      const result = await plugin(\n        schema,\n        [],\n        {\n          enumValues: {\n            UserRole: {\n              ADMIN: 'AdminRoleValue',\n            },\n          },\n        },\n        { outputFile: OUTPUT_FILE }\n      );\n\n      expect(result).toContain(`AdminRoleValue,`);\n      expect(result).toContain(`USER,`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate arguments correctly when using Array",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 145,
                "column": 60
            },
            "line": 145,
            "code": "    it('Should generate arguments correctly when using Array', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class InputWithArrayInput {\n        private Iterable<String> f;\n        private Iterable<SearchUserInput> g;\n      \n        public InputWithArrayInput(Map<String, Object> args) {\n          if (args != null) {\n            this.f = (Iterable<String>) args.get(\"f\");\n            if (args.get(\"g\") != null) {\n              this.g = (Iterable<SearchUserInput>) args.get(\"g\");\n            }\n          }\n        }\n      \n        public Iterable<String> getF() { return this.f; }\n        public Iterable<SearchUserInput> getG() { return this.g; }\n        public void setF(Iterable<String> f) { this.f = f; }\n        public void setG(Iterable<SearchUserInput> g) { this.g = g; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each type with field arguments",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 168,
                "column": 70
            },
            "line": 168,
            "code": "    it('Should generate input class per each type with field arguments', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class UserFriendsArgs {\n        private Integer skip;\n        private Integer limit;\n      \n        public UserFriendsArgs(Map<String, Object> args) {\n          if (args != null) {\n            this.skip = (Integer) args.get(\"skip\");\n            this.limit = (Integer) args.get(\"limit\");\n          }\n        }\n      \n        public Integer getSkip() { return this.skip; }\n        public Integer getLimit() { return this.limit; }\n        public void setSkip(Integer skip) { this.skip = skip; }\n        public void setLimit(Integer limit) { this.limit = limit; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should omit extra Input suffix from input class name if schema name already includes the \"Input\" suffix",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 189,
                "column": 111
            },
            "line": 189,
            "code": "    it('Should omit extra Input suffix from input class name if schema name already includes the \"Input\" suffix', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class CustomInput {\n        private Object id;\n      \n        public CustomInput(Map<String, Object> args) {\n          if (args != null) {\n            this.id = (Object) args.get(\"id\");\n          }\n        }\n      \n        public Object getId() { return this.id; }\n        public void setId(Object id) { this.id = id; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each query with arguments",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 206,
                "column": 65
            },
            "line": 206,
            "code": "    it('Should generate input class per each query with arguments', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class QueryUserArgs {\n        private Object id;\n      \n        public QueryUserArgs(Map<String, Object> args) {\n          if (args != null) {\n            this.id = (Object) args.get(\"id\");\n          }\n        }\n      \n        public Object getId() { return this.id; }\n        public void setId(Object id) { this.id = id; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class QuerySearchUserArgs {\n        private SearchUserInput searchFields;\n      \n        public QuerySearchUserArgs(Map<String, Object> args) {\n          if (args != null) {\n            this.searchFields = new SearchUserInput((Map<String, Object>) args.get(\"searchFields\"));\n          }\n        }\n      \n        public SearchUserInput getSearchFields() { return this.searchFields; }\n        public void setSearchFields(SearchUserInput searchFields) { this.searchFields = searchFields; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate check type for enum",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 236,
                "column": 43
            },
            "line": 236,
            "code": "    it('Should generate check type for enum', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n      expect(result).toBeSimilarStringTo(`if (args.get(\"sort\") instanceof ResultSort) {\n        this.sort = (ResultSort) args.get(\"sort\");\n      } else {\n        this.sort = ResultSort.valueOf((String) args.get(\"sort\"));\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate check type for enum when arg with enum list",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 245,
                "column": 67
            },
            "line": 245,
            "code": "    it('Should generate check type for enum when arg with enum list', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n      expect(result).toBeSimilarStringTo(`if (args.get(\"roles\") != null) {\n        this.roles = ((List<Object>) args.get(\"roles\")).stream()\n                .map(item -> item instanceof UserRole ? item : UserRole.valueOf((String) item))\n                .map(UserRole.class::cast)\n                .collect(Collectors.toList());\n       }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each input, also with nested input types",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 255,
                "column": 80
            },
            "line": 255,
            "code": "    it('Should generate input class per each input, also with nested input types', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class MetadataSearchInput {\n        private Integer something;\n      \n        public MetadataSearchInput(Map<String, Object> args) {\n          if (args != null) {\n            this.something = (Integer) args.get(\"something\");\n          }\n        }\n      \n        public Integer getSomething() { return this.something; }\n        public void setSomething(Integer something) { this.something = something; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class SearchUserInput {\n        private String username;\n        private String email;\n        private String name;\n        private Object dateOfBirth;\n        private ResultSort sort;\n        private MetadataSearchInput metadata;\n      \n        public SearchUserInput(Map<String, Object> args) {\n          if (args != null) {\n            this.username = (String) args.get(\"username\");\n            this.email = (String) args.get(\"email\");\n            this.name = (String) args.get(\"name\");\n            this.dateOfBirth = (Object) args.get(\"dateOfBirth\");\n            if (args.get(\"sort\") instanceof ResultSort) {\n              this.sort = (ResultSort) args.get(\"sort\");\n            } else {\n              this.sort = ResultSort.valueOf((String) args.get(\"sort\"));\n            }\n            this.metadata = new MetadataSearchInput((Map<String, Object>) args.get(\"metadata\"));\n          }\n        }\n      \n        public String getUsername() { return this.username; }\n        public String getEmail() { return this.email; }\n        public String getName() { return this.name; }\n        public Object getDateOfBirth() { return this.dateOfBirth; }\n        public ResultSort getSort() { return this.sort; }\n        public MetadataSearchInput getMetadata() { return this.metadata; }\n        public void setUsername(String username) { this.username = username; }\n        public void setEmail(String email) { this.email = email; }\n        public void setName(String name) { this.name = name; }\n        public void setDateOfBirth(Object dateOfBirth) { this.dateOfBirth = dateOfBirth; }\n        public void setSort(ResultSort sort) { this.sort = sort; }\n        public void setMetadata(MetadataSearchInput metadata) { this.metadata = metadata; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate nested inputs with out duplicated `Input` suffix",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor default false"
            ],
            "updatePoint": {
                "line": 309,
                "column": 72
            },
            "line": 309,
            "code": "    it('Should generate nested inputs with out duplicated `Input` suffix', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class UpdateUserMetadataInput {\n        private Integer something;\n      \n        public UpdateUserMetadataInput(Map<String, Object> args) {\n          if (args != null) {\n            this.something = (Integer) args.get(\"something\");\n          }\n        }\n      \n        public Integer getSomething() { return this.something; }\n        public void setSomething(Integer something) { this.something = something; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class UpdateUserInput {\n        private Object id;\n        private String username;\n        private UpdateUserMetadataInput metadata;\n      \n        public UpdateUserInput(Map<String, Object> args) {\n          if (args != null) {\n            this.id = (Object) args.get(\"id\");\n            this.username = (String) args.get(\"username\");\n            this.metadata = new UpdateUserMetadataInput((Map<String, Object>) args.get(\"metadata\"));\n          }\n        }\n      \n        public Object getId() { return this.id; }\n        public String getUsername() { return this.username; }\n        public UpdateUserMetadataInput getMetadata() { return this.metadata; }\n        public void setId(Object id) { this.id = id; }\n        public void setUsername(String username) { this.username = username; }\n        public void setMetadata(UpdateUserMetadataInput metadata) { this.metadata = metadata; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate arguments correctly when using Array",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 349,
                "column": 60
            },
            "line": 349,
            "code": "    it('Should generate arguments correctly when using Array', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class InputWithArrayInput {\n        private Iterable<String> f;\n        private Iterable<SearchUserInput> g;\n      \n        public InputWithArrayInput() {}          \n      \n        public Iterable<String> getF() { return this.f; }\n        public Iterable<SearchUserInput> getG() { return this.g; }\n        public void setF(Iterable<String> f) { this.f = f; }\n        public void setG(Iterable<SearchUserInput> g) { this.g = g; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each type with field arguments",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 365,
                "column": 70
            },
            "line": 365,
            "code": "    it('Should generate input class per each type with field arguments', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class UserFriendsArgs {\n        private Integer skip;\n        private Integer limit;\n      \n        public UserFriendsArgs() {}         \n      \n        public Integer getSkip() { return this.skip; }\n        public Integer getLimit() { return this.limit; }\n        public void setSkip(Integer skip) { this.skip = skip; }\n        public void setLimit(Integer limit) { this.limit = limit; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should omit extra Input suffix from input class name if schema name already includes the \"Input\" suffix",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 381,
                "column": 111
            },
            "line": 381,
            "code": "    it('Should omit extra Input suffix from input class name if schema name already includes the \"Input\" suffix', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class CustomInput {\n        private Object id;\n      \n        public CustomInput() {}          \n      \n        public Object getId() { return this.id; }\n        public void setId(Object id) { this.id = id; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each query with arguments",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 394,
                "column": 65
            },
            "line": 394,
            "code": "    it('Should generate input class per each query with arguments', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class QueryUserArgs {\n        private Object id;\n      \n        public QueryUserArgs() {}\n              \n        public Object getId() { return this.id; }\n        public void setId(Object id) { this.id = id; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class QuerySearchUserArgs {\n        private SearchUserInput searchFields;\n      \n        public QuerySearchUserArgs() {}\n      \n        public SearchUserInput getSearchFields() { return this.searchFields; }\n        public void setSearchFields(SearchUserInput searchFields) { this.searchFields = searchFields; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate input class per each input, also with nested input types",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 425,
                "column": 80
            },
            "line": 425,
            "code": "    it('Should generate input class per each input, also with nested input types', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class MetadataSearchInput {\n        private Integer something;\n      \n        public MetadataSearchInput() {}\n      \n        public Integer getSomething() { return this.something; }\n        public void setSomething(Integer something) { this.something = something; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class SearchUserInput {\n        private String username;\n        private String email;\n        private String name;\n        private Object dateOfBirth;\n        private ResultSort sort;\n        private MetadataSearchInput metadata;\n      \n        public SearchUserInput() {}\n      \n        public String getUsername() { return this.username; }\n        public String getEmail() { return this.email; }\n        public String getName() { return this.name; }\n        public Object getDateOfBirth() { return this.dateOfBirth; }\n        public ResultSort getSort() { return this.sort; }\n        public MetadataSearchInput getMetadata() { return this.metadata; }\n        public void setUsername(String username) { this.username = username; }\n        public void setEmail(String email) { this.email = email; }\n        public void setName(String name) { this.name = name; }\n        public void setDateOfBirth(Object dateOfBirth) { this.dateOfBirth = dateOfBirth; }\n        public void setSort(ResultSort sort) { this.sort = sort; }\n        public void setMetadata(MetadataSearchInput metadata) { this.metadata = metadata; }\n        \n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should generate nested inputs with out duplicated `Input` suffix",
            "suites": [
                "Java",
                "Input Types / Arguments useEmptyCtor true"
            ],
            "updatePoint": {
                "line": 463,
                "column": 72
            },
            "line": 463,
            "code": "    it('Should generate nested inputs with out duplicated `Input` suffix', async () => {\n      const result = await plugin(schema, [], { useEmptyCtor: true }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toBeSimilarStringTo(`public static class UpdateUserMetadataInput {\n        private Integer something;\n      \n        public UpdateUserMetadataInput() {}\n      \n        public Integer getSomething() { return this.something; }\n        public void setSomething(Integer something) { this.something = something; }\n      }`);\n\n      expect(result).toBeSimilarStringTo(`public static class UpdateUserInput {\n        private Object id;\n        private String username;\n        private UpdateUserMetadataInput metadata;\n      \n        public UpdateUserInput() {}\n          \n        public Object getId() { return this.id; }\n        public String getUsername() { return this.username; }\n        public UpdateUserMetadataInput getMetadata() { return this.metadata; }\n        public void setId(Object id) { this.id = id; }\n        public void setUsername(String username) { this.username = username; }\n        public void setMetadata(UpdateUserMetadataInput metadata) { this.metadata = metadata; }\n      }`);\n    });",
            "file": "java.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/java/tests"
        },
        {
            "name": "Should use the correct package name by default",
            "suites": [
                "Kotlin",
                "Config"
            ],
            "updatePoint": {
                "line": 85,
                "column": 54
            },
            "line": 85,
            "code": "    it('Should use the correct package name by default', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      expect(result).toContain(`package com.kotlin.generated\\n`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should use the package name provided from the config",
            "suites": [
                "Kotlin",
                "Config"
            ],
            "updatePoint": {
                "line": 91,
                "column": 60
            },
            "line": 91,
            "code": "    it('Should use the package name provided from the config', async () => {\n      const result = await plugin(schema, [], { package: 'com.my.package' }, { outputFile: OUTPUT_FILE });\n\n      expect(result).toContain(`package com.my.package\\n`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate basic enums correctly",
            "suites": [
                "Kotlin",
                "Enums"
            ],
            "updatePoint": {
                "line": 99,
                "column": 45
            },
            "line": 99,
            "code": "    it('Should generate basic enums correctly', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`    enum class UserRole(val label: String) {\n        Admin(\"ADMIN\"),\n        User(\"USER\"),\n        Editor(\"EDITOR\");\n        \n        companion object {\n          @JvmStatic\n          fun valueOfLabel(label: String): UserRole? {\n            return values().find { it.label == label }\n          }\n        }\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should allow to override enum values with custom values",
            "suites": [
                "Kotlin",
                "Enums"
            ],
            "updatePoint": {
                "line": 117,
                "column": 63
            },
            "line": 117,
            "code": "    it('Should allow to override enum values with custom values', async () => {\n      const result = await plugin(\n        schema,\n        [],\n        {\n          enumValues: {\n            UserRole: {\n              ADMIN: 'AdminRoleValue',\n            },\n          },\n        },\n        { outputFile: OUTPUT_FILE }\n      );\n\n      expect(result).toContain(`Admin(\"AdminRoleValue\"),`);\n      expect(result).toContain(`User(\"USER\"),`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should omit JvmStatic annotation if the option is set",
            "suites": [
                "Kotlin",
                "Enums"
            ],
            "updatePoint": {
                "line": 135,
                "column": 61
            },
            "line": 135,
            "code": "    it('Should omit JvmStatic annotation if the option is set', async () => {\n      const result = await plugin(schema, [], { omitJvmStatic: true }, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`    enum class UserRole(val label: String) {\n        Admin(\"ADMIN\"),\n        User(\"USER\"),\n        Editor(\"EDITOR\");\n        \n        companion object {\n          \n          fun valueOfLabel(label: String): UserRole? {\n            return values().find { it.label == label }\n          }\n        }\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate arguments correctly when using Array",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 155,
                "column": 60
            },
            "line": 155,
            "code": "    it('Should generate arguments correctly when using Array', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class InputWithArrayInput(\n        val f: Iterable<String>? = null,\n        val g: Iterable<SearchUserInput>? = null\n      ) {\n        @Suppress(\"UNCHECKED_CAST\")\n        constructor(args: Map<String, Any>) : this(\n          args[\"f\"] as Iterable<String>?,\n          args[\"g\"]?.let { g -> (g as List<Map<String, Any>>).map { SearchUserInput(it) } }\n        )\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate input class per each type with field arguments",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 171,
                "column": 70
            },
            "line": 171,
            "code": "    it('Should generate input class per each type with field arguments', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class UserFriendsArgs(\n        val skip: Int? = null,\n        val limit: Int? = null\n      ) {\n        constructor(args: Map<String, Any>) : this(\n          args[\"skip\"] as Int?,\n          args[\"limit\"] as Int?\n        )\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate argument defaults",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 186,
                "column": 41
            },
            "line": 186,
            "code": "    it('Should generate argument defaults', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class UserHobbiesArgs(\n        val skip: Int? = 0,\n        val limit: Int = 10\n      ) {\n        constructor(args: Map<String, Any>) : this(\n          args[\"skip\"] as Int? ?: 0,\n          args[\"limit\"] as Int? ?: 10\n        )\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate input class per each query with arguments",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 201,
                "column": 65
            },
            "line": 201,
            "code": "    it('Should generate input class per each query with arguments', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class QueryUserArgs(\n        val id: Any\n      ) {\n        constructor(args: Map<String, Any>) : this(\n          args[\"id\"] as Any\n        )\n      }`);\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class QuerySearchUserArgs(\n        val searchFields: SearchUserInput\n      ) {\n        @Suppress(\"UNCHECKED_CAST\")\n        constructor(args: Map<String, Any>) : this(\n            SearchUserInput(args[\"searchFields\"] as Map<String, Any>)\n        )\n      }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate input class per each input, also with nested input types",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 224,
                "column": 80
            },
            "line": 224,
            "code": "    it('Should generate input class per each input, also with nested input types', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class MetadataSearchInput(\n          val something: Int? = null\n        ) {\n          constructor(args: Map<String, Any>) : this(\n              args[\"something\"] as Int?\n          )\n        }`);\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class SearchUserInput(\n          val username: String? = null,\n          val email: String? = null,\n          val name: String? = null,\n          val sort: ResultSort? = null,\n          val metadata: MetadataSearchInput? = null\n        ) {\n          @Suppress(\"UNCHECKED_CAST\")\n          constructor(args: Map<String, Any>) : this(\n              args[\"username\"] as String?,\n              args[\"email\"] as String?,\n              args[\"name\"] as String?,\n              args[\"sort\"] as ResultSort?,\n              args[\"metadata\"]?.let { MetadataSearchInput(it as Map<String, Any>) }\n          )\n        }`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate nested inputs with out duplicated `Input` suffix",
            "suites": [
                "Kotlin",
                "Input Types / Arguments"
            ],
            "updatePoint": {
                "line": 255,
                "column": 72
            },
            "line": 255,
            "code": "    it('Should generate nested inputs with out duplicated `Input` suffix', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class UpdateUserMetadataInput(\n          val something: Int? = null\n        )`);\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class UpdateUserInput(\n          val id: Any,\n          val username: String? = null,\n          val metadata: UpdateUserMetadataInput? = null\n        )`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should NOT generate type class per each type if withTypes is not specified",
            "suites": [
                "Kotlin",
                "Types"
            ],
            "updatePoint": {
                "line": 273,
                "column": 82
            },
            "line": 273,
            "code": "    it('Should NOT generate type class per each type if withTypes is not specified', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).not.toBeSimilarStringTo(`data class User(\n        val skip: Int? = null,\n        val limit: Int? = null\n      )`);\n\n      // language=kotlin\n      expect(result).not.toBeSimilarStringTo(`data class Chat(\n        val skip: Int? = null,\n        val limit: Int? = null\n      )`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate type class per each type if withTypes is true",
            "suites": [
                "Kotlin",
                "Types"
            ],
            "updatePoint": {
                "line": 289,
                "column": 69
            },
            "line": 289,
            "code": "    it('Should generate type class per each type if withTypes is true', async () => {\n      const result = await plugin(schema, [], { withTypes: true }, { outputFile: OUTPUT_FILE });\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class User(\n        val id: Any,\n        val username: String,\n        val email: String,\n        val name: String?,\n        val friends: Iterable<User>,\n        val hobbies: Iterable<String>\n      )`);\n\n      // language=kotlin\n      expect(result).toBeSimilarStringTo(`data class Chat(\n        val id: Any,\n        val users: Iterable<User>,\n        val title: String?\n      )`);\n    });",
            "file": "kotlin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/kotlin/tests"
        },
        {
            "name": "Should generate interfaces correctly",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 37,
                "column": 42
            },
            "line": 37,
            "code": "  it('Should generate interfaces correctly', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toBeSimilarStringTo(`\n    public interface Query {\n      public DataFetcher<Object> me();\n    }`);\n    expect(result).toBeSimilarStringTo(`\n    public interface User {\n      public DataFetcher<Object> id();\n      public DataFetcher<String> username();\n      public DataFetcher<String> email();\n      public DataFetcher<String> name();\n      public DataFetcher<Object> dateOfBirth();\n    }`);\n\n    validateJava(result as any);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should generate list types correctly",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 56,
                "column": 42
            },
            "line": 56,
            "code": "  it('Should generate list types correctly', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toBeSimilarStringTo(`public interface Chat {\n      public DataFetcher<Object> id();\n      public DataFetcher<Iterable<Object>> users();\n      public DataFetcher<String> title();\n    }`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should generate neseted list types correctly",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 66,
                "column": 50
            },
            "line": 66,
            "code": "  it('Should generate neseted list types correctly', async () => {\n    const result = await plugin(buildSchema(`type Query { data: [[[[String]]]]}`), [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toBeSimilarStringTo(`public DataFetcher<Iterable<Iterable<Iterable<Iterable<String>>>>> data();`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should generate union correctly",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 72,
                "column": 37
            },
            "line": 72,
            "code": "  it('Should generate union correctly', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toBeSimilarStringTo(`public interface SearchResult extends TypeResolver {\n\n    }`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should generate interfaces correctly and add the correct imports",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 80,
                "column": 70
            },
            "line": 80,
            "code": "  it('Should generate interfaces correctly and add the correct imports', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toContain(`import graphql.schema.TypeResolver;`);\n    expect(result).toBeSimilarStringTo(`\n    public interface Node extends TypeResolver {\n      default public DataFetcher<Object> id() { return null; }\n    }`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should use the correct package name by default",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 90,
                "column": 52
            },
            "line": 90,
            "code": "  it('Should use the correct package name by default', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toContain(`package com.java.generated;`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should use the package name provided from the config",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 96,
                "column": 58
            },
            "line": 96,
            "code": "  it('Should use the package name provided from the config', async () => {\n    const result = await plugin(schema, [], { package: 'com.my.package' }, { outputFile: OUTPUT_FILE });\n\n    expect(result).toContain(`package com.my.package;`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "Should add the correct package value according to the filename",
            "suites": [
                "Java Resolvers"
            ],
            "updatePoint": {
                "line": 102,
                "column": 68
            },
            "line": 102,
            "code": "  it('Should add the correct package value according to the filename', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: OUTPUT_FILE });\n\n    expect(result).toBeSimilarStringTo(`\n    public interface Query {\n      public DataFetcher<Object> me();\n    }`);\n\n    expect(result).toBeSimilarStringTo(`\n    public interface User {\n      public DataFetcher<Object> id();\n      public DataFetcher<String> username();\n      public DataFetcher<String> email();\n      public DataFetcher<String> name();\n      public DataFetcher<Object> dateOfBirth();\n    }`);\n  });",
            "file": "java-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/java/resolvers/tests"
        },
        {
            "name": "should not throw on tsx?, jsx?, json files, both in lower and upper case",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 68,
                "column": 80
            },
            "line": 68,
            "code": "    it('should not throw on tsx?, jsx?, json files, both in lower and upper case', async () => {\n      const extensions = ['.json', '.js', '.jsx', '.ts', '.tsx'];\n      const allCases = extensions.concat(extensions.map(val => val.toUpperCase()));\n\n      try {\n        await Promise.all(allCases.map(ext => validate(schema, [], {}, `foo${ext}`, [])));\n\n        throw new Error('DONE');\n      } catch (e) {\n        expect(e.message).toEqual('DONE');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should throw on commonjs + ts",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 81,
                "column": 37
            },
            "line": 81,
            "code": "    it('should throw on commonjs + ts', async () => {\n      try {\n        await validate(schema, [], { module: 'commonjs' }, 'foo.ts', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('commonjs');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should throw on unsupported extension",
            "suites": [
                "Fragment Matcher Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 91,
                "column": 45
            },
            "line": 91,
            "code": "    it('should throw on unsupported extension', async () => {\n      try {\n        await validate(schema, [], {}, 'foo.yml', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('extension');\n      }\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should stringify the result",
            "suites": [
                "Fragment Matcher Plugin",
                "JSON"
            ],
            "updatePoint": {
                "line": 102,
                "column": 35
            },
            "line": 102,
            "code": "    it('should stringify the result', async () => {\n      const content = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.json',\n        }\n      );\n\n      expect(content).toEqual(introspection);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Fragment Matcher Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 119,
                "column": 43
            },
            "line": 119,
            "code": "    it('should use es2015 module by default', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `\n        export default ${introspection}\n      `;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should be able to use commonjs",
            "suites": [
                "Fragment Matcher Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 148,
                "column": 38
            },
            "line": 148,
            "code": "    it('should be able to use commonjs', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `\n        module.exports = ${introspection}\n      `;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 181,
                "column": 43
            },
            "line": 181,
            "code": "    it('should use es2015 module by default', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export interface IntrospectionResultData {\n          __schema: {\n            types: {\n              kind: string;\n              name: string;\n              possibleTypes: {\n                name: string;\n              }[];\n            }[];\n          };\n        }\n        const result: IntrospectionResultData = ${introspection};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 module by default - apollo client 3",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 222,
                "column": 61
            },
            "line": 222,
            "code": "    it('should use es2015 module by default - apollo client 3', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n      export interface PossibleTypesResultData {\n        possibleTypes: {\n          [key: string]: string[]\n        }\n      }\n\n        const result: PossibleTypesResultData = ${apolloClient3Result};\n\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should use es2015 even though commonjs is requested",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 259,
                "column": 59
            },
            "line": 259,
            "code": "    it('should use es2015 even though commonjs is requested', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support exportAsConst for apolloClientVersion 2",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 288,
                "column": 62
            },
            "line": 288,
            "code": "    it('should support exportAsConst for apolloClientVersion 2', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 2,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export type IntrospectionResultData = ${introspection};\n        const result: IntrospectionResultData = ${introspection};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support useExplicitTyping for apolloClientVersion 3",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 321,
                "column": 66
            },
            "line": 321,
            "code": "    it('should support useExplicitTyping for apolloClientVersion 3', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          apolloClientVersion: 3,\n          useExplicitTyping: true,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `\n        export type PossibleTypesResultData = ${apolloClient3Result};\n        const result: PossibleTypesResultData = ${apolloClient3Result};\n        export default result;\n      `;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 355,
                "column": 38
            },
            "line": 355,
            "code": "  it('should support Apollo Federation', async () => {\n    const federatedSchema = parse(/* GraphQL */ `\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n    const content = await codegen({\n      filename: 'foo.json',\n      schema: federatedSchema,\n      documents: [],\n      plugins: [\n        {\n          'fragment-matcher': {},\n        },\n      ],\n      config: {\n        federation: true,\n        apolloClientVersion: 2,\n      },\n      pluginMap: {\n        'fragment-matcher': {\n          plugin,\n          validate,\n        },\n      },\n    });\n\n    expect(content).toEqual(introspection);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should support Apollo Federation with predefined directive definitions",
            "suites": [
                "Fragment Matcher Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 401,
                "column": 76
            },
            "line": 401,
            "code": "  it('should support Apollo Federation with predefined directive definitions', async () => {\n    const federatedSchema = parse(/* GraphQL */ `\n      directive @key(fields: String!) on FIELD_DEFINITION\n\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n    const content = await codegen({\n      filename: 'foo.json',\n      schema: federatedSchema,\n      documents: [],\n      plugins: [\n        {\n          'fragment-matcher': {},\n        },\n      ],\n      config: {\n        apolloClientVersion: 2,\n        federation: true,\n      },\n      pluginMap: {\n        'fragment-matcher': {\n          plugin,\n          validate,\n        },\n      },\n    });\n\n    expect(content).toEqual(introspection);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/fragment-matcher/tests"
        },
        {
            "name": "should output a JSON file",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 6,
                "column": 31
            },
            "line": 6,
            "code": "  it('should output a JSON file', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        fieldTest: String\n      }\n\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = await plugin(schema, [], {}, { outputFile: '' });\n    const introspection = JSON.stringify(\n      introspectionFromSchema(schema, { descriptions: true, schemaDescription: false, specifiedByUrl: false }),\n      null,\n      2\n    );\n    expect(introspection).toEqual(content);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "should output a JSON file minified",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 26,
                "column": 40
            },
            "line": 26,
            "code": "  it('should output a JSON file minified', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        fieldTest: String\n      }\n\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = await plugin(schema, [], { minify: true }, { outputFile: '' });\n    const introspection = JSON.stringify(\n      introspectionFromSchema(schema, { descriptions: true, schemaDescription: false, specifiedByUrl: false })\n    );\n    expect(introspection).toEqual(content);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Introspection template"
            ],
            "updatePoint": {
                "line": 44,
                "column": 38
            },
            "line": 44,
            "code": "  it('should support Apollo Federation', async () => {\n    const schema = parse(/* GraphQL */ `\n      type Character @key(fields: \"id\") {\n        id: ID\n        name: String\n      }\n\n      type Jedi @key(fields: \"id\") {\n        id: ID\n        side: String\n      }\n\n      type Droid @key(fields: \"id\") {\n        id: ID\n        model: String\n      }\n\n      union People = Character | Jedi | Droid\n\n      type Query {\n        allPeople: [People]\n      }\n    `);\n\n    const content = await codegen({\n      filename: 'foo.json',\n      schema,\n      documents: [],\n      plugins: [\n        {\n          introspection: {},\n        },\n      ],\n      config: {\n        federation: true,\n      },\n      pluginMap: {\n        introspection: {\n          plugin,\n        },\n      },\n    });\n\n    const introspection: IntrospectionQuery = JSON.parse(content);\n    const { types } = introspection.__schema;\n    const queryType = types.find(\n      type => type.name === introspection.__schema.queryType.name\n    ) as IntrospectionObjectType;\n\n    // scalar _Any\n    expect(types.some(type => type.name === '_Any')).toBe(false);\n    // union _Entity\n    expect(types.some(type => type.name === '_Entity')).toBe(false);\n    // type _Service\n    expect(types.some(type => type.name === '_Service')).toBe(false);\n    // type Query { _entities, _service }\n    expect(queryType.fields.some(f => f.name === '_entities')).toBe(false);\n    expect(queryType.fields.some(f => f.name === '_service')).toBe(false);\n  });",
            "file": "introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/introspection/tests"
        },
        {
            "name": "should not contain an [object Object] when passing in a document",
            "suites": [
                "JSDoc Plugin",
                "Document types"
            ],
            "updatePoint": {
                "line": 7,
                "column": 72
            },
            "line": 7,
            "code": "    it('should not contain an [object Object] when passing in a document', async () => {\n      const document = parse(/* GraphQL */ `\n        query getUser {\n          users {\n            id\n          }\n        }\n\n        mutation updateUser($user: UserInput!) {\n          id\n        }\n      `);\n\n      const schema = buildSchema(/* Graphql */ `\n                type Query {\n                  users: [User!]!\n                  user(id: ID!): User\n                }\n\n                # Describes the level of access a user has\n                enum Role {\n                  ADMIN\n                  USER\n                }\n\n                # Represents a registered user\n                type User {\n                  # UUID of the user\n                  id: ID!\n                  # The user's name\n                  name: String\n                  # The user's level of access\n                  role: Role!\n                }\n\n                input UserInput {\n                    id: ID!\n                    name: String\n                    role: Role\n                }\n\n                fragment UserFields on User {\n                    name\n                    role\n                }\n            `);\n\n      const config = {};\n      const result = await plugin(schema, [{ location: '', document }], config, { outputFile: '' });\n\n      expect(result).not.toEqual(expect.stringContaining('[object Object]'));\n    });",
            "file": "jsdoc-document-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "Should work with described schemas",
            "suites": [
                "JSDoc Plugin",
                "description"
            ],
            "updatePoint": {
                "line": 7,
                "column": 42
            },
            "line": 7,
            "code": "    it('Should work with described schemas', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        \"\"\"type desc\"\"\"\n        type Foo {\n          \"\"\"type field desc\"\"\"\n            foo: Int!\n        }\n\n        \"\"\"input desc\"\"\"\n        input FooInput {\n            \"\"\"input field desc\"\"\"\n            foo: Int!\n        }\n\n        \"\"\"enum desc\"\"\"\n        enum Test {\n            A\n            B\n            \"\"\"enum value desc\"\"\"\n            C\n        }\n\n        \"\"\"scalar desc\"\"\"\n        scalar Date\n\n        \"\"\"interface desc\"\"\"\n        interface Node {\n          \"\"\" interface field desc \"\"\"\n          id: ID!\n        }\n\n        \"\"\"\n        union desc\n        multiline test\n        \"\"\"\n        union TestU = Foo\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`/**\n      * enum desc\n      * @typedef {(\"A\"|\"B\"|\"C\")} Test\n      */`);\n      expect(result).toBeSimilarStringTo(`/**\n      * union desc\n      * multiline test\n      * @typedef {(Foo)} TestU\n      */`);\n      expect(result).toBeSimilarStringTo(`/**\n      * scalar desc \n      * @typedef {*} Date\n      */`);\n      expect(result).toBeSimilarStringTo(`/**\n      * input desc \n      * @typedef {Object} FooInput\n      * @property {number} foo -  input field desc \n      */`);\n      expect(result).toBeSimilarStringTo(`/**\n      * type desc \n      * @typedef {Object} Foo\n      * @property {number} foo -  type field desc \n      */`);\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef with a property",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 75,
                "column": 49
            },
            "line": 75,
            "code": "    it('should generate a typedef with a property', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        type Foo {\n            foo: Int!\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(\n        expect.stringContaining(`/**\n * @typedef {Object} Foo\n * @property {number} foo\n */`)\n      );\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef with a nullable property",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 93,
                "column": 58
            },
            "line": 93,
            "code": "    it('should generate a typedef with a nullable property', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        type Foo {\n            foo: Int\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining('@property {number} [foo]'));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef for an input type",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 106,
                "column": 51
            },
            "line": 106,
            "code": "    it('should generate a typedef for an input type', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        input FooInput {\n            foo: Int!\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(\n        expect.stringContaining(`/**\n * @typedef {Object} FooInput\n * @property {number} foo\n */`)\n      );\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef with a nullable property (input type)",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 124,
                "column": 71
            },
            "line": 124,
            "code": "    it('should generate a typedef with a nullable property (input type)', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        input FooInput {\n            foo: Int\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining('@property {number} [foo]'));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef for a union",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 137,
                "column": 45
            },
            "line": 137,
            "code": "    it('should generate a typedef for a union', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        union FooBar = Int | Boolean\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(`/**\n * @typedef {(number|boolean)} FooBar\n */`);\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef with a list property",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 150,
                "column": 54
            },
            "line": 150,
            "code": "    it('should generate a typedef with a list property', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        type Foo {\n            foo: [Int!]!\n            nullableFoo: [Int!]\n            nullableItemsFoo: [Int]!\n            nullableItemsNullableFoo: [Int]\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining('@property {Array<number>} foo'));\n      expect(result).toEqual(expect.stringContaining('@property {Array<number>} [nullableFoo]'));\n      expect(result).toEqual(expect.stringContaining('@property {Array<(number|null|undefined)>} nullableItemsFoo'));\n      expect(result).toEqual(\n        expect.stringContaining('@property {Array<(number|null|undefined)>} [nullableItemsNullableFoo]')\n      );\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef with a custom scalar",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 171,
                "column": 54
            },
            "line": 171,
            "code": "    it('should generate a typedef with a custom scalar', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        scalar Bar\n\n        type Foo {\n            foo: Bar\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining('@typedef {*} Bar'));\n      expect(result).toEqual(expect.stringContaining('@property {Bar} [foo]'));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate a typedef for enums",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 187,
                "column": 43
            },
            "line": 187,
            "code": "    it('should generate a typedef for enums', async () => {\n      const schema = buildSchema(/* Graphql */ `\n        enum FooOrBar {\n            FOO\n            BAR\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining('* @typedef {(\"FOO\"|\"BAR\")} FooOrBar'));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should generate an annotation for deprecated fields",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 201,
                "column": 59
            },
            "line": 201,
            "code": "    it('should generate an annotation for deprecated fields', async () => {\n      const warning = 'the field foo is no longer supported, prefer bar';\n      const schema = buildSchema(/* Graphql */ `\n        type Query {\n            foo: String! @deprecated(reason: \"${warning}\")\n            bar: String!\n        }\n    `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).toEqual(expect.stringContaining(`* @property {string} foo - DEPRECATED: ${warning}`));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should not generate [object Object] for directives",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 216,
                "column": 58
            },
            "line": 216,
            "code": "    it('should not generate [object Object] for directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @client(always: Boolean) on FIELD | FRAGMENT_DEFINITION | INLINE_FRAGMENT\n      `);\n\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).not.toEqual(expect.stringContaining('[object Object]'));\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "should not generate [object Object] or extra lines for Schema",
            "suites": [
                "JSDoc Plugin",
                "schema types"
            ],
            "updatePoint": {
                "line": 227,
                "column": 69
            },
            "line": 227,
            "code": "    it('should not generate [object Object] or extra lines for Schema', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          query: RootQueryType\n          mutation: RootMutationType\n        }\n\n        type RootMutationType {\n          addItem(name: String!): String\n        }\n\n        type RootQueryType {\n          items: [String!]!\n        }\n      `);\n      const config = {};\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      expect(result).not.toEqual(expect.stringContaining('[object Object]'));\n      expect(result).toEqual(`/**\n * @typedef {Object} RootMutationType\n * @property {string} [addItem]\n */\n\n/**\n * @typedef {Object} RootQueryType\n * @property {Array<string>} items\n */`);\n    });",
            "file": "jsdoc-schema-types.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/jsdoc/tests"
        },
        {
            "name": "Should enforce graphql extension when its the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 12,
                "column": 65
            },
            "line": 12,
            "code": "    it('Should enforce graphql extension when its the only plugin', async () => {\n      const fileName = 'output.ts';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n\n        throw new Error(SHOULD_THROW_ERROR);\n      } catch (e) {\n        expect(e.message).not.toBe(SHOULD_THROW_ERROR);\n        expect(e.message).toBe('Plugin \"schema-ast\" requires extension to be \".graphql\"!');\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should not enforce graphql extension when its not the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 30,
                "column": 73
            },
            "line": 30,
            "code": "    it('Should not enforce graphql extension when its not the only plugin', async () => {\n      const fileName = 'output.ts';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          add: {},\n        },\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n      } catch (e) {\n        expect(true).toBeFalsy();\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should allow graphql extension when its the only plugin",
            "suites": [
                "Schema AST",
                "Validation"
            ],
            "updatePoint": {
                "line": 48,
                "column": 63
            },
            "line": 48,
            "code": "    it('Should allow graphql extension when its the only plugin', async () => {\n      const fileName = 'output.graphql';\n      const plugins: Types.ConfiguredPlugin[] = [\n        {\n          'schema-ast': {},\n        },\n      ];\n\n      try {\n        await validate(null, null, null, fileName, plugins);\n      } catch (e) {\n        expect(true).toBeFalsy();\n      }\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema without directives when \"includeDirectives\" is unset",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 77,
                "column": 80
            },
            "line": 77,
            "code": "    it('Should print schema without directives when \"includeDirectives\" is unset', async () => {\n      const content = await plugin(schema, [], { includeDirectives: false });\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with as \"\"\" comment as default",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 87,
                "column": 58
            },
            "line": 87,
            "code": "    it('Should print schema with as \"\"\" comment as default', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          \"\"\"\n          test\n          \"\"\"\n          fieldTest: String\n        }\n      `);\n      const content = await plugin(testSchema, [], { includeDirectives: false });\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          \"\"\"test\"\"\"\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with as # when commentDescriptions=true",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 107,
                "column": 69
            },
            "line": 107,
            "code": "      it('Should print schema with as # when commentDescriptions=true', async () => {\n        const testSchema = buildSchema(/* GraphQL */ `\n          type Query {\n            \"\"\"\n            test\n            \"\"\"\n            fieldTest: String\n          }\n        `);\n        const content = await plugin(testSchema, [], { commentDescriptions: true, includeDirectives: false });\n\n        expect(content).toBeSimilarStringTo(`\n        type Query {\n          #  test\n          fieldTest: String\n        }\n      `);\n      });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with directives when \"includeDirectives\" is set",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 127,
                "column": 75
            },
            "line": 127,
            "code": "    it('Should print schema with directives when \"includeDirectives\" is set', async () => {\n      const content = await plugin(schema, [], { includeDirectives: true });\n\n      expect(content).toBeSimilarStringTo(`\n        directive @modify(limit: Int) on FIELD_DEFINITION\n      `);\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String @modify(limit: 1)\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema with introspection when \"includeIntrospectionTypes\" is set",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 140,
                "column": 86
            },
            "line": 140,
            "code": "    it('Should print schema with introspection when \"includeIntrospectionTypes\" is set', async () => {\n      const content = await plugin(schema, [], { includeIntrospectionTypes: true });\n\n      expect(content).toBeSimilarStringTo(`\n        type __Schema\n      `);\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n          __schema: __Schema!\n          __type(name: String!): __Type\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should print schema without introspection when \"includeIntrospectionTypes\" is unset",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 156,
                "column": 91
            },
            "line": 156,
            "code": "    it('Should print schema without introspection when \"includeIntrospectionTypes\" is unset', async () => {\n      const content = await plugin(schema, [], { includeIntrospectionTypes: false });\n\n      expect(content).not.toBeSimilarStringTo(`\n        type __Schema\n      `);\n\n      expect(content).toBeSimilarStringTo(`\n        type Query {\n          fieldTest: String\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "should support Apollo Federation",
            "suites": [
                "Schema AST",
                "Output"
            ],
            "updatePoint": {
                "line": 170,
                "column": 40
            },
            "line": 170,
            "code": "    it('should support Apollo Federation', async () => {\n      const federatedSchema = parse(/* GraphQL */ `\n        type Character @key(fields: \"id\") {\n          id: ID\n          name: String\n        }\n\n        type Jedi @key(fields: \"id\") {\n          id: ID\n          side: String\n        }\n\n        type Droid @key(fields: \"id\") {\n          id: ID\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          allPeople: [People]\n        }\n      `);\n\n      const content = await codegen({\n        filename: 'foo.graphql',\n        schema: federatedSchema,\n        documents: [],\n        plugins: [\n          {\n            'schema-ast': {},\n          },\n        ],\n        config: {\n          federation: true,\n        },\n        pluginMap: {\n          'schema-ast': {\n            plugin,\n            validate,\n          },\n        },\n      });\n\n      expect(content).not.toContain(`scalar _Any`);\n      expect(content).not.toContain(`union _Entity`);\n      expect(content).not.toContain(`type _Service`);\n\n      expect(content).toBeSimilarStringTo(`\n        type Character {\n          id: ID\n          name: String\n        }\n\n        type Jedi {\n          id: ID\n          side: String\n        }\n\n        type Droid {\n          id: ID\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          allPeople: [People]\n        }\n      `);\n    });",
            "file": "schema-ast.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/schema-ast/tests"
        },
        {
            "name": "Should use default comment when extenion is unknown",
            "suites": [
                "Time"
            ],
            "updatePoint": {
                "line": 4,
                "column": 57
            },
            "line": 4,
            "code": "  it('Should use default comment when extenion is unknown', async () => {\n    const result = await plugin(null as any, [], null, { outputFile: null });\n    expect(result).toContain('// Generated on');\n  });",
            "file": "time.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/time/tests"
        },
        {
            "name": "Should use # prefix for comment when extenion is graphql",
            "suites": [
                "Time"
            ],
            "updatePoint": {
                "line": 9,
                "column": 62
            },
            "line": 9,
            "code": "  it('Should use # prefix for comment when extenion is graphql', async () => {\n    const result = await plugin(null as any, [], null, { outputFile: 'schema.graphql' });\n    expect(result).toContain('# Generated on');\n  });",
            "file": "time.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/time/tests"
        },
        {
            "name": "should not throw on tsx?, jsx?, json files, both in lower and upper case",
            "suites": [
                "Urql Introspection Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 33,
                "column": 80
            },
            "line": 33,
            "code": "    it('should not throw on tsx?, jsx?, json files, both in lower and upper case', async () => {\n      const extensions = ['.json', '.js', '.jsx', '.ts', '.tsx'];\n      const allCases = extensions.concat(extensions.map(val => val.toUpperCase()));\n\n      try {\n        await Promise.all(allCases.map(ext => validate(schema, [], {}, `foo${ext}`, [])));\n\n        throw new Error('DONE');\n      } catch (e) {\n        expect(e.message).toEqual('DONE');\n      }\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should throw on commonjs + ts",
            "suites": [
                "Urql Introspection Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 46,
                "column": 37
            },
            "line": 46,
            "code": "    it('should throw on commonjs + ts', async () => {\n      try {\n        await validate(schema, [], { module: 'commonjs' }, 'foo.ts', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('commonjs');\n      }\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should throw on useTypeImports + not ts env",
            "suites": [
                "Urql Introspection Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 56,
                "column": 51
            },
            "line": 56,
            "code": "    it('should throw on useTypeImports + not ts env', async () => {\n      const extensions = ['.json', '.js', '.jsx'];\n      const allCases = extensions.concat(extensions.map(val => val.toUpperCase()));\n\n      try {\n        await Promise.all(allCases.map(ext => validate(schema, [], { useTypeImports: true }, `foo${ext}`, [])));\n\n        throw new Error('DONE');\n      } catch (e) {\n        expect(e.message).not.toEqual('DONE');\n      }\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should throw on unsupported extension",
            "suites": [
                "Urql Introspection Plugin",
                "validate"
            ],
            "updatePoint": {
                "line": 69,
                "column": 45
            },
            "line": 69,
            "code": "    it('should throw on unsupported extension', async () => {\n      try {\n        await validate(schema, [], {}, 'foo.yml', []);\n\n        throw new Error('SHOULD_NOT_BE_HERE');\n      } catch (e) {\n        expect(e.message).toContain('extension');\n      }\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should stringify the result",
            "suites": [
                "Urql Introspection Plugin",
                "JSON"
            ],
            "updatePoint": {
                "line": 80,
                "column": 35
            },
            "line": 80,
            "code": "    it('should stringify the result', async () => {\n      const content = await plugin(\n        schema,\n        [],\n        {},\n        {\n          outputFile: 'foo.json',\n        }\n      );\n\n      expect(content).toEqual(introspection);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Urql Introspection Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 95,
                "column": 43
            },
            "line": 95,
            "code": "    it('should use es2015 module by default', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {},\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {},\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `export default ${introspection}`;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should be able to use commonjs",
            "suites": [
                "Urql Introspection Plugin",
                "JavaScript"
            ],
            "updatePoint": {
                "line": 118,
                "column": 38
            },
            "line": 118,
            "code": "    it('should be able to use commonjs', async () => {\n      const jsContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.js',\n        }\n      );\n      const jsxContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.jsx',\n        }\n      );\n      const output = `\n        module.exports = ${introspection}\n      `;\n\n      expect(jsContent).toBeSimilarStringTo(output);\n      expect(jsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should use es2015 module by default",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 149,
                "column": 43
            },
            "line": 149,
            "code": "    it('should use es2015 module by default', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {},\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {},\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `import { IntrospectionQuery } from 'graphql';\nexport default ${introspection} as unknown as IntrospectionQuery;`;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should use es2015 even though commonjs is requested",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 173,
                "column": 59
            },
            "line": 173,
            "code": "    it('should use es2015 even though commonjs is requested', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          module: 'commonjs',\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `import { IntrospectionQuery } from 'graphql';\nexport default ${introspection} as unknown as IntrospectionQuery;`;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "should emit type imports if useTypeImports config value is used",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 201,
                "column": 71
            },
            "line": 201,
            "code": "    it('should emit type imports if useTypeImports config value is used', async () => {\n      const tsContent = await plugin(\n        schema,\n        [],\n        {\n          useTypeImports: true,\n        },\n        {\n          outputFile: 'foo.ts',\n        }\n      );\n      const tsxContent = await plugin(\n        schema,\n        [],\n        {\n          useTypeImports: true,\n        },\n        {\n          outputFile: 'foo.tsx',\n        }\n      );\n      const output = `import type { IntrospectionQuery } from 'graphql';\nexport default ${introspection} as unknown as IntrospectionQuery;`;\n\n      expect(tsContent).toBeSimilarStringTo(output);\n      expect(tsxContent).toBeSimilarStringTo(output);\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "Should emit scalars if includeScalars config value is used",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 229,
                "column": 66
            },
            "line": 229,
            "code": "    it('Should emit scalars if includeScalars config value is used', async () => {\n      const schema = buildSchema(`\n        scalar MyScalar\n        type Query {\n          myScalar: MyScalar\n        }\n      `);\n      const result = await plugin(schema, [], { includeScalars: true }, { outputFile: 'foo.ts' });\n\n      expect(result).toContain('MyScalar');\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "Should emit directives if includeDirectives config value is used",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 241,
                "column": 72
            },
            "line": 241,
            "code": "    it('Should emit directives if includeDirectives config value is used', async () => {\n      const schema = buildSchema(`\n        directive @myDirective on FIELD_DEFINITION\n\n        type Query {\n          foo: Int @myDirective\n        }\n      `);\n      const result = await plugin(schema, [], { includeDirectives: true }, { outputFile: 'foo.ts' });\n\n      expect(result).toContain('myDirective');\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "Should emit enums if includeEnums config value is used",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 254,
                "column": 62
            },
            "line": 254,
            "code": "    it('Should emit enums if includeEnums config value is used', async () => {\n      const schema = buildSchema(`\n        enum MyEnum {\n          FOO\n        }\n\n        type Query {\n          myEnum: MyEnum\n        }\n      `);\n      const result = await plugin(schema, [], { includeEnums: true }, { outputFile: 'foo.ts' });\n\n      expect(result).toContain('MyEnum');\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "Should emit inputs if includeInputs config value is used",
            "suites": [
                "Urql Introspection Plugin",
                "TypeScript"
            ],
            "updatePoint": {
                "line": 269,
                "column": 64
            },
            "line": 269,
            "code": "    it('Should emit inputs if includeInputs config value is used', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          foo: Int\n        }\n\n        type Query {\n          foo(myInput: MyInput): Int\n        }\n      `);\n      const result = await plugin(schema, [], { includeInputs: true }, { outputFile: 'foo.ts' });\n\n      expect(result).toContain('MyInput');\n    });",
            "file": "urql-introspection.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/urql-introspection/tests"
        },
        {
            "name": "checks if types are actually included when Omit is applied",
            "suites": [
                "BaseResolversVisitor.createResolversFields"
            ],
            "updatePoint": {
                "line": 19,
                "column": 64
            },
            "line": 19,
            "code": "  it('checks if types are actually included when Omit is applied', () => {\n    /**\n     * This makes sure that https://github.com/dotansimha/graphql-code-generator/issues/6709 doesn't occur again.\n     * The result looked like this without the fix:\n     * export type ResolversParentTypes = {\n     *   Query: {}\n     *   A: Omit<A, 'b'> & { b?: Maybe<ResolversParentTypes['B']> }\n     *   Boolean: Scalars['Boolean']\n     *   String: Scalars['String']\n     * };\n     */\n    const visitor = new BaseResolversVisitor(\n      {\n        mappers: {\n          B: './some-file#B',\n        },\n      },\n      {} as ParsedResolversConfig,\n      schema\n    );\n\n    expect(visitor.buildResolversParentTypes()).toEqual(\n      `/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = {\n  Query: {}\n  A: A\n  Boolean: Scalars['Boolean']\n  String: Scalars['String']\n};\n`\n    );\n  });",
            "file": "create-resolvers-fields.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "generates proper types when typesPrefix is used along with `enumPrefix: false`",
            "suites": [
                "BaseResolversVisitor.createResolversFields"
            ],
            "updatePoint": {
                "line": 52,
                "column": 84
            },
            "line": 52,
            "code": "  it('generates proper types when typesPrefix is used along with `enumPrefix: false`', () => {\n    /**\n     * This makes sure that https://github.com/dotansimha/graphql-code-generator/issues/6709 doesn't occur again.\n     * The result looked like this without the fix:\n     * export type ResolversParentTypes = {\n     *   Query: {}\n     *   A: Omit<A, 'b'> & { b?: Maybe<ResolversParentTypes['B']> }\n     *   Boolean: Scalars['Boolean']\n     *   String: Scalars['String']\n     * };\n     */\n    const visitor = new BaseResolversVisitor(\n      {\n        mappers: {\n          B: './some-file#B',\n        },\n        typesPrefix: 'I',\n        enumPrefix: false,\n      },\n      {} as ParsedResolversConfig,\n      schema\n    );\n\n    expect(visitor.buildResolversParentTypes()).toEqual(\n      `/** Mapping between all available schema types and the resolvers parents */\nexport type IResolversParentTypes = {\n  Query: {}\n  A: IA\n  Boolean: Scalars['Boolean']\n  String: Scalars['String']\n};\n`\n    );\n  });",
            "file": "create-resolvers-fields.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with namespaces",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 17,
                "column": 33
            },
            "line": 17,
            "code": "  it('should work with namespaces', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#SomeNamespace.ETest`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'SomeNamespace.ETest',\n        importIdentifier: 'SomeNamespace',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with regular type",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 37,
                "column": 35
            },
            "line": 37,
            "code": "  it('should work with regular type', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#ETest`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'ETest',\n        importIdentifier: 'ETest',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should work with aliased type",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 57,
                "column": 35
            },
            "line": 57,
            "code": "  it('should work with aliased type', () => {\n    const result = parseEnumValues({\n      schema,\n      mapOrStr: {\n        Test: `my-file#ETest as Something`,\n      },\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: 'my-file',\n        sourceIdentifier: 'Something',\n        importIdentifier: 'ETest as Something',\n        mappedValues: null,\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should respect enum values from schema and escape it if needed",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 104,
                "column": 68
            },
            "line": 104,
            "code": "  it('should respect enum values from schema and escape it if needed', () => {\n    const result = parseEnumValues({\n      schema: schemaWithEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: false,\n    });\n\n    expect(result).toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: 'a',\n          B: 'b',\n          C: 'c',\n          D: `escape me \\\\'`,\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should ignore enum values from schema",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 128,
                "column": 43
            },
            "line": 128,
            "code": "  it('should ignore enum values from schema', () => {\n    const result = parseEnumValues({\n      schema: schemaWithEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: true,\n    });\n\n    expect(result).not.toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: 'a',\n          B: 'b',\n          C: 'c',\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should respect non-string enum values",
            "suites": [
                "enumValues"
            ],
            "updatePoint": {
                "line": 178,
                "column": 43
            },
            "line": 178,
            "code": "  it('should respect non-string enum values', () => {\n    const result = parseEnumValues({\n      schema: schemaWithNonStringEnumValues,\n      mapOrStr: {},\n      ignoreEnumValuesFromSchema: false,\n    });\n\n    expect(result).not.toEqual({\n      Test: {\n        isDefault: false,\n        typeIdentifier: 'Test',\n        sourceFile: null,\n        importIdentifier: null,\n        sourceIdentifier: null,\n        mappedValues: {\n          A: '1',\n          B: 'true',\n          C: 'null',\n          D: 'undefined',\n        },\n      },\n    });\n  });",
            "file": "enum-values.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a simple named mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 4,
                "column": 64
            },
            "line": 4,
            "code": "  it('Should return the correct values for a simple named mapper', () => {\n    const result = parseMapper('MyType');\n\n    expect(result).toEqual({\n      isExternal: false,\n      type: 'MyType',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a external named mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 13,
                "column": 66
            },
            "line": 13,
            "code": "  it('Should return the correct values for a external named mapper', () => {\n    const result = parseMapper('file#MyType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'MyType',\n      type: 'MyType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should return the correct values for a external default mapper",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 25,
                "column": 68
            },
            "line": 25,
            "code": "  it('Should return the correct values for a external default mapper', () => {\n    const result = parseMapper('file#default', 'MyGqlType');\n\n    expect(result).toEqual({\n      default: true,\n      isExternal: true,\n      import: 'MyGqlType',\n      type: 'MyGqlType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support namespaces",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 37,
                "column": 31
            },
            "line": 37,
            "code": "  it('Should support namespaces', () => {\n    const result = parseMapper('file#Namespace.Type', 'MyGqlType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Namespace',\n      type: 'Namespace.Type',\n      source: 'file',\n    });\n\n    // legacy\n    const legacyResult = parseMapper('file#Namespace#Type', 'MyGqlType');\n\n    expect(legacyResult).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Namespace',\n      type: 'Namespace.Type',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support aliases",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 60,
                "column": 28
            },
            "line": 60,
            "code": "  it('Should support aliases', () => {\n    const result = parseMapper('file#Type as SomeOtherType', 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Type as SomeOtherType',\n      type: 'SomeOtherType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support aliases (default)",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 72,
                "column": 38
            },
            "line": 72,
            "code": "  it('Should support aliases (default)', () => {\n    const result = parseMapper('file#default as SomeOtherType', 'SomeType');\n\n    expect(result).toEqual({\n      default: true,\n      isExternal: true,\n      import: 'SomeOtherType',\n      type: 'SomeOtherType',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should support generic with complex setup",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 84,
                "column": 47
            },
            "line": 84,
            "code": "  it('should support generic with complex setup', () => {\n    const result = parseMapper(`@common-types#Edge<ResolversParentTypes['User']>`, 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Edge',\n      type: `Edge<ResolversParentTypes['User']>`,\n      source: '@common-types',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should support generics",
            "suites": [
                "parseMapper"
            ],
            "updatePoint": {
                "line": 96,
                "column": 29
            },
            "line": 96,
            "code": "  it('Should support generics', () => {\n    const result = parseMapper('file#Type<Generic>', 'SomeType');\n\n    expect(result).toEqual({\n      default: false,\n      isExternal: true,\n      import: 'Type',\n      type: 'Type<Generic>',\n      source: 'file',\n    });\n  });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should not add a suffix to a simple named mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 109,
                "column": 56
            },
            "line": 109,
            "code": "    it('Should not add a suffix to a simple named mapper', () => {\n      const result = parseMapper('MyType', null, 'Model');\n\n      expect(result).toEqual({\n        isExternal: false,\n        type: 'MyType',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix to an external named mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 118,
                "column": 55
            },
            "line": 118,
            "code": "    it('Should add a suffix to an external named mapper', () => {\n      const result = parseMapper('file#Type', null, 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as TypeModel',\n        type: 'TypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix to an external default mapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 130,
                "column": 57
            },
            "line": 130,
            "code": "    it('Should add a suffix to an external default mapper', () => {\n      const result = parseMapper('file#default', 'MyGqlType', 'Model');\n\n      expect(result).toEqual({\n        default: true,\n        isExternal: true,\n        import: 'MyGqlTypeModel',\n        type: 'MyGqlTypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix and support generics",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 142,
                "column": 48
            },
            "line": 142,
            "code": "    it('Should add a suffix and support generics', () => {\n      const result = parseMapper('file#Type<Generic>', 'SomeType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as TypeModel',\n        type: 'TypeModel<Generic>',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should not add a suffix to a namespace",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 154,
                "column": 46
            },
            "line": 154,
            "code": "    it('Should not add a suffix to a namespace', () => {\n      const result = parseMapper('file#Namespace.Type', 'MyGqlType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Namespace',\n        type: 'Namespace.Type',\n        source: 'file',\n      });\n\n      // legacy\n      const legacyResult = parseMapper('file#Namespace#Type', 'MyGqlType', 'Model');\n\n      expect(legacyResult).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Namespace',\n        type: 'Namespace.Type',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should add a suffix next to an alias",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 177,
                "column": 44
            },
            "line": 177,
            "code": "    it('Should add a suffix next to an alias', () => {\n      const result = parseMapper('file#Type as SomeOtherType', 'SomeType', 'Model');\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as SomeOtherTypeModel',\n        type: 'SomeOtherTypeModel',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "transformMappers should apply a suffix to parseMapper",
            "suites": [
                "parseMapper",
                "suffix"
            ],
            "updatePoint": {
                "line": 189,
                "column": 61
            },
            "line": 189,
            "code": "    it('transformMappers should apply a suffix to parseMapper', () => {\n      const mappers = transformMappers(\n        {\n          Type: 'file#Type as SomeOtherType',\n        },\n        'Suffix'\n      );\n\n      const result = mappers.Type;\n\n      expect(result).toEqual({\n        default: false,\n        isExternal: true,\n        import: 'Type as SomeOtherTypeSuffix',\n        type: 'SomeOtherTypeSuffix',\n        source: 'file',\n      });\n    });",
            "file": "parse-mapper.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should use pascal case by default",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 4,
                "column": 39
            },
            "line": 4,
            "code": "  it('Should use pascal case by default', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('myName')).toBe('MyName');\n    expect(factory('myname')).toBe('Myname');\n    expect(factory('MyNAME')).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override underscore behaviour directly from configuration.",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 15,
                "column": 80
            },
            "line": 15,
            "code": "  it('Should allow to override underscore behaviour directly from configuration.', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        transformUnderscore: true,\n      },\n    });\n\n    expect(factory('My_Name')).toBe('MyName');\n    expect(factory('_Myname')).toBe('Myname');\n    expect(factory('My_name')).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use \"keep\" as root",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 27,
                "column": 40
            },
            "line": 27,
            "code": "  it('Should allow to use \"keep\" as root', () => {\n    const factory = convertFactory({\n      namingConvention: 'keep',\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('myName')).toBe('myName');\n    expect(factory('myname')).toBe('myname');\n    expect(factory('MyNAME')).toBe('MyNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use Function as root",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 38,
                "column": 42
            },
            "line": 38,
            "code": "  it('Should allow to use Function as root', () => {\n    const factory = convertFactory({\n      namingConvention: str => {\n        return 'something' + str;\n      },\n    });\n\n    expect(factory('MyName')).toBe('somethingMyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use object of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 48,
                "column": 54
            },
            "line": 48,
            "code": "  it('Should allow to use object of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: 'keep',\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('MyName');\n    expect(factory('Myname')).toBe('Myname');\n    expect(factory('NYNAME')).toBe('NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use function of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 61,
                "column": 56
            },
            "line": 61,
            "code": "  it('Should allow to use function of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => 'a_' + str,\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('a_MyName');\n    expect(factory('Myname')).toBe('a_Myname');\n    expect(factory('NYNAME')).toBe('a_NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to use function of naming conventions",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 74,
                "column": 56
            },
            "line": 74,
            "code": "  it('Should allow to use function of naming conventions', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => 'a_' + str,\n        enumValues: 'keep',\n      },\n    });\n\n    expect(factory('MyName')).toBe('a_MyName');\n    expect(factory('Myname')).toBe('a_Myname');\n    expect(factory('NYNAME')).toBe('a_NYNAME');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should keep underscore by default",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 87,
                "column": 39
            },
            "line": 87,
            "code": "  it('Should keep underscore by default', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('My_Name')).toBe('My_Name');\n    expect(factory('_Myname')).toBe('_Myname');\n    expect(factory('My_name')).toBe('My_Name');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override underscore behaviour",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 97,
                "column": 51
            },
            "line": 97,
            "code": "  it('Should allow to override underscore behaviour', () => {\n    const factory = convertFactory({\n      namingConvention: null,\n    });\n\n    expect(factory('My_Name', { transformUnderscore: true })).toBe('MyName');\n    expect(factory('_Myname', { transformUnderscore: true })).toBe('Myname');\n    expect(factory('My_name', { transformUnderscore: true })).toBe('MyName');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "Should allow to override transformUnderscore in config",
            "suites": [
                "convertFactory"
            ],
            "updatePoint": {
                "line": 107,
                "column": 60
            },
            "line": 107,
            "code": "  it('Should allow to override transformUnderscore in config', () => {\n    const factory = convertFactory({\n      namingConvention: {\n        typeNames: str => str.replace('_', ''),\n        enumValues: 'keep',\n        transformUnderscore: true,\n      },\n    });\n\n    expect(factory('My_Name')).toBe('MyName');\n    expect(factory('_Myname')).toBe('Myname');\n    expect(factory('My_name')).toBe('Myname');\n  });",
            "file": "plugins-common.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/other/visitor-plugin-common/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 41,
                "column": 58
            },
            "line": 41,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 59,
                "column": 58
            },
            "line": 59,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should add the correct angular imports",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 74,
                "column": 46
            },
            "line": 74,
            "code": "    it(`should add the correct angular imports`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from 'apollo-angular';`);\n      expect(content.prepend).toContain(`import { Injectable } from '@angular/core';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should add a constructor and super call (Issue #4366)",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 90,
                "column": 61
            },
            "line": 90,
            "code": "    it(`should add a constructor and super call (Issue #4366)`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          constructor(apollo: Apollo.Apollo) {\n            super(apollo);\n          }\n        }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should add additional DI for constructor & super call",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 110,
                "column": 61
            },
            "line": 110,
            "code": "    it(`should add additional DI for constructor & super call`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          additionalDI: ['testService: TestService', 'testService1: TestService1'],\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          constructor(apollo: Apollo.Apollo, testService: TestService, testService1: TestService1) {\n            super(apollo, testService, testService1);\n          }\n        }\n      `);\n      // await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should add explicit override to document and namedClient property",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 132,
                "column": 73
            },
            "line": 132,
            "code": "    it(`should add explicit override to document and namedClient property`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          addExplicitOverride: true,\n          namedClient: 'custom',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`override document = TestDocument;`);\n      expect(content.content).toBeSimilarStringTo(`override client = 'custom';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should add the correct angular imports with override",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 151,
                "column": 60
            },
            "line": 151,
            "code": "    it(`should add the correct angular imports with override`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          apolloAngularPackage: 'my-custom-apollo-angular',\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from 'my-custom-apollo-angular';`);\n      expect(content.prepend).toContain(`import { Injectable } from '@angular/core';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should import NgModules and remove NgModule directive",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 169,
                "column": 61
            },
            "line": 169,
            "code": "    it('Should import NgModules and remove NgModule directive', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      expect(modifiedSchema.getDirective('NgModule').name).toBe('NgModule');\n      const modulePath = '../my/lazy-module';\n      const moduleName = 'LazyModule';\n\n      const myFeed = gql(`\n        query MyFeed {\n          feed @client @NgModule(module: \"${modulePath}#${moduleName}\") {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { ${moduleName} } from '${modulePath}';`);\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({\n          providedIn: ${moduleName}\n        })\n        export class MyFeedGQL\n      `);\n      expect(content.content).toBeSimilarStringTo(`document = MyFeedDocument;`);\n      expect(content.content).not.toContain('@NgModule');\n      expect(content.content).toContain('@client');\n      await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should import namedClient and remove namedClient directive",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 205,
                "column": 66
            },
            "line": 205,
            "code": "    it('Should import namedClient and remove namedClient directive', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      expect(modifiedSchema.getDirective('namedClient').name).toBe('namedClient');\n\n      const myFeed = gql(`\n        query MyFeed {\n          feed @namedClient(name: \"custom\") {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`document = MyFeedDocument;`);\n\n      expect(content.content).toBeSimilarStringTo(`\n        client = 'custom';\n      `);\n      expect(content.content).not.toContain('@namedClient');\n      await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 236,
                "column": 104
            },
            "line": 236,
            "code": "    it('should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importDocumentNodeExternallyFrom must be provided if documentMode=external'\n      );\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set to something other than \"Operations\"",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 256,
                "column": 94
            },
            "line": 256,
            "code": "    it('output warning if importOperationTypesFrom is set to something other than \"Operations\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Whatever',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importOperationTypesFrom only works correctly when left empty or set to \"Operations\"'\n      );\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and documentMode is not \"external\"",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 277,
                "column": 92
            },
            "line": 277,
            "code": "    it('output warning if importOperationTypesFrom is set and documentMode is not \"external\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 297,
                "column": 101
            },
            "line": 297,
            "code": "    it('output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should allow importing operations and documents from another file",
            "suites": [
                "Apollo Angular",
                "Imports"
            ],
            "updatePoint": {
                "line": 318,
                "column": 73
            },
            "line": 318,
            "code": "    it('should allow importing operations and documents from another file', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n          importDocumentNodeExternallyFrom: '@myproject/generated',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from '@myproject/generated';`);\n      expect(content.content).toContain('Operations.TestQuery');\n      expect(content.content).toContain('Operations.TestQueryVariables');\n      expect(content.content).toContain('Operations.TestDocument');\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should be able to use root schema object",
            "suites": [
                "Apollo Angular",
                "Component"
            ],
            "updatePoint": {
                "line": 342,
                "column": 48
            },
            "line": 342,
            "code": "    it('Should be able to use root schema object', async () => {\n      const rootSchema = buildSchema(`\n        type RootQuery { f: String }\n        schema { query: RootQuery }\n      `);\n      const query = gql`\n        query test {\n          f\n        }\n      `;\n      const docs = [{ location: '', document: query }];\n      const content = (await plugin(\n        rootSchema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({\n          providedIn: 'root'\n        })\n        export class TestGQL extends Apollo.Query\n      `);\n      await validateTypeScript(content, rootSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should handle @client",
            "suites": [
                "Apollo Angular",
                "Component"
            ],
            "updatePoint": {
                "line": 371,
                "column": 29
            },
            "line": 371,
            "code": "    it('Should handle @client', async () => {\n      const myFeed = gql`\n        query MyFeed {\n          feed @client {\n            id\n          }\n        }\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`document = MyFeedDocument;`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should be allow to define namedClient and NgModule in config",
            "suites": [
                "Apollo Angular",
                "configuration"
            ],
            "updatePoint": {
                "line": 397,
                "column": 68
            },
            "line": 397,
            "code": "    it('should be allow to define namedClient and NgModule in config', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const myExtraFeed = gql(`\n        query MyExtraFeed {\n          feed @NgModule(module: \"./extra#ExtraModule\") @namedClient(name: \"extra\") {\n            id\n          }\n        }\n      `);\n      const docs = [\n        { location: '', document: myFeed },\n        { location: 'a.ts', document: myExtraFeed },\n      ];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {\n          ngModule: './path/to/file#AppModule',\n          namedClient: 'custom',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // NgModule\n      expect(content.prepend).toContain(`import { AppModule } from './path/to/file';`);\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({\n          providedIn: AppModule\n        })\n        export class MyFeedGQL\n      `);\n      expect(content.prepend).toContain(`import { ExtraModule } from './extra';`);\n\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({\n          providedIn: ExtraModule\n        })\n        export class MyExtraFeed\n      `);\n      expect(content.content).not.toContain('@NgModule');\n\n      // NamedClient\n      expect(content.content).toBeSimilarStringTo(`client = 'custom';`);\n      expect(content.content).toBeSimilarStringTo(`client = 'extra';`);\n      expect(content.content).not.toContain('@namedClient');\n\n      await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should be allowed to define custom operation suffixes in config",
            "suites": [
                "Apollo Angular",
                "configuration"
            ],
            "updatePoint": {
                "line": 454,
                "column": 71
            },
            "line": 454,
            "code": "    it('should be allowed to define custom operation suffixes in config', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const vote = gql(`\n      mutation vote($repoFullName: String!, $type: VoteType!) {\n    vote(repoFullName: $repoFullName, type: $type) {\n      score\n      id\n      vote {\n        vote_value\n      }\n    }\n  }\n      `);\n      const commentAdded = gql(`\n        subscription onCommentAdded($repoFullName: String!) {\n        commentAdded(repoFullName: $repoFullName) {\n          id\n          postedBy {\n            login\n            html_url\n          }\n          createdAt\n          content\n        }\n      }\n      `);\n      const docs = [\n        { location: '', document: myFeed },\n        { location: '', document: commentAdded },\n        { location: '', document: vote },\n      ];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {\n          querySuffix: 'QueryService',\n          mutationSuffix: 'MutationService',\n          subscriptionSuffix: 'SubscriptionService',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export class MyFeedQueryService`);\n      expect(content.content).toContain(`export class OnCommentAddedSubscriptionService`);\n      expect(content.content).toContain(`export class VoteMutationService`);\n      await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should generate a SDK service",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 513,
                "column": 37
            },
            "line": 513,
            "code": "    it('should generate a SDK service', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        { sdkClass: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // NgModule\n      expect(content.prepend).toContain(`import * as ApolloCore from '@apollo/client/core';`);\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({ providedIn: 'root' })\n        export class ApolloAngularSDK {\n        constructor(\n          private myFeedGql: MyFeedGQL\n        ) {}\n\n        myFeed(variables?: MyFeedQueryVariables, options?: QueryOptionsAlone<MyFeedQueryVariables>) {\n          return this.myFeedGql.fetch(variables, options)\n        }\n\n        myFeedWatch(variables?: MyFeedQueryVariables, options?: WatchQueryOptionsAlone<MyFeedQueryVariables>) {\n          return this.myFeedGql.watch(variables, options)\n        }\n        }\n      `);\n      // await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should include only the required SDK types for query operations",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 553,
                "column": 71
            },
            "line": 553,
            "code": "    it('should include only the required SDK types for query operations', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        { sdkClass: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n        interface WatchQueryOptionsAlone<V> extends Omit<ApolloCore.WatchQueryOptions<V>, 'query' | 'variables'> {}\n\n        interface QueryOptionsAlone<V> extends Omit<ApolloCore.QueryOptions<V>, 'query' | 'variables'> {}`);\n      expect(content.content).not.toContain('SubscriptionOptionsAlone');\n      expect(content.content).not.toContain('MutationOptionsAlone');\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should include only the required SDK types for mutation operations",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 582,
                "column": 74
            },
            "line": 582,
            "code": "    it('should include only the required SDK types for mutation operations', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        mutation Update($arg: Int) {\n          update(arg: $arg) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        { sdkClass: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n        interface MutationOptionsAlone<T, V> extends Omit<ApolloCore.MutationOptions<T, V>, 'mutation' | 'variables'> {}`);\n      expect(content.content).not.toContain('WatchOptionsAlone');\n      expect(content.content).not.toContain('QueryOptionsAlone');\n      expect(content.content).not.toContain('SubscriptionOptionsAlone');\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should include only the required SDK types for subscription operations",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 610,
                "column": 78
            },
            "line": 610,
            "code": "    it('should include only the required SDK types for subscription operations', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        subscription MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        { sdkClass: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n        interface SubscriptionOptionsAlone<V> extends Omit<ApolloCore.SubscriptionOptions<V>, 'query' | 'variables'> {}`);\n      expect(content.content).not.toContain('WatchOptionsAlone');\n      expect(content.content).not.toContain('QueryOptionsAlone');\n      expect(content.content).not.toContain('MutationOptionsAlone');\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should generate a SDK service with custom settings",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 638,
                "column": 58
            },
            "line": 638,
            "code": "    it('should generate a SDK service with custom settings', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {\n          sdkClass: true,\n          serviceName: 'MySDK',\n          serviceProvidedInRoot: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // NgModule\n      expect(content.prepend).toContain(`import * as ApolloCore from '@apollo/client/core';`);\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable()\n        export class MySDK {\n        constructor(\n          private myFeedGql: MyFeedGQL\n        ) {}\n\n        myFeed(variables?: MyFeedQueryVariables, options?: QueryOptionsAlone<MyFeedQueryVariables>) {\n          return this.myFeedGql.fetch(variables, options)\n        }\n\n        myFeedWatch(variables?: MyFeedQueryVariables, options?: WatchQueryOptionsAlone<MyFeedQueryVariables>) {\n          return this.myFeedGql.watch(variables, options)\n        }\n        }\n      `);\n      // await validateTypeScript(content, modifiedSchema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should generate a SDK service for Apollo Angular 1.0 on demand",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 682,
                "column": 70
            },
            "line": 682,
            "code": "    it('should generate a SDK service for Apollo Angular 1.0 on demand', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {\n          sdkClass: true,\n          apolloAngularVersion: 1,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as ApolloCore from 'apollo-client';`);\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should generate a SDK service with a requested providedIn value",
            "suites": [
                "Apollo Angular",
                "SDK Service"
            ],
            "updatePoint": {
                "line": 707,
                "column": 71
            },
            "line": 707,
            "code": "    it('should generate a SDK service with a requested providedIn value', async () => {\n      const modifiedSchema = extendSchema(schema, addToSchema);\n      const myFeed = gql(`\n        query MyFeed {\n          feed {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        modifiedSchema,\n        docs,\n        {\n          sdkClass: true,\n          serviceProvidedIn: '../app.module#AppModule',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // NgModule import\n      expect(content.prepend).toContain(`import { AppModule } from '../app.module';`);\n      // NgModule in `providedIn`\n      expect(content.content).toBeSimilarStringTo(`\n        @Injectable({ providedIn: AppModule })\n        export class ApolloAngularSDK {\n      `);\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should use Operations when preset is near-operation-file",
            "suites": [
                "Apollo Angular",
                "near-operation-file"
            ],
            "updatePoint": {
                "line": 740,
                "column": 64
            },
            "line": 740,
            "code": "    it('Should use Operations when preset is near-operation-file', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'near-operation-file',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`@Injectable({\n        providedIn: 'root'\n      })\n      export class TestGQL extends Apollo.Query<TestQuery, TestQueryVariables> {\n        document = Operations.TestDocument;\n\n        constructor(apollo: Apollo.Apollo) {\n          super(apollo);\n        }\n      }`);\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "should handle fragments",
            "suites": [
                "Apollo Angular",
                "others"
            ],
            "updatePoint": {
                "line": 768,
                "column": 31
            },
            "line": 768,
            "code": "    it('should handle fragments', async () => {\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...MyEntry\n          }\n        }\n\n        fragment MyEntry on Entry {\n          id\n          commentCount\n        }\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "apollo-angular.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-angular/tests"
        },
        {
            "name": "Should output typePolicies object correctly",
            "suites": [
                "apollo-client-helpers"
            ],
            "updatePoint": {
                "line": 6,
                "column": 49
            },
            "line": 6,
            "code": "  it('Should output typePolicies object correctly', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        user: User!\n      }\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "apollo-client-helpers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-client-helpers/tests"
        },
        {
            "name": "Should output typePolicies object with requireKeyFields: true",
            "suites": [
                "apollo-client-helpers"
            ],
            "updatePoint": {
                "line": 20,
                "column": 67
            },
            "line": 20,
            "code": "  it('Should output typePolicies object with requireKeyFields: true', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        user: User!\n      }\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n    const result = mergeOutputs([\n      await plugin(schema, [], {\n        requireKeyFields: true,\n      }),\n    ]);\n    expect(result).toContain(`keyFields:`);\n    expect(result).not.toContain(`keyFields?:`);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "apollo-client-helpers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-client-helpers/tests"
        },
        {
            "name": "Should output typePolicies object with requirePoliciesForAllTypes: true",
            "suites": [
                "apollo-client-helpers"
            ],
            "updatePoint": {
                "line": 40,
                "column": 77
            },
            "line": 40,
            "code": "  it('Should output typePolicies object with requirePoliciesForAllTypes: true', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        user: User!\n      }\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n    const result = mergeOutputs([\n      await plugin(schema, [], {\n        requirePoliciesForAllTypes: true,\n      }),\n    ]);\n    expect(result).toContain(`User:`);\n    expect(result).toContain(`Query?:`);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "apollo-client-helpers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/apollo-client-helpers/tests"
        },
        {
            "name": "Should generate simple module with one file",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 7,
                "column": 49
            },
            "line": 7,
            "code": "  it('Should generate simple module with one file', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate correctly for mutiple files",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 34,
                "column": 49
            },
            "line": 34,
            "code": "  it('Should generate correctly for mutiple files', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n        {\n          location: 'some/file/my-other-query.graphql',\n          document: parse(/* GraphQL */ `\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n\n      export const OtherQuery = gql\\`\n        query OtherQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should ignore unnamed documents",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 75,
                "column": 37
            },
            "line": 75,
            "code": "  it('Should ignore unnamed documents', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo('');\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate simple module with two documents in one file",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 96,
                "column": 66
            },
            "line": 96,
            "code": "  it('Should generate simple module with two documents in one file', async () => {\n    const result = (await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n\n      export const OtherQuery = gql\\`\n        query OtherQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a camel case",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 133,
                "column": 56
            },
            "line": 133,
            "code": "  it('Should generate module with a name as a camel case', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#camelCase' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const myQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a pascal case with underscores",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 160,
                "column": 74
            },
            "line": 160,
            "code": "  it('Should generate module with a name as a pascal case with underscores', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query My_Query {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#pascalCase', transformUnderscore: false } as any,\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const My_Query = gql\\`\n        query My_Query {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a pascal case without underscores",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 187,
                "column": 77
            },
            "line": 187,
            "code": "  it('Should generate module with a name as a pascal case without underscores', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query My_Query {\n              field\n            }\n          `),\n        },\n      ],\n      {\n        namingConvention: {\n          typeNames: 'change-case-all#pascalCase',\n          transformUnderscore: true,\n        },\n      },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQuery = gql\\`\n        query My_Query {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with a name as a contant case",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 219,
                "column": 58
            },
            "line": 219,
            "code": "  it('Should generate module with a name as a contant case', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namingConvention: 'change-case-all#constantCase' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MY_QUERY = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with prefix for a name",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 246,
                "column": 51
            },
            "line": 246,
            "code": "  it('Should generate module with prefix for a name', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { namePrefix: 'Graphql' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const GraphqlMyQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate module with suffix for a name",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 273,
                "column": 51
            },
            "line": 273,
            "code": "  it('Should generate module with suffix for a name', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { nameSuffix: 'Query' },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export const MyQueryQuery = gql\\`\n        query MyQuery {\n          field\n        }\n      \\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should generate simple module without graphql-tag",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 300,
                "column": 55
            },
            "line": 300,
            "code": "  it('Should generate simple module without graphql-tag', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { noGraphQLTag: true },\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export const MyQuery = {\"kind\":\"Document\",\"definitions\":[{\"kind\":\"OperationDefinition\",\"operation\":\"query\",\"name\":{\"kind\":\"Name\",\"value\":\"MyQuery\"},\"selectionSet\":{\"kind\":\"SelectionSet\",\"selections\":[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"field\"}}]}}]} as unknown as DocumentNode;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "should contain fragment definitions",
            "suites": [
                "graphql-codegen typescript-graphql-document-nodes"
            ],
            "updatePoint": {
                "line": 323,
                "column": 41
            },
            "line": 323,
            "code": "  it('should contain fragment definitions', async () => {\n    const result = plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            # Put your operations here\n            fragment fragment1 on User {\n              id\n              username\n            }\n\n            query user {\n              user(id: 1) {\n                ...fragment1\n              }\n            }\n\n            query user2 {\n              user2: user(id: 1) {\n                ...fragment1\n                email\n              }\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    ) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export const Fragment1 = gql\\`\n      fragment fragment1 on User {\n        id\n        username\n      }\n    \\`;\n    \n    export const User = gql\\`\n      query user {\n        user(id: 1) {\n          ...fragment1\n        }\n      }\n    \\${Fragment1}\\`;\n    \n    export const User2 = gql\\`\n      query user2 {\n        user2: user(id: 1) {\n          ...fragment1\n          email\n        }\n      }\n    \\${Fragment1}\\`;\n    `);\n    validateTs(mergeOutputs([result]));\n  });",
            "file": "graphql-document-nodes.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/document-nodes/tests"
        },
        {
            "name": "Should work",
            "suites": [
                "TypeScript",
                "with importFrom"
            ],
            "updatePoint": {
                "line": 8,
                "column": 19
            },
            "line": 8,
            "code": "    it('Should work', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(schema, [], { importFrom: './generated-types' })) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toBeSimilarStringTo(`\n        import { MyEnum } from \"./generated-types\";\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        const MY_ENUM: MyEnum[] = ['A', 'B'];\n      `);\n    });",
            "file": "enum-array.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/enum-array/tests"
        },
        {
            "name": "Should work",
            "suites": [
                "TypeScript",
                "without importFrom"
            ],
            "updatePoint": {
                "line": 29,
                "column": 19
            },
            "line": 29,
            "code": "    it('Should work', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(schema, [], {})) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toBeSimilarStringTo(`\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        const MY_ENUM: MyEnum[] = ['A', 'B'];\n      `);\n    });",
            "file": "enum-array.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/enum-array/tests"
        },
        {
            "name": "Should generate a correct wrap method",
            "suites": [
                "generic-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 88,
                "column": 45
            },
            "line": 88,
            "code": "    it('Should generate a correct wrap method', async () => {\n      const config = {};\n      const docs = [{ filePath: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const requester = <R, V> (doc: DocumentNode, vars: V): Promise<R> => Promise.resolve({} as unknown as R);\n  const sdk = getSdk(requester);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "generic-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/generic-sdk/tests"
        },
        {
            "name": "Should generate a correct wrap method with documentMode=string",
            "suites": [
                "generic-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 117,
                "column": 70
            },
            "line": 117,
            "code": "    it('Should generate a correct wrap method with documentMode=string', async () => {\n      const config = { documentMode: DocumentMode.string };\n      const docs = [{ filePath: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const requester = <R, V> (doc: string, vars: V): Promise<R> => Promise.resolve({} as unknown as R);\n  const sdk = getSdk(requester);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "generic-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/generic-sdk/tests"
        },
        {
            "name": "Should support rawRequest",
            "suites": [
                "generic-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 146,
                "column": 33
            },
            "line": 146,
            "code": "    it('Should support rawRequest', async () => {\n      const config = { rawRequest: true };\n      const docs = [{ filePath: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\n        async function rawRequestTest() {\n          const requester = <R, V> (doc: string, vars: V): Promise<R> => Promise.resolve({} as unknown as R);\n          const sdk = getSdk(requester);\n\n          await sdk.feed();\n          await sdk.feed3();\n          await sdk.feed4();\n\n          const result = await sdk.feed2({ v: \"1\" });\n\n          if (result.data.feed) {\n            if (result.data.feed[0]) {\n              const id = result.data.feed[0].id\n            }\n          }\n        }\n      `;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "generic-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/generic-sdk/tests"
        },
        {
            "name": "Should generate a correct wrap method when usingObservableFrom is set",
            "suites": [
                "generic-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 176,
                "column": 77
            },
            "line": 176,
            "code": "    it('Should generate a correct wrap method when usingObservableFrom is set', async () => {\n      const config = { usingObservableFrom: \"import Observable from 'zen-observable';\" };\n      const docs = [{ filePath: '', document: docWithSubscription }];\n      const result = (await plugin(schema, docs, config, { outputFile: 'graphql.ts' })) as Types.ComplexPluginOutput;\n\n      const output = await validate(result, config, docs, schema, '');\n      expect(output).toMatchSnapshot();\n    });",
            "file": "generic-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/generic-sdk/tests"
        },
        {
            "name": "Should throw if it encounters unnamed operations",
            "suites": [
                "generic-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 185,
                "column": 56
            },
            "line": 185,
            "code": "    it('Should throw if it encounters unnamed operations', async () => {\n      const config = { usingObservableFrom: \"import Observable from 'zen-observable';\" };\n      const docs = [{ filePath: '', document: unnamedDoc }];\n      try {\n        await plugin(schema, docs, config, { outputFile: 'graphql.ts' });\n        fail('Should throw');\n      } catch (err: unknown) {\n        expect(err).toMatchInlineSnapshot(`\n[Error: Plugin 'generic-sdk' cannot generate SDK for unnamed operation.\n\n{\n  feed {\n    id\n  }\n}]\n`);\n      }\n    });",
            "file": "generic-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/generic-sdk/tests"
        },
        {
            "name": "Should support useTypeImports",
            "suites": [
                "apollo-client",
                "sdk"
            ],
            "updatePoint": {
                "line": 75,
                "column": 37
            },
            "line": 75,
            "code": "    it('Should support useTypeImports', async () => {\n      const config = { useTypeImports: true };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('@apollo/client').ApolloClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-apollo/tests"
        },
        {
            "name": "Should generate Sdk correctly",
            "suites": [
                "apollo-client",
                "sdk"
            ],
            "updatePoint": {
                "line": 105,
                "column": 37
            },
            "line": 105,
            "code": "    it('Should generate Sdk correctly', async () => {\n      const config = {};\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('@apollo/client').ApolloClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-apollo/tests"
        },
        {
            "name": "should send requests correctly",
            "suites": [
                "GraphQL Request Integration"
            ],
            "line": 14,
            "code": "  it.skip('should send requests correctly', async () => {",
            "file": "integration.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/graphql-apollo/tests"
        },
        {
            "name": "Should generate simple module with one file",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 6,
                "column": 49
            },
            "line": 6,
            "code": "  it('Should generate simple module with one file', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const MyQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should generate correctly for mutiple files",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 35,
                "column": 49
            },
            "line": 35,
            "code": "  it('Should generate correctly for mutiple files', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n        {\n          location: 'some/file/my-other-query.graphql',\n          document: parse(/* GraphQL */ `\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const MyQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n\n      declare module '*/my-other-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const OtherQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should ignore unnamed documents",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 80,
                "column": 37
            },
            "line": 80,
            "code": "  it('Should ignore unnamed documents', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should generate simple module with two documents in one file",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 108,
                "column": 66
            },
            "line": 108,
            "code": "  it('Should generate simple module with two documents in one file', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const MyQuery: DocumentNode;\n        export const OtherQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should generate simple module with two documents in two files, with same name",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 142,
                "column": 83
            },
            "line": 142,
            "code": "  it('Should generate simple module with two documents in two files, with same name', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n        {\n          location: 'some/file-other-path/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query OtherQuery {\n              field\n            }\n          `),\n        },\n      ],\n      {},\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const MyQuery: DocumentNode;\n        export const OtherQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should generate simple module with a custom path prefix",
            "suites": [
                "graphql-codegen typescript-graphql-files-modules"
            ],
            "updatePoint": {
                "line": 180,
                "column": 61
            },
            "line": 180,
            "code": "  it('Should generate simple module with a custom path prefix', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          location: 'some/file/my-query.graphql',\n          document: parse(/* GraphQL */ `\n            query MyQuery {\n              field\n            }\n          `),\n        },\n      ],\n      { modulePathPrefix: 'api/' },\n      { outputFile: '' }\n    );\n\n    expect(result).toBeSimilarStringTo(`\n      declare module '*/api/my-query.graphql' {\n        import { DocumentNode } from 'graphql';\n        const defaultDocument: DocumentNode;\n        export const MyQuery: DocumentNode;\n      \n        export default defaultDocument;\n      }\n    `);\n    validateTs(result);\n  });",
            "file": "graphql-files-modules.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-files-modules/tests"
        },
        {
            "name": "Should generate a correct wrap method",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 64,
                "column": 45
            },
            "line": 64,
            "code": "    it('Should generate a correct wrap method', async () => {\n      const config = {};\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const client = new GraphQLClient('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(result.content).toContain(\n        `(FeedDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'feed', 'query');`\n      );\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should generate a correct wrap method with documentMode=string",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 96,
                "column": 70
            },
            "line": 96,
            "code": "    it('Should generate a correct wrap method with documentMode=string', async () => {\n      const config = { documentMode: DocumentMode.string };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const client = new GraphQLClient('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should allow passing wrapper arg to generated getSdk",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 125,
                "column": 60
            },
            "line": 125,
            "code": "    it('Should allow passing wrapper arg to generated getSdk', async () => {\n      const config = { documentMode: DocumentMode.string };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const client = new GraphQLClient('');\n  const functionWrapper: SdkFunctionWrapper = async <T>(action: () => Promise<T>): Promise<T> => {\n    console.log('before');\n    const result = await action();\n    console.log('after');\n    return result;\n  }\n\n  const sdk = getSdk(client, functionWrapper);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should support useTypeImports",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 161,
                "column": 37
            },
            "line": 161,
            "code": "    it('Should support useTypeImports', async () => {\n      const config = { useTypeImports: true };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('graphql-request').GraphQLClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should support rawRequest when documentMode = \"documentNode\"",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 191,
                "column": 68
            },
            "line": 191,
            "code": "    it('Should support rawRequest when documentMode = \"documentNode\"', async () => {\n      const config = { rawRequest: true };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('graphql-request').GraphQLClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should not import print as type when supporting useTypeImports and rawRequest and documentMode = \"documentNode\"",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 221,
                "column": 119
            },
            "line": 221,
            "code": "    it('Should not import print as type when supporting useTypeImports and rawRequest and documentMode = \"documentNode\"', async () => {\n      const config = { rawRequest: true, useTypeImports: true };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('graphql-request').GraphQLClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should support extensionType when rawRequest is true and documentMode = \"DocumentNode\"",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 251,
                "column": 94
            },
            "line": 251,
            "code": "    it('Should support extensionType when rawRequest is true and documentMode = \"DocumentNode\"', async () => {\n      const config = { rawRequest: true, extensionsType: 'unknown' };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('graphql-request').GraphQLClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "extensionType should be irrelevant when rawRequest is false",
            "suites": [
                "graphql-request",
                "sdk"
            ],
            "updatePoint": {
                "line": 281,
                "column": 67
            },
            "line": 281,
            "code": "    it('extensionType should be irrelevant when rawRequest is false', async () => {\n      const config = { rawRequest: false, extensionsType: 'unknown' };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const Client = require('graphql-request').GraphQLClient;\n  const client = new Client('');\n  const sdk = getSdk(client);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "#5386 - should provide a nice error when dealing with anonymous operations",
            "suites": [
                "graphql-request",
                "issues"
            ],
            "updatePoint": {
                "line": 313,
                "column": 82
            },
            "line": 313,
            "code": "    it('#5386 - should provide a nice error when dealing with anonymous operations', async () => {\n      const doc = parse(/* GraphQL */ `\n        query {\n          feed {\n            id\n          }\n        }\n      `);\n\n      const warnSpy = jest.spyOn(console, 'warn');\n      const docs = [{ location: 'file.graphlq', document: doc }];\n      const result = (await plugin(schema, docs, {}, {})) as Types.ComplexPluginOutput;\n      expect(result.content).not.toContain('feed');\n      expect(warnSpy.mock.calls.length).toBe(1);\n      expect(warnSpy.mock.calls[0][0]).toContain('Anonymous GraphQL operation was ignored');\n      expect(warnSpy.mock.calls[0][1]).toContain('feed');\n      warnSpy.mockRestore();\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "#4748 - integration with importDocumentNodeExternallyFrom",
            "suites": [
                "graphql-request",
                "issues"
            ],
            "updatePoint": {
                "line": 332,
                "column": 65
            },
            "line": 332,
            "code": "    it('#4748 - integration with importDocumentNodeExternallyFrom', async () => {\n      const config = { importDocumentNodeExternallyFrom: './operations', documentMode: DocumentMode.external };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n      const output = await validate(result, config, docs, schema, '');\n\n      expect(output).toContain(`import * as Operations from './operations';`);\n      expect(output).toContain(\n        `(Operations.FeedDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'feed', 'query');`\n      );\n      expect(output).toContain(\n        `(Operations.Feed2Document, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'feed2', 'query');`\n      );\n      expect(output).toContain(\n        `(Operations.Feed3Document, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'feed3', 'query');`\n      );\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "#7114 - honor importOperationTypesFrom",
            "suites": [
                "graphql-request",
                "issues"
            ],
            "updatePoint": {
                "line": 352,
                "column": 46
            },
            "line": 352,
            "code": "    it('#7114 - honor importOperationTypesFrom', async () => {\n      const config = { importOperationTypesFrom: 'Types' };\n      const docs = [{ location: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n      const output = await validate(result, config, docs, schema, '');\n\n      expect(output).toContain(`Types.FeedQuery`);\n      expect(output).toContain(`Types.Feed2Query`);\n      expect(output).toContain(`Types.Feed3Query`);\n      expect(output).toContain(`Types.Feed4Query`);\n    });",
            "file": "graphql-request.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "should send requests correctly",
            "suites": [
                "GraphQL Request Integration"
            ],
            "updatePoint": {
                "line": 12,
                "column": 36
            },
            "line": 12,
            "code": "  it('should send requests correctly', async () => {\n    const sdkFileName = 'graphql-request-sdk.ts';\n    const sdkFilePath = join(__dirname, './test-files', sdkFileName);\n    const typeDefs = parse(/* GraphQL */ `\n      type Query {\n        add(x: Int!, y: Int!): Int!\n      }\n    `);\n    const schema = makeExecutableSchema({\n      typeDefs,\n      resolvers: {\n        Query: {\n          add: (_, { x, y }) => x + y,\n        },\n      },\n    });\n    const exampleQuery = /* GraphQL */ `\n      query Add($x: Int!, $y: Int!) {\n        add(x: $x, y: $y)\n      }\n    `;\n    const sdkCodeString = await codegen({\n      schema: typeDefs,\n      schemaAst: schema,\n      documents: [\n        {\n          document: parse(exampleQuery),\n          rawSDL: exampleQuery,\n        },\n      ],\n      filename: sdkFileName,\n      pluginMap: {\n        typescript: TypeScriptPlugin,\n        'typescript-operations': TypeScriptOperationsPlugin,\n        'graphql-request': GraphQLRequestPlugin,\n      },\n      plugins: [\n        {\n          typescript: {},\n        },\n        {\n          'typescript-operations': {},\n        },\n        {\n          'graphql-request': {},\n        },\n      ],\n      config: {},\n    });\n    await writeFile(sdkFilePath, sdkCodeString, 'utf-8');\n    const mockServer = mockGraphQLServer({\n      schema,\n      host: 'http://localhost:4000',\n      path: '/graphql',\n    });\n    const { runExampleQuery } = require('./test-files/run-example-query');\n    const queryResult = await runExampleQuery(2, 3);\n    expect(queryResult?.add).toBe(5);\n    mockServer.done();\n    await remove(sdkFilePath);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/graphql-request/tests"
        },
        {
            "name": "Should generate a correct wrap method",
            "suites": [
                "jit-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 88,
                "column": 45
            },
            "line": 88,
            "code": "    it('Should generate a correct wrap method', async () => {\n      const config = {};\n      const docs = [{ filePath: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const schema = buildSchema(\\`${printSchema(schema).trim()}\\`);\n  const sdk = getJitSdk(schema);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "jit-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/jit-sdk/tests"
        },
        {
            "name": "Should generate a correct wrap method with documentMode=string",
            "suites": [
                "jit-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 117,
                "column": 70
            },
            "line": 117,
            "code": "    it('Should generate a correct wrap method with documentMode=string', async () => {\n      const config = { documentMode: DocumentMode.string };\n      const docs = [{ filePath: '', document: basicDoc }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      const usage = `\nasync function test() {\n  const schema = buildSchema(\\`${printSchema(schema).trim()}\\`);\n  const sdk = getJitSdk(schema);\n\n  await sdk.feed();\n  await sdk.feed3();\n  await sdk.feed4();\n\n  const result = await sdk.feed2({ v: \"1\" });\n\n  if (result.feed) {\n    if (result.feed[0]) {\n      const id = result.feed[0].id\n    }\n  }\n}`;\n      const output = await validate(result, config, docs, schema, usage);\n\n      expect(output).toMatchSnapshot();\n    });",
            "file": "jit-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/jit-sdk/tests"
        },
        {
            "name": "Should generate a correct wrap method in case of Subscription",
            "suites": [
                "jit-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 146,
                "column": 69
            },
            "line": 146,
            "code": "    it('Should generate a correct wrap method in case of Subscription', async () => {\n      const docs = [{ filePath: '', document: docWithSubscription }];\n      const result = (await plugin(schema, docs, {}, { outputFile: 'graphql.ts' })) as Types.ComplexPluginOutput;\n\n      const output = await validate(result, {}, docs, schema, '');\n      expect(output).toMatchSnapshot();\n    });",
            "file": "jit-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/jit-sdk/tests"
        },
        {
            "name": "Should throw if it encounters unnamed operations",
            "suites": [
                "jit-sdk",
                "sdk"
            ],
            "updatePoint": {
                "line": 154,
                "column": 56
            },
            "line": 154,
            "code": "    it('Should throw if it encounters unnamed operations', async () => {\n      const docs = [{ filePath: '', document: unnamedDoc }];\n      try {\n        await plugin(schema, docs, {}, { outputFile: 'graphql.ts' });\n        fail('Should throw');\n      } catch (err: unknown) {\n        expect(err).toMatchInlineSnapshot(`\n[Error: Plugin 'Jit-sdk' cannot generate SDK for unnamed operation.\n\n{\n  feed {\n    id\n  }\n}]\n`);\n      }\n    });",
            "file": "jit-sdk.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/jit-sdk/tests"
        },
        {
            "name": "Should accept dbTypeSuffix",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 104,
                "column": 34
            },
            "line": 104,
            "code": "    it('Should accept dbTypeSuffix', async () => {\n      const config = { dbTypeSuffix: 'Obj' };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      expect(result).toContain('export type UserObj = {');\n      expect(result).toContain('export type EmbeddedTypeObj = {');\n      expect(result).toContain('export type LinkTypeObj = {');\n      await validate(result, schema, config);\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should accept dbInterfaceSuffix",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 113,
                "column": 39
            },
            "line": 113,
            "code": "    it('Should accept dbInterfaceSuffix', async () => {\n      const result = await plugin(schema, [], { dbInterfaceSuffix: 'InterfaceObj' }, { outputFile: '' });\n      expect(result).toContain(`export type FeedItemInterfaceObj = {`);\n      expect(result).toContain(`export type PostDbObject = FeedItemInterfaceObj & {`);\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize objectIdType import with basic type",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 120,
                "column": 69
            },
            "line": 120,
            "code": "    it('Should allow to customize objectIdType import with basic type', async () => {\n      const result = await plugin(schema, [], { objectIdType: 'string' }, { outputFile: '' });\n      expect(result).toContain(`_id: string`);\n      expect(result).not.toContain(`ObjectId`);\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize objectIdType import with custom import",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 127,
                "column": 72
            },
            "line": 127,
            "code": "    it('Should allow to customize objectIdType import with custom import', async () => {\n      const result = await plugin(schema, [], { objectIdType: 'ObjectID#bson' }, { outputFile: '' });\n      expect(result).toContain(`_id: ObjectID`);\n      expect(result).not.toContain(`ObjectId`);\n      expect(result).toContain(`import { ObjectID } from 'bson';`);\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize idFieldName",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 135,
                "column": 45
            },
            "line": 135,
            "code": "    it('Should allow to customize idFieldName', async () => {\n      const result = await plugin(schema, [], { idFieldName: 'id' }, { outputFile: '' });\n      expect(result).toContain(`id: ObjectId`);\n      expect(result).not.toContain(`_id`);\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize enumsAsString",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 142,
                "column": 47
            },
            "line": 142,
            "code": "    it('Should allow to customize enumsAsString', async () => {\n      const result = await plugin(schema, [], { enumsAsString: false }, { outputFile: '' });\n      expect(result).not.toContain('gender?: Maybe<string>');\n      expect(result).toContain('gender?: Maybe<Gender>');\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize avoidOptionals",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 149,
                "column": 48
            },
            "line": 149,
            "code": "    it('Should allow to customize avoidOptionals', async () => {\n      const result = await plugin(schema, [], { avoidOptionals: true }, { outputFile: '' });\n      expect(result).not.toContain('?:');\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should allow to customize namingConvention",
            "suites": [
                "TypeScript Mongo",
                "Config"
            ],
            "updatePoint": {
                "line": 155,
                "column": 50
            },
            "line": 155,
            "code": "    it('Should allow to customize namingConvention', async () => {\n      const config = { namingConvention: 'change-case-all#lowerCase' };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      expect(result).toContain('export type userdbobject = {');\n      expect(result).toContain(`export type feeditemdbinterface = {`);\n      await validate(result, schema, config);\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should compile TypeScript correctly",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 165,
                "column": 43
            },
            "line": 165,
            "code": "    it('Should compile TypeScript correctly', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should include only the relevant types",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 170,
                "column": 46
            },
            "line": 170,
            "code": "    it('Should include only the relevant types', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('export type UserDbObject = {');\n      expect(result).not.toContain('export type QueryDbObject = {');\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should generate output for interfaces with discriminatorField",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 176,
                "column": 69
            },
            "line": 176,
            "code": "    it('Should generate output for interfaces with discriminatorField', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`export type FeedItemDbInterface = {`);\n      expect(result).toContain(`kind: string,`);\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should include a valid type when implementing interfaces",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 182,
                "column": 64
            },
            "line": 182,
            "code": "    it('Should include a valid type when implementing interfaces', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`export type FeedItemDbInterface = {`);\n      expect(result).toContain(`export type PostDbObject = FeedItemDbInterface & {`);\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should include a valid union with discriminatorField",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 188,
                "column": 60
            },
            "line": 188,
            "code": "    it('Should include a valid union with discriminatorField', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toBeSimilarStringTo(`\n      export type SearchResultDbObject = (PostDbObject | UserDbObject) & {\n        entityType: string,\n      };`);\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @id directive",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 196,
                "column": 58
            },
            "line": 196,
            "code": "    it('Should output the correct values for @id directive', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('_id?: Maybe<ObjectId>'); // optional id\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @column directive",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 202,
                "column": 62
            },
            "line": 202,
            "code": "    it('Should output the correct values for @column directive', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain('name?: Maybe<string>'); // optional scalar\n      expect(result).toContain('gender?: Maybe<string>'); // enum as string by default\n      expect(result).toContain(`arrayColumn?: Maybe<Array<Maybe<number>>>`); // simple @column with array\n      expect(result).toContain(`columnWithOverride?: number`); // override type\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @link directive",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 211,
                "column": 60
            },
            "line": 211,
            "code": "    it('Should output the correct values for @link directive', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`someLink?: Maybe<LinkTypeDbObject['_id']>`); // link to another entity\n      expect(result).toContain(`multipleLinks?: Maybe<Array<Maybe<LinkTypeDbObject['_id']>>>`); // links array\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @link directive and overrideType",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 218,
                "column": 77
            },
            "line": 218,
            "code": "    it('Should output the correct values for @link directive and overrideType', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`someLinkWithOverride?: Maybe<LinkTypeDbObject['_id']>`); // link to another entity\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should prduce valid types when names are uppercase",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 224,
                "column": 58
            },
            "line": 224,
            "code": "    it('Should prduce valid types when names are uppercase', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toBeSimilarStringTo(`\n      export type TestDbObject = {\n        _id: ObjectId,\n        foo: string,\n      };\n\n      export type Test2DbObject = {\n        testfield: TestDbObject['_id'],\n      };`);\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @link directive and overrideType and array type",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 239,
                "column": 92
            },
            "line": 239,
            "code": "    it('Should output the correct values for @link directive and overrideType and array type', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result).toContain(`documents?: Maybe<Array<Maybe<MachineDocumentDbObject['_id']>>>`); // link to another entity with overwrite type and array\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @map directive",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 246,
                "column": 59
            },
            "line": 246,
            "code": "    it('Should output the correct values for @map directive', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`myInnerArray?: Maybe<Array<Maybe<number>>>`); // simple @column with array and @map\n      expect(result).toContain(`other_name?: Maybe<string>`); // simple @map scalar\n      expect(result).toBeSimilarStringTo(`\n      profile: {\n        inner: {\n          field?: Maybe<string>,\n        },\n      },`); // custom @map with inner fields\n      expect(result).toBeSimilarStringTo(`\n      innerEmbedded: {\n        moreLevel?: Maybe<EmbeddedTypeDbObject>,\n      },`); // embedded with @map\n      expect(result).toContain(`nonNullableColumn: string`); // simple @column with @map\n      expect(result).toContain(`nullableLinkId?: Maybe<LinkTypeDbObject['_id']>`); // nullable @link with @map\n      expect(result).toBeSimilarStringTo(`\n      nullableColumnMap: {\n        level?: Maybe<string>,\n      },`); // map with nullable field;\n      expect(result).toBeSimilarStringTo(`\n      nonNullableColumnMap: {\n        level: string,\n      },`); // map with non-nullable field\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values for @embedded directive",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 273,
                "column": 64
            },
            "line": 273,
            "code": "    it('Should output the correct values for @embedded directive', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`basicEmbedded: EmbeddedTypeDbObject`); // embedded type\n      expect(result).toContain(`arrayEmbedded: Array<EmbeddedTypeDbObject>`); // embedded array\n      expect(result).toContain(`nullableEmbedded?: Maybe<Array<Maybe<EmbeddedTypeDbObject>>`); // optional array embedded\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values with additionalFields",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 280,
                "column": 62
            },
            "line": 280,
            "code": "    it('Should output the correct values with additionalFields', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`nonSchemaField: string`); // additional field\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should output the correct values with nonSchemaOptionalField",
            "suites": [
                "TypeScript Mongo",
                "Output"
            ],
            "updatePoint": {
                "line": 286,
                "column": 68
            },
            "line": 286,
            "code": "    it('Should output the correct values with nonSchemaOptionalField', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result).toContain(`nonSchemaOptionalField?: string`); // non schema optional additional field\n      await validate(result, schema, {});\n    });",
            "file": "typescript-mongo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/mongodb/tests"
        },
        {
            "name": "Should generate mocks based on queries and mutations",
            "suites": [
                "msw"
            ],
            "updatePoint": {
                "line": 13,
                "column": 58
            },
            "line": 13,
            "code": "  it('Should generate mocks based on queries and mutations', async () => {\n    const result = await plugin(null, documents, {});\n\n    // handler function names\n    expect(result.content).toContain(`mock${queryName}Query`);\n    expect(result.content).toContain(`mock${mutationName}Mutation`);\n\n    // handler strings\n    expect(result.content).toContain(`'${queryName}',`);\n    expect(result.content).toContain(`'${mutationName}',`);\n\n    expect(result.prepend).toMatchSnapshot('imports');\n    expect(result.content).toMatchSnapshot('content');\n  });",
            "file": "msw.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/msw/tests"
        },
        {
            "name": "Should generate a link with an endpoint when passed a link variable",
            "suites": [
                "msw"
            ],
            "updatePoint": {
                "line": 28,
                "column": 73
            },
            "line": 28,
            "code": "  it('Should generate a link with an endpoint when passed a link variable', async () => {\n    const link = { name: 'api', endpoint: 'http://localhost:3000/graphql' };\n    const capitalizedName = pascalCase(link.name);\n\n    const result = await plugin(null, documents, { link });\n\n    // endpoint definition\n    expect(result.content).toContain(`const ${link.name} = graphql.link('${link.endpoint}')`);\n\n    // endpoint used instead of `graphql`\n    expect(result.content).not.toContain(`graphql.query`);\n    expect(result.content).not.toContain(`graphql.mutation`);\n    expect(result.content).toContain(`${link.name}.query`);\n    expect(result.content).toContain(`${link.name}.mutation`);\n\n    // handler function names\n    expect(result.content).toContain(`mock${queryName}Query${capitalizedName}`);\n    expect(result.content).toContain(`mock${mutationName}Mutation${capitalizedName}`);\n\n    expect(result.content).toMatchSnapshot('content with a link/endpoint');\n  });",
            "file": "msw.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/msw/tests"
        },
        {
            "name": "Should generate JSDoc documentation with variables and selection from the operations themselves",
            "suites": [
                "msw"
            ],
            "updatePoint": {
                "line": 50,
                "column": 101
            },
            "line": 50,
            "code": "  it('Should generate JSDoc documentation with variables and selection from the operations themselves', async () => {\n    const variables = ['id', 'offset', 'limit'];\n    const input = variables.map(v => `$${v}: Int`).join(', ');\n\n    const fields = ['name', 'phone', 'country'];\n    const selection = fields.join(', ');\n\n    const documents = [\n      { document: parse(`query ${queryName}(${input}) { ${selection} }`) },\n      { document: parse(`mutation ${mutationName}(${input}) { ${selection} }`) },\n    ];\n\n    const result = await plugin(null, documents, {});\n\n    expect(result.content).toContain(`const { ${variables.join(', ')} } = req.variables`);\n    expect(result.content).toContain(`ctx.data({ ${selection} })`);\n    expect(result.content).toMatchSnapshot('content with variables and selection JSDoc documentation');\n  });",
            "file": "msw.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/msw/tests"
        },
        {
            "name": "Should use the \"importOperationTypesFrom\" setting",
            "suites": [
                "msw"
            ],
            "updatePoint": {
                "line": 69,
                "column": 55
            },
            "line": 69,
            "code": "  it('Should use the \"importOperationTypesFrom\" setting', async () => {\n    const importOperationTypesFrom = 'Types';\n    const result = await plugin(null, documents, { importOperationTypesFrom });\n\n    // handler variable and result type\n    const queryVariablesType = `${importOperationTypesFrom}.${queryName}QueryVariables`;\n    const queryType = `${importOperationTypesFrom}.${queryName}Query`;\n    expect(result.content).toContain(`GraphQLRequest<${queryVariablesType}>`);\n    expect(result.content).toContain(`GraphQLContext<${queryType}>`);\n    expect(result.content).toContain(`graphql.query<${queryType}, ${queryVariablesType}>`);\n\n    const mutationVariablesType = `${importOperationTypesFrom}.${mutationName}MutationVariables`;\n    const mutationType = `${importOperationTypesFrom}.${mutationName}Mutation`;\n    expect(result.content).toContain(`GraphQLRequest<${mutationVariablesType}>`);\n    expect(result.content).toContain(`GraphQLContext<${mutationType}>`);\n    expect(result.content).toContain(`graphql.mutation<${mutationType}, ${mutationVariablesType}>`);\n\n    expect(result.content).toMatchSnapshot('content with types configured via importOperationTypesFrom');\n  });",
            "file": "msw.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/msw/tests"
        },
        {
            "name": "Should generate const strings when useConsts: true is set",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 6,
                "column": 63
            },
            "line": 6,
            "code": "  it('Should generate const strings when useConsts: true is set', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query myQuery {\n              id\n            }\n          `),\n        },\n      ],\n      {\n        useConsts: true,\n      }\n    );\n\n    expect(result).toBeSimilarStringTo(`export const namedOperations = {\n      Query: {\n        myQuery: 'myQuery' as const\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should generate the correct output with a single query",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 30,
                "column": 60
            },
            "line": 30,
            "code": "  it('Should generate the correct output with a single query', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query myQuery {\n              id\n            }\n          `),\n        },\n      ],\n      {}\n    );\n\n    expect(result).toBeSimilarStringTo(`export const namedOperations = {\n      Query: {\n        myQuery: 'myQuery'\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should return empty reuslt when no valid operations",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 52,
                "column": 57
            },
            "line": 52,
            "code": "  it('Should return empty reuslt when no valid operations', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query {\n              id\n            }\n          `),\n        },\n      ],\n      {}\n    );\n\n    expect(result).toBe('');\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should work with fragments",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 70,
                "column": 32
            },
            "line": 70,
            "code": "  it('Should work with fragments', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query myQuery {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            fragment UserFields on User {\n              id\n            }\n          `),\n        },\n      ],\n      {}\n    );\n\n    expect(result).toBeSimilarStringTo(`export const namedOperations = {\n      Query: {\n        myQuery: 'myQuery'\n      },\n      Fragment: {\n        UserFields: 'UserFields'\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should return empty reuslt when no operations exists",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 102,
                "column": 58
            },
            "line": 102,
            "code": "  it('Should return empty reuslt when no operations exists', async () => {\n    const result = await plugin(null, [], {});\n\n    expect(result).toBe('');\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should override identifier name",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 108,
                "column": 37
            },
            "line": 108,
            "code": "  it('Should override identifier name', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query myQuery {\n              id\n            }\n          `),\n        },\n      ],\n      { identifierName: 'AllMyOperations' }\n    );\n\n    expect(result).toBeSimilarStringTo(`export const AllMyOperations = {\n      Query: {\n        myQuery: 'myQuery'\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should generate the correct output with a multiple operations",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 130,
                "column": 67
            },
            "line": 130,
            "code": "  it('Should generate the correct output with a multiple operations', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query myQuery {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            mutation doSomething {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            mutation doSomethingElse {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            subscription somethingHappened {\n              id\n            }\n          `),\n        },\n      ],\n      {}\n    );\n\n    expect(result).toBeSimilarStringTo(`export const namedOperations = {\n      Query: {\n        myQuery: 'myQuery'\n      },\n      Mutation: {\n        doSomething: 'doSomething',\n        doSomethingElse: 'doSomethingElse'\n      },\n      Subscription: {\n        somethingHappened: 'somethingHappened'\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "Should ignore anonymouse operations",
            "suites": [
                "named-operations-object"
            ],
            "updatePoint": {
                "line": 180,
                "column": 41
            },
            "line": 180,
            "code": "  it('Should ignore anonymouse operations', async () => {\n    const result = await plugin(\n      null,\n      [\n        {\n          document: parse(/* GraphQL */ `\n            query {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            mutation doSomething {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            mutation doSomethingElse {\n              id\n            }\n          `),\n        },\n        {\n          document: parse(/* GraphQL */ `\n            subscription somethingHappened {\n              id\n            }\n          `),\n        },\n      ],\n      {}\n    );\n\n    expect(result).toBeSimilarStringTo(`export const namedOperations = {\n      Mutation: {\n        doSomething: 'doSomething',\n        doSomethingElse: 'doSomethingElse'\n      },\n      Subscription: {\n        somethingHappened: 'somethingHappened'\n      }\n    }`);\n  });",
            "file": "plugin.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/named-operations-object/tests"
        },
        {
            "name": "builds from a read query with single string parameter",
            "suites": [
                "oclif",
                "cli"
            ],
            "updatePoint": {
                "line": 9,
                "column": 61
            },
            "line": 9,
            "code": "    it('builds from a read query with single string parameter', async () => {\n      const document = parse(`\n        query GetEntry($name: String!) {\n          entry(repoFullName: $name) {\n            repository {\n              name\n            }\n          }\n        }\n      `);\n\n      const config = {};\n      const docs = [{ location: '', document }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n    });",
            "file": "oclif.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/oclif/tests"
        },
        {
            "name": "builds from a read query with single enum parameter",
            "suites": [
                "oclif",
                "cli"
            ],
            "updatePoint": {
                "line": 29,
                "column": 59
            },
            "line": 29,
            "code": "    it('builds from a read query with single enum parameter', async () => {\n      const document = parse(`\n        query GetFeed($type: FeedType!) {\n          feed(type: $type) {\n            id\n            commentCount\n          }\n        }\n      `);\n\n      const config = {};\n      const docs = [{ location: '', document }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n    });",
            "file": "oclif.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/oclif/tests"
        },
        {
            "name": "builds from a read query with integer parameters",
            "suites": [
                "oclif",
                "cli"
            ],
            "updatePoint": {
                "line": 48,
                "column": 56
            },
            "line": 48,
            "code": "    it('builds from a read query with integer parameters', async () => {\n      const document = parse(`\n        query GetFeed($type: FeedType!, $offset: Int!, $limit: Int!) {\n          feed(type: $type, offset: $offset, limit: $limit) {\n            id\n            commentCount\n          }\n        }\n      `);\n\n      const config = {};\n      const docs = [{ location: '', document }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n    });",
            "file": "oclif.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/oclif/tests"
        },
        {
            "name": "reads metadata from the @oclif directive",
            "suites": [
                "oclif",
                "cli"
            ],
            "updatePoint": {
                "line": 67,
                "column": 48
            },
            "line": 67,
            "code": "    it('reads metadata from the @oclif directive', async () => {\n      const document = parse(`\n        query GetCurrentUser @oclif(description: \"Get Current User\", example: \"cli get-current-user\", example: \"hello\") {\n          currentUser {\n            login\n          }\n        }\n      `);\n\n      const config = {};\n      const docs = [{ location: '', document }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n    });",
            "file": "oclif.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/oclif/tests"
        },
        {
            "name": "builds from a mutation with string and enum type",
            "suites": [
                "oclif",
                "cli"
            ],
            "updatePoint": {
                "line": 85,
                "column": 56
            },
            "line": 85,
            "code": "    it('builds from a mutation with string and enum type', async () => {\n      const document = parse(`\n        mutation Vote($name: String!, $type: VoteType!) {\n          vote(repoFullName: $name, type: $type) {\n            score\n          }\n        }\n      `);\n\n      const config = {};\n      const docs = [{ location: '', document }];\n      const result = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toMatchSnapshot();\n    });",
            "file": "oclif.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/oclif/tests"
        },
        {
            "name": "Should not generate \"export\" when noExport is set to true",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 106,
                "column": 65
            },
            "line": 106,
            "code": "    it('Should not generate \"export\" when noExport is set to true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                created: createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { noExport: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).not.toContain('export');\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"namespacedImportName\" and add it when specified",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 134,
                "column": 70
            },
            "line": 134,
            "code": "    it('Should handle \"namespacedImportName\" and add it when specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n              textAlias: text\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                created: createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namespacedImportName: 'Types' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<Types.TextNotification, 'text' | 'id'>\n            & { textAlias: Types.TextNotification['text'] }\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<Types.ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & { created: Types.ImageMetadata['createdBy'] }\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config, schema, '', [`Cannot find namespace 'Types'.`]);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Can merge an inline fragment with a spread",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 183,
                "column": 50
            },
            "line": 183,
            "code": "    it('Can merge an inline fragment with a spread', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Comment {\n          id: ID!\n          title: String!\n        }\n\n        type TextComment implements Comment {\n          id: ID!\n          title: String!\n          text: String!\n        }\n\n        type ImageComment implements Comment {\n          id: ID!\n          title: String!\n          image: String!\n        }\n\n        type Post {\n          id: ID!\n          comments: [Comment!]!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        fragment Post on Post {\n          id\n          comments {\n            ... on TextComment {\n              text\n            }\n          }\n        }\n\n        fragment PostPlus on Post {\n          ...Post\n          comments {\n            id\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: 'test-file.ts', document: ast }],\n        {},\n        {\n          outputFile: '',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type PostFragment = { __typename?: 'Post', id: string, comments: Array<{ __typename?: 'TextComment', text: string } | { __typename?: 'ImageComment' }> };\n\n        export type PostPlusFragment = { __typename?: 'Post', id: string, comments: Array<{ __typename?: 'TextComment', text: string, id: string } | { __typename?: 'ImageComment', id: string }> };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"namespacedImportName\" and \"preResolveTypes\" together",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 241,
                "column": 75
            },
            "line": 241,
            "code": "    it('Should handle \"namespacedImportName\" and \"preResolveTypes\" together', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          f: E\n          user: User!\n        }\n\n        enum E {\n          A\n          B\n        }\n\n        scalar JSON\n\n        type User {\n          id: ID!\n          f: E\n          j: JSON\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query test {\n          f\n          user {\n            id\n            f\n            j\n          }\n        }\n      `);\n      const config = { namespacedImportName: 'Types', preResolveTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQuery = { __typename?: 'Query', f?: Types.E | null, user: { __typename?: 'User', id: string, f?: Types.E | null, j?: any | null } };`\n      );\n\n      await validate(content, config, schema, '', [`Cannot find namespace 'Types'.`]);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct output when using immutableTypes config",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 283,
                "column": 75
            },
            "line": 283,
            "code": "    it('Should generate the correct output when using immutableTypes config', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namingConvention: 'change-case-all#lowerCase', immutableTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type notificationsquery = (\n          { readonly __typename?: 'Query' }\n          & { readonly notifications: ReadonlyArray<(\n            { readonly __typename?: 'TextNotification' }\n            & Pick<textnotification, 'text' | 'id'>\n          ) | (\n            { readonly __typename?: 'ImageNotification' }\n            & Pick<imagenotification, 'imageUrl' | 'id'>\n            & { readonly metadata: (\n              { readonly __typename?: 'ImageMetadata' }\n              & Pick<imagemetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should include fragment variable definitions when experimentalFragmentVariables is set",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 326,
                "column": 94
            },
            "line": 326,
            "code": "    it('should include fragment variable definitions when experimentalFragmentVariables is set', async () => {\n      const ast = parse(\n        /* GraphQL */ `\n          fragment TextNotificationFragment($skip: Boolean!) on TextNotification {\n            text @skip(if: $skip)\n          }\n        `,\n        // < v15 compatibility\n        { experimentalFragmentVariables: true, allowLegacyFragmentVariables: true } as any\n      );\n      const config = { experimentalFragmentVariables: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should resolve optionals according to maybeValue",
            "suites": [
                "TypeScript Operations Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 343,
                "column": 56
            },
            "line": 343,
            "code": "    it('should resolve optionals according to maybeValue', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          age: Int\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showProperty: Boolean!) {\n          user {\n            name\n            age\n            address @include(if: $showProperty)\n            nicknames @include(if: $showProperty)\n            parents @include(if: $showProperty)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n          maybeValue: \"T | 'specialType'\",\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, age?: number | 'specialType', address?: string, nicknames?: Array<string> | 'specialType', parents?: Array<User> } };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should include scalars when doing pick",
            "suites": [
                "TypeScript Operations Plugin",
                "Scalars"
            ],
            "updatePoint": {
                "line": 388,
                "column": 46
            },
            "line": 388,
            "code": "    it('Should include scalars when doing pick', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar Date\n        type Query {\n          me: User\n        }\n        type User {\n          id: ID!\n          joinDate: Date!\n        }\n      `);\n\n      const doc = parse(/* GraphQL */ `\n        query {\n          me {\n            id\n            joinDate\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: doc }], config, {\n        outputFile: '',\n      });\n      expect(content).toContain(`Pick<User, 'id' | 'joinDate'>`);\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate custom operation result name",
            "suites": [
                "TypeScript Operations Plugin",
                "Custom Operation Result Name Suffix"
            ],
            "updatePoint": {
                "line": 418,
                "column": 52
            },
            "line": 418,
            "code": "    it('Should generate custom operation result name', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { operationResultSuffix: 'Result', preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type NotificationsQueryVariables = Exact<{ [key: string]: never; }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQueryResult = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & Pick<ImageMetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 467,
                "column": 64
            },
            "line": 467,
            "code": "    it('Should allow custom naming and point to the correct type', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false, namingConvention: 'change-case-all#lowerCase' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type notificationsquery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<textnotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<imagenotification, 'imageUrl' | 'id'>\n            & { metadata: (\n              { __typename?: 'ImageMetadata' }\n              & Pick<imagemetadata, 'createdBy'>\n            ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should allow custom naming and point to the correct type - with custom prefix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 510,
                "column": 85
            },
            "line": 510,
            "code": "    it('Should allow custom naming and point to the correct type - with custom prefix', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: false, typesPrefix: 'i', namingConvention: 'change-case-all#lowerCase' };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type inotificationsqueryvariables = Exact<{ [key: string]: never; }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type inotificationsquery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<itextnotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<iimagenotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<iimagemetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Test for dedupeOperationSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 557,
                "column": 38
            },
            "line": 557,
            "code": "    it('Test for dedupeOperationSuffix', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n\n        fragment MyFragment on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n\n        fragment My on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast3 = parse(/* GraphQL */ `\n        query notificationsQuery {\n          ...MyFragment\n        }\n\n        fragment MyFragment on Query {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        (await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })).content\n      ).toContain('export type NotificationsQueryQuery =');\n      expect(\n        (await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })).content\n      ).toContain('export type MyFragmentFragment =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQueryQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type MyFragment =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type NotificationsQuery =');\n      expect(\n        (\n          await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )\n        ).content\n      ).toContain('export type MyFragment =');\n\n      const withUsage = (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast3 }],\n          { dedupeOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content;\n      expect(withUsage).toBeSimilarStringTo(`\n        export type MyFragment = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id'>\n          )> }\n        );\n      `);\n      expect(withUsage).toBeSimilarStringTo(`\n      export type NotificationsQuery = (\n        { __typename?: 'Query' }\n        & { notifications: Array<(\n          { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n          { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Test for omitOperationSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 698,
                "column": 34
            },
            "line": 698,
            "code": "  it('Test for omitOperationSuffix', async () => {\n    const ast = parse(/* GraphQL */ `\n      query notificationsQuery {\n        notifications {\n          id\n        }\n      }\n\n      fragment MyFragment on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n    const ast2 = parse(/* GraphQL */ `\n      query notifications {\n        notifications {\n          id\n        }\n      }\n\n      fragment My on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n    const ast3 = parse(/* GraphQL */ `\n      query notifications {\n        ...My\n      }\n\n      fragment My on Query {\n        notifications {\n          id\n        }\n      }\n    `);\n\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQueryQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragmentFragment =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragment =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type Notifications =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: true, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type My =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: false, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type NotificationsQuery =');\n    expect(\n      (\n        await plugin(\n          schema,\n          [{ location: 'test-file.ts', document: ast2 }],\n          { omitOperationSuffix: false, preResolveTypes: false },\n          { outputFile: '' }\n        )\n      ).content\n    ).toContain('export type MyFragment =');\n\n    const withUsage = (\n      await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast3 }],\n        { omitOperationSuffix: true, preResolveTypes: false },\n        { outputFile: '' }\n      )\n    ).content;\n    expect(withUsage).toBeSimilarStringTo(`\n      export type My = (\n        { __typename?: 'Query' }\n        & { notifications: Array<(\n          { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n          { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n    `);\n    expect(withUsage).toBeSimilarStringTo(`\n    export type Notifications = (\n      { __typename?: 'Query' }\n      & { notifications: Array<(\n        { __typename?: 'TextNotification' }\n        & Pick<TextNotification, 'id'>\n      ) | (\n        { __typename?: 'ImageNotification' }\n        & Pick<ImageNotification, 'id'>\n      )> }\n    );\n    `);\n  });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore __typename for root types with skipTypeNameForRoot = true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 853,
                "column": 79
            },
            "line": 853,
            "code": "    it('Should ignore __typename for root types with skipTypeNameForRoot = true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = { test?: Maybe<(\n          { __typename?: 'Test' }\n          & Pick<Test, 'foo'>\n        )> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore __typename for root types with skipTypeNameForRoot = true, and with nonOptionalTypename = true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 887,
                "column": 116
            },
            "line": 887,
            "code": "    it('Should ignore __typename for root types with skipTypeNameForRoot = true, and with nonOptionalTypename = true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: true,\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = { test?: Maybe<(\n          { __typename: 'Test' }\n          & Pick<Test, 'foo'>\n        )> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should ignore skipTypeNameForRoot = true when __typename is specified manually",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 922,
                "column": 86
            },
            "line": 922,
            "code": "    it('Should ignore skipTypeNameForRoot = true when __typename is specified manually', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Test {\n          foo: String\n        }\n\n        type Query {\n          test: Test\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          __typename\n          test {\n            foo\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: true,\n        skipTypeNameForRoot: true,\n        preResolveTypes: false,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type Q1Query = (\n          { __typename: 'Query' }\n          & { test?: Maybe<(\n            { __typename: 'Test' }\n            & Pick<Test, 'foo'>\n          )> }\n        );`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly with nonOptionalTypename=false,skipTypename=true,preResolveTypes=true and explicit field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 961,
                "column": 128
            },
            "line": 961,
            "code": "    it('Should add __typename correctly with nonOptionalTypename=false,skipTypename=true,preResolveTypes=true and explicit field', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Search {\n          search: [SearchResult!]!\n        }\n\n        type Movie {\n          id: ID!\n          title: String!\n        }\n        type Person {\n          id: ID!\n          name: String!\n        }\n\n        union SearchResult = Movie | Person\n\n        type Query {\n          search(term: String!): [SearchResult!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query q1 {\n          search {\n            ... on Movie {\n              __typename\n              id\n              title\n            }\n            ... on Person {\n              __typename\n              id\n              name\n            }\n          }\n        }\n\n        query q2 {\n          search {\n            __typename\n            ... on Movie {\n              id\n              title\n            }\n            ... on Person {\n              id\n              name\n            }\n          }\n        }\n      `);\n      const config = {\n        nonOptionalTypename: false,\n        skipTypename: true,\n      };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toContain(\n        `export type Q1Query = { search: Array<{ __typename: 'Movie', id: string, title: string } | { __typename: 'Person', id: string, name: string }> };`\n      );\n      expect(content).toContain(\n        `export type Q2Query = { search: Array<{ __typename: 'Movie', id: string, title: string } | { __typename: 'Person', id: string, name: string }> };`\n      );\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should skip __typename when skipTypename is set to true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1029,
                "column": 63
            },
            "line": 1029,
            "code": "    it('Should skip __typename when skipTypename is set to true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).not.toContain(`__typename`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename when dealing with fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1044,
                "column": 57
            },
            "line": 1044,
            "code": "    it('Should add __typename when dealing with fragments', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          A: String\n        }\n\n        type B implements Node {\n          id: ID!\n          B: String\n        }\n\n        type Query {\n          some: Node\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment Node on Node {\n          __typename\n          id\n        }\n\n        query Test {\n          some {\n            ...Node\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type TestQuery = (\n        { __typename?: 'Query' }\n        & { some?: Maybe<(\n          { __typename: 'A' }\n          & Pick<A, 'id'>\n        ) | (\n          { __typename: 'B' }\n          & Pick<B, 'id'>\n        )> }\n      );\n      `);\n      await validate(content, config, testSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add aliased __typename correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1095,
                "column": 47
            },
            "line": 1095,
            "code": "    it('Should add aliased __typename correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          type: __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & Pick<Query, 'dummy'>\n        & { type: 'Query' }\n      );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add aliased __typename correctly with preResovleTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1116,
                "column": 68
            },
            "line": 1116,
            "code": "    it('Should add aliased __typename correctly with preResovleTypes', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          type: __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = { __typename?: 'Query', dummy?: string | null, type: 'Query' };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when explicitly specified",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1133,
                "column": 71
            },
            "line": 1133,
            "code": "    it('Should add __typename as non-optional when explicitly specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when forced",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1153,
                "column": 57
            },
            "line": 1153,
            "code": "    it('Should add __typename as non-optional when forced', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { nonOptionalTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as optional when its not specified",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1172,
                "column": 64
            },
            "line": 1172,
            "code": "    it('Should add __typename as optional when its not specified', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename?: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename as non-optional when its explictly specified, even if skipTypename is true",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1191,
                "column": 104
            },
            "line": 1191,
            "code": "    it('Should add __typename as non-optional when its explictly specified, even if skipTypename is true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          __typename\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = (\n          { __typename: 'Query' }\n          & Pick<Query, 'dummy'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly when unions are in use",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1212,
                "column": 62
            },
            "line": 1212,
            "code": "    it('Should add __typename correctly when unions are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { unionTest?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          ) | (\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add __typename correctly when interfaces are in use",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1245,
                "column": 66
            },
            "line": 1245,
            "code": "    it('Should add __typename correctly when interfaces are in use', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<ImageMetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should mark __typename as non optional in case it is included in the selection set of an interface field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1286,
                "column": 112
            },
            "line": 1286,
            "code": "    it('should mark __typename as non optional in case it is included in the selection set of an interface field', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            __typename\n            ... on TextNotification {\n              text\n            }\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename: 'TextNotification' }\n            & Pick<TextNotification, 'text'>\n          ) | (\n            { __typename: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should mark __typename as non optional in case it is included in the selection set of an union field",
            "suites": [
                "TypeScript Operations Plugin",
                "__typename"
            ],
            "updatePoint": {
                "line": 1318,
                "column": 108
            },
            "line": 1318,
            "code": "    it('should mark __typename as non optional in case it is included in the selection set of an union field', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            __typename\n            ... on Profile {\n              firstName\n            }\n            ... on User {\n              email\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      { __typename?: 'Query' }\n      & { unionTest?: Maybe<(\n        { __typename: 'User' }\n        & Pick<User, 'email'>\n      ) | (\n        { __typename: 'Profile' }\n        & Pick<Profile, 'firstName'>\n      )> }\n    );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 1352,
                "column": 49
            },
            "line": 1352,
            "code": "    it('Should handle unnamed documents correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle unnamed documents correctly with multiple documents",
            "suites": [
                "TypeScript Operations Plugin",
                "Unnamed Documents"
            ],
            "updatePoint": {
                "line": 1371,
                "column": 73
            },
            "line": 1371,
            "code": "    it('Should handle unnamed documents correctly with multiple documents', async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          dummy\n        }\n\n        query {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_2_Query = Pick<Query, 'dummy'>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type Unnamed_2_QueryVariables = Exact<{ [key: string]: never; }>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect invalid types as parent and notify",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1403,
                "column": 56
            },
            "line": 1403,
            "code": "    it('Should detect invalid types as parent and notify', async () => {\n      const ast = parse(/* GraphQL */ `\n        mutation test {\n          test\n        }\n      `);\n      const config = { preResolveTypes: false };\n\n      try {\n        await plugin(\n          buildSchema(/* GraphQL */ `\n            type Query {\n              foo: String\n            }\n          `),\n          [{ location: 'test-file.ts', document: ast }],\n          config,\n          { outputFile: '' }\n        );\n        expect(true).toBeFalsy();\n      } catch (e) {\n        expect(e.message).toBe('Unable to find root schema type for operation type \"mutation\"!');\n      }\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid __typename usage and split types according to that (with usage)",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1428,
                "column": 89
            },
            "line": 1428,
            "code": "    it('Should have valid __typename usage and split types according to that (with usage)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar IPV4\n        scalar IPV6\n\n        type IPV4Route {\n          address: IPV4\n          gateway: IPV4\n        }\n\n        type IPV6Route {\n          address: IPV6\n          gateway: IPV6\n        }\n\n        union RouteUnion = IPV4Route | IPV6Route\n\n        type Query {\n          routes: [RouteUnion!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment NetRoute on RouteUnion {\n          __typename\n          ... on IPV4Route {\n            ipv4Address: address\n            ipv4Gateway: gateway\n          }\n          ... on IPV6Route {\n            ipv6Address: address\n            ipv6Gateway: gateway\n          }\n        }\n\n        query QQ {\n          routes {\n            ...NetRoute\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const usage = `\n      type Route = QqQuery['routes'][0];\n\n      function validateGateway(route: Route) {\n          if (route.__typename === 'IPV4Route') {\n              console.log(route.ipv4Gateway)\n          } else {\n              console.log(route.ipv6Gateway)\n          }\n      }\n      `;\n\n      await validate(content, config, testSchema, usage);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1489,
                "column": 76
            },
            "line": 1489,
            "code": "    it('Should generate the correct __typename when using fragment over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ... on User {\n              id\n              name\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using both inline fragment and spread over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1518,
                "column": 99
            },
            "line": 1518,
            "code": "    it('Should generate the correct __typename when using both inline fragment and spread over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ... on User {\n              ...user\n            }\n          }\n        }\n\n        fragment user on User {\n          id\n          name\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment spread over type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1551,
                "column": 83
            },
            "line": 1551,
            "code": "    it('Should generate the correct __typename when using fragment spread over type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          id: ID!\n          name: String\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        query userQuery {\n          user {\n            ...user\n          }\n        }\n\n        fragment user on User {\n          id\n          name\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(content, config, testSchema);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct __typename when using fragment spread over union",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1582,
                "column": 84
            },
            "line": 1582,
            "code": "    it('Should generate the correct __typename when using fragment spread over union', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Error {\n          message: String!\n        }\n\n        union UserResult = User | Error\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment UserFragment on User {\n          id\n        }\n        query aaa {\n          user {\n            ...UserFragment\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      await validate(\n        content,\n        config,\n        testSchema,\n        `function test(q: AaaQuery) {\n        console.log(q.user.__typename === 'User' ? q.user.id : null);\n        console.log(q.user.__typename === 'Error' ? q.user.__typename : null);\n      }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid fragments intersection on different types (with usage) #2498",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1624,
                "column": 86
            },
            "line": 1624,
            "code": "    it('Should have valid fragments intersection on different types (with usage) #2498', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface User {\n          id: ID!\n        }\n\n        type Tom implements User {\n          id: ID!\n          foo: String!\n        }\n\n        type Jerry implements User {\n          id: ID!\n          bar: String!\n        }\n\n        type Query {\n          user: User\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment tom on Tom {\n          id\n          foo\n        }\n\n        fragment jerry on Jerry {\n          id\n          bar\n        }\n\n        fragment user on User {\n          ...tom\n          ...jerry\n        }\n\n        query userQuery {\n          user {\n            ...user\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      await validate(\n        content,\n        config,\n        testSchema,\n        `\n          function test(a: UserFragment) {\n              if (a.__typename === 'Tom') {\n                  console.log(a.foo);\n              } else if (a.__typename === 'Jerry') {\n                  console.log(a.bar);\n              }\n          }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should have valid __typename usage and split types according to that (with usage)",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1687,
                "column": 89
            },
            "line": 1687,
            "code": "    it('Should have valid __typename usage and split types according to that (with usage)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        scalar IPV4\n        scalar IPV6\n\n        type IPV4Route {\n          address: IPV4\n          gateway: IPV4\n        }\n\n        type IPV6Route {\n          address: IPV6\n          gateway: IPV6\n        }\n\n        union RouteUnion = IPV4Route | IPV6Route\n\n        type Query {\n          routes: [RouteUnion!]!\n        }\n      `);\n      const ast = parse(/* GraphQL */ `\n        fragment NetRoute on RouteUnion {\n          __typename\n          ... on IPV4Route {\n            ipv4Address: address\n            ipv4Gateway: gateway\n          }\n          ...test\n        }\n\n        fragment test on IPV6Route {\n          ipv6Address: address\n          ipv6Gateway: gateway\n        }\n\n        query QQ {\n          routes {\n            ...NetRoute\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const usage = `\n      type Route = QqQuery['routes'][0];\n\n      function validateGateway(route: Route) {\n          if (route.__typename === 'IPV4Route') {\n              console.log(route.ipv4Gateway)\n          } else {\n              console.log(route.ipv6Gateway)\n          }\n      }\n      `;\n\n      await validate(content, config, testSchema, usage);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with no other fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1750,
                "column": 86
            },
            "line": 1750,
            "code": "    it('Should support fragment spread correctly with simple type with no other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n          role\n        }\n\n        query me {\n          me {\n            ...UserFields\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { me?: Maybe<(\n            Pick<User, 'id' | 'username' | 'role'>\n            & { profile?: Maybe<Pick<Profile, 'age'>> }\n          )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with simple type with other fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1780,
                "column": 83
            },
            "line": 1780,
            "code": "    it('Should support fragment spread correctly with simple type with other fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            username\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type MeQuery = { me?: Maybe<(\n        Pick<User, 'username' | 'id'>\n        & { profile?: Maybe<Pick<Profile, 'age'>> }\n      )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support fragment spread correctly with multiple fragment spread",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1810,
                "column": 78
            },
            "line": 1810,
            "code": "    it('Should support fragment spread correctly with multiple fragment spread', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n        }\n\n        fragment UserProfile on User {\n          profile {\n            age\n          }\n        }\n\n        query me {\n          me {\n            ...UserFields\n            ...UserProfile\n            username\n          }\n        }\n      `);\n      const config = { skipTypename: false, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type MeQuery = (\n        { __typename?: 'Query' }\n        & { me?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'username' | 'id'>\n          & { profile?: Maybe<(\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        )> }\n      );\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type UserProfileFragment = (\n          { __typename?: 'User' }\n          & { profile?: Maybe<(\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type UserFieldsFragment = (\n          { __typename?: 'User' }\n          & Pick<User, 'id'>\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when using with interfaces with different type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1866,
                "column": 109
            },
            "line": 1866,
            "code": "    it('Should generate the correct intersection for fragments when using with interfaces with different type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type A implements Base {\n          id: ID!\n          x: Int!\n        }\n\n        type B implements Base {\n          id: ID!\n          y: Int!\n        }\n\n        type Query {\n          b: Base\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          b {\n            ...a\n            ...b\n          }\n        }\n\n        fragment a on A {\n          id\n          x\n        }\n\n        fragment b on B {\n          id\n          y\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { b?: Maybe<(\n          { __typename?: 'A' }\n          & Pick<A, 'id' | 'x'>\n        ) | (\n          { __typename?: 'B' }\n          & Pick<B, 'id' | 'y'>\n        )> }\n      );\n\n      export type AFragment = (\n        { __typename?: 'A' }\n        & Pick<A, 'id' | 'x'>\n      );\n\n      export type BFragment = (\n        { __typename?: 'B' }\n        & Pick<B, 'id' | 'y'>\n      );\n      `);\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when type implements 2 interfaces",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1935,
                "column": 96
            },
            "line": 1935,
            "code": "    it('Should generate the correct intersection for fragments when type implements 2 interfaces', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base1 {\n          foo: String!\n        }\n\n        interface Base2 {\n          bar: String!\n        }\n\n        type MyType implements Base1 & Base2 {\n          foo: String!\n          bar: String!\n          test: String!\n        }\n\n        type Query {\n          myType: MyType!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          myType {\n            ...a\n            ...b\n            ...c\n          }\n        }\n\n        fragment c on MyType {\n          test\n        }\n\n        fragment a on Base1 {\n          foo\n        }\n\n        fragment b on Base2 {\n          bar\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { myType: (\n          { __typename?: 'MyType' }\n          & Pick<MyType, 'foo' | 'bar' | 'test'>\n        ) }\n      );\n      `);\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate the correct intersection for fragments when using with interfaces with same type",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 1993,
                "column": 104
            },
            "line": 1993,
            "code": "    it('Should generate the correct intersection for fragments when using with interfaces with same type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type A implements Base {\n          id: ID!\n          x: Int!\n        }\n\n        type B implements Base {\n          id: ID!\n          y: Int!\n        }\n\n        type Query {\n          b: Base\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          b {\n            ...a\n            ...b\n          }\n        }\n\n        fragment a on A {\n          id\n        }\n\n        fragment b on A {\n          x\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type Unnamed_1_Query = (\n        { __typename?: 'Query' }\n        & { b?: Maybe<(\n          { __typename?: 'A' }\n          & Pick<A, 'id' | 'x'>\n        ) | { __typename?: 'B' }> }\n      );\n\n        export type AFragment = (\n          { __typename?: 'A' }\n          & Pick<A, 'id'>\n        );\n\n        export type BFragment = (\n          { __typename?: 'A' }\n          & Pick<A, 'x'>\n        );\n      `);\n      validateTs(mergeOutputs([content]), config);\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support interfaces correctly when used with inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2058,
                "column": 75
            },
            "line": 2058,
            "code": "    it('Should support interfaces correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n              metadata {\n                createdBy\n              }\n            }\n          }\n        }\n      `);\n\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type NotificationsQuery = (\n          { __typename?: 'Query' }\n          & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'text' | 'id'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'imageUrl' | 'id'>\n            & { metadata: (\n                { __typename?: 'ImageMetadata' }\n                & Pick<ImageMetadata, 'createdBy'>\n              ) }\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2101,
                "column": 70
            },
            "line": 2101,
            "code": "    it('Should support union correctly when used with inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          unionTest {\n            ... on User {\n              id\n            }\n\n            ... on Profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n            & { unionTest?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          ) | (\n            { __typename?: 'Profile' }\n            & Pick<Profile, 'age'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments on types implementing common interface",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2135,
                "column": 109
            },
            "line": 2135,
            "code": "    it('Should support union correctly when used with inline fragments on types implementing common interface', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          mixedNotifications {\n            ... on Notifiction {\n              id\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { mixedNotifications: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id' | 'text'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id' | 'imageUrl'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support union correctly when used with inline fragments on types implementing common interface and also other types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2173,
                "column": 130
            },
            "line": 2173,
            "code": "    it('Should support union correctly when used with inline fragments on types implementing common interface and also other types', async () => {\n      const ast = parse(/* GraphQL */ `\n        query unionTest {\n          search(term: \"a\") {\n            ... on User {\n              id\n            }\n\n            ... on Notifiction {\n              id\n            }\n\n            ... on TextNotification {\n              text\n            }\n\n            ... on ImageNotification {\n              imageUrl\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UnionTestQuery = (\n          { __typename?: 'Query' }\n          & { search: Array<(\n            { __typename?: 'TextNotification' }\n            & Pick<TextNotification, 'id' | 'text'>\n          ) | (\n            { __typename?: 'ImageNotification' }\n            & Pick<ImageNotification, 'id' | 'imageUrl'>\n          ) | (\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          )> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support merging identical fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2218,
                "column": 61
            },
            "line": 2218,
            "code": "    it('Should support merging identical fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type TestQuery = (\n          { notifications: Array<(\n            { id: string }\n            & { __typename?: 'TextNotification' | 'ImageNotification' }\n          )> }\n          & { __typename?: 'Query' }\n        );\n\n        export type NFragment = (\n          { id: string }\n          & { __typename?: 'TextNotification' | 'ImageNotification' }\n        );\n     `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for merged fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2254,
                "column": 78
            },
            "line": 2254,
            "code": "    it('Should support computing correct names for merged fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Notifiction {\n          id\n          ... on TextNotification {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        type N_TextNotification_Fragment = (\n          { text: string, id: string }\n          & { __typename?: 'TextNotification' }\n        );\n\n        type N_ImageNotification_Fragment = (\n          { id: string }\n          & { __typename?: 'ImageNotification' }\n        );\n\n        export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for large merged fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2284,
                "column": 84
            },
            "line": 2284,
            "code": "    it('Should support computing correct names for large merged fragment union types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type B implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type C implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type D implements Node {\n          id: ID!\n          text: String!\n        }\n\n        type E implements Node {\n          id: ID!\n          text: String!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        fragment N on Node {\n          id\n          ... on A {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n         type N_A_Fragment = (\n           { text: string, id: string }\n           & { __typename?: 'A' }\n         );\n\n         type N_ZhJjUzpMTyh98zugnx0IKwiLetPNjV8KYbSlmpAeuu_Fragment = (\n           { id: string }\n           & { __typename?: 'B' | 'C' | 'D' | 'E' }\n         );\n\n         export type NFragment = N_A_Fragment | N_ZhJjUzpMTyh98zugnx0IKwiLetPNjV8KYbSlmpAeuu_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should not create empty types when merging fragment union types",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2345,
                "column": 71
            },
            "line": 2345,
            "code": "    it('Should not create empty types when merging fragment union types', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Query {\n          notifications {\n            ... on TextNotification {\n              text\n            }\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       export type NFragment = (\n         { notifications: Array<(\n           { text: string }\n           & { __typename?: 'TextNotification' }\n         ) | { __typename?: 'ImageNotification' }> }\n         & { __typename?: 'Query' }\n       );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support merging identical fragment union types with skipTypename",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2372,
                "column": 79
            },
            "line": 2372,
            "code": "    it('Should support merging identical fragment union types with skipTypename', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, skipTypename: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type TestQuery = { notifications: Array<{ id: string }> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support computing correct names for merged fragment union types with skipTypename",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2397,
                "column": 96
            },
            "line": 2397,
            "code": "    it('Should support computing correct names for merged fragment union types with skipTypename', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment N on Notifiction {\n          id\n          ... on TextNotification {\n            text\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, skipTypename: true, mergeFragmentTypes: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       type N_TextNotification_Fragment = { text: string, id: string };\n\n       type N_ImageNotification_Fragment = { id: string };\n\n       export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Ignores merging when enabled alongside inline fragment masking",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2421,
                "column": 70
            },
            "line": 2421,
            "code": "    it('Ignores merging when enabled alongside inline fragment masking', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          notifications {\n            ...N\n          }\n        }\n\n        fragment N on Notifiction {\n          id\n        }\n      `);\n      const config = { preResolveTypes: true, mergeFragmentTypes: true, inlineFragmentTypes: 'mask' } as const;\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n       export type TestQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n       export type TestQuery = { __typename?: 'Query', notifications: Array<(\n        { __typename?: 'TextNotification' }\n        & { ' $fragmentRefs': { 'N_TextNotification_Fragment': N_TextNotification_Fragment } }\n       ) | (\n        { __typename?: 'ImageNotification' }\n        & { ' $fragmentRefs': { 'N_ImageNotification_Fragment': N_ImageNotification_Fragment } }\n       )> };\n\n       type N_TextNotification_Fragment = { __typename?: 'TextNotification', id: string } & { ' $fragmentName': 'N_TextNotification_Fragment' };\n\n       type N_ImageNotification_Fragment = { __typename?: 'ImageNotification', id: string } & { ' $fragmentName': 'N_ImageNotification_Fragment' };\n\n       export type NFragment = N_TextNotification_Fragment | N_ImageNotification_Fragment;\n     `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should support inline fragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2459,
                "column": 39
            },
            "line": 2459,
            "code": "    it('Should support inline fragments', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            ... on User {\n              username\n              profile {\n                age\n              }\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n      expect(content).toBeSimilarStringTo(`\n        export type CurrentUserQuery = { me?: Maybe<(\n            Pick<User, 'username' | 'id'>\n            & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query on GitHub schema",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2487,
                "column": 80
            },
            "line": 2487,
            "code": "    it('Should build a basic selection set based on basic query on GitHub schema', async () => {\n      const ast = parse(/* GraphQL */ `\n        query me($repoFullName: String!) {\n          currentUser {\n            login\n            html_url\n          }\n          entry(repoFullName: $repoFullName) {\n            id\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(gitHuntSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type MeQueryVariables = Exact<{\n          repoFullName: Scalars['String'];\n        }>;`\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { currentUser?: Maybe<Pick<User, 'login' | 'html_url'>>, entry?: Maybe<(\n          Pick<Entry, 'id' | 'createdAt'>\n          & { postedBy: Pick<User, 'login' | 'html_url'> }\n        )> };\n      `);\n      await validate(content, config, gitHuntSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query on GitHub schema with preResolveTypes=true",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2523,
                "column": 106
            },
            "line": 2523,
            "code": "    it('Should build a basic selection set based on basic query on GitHub schema with preResolveTypes=true', async () => {\n      const ast = parse(/* GraphQL */ `\n        query me($repoFullName: String!) {\n          currentUser {\n            login\n            html_url\n          }\n          entry(repoFullName: $repoFullName) {\n            id\n            postedBy {\n              login\n              html_url\n            }\n            createdAt\n          }\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(gitHuntSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type MeQuery = { __typename?: 'Query', currentUser?: { __typename?: 'User', login: string, html_url: string } | null, entry?: { __typename?: 'Entry', id: number, createdAt: number, postedBy: { __typename?: 'User', login: string, html_url: string } } | null };\n      `);\n      await validate(content, config, gitHuntSchema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should produce valid output with preResolveTypes=true and enums",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2551,
                "column": 71
            },
            "line": 2551,
            "code": "    it('Should produce valid output with preResolveTypes=true and enums', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          info {\n            ...information\n          }\n        }\n\n        fragment information on Information {\n          entries {\n            id\n            value\n          }\n        }\n      `);\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Information {\n          entries: [Information_Entry!]!\n        }\n\n        enum Information_EntryType {\n          NAME\n          ADDRESS\n        }\n\n        type Information_Entry {\n          id: Information_EntryType!\n          value: String\n        }\n\n        type Query {\n          info: Information\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const o = await validate(content, config, testSchema);\n      expect(o).toContain(`export enum Information_EntryType {`);\n      expect(o).toContain(`__typename?: 'Information_Entry', id: Information_EntryType,`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should produce valid output with preResolveTypes=true and enums with prefixes set",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2595,
                "column": 89
            },
            "line": 2595,
            "code": "    it('Should produce valid output with preResolveTypes=true and enums with prefixes set', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test($e: Information_EntryType!) {\n          info {\n            ...information\n          }\n          infoArgTest(e: $e) {\n            ...information\n          }\n        }\n\n        fragment information on Information {\n          entries {\n            id\n            value\n          }\n        }\n      `);\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Information {\n          entries: [Information_Entry!]!\n        }\n\n        enum Information_EntryType {\n          NAME\n          ADDRESS\n        }\n\n        type Information_Entry {\n          id: Information_EntryType!\n          value: String\n        }\n\n        type Query {\n          infoArgTest(e: Information_EntryType!): Information\n          info: Information\n        }\n      `);\n      const config = { preResolveTypes: true, typesPrefix: 'I', enumPrefix: false };\n      const { content } = await plugin(testSchema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      const o = await validate(content, config, testSchema);\n      expect(o).toBeSimilarStringTo(` export type ITestQueryVariables = Exact<{\n        e: Information_EntryType;\n      }>;`);\n      expect(o).toContain(`export type IQuery = {`);\n      expect(o).toContain(`export enum Information_EntryType {`);\n      expect(o).toContain(`__typename?: 'Information_Entry', id: Information_EntryType,`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2647,
                "column": 63
            },
            "line": 2647,
            "code": "    it('Should build a basic selection set based on basic query', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type DummyQuery = Pick<Query, 'dummy'>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on basic query with field aliasing for basic scalar",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2664,
                "column": 100
            },
            "line": 2664,
            "code": "    it('Should build a basic selection set based on basic query with field aliasing for basic scalar', async () => {\n      const ast = parse(/* GraphQL */ `\n        query dummy {\n          customName: dummy\n          customName2: dummyWithType {\n            age\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type DummyQuery = (\n          { customName: Query['dummy'] }\n          & { customName2?: Maybe<Pick<Profile, 'age'>> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build a basic selection set based on a query with inner fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Selection Set"
            ],
            "updatePoint": {
                "line": 2687,
                "column": 77
            },
            "line": 2687,
            "code": "    it('Should build a basic selection set based on a query with inner fields', async () => {\n      const ast = parse(/* GraphQL */ `\n        query currentUser {\n          me {\n            id\n            username\n            role\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type CurrentUserQuery = { me?: Maybe<(\n          Pick<User, 'id' | 'username' | 'role'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should build fragment definition correctly - with name and selection set",
            "suites": [
                "TypeScript Operations Plugin",
                "Fragment Definition"
            ],
            "updatePoint": {
                "line": 2716,
                "column": 80
            },
            "line": 2716,
            "code": "    it('Should build fragment definition correctly - with name and selection set', async () => {\n      const ast = parse(/* GraphQL */ `\n        fragment UserFields on User {\n          id\n          username\n          profile {\n            age\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserFieldsFragment = (\n          Pick<User, 'id' | 'username'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        );\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Mutation correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2742,
                "column": 40
            },
            "line": 2742,
            "code": "    it('Should detect Mutation correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        mutation login {\n          login(username: \"1\", password: \"2\") {\n            id\n            username\n            profile {\n              age\n            }\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type LoginMutation = { login?: Maybe<(\n          Pick<User, 'id' | 'username'>\n          & { profile?: Maybe<Pick<Profile, 'age'>> }\n        )> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Query correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2768,
                "column": 37
            },
            "line": 2768,
            "code": "    it('Should detect Query correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query test {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestQuery = Pick<Query, 'dummy'>;\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should detect Subscription correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2785,
                "column": 44
            },
            "line": 2785,
            "code": "    it('Should detect Subscription correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        subscription test {\n          userCreated {\n            id\n          }\n        }\n      `);\n      const config = { skipTypename: true, preResolveTypes: false };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n        export type TestSubscription = { userCreated?: Maybe<Pick<User, 'id'>> };\n      `);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle operation variables correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2804,
                "column": 51
            },
            "line": 2804,
            "code": "    it('Should handle operation variables correctly', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery(\n          $username: String\n          $email: String\n          $password: String!\n          $input: InputType\n          $mandatoryInput: InputType!\n          $testArray: [String]\n          $requireString: [String]!\n          $innerRequired: [String!]!\n        ) {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQueryQueryVariables = Exact<{\n          username?: InputMaybe<Scalars['String']>;\n          email?: InputMaybe<Scalars['String']>;\n          password: Scalars['String'];\n          input?: InputMaybe<InputType>;\n          mandatoryInput: InputType;\n          testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>>;\n          requireString: Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>;\n          innerRequired: Array<Scalars['String']> | Scalars['String'];\n        }>;`\n      );\n      await validate(content, config, schema);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle operation variables correctly when they use custom scalars",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2839,
                "column": 80
            },
            "line": 2839,
            "code": "    it('Should handle operation variables correctly when they use custom scalars', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery($test: DateTime) {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type TestQueryQueryVariables = Exact<{\n          test?: InputMaybe<Scalars['DateTime']>;\n        }>;`\n      );\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should create empty variables when there are no operation variables",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2858,
                "column": 75
            },
            "line": 2858,
            "code": "    it('Should create empty variables when there are no operation variables', async () => {\n      const ast = parse(/* GraphQL */ `\n        query testQuery {\n          dummy\n        }\n      `);\n      const config = { skipTypename: true };\n      const { content } = await plugin(schema, [{ location: 'test-file.ts', document: ast }], config, {\n        outputFile: '',\n      });\n\n      expect(content).toBeSimilarStringTo(`export type TestQueryQueryVariables = Exact<{ [key: string]: never; }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "avoid duplicates - each type name should be unique",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2873,
                "column": 58
            },
            "line": 2873,
            "code": "    it('avoid duplicates - each type name should be unique', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type DeleteMutation {\n          deleted: Boolean!\n        }\n        type UpdateMutation {\n          updated: Boolean!\n        }\n        union MessageMutationType = DeleteMutation | UpdateMutation\n        type Query {\n          dummy: String\n        }\n        type Mutation {\n          mutation(message: String!, type: String!): MessageMutationType!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        mutation SubmitMessage($message: String!) {\n          mutation(message: $message) {\n            ... on DeleteMutation {\n              deleted\n            }\n            ... on UpdateMutation {\n              updated\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type SubmitMessageMutation = (\n          { __typename?: 'Mutation' }\n          & { mutation: (\n            { __typename?: 'DeleteMutation' }\n            & Pick<DeleteMutation, 'deleted'>\n          ) | (\n            { __typename?: 'UpdateMutation' }\n          & Pick<UpdateMutation, 'updated'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should use __typename in fragments when requested",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2925,
                "column": 57
            },
            "line": 2925,
            "code": "    it('should use __typename in fragments when requested', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Post {\n          post {\n            ... on Post {\n              __typename\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type PostQuery = (\n          { __typename?: 'Query' }\n          & { post: { __typename: 'Post' } }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (__schema)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 2961,
                "column": 52
            },
            "line": 2961,
            "code": "    it('should handle introspection types (__schema)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __schema {\n            queryType {\n              fields {\n                name\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type InfoQuery = (\n          { __typename?: 'Query' }\n          & { __schema: (\n            { __typename?: '__Schema' }\n            & { queryType: (\n              { __typename?: '__Type' }\n              & { fields?: Maybe<Array<(\n                { __typename?: '__Field' }\n                & Pick<__Field, 'name'>\n              )>> }\n            ) }\n          ) }\n        );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (__type)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3007,
                "column": 50
            },
            "line": 3007,
            "code": "    it('should handle introspection types (__type)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type InfoQuery = (\n          { __typename?: 'Query' }\n          & { __type?: Maybe<(\n            { __typename?: '__Type' }\n            & Pick<__Type, 'name'>\n            & { fields?: Maybe<Array<(\n              { __typename?: '__Field' }\n              & Pick<__Field, 'name'>\n              & { type: (\n                { __typename?: '__Type' }\n                & Pick<__Type, 'name' | 'kind'>\n              ) }\n            )>> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should handle introspection types (like __TypeKind)",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3059,
                "column": 59
            },
            "line": 3059,
            "code": "    it('should handle introspection types (like __TypeKind)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const coreContent = await tsPlugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const pluginContent = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const content = mergeOutputs([coreContent, pluginContent]);\n\n      expect(content).toBeSimilarStringTo(`\n      /** An enum describing what kind of type a given \\`__Type\\` is. */\n      export enum __TypeKind {\n        /** Indicates this type is a scalar. */\n        Scalar = 'SCALAR',\n        /** Indicates this type is an object. \\`fields\\` and \\`interfaces\\` are valid fields. */\n        Object = 'OBJECT',\n        /** Indicates this type is an interface. \\`fields\\`, \\`interfaces\\`, and \\`possibleTypes\\` are valid fields. */\n        Interface = 'INTERFACE',\n        /** Indicates this type is a union. \\`possibleTypes\\` is a valid field. */\n        Union = 'UNION',\n        /** Indicates this type is an enum. \\`enumValues\\` is a valid field. */\n        Enum = 'ENUM',\n        /** Indicates this type is an input object. \\`inputFields\\` is a valid field. */\n        InputObject = 'INPUT_OBJECT',\n        /** Indicates this type is a list. \\`ofType\\` is a valid field. */\n        List = 'LIST',\n        /** Indicates this type is a non-null. \\`ofType\\` is a valid field. */\n        NonNull = 'NON_NULL'\n      }\n      `);\n\n      validateTs(content);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate correctly when using enums and typesPrefix",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3128,
                "column": 66
            },
            "line": 3128,
            "code": "    it('Should generate correctly when using enums and typesPrefix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum Access {\n          Read\n          Write\n          All\n        }\n        type User {\n          access: Access\n        }\n        input Filter {\n          match: String!\n        }\n        type Query {\n          users(filter: Filter!): [User]\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query users($filter: Filter!) {\n          users(filter: $filter) {\n            access\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { typesPrefix: 'PREFIX_', preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type PREFIX_UsersQueryVariables = Exact<{\n          filter: PREFIX_Filter;\n        }>;\n      `);\n      expect(content).toBeSimilarStringTo(`\n        export type PREFIX_UsersQuery = (\n          { __typename?: 'Query' }\n          & { users?: Maybe<Array<Maybe<(\n            { __typename?: 'User' }\n            & Pick<PREFIX_User, 'access'>\n          )>>> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should make arguments optional when there is a default value",
            "suites": [
                "TypeScript Operations Plugin",
                "Operation Definition"
            ],
            "updatePoint": {
                "line": 3178,
                "column": 68
            },
            "line": 3178,
            "code": "    it('Should make arguments optional when there is a default value', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          name: String!\n        }\n        type Query {\n          users(reverse: Boolean!): [User!]!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query users($reverse: Boolean = true) {\n          users(reverse: $reverse) {\n            name\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UsersQueryVariables = Exact<{\n          reverse?: InputMaybe<Scalars['Boolean']>;\n        }>;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should generate correct types for union that returns interface types",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3213,
                "column": 76
            },
            "line": 3213,
            "code": "    it('should generate correct types for union that returns interface types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n        }\n        type ComplexError implements Error {\n          message: String!\n          additionalInfo: String!\n        }\n\n        type FieldResultSuccess {\n          someValue: Boolean!\n        }\n\n        union FieldResult = Error1 | Error2 | ComplexError | FieldResultSuccess\n\n        type Query {\n          field: FieldResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query field {\n          field {\n            __typename\n            ... on Error {\n              message\n            }\n            ... on ComplexError {\n              additionalInfo\n            }\n            ... on FieldResultSuccess {\n              someValue\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type FieldQuery = (\n        { __typename?: 'Query' }\n        & { field: (\n          { __typename: 'Error1' }\n          & Pick<Error1, 'message'>\n        ) | (\n          { __typename: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename: 'ComplexError' }\n          & Pick<ComplexError, 'message' | 'additionalInfo'>\n        ) | (\n          { __typename: 'FieldResultSuccess' }\n          & Pick<FieldResultSuccess, 'someValue'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "should generate correct types for union that returns interface types (variant __typename in fragment)",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3288,
                "column": 109
            },
            "line": 3288,
            "code": "    it('should generate correct types for union that returns interface types (variant __typename in fragment)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n        }\n        type ComplexError implements Error {\n          message: String!\n          additionalInfo: String!\n        }\n\n        type FieldResultSuccess {\n          someValue: Boolean!\n        }\n\n        union FieldResult = Error1 | Error2 | ComplexError | FieldResultSuccess\n\n        type Query {\n          field: FieldResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query field {\n          field {\n            ... on Error {\n              __typename\n              message\n            }\n            ... on ComplexError {\n              additionalInfo\n            }\n            ... on FieldResultSuccess {\n              someValue\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n        export type FieldQuery = (\n          { __typename?: 'Query' }\n          & { field: (\n            { __typename: 'Error1' }\n            & Pick<Error1, 'message'>\n          ) | (\n            { __typename: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename: 'ComplexError' }\n            & Pick<ComplexError, 'message' | 'additionalInfo'>\n          ) | (\n            { __typename?: 'FieldResultSuccess' }\n            & Pick<FieldResultSuccess, 'someValue'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "interface with same field names",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3362,
                "column": 39
            },
            "line": 3362,
            "code": "    it('interface with same field names', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        type A implements Node {\n          id: ID!\n          a: String\n        }\n\n        type B implements Node {\n          id: ID!\n          a: Boolean\n        }\n\n        type Query {\n          node: Node\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query something {\n          node {\n            ... on A {\n              a\n            }\n\n            ... on B {\n              a\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type SomethingQuery = (\n          { __typename?: 'Query' }\n          & { node?: Maybe<(\n            { __typename?: 'A' }\n            & Pick<A, 'a'>\n          ) | (\n            { __typename?: 'B' }\n            & Pick<B, 'a'>\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "union returning single interface types",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3419,
                "column": 46
            },
            "line": 3419,
            "code": "    it('union returning single interface types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n        type Query {\n          user: UserResult\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n            ... on Error {\n              message\n            }\n            ... on Error3 {\n              info {\n                message\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id' | 'login'>\n          ) | (\n            { __typename?: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename?: 'Error3' }\n            & Pick<Error3, 'message'>\n            & { info?: Maybe<(\n              { __typename?: 'AdditionalInfo' }\n              & Pick<AdditionalInfo, 'message'>\n            )> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "duplicated fragment on type includes combined types only once",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3497,
                "column": 69
            },
            "line": 3497,
            "code": "    it('duplicated fragment on type includes combined types only once', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n        type Query {\n          user: UserResult\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n            ... on Error {\n              message\n              ... on Error3 {\n                info {\n                  message\n                  message2\n                }\n              }\n            }\n            ... on Error {\n              ... on Error3 {\n                info {\n                  message\n                  message2\n                }\n              }\n            }\n            ... on Error3 {\n              info {\n                message\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user?: Maybe<(\n            { __typename?: 'User' }\n            & Pick<User, 'id' | 'login'>\n          ) | (\n            { __typename?: 'Error2' }\n            & Pick<Error2, 'message'>\n          ) | (\n            { __typename?: 'Error3' }\n            & Pick<Error3, 'message'>\n            & { info?: Maybe<(\n                { __typename?: 'AdditionalInfo' }\n                & Pick<AdditionalInfo, 'message' | 'message2'>\n              )> }\n          )> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should merge inline fragments fields correctly",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3590,
                "column": 54
            },
            "line": 3590,
            "code": "    it('Should merge inline fragments fields correctly', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ... on User {\n              id\n            }\n\n            ... on User {\n              login\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const o = await validate(content, {}, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should merge inline fragments fields correctly with fragment spread over the same type",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3638,
                "column": 94
            },
            "line": 3638,
            "code": "    it('Should merge inline fragments fields correctly with fragment spread over the same type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ... on User {\n              id\n            }\n\n            ...test\n          }\n        }\n\n        fragment test on User {\n          login\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const o = await validate(content, {}, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) }\n      );`);\n\n      expect(o).toBeSimilarStringTo(`export type TestFragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'login'>\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3692,
                "column": 88
            },
            "line": 3692,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(\n        content,\n        {},\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([content])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'login' | 'id'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );`);\n\n      expect(output).toBeSimilarStringTo(`\n      export type AdditionalInfoFragment = (\n        { __typename?: 'AdditionalInfo' }\n        & Pick<AdditionalInfo, 'message'>\n      );\n\n      type UserResult1_User_Fragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'id'>\n      );\n\n      type UserResult1_Error2_Fragment = { __typename?: 'Error2' };\n\n      type UserResult1_Error3_Fragment = (\n        { __typename?: 'Error3' }\n        & { info?: Maybe<(\n          { __typename?: 'AdditionalInfo' }\n          & Pick<AdditionalInfo, 'message2'>\n        )> }\n      );\n\n      export type UserResult1Fragment = UserResult1_User_Fragment | UserResult1_Error2_Fragment | UserResult1_Error3_Fragment;\n\n      type UserResult_User_Fragment = (\n        { __typename?: 'User' }\n        & Pick<User, 'id'>\n      );\n\n      type UserResult_Error2_Fragment = (\n        { __typename?: 'Error2' }\n        & Pick<Error2, 'message'>\n      );\n\n      type UserResult_Error3_Fragment = { __typename?: 'Error3' };\n\n      export type UserResultFragment = UserResult_User_Fragment | UserResult_Error2_Fragment | UserResult_Error3_Fragment;`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3856,
                "column": 115
            },
            "line": 3856,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(\n        content,\n        config,\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'login'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4216 - handle fragments against unions and interfaces with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 3984,
                "column": 89
            },
            "line": 3984,
            "code": "    it('#4216 - handle fragments against unions and interfaces with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Searchable!]\n        }\n\n        interface Concept {\n          id: String\n        }\n\n        type Dimension implements Concept {\n          id: String\n        }\n\n        type DimValue {\n          dimension: Dimension\n          value: String!\n        }\n\n        union Searchable = Dimension | DimValue\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        fragment SearchableFragment on Searchable {\n          ...SearchConceptFragment\n          ...SearchDimValueFragment\n        }\n\n        fragment SearchConceptFragment on Concept {\n          id\n        }\n\n        fragment SearchDimValueFragment on DimValue {\n          dimension {\n            ...SearchConceptFragment\n          }\n          value\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(content, config, testSchema);\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Searchable>>;\n        };\n\n        export type Concept = {\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type Dimension = Concept & {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type DimValue = {\n          __typename?: 'DimValue';\n          dimension?: Maybe<Dimension>;\n          value: Scalars['String'];\n        };\n\n        export type Searchable = Dimension | DimValue;\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = (\n          { __typename?: 'Query' }\n          & { search?: Maybe<Array<(\n            { __typename?: 'Dimension' }\n            & Pick<Dimension, 'id'>\n          ) | (\n            { __typename?: 'DimValue' }\n            & Pick<DimValue, 'value'>\n            & { dimension?: Maybe<(\n              { __typename?: 'Dimension' }\n              & Pick<Dimension, 'id'>\n            )> }\n          )>> }\n        );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Handles fragments across files with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4100,
                "column": 65
            },
            "line": 4100,
            "code": "    it('Handles fragments across files with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Dimension!]\n        }\n\n        type Dimension {\n          id: String\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        # Unreferenced fragments are still dropped\n        fragment ExtraFragment on Dimension {\n          id\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment SearchableFragment on Dimension {\n          id\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        flattenGeneratedTypesIncludeFragments: true,\n        preResolveTypes: true,\n      };\n\n      const { content } = await plugin(\n        testSchema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        config,\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(content, config, testSchema);\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Dimension>>;\n        };\n\n        export type Dimension = {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n        export type SearchableFragmentFragment = { __typename?: 'Dimension', id?: string | null };\n\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = { __typename?: 'Query', search?: Array<{ __typename?: 'Dimension', id?: string | null }> | null };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Drops fragments with flattenGeneratedTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4185,
                "column": 50
            },
            "line": 4185,
            "code": "    it('Drops fragments with flattenGeneratedTypes', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          search: [Dimension!]\n        }\n\n        type Dimension {\n          id: String\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query SearchPopular {\n          search {\n            ...SearchableFragment\n          }\n        }\n\n        # Unreferenced fragments should be dropped by flattenGeneratedTypes\n        fragment ExtraFragment on Dimension {\n          id\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        # Referenced fragments should be dropped by flattenGeneratedTypes\n        fragment SearchableFragment on Dimension {\n          id\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        flattenGeneratedTypesIncludeFragments: false,\n        preResolveTypes: true,\n      };\n\n      const { content } = await plugin(\n        testSchema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        config,\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      const output = await validate(content, config, testSchema);\n\n      expect(output).toBeSimilarStringTo(`\n        export type Maybe<T> = T | null;\n        export type InputMaybe<T> = Maybe<T>;\n        export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n        export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n        export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n        /** All built-in and custom scalars, mapped to their actual values */\n        export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n        };\n\n        export type Query = {\n          __typename?: 'Query';\n          search?: Maybe<Array<Dimension>>;\n        };\n\n        export type Dimension = {\n          __typename?: 'Dimension';\n          id?: Maybe<Scalars['String']>;\n        };\n\n        export type SearchPopularQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type SearchPopularQuery = { __typename?: 'Query', search?: Array<{ __typename?: 'Dimension', id?: string | null }> | null };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should add operation name when addOperationExport is true",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4270,
                "column": 65
            },
            "line": 4270,
            "code": "    it('Should add operation name when addOperationExport is true', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n          login: String!\n        }\n\n        type Query {\n          user: User!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserIdQuery {\n          user {\n            id\n          }\n        }\n        query UserLoginQuery {\n          user {\n            login\n          }\n        }\n      `);\n\n      const config = {\n        addOperationExport: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserIdQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type UserIdQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id'>\n        ) }\n      );\n\n      export type UserLoginQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type UserLoginQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'login'>\n        ) }\n      );\n\n      export declare const UserIdQuery: import(\"graphql\").DocumentNode;\n      export declare const UserLoginQuery: import(\"graphql\").DocumentNode;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes and directives",
            "suites": [
                "TypeScript Operations Plugin",
                "Union & Interfaces"
            ],
            "updatePoint": {
                "line": 4330,
                "column": 130
            },
            "line": 4330,
            "code": "    it('Should handle union selection sets with both FragmentSpreads and InlineFragments with flattenGeneratedTypes and directives', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Error {\n          message: String!\n        }\n        type Error1 implements Error {\n          message: String!\n        }\n        type Error2 implements Error {\n          message: String!\n        }\n        type Error3 implements Error {\n          message: String!\n          info: AdditionalInfo\n        }\n        type AdditionalInfo {\n          message: String!\n          message2: String!\n        }\n        type User {\n          id: ID!\n          login: String!\n          test: String\n          test2: String\n        }\n\n        union UserResult = User | Error2 | Error3\n\n        type Query {\n          user: UserResult!\n        }\n\n        directive @client on FIELD\n        directive @connection on FIELD\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query UserQuery {\n          user {\n            ...UserResult\n            ...UserResult1\n            ... on User {\n              login\n              test @client\n            }\n            ... on Error3 {\n              message\n              info {\n                ...AdditionalInfo\n              }\n            }\n          }\n        }\n\n        fragment AdditionalInfo on AdditionalInfo {\n          message\n        }\n\n        fragment UserResult1 on UserResult {\n          ... on User {\n            id\n            test2 @connection\n          }\n          ... on Error3 {\n            info {\n              message2\n            }\n          }\n        }\n\n        fragment UserResult on UserResult {\n          ... on User {\n            id\n          }\n          ... on Error2 {\n            message\n          }\n        }\n      `);\n\n      const config = {\n        flattenGeneratedTypes: true,\n        preResolveTypes: false,\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      const output = await validate(\n        content,\n        config,\n        testSchema,\n        `\n        function t(q: UserQueryQuery) {\n            if (q.user) {\n                if (q.user.__typename === 'User') {\n                    if (q.user.id) {\n                        const u = q.user.login;\n                    }\n                }\n                if (q.user.__typename === 'Error2') {\n                    console.log(q.user.message);\n                }\n                if (q.user.__typename === 'Error3') {\n                    if (q.user.info) {\n                        console.log(q.user.info.__typename)\n                    }\n                }\n            }\n        }`\n      );\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toBeSimilarStringTo(`\n      export type UserQueryQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & Pick<User, 'id' | 'test2' | 'login' | 'test'>\n        ) | (\n          { __typename?: 'Error2' }\n          & Pick<Error2, 'message'>\n        ) | (\n          { __typename?: 'Error3' }\n          & Pick<Error3, 'message'>\n          & { info?: Maybe<(\n            { __typename?: 'AdditionalInfo' }\n            & Pick<AdditionalInfo, 'message2' | 'message'>\n          )> }\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4212 - Should merge TS arrays in a more elegant way",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4467,
                "column": 60
            },
            "line": 4467,
            "code": "    it('#4212 - Should merge TS arrays in a more elegant way', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Item {\n          id: ID!\n          name: String!\n        }\n\n        type Object {\n          items: [Item!]!\n        }\n\n        type Query {\n          obj: Object\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment Object1 on Object {\n          items {\n            id\n          }\n        }\n\n        fragment Object2 on Object {\n          items {\n            name\n          }\n        }\n\n        fragment CombinedObject on Object {\n          ...Object1\n          ...Object2\n        }\n\n        query test {\n          obj {\n            ...CombinedObject\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      await validate(\n        content,\n        {},\n        testSchema,\n        `\n          function test (t: TestQuery) {\n            for (const item of t.obj!.items) {\n              console.log(item.id, item.name, item.__typename);\n            }\n          }\n      `\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5422 - Error when interface doesnt have implemeting types",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4531,
                "column": 66
            },
            "line": 4531,
            "code": "    it('#5422 - Error when interface doesnt have implemeting types', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface A {\n          a: String!\n        }\n\n        type Query {\n          test: A\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query test {\n          test {\n            a\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).not.toContain(`Maybe<>`);\n      expect(content).toContain(`Maybe<never>`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4389 - validate issues with interfaces",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4563,
                "column": 47
            },
            "line": 4563,
            "code": "    it('#4389 - validate issues with interfaces', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface A {\n          a: String!\n        }\n\n        interface B implements A {\n          a: String!\n          b: String\n        }\n\n        type C implements B {\n          a: String!\n          b: String\n          c: String!\n        }\n\n        type Query {\n          foo: C\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query {\n          foo {\n            ... on A {\n              a\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toContain(`{ foo?: Maybe<{ __typename?: 'C' }> }`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5001 - incorrect output with typeSuffix",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4606,
                "column": 48
            },
            "line": 4606,
            "code": "    it('#5001 - incorrect output with typeSuffix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n          }\n        }\n      `);\n\n      const config = {\n        typesSuffix: 'Type',\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).not.toContain('UserTypeQueryVariablesType');\n      expect(content).not.toContain('UserTypeQueryType');\n      expect(content).toContain('UserQueryVariablesType');\n      expect(content).toContain('UserQueryType');\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3064 - fragments over interfaces causes issues with fields",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4643,
                "column": 67
            },
            "line": 4643,
            "code": "    it('#3064 - fragments over interfaces causes issues with fields', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Venue {\n          id: String!\n          name: String!\n        }\n\n        type GPSPosition {\n          lat: Float!\n          lng: Float!\n        }\n\n        interface VenueWithPosition {\n          id: String!\n          gpsPosition: GPSPosition!\n        }\n\n        type Hotel implements VenueWithPosition & Venue {\n          id: String!\n          gpsPosition: GPSPosition!\n          name: String!\n        }\n\n        type Transport implements Venue {\n          id: String!\n          name: String!\n        }\n\n        type Query {\n          hotel: Hotel!\n          transport: Transport!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment venue on Venue {\n          id\n          ... on VenueWithPosition {\n            gpsPosition {\n              lat\n              lng\n            }\n          }\n        }\n\n        query q {\n          hotel {\n            ...venue\n          }\n          transport {\n            ...venue\n          }\n        }\n      `);\n\n      const config = {};\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toMatchSnapshot();\n\n      const result = await validate(\n        content,\n        {},\n        testSchema,\n        `function test(q: QQuery) {\n        if (q.hotel) {\n            const t1 = q.hotel.gpsPosition.lat\n        }\n\n        if (q.transport) {\n            const t2 = q.transport.id;\n        }\n    }`\n      );\n      expect(mergeOutputs([result])).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2916 - Missing import prefix with preResolveTypes: true and near-operation-file preset",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4723,
                "column": 95
            },
            "line": 4723,
            "code": "    it('#2916 - Missing import prefix with preResolveTypes: true and near-operation-file preset', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        enum Department {\n          Direction\n          Development\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n          department: Department!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n            dep: department\n          }\n        }\n      `);\n\n      const config = {\n        skipTypename: true,\n        preResolveTypes: true,\n        namespacedImportName: 'Types',\n      };\n\n      const { content } = await plugin(testSchema, [{ location: '', document: query }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toContain(`dep: Types.Department`);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2699 - Issues with multiple interfaces and unions",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4767,
                "column": 58
            },
            "line": 4767,
            "code": "    it('#2699 - Issues with multiple interfaces and unions', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          id: ID!\n        }\n\n        scalar DateTime\n\n        interface Element {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n        }\n\n        interface Entity {\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type EntityBrandData {\n          active: Boolean!\n          browsable: Boolean!\n          description: String!\n          alternateTitle: String\n          title: String!\n        }\n\n        type Query {\n          node(id: ID!): Node!\n        }\n\n        type Company implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type Theater implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type Movie implements Element & Node & Entity {\n          active: Boolean!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n\n        type User implements Element & Node & Entity {\n          active: Boolean!\n          name: String!\n          createdAt: DateTime!\n          createdBy: User\n          updatedAt: DateTime!\n          updatedBy: User\n          id: ID!\n          brandData(brand: ID!): EntityBrandData\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query getEntityBrandData($gid: ID!, $brand: ID!) {\n          node(gid: $gid) {\n            __typename\n            id\n            ... on Entity {\n              ...EntityBrandData\n            }\n            ... on Element {\n              ...ElementMetadata\n            }\n            ... on Company {\n              active\n            }\n            ... on Theater {\n              active\n            }\n          }\n        }\n\n        fragment EntityBrandData on Entity {\n          brandData(brand: $brand) {\n            active\n            browsable\n            title\n            alternateTitle\n            description\n          }\n        }\n\n        fragment ElementMetadata on Element {\n          createdAt\n          createdBy {\n            id\n            name\n          }\n          updatedAt\n          updatedBy {\n            id\n            name\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(mergeOutputs([content])).toMatchSnapshot();\n\n      await validate(\n        content,\n        {},\n        testSchema,\n        `\nfunction test(q: GetEntityBrandDataQuery): void {\n  const typeName: 'Company' | 'Theater' | 'User' | 'Movie' = q.node.__typename; // just to check that those are the types we want here\n  const brandData = q.node.brandData; // this was missing in the original issue\n  const createdAt = q.node.createdAt; // this was missing in the original issue\n\n  if (q.node.__typename === 'Company') {\n    console.log('Company:', q.node.active);\n  } else if (q.node.__typename === 'Theater') {\n    console.log('Theater:', q.node.active);\n  } else if (q.node.__typename === 'User') {\n    console.log('User:', q.node.id);\n  } else if (q.node.__typename === 'Movie') {\n    console.log('Movie:', q.node.id);\n  }\n}`\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#1624 - Should work with fragment on union type",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4919,
                "column": 55
            },
            "line": 4919,
            "code": "    it('#1624 - Should work with fragment on union type', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          fooBar: [FooBar!]!\n        }\n\n        union FooBar = Foo | Bar\n\n        type Foo {\n          id: ID!\n        }\n\n        type Bar {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query TestQuery {\n          fooBar {\n            ...FooBarFragment\n          }\n        }\n\n        fragment FooBarFragment on FooBar {\n          ... on Foo {\n            id\n          }\n          ... on Bar {\n            id\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type TestQueryQuery = (\n        { __typename?: 'Query' }\n        & { fooBar: Array<(\n          { __typename?: 'Foo' }\n          & Pick<Foo, 'id'>\n        ) | (\n          { __typename?: 'Bar' }\n          & Pick<Bar, 'id'>\n        )> }\n      );\n\n      type FooBarFragment_Foo_Fragment = (\n        { __typename?: 'Foo' }\n        & Pick<Foo, 'id'>\n      );\n\n      type FooBarFragment_Bar_Fragment = (\n        { __typename?: 'Bar' }\n        & Pick<Bar, 'id'>\n      );\n\n      export type FooBarFragmentFragment = FooBarFragment_Foo_Fragment | FooBarFragment_Bar_Fragment;\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2407 Fragment on Fragment Spread on Union type",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 4988,
                "column": 55
            },
            "line": 4988,
            "code": "    it('#2407 Fragment on Fragment Spread on Union type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Price {\n          id: ID!\n          item: [PriceItemUnion]!\n        }\n\n        type Product {\n          id: ID!\n          title: String!\n        }\n\n        union PriceItemUnion = Product\n\n        type Query {\n          price: Price!\n        }\n      `);\n\n      const productFragmentDocument = parse(/* GraphQL */ `\n        fragment ProductFragment on Product {\n          id\n          title\n        }\n      `);\n\n      const priceFragmentDocument = parse(/* GraphQL */ `\n        fragment PriceFragment on Price {\n          id\n          item {\n            ... on Product {\n              ...ProductFragment\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [\n          { location: '', document: productFragmentDocument },\n          { location: '', document: priceFragmentDocument },\n        ],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type ProductFragmentFragment = (\n        { __typename?: 'Product' }\n        & Pick<Product, 'id' | 'title'>\n      );\n\n        export type PriceFragmentFragment = (\n          { __typename?: 'Price' }\n          & Pick<Price, 'id'>\n          & { item: Array<Maybe<(\n            { __typename?: 'Product' }\n            & Pick<Product, 'id' | 'title'>\n          )>> }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2506 - inline fragment without typeCondition specified",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5054,
                "column": 63
            },
            "line": 5054,
            "code": "    it('#2506 - inline fragment without typeCondition specified', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n        }\n\n        type User {\n          name: String\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'name'>\n        )> }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2436 - interface with field of same name but different type is correctly handled",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5094,
                "column": 89
            },
            "line": 5094,
            "code": "    it('#2436 - interface with field of same name but different type is correctly handled', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface DashboardTile {\n          tileId: ID!\n        }\n        type TileFilterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileFilterDetails implements DashboardTile {\n          tileId: ID!\n          md: TileFilterMetadata!\n        }\n        type TileParameterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileParameterDetails implements DashboardTile {\n          tileId: ID!\n          md: TileParameterMetadata!\n        }\n        type DashboardVersion {\n          id: ID!\n          tiles: DashboardTile!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment DashboardVersionFragment on DashboardVersion {\n          tiles {\n            ... on DashboardTileFilterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n            ... on DashboardTileParameterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type DashboardVersionFragmentFragment = (\n          { __typename?: 'DashboardVersion' }\n          & { tiles: (\n            { __typename?: 'DashboardTileFilterDetails' }\n            & Pick<DashboardTileFilterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileFilterMetadata' }\n              & Pick<TileFilterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) | (\n            { __typename?: 'DashboardTileParameterDetails' }\n            & Pick<DashboardTileParameterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileParameterMetadata' }\n              & Pick<TileParameterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2436 - union with field of same name but different type is correctly handled",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5173,
                "column": 85
            },
            "line": 5173,
            "code": "    it('#2436 - union with field of same name but different type is correctly handled', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type TileFilterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileFilterDetails {\n          tileId: ID!\n          md: TileFilterMetadata!\n        }\n        type TileParameterMetadata {\n          viz: String!\n          columnInfo: String!\n        }\n        type DashboardTileParameterDetails {\n          tileId: ID!\n          md: TileParameterMetadata!\n        }\n        union DashboardTile = DashboardTileFilterDetails | DashboardTileParameterDetails\n\n        type DashboardVersion {\n          id: ID!\n          tiles: DashboardTile!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment DashboardVersionFragment on DashboardVersion {\n          tiles {\n            ... on DashboardTileFilterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n            ... on DashboardTileParameterDetails {\n              tileId\n              md {\n                viz\n                columnInfo\n              }\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type DashboardVersionFragmentFragment = (\n          { __typename?: 'DashboardVersion' }\n          & { tiles: (\n            { __typename?: 'DashboardTileFilterDetails' }\n            & Pick<DashboardTileFilterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileFilterMetadata' }\n              & Pick<TileFilterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) | (\n            { __typename?: 'DashboardTileParameterDetails' }\n            & Pick<DashboardTileParameterDetails, 'tileId'>\n            & { md: (\n              { __typename?: 'TileParameterMetadata' }\n              & Pick<TileParameterMetadata, 'viz' | 'columnInfo'>\n            ) }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3950 - Invalid output with fragments and skipTypename: true",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5251,
                "column": 68
            },
            "line": 5251,
            "code": "    it('#3950 - Invalid output with fragments and skipTypename: true', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          animals: [Animal!]!\n        }\n\n        interface Animal {\n          id: ID!\n        }\n        type Duck implements Animal {\n          id: ID!\n        }\n        type Lion implements Animal {\n          id: ID!\n        }\n        type Puma implements Animal {\n          id: ID!\n        }\n        type Wolf implements Animal {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment CatFragment on Animal {\n          ... on Lion {\n            id\n          }\n          ... on Puma {\n            id\n          }\n        }\n\n        query kitty {\n          animals {\n            ...CatFragment\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"type CatFragment_Duck_Fragment = {};\n\n        type CatFragment_Lion_Fragment = { id: string };\n\n        type CatFragment_Puma_Fragment = { id: string };\n\n        type CatFragment_Wolf_Fragment = {};\n\n        export type CatFragmentFragment = CatFragment_Duck_Fragment | CatFragment_Lion_Fragment | CatFragment_Puma_Fragment | CatFragment_Wolf_Fragment;\n\n        export type KittyQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type KittyQuery = { animals: Array<{ id: string } | { id: string } | {}> };\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#3950 - Invalid output with fragments and skipTypename: false",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5321,
                "column": 69
            },
            "line": 5321,
            "code": "    it('#3950 - Invalid output with fragments and skipTypename: false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          animals: [Animal!]!\n        }\n\n        interface Animal {\n          id: ID!\n        }\n        type Duck implements Animal {\n          id: ID!\n        }\n        type Lion implements Animal {\n          id: ID!\n        }\n        type Puma implements Animal {\n          id: ID!\n        }\n        type Wolf implements Animal {\n          id: ID!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        fragment CatFragment on Animal {\n          ... on Lion {\n            id\n          }\n          ... on Puma {\n            id\n          }\n        }\n\n        query kitty {\n          animals {\n            ...CatFragment\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"type CatFragment_Duck_Fragment = { __typename?: 'Duck' };\n\n        type CatFragment_Lion_Fragment = { __typename?: 'Lion', id: string };\n\n        type CatFragment_Puma_Fragment = { __typename?: 'Puma', id: string };\n\n        type CatFragment_Wolf_Fragment = { __typename?: 'Wolf' };\n\n        export type CatFragmentFragment = CatFragment_Duck_Fragment | CatFragment_Lion_Fragment | CatFragment_Puma_Fragment | CatFragment_Wolf_Fragment;\n\n        export type KittyQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type KittyQuery = { __typename?: 'Query', animals: Array<{ __typename?: 'Duck' } | { __typename?: 'Lion', id: string } | { __typename?: 'Puma', id: string } | { __typename?: 'Wolf' }> };\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#2489 - Union that only covers one possible type with selection set and no typename",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5391,
                "column": 91
            },
            "line": 5391,
            "code": "    it('#2489 - Union that only covers one possible type with selection set and no typename', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type NotFoundError {\n          message: String!\n        }\n        type UserBannedError {\n          message: String!\n        }\n        type User {\n          id: ID!\n          login: String\n        }\n        union UserResult = NotFoundError | UserBannedError | User\n\n        type Query {\n          user: UserResult!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query user {\n          user {\n            ... on User {\n              id\n              login\n            }\n          }\n        }\n      `);\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: query }],\n        {\n          skipTypename: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQuery = { user: Pick<User, 'id' | 'login'> | {} };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#4888 - Types for input Lists do not support coercion",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5437,
                "column": 61
            },
            "line": 5437,
            "code": "    it('#4888 - Types for input Lists do not support coercion', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Query {\n          search(testArray: [String], requireString: [String]!, innerRequired: [String!]!): [User!]\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($testArray: [String], $requireString: [String]!, $innerRequired: [String!]!) {\n          search(testArray: $testArray, requireString: $requireString, innerRequired: $innerRequired) {\n            id\n          }\n        }\n      `);\n      const config = { preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: '', document: ast }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>>;\n        requireString: Array<InputMaybe<Scalars['String']>> | InputMaybe<Scalars['String']>;\n        innerRequired: Array<Scalars['String']> | Scalars['String'];\n      }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5352 - Prevent array input coercion if arrayInputCoercion = false",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5469,
                "column": 74
            },
            "line": 5469,
            "code": "    it('#5352 - Prevent array input coercion if arrayInputCoercion = false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type User {\n          id: ID!\n        }\n\n        type Query {\n          search(testArray: [String], requireString: [String]!, innerRequired: [String!]!): [User!]\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query user($testArray: [String], $requireString: [String]!, $innerRequired: [String!]!) {\n          search(testArray: $testArray, requireString: $requireString, innerRequired: $innerRequired) {\n            id\n          }\n        }\n      `);\n      const config = { preResolveTypes: true, arrayInputCoercion: false };\n      const { content } = await plugin(schema, [{ location: '', document: ast }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        testArray?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n        requireString: Array<InputMaybe<Scalars['String']>>;\n        innerRequired: Array<Scalars['String']>;\n      }>;`);\n      await validate(content, config);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#5263 - inline fragment spread on interface field results in incorrect types",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues"
            ],
            "updatePoint": {
                "line": 5501,
                "column": 84
            },
            "line": 5501,
            "code": "    it('#5263 - inline fragment spread on interface field results in incorrect types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Entity {\n          id: ID!\n        }\n\n        interface NamedEntity implements Entity {\n          id: ID!\n          name: String!\n        }\n\n        type Session implements Entity {\n          id: ID!\n          data: String!\n        }\n\n        type User implements NamedEntity & Entity {\n          id: ID!\n          name: String!\n        }\n\n        type Query {\n          entity(id: ID!): Entity!\n        }\n      `);\n\n      const document = parse(/* GraphQL */ `\n        query entity {\n          entity(id: 1) {\n            id\n            ... on NamedEntity {\n              name\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type EntityQuery = (\n        { __typename?: 'Query' }\n        & { entity: (\n          { __typename?: 'Session' }\n          & Pick<Session, 'id'>\n        ) | (\n          { __typename?: 'User' }\n          & Pick<User, 'name' | 'id'>\n        ) }\n      );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "InlineFragmentQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5574,
                "column": 29
            },
            "line": 5574,
            "code": "      it('InlineFragmentQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          query InlineFragmentQuery {\n            user {\n              ... on User {\n                friends {\n                  id\n                }\n              }\n              ... on User {\n                friends {\n                  name\n                }\n              }\n            }\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type InlineFragmentQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type InlineFragmentQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5616,
                "column": 29
            },
            "line": 5616,
            "code": "      it('SpreadFragmentQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsIdFragment on Query {\n            user {\n              friends {\n                id\n              }\n            }\n          }\n\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentQuery {\n            ...UserFriendsIdFragment\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsIdFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id'>\n              )> }\n            ) }\n          );\n\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentWithSelectionQuery",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5687,
                "column": 42
            },
            "line": 5687,
            "code": "      it('SpreadFragmentWithSelectionQuery', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentWithSelectionQuery {\n            user {\n              id\n              friends {\n                id\n              }\n            }\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentWithSelectionQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentWithSelectionQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & Pick<User, 'id'>\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "SpreadFragmentWithSelectionQuery - flatten",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5744,
                "column": 52
            },
            "line": 5744,
            "code": "      it('SpreadFragmentWithSelectionQuery - flatten', async () => {\n        const document = parse(/* GraphQL */ `\n          fragment UserFriendsNameFragment on Query {\n            user {\n              friends {\n                name\n              }\n            }\n          }\n\n          query SpreadFragmentWithSelectionQuery {\n            user {\n              id\n              friends {\n                id\n              }\n            }\n            ...UserFriendsNameFragment\n          }\n        `);\n\n        const { content } = await plugin(\n          schema,\n          [{ location: '', document }],\n          { preResolveTypes: false },\n          {\n            outputFile: 'graphql.ts',\n          }\n        );\n\n        expect(content).toBeSimilarStringTo(`\n          export type UserFriendsNameFragmentFragment = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'name'>\n              )> }\n            ) }\n          );\n\n          export type SpreadFragmentWithSelectionQueryQueryVariables = Exact<{ [key: string]: never; }>;\n\n          export type SpreadFragmentWithSelectionQueryQuery = (\n            { __typename?: 'Query' }\n            & { user: (\n              { __typename?: 'User' }\n              & Pick<User, 'id'>\n              & { friends: Array<(\n                { __typename?: 'User' }\n                & Pick<User, 'id' | 'name'>\n              )> }\n            ) }\n          );\n        `);\n      });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "#7811 - generates $fragmentName for fragment subtypes for fragment masking",
            "suites": [
                "TypeScript Operations Plugin",
                "Issues",
                "#6149 - operation fragment merging behavior"
            ],
            "updatePoint": {
                "line": 5803,
                "column": 82
            },
            "line": 5803,
            "code": "    it('#7811 - generates $fragmentName for fragment subtypes for fragment masking', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Character {\n          name: String\n        }\n\n        type Jedi {\n          name: String\n          side: String\n        }\n\n        type Droid {\n          model: String\n        }\n\n        union People = Character | Jedi | Droid\n\n        type Query {\n          people: People!\n        }\n      `);\n\n      const query = parse(/* GraphQL */ `\n        query GetPeople {\n          people {\n            ...PeopleInfo\n          }\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        fragment PeopleInfo on People {\n          ... on Character {\n            name\n          }\n\n          ... on Jedi {\n            side\n          }\n\n          ... on Droid {\n            model\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [\n          { location: '', document: query },\n          { location: '', document: fragment },\n        ],\n        { inlineFragmentTypes: 'mask' },\n        { outputFile: 'graphql.ts' }\n      );\n\n      expect(content).toMatchInlineSnapshot(`\n        \"export type GetPeopleQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type GetPeopleQuery = { __typename?: 'Query', people: (\n            { __typename?: 'Character' }\n            & { ' $fragmentRefs': { 'PeopleInfo_Character_Fragment': PeopleInfo_Character_Fragment } }\n          ) | (\n            { __typename?: 'Jedi' }\n            & { ' $fragmentRefs': { 'PeopleInfo_Jedi_Fragment': PeopleInfo_Jedi_Fragment } }\n          ) | (\n            { __typename?: 'Droid' }\n            & { ' $fragmentRefs': { 'PeopleInfo_Droid_Fragment': PeopleInfo_Droid_Fragment } }\n          ) };\n\n        type PeopleInfo_Character_Fragment = { __typename?: 'Character', name?: string | null } & { ' $fragmentName': 'PeopleInfo_Character_Fragment' };\n\n        type PeopleInfo_Jedi_Fragment = { __typename?: 'Jedi', side?: string | null } & { ' $fragmentName': 'PeopleInfo_Jedi_Fragment' };\n\n        type PeopleInfo_Droid_Fragment = { __typename?: 'Droid', model?: string | null } & { ' $fragmentName': 'PeopleInfo_Droid_Fragment' };\n\n        export type PeopleInfoFragment = PeopleInfo_Character_Fragment | PeopleInfo_Jedi_Fragment | PeopleInfo_Droid_Fragment;\n        \"\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "fields with @skip, @include should pre resolve into optional",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 5887,
                "column": 68
            },
            "line": 5887,
            "code": "    it('fields with @skip, @include should pre resolve into optional', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!) {\n          user {\n            name\n            address @include(if: $showAddress)\n            nicknames @include(if: $showNicknames)\n            parents @include(if: $showParents)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n      }>;\n\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, address?: string, nicknames?: Array<string> | null, parents?: Array<User> } };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "objects with @skip, @include should pre resolve into optional",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 5931,
                "column": 69
            },
            "line": 5931,
            "code": "    it('objects with @skip, @include should pre resolve into optional', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n          moreFriends: [User!]!\n        }\n\n        type Address {\n          city: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n        showName: Scalars['Boolean'];\n      }>;\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, name?: string, address?: { __typename?: 'Address', city: string }, friends?: Array<{ __typename?: 'User', id: string }> } };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "fields with @skip, @include should make container resolve into MakeOptional type",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 5984,
                "column": 88
            },
            "line": 5984,
            "code": "    it('fields with @skip, @include should make container resolve into MakeOptional type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n        type User {\n          id: String!\n          name: String!\n          address: Address!\n          friends: [User!]!\n        }\n        type Address {\n          city: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showAddress: Boolean!, $showName: Boolean!) {\n          user {\n            id\n            name @include(if: $showName)\n            address @include(if: $showAddress) {\n              city\n            }\n            friends @include(if: $isFriendly) {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQueryVariables = Exact<{\n        showAddress: Scalars['Boolean'];\n        showName: Scalars['Boolean'];\n      }>;\n\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user: (\n          { __typename?: 'User' }\n          & MakeOptional<Pick<User, 'id' | 'name'>, 'name'>\n          & { address?: (\n            { __typename?: 'Address' }\n            & Pick<Address, 'city'>\n          ), friends?: Array<(\n            { __typename?: 'User' }\n            & Pick<User, 'id'>\n          )> }\n        ) }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "On avoidOptionals:true, fields with @skip, @include should make container resolve into MakeMaybe type",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6046,
                "column": 109
            },
            "line": 6046,
            "code": "    it('On avoidOptionals:true, fields with @skip, @include should make container resolve into MakeMaybe type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email @skip(if: true)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          avoidOptionals: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type UserQueryVariables = Exact<{ [key: string]: never; }>;\n\n        export type UserQuery = (\n          { __typename?: 'Query' }\n          & { user: (\n            { __typename?: 'User' }\n            & MakeMaybe<Pick<User, 'id' | 'username' | 'email'>, 'email'>\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should handle \"preResolveTypes\" and \"avoidOptionals\" together",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6094,
                "column": 69
            },
            "line": 6094,
            "code": "    it('Should handle \"preResolveTypes\" and \"avoidOptionals\" together', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user(id: ID!): User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String\n        }\n      `);\n      const operations = parse(/* GraphQL */ `\n        query user {\n          user(id: 1) {\n            id\n            username\n            email\n          }\n        }\n      `);\n      const config = { avoidOptionals: true, preResolveTypes: true };\n      const { content } = await plugin(schema, [{ location: '', document: operations }], config, {\n        outputFile: 'graphql.ts',\n      });\n\n      expect(content).toBeSimilarStringTo(\n        `export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', id: string, username: string, email: string | null } }`\n      );\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "On avoidOptionals:true, optionals (?) on types should be avoided",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6125,
                "column": 72
            },
            "line": 6125,
            "code": "    it('On avoidOptionals:true, optionals (?) on types should be avoided', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          me: User!\n        }\n\n        type User {\n          messages: [Message!]!\n        }\n\n        type Message {\n          content: String!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query MyQuery($include: Boolean!) {\n          me {\n            messages @include(if: $include) {\n              content\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          avoidOptionals: true,\n          nonOptionalTypename: true,\n          preResolveTypes: false,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n        export type MyQueryQuery = (\n          { __typename: 'Query' }\n          & { me: (\n            { __typename: 'User' }\n            & { messages?: Array<(\n              { __typename: 'Message' }\n              & Pick<Message, 'content'>\n            )> }\n          ) }\n        );\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "inline fragment with conditional directives and avoidOptionals",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6177,
                "column": 70
            },
            "line": 6177,
            "code": "    it('inline fragment with conditional directives and avoidOptionals', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n          group: Group!\n        }\n\n        type User {\n          name: String\n        }\n\n        type Group {\n          id: Int!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n            group {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: true, avoidOptionals: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = {\n        __typename?: 'Query',\n        user?: {\n          __typename?: 'User',\n          name: string | null\n        } | null,\n        group?: {\n          __typename?: 'Group',\n          id: number\n        }\n      };`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "resolve optionals according to maybeValue together with avoidOptionals and conditional directives",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6229,
                "column": 105
            },
            "line": 6229,
            "code": "    it('resolve optionals according to maybeValue together with avoidOptionals and conditional directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User!\n        }\n\n        type User {\n          name: String!\n          age: Int\n          address: String!\n          nicknames: [String!]\n          parents: [User!]!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($showProperty: Boolean!) {\n          user {\n            name\n            age\n            address @include(if: $showProperty)\n            nicknames @include(if: $showProperty)\n            parents @include(if: $showProperty)\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        {\n          preResolveTypes: true,\n          maybeValue: \"T | 'specialType'\",\n          avoidOptionals: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = { __typename?: 'Query', user: { __typename?: 'User', name: string, age: number | 'specialType', address?: string, nicknames?: Array<string> | 'specialType', parents?: Array<User> } };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "inline fragment with conditional directives and avoidOptionals, without preResolveTypes",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6273,
                "column": 95
            },
            "line": 6273,
            "code": "    it('inline fragment with conditional directives and avoidOptionals, without preResolveTypes', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type Query {\n          user: User\n          group: Group!\n        }\n\n        type User {\n          name: String\n        }\n\n        type Group {\n          id: Int!\n        }\n      `);\n\n      const fragment = parse(/* GraphQL */ `\n        query user($withUser: Boolean! = false) {\n          ... @include(if: $withUser) {\n            user {\n              name\n            }\n            group {\n              id\n            }\n          }\n        }\n      `);\n\n      const { content } = await plugin(\n        schema,\n        [{ location: '', document: fragment }],\n        { preResolveTypes: false, avoidOptionals: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      expect(content).toBeSimilarStringTo(`\n      export type UserQuery = (\n        { __typename?: 'Query' }\n        & { user?: Maybe<(\n          { __typename?: 'User' }\n          & Pick<User, 'name'>\n        )>, group?: (\n          { __typename?: 'Group' }\n          & Pick<Group, 'id'>\n        ) }\n      );`);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "handles unnamed queries",
            "suites": [
                "TypeScript Operations Plugin",
                "conditional directives handling"
            ],
            "updatePoint": {
                "line": 6325,
                "column": 29
            },
            "line": 6325,
            "code": "  it('handles unnamed queries', async () => {\n    const ast = parse(/* GraphQL */ `\n      query {\n        notifications {\n          id\n        }\n      }\n    `);\n\n    const result = await plugin(\n      schema,\n      [{ location: 'test-file.ts', document: ast }],\n      { preResolveTypes: false },\n      { outputFile: '' }\n    );\n    expect(result.content).toBeSimilarStringTo(`\n      export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n      export type Unnamed_1_Query = (\n          { __typename?: 'Query' }\n        & { notifications: Array<(\n            { __typename?: 'TextNotification' }\n          & Pick<TextNotification, 'id'>\n        ) | (\n            { __typename?: 'ImageNotification' }\n          & Pick<ImageNotification, 'id'>\n        )> }\n      );\n    `);\n  });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'combine' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6357,
                "column": 38
            },
            "line": 6357,
            "code": "    it(\"'combine' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'combine' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: (\n            { __typename?: 'User' }\n            & UserFragmentFragment\n          ) | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'inline' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6387,
                "column": 37
            },
            "line": 6387,
            "code": "    it(\"'inline' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'inline' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: { __typename?: 'User', id: string } | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "'mask' yields correct types",
            "suites": [
                "TypeScript Operations Plugin",
                "inlineFragmentTypes option"
            ],
            "updatePoint": {
                "line": 6414,
                "column": 35
            },
            "line": 6414,
            "code": "    it(\"'mask' yields correct types\", async () => {\n      const ast = parse(/* GraphQL */ `\n        query {\n          me {\n            ...UserFragment\n          }\n        }\n        fragment UserFragment on User {\n          id\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [{ location: 'test-file.ts', document: ast }],\n        { inlineFragmentTypes: 'mask' },\n        { outputFile: '' }\n      );\n      expect(result.content).toBeSimilarStringTo(`\n        export type Unnamed_1_QueryVariables = Exact<{ [key: string]: never; }>;\n\n\n        export type Unnamed_1_Query = { __typename?: 'Query', me?: (\n            { __typename?: 'User' }\n            & { ' $fragmentRefs': { 'UserFragmentFragment': UserFragmentFragment } }\n          ) | null };\n\n        export type UserFragmentFragment = { __typename?: 'User', id: string } & { ' $fragmentName': 'UserFragmentFragment' };\n      `);\n    });",
            "file": "ts-documents.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/operations/tests"
        },
        {
            "name": "Should generate output correctly and backward compatible output",
            "suites": [
                "React Apollo",
                "Apollo Client v2 Backward Compatible"
            ],
            "updatePoint": {
                "line": 88,
                "column": 71
            },
            "line": 88,
            "code": "    it('Should generate output correctly and backward compatible output', async () => {\n      const documents = parse(/* GraphQL */ `\n        query Feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation SubmitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { reactApolloVersion: 2, withComponent: true, withHOC: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // To make sure we have the gql tag imported\n      expect(content.prepend).toContain(`import gql from 'graphql-tag';`);\n      // To make sure we have React for the Component  and the rest of the grouped namespaces\n      expect(content.prepend).toContain(`import * as React from 'react';`);\n      expect(content.prepend).toContain(`import * as ApolloReactCommon from '@apollo/react-common';`);\n      expect(content.prepend).toContain(`import * as ApolloReactComponents from '@apollo/react-components';`);\n      expect(content.prepend).toContain(`import * as ApolloReactHoc from '@apollo/react-hoc';`);\n      expect(content.prepend).toContain(`import * as ApolloReactHooks from '@apollo/react-hooks';`);\n      // To make sure the default gql is used correctly, without namespace prefix\n      expect(content.content).toContain('export const FeedDocument = gql`\\n');\n      // To make sure we don't have apollo v3 related code\n      expect(content.content).not.toContain('Apollo.');\n      expect(content.content).toContain('ApolloReactCommon.');\n      expect(content.content).toContain('ApolloReactHoc.');\n      expect(content.content).toContain('ApolloReactComponents.');\n      expect(content.content).toContain('ApolloReactHooks.');\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Issue #4887 - baseOptions of generated hooks should not be optional when there are required variables",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "line": 143,
            "code": "    it.each([\n      {\n        document: `query Feed { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n      {\n        document: `mutation Feed { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n      {\n        document: `query Feed($something: Boolean) { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n      {\n        document: `query Feed($something: Boolean!) { feed { ...Feed } } `,\n        optionalBaseOptions: false,\n      },\n      {\n        document: `mutation Feed($something: Boolean!) { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n      {\n        document: `query Feed($something: Boolean!, $somethingElse: Boolean!) { feed { ...Feed } } `,\n        optionalBaseOptions: false,\n      },\n      {\n        document: `query Feed($something: Boolean, $somethingElse: Boolean!) { feed { ...Feed } } `,\n        optionalBaseOptions: false,\n      },\n      {\n        document: `query Feed($something: Boolean! = true) { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n      {\n        document: `query Feed($something: Boolean! = true, $somethingElse: Boolean) { feed { ...Feed } } `,\n        optionalBaseOptions: true,\n      },\n    ])(\n      'Issue #4887 - baseOptions of generated hooks should not be optional when there are required variables',\n      async ({ document, optionalBaseOptions }) => {\n        const docs = [\n          {\n            location: '',\n            document: parse(document),\n          },\n        ];\n\n        const result = (await plugin(\n          schema,\n          docs,\n          {},\n          {\n            outputFile: 'graphql.tsx',\n          }\n        )) as Types.ComplexPluginOutput;\n\n        expect(result.content).toContain(`(baseOptions${optionalBaseOptions ? '?' : ''}: Apollo.`);\n      }\n    );",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Issue #3612 - Missing fragments spread when fragment name is same as operation?",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 203,
                "column": 87
            },
            "line": 203,
            "code": "    it('Issue #3612 - Missing fragments spread when fragment name is same as operation?', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query Feed {\n              feed {\n                ...Feed\n              }\n            }\n\n            fragment Feed on Feed {\n              id\n              commentCount\n              repository {\n                ...RepoFields\n              }\n            }\n\n            fragment RepoFields on Repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          `),\n        },\n      ];\n      const result = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`    export const FeedDocument = gql\\`\n      query Feed {\n    feed {\n      ...Feed\n    }\n  }\n      \\${FeedFragmentDoc}\\`;`);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Issue #2742 - Incorrect import prefix",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 250,
                "column": 45
            },
            "line": 250,
            "code": "    it('Issue #2742 - Incorrect import prefix', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query GET_SOMETHING {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        addDocBlocks: false,\n        withHooks: true,\n        withComponent: false,\n        withHOC: false,\n        skipTypename: true,\n        importOperationTypesFrom: 'Types',\n      };\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      const output = await validateTypeScript(content, schema, docs, config);\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toContain(\n        `export type Get_SomethingQueryResult = Apollo.QueryResult<Types.Get_SomethingQuery, Types.Get_SomethingQueryVariables>;`\n      );\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Issue #2826 - Incorrect prefix",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 284,
                "column": 38
            },
            "line": 284,
            "code": "    it('Issue #2826 - Incorrect prefix', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query GET_SOMETHING {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        addDocBlocks: false,\n        withHooks: true,\n        withComponent: false,\n        withHOC: false,\n        skipTypename: true,\n        typesPrefix: 'GQL',\n      };\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      const output = await validateTypeScript(content, schema, docs, config);\n      expect(mergeOutputs([output])).toMatchSnapshot();\n\n      expect(output).toContain(\n        `export type Get_SomethingQueryResult = Apollo.QueryResult<GQLGet_SomethingQuery, GQLGet_SomethingQueryVariables>;`\n      );\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "PR #2725 - transformUnderscore: true causes invalid output",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 318,
                "column": 66
            },
            "line": 318,
            "code": "    it('PR #2725 - transformUnderscore: true causes invalid output', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query GET_SOMETHING {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        addDocBlocks: false,\n        withHooks: true,\n        withComponent: false,\n        withHOC: false,\n        skipTypename: true,\n        namingConvention: {\n          typeNames: 'change-case-all#pascalCase',\n          enumValues: 'keep',\n          transformUnderscore: true,\n        },\n      };\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      const output = await validateTypeScript(content, schema, docs, config);\n      expect(mergeOutputs([output])).toMatchSnapshot();\n      expect(output).toMatchSnapshot();\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Issue #2080 - noGraphQLTag does not work with fragments correctly",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 352,
                "column": 73
            },
            "line": 352,
            "code": "    it('Issue #2080 - noGraphQLTag does not work with fragments correctly', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query test {\n              feed {\n                id\n                commentCount\n                repository {\n                  ...RepositoryFields\n                }\n              }\n            }\n\n            fragment RepositoryFields on Repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n      expect(\n        content.content.split('{\"kind\":\"FragmentDefinition\",\"name\":{\"kind\":\"Name\",\"value\":\"RepositoryFields\"}').length\n      ).toBe(3);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "#6001 - Should not use TypesSuffix on function names",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 392,
                "column": 60
            },
            "line": 392,
            "code": "    it('#6001 - Should not use TypesSuffix on function names', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query user {\n              user(id: 1) {\n                id\n                username\n                email\n              }\n            }\n          `),\n        },\n      ];\n\n      const content = await plugin(schema, docs, { typesSuffix: 'Type' });\n\n      expect(content.content).toEqual(expect.stringMatching(/UserQueryType/));\n      // String matching `useUserQuery` but not `useUserQueryType`.\n      expect(content.content).toEqual(expect.stringMatching(/(?=.useUserQuery)(?!.useUserQueryType)(.+)/));\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "#6212 - Should use TypesSuffix on function names if hooksSuffix provided",
            "suites": [
                "React Apollo",
                "Issues"
            ],
            "updatePoint": {
                "line": 415,
                "column": 80
            },
            "line": 415,
            "code": "    it('#6212 - Should use TypesSuffix on function names if hooksSuffix provided', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query user {\n              user(id: 1) {\n                id\n                username\n                email\n              }\n            }\n          `),\n        },\n      ];\n\n      const content = await plugin(schema, docs, { typesSuffix: 'Type', hooksSuffix: 'HookXYZ' });\n\n      expect(content.content).toEqual(expect.stringMatching(/UserQueryType/));\n      // String matching `useUserQuery` but not `useUserQueryType`.\n      expect(content.content).toEqual(expect.stringMatching(/(?=.useUserQueryHookXYZ)(?!.useUserQueryType)(.+)/));\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import React and ReactApollo dependencies",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 440,
                "column": 56
            },
            "line": 440,
            "code": "    it('should import React and ReactApollo dependencies', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComponent: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      expect(content.prepend).toContain(`import { gql } from '@apollo/client';`);\n      expect(content.prepend).toContain(`import * as ApolloReactComponents from '@apollo/client/react/components';`);\n      expect(content.prepend).toContain(`import * as React from 'react';`);\n\n      // To make sure all imports are unified correctly under Apollo namespaced import\n      expect(content.content).toContain(` gql\\``);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 461,
                "column": 58
            },
            "line": 461,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 479,
                "column": 58
            },
            "line": 479,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 494,
                "column": 39
            },
            "line": 494,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })) as any).content\n      ).toContain('Apollo.QueryResult<NotificationsQueryQuery, NotificationsQueryQueryVariables>;');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>');\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "tests for omitOperationSuffix",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 555,
                "column": 37
            },
            "line": 555,
            "code": "    it(`tests for omitOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })) as any).content\n      ).toContain('Apollo.QueryResult<NotificationsQueryQuery, NotificationsQueryQueryVariables>;');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { omitOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { omitOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { omitOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<Notifications, NotificationsVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { omitOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>');\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Apollo namespaced import correctly",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 616,
                "column": 56
            },
            "line": 616,
            "code": "    it('should import Apollo namespaced import correctly', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import ApolloReactHooks from apolloReactHooksImportFrom config option",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 631,
                "column": 84
            },
            "line": 631,
            "code": "    it('should import ApolloReactHooks from apolloReactHooksImportFrom config option', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { apolloReactHooksImportFrom: 'react-apollo-hooks' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as ApolloReactHooks from 'react-apollo-hooks';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import ApolloReactCommon from apolloReactCommonImportFrom config option",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 646,
                "column": 86
            },
            "line": 646,
            "code": "    it('should import ApolloReactCommon from apolloReactCommonImportFrom config option', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { apolloReactCommonImportFrom: 'custom-apollo-react-common' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as ApolloReactCommon from 'custom-apollo-react-common';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should skip import React and ApolloReactComponents by default (only hooks)",
            "suites": [
                "React Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 661,
                "column": 82
            },
            "line": 661,
            "code": "    it('should skip import React and ApolloReactComponents by default (only hooks)', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactComponents from '@apollo/react-components';`);\n      expect(content.prepend).not.toContain(`import * as React from 'react';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate basic fragments documents correctly",
            "suites": [
                "React Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 679,
                "column": 59
            },
            "line": 679,
            "code": "    it('Should generate basic fragments documents correctly', async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment MyFragment on Repository {\n              full_name\n            }\n\n            query test {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const result = await plugin(schema, docs, {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyFragmentFragmentDoc = gql\\`\n      fragment MyFragment on Repository {\n        full_name\n      }\n      \\`;`);\n      await validateTypeScript(result, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate Document variables for inline fragments",
            "suites": [
                "React Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 707,
                "column": 63
            },
            "line": 707,
            "code": "    it('should generate Document variables for inline fragments', async () => {\n      const repositoryWithOwner = gql`\n        fragment RepositoryWithOwner on Repository {\n          full_name\n          html_url\n          owner {\n            avatar_url\n          }\n        }\n      `;\n      const feedWithRepository = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          commentCount\n          repository(search: \"phrase\") {\n            ...RepositoryWithOwner\n          }\n        }\n\n        ${repositoryWithOwner}\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n\n        ${feedWithRepository}\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const FeedWithRepositoryFragmentDoc = gql\\`\nfragment FeedWithRepository on Entry {\n  id\n  commentCount\n  repository(search: \"phrase\") {\n    ...RepositoryWithOwner\n  }\n}\n\\${RepositoryWithOwnerFragmentDoc}\\`;`);\n      expect(content.content).toBeSimilarStringTo(`export const RepositoryWithOwnerFragmentDoc = gql\\`\nfragment RepositoryWithOwner on Repository {\n  full_name\n  html_url\n  owner {\n    avatar_url\n  }\n}\n\\`;`);\n\n      expect(content.content).toBeSimilarStringTo(`export const MyFeedDocument = gql\\`\nquery MyFeed {\n  feed {\n    ...FeedWithRepository\n  }\n}\n\\${FeedWithRepositoryFragmentDoc}\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should avoid generating duplicate fragments",
            "suites": [
                "React Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 778,
                "column": 51
            },
            "line": 778,
            "code": "    it('should avoid generating duplicate fragments', async () => {\n      const simpleFeed = gql`\n        fragment Item on Entry {\n          id\n        }\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...Item\n          }\n          allFeeds: feed {\n            ...Item\n          }\n        }\n      `;\n      const documents = [simpleFeed, myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        export const MyFeedDocument = gql\\`\n        query MyFeed {\n            feed {\n              ...Item\n            }\n            allFeeds: feed {\n              ...Item\n            }\n          }\n          \\${ItemFragmentDoc}\\``);\n      expect(content.content).toBeSimilarStringTo(`\n        export const ItemFragmentDoc = gql\\`\n        fragment Item on Entry {\n          id\n        }\n\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate fragments in proper order (when one depends on other)",
            "suites": [
                "React Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 825,
                "column": 77
            },
            "line": 825,
            "code": "    it('Should generate fragments in proper order (when one depends on other)', async () => {\n      const myFeed = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          repository {\n            ...RepositoryWithOwner\n          }\n        }\n\n        fragment RepositoryWithOwner on Repository {\n          full_name\n        }\n\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n      `;\n      const documents = [myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const feedWithRepositoryPos = content.content.indexOf('fragment FeedWithRepository');\n      const repositoryWithOwnerPos = content.content.indexOf('fragment RepositoryWithOwner');\n      expect(repositoryWithOwnerPos).toBeLessThan(feedWithRepositoryPos);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate Document variable",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 863,
                "column": 41
            },
            "line": 863,
            "code": "    it('should generate Document variable', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          export const TestDocument = gql\\`\n          query test {\n            feed {\n              id\n              commentCount\n              repository {\n                full_name\n                html_url\n                owner {\n                  avatar_url\n                }\n              }\n            }\n          }\n          \\`;\n        `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate Document variable with noGraphQlTag",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 894,
                "column": 59
            },
            "line": 894,
            "code": "    it('should generate Document variable with noGraphQlTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"avatar_url\"}}]}}]}}]}}]}}]} as unknown as DocumentNode;`\n      );\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate correct Document variable with escaped values",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 918,
                "column": 69
            },
            "line": 918,
            "code": "    it('should generate correct Document variable with escaped values', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            mutation Test {\n              submitRepository(repoFullName: \"\\\\\"REPONAME\\\\\"\") {\n                createdAt\n              }\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          export const TestDocument = gql\\`\n            mutation Test {\n              submitRepository(repoFullName: \"\\\\\\\\\"REPONAME\\\\\\\\\"\") {\n                createdAt\n              }\n            }\n          \\`;\n        `);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate Component",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 953,
                "column": 33
            },
            "line": 953,
            "code": "    it('should generate Component', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComponent: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type TestComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TestQuery, TestQueryVariables>, 'query'>;\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: TestComponentProps) =>\n      (\n          <ApolloReactComponents.Query<TestQuery, TestQueryVariables> query={TestDocument} {...props} />\n      );\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate a component with a custom suffix when specified",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 977,
                "column": 71
            },
            "line": 977,
            "code": "    it('should generate a component with a custom suffix when specified', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { componentSuffix: 'Element', withComponent: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type TestElementProps = Omit<ApolloReactComponents.QueryComponentOptions<TestQuery, TestQueryVariables>, 'query'>;\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestElement = (props: TestElementProps) =>\n      (\n          <ApolloReactComponents.Query<TestQuery, TestQueryVariables> query={TestDocument} {...props} />\n      );\n      `);\n      await validateTypeScript(content, schema, docs, { componentSuffix: 'Element' });\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should not generate Component by default",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 1000,
                "column": 48
            },
            "line": 1000,
            "code": "    it('should not generate Component by default', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export class TestComponent`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should make variables property required if any of variable definitions is non-null",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 1015,
                "column": 90
            },
            "line": 1015,
            "code": "    it('should make variables property required if any of variable definitions is non-null', async () => {\n      const docs = [\n        {\n          location: '',\n          document: gql`\n            query Test($foo: String!) {\n              test(foo: $foo)\n            }\n          `,\n        },\n      ];\n      const schema = buildASTSchema(gql`\n        type Query {\n          test(foo: String!): Boolean\n        }\n      `);\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComponent: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type TestComponentProps = Omit<ApolloReactComponents.QueryComponentOptions<TestQuery, TestQueryVariables>, 'query'> & ({ variables: TestQueryVariables; skip?: boolean; } | { skip: boolean; });\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: TestComponentProps) =>\n      (\n          <ApolloReactComponents.Query<TestQuery, TestQueryVariables> query={TestDocument} {...props} />\n      );\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should make variables property optional if operationType is mutation",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 1053,
                "column": 76
            },
            "line": 1053,
            "code": "    it('should make variables property optional if operationType is mutation', async () => {\n      const docs = [\n        {\n          location: '',\n          document: gql`\n            mutation Test($foo: String!) {\n              test(foo: $foo)\n            }\n          `,\n        },\n      ];\n      const schema = buildASTSchema(gql`\n        type Mutation {\n          test(foo: String!): Boolean\n        }\n      `);\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComponent: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type TestComponentProps = Omit<ApolloReactComponents.MutationComponentOptions<TestMutation, TestMutationVariables>, 'mutation'>;\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: TestComponentProps) => (\n        <ApolloReactComponents.Mutation<TestMutation, TestMutationVariables> mutation={TestDocument} {...props} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should not add typesPrefix to Component",
            "suites": [
                "React Apollo",
                "Component"
            ],
            "updatePoint": {
                "line": 1088,
                "column": 47
            },
            "line": 1088,
            "code": "    it('should not add typesPrefix to Component', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export class ITestComponent`);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate HOCs correctly",
            "suites": [
                "React Apollo",
                "HOC"
            ],
            "updatePoint": {
                "line": 1104,
                "column": 38
            },
            "line": 1104,
            "code": "    it('should generate HOCs correctly', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const config = { withHOC: true };\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export type TestProps<TChildProps = {}, TDataName extends string = 'data'> = {\n          [key in TDataName]: ApolloReactHoc.DataValue<TestQuery, TestQueryVariables>\n        } & TChildProps;`\n      );\n\n      expect(content.content)\n        .toBeSimilarStringTo(`export function withTest<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n      TProps,\n      TestQuery,\n      TestQueryVariables,\n      TestProps<TChildProps, TDataName>>) {\n        return ApolloReactHoc.withQuery<TProps, TestQuery, TestQueryVariables, TestProps<TChildProps, TDataName>>(TestDocument, {\n          alias: 'test',\n          ...operationOptions\n        });\n    }`);\n      await validateTypeScript(content, schema, docs, config);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate HOC props with correct operation result type name",
            "suites": [
                "React Apollo",
                "HOC"
            ],
            "updatePoint": {
                "line": 1131,
                "column": 73
            },
            "line": 1131,
            "code": "    it('should generate HOC props with correct operation result type name', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const config = { operationResultSuffix: 'Response', withHOC: true };\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export type TestProps<TChildProps = {}, TDataName extends string = 'data'> = {\n          [key in TDataName]: ApolloReactHoc.DataValue<TestQueryResponse, TestQueryVariables>\n        } & TChildProps;`\n      );\n\n      await validateTypeScript(content, schema, docs, config);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should not generate HOCs by default",
            "suites": [
                "React Apollo",
                "HOC"
            ],
            "updatePoint": {
                "line": 1147,
                "column": 43
            },
            "line": 1147,
            "code": "    it('should not generate HOCs by default', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export type TestProps`);\n      expect(content.content).not.toContain(`export function withTest`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should not add typesPrefix to HOCs",
            "suites": [
                "React Apollo",
                "HOC"
            ],
            "updatePoint": {
                "line": 1163,
                "column": 42
            },
            "line": 1163,
            "code": "    it('should not add typesPrefix to HOCs', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I', withHOC: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export type ITestProps`);\n      expect(content.content).toContain(`export function withTest`);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate mutation function signature correctly",
            "suites": [
                "React Apollo",
                "HOC"
            ],
            "updatePoint": {
                "line": 1178,
                "column": 61
            },
            "line": 1178,
            "code": "    it('should generate mutation function signature correctly', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            mutation submitComment($repoFullName: String!, $commentContent: String!) {\n              submitComment(repoFullName: $repoFullName, commentContent: $commentContent) {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withMutationFn: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(\n        `export type SubmitCommentMutationFn = Apollo.MutationFunction<SubmitCommentMutation, SubmitCommentMutationVariables>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate hooks for query and mutation by default",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1208,
                "column": 63
            },
            "line": 1208,
            "code": "    it('Should generate hooks for query and mutation by default', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useFeedQuery(baseOptions?: Apollo.QueryHookOptions<FeedQuery, FeedQueryVariables>) {\n  const options = {...defaultOptions, ...baseOptions}\n  return Apollo.useQuery<FeedQuery, FeedQueryVariables>(FeedDocument, options);\n}`);\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useSubmitRepositoryMutation(baseOptions?: Apollo.MutationHookOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>) {\n  const options = {...defaultOptions, ...baseOptions}\n  return Apollo.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument, options);\n}`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate deduped hooks for query and mutation",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1255,
                "column": 60
            },
            "line": 1255,
            "code": "    it('Should generate deduped hooks for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query FeedQuery {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation SubmitRepositoryMutation($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n      const config = { withHooks: true, withComponent: false, withHOC: false, dedupeOperationSuffix: true };\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useFeedQuery(baseOptions?: Apollo.QueryHookOptions<FeedQuery, FeedQueryVariables>) {\n       const options = {...defaultOptions, ...baseOptions}\n      return Apollo.useQuery<FeedQuery, FeedQueryVariables>(FeedQueryDocument, options);\n    }`);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useSubmitRepositoryMutation(baseOptions?: Apollo.MutationHookOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n      return Apollo.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryMutationDocument, options);\n    }`);\n      await validateTypeScript(content, schema, docs, config);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should not generate hooks for query and mutation",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1298,
                "column": 56
            },
            "line": 1298,
            "code": "    it('Should not generate hooks for query and mutation', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate subscription hooks",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1313,
                "column": 42
            },
            "line": 1313,
            "code": "    it('Should generate subscription hooks', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withHooks: true,\n          withComponent: false,\n          withHOC: false,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useListenToCommentsSubscription(baseOptions?: Apollo.SubscriptionHookOptions<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>) {\n  const options = {...defaultOptions, ...baseOptions}\n  return Apollo.useSubscription<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>(ListenToCommentsDocument, options);\n}`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should not add typesPrefix to hooks",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1345,
                "column": 43
            },
            "line": 1345,
            "code": "    it('Should not add typesPrefix to hooks', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTestQuery`);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate hook result",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1359,
                "column": 35
            },
            "line": 1359,
            "code": "    it('should generate hook result', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false, withHOC: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type FeedQueryHookResult = ReturnType<typeof useFeedQuery>;\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type FeedLazyQueryHookResult = ReturnType<typeof useFeedLazyQuery>;\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type SubmitRepositoryMutationHookResult = ReturnType<typeof useSubmitRepositoryMutation>;\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should generate JSDoc docblocks for hooks",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1441,
                "column": 49
            },
            "line": 1441,
            "code": "    it('Should generate JSDoc docblocks for hooks', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false, withHOC: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n\n      expect(queryDocBlock).toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n\n      expect(mutationDocBlock).toEqual(mutationDocBlockSnapshot);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Should NOT generate JSDoc docblocks for hooks if addDocBlocks is false",
            "suites": [
                "React Apollo",
                "Hooks"
            ],
            "updatePoint": {
                "line": 1475,
                "column": 78
            },
            "line": 1475,
            "code": "    it('Should NOT generate JSDoc docblocks for hooks if addDocBlocks is false', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false, withHOC: false, addDocBlocks: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n\n      expect(queryDocBlock).not.toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n\n      expect(mutationDocBlock).not.toEqual(mutationDocBlockSnapshot);\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate ResultType for Query if withResultType is true",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1536,
                "column": 70
            },
            "line": 1536,
            "code": "    it('should generate ResultType for Query if withResultType is true', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      expect(content.content).toContain(\n        `export type TestQueryResult = Apollo.QueryResult<TestQuery, TestQueryVariables>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate ResultType for Query if withResultType is false",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1554,
                "column": 75
            },
            "line": 1554,
            "code": "    it('should NOT generate ResultType for Query if withResultType is false', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withResultType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from '@apollo/react-common';`);\n      expect(content.content).not.toContain(\n        `export type TestQueryResult = Apollo.QueryResult<TestQuery, TestQueryVariables>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate ResultType for Mutation if withResultType is true",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1572,
                "column": 73
            },
            "line": 1572,
            "code": "    it('should generate ResultType for Mutation if withResultType is true', async () => {\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      expect(content.content).toContain(`export type TestMutationResult = Apollo.MutationResult<TestMutation>;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate ResultType for Mutation if withResultType is false",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1589,
                "column": 78
            },
            "line": 1589,
            "code": "    it('should NOT generate ResultType for Mutation if withResultType is false', async () => {\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withResultType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as Apollo from '@apollo/react-common';`);\n      expect(content.content).not.toContain(`export type TestMutationResult = Apollo.MutationResult<TestMutation>;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate ResultType for Subscription if withResultType is true",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1606,
                "column": 77
            },
            "line": 1606,
            "code": "    it('should generate ResultType for Subscription if withResultType is true', async () => {\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      expect(content.content).toContain(\n        `export type TestSubscriptionResult = Apollo.SubscriptionResult<TestSubscription>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate ResultType for Subscription if withResultType is false",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1625,
                "column": 82
            },
            "line": 1625,
            "code": "    it('should NOT generate ResultType for Subscription if withResultType is false', async () => {\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withResultType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as Apollo from '@apollo/react-common';`);\n      expect(content.content).not.toContain(\n        `export type TestSubscriptionResult = Apollo.SubscriptionResult<TestSubscription>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate lazy query hooks",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1643,
                "column": 40
            },
            "line": 1643,
            "code": "    it('should generate lazy query hooks', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false, withHOC: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeedQuery, FeedQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedDocument, options);\n      }`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate lazy query hooks with proper hooksSuffix",
            "suites": [
                "React Apollo",
                "ResultType"
            ],
            "updatePoint": {
                "line": 1677,
                "column": 64
            },
            "line": 1677,
            "code": "    it('should generate lazy query hooks with proper hooksSuffix', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false, withHOC: false, hooksSuffix: 'MySuffix' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useFeedLazyQueryMySuffix(baseOptions?: Apollo.LazyQueryHookOptions<FeedQuery, FeedQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedDocument, options);\n      }`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate MutationOptions for Mutation if withMutationOptionsType is true",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1723,
                "column": 87
            },
            "line": 1723,
            "code": "    it('should generate MutationOptions for Mutation if withMutationOptionsType is true', async () => {\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Apollo from '@apollo/client';`);\n      expect(content.content).toContain(\n        `export type TestMutationOptions = Apollo.BaseMutationOptions<TestMutation, TestMutationVariables>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate MutationOptions for Mutation if withMutationOptionsType is false",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1742,
                "column": 92
            },
            "line": 1742,
            "code": "    it('should NOT generate MutationOptions for Mutation if withMutationOptionsType is false', async () => {\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withMutationOptionsType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from '@apollo/react-common';`);\n      expect(content.content).not.toContain(\n        `export type TestMutationOptions = Apollo.BaseMutationOptions<TestMutation, TestMutationVariables>;`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate MutationOptions for Query if withMutationOptionsType is true",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1761,
                "column": 88
            },
            "line": 1761,
            "code": "    it('should NOT generate MutationOptions for Query if withMutationOptionsType is true', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from 'react-apollo';`);\n      expect(content.content).not.toContain(`Apollo.BaseMutationOptions`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate MutationOptions for Query if withMutationOptionsType is false",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1777,
                "column": 89
            },
            "line": 1777,
            "code": "    it('should NOT generate MutationOptions for Query if withMutationOptionsType is false', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withMutationOptionsType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from 'react-apollo';`);\n      expect(content.content).not.toContain(`Apollo.BaseMutationOptions`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate MutationOptions for Subscription if withMutationOptionsType is true",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1793,
                "column": 95
            },
            "line": 1793,
            "code": "    it('should NOT generate MutationOptions for Subscription if withMutationOptionsType is true', async () => {\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from 'react-apollo';`);\n      expect(content.content).not.toContain(`Apollo.BaseMutationOptions`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate MutationOptions for Subscription if withMutationOptionsType is false",
            "suites": [
                "React Apollo",
                "MutationOptions"
            ],
            "updatePoint": {
                "line": 1810,
                "column": 96
            },
            "line": 1810,
            "code": "    it('should NOT generate MutationOptions for Subscription if withMutationOptionsType is false', async () => {\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config, withMutationOptionsType: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toContain(`import * as ApolloReactCommon from 'react-apollo';`);\n      expect(content.content).not.toContain(`Apollo.BaseMutationOptions`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate a function for use with refetchQueries",
            "suites": [
                "React Apollo",
                "withRefetchFn"
            ],
            "updatePoint": {
                "line": 1829,
                "column": 62
            },
            "line": 1829,
            "code": "    it('should generate a function for use with refetchQueries', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, {\n        withRefetchFn: true,\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(\n        `export function refetchTestQuery(variables?: TestQueryVariables) {\n      return { query: TestDocument, variables: variables }\n    }`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should require variables if they contain non-null non-default arguments",
            "suites": [
                "React Apollo",
                "withRefetchFn"
            ],
            "updatePoint": {
                "line": 1844,
                "column": 79
            },
            "line": 1844,
            "code": "    it('should require variables if they contain non-null non-default arguments', async () => {\n      const docs = [{ location: '', document: queryWithRequiredVariablesDoc }];\n\n      const content = (await plugin(schema, docs, {\n        withRefetchFn: true,\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(\n        `export function refetchWithRequiredVariablesQuery(variables: WithRequiredVariablesQueryVariables) {\n      return { query: WithRequiredVariablesDocument, variables: variables }\n    }`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should not require variables if they contain non-null default arguments",
            "suites": [
                "React Apollo",
                "withRefetchFn"
            ],
            "updatePoint": {
                "line": 1859,
                "column": 79
            },
            "line": 1859,
            "code": "    it('should not require variables if they contain non-null default arguments', async () => {\n      const docs = [{ location: '', document: queryWithNonNullDefaultVariablesDoc }];\n\n      const content = (await plugin(schema, docs, {\n        withRefetchFn: true,\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(\n        `export function refetchWithNonNullDefaultVariablesQuery(variables?: WithNonNullDefaultVariablesQueryVariables) {\n      return { query: WithNonNullDefaultVariablesDocument, variables: variables }\n    }`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import DocumentNode when documentMode is \"documentNode\"",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1903,
                "column": 70
            },
            "line": 1903,
            "code": "    it('should import DocumentNode when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate Document variable when documentMode is \"documentNode\"",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1921,
                "column": 77
            },
            "line": 1921,
            "code": "    it('should generate Document variable when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"avatar_url\"}}]}}]}}]}}]}}]} as unknown as DocumentNode;`\n      );\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should generate definitions Document variable when documentMode is \"documentNode\" and nested fragments",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1945,
                "column": 110
            },
            "line": 1945,
            "code": "    it('should generate definitions Document variable when documentMode is \"documentNode\" and nested fragments', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          a: A\n        }\n\n        type A {\n          bs: [B!]!\n        }\n\n        type B {\n          cs: [C!]!\n        }\n\n        type C {\n          greeting: String!\n        }\n      `);\n      const testDoc = parse(/* GraphQL */ `\n        query Test {\n          a {\n            ...AFields\n          }\n        }\n\n        fragment AFields on A {\n          bs {\n            ...BFields\n          }\n        }\n\n        fragment BFields on B {\n          cs {\n            ...CFields\n          }\n        }\n\n        fragment CFields on C {\n          greeting\n        }\n      `);\n      const docs = [{ location: '', document: testDoc }];\n      const content = (await plugin(\n        testSchema,\n        docs,\n        {\n          withComponent: false,\n          withHOC: false,\n          withHooks: false,\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toMatchSnapshot();\n\n      await validateTypeScript(content, testSchema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation using inline fragment",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2006,
                "column": 109
            },
            "line": 2006,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                ...feedFragment\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc = gql`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2041,
                "column": 113
            },
            "line": 2041,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc = gql`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with just fragment",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2077,
                "column": 91
            },
            "line": 2077,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with just fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc = gql`);\n\n      await validateTypeScript(content, schema, docs, { ...config });\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in Query component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2109,
                "column": 85
            },
            "line": 2109,
            "code": "    it('should import Operations from one external file and use it in Query component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestComponent = (props: TestComponentProps) => (\n          <ApolloReactComponents.Query<TestQuery, TestQueryVariables> query={Operations.test} {...props} />\n        );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useQuery and useLazyQuery",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2132,
                "column": 95
            },
            "line": 2132,
            "code": "    it('should import Operations from one external file and use it in useQuery and useLazyQuery', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestQuery(baseOptions?: Apollo.QueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<TestQuery, TestQueryVariables>(Operations.test, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<TestQuery, TestQueryVariables>(Operations.test, options);\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in withQuery",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2163,
                "column": 79
            },
            "line": 2163,
            "code": "    it('should import Operations from one external file and use it in withQuery', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestQuery,\n        TestQueryVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withQuery<TProps, TestQuery, TestQueryVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      };\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in Mutation component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2194,
                "column": 88
            },
            "line": 2194,
            "code": "    it('should import Operations from one external file and use it in Mutation component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestComponent = (props: TestComponentProps) => (\n          <ApolloReactComponents.Mutation<TestMutation, TestMutationVariables> mutation={Operations.test} {...props} />\n        );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useMutation",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2217,
                "column": 81
            },
            "line": 2217,
            "code": "    it('should import Operations from one external file and use it in useMutation', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestMutation(baseOptions?: Apollo.MutationHookOptions<TestMutation, TestMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<TestMutation, TestMutationVariables>(Operations.test, options);\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in withMutation",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2242,
                "column": 82
            },
            "line": 2242,
            "code": "    it('should import Operations from one external file and use it in withMutation', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'mutate'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestMutation,\n        TestMutationVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withMutation<TProps, TestMutation, TestMutationVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in Subscription component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2273,
                "column": 92
            },
            "line": 2273,
            "code": "    it('should import Operations from one external file and use it in Subscription component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestComponent = (props: TestComponentProps) => (\n          <ApolloReactComponents.Subscription<TestSubscription, TestSubscriptionVariables> subscription={Operations.test} {...props} />\n        );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useSubscription",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2296,
                "column": 85
            },
            "line": 2296,
            "code": "    it('should import Operations from one external file and use it in useSubscription', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestSubscription(baseOptions?: Apollo.SubscriptionHookOptions<TestSubscription, TestSubscriptionVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useSubscription<TestSubscription, TestSubscriptionVariables>(Operations.test, options);\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in withSubscription",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2321,
                "column": 86
            },
            "line": 2321,
            "code": "    it('should import Operations from one external file and use it in withSubscription', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestSubscription,\n        TestSubscriptionVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withSubscription<TProps, TestSubscription, TestSubscriptionVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in multiple components",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2352,
                "column": 89
            },
            "line": 2352,
            "code": "    it('should import Operations from one external file and use it in multiple components', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestOneComponent = (props: TestOneComponentProps) => (\n        <ApolloReactComponents.Query<TestOneQuery, TestOneQueryVariables> query={Operations.testOne} {...props} />\n      );`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestTwoComponent = (props: TestTwoComponentProps) => (\n          <ApolloReactComponents.Mutation<TestTwoMutation, TestTwoMutationVariables> mutation={Operations.testTwo} {...props} />\n        );`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestThreeComponent = (props: TestThreeComponentProps) => (\n          <ApolloReactComponents.Subscription<TestThreeSubscription, TestThreeSubscriptionVariables> subscription={Operations.testThree} {...props} />\n        );`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in multiple hooks",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2384,
                "column": 84
            },
            "line": 2384,
            "code": "    it('should import Operations from one external file and use it in multiple hooks', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: '', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestOneQuery(baseOptions?: Apollo.QueryHookOptions<TestOneQuery, TestOneQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<TestOneQuery, TestOneQueryVariables>(Operations.testOne, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestOneLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestOneQuery, TestOneQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<TestOneQuery, TestOneQueryVariables>(Operations.testOne, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestTwoMutation(baseOptions?: Apollo.MutationHookOptions<TestTwoMutation, TestTwoMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<TestTwoMutation, TestTwoMutationVariables>(Operations.testTwo, options);\n      }\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestThreeSubscription(baseOptions?: Apollo.SubscriptionHookOptions<TestThreeSubscription, TestThreeSubscriptionVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useSubscription<TestThreeSubscription, TestThreeSubscriptionVariables>(Operations.testThree, options);\n      }`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in multiple HOCs",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2428,
                "column": 83
            },
            "line": 2428,
            "code": "    it('should import Operations from one external file and use it in multiple HOCs', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: '', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestOne<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestOneQuery,\n        TestOneQueryVariables,\n        TestOneProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withQuery<TProps, TestOneQuery, TestOneQueryVariables, TestOneProps<TChildProps, TDataName>>(Operations.testOne, {\n            alias: 'testOne',\n            ...operationOptions\n          });\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestTwo<TProps, TChildProps = {}, TDataName extends string = 'mutate'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestTwoMutation,\n        TestTwoMutationVariables,\n        TestTwoProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withMutation<TProps, TestTwoMutation, TestTwoMutationVariables, TestTwoProps<TChildProps, TDataName>>(Operations.testTwo, {\n            alias: 'testTwo',\n            ...operationOptions\n          });\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestThree<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestThreeSubscription,\n        TestThreeSubscriptionVariables,\n        TestThreeProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withSubscription<TProps, TestThreeSubscription, TestThreeSubscriptionVariables, TestThreeProps<TChildProps, TDataName>>(Operations.testThree, {\n            alias: 'testThree',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for Query component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2483,
                "column": 77
            },
            "line": 2483,
            "code": "    it('should import Operations from near operation file for Query component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestComponent = (props: TestComponentProps) => (\n          <ApolloReactComponents.Query<TestQuery, TestQueryVariables> query={Operations.test} {...props} />\n        );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useQuery and useLazyQuery",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2506,
                "column": 87
            },
            "line": 2506,
            "code": "    it('should import Operations from near operation file for useQuery and useLazyQuery', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestQuery(baseOptions?: Apollo.QueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<TestQuery, TestQueryVariables>(Operations.test, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestQuery, TestQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<TestQuery, TestQueryVariables>(Operations.test, options);\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for withQuery",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2537,
                "column": 71
            },
            "line": 2537,
            "code": "    it('should import Operations from near operation file for withQuery', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestQuery,\n        TestQueryVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withQuery<TProps, TestQuery, TestQueryVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for Mutation component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2568,
                "column": 80
            },
            "line": 2568,
            "code": "    it('should import Operations from near operation file for Mutation component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: TestComponentProps) => (\n        <ApolloReactComponents.Mutation<TestMutation, TestMutationVariables> mutation={Operations.test} {...props} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useMutation",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2591,
                "column": 73
            },
            "line": 2591,
            "code": "    it('should import Operations from near operation file for useMutation', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestMutation(baseOptions?: Apollo.MutationHookOptions<TestMutation, TestMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<TestMutation, TestMutationVariables>(Operations.test, options);\n      }`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for withMutation",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2615,
                "column": 74
            },
            "line": 2615,
            "code": "    it('should import Operations from near operation file for withMutation', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'mutate'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestMutation,\n        TestMutationVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withMutation<TProps, TestMutation, TestMutationVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for Subscription component",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2646,
                "column": 84
            },
            "line": 2646,
            "code": "    it('should import Operations from near operation file for Subscription component', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: TestComponentProps) => (\n        <ApolloReactComponents.Subscription<TestSubscription, TestSubscriptionVariables> subscription={Operations.test} {...props} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useSubscription",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2669,
                "column": 77
            },
            "line": 2669,
            "code": "    it('should import Operations from near operation file for useSubscription', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestSubscription(baseOptions?: Apollo.SubscriptionHookOptions<TestSubscription, TestSubscriptionVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useSubscription<TestSubscription, TestSubscriptionVariables>(Operations.test, options);\n      }`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for withSubscription",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2693,
                "column": 78
            },
            "line": 2693,
            "code": "    it('should import Operations from near operation file for withSubscription', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTest<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestSubscription,\n        TestSubscriptionVariables,\n        TestProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withSubscription<TProps, TestSubscription, TestSubscriptionVariables, TestProps<TChildProps, TDataName>>(Operations.test, {\n            alias: 'test',\n            ...operationOptions\n          });\n      }\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file and use it in multiple components",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2724,
                "column": 91
            },
            "line": 2724,
            "code": "    it('should import Operations from near operation file and use it in multiple components', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: true,\n        withHooks: false,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestOneComponent = (props: TestOneComponentProps) => (\n        <ApolloReactComponents.Query<TestOneQuery, TestOneQueryVariables> query={Operations.testOne} {...props} />\n      );`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestTwoComponent = (props: TestTwoComponentProps) => (\n          <ApolloReactComponents.Mutation<TestTwoMutation, TestTwoMutationVariables> mutation={Operations.testTwo} {...props} />\n        );`);\n      expect(content.content).toBeSimilarStringTo(`\n        export const TestThreeComponent = (props: TestThreeComponentProps) => (\n          <ApolloReactComponents.Subscription<TestThreeSubscription, TestThreeSubscriptionVariables> subscription={Operations.testThree} {...props} />\n        );`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file and use it in multiple hooks",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2756,
                "column": 86
            },
            "line": 2756,
            "code": "    it('should import Operations from near operation file and use it in multiple hooks', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: true,\n        withHOC: false,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestOneQuery(baseOptions?: Apollo.QueryHookOptions<TestOneQuery, TestOneQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useQuery<TestOneQuery, TestOneQueryVariables>(Operations.testOne, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestOneLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TestOneQuery, TestOneQueryVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useLazyQuery<TestOneQuery, TestOneQueryVariables>(Operations.testOne, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestTwoMutation(baseOptions?: Apollo.MutationHookOptions<TestTwoMutation, TestTwoMutationVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useMutation<TestTwoMutation, TestTwoMutationVariables>(Operations.testTwo, options);\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function useTestThreeSubscription(baseOptions?: Apollo.SubscriptionHookOptions<TestThreeSubscription, TestThreeSubscriptionVariables>) {\n        const options = {...defaultOptions, ...baseOptions}\n        return Apollo.useSubscription<TestThreeSubscription, TestThreeSubscriptionVariables>(Operations.testThree, options);\n      }`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file and use it in multiple HOCs",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2799,
                "column": 85
            },
            "line": 2799,
            "code": "    it('should import Operations from near operation file and use it in multiple HOCs', async () => {\n      const config: ReactApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n        withComponent: false,\n        withHooks: false,\n        withHOC: true,\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.tsx',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestOne<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestOneQuery,\n        TestOneQueryVariables,\n        TestOneProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withQuery<TProps, TestOneQuery, TestOneQueryVariables, TestOneProps<TChildProps, TDataName>>(Operations.testOne, {\n            alias: 'testOne',\n            ...operationOptions\n          });\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestTwo<TProps, TChildProps = {}, TDataName extends string = 'mutate'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestTwoMutation,\n        TestTwoMutationVariables,\n        TestTwoProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withMutation<TProps, TestTwoMutation, TestTwoMutationVariables, TestTwoProps<TChildProps, TDataName>>(Operations.testTwo, {\n            alias: 'testTwo',\n            ...operationOptions\n          });\n      }\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export function withTestThree<TProps, TChildProps = {}, TDataName extends string = 'data'>(operationOptions?: ApolloReactHoc.OperationOption<\n        TProps,\n        TestThreeSubscription,\n        TestThreeSubscriptionVariables,\n        TestThreeProps<TChildProps, TDataName>>) {\n          return ApolloReactHoc.withSubscription<TProps, TestThreeSubscription, TestThreeSubscriptionVariables, TestThreeProps<TChildProps, TDataName>>(Operations.testThree, {\n            alias: 'testThree',\n            ...operationOptions\n          });\n      }\n      `);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and one file",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2855,
                "column": 90
            },
            "line": 2855,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and one file`, async () => {\n      const docs = [\n        {\n          location: 'path/to/document.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'near-operation-file',\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and multiple files",
            "suites": [
                "React Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 2883,
                "column": 96
            },
            "line": 2883,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and multiple files`, async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment1 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n        {\n          location: 'b.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment2 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "react-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-apollo/tests"
        },
        {
            "name": "Duplicated nested fragments are removed",
            "suites": [
                "React-Query"
            ],
            "updatePoint": {
                "line": 24,
                "column": 45
            },
            "line": 24,
            "code": "  it('Duplicated nested fragments are removed', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      schema {\n        query: Query\n      }\n\n      type Query {\n        user(id: ID!): User\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n\n    const ast = parse(/* GraphQL */ `\n      query foo {\n        user1: user(id: 1) {\n          ...userWithEmail\n        }\n        user2: user(id: 2) {\n          ...userWithName\n        }\n      }\n\n      fragment userBase on User {\n        id\n      }\n\n      fragment userWithEmail on User {\n        ...userBase\n        email\n      }\n\n      fragment userWithName on User {\n        ...userBase\n        name\n      }\n    `);\n\n    const res = (await plugin(\n      schema,\n      [{ location: '', document: ast }],\n      { dedupeFragments: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect((res.content.match(/\\{UserBaseFragmentDoc\\}/g) || []).length).toBe(1);\n  });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "should allow to override TError type",
            "suites": [
                "React-Query"
            ],
            "updatePoint": {
                "line": 127,
                "column": 42
            },
            "line": 127,
            "code": "  it('should allow to override TError type', async () => {\n    const config = {\n      errorType: 'any',\n    };\n\n    const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n    expect(out.content).not.toContain(`TError = unknown`);\n    expect(out.content).toContain(`TError = any`);\n  });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with external mapper",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 138,
                "column": 60
            },
            "line": 138,
            "code": "    it('Should generate query correctly with external mapper', async () => {\n      const config = {\n        fetcher: './my-file#myCustomFetcher',\n        typesPrefix: 'T',\n        addInfiniteQuery: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useInfiniteQuery, useMutation, UseQueryOptions, UseInfiniteQueryOptions, UseMutationOptions, QueryFunctionContext } from 'react-query';`\n      );\n\n      expect(out.prepend).toContain(`import { myCustomFetcher } from './my-file';`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n          TData = TTestQuery,\n          TError = unknown\n        >(\n          variables?: TTestQueryVariables,\n          options?: UseQueryOptions<TTestQuery, TError, TData>\n        ) =>\n        useQuery<TTestQuery, TError, TData>(\n          variables === undefined ? ['test'] : ['test', variables],\n          myCustomFetcher<TTestQuery, TTestQueryVariables>(TestDocument, variables),\n          options\n        );`);\n\n      expect(out.content).toBeSimilarStringTo(`export const useInfiniteTestQuery = <\n      TData = TTestQuery,\n      TError = unknown\n    >(\n      variables?: TTestQueryVariables,\n      options?: UseInfiniteQueryOptions<TTestQuery, TError, TData>\n    ) =>{\n    return useInfiniteQuery<TTestQuery, TError, TData>(\n      variables === undefined ? ['test.infinite'] : ['test.infinite', variables],\n      (metaData) => myCustomFetcher<TTestQuery, TTestQueryVariables>(TestDocument, {...variables, ...(metaData.pageParam ?? {})})(),\n      options\n    )};`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>) =>\n      useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n        ['test'],\n        (variables?: TTestMutationVariables) => myCustomFetcher<TTestMutation, TTestMutationVariables>(TestDocument, variables)(),\n        options\n      );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with internal mapper",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 191,
                "column": 60
            },
            "line": 191,
            "code": "    it('Should generate query correctly with internal mapper', async () => {\n      const config = {\n        fetcher: 'myCustomFetcher',\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';`\n      );\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n        TData = TTestQuery,\n        TError = unknown\n      >(\n        variables?: TTestQueryVariables,\n        options?: UseQueryOptions<TTestQuery, TError, TData>\n      ) =>\n      useQuery<TTestQuery, TError, TData>(\n        variables === undefined ? ['test'] : ['test', variables],\n        myCustomFetcher<TTestQuery, TTestQueryVariables>(TestDocument, variables),\n        options\n      );`);\n\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n        TError = unknown,\n        TContext = unknown\n      >(options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>) =>\n      useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n        ['test'],\n        (variables?: TTestMutationVariables) => myCustomFetcher<TTestMutation, TTestMutationVariables>(TestDocument, variables)(),\n        options\n      );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate mutation correctly with lazy variables",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 229,
                "column": 62
            },
            "line": 229,
            "code": "    it('Should generate mutation correctly with lazy variables', async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#useCustomFetcher',\n          isReactHook: true,\n        },\n        typesPrefix: 'T',\n        addInfiniteQuery: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useInfiniteQuery, useMutation, UseQueryOptions, UseInfiniteQueryOptions, UseMutationOptions, QueryFunctionContext } from 'react-query';`\n      );\n      expect(out.prepend).toContain(`import { useCustomFetcher } from './my-file';`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n          TData = TTestQuery,\n          TError = unknown\n        >(\n          variables?: TTestQueryVariables,\n          options?: UseQueryOptions<TTestQuery, TError, TData>\n        ) =>\n        useQuery<TTestQuery, TError, TData>(\n          variables === undefined ? ['test'] : ['test', variables],\n          useCustomFetcher<TTestQuery, TTestQueryVariables>(TestDocument).bind(null, variables),\n          options\n        );`);\n\n      expect(out.content).toBeSimilarStringTo(`export const useInfiniteTestQuery = <\n      TData = TTestQuery,\n      TError = unknown\n    >(\n      variables?: TTestQueryVariables,\n      options?: UseInfiniteQueryOptions<TTestQuery, TError, TData>\n    ) =>{\n      const query = useCustomFetcher<TTestQuery, TTestQueryVariables>(TestDocument)\n      return useInfiniteQuery<TTestQuery, TError, TData>(\n      variables === undefined ? ['test.infinite'] : ['test.infinite', variables],\n      (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),\n      options\n    )};`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n        TError = unknown,\n        TContext = unknown\n      >(options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>) =>\n      useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n        ['test'],\n        useCustomFetcher<TTestMutation, TTestMutationVariables>(TestDocument),\n        options\n      );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should support useTypeImports",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 285,
                "column": 37
            },
            "line": 285,
            "code": "    it('Should support useTypeImports', async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#customFetcher',\n        },\n        useTypeImports: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(`import type { customFetcher } from './my-file';`);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate fetcher field when exposeFetcher is true and the fetcher isn't a react hook",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 298,
                "column": 99
            },
            "line": 298,
            "code": "    it(\"Should generate fetcher field when exposeFetcher is true and the fetcher isn't a react hook\", async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#customFetcher',\n        },\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.fetcher = (variables?: TestQueryVariables, options?: RequestInit['headers']) => customFetcher<TestQuery, TestQueryVariables>(TestDocument, variables, options);`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should NOT generate fetcher field when exposeFetcher is true and the fetcher IS a react hook",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 312,
                "column": 100
            },
            "line": 312,
            "code": "    it('Should NOT generate fetcher field when exposeFetcher is true and the fetcher IS a react hook', async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#useCustomFetcher',\n          isReactHook: true,\n        },\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).not.toBeSimilarStringTo(`useTestQuery.fetcher`);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate mutation fetcher field when exposeFetcher is true and the fetcher isn't a react hook",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 325,
                "column": 108
            },
            "line": 325,
            "code": "    it(\"Should generate mutation fetcher field when exposeFetcher is true and the fetcher isn't a react hook\", async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#customFetcher',\n        },\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestMutation.fetcher = (variables?: TestMutationVariables, options?: RequestInit['headers']) => customFetcher<TestMutation, TestMutationVariables>(TestDocument, variables, options);`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should NOT generate mutation fetcher field when exposeFetcher is true and the fetcher IS a react hook",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper"
            ],
            "updatePoint": {
                "line": 339,
                "column": 109
            },
            "line": 339,
            "code": "    it('Should NOT generate mutation fetcher field when exposeFetcher is true and the fetcher IS a react hook', async () => {\n      const config = {\n        fetcher: {\n          func: './my-file#useCustomFetcher',\n          isReactHook: true,\n        },\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).not.toBeSimilarStringTo(`useTestMutation.fetcher`);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate getKey for each mutation",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper",
                "exposeMutationKeys: true"
            ],
            "updatePoint": {
                "line": 353,
                "column": 50
            },
            "line": 353,
            "code": "      it('Should generate getKey for each mutation', async () => {\n        const config = {\n          fetcher: 'fetch',\n          exposeMutationKeys: true,\n        };\n        const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n        expect(out.content).toBeSimilarStringTo(`useTestMutation.getKey = () => ['test']\\n`);\n      });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "React-Query",
                "fetcher: custom-mapper",
                "exposeMutationKeys: true"
            ],
            "updatePoint": {
                "line": 363,
                "column": 39
            },
            "line": 363,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n      const config = {\n        fetcher: 'myCustomFetcher',\n        typesPrefix: 'T',\n        outputFile: '',\n      };\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, config)) as any).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQueryQuery = ');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with client",
            "suites": [
                "React-Query",
                "fetcher: graphql-request"
            ],
            "updatePoint": {
                "line": 471,
                "column": 51
            },
            "line": 471,
            "code": "    it('Should generate query correctly with client', async () => {\n      const config = {\n        fetcher: 'graphql-request',\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';`\n      );\n      expect(out.prepend).toContain(`import { GraphQLClient } from 'graphql-request';`);\n      expect(out.prepend).toContain(`import { RequestInit } from 'graphql-request/dist/types.dom';`);\n      expect(out.prepend[3])\n        .toBeSimilarStringTo(`    function fetcher<TData, TVariables>(client: GraphQLClient, query: string, variables?: TVariables, headers?: RequestInit['headers']) {\n          return async (): Promise<TData> => client.request<TData, TVariables>(query, variables, headers);\n        }`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n      TData = TTestQuery,\n      TError = unknown\n    >(\n      client: GraphQLClient,\n      variables?: TTestQueryVariables,\n      options?: UseQueryOptions<TTestQuery, TError, TData>,\n      headers?: RequestInit['headers']\n    ) =>\n    useQuery<TTestQuery, TError, TData>(\n      variables === undefined ? ['test'] : ['test', variables],\n      fetcher<TTestQuery, TTestQueryVariables>(client, TestDocument, variables, headers),\n      options\n    );`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n      TError = unknown,\n      TContext = unknown\n    >(\n      client: GraphQLClient,\n      options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>,\n      headers?: RequestInit['headers']\n    ) =>\n    useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n      ['test'],\n      (variables?: TTestMutationVariables) => fetcher<TTestMutation, TTestMutationVariables>(client, TestDocument, variables, headers)(),\n      options\n    );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should support useTypeImports",
            "suites": [
                "React-Query",
                "fetcher: graphql-request"
            ],
            "updatePoint": {
                "line": 519,
                "column": 37
            },
            "line": 519,
            "code": "    it('Should support useTypeImports', async () => {\n      const config = {\n        fetcher: 'graphql-request',\n        useTypeImports: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(`import type { GraphQLClient } from 'graphql-request';`);\n      expect(out.prepend).toContain(\n        `import { useQuery, useMutation, type UseQueryOptions, type UseMutationOptions } from 'react-query';`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate fetcher field when exposeFetcher is true",
            "suites": [
                "React-Query",
                "fetcher: graphql-request"
            ],
            "updatePoint": {
                "line": 532,
                "column": 64
            },
            "line": 532,
            "code": "    it('Should generate fetcher field when exposeFetcher is true', async () => {\n      const config = {\n        fetcher: 'graphql-request',\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.fetcher = (client: GraphQLClient, variables?: TestQueryVariables, headers?: RequestInit['headers']) => fetcher<TestQuery, TestQueryVariables>(client, TestDocument, variables, headers);`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "React-Query",
                "fetcher: graphql-request"
            ],
            "updatePoint": {
                "line": 543,
                "column": 39
            },
            "line": 543,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n      const config = {\n        fetcher: 'graphql-request',\n        typesPrefix: 'T',\n      };\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, config)) as any).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQueryQuery = ');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with hardcoded endpoint",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 650,
                "column": 63
            },
            "line": 650,
            "code": "    it('Should generate query correctly with hardcoded endpoint', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'http://localhost:3000/graphql',\n        },\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';`\n      );\n      expect(out.prepend[1])\n        .toBeSimilarStringTo(`    function fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n        return async (): Promise<TData> => {\n          const res = await fetch(\"http://localhost:3000/graphql\", {\n            method: \"POST\",\n            body: JSON.stringify({ query, variables }),\n          });\n\n          const json = await res.json();\n\n          if (json.errors) {\n            const { message } = json.errors[0];\n\n            throw new Error(message);\n          }\n\n          return json.data;\n        }\n      }`);\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n        TData = TTestQuery,\n        TError = unknown\n      >(\n        variables?: TTestQueryVariables,\n        options?: UseQueryOptions<TTestQuery, TError, TData>\n      ) =>\n      useQuery<TTestQuery, TError, TData>(\n        variables === undefined ? ['test'] : ['test', variables],\n        fetcher<TTestQuery, TTestQueryVariables>(TestDocument, variables),\n        options\n      );`);\n\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n        TError = unknown,\n        TContext = unknown\n      >(options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>) =>\n      useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n        ['test'],\n        (variables?: TTestMutationVariables) => fetcher<TTestMutation, TTestMutationVariables>(TestDocument, variables)(),\n        options\n      );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with fetch config",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 709,
                "column": 57
            },
            "line": 709,
            "code": "    it('Should generate query correctly with fetch config', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'http://localhost:3000/graphql',\n          fetchParams: JSON.stringify({\n            headers: {\n              Authorization: 'Bearer XYZ',\n            },\n          }),\n        },\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend[1]).toMatchInlineSnapshot(`\n\"\nfunction fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n  return async (): Promise<TData> => {\n    const res = await fetch(\\\\\"http://localhost:3000/graphql\\\\\", {\n    method: \\\\\"POST\\\\\",\n    ...({\\\\\"headers\\\\\":{\\\\\"Authorization\\\\\":\\\\\"Bearer XYZ\\\\\"}}),\n      body: JSON.stringify({ query, variables }),\n    });\n\n    const json = await res.json();\n\n    if (json.errors) {\n      const { message } = json.errors[0];\n\n      throw new Error(message);\n    }\n\n    return json.data;\n  }\n}\"\n`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with fetch config and fetchParams object",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 751,
                "column": 80
            },
            "line": 751,
            "code": "    it('Should generate query correctly with fetch config and fetchParams object', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'http://localhost:3000/graphql',\n          fetchParams: {\n            headers: {\n              Authorization: 'Bearer XYZ',\n            },\n          },\n        },\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend[1]).toMatchInlineSnapshot(`\n\"\nfunction fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n  return async (): Promise<TData> => {\n    const res = await fetch(\\\\\"http://localhost:3000/graphql\\\\\", {\n    method: \\\\\"POST\\\\\",\n    ...({\\\\\"headers\\\\\":{\\\\\"Authorization\\\\\":\\\\\"Bearer XYZ\\\\\"}}),\n      body: JSON.stringify({ query, variables }),\n    });\n\n    const json = await res.json();\n\n    if (json.errors) {\n      const { message } = json.errors[0];\n\n      throw new Error(message);\n    }\n\n    return json.data;\n  }\n}\"\n`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with hardcoded endpoint from env var",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 793,
                "column": 76
            },
            "line": 793,
            "code": "    it('Should generate query correctly with hardcoded endpoint from env var', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'process.env.ENDPOINT_URL',\n        },\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend[1])\n        .toBeSimilarStringTo(`function fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n        return async (): Promise<TData> => {\n          const res = await fetch(process.env.ENDPOINT_URL as string, {\n            method: \"POST\",\n            body: JSON.stringify({ query, variables }),\n          });\n\n          const json = await res.json();\n\n          if (json.errors) {\n            const { message } = json.errors[0];\n\n            throw new Error(message);\n          }\n\n          return json.data;\n        }\n      }`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query correctly with hardcoded endpoint from just identifier",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 827,
                "column": 84
            },
            "line": 827,
            "code": "    it('Should generate query correctly with hardcoded endpoint from just identifier', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'myEndpoint',\n        },\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend[1])\n        .toBeSimilarStringTo(`    function fetcher<TData, TVariables>(query: string, variables?: TVariables) {\n        return async (): Promise<TData> => {\n          const res = await fetch(myEndpoint as string, {\n            method: \"POST\",\n            body: JSON.stringify({ query, variables }),\n          });\n\n          const json = await res.json();\n\n          if (json.errors) {\n            const { message } = json.errors[0];\n\n            throw new Error(message);\n          }\n\n          return json.data;\n        }\n      }`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate fetcher field when exposeFetcher is true",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 861,
                "column": 64
            },
            "line": 861,
            "code": "    it('Should generate fetcher field when exposeFetcher is true', async () => {\n      const config = {\n        fetcher: {\n          endpoint: 'myEndpoint',\n        },\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.fetcher = (variables?: TestQueryVariables) => fetcher<TestQuery, TestQueryVariables>(TestDocument, variables);`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "React-Query",
                "fetcher: hardcoded-fetch"
            ],
            "updatePoint": {
                "line": 875,
                "column": 39
            },
            "line": 875,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n      const config = {\n        fetcher: {\n          endpoint: 'http://localhost:3000/graphql',\n        },\n        typesPrefix: 'T',\n      };\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, config)) as any).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQueryQuery = ');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate query and mutation correctly",
            "suites": [
                "React-Query",
                "fetcher: fetch"
            ],
            "updatePoint": {
                "line": 984,
                "column": 52
            },
            "line": 984,
            "code": "    it('Should generate query and mutation correctly', async () => {\n      const config = {\n        fetcher: 'fetch',\n        typesPrefix: 'T',\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n\n      expect(out.prepend).toContain(\n        `import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from 'react-query';`\n      );\n\n      expect(out.content).toBeSimilarStringTo(`export const useTestQuery = <\n        TData = TTestQuery,\n        TError = unknown\n      >(\n        dataSource: { endpoint: string, fetchParams?: RequestInit },\n        variables?: TTestQueryVariables,\n        options?: UseQueryOptions<TTestQuery, TError, TData>\n      ) =>\n      useQuery<TTestQuery, TError, TData>(\n        variables === undefined ? ['test'] : ['test', variables],\n        fetcher<TTestQuery, TTestQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, TestDocument, variables),\n        options\n      );`);\n\n      expect(out.content).toBeSimilarStringTo(`export const useTestMutation = <\n          TError = unknown,\n          TContext = unknown\n        >(\n          dataSource: { endpoint: string, fetchParams?: RequestInit },\n          options?: UseMutationOptions<TTestMutation, TError, TTestMutationVariables, TContext>\n        ) =>\n        useMutation<TTestMutation, TError, TTestMutationVariables, TContext>(\n          ['test'],\n          (variables?: TTestMutationVariables) => fetcher<TTestMutation, TTestMutationVariables>(dataSource.endpoint, dataSource.fetchParams || {}, TestDocument, variables)(),\n          options\n        );`);\n\n      expect(out.content).toMatchSnapshot();\n      await validateTypeScript(mergeOutputs(out), schema, docs, config);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate fetcher field when exposeFetcher is true",
            "suites": [
                "React-Query",
                "fetcher: fetch"
            ],
            "updatePoint": {
                "line": 1027,
                "column": 64
            },
            "line": 1027,
            "code": "    it('Should generate fetcher field when exposeFetcher is true', async () => {\n      const config = {\n        exposeFetcher: true,\n      };\n\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.fetcher = (dataSource: { endpoint: string, fetchParams?: RequestInit }, variables?: TestQueryVariables) => fetcher<TestQuery, TestQueryVariables>(dataSource.endpoint, dataSource.fetchParams || {}, TestDocument, variables);`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "React-Query",
                "fetcher: fetch"
            ],
            "updatePoint": {
                "line": 1038,
                "column": 39
            },
            "line": 1038,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n      const config = {\n        fetcher: 'fetch',\n        typesPrefix: 'T',\n      };\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, config)) as any).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQueryQuery = ');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('fetcher<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            config\n          )) as any\n        ).content\n      ).toContain('export const useNotificationsQuery =');\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate document field for each query",
            "suites": [
                "React-Query",
                "exposeDocument: true"
            ],
            "updatePoint": {
                "line": 1145,
                "column": 53
            },
            "line": 1145,
            "code": "    it('Should generate document field for each query', async () => {\n      const config = {\n        fetcher: 'fetch',\n        exposeDocument: true,\n      };\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(`useTestQuery.document = TestDocument;`);\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate getKey for each query",
            "suites": [
                "React-Query",
                "exposeQueryKeys: true"
            ],
            "updatePoint": {
                "line": 1156,
                "column": 45
            },
            "line": 1156,
            "code": "    it('Should generate getKey for each query', async () => {\n      const config = {\n        fetcher: 'fetch',\n        exposeQueryKeys: true,\n      };\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.getKey = (variables?: TestQueryVariables) => variables === undefined ? ['test'] : ['test', variables];`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should generate getKey for each query - also infinite queries",
            "suites": [
                "React-Query",
                "exposeQueryKeys: true, addInfiniteQuery: true"
            ],
            "updatePoint": {
                "line": 1169,
                "column": 69
            },
            "line": 1169,
            "code": "    it('Should generate getKey for each query - also infinite queries', async () => {\n      const config = {\n        fetcher: 'fetch',\n        exposeQueryKeys: true,\n        addInfiniteQuery: true,\n      };\n      const out = (await plugin(schema, docs, config)) as Types.ComplexPluginOutput;\n      expect(out.content).toBeSimilarStringTo(\n        `useTestQuery.getKey = (variables?: TestQueryVariables) => variables === undefined ? ['test'] : ['test', variables];`\n      );\n      expect(out.content).toBeSimilarStringTo(\n        `useInfiniteTestQuery.getKey = (variables?: TestQueryVariables) => variables === undefined ? ['test.infinite'] : ['test.infinite', variables];`\n      );\n    });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Should not generate fetcher if there are no operations",
            "suites": [
                "React-Query",
                "exposeQueryKeys: true, addInfiniteQuery: true"
            ],
            "updatePoint": {
                "line": 1185,
                "column": 60
            },
            "line": 1185,
            "code": "  it('Should not generate fetcher if there are no operations', async () => {\n    const out = (await plugin(schema, notOperationDocs, {})) as Types.ComplexPluginOutput;\n    expect(out.prepend).not.toBeSimilarStringTo(`function fetcher<TData, TVariables>(`);\n\n    const config = {\n      fetcher: 'graphql-request',\n    };\n\n    const outGraphqlRequest = (await plugin(schema, notOperationDocs, config)) as Types.ComplexPluginOutput;\n    expect(outGraphqlRequest.prepend).not.toContain(`import { GraphQLClient } from 'graphql-request';`);\n  });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "Parses process.env variables correctly",
            "suites": [
                "React-Query",
                "exposeQueryKeys: true, addInfiniteQuery: true"
            ],
            "updatePoint": {
                "line": 1197,
                "column": 44
            },
            "line": 1197,
            "code": "  it('Parses process.env variables correctly', async () => {\n    const outGraphqlRequest = (await plugin(schema, docs, {\n      fetcher: {\n        endpoint: 'process.env.ENDPOINT',\n        fetchParams: `\n          {\n            headers: {\n              apiKey: process.env.APIKEY as string,\n              somethingElse: process.env.SOMETHING as string\n            },\n          }`,\n      },\n    })) as Types.ComplexPluginOutput;\n\n    expect(outGraphqlRequest.prepend).toBeSimilarStringTo(`\n    const res = await fetch(process.env.ENDPOINT as string, {\n      method: \"POST\", ...(\n                {\n                  headers: {\n                    apiKey: process.env.APIKEY as string,\n                    somethingElse: process.env.SOMETHING as string\n                  },\n                }),\n            body: JSON.stringify({ query, variables }),\n          });\n    `);\n  });",
            "file": "react-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/react-query/tests"
        },
        {
            "name": "should add __resolveReference to objects that have @key",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 27,
                "column": 61
            },
            "line": 27,
            "code": "  it('should add __resolveReference to objects that have @key', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        allUsers: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n    // Foo shouldn't because it doesn't have @key\n    expect(content).not.toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['Book']>, { __typename: 'Book' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support extend keyword",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 61,
                "column": 35
            },
            "line": 61,
            "code": "  it('should support extend keyword', async () => {\n    const federatedSchema = /* GraphQL */ `\n      extend type Query {\n        allUsers: [User]\n      }\n\n      extend type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n    // Foo shouldn't because it doesn't have @key\n    expect(content).not.toBeSimilarStringTo(`\n      __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['Book']>, { __typename: 'Book' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should include fields from @requires directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 95,
                "column": 52
            },
            "line": 95,
            "code": "  it('should include fields from @requires directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String @external\n        age: Int! @external\n        username: String @requires(fields: \"name age\")\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}> & GraphQLRecursivePick<ParentType, {\"name\":true,\"age\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle nested fields from @requires directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 127,
                "column": 58
            },
            "line": 127,
            "code": "  it('should handle nested fields from @requires directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      extend type User @key(fields: \"id\") {\n        id: ID! @external\n        name: String @external\n        age: Int! @external\n        address: Address! @external\n        username: String @requires(fields: \"name age address { street }\")\n      }\n\n      extend type Address {\n        street: String! @external\n        zip: Int! @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}> & GraphQLRecursivePick<ParentType, {\"name\":true,\"age\":true,\"address\":{\"street\":true}}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle nested fields from @key directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 163,
                "column": 53
            },
            "line": 163,
            "code": "  it('should handle nested fields from @key directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"name { first last }\") {\n        name: Name! @external\n        username: String\n      }\n\n      type Name {\n        first: String! @external\n        last: String! @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not apply key/requires fields restriction for base federated types",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 196,
                "column": 79
            },
            "line": 196,
            "code": "  it('should not apply key/requires fields restriction for base federated types', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"name { first last }\") {\n        name: Name!\n        username: String\n      }\n\n      type Name {\n        first: String!\n        last: String!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"name\":{\"first\":true,\"last\":true}}>, ContextType>;\n        name?: Resolver<ResolversTypes['Name'], ParentType, ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should handle interface types",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "line": 230,
            "code": "  it.skip('should handle interface types', async () => {",
            "file": "federation.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should skip to generate resolvers of fields with @external directive",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 274,
                "column": 74
            },
            "line": 274,
            "code": "  it('should skip to generate resolvers of fields with @external directive', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type Book {\n        author: User @provides(fields: \"name\")\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String @external\n        username: String @external\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // UserResolver should not have a resolver function of name field\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        name?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & GraphQLRecursivePick<ParentType, {\"id\":true}>, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not include _FieldSet scalar",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 309,
                "column": 41
            },
            "line": 309,
            "code": "  it('should not include _FieldSet scalar', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch(`_FieldSet`);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not include federation directives",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 336,
                "column": 46
            },
            "line": 336,
            "code": "  it('should not include federation directives', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        users: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch('ExternalDirectiveResolver');\n    expect(content).not.toMatch('RequiresDirectiveResolver');\n    expect(content).not.toMatch('ProvidesDirectiveResolver');\n    expect(content).not.toMatch('KeyDirectiveResolver');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not add directive definitions and scalars if they are already there",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 366,
                "column": 80
            },
            "line": 366,
            "code": "  it('should not add directive definitions and scalars if they are already there', async () => {\n    const federatedSchema = /* GraphQL */ `\n      scalar _FieldSet\n\n      directive @key(fields: _FieldSet!) on OBJECT | INTERFACE\n\n      type Query {\n        allUsers: [User]\n      }\n\n      type User @key(fields: \"id\") {\n        id: ID!\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    expect(content).not.toMatch(`_FieldSet`);\n    expect(content).not.toMatch('ExternalDirectiveResolver');\n    expect(content).not.toMatch('RequiresDirectiveResolver');\n    expect(content).not.toMatch('ProvidesDirectiveResolver');\n    expect(content).not.toMatch('KeyDirectiveResolver');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should allow for duplicated directives",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 401,
                "column": 44
            },
            "line": 401,
            "code": "  it('should allow for duplicated directives', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        allUsers: [User]\n      }\n\n      extend type User @key(fields: \"id\") @key(fields: \"name\") {\n        id: ID! @external\n        name: String\n        username: String\n      }\n\n      type Book {\n        id: ID!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // User should have it\n    expect(content).toBeSimilarStringTo(`\n      export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        name?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        username?: Resolver<Maybe<ResolversTypes['String']>, { __typename: 'User' } & (GraphQLRecursivePick<ParentType, {\"id\":true}> | GraphQLRecursivePick<ParentType, {\"name\":true}>), ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should only extend an original type by a mapped type",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "line": 436,
            "code": "  it.skip('should only extend an original type by a mapped type', async () => {",
            "file": "federation.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not generate unused scalars",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation"
            ],
            "updatePoint": {
                "line": 470,
                "column": 40
            },
            "line": 470,
            "code": "  it('should not generate unused scalars', async () => {\n    const federatedSchema = /* GraphQL */ `\n      type Query {\n        user(id: ID!): User!\n      }\n\n      type User {\n        id: ID!\n        username: String!\n      }\n    `;\n\n    const content = await generate({\n      schema: federatedSchema,\n      config: {\n        federation: true,\n      },\n    });\n\n    // no GraphQLScalarTypeConfig\n    expect(content).not.toContain('GraphQLScalarTypeConfig');\n    // no GraphQLScalarType\n    expect(content).not.toContain('GraphQLScalarType');\n  });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should add the UnwrappedObject type",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation",
                "When field definition wrapping is enabled"
            ],
            "updatePoint": {
                "line": 496,
                "column": 43
            },
            "line": 496,
            "code": "    it('should add the UnwrappedObject type', async () => {\n      const federatedSchema = /* GraphQL */ `\n        type User @key(fields: \"id\") {\n          id: ID!\n        }\n      `;\n\n      const content = await generate({\n        schema: federatedSchema,\n        config: {\n          federation: true,\n          wrapFieldDefinitions: true,\n        },\n      });\n\n      expect(content).toBeSimilarStringTo(`type UnwrappedObject<T> = {`);\n    });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should add UnwrappedObject around ParentType for __resloveReference",
            "suites": [
                "TypeScript Resolvers Plugin + Apollo Federation",
                "When field definition wrapping is enabled"
            ],
            "updatePoint": {
                "line": 514,
                "column": 75
            },
            "line": 514,
            "code": "    it('should add UnwrappedObject around ParentType for __resloveReference', async () => {\n      const federatedSchema = /* GraphQL */ `\n        type User @key(fields: \"id\") {\n          id: ID!\n        }\n      `;\n\n      const content = await generate({\n        schema: federatedSchema,\n        config: {\n          federation: true,\n          wrapFieldDefinitions: true,\n        },\n      });\n\n      // __resolveReference should be unwrapped\n      expect(content).toBeSimilarStringTo(`\n        __resolveReference?: ReferenceResolver<Maybe<ResolversTypes['User']>, { __typename: 'User' } & GraphQLRecursivePick<UnwrappedObject<ParentType>, {\"id\":true}>, ContextType>;\n      `);\n      // but ID should not\n      expect(content).toBeSimilarStringTo(`id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>`);\n    });",
            "file": "federation.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes object when there are no mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 8,
                "column": 66
            },
            "line": 8,
            "code": "  it('Should build ResolversTypes object when there are no mappers', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Child>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with simple mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 30,
                "column": 53
            },
            "line": 30,
            "code": "  it('Should build ResolversTypes with simple mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'number',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyTypeDb>;\n        String: ResolverTypeWrapper<number>;\n        Child: ResolverTypeWrapper<Omit<Child, 'bar' | 'parent'> & { bar: ResolversTypes['String'], parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<Omit<MyOtherType, 'bar'> & { bar: ResolversTypes['String'] }>;\n        ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 63,
                "column": 70
            },
            "line": 63,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Movie {\n        id: ID!\n        title: String!\n      }\n\n      type Book {\n        id: ID!\n        author: String!\n      }\n\n      union MovieLike = Movie | Book\n\n      type NonInterfaceHasNarrative {\n        narrative: MovieLike!\n        movie: Movie!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Movie: 'MovieEntity',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n    expect(content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Movie: ResolverTypeWrapper<MovieEntity>;\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Book: ResolverTypeWrapper<Book>;\n        MovieLike: ResolversTypes['Movie'] | ResolversTypes['Book'];\n        NonInterfaceHasNarrative: ResolverTypeWrapper<Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversTypes['MovieLike'], movie: ResolversTypes['Movie'] }>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770, attempt #2)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 107,
                "column": 82
            },
            "line": 107,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770, attempt #2)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Movie {\n        id: ID!\n        title: String!\n      }\n\n      type Book {\n        id: ID!\n        author: String!\n      }\n\n      union MovieLike = Movie | Book\n\n      type NonInterfaceHasNarrative {\n        narrative: MovieLike!\n        movie: Movie!\n      }\n\n      type LayerOfIndirection {\n        id: ID!\n        movies: [NonInterfaceHasNarrative!]!\n      }\n\n      type AnotherLayerOfIndirection {\n        inner: LayerOfIndirection!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Movie: 'MovieEntity',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n    expect(content).toBeSimilarStringTo(`export type ResolversTypes = {\n      Movie: ResolverTypeWrapper<MovieEntity>;\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Book: ResolverTypeWrapper<Book>;\n      MovieLike: ResolversTypes['Movie'] | ResolversTypes['Book'];\n      NonInterfaceHasNarrative: ResolverTypeWrapper<Omit<NonInterfaceHasNarrative, 'narrative' | 'movie'> & { narrative: ResolversTypes['MovieLike'], movie: ResolversTypes['Movie'] }>;\n      LayerOfIndirection: ResolverTypeWrapper<Omit<LayerOfIndirection, 'movies'> & { movies: Array<ResolversTypes['NonInterfaceHasNarrative']> }>;\n      AnotherLayerOfIndirection: ResolverTypeWrapper<Omit<AnotherLayerOfIndirection, 'inner'> & { inner: ResolversTypes['LayerOfIndirection'] }>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to map custom type that refers itself (issue #1770, attempt #3 - circular)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 160,
                "column": 93
            },
            "line": 160,
            "code": "  it('Should allow to map custom type that refers itself (issue #1770, attempt #3 - circular)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Account {\n        id: ID!\n        name: String!\n        programs: [Program!]!\n      }\n\n      type Program {\n        id: ID!\n        name: String!\n        account: Account!\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        typesPrefix: 'Gql',\n        defaultMapper: 'Partial<{T}>',\n        namingConvention: {\n          typeNames: 'change-case-all#pascalCase',\n          enumValues: 'change-case-all#upperCase',\n        },\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([result]);\n\n    expect(content).toBeSimilarStringTo(`export type GqlResolversTypes = {\n      Account: ResolverTypeWrapper<Partial<GqlAccount>>;\n      ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n      String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n      Program: ResolverTypeWrapper<Partial<GqlProgram>>;\n      Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should map to a custom type on every level (+ actual usage in code)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 199,
                "column": 73
            },
            "line": 199,
            "code": "  it('should map to a custom type on every level (+ actual usage in code)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type User {\n        id: ID!\n        name: String!\n        chats: [Chat!]\n      }\n\n      type Chat {\n        id: ID!\n        owner: User!\n        members: [User!]\n      }\n\n      type Query {\n        me: User\n      }\n    `);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          ID: 'number',\n          Chat: 'number',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    const usage = `\n      const resolvers: Resolvers = {\n        Query: {\n          me() {\n            return {\n              id: 1,\n              name: 'Foo',\n              chats: [0,1,2],\n            };\n          }\n        },\n        Chat: {\n          id(parent) {\n            const id: number = parent;\n            return id;\n          }\n        }\n      }\n    `;\n\n    await validate(\n      mergeOutputs([usage, result]),\n      {\n        scalars: {\n          ID: 'number',\n        },\n      },\n      testSchema\n    );\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T}",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 261,
                "column": 66
            },
            "line": 261,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T}', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: 'Partial<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Partial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n      String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n      Child: ResolverTypeWrapper<Partial<Child>>;\n      MyOtherType: ResolverTypeWrapper<Partial<MyOtherType>>;\n      ChildUnion: Partial<ResolversTypes['Child'] | ResolversTypes['MyOtherType']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n      SomeNode: ResolverTypeWrapper<Partial<SomeNode>>;\n      MyUnion: Partial<ResolversTypes['MyType'] | ResolversTypes['MyOtherType']>;\n      MyScalar: ResolverTypeWrapper<Partial<Scalars['MyScalar']>>;\n      Int: ResolverTypeWrapper<Partial<Scalars['Int']>>;\n      Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set using {T} with external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 291,
                "column": 91
            },
            "line": 291,
            "code": "  it('Should build ResolversTypes with defaultMapper set using {T} with external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: './my-wrapper#CustomPartial<{T}>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { CustomPartial } from './my-wrapper';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<CustomPartial<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>>;\n      String: ResolverTypeWrapper<CustomPartial<Scalars['String']>>;\n      Child: ResolverTypeWrapper<CustomPartial<Child>>;\n      MyOtherType: ResolverTypeWrapper<CustomPartial<MyOtherType>>;\n      ChildUnion: CustomPartial<ResolversTypes['Child'] | ResolversTypes['MyOtherType']>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<CustomPartial<Scalars['ID']>>;\n      SomeNode: ResolverTypeWrapper<CustomPartial<SomeNode>>;\n      MyUnion: CustomPartial<ResolversTypes['MyType'] | ResolversTypes['MyOtherType']>;\n      MyScalar: ResolverTypeWrapper<CustomPartial<Scalars['MyScalar']>>;\n      Int: ResolverTypeWrapper<CustomPartial<Scalars['Int']>>;\n      Boolean: ResolverTypeWrapper<CustomPartial<Scalars['Boolean']>>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using {T} with external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 322,
                "column": 102
            },
            "line": 322,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using {T} with external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-wrapper#CustomPartial<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { CustomPartial } from './my-wrapper';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<CustomPartial<MyType>>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should map to a custom type on every level when {T} is used as default mapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 355,
                "column": 83
            },
            "line": 355,
            "code": "  it('Should map to a custom type on every level when {T} is used as default mapper', async () => {\n    const config = {\n      scalars: {\n        ID: 'number',\n      },\n      noSchemaStitching: true,\n      defaultMapper: 'Partial<{T}>',\n      mappers: {\n        User: 'number',\n      },\n    };\n    const testSchema = buildSchema(/* GraphQL */ `\n      type User {\n        id: ID!\n        name: String!\n        chats: [Chat!]\n      }\n\n      type Chat {\n        id: ID!\n        owner: User!\n        members: [User!]\n      }\n\n      type Query {\n        me: User\n      }\n    `);\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        User: ResolverTypeWrapper<number>;\n        ID: ResolverTypeWrapper<Partial<Scalars['ID']>>;\n        String: ResolverTypeWrapper<Partial<Scalars['String']>>;\n        Chat: ResolverTypeWrapper<Partial<Omit<Chat, 'owner' | 'members'> & { owner: ResolversTypes['User'], members?: Maybe<Array<ResolversTypes['User']>> }>>;\n        Query: ResolverTypeWrapper<{}>;\n        Boolean: ResolverTypeWrapper<Partial<Scalars['Boolean']>>;\n      };\n    `);\n\n    const usage = `\n      const resolvers: Resolvers = {\n        Query: {\n          me() {\n            return 1;\n          }\n        },\n        Chat: {\n          id(chat) {\n            return chat.id;\n          },\n          owner(chat) {\n            const id: number = chat.owner;\n            return id;\n          },\n          members(chat) {\n            const ids: number[] = chat.members;\n            return ids;\n          }\n        },\n        User: {\n          id(parent) {\n            const id: number = parent;\n            return id;\n          }\n        }\n      }\n    `;\n\n    await validate(mergeOutputs([result, usage]), config, testSchema);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 428,
                "column": 101
            },
            "line": 428,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyType as DatabaseMyType } from './my-type';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default)",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 461,
                "column": 116
            },
            "line": 461,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default)', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-type#default as DatabaseMyOtherType',\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import DatabaseMyOtherType, { MyType as DatabaseMyType } from './my-type';`);\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<DatabaseMyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default) and type import",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 495,
                "column": 132
            },
            "line": 495,
            "code": "  it('Should build ResolversTypes with mapper set for concrete type using renamed external identifier (with default) and type import', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-type#default as DatabaseMyOtherType',\n          MyType: './my-type#MyType as DatabaseMyType',\n        },\n        useTypeImports: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(\n      `import type { default as DatabaseMyOtherType, MyType as DatabaseMyType } from './my-type';`\n    );\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<DatabaseMyType>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<DatabaseMyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with defaultMapper set",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 532,
                "column": 56
            },
            "line": 532,
            "code": "  it('Should build ResolversTypes with defaultMapper set', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: 'MyTypeDb',\n          String: 'string',\n        },\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>;\n      String: ResolverTypeWrapper<string>;\n      Child: ResolverTypeWrapper<any>;\n      MyOtherType: ResolverTypeWrapper<any>;\n      ChildUnion: ResolverTypeWrapper<any>;\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<any>;\n      SomeNode: ResolverTypeWrapper<any>;\n      MyUnion: ResolverTypeWrapper<any>;\n      MyScalar: ResolverTypeWrapper<any>;\n      Int: ResolverTypeWrapper<any>;\n      Boolean: ResolverTypeWrapper<any>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 566,
                "column": 55
            },
            "line": 566,
            "code": "  it('Should build ResolversTypes with external mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-module#CustomMyOtherType',\n          MyType: 'MyTypeDb',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeDb>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<CustomMyOtherType>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should handle {T} in a mapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 599,
                "column": 35
            },
            "line": 599,
            "code": "  it('Should handle {T} in a mapper', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: 'Partial<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Partial<MyType>>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<MyOtherType>;\n        ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should warn about unused mappers by default",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 632,
                "column": 49
            },
            "line": 632,
            "code": "  it('should warn about unused mappers by default', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).toHaveBeenCalledWith('Unused mappers: Post');\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should be able not to warn about unused mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 670,
                "column": 53
            },
            "line": 670,
            "code": "  it('should be able not to warn about unused mappers', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        comments: [Comment!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n\n      type Comment {\n        id: ID!\n        text: String!\n        author: User!\n      }\n    `);\n\n    await plugin(\n      testSchema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Comment: 'number',\n          Post: 'string',\n        },\n        showUnusedMappers: false,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n\n    expect(spy).not.toHaveBeenCalled();\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 709,
                "column": 64
            },
            "line": 709,
            "code": "  it('Should generate basic type resolvers with external mappers', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n          bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n        };\n      `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n        }\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with external mappers using same imported type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 791,
                "column": 89
            },
            "line": 791,
            "code": "  it('Should generate basic type resolvers with external mappers using same imported type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyType: './my-file#MyCustomOtherType',\n          MyOtherType: './my-file#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomOtherType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n          bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n          __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n        };\n      `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n        }\n      `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolvers when used with mappers with interfaces",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 874,
                "column": 82
            },
            "line": 874,
            "code": "  it('Should generate the correct resolvers when used with mappers with interfaces', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          Node: 'MyNodeType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await validate(mergeOutputs([result, `type MyNodeType = {};`]));\n\n    spy.mockRestore();\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to any",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 957,
                "column": 72
            },
            "line": 957,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to any', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: 'any',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with defaultMapper set to external identifier",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1025,
                "column": 88
            },
            "line": 1025,
            "code": "  it('Should generate basic type resolvers with defaultMapper set to external identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        defaultMapper: './my-file#MyBaseType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyBaseType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n        name: 'MyScalar';\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n    await validate(result);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1095,
                "column": 79
            },
            "line": 1095,
            "code": "  it('Should replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    await validate(mergeOutputs([result, 'type MyOtherTypeCustom = {};']));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not replace using Omit when non-mapped type is pointing to mapped type",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1128,
                "column": 83
            },
            "line": 1128,
            "code": "  it('Should not replace using Omit when non-mapped type is pointing to mapped type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: 'MyOtherTypeCustom',\n          MyType: 'MyTypeCustom',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversTypes = {\n      MyType: ResolverTypeWrapper<MyTypeCustom>;\n      String: ResolverTypeWrapper<Scalars['String']>;\n      Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n      MyOtherType: ResolverTypeWrapper<MyOtherTypeCustom>;\n      ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n      Query: ResolverTypeWrapper<{}>;\n      Subscription: ResolverTypeWrapper<{}>;\n      Node: ResolversTypes['SomeNode'];\n      ID: ResolverTypeWrapper<Scalars['ID']>;\n      SomeNode: ResolverTypeWrapper<SomeNode>;\n      MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n      MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n      Int: ResolverTypeWrapper<Scalars['Int']>;\n      Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n    };`);\n    await validate(mergeOutputs([result, `type MyTypeCustom = {}; type MyOtherTypeCustom = {};`]));\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should build ResolversTypes object when there are no mappers",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1162,
                "column": 66
            },
            "line": 1162,
            "code": "  it('Should build ResolversTypes object when there are no mappers', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Child>;\n        MyOtherType: ResolverTypeWrapper<MyOtherType>;\n        ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1185,
                "column": 31
            },
            "line": 1185,
            "code": "  it('should support namespaces', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        mappers: {\n          MyOtherType: './my-file#MyNamespace#MyCustomOtherType',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversTypes['MyOtherType']>, unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyCustomOtherType>;\n        ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: Omit<MyType, 'otherType' | 'unionChild'> & { otherType?: Maybe<ResolversParentTypes['MyOtherType']>, unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n      String: Scalars['String'];\n      Child: Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> };\n      MyOtherType: MyNamespace.MyCustomOtherType;\n      ChildUnion: ResolversParentTypes['Child'] | ResolversParentTypes['MyOtherType'];\n      Query: {};\n      Subscription: {};\n      Node: ResolversParentTypes['SomeNode'];\n      ID: Scalars['ID'];\n      SomeNode: SomeNode;\n      MyUnion: ResolversParentTypes['MyType'] | ResolversParentTypes['MyOtherType'];\n      MyScalar: Scalars['MyScalar'];\n      Int: Scalars['Int'];\n      Boolean: Scalars['Boolean'];\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in contextType",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1239,
                "column": 46
            },
            "line": 1239,
            "code": "  it('should support namespaces in contextType', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        contextType: './my-file#MyNamespace#MyContextType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toContain(`<ContextType = MyNamespace.MyContextType>`);\n    expect(result.content).not.toContain(`<ContextType = MyNamespace>`);\n    expect(result.content).not.toContain(`<ContextType = MyContextType>`);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in defaultMapper",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1257,
                "column": 48
            },
            "line": 1257,
            "code": "  it('should support namespaces in defaultMapper', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: './my-file#MyNamespace#MyDefaultMapper',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        String: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Child: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        ChildUnion: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        SomeNode: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyUnion: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        MyScalar: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Int: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n        Boolean: ResolverTypeWrapper<MyNamespace.MyDefaultMapper>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        MyType: MyNamespace.MyDefaultMapper;\n        String: MyNamespace.MyDefaultMapper;\n        Child: MyNamespace.MyDefaultMapper;\n        MyOtherType: MyNamespace.MyDefaultMapper;\n        ChildUnion: MyNamespace.MyDefaultMapper;\n        Query: {};\n        Subscription: {};\n        Node: ResolversParentTypes['SomeNode'];\n        ID: MyNamespace.MyDefaultMapper;\n        SomeNode: MyNamespace.MyDefaultMapper;\n        MyUnion: MyNamespace.MyDefaultMapper;\n        MyScalar: MyNamespace.MyDefaultMapper;\n        Int: MyNamespace.MyDefaultMapper;\n        Boolean: MyNamespace.MyDefaultMapper;\n      };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces in rootValueType",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1308,
                "column": 48
            },
            "line": 1308,
            "code": "  it('should support namespaces in rootValueType', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        rootValueType: './my-file#MyNamespace#MyRootType',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversTypes['ChildUnion']> }>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Child: ResolverTypeWrapper<Child>;\n        MyOtherType: ResolverTypeWrapper<MyOtherType>;\n        ChildUnion: ResolversTypes['Child'] | ResolversTypes['MyOtherType'];\n        Query: ResolverTypeWrapper<MyNamespace.MyRootType>;\n        Subscription: ResolverTypeWrapper<MyNamespace.MyRootType>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<Scalars['ID']>;\n        SomeNode: ResolverTypeWrapper<SomeNode>;\n        MyUnion: ResolversTypes['MyType'] | ResolversTypes['MyOtherType'];\n        MyScalar: ResolverTypeWrapper<Scalars['MyScalar']>;\n        Int: ResolverTypeWrapper<Scalars['Int']>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: Omit<MyType, 'unionChild'> & { unionChild?: Maybe<ResolversParentTypes['ChildUnion']> };\n      String: Scalars['String'];\n      Child: Child;\n      MyOtherType: MyOtherType;\n      ChildUnion: ResolversParentTypes['Child'] | ResolversParentTypes['MyOtherType'];\n      Query: MyNamespace.MyRootType;\n      Subscription: MyNamespace.MyRootType;\n      Node: ResolversParentTypes['SomeNode'];\n      ID: Scalars['ID'];\n      SomeNode: SomeNode;\n      MyUnion: ResolversParentTypes['MyType'] | ResolversParentTypes['MyOtherType'];\n      MyScalar: Scalars['MyScalar'];\n      Int: Scalars['Int'];\n      Boolean: Scalars['Boolean'];\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support namespaces and {T} placeholder",
            "suites": [
                "ResolversTypes"
            ],
            "updatePoint": {
                "line": 1360,
                "column": 51
            },
            "line": 1360,
            "code": "  it('should support namespaces and {T} placeholder', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        defaultMapper: './my-file#MyNamespace#MyDefaultMapper<{T}>',\n        mappers: {\n          MyType: './my-file#MyNamespace#MyType<{T}>',\n        },\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyNamespace } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MyType: ResolverTypeWrapper<MyNamespace.MyType<MyType>>;\n        String: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['String']>>;\n        Child: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversTypes['MyType']> }>>;\n        MyOtherType: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<MyOtherType>>;\n        ChildUnion: MyNamespace.MyDefaultMapper<ResolversTypes['Child'] | ResolversTypes['MyOtherType']>;\n        Query: ResolverTypeWrapper<{}>;\n        Subscription: ResolverTypeWrapper<{}>;\n        Node: ResolversTypes['SomeNode'];\n        ID: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['ID']>>;\n        SomeNode: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<SomeNode>>;\n        MyUnion: MyNamespace.MyDefaultMapper<ResolversTypes['MyType'] | ResolversTypes['MyOtherType']>;\n        MyScalar: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['MyScalar']>>;\n        Int: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['Int']>>;\n        Boolean: ResolverTypeWrapper<MyNamespace.MyDefaultMapper<Scalars['Boolean']>>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type ResolversParentTypes = {\n      MyType: MyNamespace.MyType<MyType>;\n      String: MyNamespace.MyDefaultMapper<Scalars['String']>;\n      Child: MyNamespace.MyDefaultMapper<Omit<Child, 'parent'> & { parent?: Maybe<ResolversParentTypes['MyType']> }>;\n      MyOtherType: MyNamespace.MyDefaultMapper<MyOtherType>;\n      ChildUnion: MyNamespace.MyDefaultMapper<ResolversParentTypes['Child'] | ResolversParentTypes['MyOtherType']>;\n      Query: {};\n      Subscription: {};\n      Node: ResolversParentTypes['SomeNode'];\n      ID: MyNamespace.MyDefaultMapper<Scalars['ID']>;\n      SomeNode: MyNamespace.MyDefaultMapper<SomeNode>;\n      MyUnion: MyNamespace.MyDefaultMapper<ResolversParentTypes['MyType'] | ResolversParentTypes['MyOtherType']>;\n      MyScalar: MyNamespace.MyDefaultMapper<Scalars['MyScalar']>;\n      Int: MyNamespace.MyDefaultMapper<Scalars['Int']>;\n      Boolean: MyNamespace.MyDefaultMapper<Scalars['Boolean']>;\n    };\n    `);\n  });",
            "file": "mapping.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce IResolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Backward Compatability"
            ],
            "updatePoint": {
                "line": 11,
                "column": 63
            },
            "line": 11,
            "code": "    it('should produce IResolvers compatible with graphql-tools', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          users: [User!]!\n        }\n\n        type User {\n          id: ID!\n          name: String!\n        }\n      `);\n\n      const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n      const resolversContent = (await plugin(\n        testSchema,\n        [],\n        {\n          contextType: 'Context',\n          useIndexSignature: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      const content = mergeOutputs([\n        tsContent,\n        resolversContent,\n        `\n          import { makeExecutableSchema } from '@graphql-tools/schema';\n\n          interface Context {\n            users: Array<{\n              id: string;\n              name: string;\n            }>;\n          }\n\n          const resolvers: IResolvers = {\n            Query: {\n              users(parent, args, ctx, info) {\n                return ctx.users;\n              }\n            }\n          }\n\n          makeExecutableSchema({\n            typeDefs: '',\n            resolvers\n          })\n        `,\n      ]);\n\n      expect(content).toBeSimilarStringTo(`\n        export type Resolvers<ContextType = Context> = ResolversObject<{\n          Query?: QueryResolvers<ContextType>;\n          User?: UserResolvers<ContextType>;\n        }>;\n      `);\n\n      validateTs(content);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should use StitchingResolver when its active on config",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Backward Compatability"
            ],
            "updatePoint": {
                "line": 74,
                "column": 60
            },
            "line": 74,
            "code": "  it('Should use StitchingResolver when its active on config', async () => {\n    const result = await plugin(schema, [], { noSchemaStitching: false }, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`export type StitchingResolver<TResult, TParent, TContext, TArgs>`);\n    expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        | ResolverFn<TResult, TParent, TContext, TArgs>\n        | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n        | StitchingResolver<TResult, TParent, TContext, TArgs>;\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "onlyResolveTypeForInterfaces - should allow to have only resolveType for interfaces",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 89,
                "column": 91
            },
            "line": 89,
            "code": "    it('onlyResolveTypeForInterfaces - should allow to have only resolveType for interfaces', async () => {\n      const config = {\n        onlyResolveTypeForInterfaces: true,\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      const content = await validate(result, config, schema);\n\n      expect(content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n      };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "optionalInfoArgument - should allow to have optional info argument",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 102,
                "column": 74
            },
            "line": 102,
            "code": "    it('optionalInfoArgument - should allow to have optional info argument', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        optionalInfoArgument: true,\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      const content = await validate(result, config, schema);\n\n      expect(content).not.toContain(`info: `);\n      expect(content).toContain(`info?: `);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "allowParentTypeOverride - should allow to have less strict resolvers by overrding parent type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 117,
                "column": 101
            },
            "line": 117,
            "code": "    it('allowParentTypeOverride - should allow to have less strict resolvers by overrding parent type', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        allowParentTypeOverride: true,\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n\n      const content = await validate(\n        result,\n        config,\n        schema,\n        `\n        export const myTypeResolvers: MyTypeResolvers<{}, { parentOverride: boolean }> = {\n          foo: (parentValue) => {\n            const a: boolean = parentValue.parentOverride;\n\n            return a.toString();\n          }\n        };\n      `\n      );\n\n      expect(content).not.toContain(`ParentType extends `);\n      expect(content).toContain(`ParentType = `);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "namespacedImportName - should work correctly with imported namespaced type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 145,
                "column": 82
            },
            "line": 145,
            "code": "    it('namespacedImportName - should work correctly with imported namespaced type', async () => {\n      const config = {\n        noSchemaStitching: true,\n        useIndexSignature: true,\n        namespacedImportName: 'Types',\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      const content = mergeOutputs([result]);\n      expect(content).toMatchSnapshot();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "directiveResolverMappings - should generate correct types (inline definition)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 156,
                "column": 85
            },
            "line": 156,
            "code": "    it('directiveResolverMappings - should generate correct types (inline definition)', async () => {\n      const config = {\n        noSchemaStitching: true,\n        directiveResolverMappings: {\n          authenticated: `\n(\n  parent: TParent,\n  args: TArgs,\n  context: AuthenticatedContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;`,\n        },\n      };\n      const result = await plugin(schema, [], config, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\nexport type ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> =\n(\n  parent: TParent,\n  args: TArgs,\n  context: AuthenticatedContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFnAuthenticated<TResult, TParent, TContext, TArgs>;\n};\nexport type ResolverAuthenticated<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> | ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs>;\n`);\n      expect(result.content).toBeSimilarStringTo(`\nexport type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n  foo?: ResolverAuthenticated<ResolversTypes['String'], ParentType, ContextType>;\n  otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n  withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n  unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "makeResolverTypeCallable - should remove ResolverWithResolve type from resolver union",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 195,
                "column": 93
            },
            "line": 195,
            "code": "    it('makeResolverTypeCallable - should remove ResolverWithResolve type from resolver union', async () => {\n      const result = await plugin(schema, [], { makeResolverTypeCallable: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>;\n    `);\n\n      expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>\n      | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n      await validate(result);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "makeResolverTypeCallable - adds ResolverWithResolve type to resolver union when set to false",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 212,
                "column": 100
            },
            "line": 212,
            "code": "    it('makeResolverTypeCallable - adds ResolverWithResolve type to resolver union when set to false', async () => {\n      const result = await plugin(schema, [], { makeResolverTypeCallable: false }, { outputFile: '' });\n\n      expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>;\n    `);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n      ResolverFn<TResult, TParent, TContext, TArgs>\n      | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n      await validate(result);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "directiveResolverMappings - should generate correct types (import definition)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Config"
            ],
            "updatePoint": {
                "line": 230,
                "column": 83
            },
            "line": 230,
            "code": "  it('directiveResolverMappings - should generate correct types (import definition)', async () => {\n    const config = {\n      noSchemaStitching: true,\n      directiveResolverMappings: {\n        authenticated: `../resolver-types.ts#AuthenticatedResolver`,\n      },\n    };\n    const result = await plugin(schema, [], config, { outputFile: '' });\n    expect(result.prepend).toContain(\n      \"import { AuthenticatedResolver as ResolverFnAuthenticated } from '../resolver-types.ts';\"\n    );\n    expect(result.prepend).toContain('export { ResolverFnAuthenticated };');\n    expect(result.content).toBeSimilarStringTo(`\nexport type ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFnAuthenticated<TResult, TParent, TContext, TArgs>;\n};\nexport type ResolverAuthenticated<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFnAuthenticated<TResult, TParent, TContext, TArgs> | ResolverAuthenticatedWithResolve<TResult, TParent, TContext, TArgs>;\n`);\n    expect(result.content).toBeSimilarStringTo(`\nexport type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\nfoo?: ResolverAuthenticated<ResolversTypes['String'], ParentType, ContextType>;\notherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\nwithArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\nunionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n__isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n};\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not generate enum internal values resolvers when enum doesnt have enumValues set",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 260,
                "column": 95
            },
            "line": 260,
            "code": "    it('Should not generate enum internal values resolvers when enum doesnt have enumValues set', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n      const mergedOutput = await validate(\n        result,\n        config,\n        testSchema,\n        `\n        export const resolvers: Resolvers = {\n          Query: {\n            v: () => 'A',\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).not.toContain('EnumResolverSignature');\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as object with explicit values",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 293,
                "column": 114
            },
            "line": 293,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as object with explicit values', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: {\n          MyEnum: {\n            A: 'val_1',\n            B: 'val_2',\n            C: 'val_3',\n          },\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await validate(\n        result,\n        config,\n        testSchema,\n        `\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: 'val_1',\n            B: 'val_2',\n            C: 'val_3',\n          },\n          Query: {\n            v: () => 'val_1',\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).not.toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).not.toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(`export type MyEnumResolvers = { A: 'val_1', B: 'val_2', C: 'val_3' };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set as external enum",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 340,
                "column": 100
            },
            "line": 340,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set as external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await validate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has mappers pointing to external enum",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 391,
                "column": 102
            },
            "line": 391,
            "code": "    it('Should generate enum internal values resolvers when enum has mappers pointing to external enum', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        mappers: {\n          MyEnum: 'MyCustomEnum',\n        },\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await validate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 442,
                "column": 114
            },
            "line": 442,
            "code": "    it('Should generate enum internal values resolvers when enum has enumValues set on a global level of all enums', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          v: MyEnum\n        }\n\n        enum MyEnum {\n          A\n          B\n          C\n        }\n      `);\n      const config = {\n        noSchemaStitching: true,\n        enumValues: './enums',\n      };\n      const result = await plugin(testSchema, [], config, { outputFile: '' });\n\n      const mergedOutput = await validate(\n        result,\n        config,\n        testSchema,\n        `\n        enum MyCustomEnum {\n          CUSTOM_A,\n          CUSTOM_B,\n          CUSTOM_C\n        }\n\n        export const resolvers: Resolvers = {\n          MyEnum: {\n            A: MyCustomEnum.CUSTOM_A,\n            B: MyCustomEnum.CUSTOM_B,\n            C: MyCustomEnum.CUSTOM_C,\n          },\n          Query: {\n            v: () => MyCustomEnum.CUSTOM_A,\n          }\n        };\n      `\n      );\n\n      expect(mergedOutput).toContain(`import { MyEnum } from './enums'`);\n      expect(mergedOutput).toContain(`export { MyEnum }`);\n      expect(mergedOutput).toContain(ENUM_RESOLVERS_SIGNATURE);\n      expect(mergedOutput).toContain('EnumResolverSignature');\n      expect(mergedOutput).toContain(\n        `export type MyEnumResolvers = EnumResolverSignature<{ A?: any, B?: any, C?: any }, ResolversTypes['MyEnum']>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override ResolverTypeWrapper signature",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 494,
                "column": 60
            },
            "line": 494,
            "code": "  it('Should allow to override ResolverTypeWrapper signature', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n        resolverTypeWrapperSignature: 'Promise<DeepPartial<T>> | DeepPartial<T>',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain(`export type ResolverTypeWrapper<T> = Promise<DeepPartial<T>> | DeepPartial<T>;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should have default value for ResolverTypeWrapper signature",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 508,
                "column": 65
            },
            "line": 508,
            "code": "  it('Should have default value for ResolverTypeWrapper signature', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain(`export type ResolverTypeWrapper<T> = Promise<T> | T;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not warn when noSchemaStitching is not defined",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 521,
                "column": 59
            },
            "line": 521,
            "code": "  it('Should not warn when noSchemaStitching is not defined', async () => {\n    const spy = jest.spyOn(console, 'warn').mockImplementation();\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(spy).not.toHaveBeenCalled();\n\n    spy.mockRestore();\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should disable StitchingResolver on demand",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 532,
                "column": 48
            },
            "line": 532,
            "code": "  it('Should disable StitchingResolver on demand', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        noSchemaStitching: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).not.toBeSimilarStringTo(`\n      export type StitchingResolver<TResult, TParent, TContext, TArgs> = {\n        fragment: string;\n        resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n      };\n    `);\n    expect(result.content).not.toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        | ResolverFn<TResult, TParent, TContext, TArgs>\n        | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n        | StitchingResolver<TResult, TParent, TContext, TArgs>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n        ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Default values of args and compatibility with typescript plugin",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 563,
                "column": 69
            },
            "line": 563,
            "code": "  it('Default values of args and compatibility with typescript plugin', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        something(arg: String = \"default_value\"): String\n      }\n    `);\n\n    const config: any = { noSchemaStitching: true };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const mergedOutputs = mergeOutputs([\n      result,\n      {\n        content: `\n    const resolvers: QueryResolvers = {\n      something: (root, args, context, info) => {\n        return args.arg; // This should work becuase \"args.arg\" is now forced\n      }\n    };`,\n      },\n    ]);\n\n    expect(mergedOutputs).toContain(`export type RequireFields`);\n    expect(mergedOutputs).toContain(\n      `something?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QuerySomethingArgs, 'arg'>>;`\n    );\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Test for enum usage in resolvers (to verify compatibility with enumValues)",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 590,
                "column": 80
            },
            "line": 590,
            "code": "  it('Test for enum usage in resolvers (to verify compatibility with enumValues)', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        a: A\n      }\n\n      enum A {\n        X\n        Y\n        Z\n      }\n\n      enum NotMapped {\n        X\n        Y\n      }\n\n      type B {\n        a: String\n      }\n    `);\n\n    const config = {\n      enumValues: {\n        A: 'MyA',\n      },\n      typesPrefix: 'GQL_',\n    };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const tsContent = (await tsPlugin(testSchema, [], config, {\n      outputFile: 'graphql.ts',\n    })) as Types.ComplexPluginOutput;\n    const mergedOutputs = mergeOutputs([result, tsContent]);\n\n    expect(mergedOutputs).not.toContain(`A: A;`);\n    expect(mergedOutputs).not.toContain(`A: GQL_A;`);\n    expect(mergedOutputs).toContain(`NotMapped: GQL_NotMapped;`);\n    expect(mergedOutputs).not.toContain(`NotMapped: NotMapped;`);\n    expect(mergedOutputs).toContain(`B: GQL_B;`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to generate optional __resolveType",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 631,
                "column": 53
            },
            "line": 631,
            "code": "  it('Should allow to generate optional __resolveType', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      { optionalResolveType: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType?: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType?: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 653,
                "column": 42
            },
            "line": 653,
            "code": "  it('Should generate basic type resolvers', async () => {\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n    }`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate basic type resolvers with avoidOptionals",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 724,
                "column": 62
            },
            "line": 724,
            "code": "  it('Should generate basic type resolvers with avoidOptionals', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      { avoidOptionals: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = any, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content)\n      .toBeSimilarStringTo(`export interface MyScalarScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['MyScalar'], any> {\n      name: 'MyScalar';\n    }`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with simple identifier",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 799,
                "column": 61
            },
            "line": 799,
            "code": "  it('Should allow to override context with simple identifier', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        contextType: 'MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(mergeOutputs([result, `type MyCustomCtx = {};`]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should with correctly with addUnderscoreToArgsType set to true",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 872,
                "column": 68
            },
            "line": 872,
            "code": "  it('Should with correctly with addUnderscoreToArgsType set to true', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        addUnderscoreToArgsType: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toContain('MyType_WithArgsArgs');\n    expect(result.content).not.toContain('MyTypeWithArgsArgs');\n\n    await validate(mergeOutputs([result]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 888,
                "column": 63
            },
            "line": 888,
            "code": "  it('Should allow to override context with mapped context type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 963,
                "column": 63
            },
            "line": 963,
            "code": "  it('Should allow to override context with mapped context type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = MyCustomCtx, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type as default export",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1037,
                "column": 81
            },
            "line": 1037,
            "code": "  it('Should allow to override context with mapped context type as default export', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        contextType: './my-file#default',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import ContextType from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = ContextType, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should allow to override context with mapped context type as default export with type import",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1111,
                "column": 98
            },
            "line": 1111,
            "code": "  it('Should allow to override context with mapped context type as default export with type import', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        contextType: './my-file#default',\n        useTypeImports: true,\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import type { default as ContextType } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveArgs = {\n      arg: Scalars['Int'];\n      arg2: Scalars['String'];\n      arg3: Scalars['Boolean'];\n    };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type MyDirectiveDirectiveResolver<Result, Parent, ContextType = ContextType, Args = MyDirectiveDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyOtherTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyOtherType'] = ResolversParentTypes['MyOtherType']> = {\n        bar?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        __resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SomeNodeResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['SomeNode'] = ResolversParentTypes['SomeNode']> = {\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type SubscriptionResolvers<ContextType = ContextType, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {\n        somethingChanged?: SubscriptionResolver<Maybe<ResolversTypes['MyOtherType']>, \"somethingChanged\", ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1187,
                "column": 59
            },
            "line": 1187,
            "code": "  it('should generate named custom field level context type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        fieldContextTypes: [\n          'MyType.foo#./my-file#ContextTypeOne',\n          'Query.something#./my-file#ContextTypeTwo',\n          'MyType.otherType#SpecialContextType',\n        ],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { ContextTypeOne, ContextTypeTwo } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, ContextTypeOne>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, SpecialContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        something?: Resolver<ResolversTypes['MyType'], ParentType, ContextTypeTwo>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1220,
                "column": 84
            },
            "line": 1220,
            "code": "  it('should generate named custom field level context type for field with directive', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextType>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive and context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1243,
                "column": 101
            },
            "line": 1243,
            "code": "  it('should generate named custom field level context type for field with directive and context type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n        contextType: './my-file#MyCustomCtx',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { MyCustomCtx, AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = MyCustomCtx, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextType>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate named custom field level context type for field with directive and field context type",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1267,
                "column": 107
            },
            "line": 1267,
            "code": "  it('should generate named custom field level context type for field with directive and field context type', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      {\n        directiveContextTypes: ['authenticated#./my-file#AuthenticatedContext'],\n        fieldContextTypes: ['MyType.foo#./my-file#ContextTypeOne'],\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { ContextTypeOne, AuthenticatedContext } from './my-file';`);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyTypeResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyType'] = ResolversParentTypes['MyType']> = {\n        foo?: Resolver<ResolversTypes['String'], ParentType, AuthenticatedContext<ContextTypeOne>>;\n        otherType?: Resolver<Maybe<ResolversTypes['MyOtherType']>, ParentType, ContextType>;\n        withArgs?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<MyTypeWithArgsArgs, 'arg2'>>;\n        unionChild?: Resolver<Maybe<ResolversTypes['ChildUnion']>, ParentType, ContextType>;\n        __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has scalars",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1291,
                "column": 65
            },
            "line": 1291,
            "code": "  it('Should generate the correct imports when schema has scalars', async () => {\n    const testSchema = buildSchema(`scalar MyScalar`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.prepend).toContain(\n      `import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';`\n    );\n    await validate(result, {}, schema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when schema has no scalars",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1301,
                "column": 68
            },
            "line": 1301,
            "code": "  it('Should generate the correct imports when schema has no scalars', async () => {\n    const testSchema = buildSchema(`type MyType { f: String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.prepend).not.toContain(`import { GraphQLResolveInfo, GraphQLScalarTypeConfig } from 'graphql';`);\n    await validate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct imports when customResolveInfo defined in config",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Enums"
            ],
            "updatePoint": {
                "line": 1309,
                "column": 82
            },
            "line": 1309,
            "code": "  it('Should generate the correct imports when customResolveInfo defined in config', async () => {\n    const testSchema = buildSchema(`scalar MyScalar`);\n    const result = (await plugin(\n      testSchema,\n      [],\n      {\n        customResolveInfo: './my-type#MyGraphQLResolveInfo',\n      },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.prepend).toContain(`import { GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';`);\n    expect(result.prepend).toContain(`import { MyGraphQLResolveInfo as GraphQLResolveInfo } from './my-type';`);\n    await validate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "./my-type#MyResolverFn",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1326,
                "column": 30
            },
            "line": 1326,
            "code": "    it('./my-type#MyResolverFn', async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: './my-type#MyResolverFn',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { MyResolverFn as ResolverFn } from './my-type';`);\n      expect(result.prepend).toContain(`export { ResolverFn };`);\n      await validate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "./my-type#ResolverFn",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1342,
                "column": 28
            },
            "line": 1342,
            "code": "    it('./my-type#ResolverFn', async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: './my-type#ResolverFn',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { ResolverFn } from './my-type';`);\n      expect(result.prepend).toContain(`export { ResolverFn };`);\n      await validate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "definition directly",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1358,
                "column": 27
            },
            "line": 1358,
            "code": "    it(`definition directly`, async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const fnDefinition = `(\n        parent: TParent,\n        args: TArgs,\n        context: TContext,\n        info: GraphQLResolveInfo & { nestedStuff: GraphQLResolveInfo }\n      ) => Promise<TResult> | TResult;\n      `;\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          customResolverFn: fnDefinition,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`export type ResolverFn<TResult, TParent, TContext, TArgs> = ${fnDefinition}`);\n      await validate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "ok with default",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1380,
                "column": 23
            },
            "line": 1380,
            "code": "    it(`ok with default`, async () => {\n      const testSchema = buildSchema(`scalar MyScalar`);\n      const defaultResolverFn = `\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;`;\n      const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n      expect(result.content).toContain(defaultResolverFn);\n      await validate(result, {}, testSchema);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should not convert type names in unions",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1396,
                "column": 45
            },
            "line": 1396,
            "code": "  it('Should not convert type names in unions', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type CCCFoo {\n        foo: String!\n      }\n\n      type CCCBar {\n        bar: String!\n      }\n\n      type Query {\n        something: CCCUnion!\n      }\n\n      union CCCUnion = CCCFoo | CCCBar\n    `);\n\n    const tsContent = (await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' })) as Types.ComplexPluginOutput;\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`CCCUnion: ResolversTypes['CCCFoo'] | ResolversTypes['CCCBar']`); // In ResolversTypes\n    expect(content.content).toBeSimilarStringTo(`\n    export type CccUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CCCUnion'] = ResolversParentTypes['CCCUnion']> = {\n      __resolveType: TypeResolveFn<'CCCFoo' | 'CCCBar', ParentType, ContextType>;\n    };\n    `);\n\n    await validateTs(mergeOutputs([tsContent, content]));\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate the correct resolver args type names when typesPrefix is specified",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1426,
                "column": 88
            },
            "line": 1426,
            "code": "  it('Should generate the correct resolver args type names when typesPrefix is specified', async () => {\n    const testSchema = buildSchema(`type MyType { f(a: String): String }`);\n    const config = { typesPrefix: 'T' };\n    const result = await plugin(testSchema, [], config, { outputFile: '' });\n    const o = await validate(result, config, testSchema);\n\n    expect(o).toContain(\n      `f?: Resolver<Maybe<TResolversTypes['String']>, ParentType, ContextType, Partial<TMyTypeFArgs>>;`\n    );\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should make list of all-optional arguments include undefined types",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1438,
                "column": 72
            },
            "line": 1438,
            "code": "  it('should make list of all-optional arguments include undefined types', async () => {\n    const testSchema = buildSchema(`type MyType { f(a: String, b: Int): String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(\n      `f?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<MyTypeFArgs>>;`\n    );\n    await validate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should include generic wrapper type only when necessary",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1449,
                "column": 61
            },
            "line": 1449,
            "code": "  it('should include generic wrapper type only when necessary', async () => {\n    const testSchema = buildSchema(`type MyType { f: String }`);\n    const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(\n      `f?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;`\n    );\n    await validate(result, {}, testSchema);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate Resolvers interface",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1459,
                "column": 41
            },
            "line": 1459,
            "code": "  it('should generate Resolvers interface', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      directive @modify(limit: Int) on FIELD_DEFINITION\n      scalar Date\n      type Query {\n        post: Post\n        entity: PostOrUser\n      }\n      interface Node {\n        id: String\n      }\n      union PostOrUser = Post | User\n      type Post implements Node {\n        author: User\n      }\n      type User implements Node {\n        id: String\n        name: String\n      }\n      schema {\n        query: Query\n      }\n    `);\n\n    const content = (await plugin(\n      testSchema,\n      [],\n      { scalars: { Date: 'Date' } },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type Resolvers<ContextType = any> = {\n        Date?: GraphQLScalarType;\n        Query?: QueryResolvers<ContextType>;\n        Node?: NodeResolvers<ContextType>;\n        PostOrUser?: PostOrUserResolvers<ContextType>;\n        Post?: PostResolvers<ContextType>;\n        User?: UserResolvers<ContextType>;\n      };\n    `);\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type DirectiveResolvers<ContextType = any> = {\n        modify?: ModifyDirectiveResolver<any, any, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should not create DirectiveResolvers if there is no directive defined in the schema",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1510,
                "column": 89
            },
            "line": 1510,
            "code": "  it('should not create DirectiveResolvers if there is no directive defined in the schema', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        foo: String\n      }\n    `);\n\n    const content = (await plugin(\n      testSchema,\n      [],\n      { scalars: { Date: 'Date' } },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).not.toBeSimilarStringTo(`\n      export type DirectiveResolvers<ContextType = any> = {};\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce Resolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1531,
                "column": 60
            },
            "line": 1531,
            "code": "  it('should produce Resolvers compatible with graphql-tools', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users: [User!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n\n    const tsContent = (await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' })) as Types.ComplexPluginOutput;\n    const resolversContent = (await plugin(\n      testSchema,\n      [],\n      {\n        contextType: 'AppContext',\n        useIndexSignature: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { makeExecutableSchema } from '@graphql-tools/schema';\n\n        interface AppContext {\n          users: Array<{\n            id: string;\n            name: string;\n          }>;\n        }\n\n        const resolvers: Resolvers = {\n          Query: {\n            users(parent, args, ctx, info) {\n              return ctx.users;\n            }\n          }\n        }\n\n        makeExecutableSchema({\n          typeDefs: '',\n          resolvers\n        })\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should produce resolvers compatible with graphql-tools",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1586,
                "column": 60
            },
            "line": 1586,
            "code": "  it('should produce resolvers compatible with graphql-tools', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users: [User!]!\n      }\n\n      type User {\n        id: ID!\n        name: String!\n      }\n    `);\n\n    const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n    const resolversContent = await plugin(\n      testSchema,\n      [],\n      {\n        contextType: 'AppContext',\n        useIndexSignature: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    );\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { makeExecutableSchema } from '@graphql-tools/schema';\n\n        interface AppContext {\n          users: Array<{\n            id: string;\n            name: string;\n          }>;\n        }\n\n        const query: QueryResolvers = {\n          users(parent, args, ctx, info) {\n            return ctx.users;\n          }\n        }\n\n        makeExecutableSchema({\n          typeDefs: '',\n          resolvers: {\n            Query: query\n          }\n        })\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use {} as default of rootValueType",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1641,
                "column": 47
            },
            "line": 1641,
            "code": "  it('should use {} as default of rootValueType', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Subscription: ResolverTypeWrapper<{}>;\n        Query: ResolverTypeWrapper<{}>;\n        Mutation: ResolverTypeWrapper<{}>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate ResolversParentTypes",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1674,
                "column": 42
            },
            "line": 1674,
            "code": "  it('should generate ResolversParentTypes', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversParentTypes = {\n        Subscription: {};\n        Query: {};\n        Mutation: {};\n        String: Scalars['String'];\n        Post: Post;\n        Boolean: Scalars['Boolean'];\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use correct value when rootValueType mapped as default",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1707,
                "column": 67
            },
            "line": 1707,
            "code": "  it('should use correct value when rootValueType mapped as default', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'my-file#default',\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        Subscription: ResolverTypeWrapper<RootValueType>;\n        Query: ResolverTypeWrapper<RootValueType>;\n        Mutation: ResolverTypeWrapper<RootValueType>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n\n    expect(content.prepend).toContain(`import RootValueType from 'my-file';`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use correct value when rootValueType mapped as default with type import",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1749,
                "column": 84
            },
            "line": 1749,
            "code": "  it('should use correct value when rootValueType mapped as default with type import', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'my-file#default',\n        useTypeImports: true,\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(`import type { default as RootValueType } from 'my-file';`);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use rootValueType in Query, Mutation and Subscription",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1781,
                "column": 66
            },
            "line": 1781,
            "code": "  it('should use rootValueType in Query, Mutation and Subscription', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type MySubscription {\n        postAdded: Post\n      }\n\n      type MyQuery {\n        posts: [Post]\n      }\n\n      type MyMutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'MyRoot',\n      },\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolversTypes = {\n        MySubscription: ResolverTypeWrapper<MyRoot>;\n        MyQuery: ResolverTypeWrapper<MyRoot>;\n        MyMutation: ResolverTypeWrapper<MyRoot>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n        Post: ResolverTypeWrapper<Post>;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should generate subscription types correctly",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1827,
                "column": 50
            },
            "line": 1827,
            "code": "  it('should generate subscription types correctly', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Subscription {\n        postAdded: Post\n      }\n\n      type Query {\n        posts: [Post]\n      }\n\n      type Mutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n    `);\n    const tsContent = await tsPlugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n    const resolversContent = await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: '{version: 1}',\n      },\n      { outputFile: 'graphql.ts' }\n    );\n    const content = mergeOutputs([\n      tsContent,\n      resolversContent,\n      `\n        import { PubSub } from 'graphql-subscriptions';\n        const pubsub = new PubSub();\n\n        const POST_ADDED = 'POST_ADDED';\n\n        const resolvers: Resolvers = {\n          Subscription: {\n            postAdded: {\n              subscribe: () => pubsub.asyncIterator([POST_ADDED]),\n            }\n          },\n          Mutation: {\n            addPost: (root, { author, comment }) => {\n              const post = {\n                author,\n                comment,\n              };\n\n              // RootValue should be accessible\n              console.log(root.version);\n\n              // Pass correct data\n              pubsub.publish(POST_ADDED, post);\n\n              // Return correct data\n              return post;\n            }\n          },\n        };\n      `,\n    ]);\n\n    validateTs(content);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate valid types even when there are no implementers for an interface",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1894,
                "column": 86
            },
            "line": 1894,
            "code": "  it('Should generate valid types even when there are no implementers for an interface', async () => {\n    const schemaWithNoImplementors = buildSchema(/* GraphQL */ `\n      interface Node {\n        id: ID!\n      }\n\n      type Query {\n        node: Node!\n      }\n    `);\n\n    const result = await plugin(schemaWithNoImplementors, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        __resolveType: TypeResolveFn<null, ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should use MaybePromise in ResolverTypeWrapper",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "updatePoint": {
                "line": 1914,
                "column": 52
            },
            "line": 1914,
            "code": "  it('should use MaybePromise in ResolverTypeWrapper', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type MySubscription {\n        postAdded: Post\n      }\n\n      type MyQuery {\n        posts: [Post]\n      }\n\n      type MyMutation {\n        addPost(author: String, comment: String): Post\n      }\n\n      type Post {\n        author: String\n        comment: String\n      }\n\n      schema {\n        query: MyQuery\n        mutation: MyMutation\n        subscription: MySubscription\n      }\n    `);\n    const content = (await plugin(\n      testSchema,\n      [],\n      {\n        rootValueType: 'MyRoot',\n        asyncResolverTypes: true,\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.content).toBeSimilarStringTo(`\n      export type ResolverTypeWrapper<T> = Promise<T> | T;\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should support all use-cases of subscription resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "Should generate the correct imports when customResolverFn defined in config"
            ],
            "line": 1954,
            "code": "  it.skip('should support all use-cases of subscription resolvers', async () => {",
            "file": "ts-resolvers.spec.ts",
            "skipped": true,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#4687 - incorrect suffix when used with typesSuffix",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2209,
                "column": 59
            },
            "line": 2209,
            "code": "    it('#4687 - incorrect suffix when used with typesSuffix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type User {\n          _id: ID!\n        }\n        type Query {\n          user(_id: ID!): User\n          user2(_id: ID): User\n          me: User\n        }\n      `);\n\n      const config = {\n        typesSuffix: 'QL',\n      };\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n      const o = await validate(output, config, testSchema);\n      expect(o).not.toContain(\n        `user?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, RequireFields<QueryQLuserArgs, '_id'>>;`\n      );\n      expect(o).toContain(\n        `user?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, RequireFields<QueryUserArgsQL, '_id'>>;`\n      );\n      expect(o).toContain(`me?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType>;`);\n      expect(o).toContain(\n        `user2?: Resolver<Maybe<ResolversTypesQL['User']>, ParentType, ContextType, Partial<QueryUser2ArgsQL>>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should work correctly with enumPrefix: false - issue #2679",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2237,
                "column": 66
            },
            "line": 2237,
            "code": "    it('should work correctly with enumPrefix: false - issue #2679', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          t: Test\n        }\n\n        enum Test {\n          A\n          B\n          C\n        }\n      `);\n\n      const config = {\n        typesPrefix: 'I',\n        enumPrefix: false,\n        namingConvention: 'keep',\n        constEnums: true,\n      };\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n      const o = await validate(output, config, testSchema);\n\n      expect(o).toBeSimilarStringTo(`\n      export const enum Test {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      };`);\n      expect(o).toBeSimilarStringTo(`\n      export type IResolversTypes = {\n        Query: ResolverTypeWrapper<{}>;\n        Test: Test;\n        Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n        String: ResolverTypeWrapper<Scalars['String']>;\n      };`);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "should keep non-optional arguments non-optional - issue #2323",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2274,
                "column": 69
            },
            "line": 2274,
            "code": "    it('should keep non-optional arguments non-optional - issue #2323', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum OrderBy {\n          name\n          id\n        }\n\n        input Filter {\n          contain: String\n        }\n\n        type Node {\n          id: ID!\n          name: String!\n        }\n\n        type Connection {\n          nodes: [Node]\n        }\n\n        type Query {\n          list(after: String, orderBy: OrderBy = name, filter: Filter!): Connection!\n        }\n      `);\n\n      const output = (await plugin(\n        testSchema,\n        [],\n        {\n          avoidOptionals: false,\n          maybeValue: 'T | undefined',\n        } as any,\n        { outputFile: 'graphql.ts' }\n      )) as Types.ComplexPluginOutput;\n\n      // filter should be non-optional\n      expect(output.content).toBeSimilarStringTo(`\n        export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n          list?: Resolver<ResolversTypes['Connection'], ParentType, ContextType, RequireFields<QueryListArgs, 'orderBy' | 'filter'>>;\n        };\n      `);\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#3257 - should not import mapper when its already imported because of enumValues",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2317,
                "column": 88
            },
            "line": 2317,
            "code": "    it('#3257 - should not import mapper when its already imported because of enumValues', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          role: [ProjectRoleDetail!]!\n        }\n\n        enum ProjectRole {\n          PROJECT_MANAGER\n          ETC\n        }\n\n        type ProjectRoleDetail {\n          code: ProjectRole!\n          name: String!\n        }\n      `);\n\n      const config = {\n        noSchemaStitching: true,\n        contextType: '@src/context#Context',\n        useIndexSignature: true,\n        avoidOptionals: true,\n        mappers: {\n          ProjectRoleDetail: '../entities#ProjectRole',\n        },\n        enumValues: {\n          ProjectRole: '../entities#ProjectRole',\n        },\n      };\n\n      const tsContent = (await tsPlugin(testSchema, [], config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n      const output = await plugin(testSchema, [], config, { outputFile: 'graphql.ts' });\n\n      expect(output.prepend.filter(t => t.includes('import')).length).toBe(2);\n      expect(output.prepend.filter(t => t.includes('ProjectRole')).length).toBe(0);\n      expect(tsContent.prepend.filter(t => t.includes('ProjectRole')).length).toBe(1);\n      expect(tsContent.prepend.includes(`import { ProjectRole } from '../entities';`)).toBeTruthy();\n      expect(output.prepend.includes(`import { ProjectRole } from '../entities';`)).toBeFalsy();\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#3264 - enumValues is not being applied to directive resolver",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2363,
                "column": 69
            },
            "line": 2363,
            "code": "    it('#3264 - enumValues is not being applied to directive resolver', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        directive @auth(\n          role: UserRole = ADMIN\n        ) on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        enum UserRole {\n          ADMIN\n          USER\n        }\n\n        schema {\n          query: Query\n        }\n\n        type Query {\n          me: User!\n        }\n\n        type User {\n          id: ID!\n          username: String!\n          email: String!\n          role: UserRole!\n        }\n      `);\n\n      const output = (await plugin(\n        testSchema,\n        [],\n        {\n          noSchemaStitching: true,\n          typesPrefix: 'Gql',\n          maybeValue: 'T | undefined',\n          enumValues: {\n            UserRole: '@org/package#UserRole',\n          },\n        } as any,\n        { outputFile: 'graphql.ts' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(output.content).toContain(`export type GqlAuthDirectiveArgs = {\\n  role?: Maybe<UserRole>;\\n};`);\n      expect(output.content).toContain(\n        `export type GqlAuthDirectiveResolver<Result, Parent, ContextType = any, Args = GqlAuthDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;`\n      );\n    });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Should generate resolvers with replaced internalResolversPrefix if specified",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2411,
                "column": 82
            },
            "line": 2411,
            "code": "  it('Should generate resolvers with replaced internalResolversPrefix if specified', async () => {\n    const result = (await plugin(\n      schema,\n      [],\n      { internalResolversPrefix: '' },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).not.toContain('__resolveType');\n    expect(result.content).toContain('resolveType');\n    expect(result.content).not.toContain('__isTypeOf');\n    expect(result.content).toContain('isTypeOf');\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type MyUnionResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUnion'] = ResolversParentTypes['MyUnion']> = {\n        resolveType: TypeResolveFn<'MyType' | 'MyOtherType', ParentType, ContextType>;\n      };\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {\n        resolveType: TypeResolveFn<'SomeNode', ParentType, ContextType>;\n        id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;\n      };\n    `);\n\n    await validate(result);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "#7005 - avoidOptionals should preserve optional resolvers",
            "suites": [
                "TypeScript Resolvers Plugin",
                "issues"
            ],
            "updatePoint": {
                "line": 2440,
                "column": 63
            },
            "line": 2440,
            "code": "  it('#7005 - avoidOptionals should preserve optional resolvers', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Query {\n        users(filter: UserFilterInput = {}): [User!]!\n        ping: String!\n      }\n\n      input UserFilterInput {\n        status: String = \"ACTIVE\"\n      }\n\n      type User {\n        id: ID!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        avoidOptionals: {\n          defaultValue: true,\n          field: true,\n          inputValue: true,\n          object: true,\n          resolvers: false,\n        },\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(output.content).toBeSimilarStringTo(`\n      export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {\n        users?: Resolver<Array<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUsersArgs, 'filter'>>;\n        ping?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n      };\n    `);\n  });",
            "file": "ts-resolvers.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/resolvers/tests"
        },
        {
            "name": "Without hooks",
            "suites": [
                "RTK Query"
            ],
            "updatePoint": {
                "line": 28,
                "column": 21
            },
            "line": 28,
            "code": "  test('Without hooks', async () => {\n    const documents = parse(gql.commentQuery + gql.feedQuery + gql.newEntryMutation);\n    const docs = [{ location: '', document: documents }];\n\n    const content = (await plugin(\n      schema,\n      docs,\n      {\n        importBaseApiFrom: './baseApi',\n        exportHooks: false,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(\"import { api } from './baseApi';\");\n\n    expect(content.content).toMatchSnapshot();\n  });",
            "file": "rtk-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/rtk-query/tests"
        },
        {
            "name": "With hooks",
            "suites": [
                "RTK Query"
            ],
            "updatePoint": {
                "line": 48,
                "column": 18
            },
            "line": 48,
            "code": "  test('With hooks', async () => {\n    const documents = parse(gql.commentQuery + gql.feedQuery + gql.newEntryMutation);\n    const docs = [{ location: '', document: documents }];\n\n    const content = (await plugin(\n      schema,\n      docs,\n      {\n        importBaseApiFrom: './baseApi',\n        exportHooks: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(\"import { api } from './baseApi';\");\n\n    expect(content.content).toMatchSnapshot();\n  });",
            "file": "rtk-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/rtk-query/tests"
        },
        {
            "name": "With overrideExisting",
            "suites": [
                "RTK Query"
            ],
            "updatePoint": {
                "line": 68,
                "column": 29
            },
            "line": 68,
            "code": "  test('With overrideExisting', async () => {\n    const documents = parse(gql.commentQuery + gql.feedQuery + gql.newEntryMutation);\n    const docs = [{ location: '', document: documents }];\n\n    const content = (await plugin(\n      schema,\n      docs,\n      {\n        importBaseApiFrom: './baseApi',\n        exportHooks: false,\n        overrideExisting: 'module.hot?.status() === \"apply\"',\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(\"import { api } from './baseApi';\");\n    expect(content.content).toContain('overrideExisting: module.hot?.status() === \"apply\",');\n\n    expect(content.content).toMatchSnapshot();\n  });",
            "file": "rtk-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/rtk-query/tests"
        },
        {
            "name": "For fragment",
            "suites": [
                "RTK Query"
            ],
            "updatePoint": {
                "line": 90,
                "column": 20
            },
            "line": 90,
            "code": "  test('For fragment', async () => {\n    const documents = parse(gql.voteButtonsFragment);\n    const docs = [{ location: '', document: documents }];\n\n    const content = (await plugin(\n      schema,\n      docs,\n      {\n        importBaseApiFrom: './baseApi',\n        exportHooks: true,\n      },\n      {\n        outputFile: 'graphql.ts',\n      }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).not.toContain(\"import { api } from './baseApi';\");\n    expect(content.content).not.toContain('api.injectEndpoints');\n\n    expect(content.content).toMatchSnapshot();\n  });",
            "file": "rtk-query.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/rtk-query/tests"
        },
        {
            "name": "should import dependencies if class components are generated",
            "suites": [
                "Components"
            ],
            "updatePoint": {
                "line": 10,
                "column": 66
            },
            "line": 10,
            "code": "  it('should import dependencies if class components are generated', async () => {\n    const documents = gql`\n      query Feed {\n        feed {\n          id\n          commentCount\n          repository {\n            full_name\n            html_url\n            owner {\n              avatar_url\n            }\n          }\n        }\n      }\n    `;\n\n    const content = (await plugin(\n      schema,\n      [{ location: '', document: documents }],\n      { componentType: StencilComponentType.class },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content.prepend).toContain(`import 'stencil-apollo';`);\n    expect(content.prepend).toContain(`import { Component, Prop, h } from '@stencil/core';`);\n  });",
            "file": "stencil-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/stencil-apollo/tests"
        },
        {
            "name": "should generate Functional Component",
            "suites": [
                "Components"
            ],
            "updatePoint": {
                "line": 38,
                "column": 42
            },
            "line": 38,
            "code": "  it('should generate Functional Component', async () => {\n    const documents = gql`\n      query Feed {\n        feed {\n          id\n          commentCount\n          repository {\n            full_name\n            html_url\n            owner {\n              avatar_url\n            }\n          }\n        }\n      }\n    `;\n\n    const { content } = (await plugin(\n      schema,\n      [{ location: '', document: documents }],\n      { componentType: StencilComponentType.functional },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content).toBeSimilarStringTo(`\n        export type FeedProps = {\n            variables ?: FeedQueryVariables;\n            inlist ?: StencilApollo.QueryRenderer<FeedQuery, FeedQueryVariables>;\n        };\n    `);\n\n    expect(content).toBeSimilarStringTo(`\n        export const FeedComponent = (props: FeedProps, children: [StencilApollo.QueryRenderer<FeedQuery, FeedQueryVariables>]) => (\n          <apollo-query query={ FeedDocument } { ...props } renderer={ children[0] } />\n        );\n    `);\n  });",
            "file": "stencil-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/stencil-apollo/tests"
        },
        {
            "name": "should generate Class Component",
            "suites": [
                "Components"
            ],
            "updatePoint": {
                "line": 76,
                "column": 37
            },
            "line": 76,
            "code": "  it('should generate Class Component', async () => {\n    const documents = gql`\n      query Feed {\n        feed {\n          id\n          commentCount\n          repository {\n            full_name\n            html_url\n            owner {\n              avatar_url\n            }\n          }\n        }\n      }\n    `;\n\n    const { content } = (await plugin(\n      schema,\n      [{ location: '', document: documents }],\n      { componentType: StencilComponentType.class },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content).toBeSimilarStringTo(`\n            @Component({\n                tag: 'apollo-feed'\n            })\n            export class FeedComponent {\n                @Prop() renderer: import('stencil-apollo').QueryRenderer<FeedQuery, FeedQueryVariables>;\n                @Prop() variables: FeedQueryVariables;\n                render() {\n                    return <apollo-query query={ FeedDocument } variables={ this.variables } renderer={ this.renderer } />;\n                }\n            }\n      `);\n  });",
            "file": "stencil-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/stencil-apollo/tests"
        },
        {
            "name": "should generate Class Component with variables",
            "suites": [
                "Components"
            ],
            "updatePoint": {
                "line": 114,
                "column": 52
            },
            "line": 114,
            "code": "  it('should generate Class Component with variables', async () => {\n    const documents = gql`\n      query Feed($limit: Int) {\n        feed(limit: $limit) {\n          id\n          commentCount\n          repository {\n            full_name\n            html_url\n            owner {\n              avatar_url\n            }\n          }\n        }\n      }\n    `;\n\n    const { content } = (await plugin(\n      schema,\n      [{ location: '', document: documents }],\n      { componentType: StencilComponentType.class },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(content).toBeSimilarStringTo(`\n            @Component({\n                tag: 'apollo-feed'\n            })\n            export class FeedComponent {\n                @Prop() renderer: import('stencil-apollo').QueryRenderer<FeedQuery, FeedQueryVariables>;\n                @Prop() variables: FeedQueryVariables;\n                render() {\n                    return <apollo-query query={ FeedDocument } variables={ this.variables } renderer={ this.renderer } />;\n                }\n            }\n      `);\n  });",
            "file": "stencil-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/stencil-apollo/tests"
        },
        {
            "name": "should expose Maybe",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 7,
                "column": 25
            },
            "line": 7,
            "code": "  it('should expose Maybe', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.prepend).toBeSimilarStringTo('export type Maybe<T> =');\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should expose Exact",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 15,
                "column": 25
            },
            "line": 15,
            "code": "  it('should expose Exact', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.prepend).toBeSimilarStringTo('export type Exact<');\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should expose FixDecorator",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 23,
                "column": 32
            },
            "line": 23,
            "code": "  it('should expose FixDecorator', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.prepend).toBeSimilarStringTo('export type FixDecorator<T> = T;');\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql import/export",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 31,
                "column": 48
            },
            "line": 31,
            "code": "  it('should generate type-graphql import/export', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.prepend).toBeSimilarStringTo(`import * as TypeGraphQL from 'type-graphql';\n    export { TypeGraphQL };`);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql enums",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 41,
                "column": 40
            },
            "line": 41,
            "code": "  it('should generate type-graphql enums', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      \"custom enum\"\n      enum MyEnum {\n        \"this is a\"\n        A\n        \"this is b\"\n        B\n      }\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export enum MyEnum {\n        /** this is a */\n        A = 'A',\n        /** this is b */\n        B = 'B'\n      }\n      TypeGraphQL.registerEnumType(MyEnum, { name: 'MyEnum' });`);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql classes for object types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 64,
                "column": 59
            },
            "line": 64,
            "code": "  it('should generate type-graphql classes for object types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type A {\n        id: ID\n        mandatoryId: ID!\n        str: String\n        mandatoryStr: String!\n        bool: Boolean\n        mandatoryBool: Boolean!\n        int: Int\n        mandatoryInt: Int!\n        float: Float\n        mandatoryFloat: Float!\n        b: B\n        mandatoryB: B!\n        arr: [String!]\n        mandatoryArr: [String!]!\n      }\n      type B {\n        id: ID\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.ObjectType()\n      export class A {\n        __typename?: 'A';\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n        @TypeGraphQL.Field(type => TypeGraphQL.ID)\n        mandatoryId!: Scalars['ID'];\n        @TypeGraphQL.Field(type => String, { nullable: true })\n        str?: Maybe<Scalars['String']>;\n        @TypeGraphQL.Field(type => String)\n        mandatoryStr!: Scalars['String'];\n        @TypeGraphQL.Field(type => Boolean, { nullable: true })\n        bool?: Maybe<Scalars['Boolean']>;\n        @TypeGraphQL.Field(type => Boolean)\n        mandatoryBool!: Scalars['Boolean'];\n        @TypeGraphQL.Field(type => TypeGraphQL.Int, { nullable: true })\n        int?: Maybe<Scalars['Int']>;\n        @TypeGraphQL.Field(type => TypeGraphQL.Int)\n        mandatoryInt!: Scalars['Int'];\n        @TypeGraphQL.Field(type => TypeGraphQL.Float, { nullable: true })\n        float?: Maybe<Scalars['Float']>;\n        @TypeGraphQL.Field(type => TypeGraphQL.Float)\n        mandatoryFloat!: Scalars['Float'];\n        @TypeGraphQL.Field(type => B, { nullable: true })\n        b?: Maybe<B>;\n        @TypeGraphQL.Field(type => B)\n        mandatoryB!: FixDecorator<B>;\n        @TypeGraphQL.Field(type => [String], { nullable: true })\n        arr?: Maybe<Array<Scalars['String']>>;\n        @TypeGraphQL.Field(type => [String])\n        mandatoryArr!: Array<Scalars['String']>;\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql classes implementing type-graphql interfaces for object types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 125,
                "column": 96
            },
            "line": 125,
            "code": "  it('should generate type-graphql classes implementing type-graphql interfaces for object types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Test implements ITest {\n        id: ID\n        mandatoryStr: String!\n      }\n      interface ITest {\n        id: ID\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.ObjectType({ implements: ITest })\n      export class Test extends ITest {\n        __typename?: 'Test';\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n        @TypeGraphQL.Field(type => String)\n        mandatoryStr!: Scalars['String'];\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.InterfaceType()\n      export abstract class ITest {\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql classes for input types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 159,
                "column": 58
            },
            "line": 159,
            "code": "  it('should generate type-graphql classes for input types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      input A {\n        id: ID\n        mandatoryId: ID!\n        str: String\n        mandatoryStr: String!\n        bool: Boolean\n        mandatoryBool: Boolean!\n        int: Int\n        mandatoryInt: Int!\n        float: Float\n        mandatoryFloat: Float!\n        b: B\n        mandatoryB: B!\n        arr: [String!]\n        mandatoryArr: [String!]!\n      }\n      input B {\n        id: ID\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.InputType()\n      export class A {\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID)\n        mandatoryId!: Scalars['ID'];\n\n        @TypeGraphQL.Field(type => String, { nullable: true })\n        str?: Maybe<Scalars['String']>;\n\n        @TypeGraphQL.Field(type => String)\n        mandatoryStr!: Scalars['String'];\n\n        @TypeGraphQL.Field(type => Boolean, { nullable: true })\n        bool?: Maybe<Scalars['Boolean']>;\n\n        @TypeGraphQL.Field(type => Boolean)\n        mandatoryBool!: Scalars['Boolean'];\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Int, { nullable: true })\n        int?: Maybe<Scalars['Int']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Int)\n        mandatoryInt!: Scalars['Int'];\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Float, { nullable: true })\n        float?: Maybe<Scalars['Float']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Float)\n        mandatoryFloat!: Scalars['Float'];\n\n        @TypeGraphQL.Field(type => B, { nullable: true })\n        b?: Maybe<B>;\n\n        @TypeGraphQL.Field(type => B)\n        mandatoryB!: FixDecorator<B>;\n\n        @TypeGraphQL.Field(type => [String], { nullable: true })\n        arr?: Maybe<Array<Scalars['String']>>;\n\n        @TypeGraphQL.Field(type => [String])\n        mandatoryArr!: Array<Scalars['String']>;\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate an args type",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 233,
                "column": 34
            },
            "line": 233,
            "code": "  it('should generate an args type', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Mutation {\n        test(\n          id: ID\n          mandatoryId: ID!\n          str: String\n          mandatoryStr: String!\n          bool: Boolean\n          mandatoryBool: Boolean!\n          int: Int\n          mandatoryInt: Int!\n          float: Float\n          mandatoryFloat: Float!\n          b: B\n          mandatoryB: B!\n          arr: [String!]\n          mandatoryArr: [String!]!\n        ): Boolean!\n      }\n\n      input B {\n        id: ID\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.ArgsType()\n      export class MutationTestArgs {\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID)\n        mandatoryId!: Scalars['ID'];\n\n        @TypeGraphQL.Field(type => String, { nullable: true })\n        str?: Maybe<Scalars['String']>;\n\n        @TypeGraphQL.Field(type => String)\n        mandatoryStr!: Scalars['String'];\n\n        @TypeGraphQL.Field(type => Boolean, { nullable: true })\n        bool?: Maybe<Scalars['Boolean']>;\n\n        @TypeGraphQL.Field(type => Boolean)\n        mandatoryBool!: Scalars['Boolean'];\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Int, { nullable: true })\n        int?: Maybe<Scalars['Int']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Int)\n        mandatoryInt!: Scalars['Int'];\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Float, { nullable: true })\n        float?: Maybe<Scalars['Float']>;\n\n        @TypeGraphQL.Field(type => TypeGraphQL.Float)\n        mandatoryFloat!: Scalars['Float'];\n\n        @TypeGraphQL.Field(type => B, { nullable: true })\n        b?: Maybe<B>;\n\n        @TypeGraphQL.Field(type => B)\n        mandatoryB!: FixDecorator<B>;\n\n        @TypeGraphQL.Field(type => [String], { nullable: true })\n        arr?: Maybe<Array<Scalars['String']>>;\n\n        @TypeGraphQL.Field(type => [String])\n        mandatoryArr!: Array<Scalars['String']>;\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate type-graphql types as custom types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 310,
                "column": 56
            },
            "line": 310,
            "code": "  it('should generate type-graphql types as custom types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Test {\n        id: ID\n        mandatoryStr: String!\n      }\n      interface ITest {\n        id: ID\n      }\n    `);\n\n    const result = (await plugin(\n      schema,\n      [],\n      { decoratorName: { type: 'Foo', field: 'Bar', interface: 'FooBar' } },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n        @TypeGraphQL.Foo()\n        export class Test {\n          __typename?: 'Test';\n          @TypeGraphQL.Bar(type => TypeGraphQL.ID, { nullable: true })\n          id?: Maybe<Scalars['ID']>;\n          @TypeGraphQL.Bar(type => String)\n          mandatoryStr!: Scalars['String'];\n        }\n      `);\n    expect(result.content).toBeSimilarStringTo(`\n        @TypeGraphQL.FooBar()\n        export abstract class ITest {\n\n          @TypeGraphQL.Bar(type => TypeGraphQL.ID, { nullable: true })\n          id?: Maybe<Scalars['ID']>;\n        }\n      `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should generate custom scalar types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 348,
                "column": 41
            },
            "line": 348,
            "code": "  it('should generate custom scalar types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar DateTime\n\n      type A {\n        date: DateTime\n        mandatoryDate: DateTime!\n      }\n    `);\n\n    const result = (await plugin(\n      schema,\n      [],\n      { scalars: { DateTime: 'Date' } },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.ObjectType()\n      export class A {\n        __typename?: 'A';\n        @TypeGraphQL.Field(type => Date, { nullable: true })\n        date?: Maybe<Scalars['DateTime']>;\n        @TypeGraphQL.Field(type => Date)\n        mandatoryDate!: Scalars['DateTime'];\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should correctly set options for nullable types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 377,
                "column": 53
            },
            "line": 377,
            "code": "  it('should correctly set options for nullable types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type MyType {\n        str1: String\n        str2: String!\n        strArr1: [String]\n        strArr2: [String]!\n        strArr3: [String!]\n        strArr4: [String!]!\n\n        int1: Int\n        int2: Int!\n        intArr1: [Int]\n        intArr2: [Int]!\n        intArr3: [Int!]\n        intArr4: [Int!]!\n\n        custom1: MyType2\n        custom2: MyType2!\n        customArr1: [MyType2]\n        customArr2: [MyType2]!\n        customArr3: [MyType2!]\n        customArr4: [MyType2!]!\n      }\n\n      input MyInputType {\n        inputStr1: String\n        inputStr2: String!\n        inputStrArr1: [String]\n        inputStrArr2: [String]!\n        inputStrArr3: [String!]\n        inputStrArr4: [String!]!\n\n        inputInt1: Int\n        inputInt2: Int!\n        inputIntArr1: [Int]\n        inputIntArr2: [Int]!\n        inputIntArr3: [Int!]\n        inputIntArr4: [Int!]!\n\n        inputCustom1: MyType2\n        inputCustom2: MyType2!\n        inputCustomArr1: [MyType2]\n        inputCustomArr2: [MyType2]!\n        inputCustomArr3: [MyType2!]\n        inputCustomArr4: [MyType2!]!\n      }\n\n      type MyType2 {\n        id: ID!\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => String, { nullable: true })\n      str1?: Maybe<Scalars['String']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => String)\n      str2!: Scalars['String'];\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: 'itemsAndList' })\n      strArr1?: Maybe<Array<Maybe<Scalars['String']>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: 'items' })\n      strArr2!: Array<Maybe<Scalars['String']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: true })\n      strArr3?: Maybe<Array<Scalars['String']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String])\n      strArr4!: Array<Scalars['String']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => TypeGraphQL.Int, { nullable: true })\n      int1?: Maybe<Scalars['Int']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => TypeGraphQL.Int)\n      int2!: Scalars['Int'];\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: 'itemsAndList' })\n      intArr1?: Maybe<Array<Maybe<Scalars['Int']>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: 'items' })\n      intArr2!: Array<Maybe<Scalars['Int']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: true })\n      intArr3?: Maybe<Array<Scalars['Int']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int])\n      intArr4!: Array<Scalars['Int']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => MyType2, { nullable: true })\n      custom1?: Maybe<MyType2>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => MyType2)\n      custom2!: FixDecorator<MyType2>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: 'itemsAndList' })\n      customArr1?: Maybe<Array<Maybe<MyType2>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: 'items' })\n      customArr2!: Array<Maybe<MyType2>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: true })\n      customArr3?: Maybe<Array<MyType2>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2])\n      customArr4!: Array<MyType2>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => String, { nullable: true })\n      inputStr1?: Maybe<Scalars['String']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => String)\n      inputStr2!: Scalars['String'];\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: 'itemsAndList' })\n      inputStrArr1?: Maybe<Array<Maybe<Scalars['String']>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: 'items' })\n      inputStrArr2!: Array<Maybe<Scalars['String']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String], { nullable: true })\n      inputStrArr3?: Maybe<Array<Scalars['String']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [String])\n      inputStrArr4!: Array<Scalars['String']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => TypeGraphQL.Int, { nullable: true })\n      inputInt1?: Maybe<Scalars['Int']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => TypeGraphQL.Int)\n      inputInt2!: Scalars['Int'];\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: 'itemsAndList' })\n      inputIntArr1?: Maybe<Array<Maybe<Scalars['Int']>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: 'items' })\n      inputIntArr2!: Array<Maybe<Scalars['Int']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int], { nullable: true })\n      inputIntArr3?: Maybe<Array<Scalars['Int']>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [TypeGraphQL.Int])\n      inputIntArr4!: Array<Scalars['Int']>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => MyType2, { nullable: true })\n      inputCustom1?: Maybe<MyType2>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => MyType2)\n      inputCustom2!: FixDecorator<MyType2>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: 'itemsAndList' })\n      inputCustomArr1?: Maybe<Array<Maybe<MyType2>>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: 'items' })\n      inputCustomArr2!: Array<Maybe<MyType2>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2], { nullable: true })\n      inputCustomArr3?: Maybe<Array<MyType2>>;\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.Field(type => [MyType2])\n      inputCustomArr4!: Array<MyType2>;\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should put the GraphQL description in the TypeGraphQL options",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 613,
                "column": 67
            },
            "line": 613,
            "code": "  it('should put the GraphQL description in the TypeGraphQL options', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      \"\"\"\n      Test type description\n      \"\"\"\n      type Test implements ITest {\n        \"\"\"\n        id field description\n        inside Test class\n        \"\"\"\n        id: ID\n\n        \"\"\"\n        mandatoryStr field description\n        \"\"\"\n        mandatoryStr: String!\n      }\n\n      \"\"\"\n      ITest interface description\n      \"\"\"\n      interface ITest {\n        \"\"\"\n        id field description\n        inside ITest interface\n        \"\"\"\n        id: ID\n      }\n\n      \"\"\"\n      TestInput input description\n      \"\"\"\n      input TestInput {\n        id: ID\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.ObjectType({ description: 'Test type description', implements: ITest })\n      export class Test extends ITest {\n        __typename?: 'Test';\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { description: 'id field description\\\\ninside Test class', nullable: true })\n        id?: Maybe<Scalars['ID']>;\n        @TypeGraphQL.Field(type => String, { description: 'mandatoryStr field description' })\n        mandatoryStr!: Scalars['String'];\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.InterfaceType({ description: 'ITest interface description' })\n      export abstract class ITest {\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { description: 'id field description\\\\ninside ITest interface', nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }\n    `);\n\n    expect(result.content).toBeSimilarStringTo(`\n      @TypeGraphQL.InputType({ description: 'TestInput input description' })\n      export class TestInput {\n\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }\n    `);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "should only generate TypeGraphQL decorators for included types",
            "suites": [
                "type-graphql"
            ],
            "updatePoint": {
                "line": 682,
                "column": 68
            },
            "line": 682,
            "code": "  it('should only generate TypeGraphQL decorators for included types', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      enum RegularEnum {\n        A\n        B\n      }\n\n      enum TypeGraphQLEnum {\n        A\n        B\n      }\n\n      interface IRegularInterfaceType {\n        id: ID\n      }\n\n      interface ITypeGraphQLInterfaceType {\n        id: ID\n      }\n\n      type RegularType {\n        id: ID\n      }\n\n      type TypeGraphQLType {\n        id: ID\n      }\n\n      input RegularInputType {\n        id: ID\n      }\n\n      input TypeGraphQLInputType {\n        id: ID\n      }\n\n      type Query {\n        regularFunction(mandatoryId: ID!, optionalId: ID): Boolean!\n        typeGraphQLFunction(mandatoryId: ID!, optionalId: ID): Boolean!\n      }\n    `);\n\n    const result = await plugin(\n      schema,\n      [],\n      {\n        decorateTypes: [\n          'TypeGraphQLEnum',\n          'ITypeGraphQLInterfaceType',\n          'TypeGraphQLType',\n          'TypeGraphQLInputType',\n          'QueryTypeGraphQlFunctionArgs',\n        ],\n      },\n      { outputFile: '' }\n    );\n\n    expect(result.content).not.toBeSimilarStringTo(\n      `TypeGraphQL.registerEnumType(RegularEnum, { name: 'RegularEnum' });`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `TypeGraphQL.registerEnumType(TypeGraphQlEnum, { name: 'TypeGraphQlEnum' });`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `export type IRegularInterfaceType = {\n        id?: Maybe<Scalars['ID']>;\n      };`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `\n      @TypeGraphQL.InterfaceType()\n      export abstract class ITypeGraphQlInterfaceType {\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `export type RegularType = {\n        __typename?: 'RegularType';\n        id?: Maybe<Scalars['ID']>;\n      };`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `@TypeGraphQL.ObjectType()\n      export class TypeGraphQlType {\n        __typename?: 'TypeGraphQLType';\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `export type RegularInputType = {\n        id?: Maybe<Scalars['ID']>;\n      };`\n    );\n\n    expect(result.content).toBeSimilarStringTo(\n      `@TypeGraphQL.InputType()\n      export class TypeGraphQlInputType {\n        @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n        id?: Maybe<Scalars['ID']>;\n      }`\n    );\n\n    expect(result.content).toBeSimilarStringTo(`\n    export type Query = {\n      __typename?: 'Query';\n      regularFunction: Scalars['Boolean'];\n      typeGraphQLFunction: Scalars['Boolean'];\n    };`);\n\n    expect(result.content).toBeSimilarStringTo(`export type QueryRegularFunctionArgs = {\n        mandatoryId: Scalars['ID'];\n        optionalId?: InputMaybe<Scalars['ID']>;\n      };`);\n\n    expect(result.content).toBeSimilarStringTo(` @TypeGraphQL.ArgsType()\n       export class QueryTypeGraphQlFunctionArgs {\n\n         @TypeGraphQL.Field(type => TypeGraphQL.ID)\n         mandatoryId!: Scalars['ID'];\n\n         @TypeGraphQL.Field(type => TypeGraphQL.ID, { nullable: true })\n         optionalId?: Maybe<Scalars['ID']>;\n       };`);\n  });",
            "file": "type-graphql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/type-graphql/tests"
        },
        {
            "name": "Should not output imports when there are no operations at all",
            "suites": [
                "TypedDocumentNode"
            ],
            "updatePoint": {
                "line": 6,
                "column": 67
            },
            "line": 6,
            "code": "  it('Should not output imports when there are no operations at all', async () => {\n    const result = (await plugin(null as any, [], {})) as Types.ComplexPluginOutput;\n    expect(result.content).toBe('');\n    expect(result.prepend.length).toBe(0);\n  });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Duplicated nested fragments handle (dedupeFragments=true)",
            "suites": [
                "TypedDocumentNode"
            ],
            "updatePoint": {
                "line": 12,
                "column": 63
            },
            "line": 12,
            "code": "  it('Duplicated nested fragments handle (dedupeFragments=true)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      schema {\n        query: Query\n      }\n\n      type Query {\n        jobs: [Job!]!\n      }\n\n      type Job {\n        id: ID!\n        recruiterName: String!\n        title: String!\n      }\n    `);\n\n    const ast = parse(/* GraphQL */ `\n      query GetJobs {\n        jobs {\n          ...DataForPageA\n          ...DataForPageB\n          ...JobSimpleRecruiterData\n        }\n      }\n\n      fragment DataForPageA on Job {\n        id\n        ...JobSimpleRecruiterData\n      }\n\n      fragment DataForPageB on Job {\n        title\n        ...JobSimpleRecruiterData\n      }\n\n      fragment JobSimpleRecruiterData on Job {\n        recruiterName\n      }\n    `);\n\n    const res = (await plugin(\n      schema,\n      [{ location: '', document: ast }],\n      { dedupeFragments: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect((res.content.match(/JobSimpleRecruiterDataFragmentDoc.definitions/g) || []).length).toBe(1);\n  });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Check with nested and recursive fragments handle (dedupeFragments=true)",
            "suites": [
                "TypedDocumentNode"
            ],
            "updatePoint": {
                "line": 63,
                "column": 77
            },
            "line": 63,
            "code": "  it('Check with nested and recursive fragments handle (dedupeFragments=true)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        test: MyType\n        nested: MyOtherType\n      }\n\n      type MyOtherType {\n        myType: MyType!\n        myOtherTypeRecursive: MyOtherType!\n      }\n\n      type MyType {\n        foo: String!\n      }\n    `);\n\n    const ast = parse(/* GraphQL */ `\n      query test {\n        test {\n          ...MyTypeFields\n          nested {\n            myOtherTypeRecursive {\n              myType {\n                ...MyTypeFields\n              }\n              myOtherTypeRecursive {\n                ...MyOtherTypeRecursiveFields\n              }\n            }\n            myType {\n              ...MyTypeFields\n            }\n          }\n        }\n      }\n\n      fragment MyOtherTypeRecursiveFields on MyOtherType {\n        myType {\n          ...MyTypeFields\n        }\n      }\n\n      fragment MyTypeFields on MyType {\n        foo\n      }\n    `);\n\n    const res = (await plugin(\n      schema,\n      [{ location: '', document: ast }],\n      { dedupeFragments: true },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect((res.content.match(/MyTypeFieldsFragmentDoc.definitions/g) || []).length).toBe(1);\n  });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Ignore duplicated nested fragments handle (dedupeFragments=false)",
            "suites": [
                "TypedDocumentNode"
            ],
            "updatePoint": {
                "line": 121,
                "column": 71
            },
            "line": 121,
            "code": "  it('Ignore duplicated nested fragments handle (dedupeFragments=false)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      schema {\n        query: Query\n      }\n\n      type Query {\n        jobs: [Job!]!\n      }\n\n      type Job {\n        id: ID!\n        recruiterName: String!\n        title: String!\n      }\n    `);\n\n    const ast = parse(/* GraphQL */ `\n      query GetJobs {\n        jobs {\n          ...DataForPageA\n          ...DataForPageB\n        }\n      }\n\n      fragment DataForPageA on Job {\n        id\n        ...JobSimpleRecruiterData\n      }\n\n      fragment DataForPageB on Job {\n        title\n        ...JobSimpleRecruiterData\n      }\n\n      fragment JobSimpleRecruiterData on Job {\n        recruiterName\n      }\n    `);\n\n    const res = (await plugin(\n      schema,\n      [{ location: '', document: ast }],\n      { dedupeFragments: false },\n      { outputFile: '' }\n    )) as Types.ComplexPluginOutput;\n\n    expect((res.content.match(/JobSimpleRecruiterDataFragmentDoc.definitions/g) || []).length).toBe(2);\n  });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Check is add __typename to typed document",
            "suites": [
                "TypedDocumentNode",
                "addTypenameToSelectionSets"
            ],
            "updatePoint": {
                "line": 172,
                "column": 49
            },
            "line": 172,
            "code": "    it('Check is add __typename to typed document', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          job: Job\n        }\n\n        type Job {\n          id: ID!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          job {\n            id\n          }\n        }\n      `);\n\n      const res = (await plugin(\n        schema,\n        [{ location: '', document: ast }],\n        { addTypenameToSelectionSets: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect((res.content.match(/__typename/g) || []).length).toBe(1);\n    });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "Check with __typename in selection set",
            "suites": [
                "TypedDocumentNode",
                "addTypenameToSelectionSets"
            ],
            "updatePoint": {
                "line": 205,
                "column": 46
            },
            "line": 205,
            "code": "    it('Check with __typename in selection set', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        schema {\n          query: Query\n        }\n\n        type Query {\n          job: Job\n        }\n\n        type Job {\n          id: ID!\n        }\n      `);\n\n      const ast = parse(/* GraphQL */ `\n        query {\n          job {\n            id\n            __typename\n          }\n        }\n      `);\n\n      const res = (await plugin(\n        schema,\n        [{ location: '', document: ast }],\n        { addTypenameToSelectionSets: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect((res.content.match(/__typename/g) || []).length).toBe(1);\n    });",
            "file": "typed-document-node.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typed-document-node/tests"
        },
        {
            "name": "should expose Maybe",
            "suites": [
                "TypeScript"
            ],
            "updatePoint": {
                "line": 7,
                "column": 25
            },
            "line": 7,
            "code": "  it('should expose Maybe', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      scalar A\n    `);\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.prepend).toBeSimilarStringTo('export type Maybe<T> =');\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should include a description for Scalars type",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 16,
                "column": 53
            },
            "line": 16,
            "code": "    it('Should include a description for Scalars type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom scalar\"\n        scalar A\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n          /** My custom scalar */\n          A: any;\n        };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add description for input types",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 37,
                "column": 46
            },
            "line": 37,
            "code": "    it('Should add description for input types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          f: String\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add description for input fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 51,
                "column": 47
            },
            "line": 51,
            "code": "    it('Should add description for input fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          \"f is something\"\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** MyInput */\n        export type MyInput = {\n          /** f is something */\n          f: Scalars['String'];\n        }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with multiline comment",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 69,
                "column": 42
            },
            "line": 69,
            "code": "    it('Should work with multiline comment', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        MyInput\n        multiline\n        \"\"\"\n        input MyInput {\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /**\n         * MyInput\n         * multiline\n         */\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with unions",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 89,
                "column": 31
            },
            "line": 89,
            "code": "    it('Should work with unions', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"my union\"\n        union A = B | C\n\n        type B {\n          id: ID\n        }\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** my union */\n        export type A = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with types",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 108,
                "column": 30
            },
            "line": 108,
            "code": "    it('Should work with types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"this is b\"\n        type B {\n          id: ID\n        }\n        \"this is c\"\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is b */\n        export type B = `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        /** this is c */\n        export type C = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with type fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 130,
                "column": 36
            },
            "line": 130,
            "code": "    it('Should work with type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type B {\n          \"the id\"\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type B = {\n        __typename?: 'B';\n        /** the id */\n        id?: Maybe<Scalars['ID']>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with inteface and inteface fields",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 147,
                "column": 53
            },
            "line": 147,
            "code": "    it('Should work with inteface and inteface fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          \"the id\"\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Node = {\n        /** the id */\n        id: Scalars['ID'];\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 163,
                "column": 45
            },
            "line": 163,
            "code": "    it('Should work with enum and enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export enum MyEnum {\n        /** this is a */\n        A = 'A',\n        /** this is b */\n        B = 'B'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should removed underscore from enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 185,
                "column": 50
            },
            "line": 185,
            "code": "    it('Should removed underscore from enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        ABC = 'A_B_C',\n        XYZ = 'X_Y_Z',\n        Test = '_TEST',\n        MyValue = 'My_Value'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum as const",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 205,
                "column": 38
            },
            "line": 205,
            "code": "    it('Should work with enum as const', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsConst: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnum = {\n        ABC: 'A_B_C',\n        XYZ: 'X_Y_Z',\n        Test: '_TEST',\n        MyValue: 'My_Value'\n      } as const;\n      export type MyEnum = typeof MyEnum[keyof typeof MyEnum];`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum as const combined with enum values",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 231,
                "column": 64
            },
            "line": 231,
            "code": "    it('Should work with enum as const combined with enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A_B_C\n          X_Y_Z\n          _TEST\n          My_Value\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          enumsAsConst: true,\n          enumValues: {\n            MyEnum: {\n              A_B_C: 0,\n              X_Y_Z: 'Foo',\n              _TEST: 'Bar',\n              My_Value: 1,\n            },\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyEnum = {\n        ABC: 0,\n        XYZ: 'Foo',\n        Test: 'Bar',\n        MyValue: 1\n      } as const;\n      export type MyEnum = typeof MyEnum[keyof typeof MyEnum];`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values (enumsAsTypes)",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 267,
                "column": 60
            },
            "line": 267,
            "code": "    it('Should work with enum and enum values (enumsAsTypes)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export type MyEnum =\n        /** this is a */\n        | 'A'\n        /** this is b */\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with directives",
            "suites": [
                "TypeScript",
                "description to comment"
            ],
            "updatePoint": {
                "line": 293,
                "column": 35
            },
            "line": 293,
            "code": "    it('Should work with directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom directive\"\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** Type overrides using directives */\n      export type DirectiveArgumentAndInputFieldMappings = {\n        /** My custom directive */\n        AsNumber: number;\n      };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not include a description for Scalars type",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 316,
                "column": 57
            },
            "line": 316,
            "code": "    it('Should not include a description for Scalars type', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"My custom scalar\"\n        scalar A\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n          ID: string;\n          String: string;\n          Boolean: boolean;\n          Int: number;\n          Float: number;\n          A: any;\n        };\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not add description for input types",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 335,
                "column": 50
            },
            "line": 335,
            "code": "    it('Should not add description for input types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          f: String\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not add description for input fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 348,
                "column": 51
            },
            "line": 348,
            "code": "    it('Should not add description for input fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"MyInput\"\n        input MyInput {\n          \"f is something\"\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          f: Scalars['String'];\n        }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should remove multiline comment",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 364,
                "column": 39
            },
            "line": 364,
            "code": "    it('Should remove multiline comment', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"\"\"\n        MyInput\n        multiline\n        \"\"\"\n        input MyInput {\n          f: String!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with unions",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 380,
                "column": 31
            },
            "line": 380,
            "code": "    it('Should work with unions', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"my union\"\n        union A = B | C\n\n        type B {\n          id: ID\n        }\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type A = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with types",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 398,
                "column": 30
            },
            "line": 398,
            "code": "    it('Should work with types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"this is b\"\n        type B {\n          id: ID\n        }\n        \"this is c\"\n        type C {\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type B = `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type C = `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with type fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 418,
                "column": 36
            },
            "line": 418,
            "code": "    it('Should work with type fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        type B {\n          \"the id\"\n          id: ID\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type B = {\n        __typename?: 'B';\n        id?: Maybe<Scalars['ID']>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with inteface and inteface fields",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 434,
                "column": 53
            },
            "line": 434,
            "code": "    it('Should work with inteface and inteface fields', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        interface Node {\n          \"the id\"\n          id: ID!\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Node = {\n        id: Scalars['ID'];\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 449,
                "column": 45
            },
            "line": 449,
            "code": "    it('Should work with enum and enum values', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = await plugin(schema, [], { disableDescriptions: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        B = 'B'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should work with enum and enum values (enumsAsTypes)",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 468,
                "column": 60
            },
            "line": 468,
            "code": "    it('Should work with enum and enum values (enumsAsTypes)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, disableDescriptions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyEnum =\n        | 'A'\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not work when config is false",
            "suites": [
                "TypeScript",
                "disable comment generation"
            ],
            "updatePoint": {
                "line": 491,
                "column": 44
            },
            "line": 491,
            "code": "    it('Should not work when config is false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        \"custom enum\"\n        enum MyEnum {\n          \"this is a\"\n          A\n          \"this is b\"\n          B\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, disableDescriptions: false },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** custom enum */\n      export type MyEnum =\n        /** this is a */\n        | 'A'\n        /** this is b */\n        | 'B';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#6815 - Generate different type for Maybe wrapper based on input variables",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 519,
                "column": 82
            },
            "line": 519,
            "code": "    it('#6815 - Generate different type for Maybe wrapper based on input variables', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test(id: ID): String\n          testWithInput(filter: Filter): String\n        }\n\n        input Filter {\n          a: String\n          b: Int\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          maybeValue: 'T | null',\n          inputMaybeValue: 'T | null | undefined',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      const output = mergeOutputs([result]);\n      expect(output).toContain(`export type InputMaybe<T> = T | null | undefined;`);\n      expect(output).toContain(`export type Maybe<T> = T | null;`);\n      expect(output).toContain(`test?: Maybe<Scalars['String']>;`);\n      expect(output).toContain(`id?: InputMaybe<Scalars['ID']>;`);\n      expect(output).toContain(`filter?: InputMaybe<Filter>;`);\n      expect(output).toContain(`a?: InputMaybe<Scalars['String']>;`);\n      expect(output).toContain(`b?: InputMaybe<Scalars['Int']>;`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#5643 - Incorrect combinations of declartionKinds leads to syntax error",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 552,
                "column": 79
            },
            "line": 552,
            "code": "    it('#5643 - Incorrect combinations of declartionKinds leads to syntax error', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Base {\n          id: ID!\n        }\n\n        type MyType implements Base {\n          id: ID!\n        }\n\n        type Query {\n          t: MyType!\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          declarationKind: {\n            type: 'class',\n            interface: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain(`export class MyType extends Base {`);\n      expect(output).toContain(`export class MyType implements Base {`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4564 - numeric enum values set on schema level",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 583,
                "column": 55
            },
            "line": 583,
            "code": "    it('#4564 - numeric enum values set on schema level', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    missing: {\n                      value: 0,\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(testSchema, [], {}, { outputFile: '' })) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain(`Missing = 'missing'`);\n      expect(output).toContain(`Missing = 0`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4564 - numeric enum values set on schema level - complex numeric",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 610,
                "column": 73
            },
            "line": 610,
            "code": "    it('#4564 - numeric enum values set on schema level - complex numeric', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    available: {\n                      value: '01',\n                    },\n                    somethingElse: {\n                      value: '99',\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(testSchema, [], {}, { outputFile: '' })) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toContain(`Available = '01'`);\n      expect(output).toContain(`SomethingElse = '99'`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7898 - falsy enum value set on schema with enumsAsTypes set",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 640,
                "column": 68
            },
            "line": 640,
            "code": "    it('#7898 - falsy enum value set on schema with enumsAsTypes set', async () => {\n      const testSchema = new GraphQLSchema({\n        types: [\n          new GraphQLObjectType({\n            name: 'Query',\n            fields: {\n              test: {\n                type: new GraphQLEnumType({\n                  name: 'MyEnum',\n                  values: {\n                    EnumValueName: {\n                      value: 0,\n                    },\n                  },\n                }),\n              },\n            },\n          }),\n        ],\n      });\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).not.toContain('EnumValueName');\n      expect(output).toContain('0');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#6532 - numeric enum values with namingConvention",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 672,
                "column": 57
            },
            "line": 672,
            "code": "    it('#6532 - numeric enum values with namingConvention', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test: Test!\n        }\n\n        enum Test {\n          Boop\n          BIP\n          BaP\n          TEST_VALUE\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          numericEnums: true,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toBeSimilarStringTo(`export enum Test {\n        Boop = 0,\n        Bip = 1,\n        BaP = 2,\n        TestValue = 3\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3137 - numeric enum value",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 703,
                "column": 34
            },
            "line": 703,
            "code": "    it('#3137 - numeric enum value', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Query {\n          test: Test!\n        }\n\n        enum Test {\n          A\n          B\n          C\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          enumValues: {\n            Test: {\n              A: 0,\n              B: 'test',\n              C: '2',\n            },\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      expect(output).toBeSimilarStringTo(`export enum Test {\n        A = 0,\n        B = 'test',\n        C = '2'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4157 - Should generate numeric values for enums if numericEnums is set to true",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 738,
                "column": 87
            },
            "line": 738,
            "code": "    it('#4157 - Should generate numeric values for enums if numericEnums is set to true', async () => {\n      const testSchema = buildSchema(/* GraphQl */ `\n        enum Status {\n            Idle\n            Running\n            Error\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          numericEnums: true,\n        },\n        {\n          outputFile: '',\n        }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      validateTs(output);\n\n      expect(output).toBeSimilarStringTo(`\n        export enum Status {\n            Idle = 0,\n            Running = 1,\n            Error = 2\n        }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2679 - incorrect prefix for enums",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 769,
                "column": 42
            },
            "line": 769,
            "code": "    it('#2679 - incorrect prefix for enums', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum FilterOption {\n          New\n          Active\n          Closed\n        }\n\n        input UpdateFilterOptionInput {\n          newOption: FilterOption!\n        }\n\n        type Query {\n          exampleQuery(i: UpdateFilterOptionInput, t: FilterOption): String\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          enumPrefix: false,\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      const output = mergeOutputs([result]);\n      validateTs(output);\n\n      expect(output).toBeSimilarStringTo(`\n      export enum FilterOption {\n        New = 'New',\n        Active = 'Active',\n        Closed = 'Closed'\n      }`);\n\n      expect(output).toBeSimilarStringTo(`\n      export type IUpdateFilterOptionInput = {\n        newOption: FilterOption;\n      };`);\n      expect(output).toBeSimilarStringTo(`\n      export type IQueryExampleQueryArgs = {\n        i?: InputMaybe<IUpdateFilterOptionInput>;\n        t?: InputMaybe<FilterOption>;\n      };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3180 - enumValues and named default import",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 816,
                "column": 51
            },
            "line": 816,
            "code": "    it('#3180 - enumValues and named default import', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        type Test {\n          t: MyEnum\n          test(a: MyEnum): String\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          namingConvention: { enumValues: 'change-case-all#constantCase' },\n          enumValues: {\n            MyEnum: './files#default as MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend[0]).toBe(`import MyEnum from './files';`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#4834 - enum members should be quoted if numeric",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 845,
                "column": 56
            },
            "line": 845,
            "code": "    it('#4834 - enum members should be quoted if numeric', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MediaItemSizeEnum {\n          AXB\n          _1X2\n          _3X4\n        }\n      `);\n\n      const result = (await plugin(testSchema, [], {})) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`export enum MediaItemSizeEnum {\n        Axb = 'AXB',\n        '1X2' = '_1X2',\n        '3X4' = '_3X4'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2976 - Issues with mapped enumValues and type prefix in args",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 863,
                "column": 69
            },
            "line": 863,
            "code": "    it('#2976 - Issues with mapped enumValues and type prefix in args', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        type Test {\n          t: MyEnum\n          test(a: MyEnum): String\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'I',\n          namingConvention: { enumValues: 'change-case-all#constantCase' },\n          enumValues: {\n            MyEnum: './files#MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`export type ITest = {\n        __typename?: 'Test';\n       t?: Maybe<MyEnum>;\n       test?: Maybe<Scalars['String']>;\n     };`);\n\n      expect(result.content).toBeSimilarStringTo(`export type ITestTestArgs = {\n      a?: InputMaybe<MyEnum>;\n    };`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#2082 - Issues with enumValues and types prefix",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 900,
                "column": 55
            },
            "line": 900,
            "code": "    it('#2082 - Issues with enumValues and types prefix', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n\n        enum OtherEnum {\n          V\n        }\n\n        type Test {\n          a: MyEnum\n          b: OtherEnum\n        }\n      `);\n      const result = (await plugin(\n        testSchema,\n        [],\n        {\n          typesPrefix: 'GQL_',\n          enumValues: {\n            MyEnum: './files#MyEnum',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toContain(`import { MyEnum } from './files';`);\n      expect(result.content).toContain(`enum GQL_OtherEnum {`);\n      expect(result.content).toContain(`a?: Maybe<MyEnum>;`);\n      expect(result.content).toContain(`b?: Maybe<GQL_OtherEnum>`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1488 - Should generate readonly also in input types when immutableTypes is set",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 934,
                "column": 87
            },
            "line": 934,
            "code": "    it('#1488 - Should generate readonly also in input types when immutableTypes is set', async () => {\n      const schema = buildSchema(`\n      input MyInput {\n        f: String!\n      }`);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { immutableTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        readonly f: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#3141 - @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 954,
                "column": 45
            },
            "line": 954,
            "code": "    it('#3141 - @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      type User {\n        fullName: String!\n        firstName: String! @deprecated(reason: \"Field \\`fullName\\` has been superseded by \\`firstName\\`.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type User = {\n        __typename?: 'User';\n        fullName: Scalars['String'];\n        /** @deprecated Field \\`fullName\\` has been superseded by \\`firstName\\`. */\n        firstName: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7627 - enum value @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 972,
                "column": 56
            },
            "line": 972,
            "code": "    it('#7627 - enum value @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B @deprecated(reason: \"Enum value \\`B\\` has been deprecated.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        /** @deprecated Enum value \\`B\\` has been deprecated. */\n        B = 'B'\n      }`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#7766 - input value @deprecated directive support",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 989,
                "column": 57
            },
            "line": 989,
            "code": "    it('#7766 - input value @deprecated directive support', async () => {\n      const schema = buildSchema(`\n      input MyInput {\n        A: Int\n        B: Int @deprecated(reason: \"input value \\`B\\` has been deprecated.\")\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        A?: InputMaybe<Scalars['Int']>;\n        /** @deprecated input value \\`B\\` has been deprecated. */\n        B?: InputMaybe<Scalars['Int']>;\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1462 - Union of scalars and argument of directive",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1006,
                "column": 58
            },
            "line": 1006,
            "code": "    it('#1462 - Union of scalars and argument of directive', async () => {\n      const schema = buildSchema(`\n      union Any = String | Int | Float | ID\n\n      directive @default(\n        value: Any,\n      ) on ENUM_VALUE | FIELD_DEFINITION\n\n      type CardEdge {\n        count: Int! @default(value: 1)\n      }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(\n        `export type Any = Scalars['String'] | Scalars['Int'] | Scalars['Float'] | Scalars['ID'];`\n      );\n      expect(result.content).toBeSimilarStringTo(`\n      export type CardEdge = {\n        __typename?: 'CardEdge';\n        count: Scalars['Int'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1954 - Duplicate type names for args type",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1030,
                "column": 50
            },
            "line": 1030,
            "code": "    it('#1954 - Duplicate type names for args type', async () => {\n      const schema = buildSchema(`\n      type PullRequest {\n        reviewThreads(first: Int!): Int\n      }\n\n      type PullRequestReview {\n          threads(first: Int!, last: Int!): Int\n      }`);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { addUnderscoreToArgsType: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain('PullRequest_ReviewThreadsArgs');\n      expect(result.content).toContain('PullRequestReview_ThreadsArgs');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "#1980 Do not put prefix on enums in args when enumPrefix: false",
            "suites": [
                "TypeScript",
                "Issues"
            ],
            "updatePoint": {
                "line": 1050,
                "column": 71
            },
            "line": 1050,
            "code": "    it('#1980 Do not put prefix on enums in args when enumPrefix: false', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum SuggestionType {\n          concern\n          goal\n        }\n\n        type Suggestion {\n          id: ID!\n          userId: ID!\n          suggestionType: SuggestionType!\n          text: String!\n        }\n\n        type RootQueryType {\n          suggestionsForUser(userId: ID!, suggestionType: SuggestionType!): [Suggestion!]\n        }\n      `);\n      const result = (await plugin(schema, [], {\n        skipTypename: true,\n        declarationKind: 'interface',\n        typesPrefix: 'I',\n        enumPrefix: false,\n        constEnums: true,\n        scalars: {\n          DateTime: 'string',\n          Time: 'string',\n          Date: 'string',\n        },\n      })) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface ISuggestion {\n            id: Scalars['ID'];\n            userId: Scalars['ID'];\n            suggestionType: SuggestionType;\n            text: Scalars['String'];\n          }\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n          export const enum SuggestionType {\n            Concern = 'concern',\n            Goal = 'goal'\n          };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface IRootQueryType {\n            suggestionsForUser?: Maybe<Array<ISuggestion>>;\n          }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n          export interface IRootQueryTypeSuggestionsForUserArgs {\n            userId: Scalars['ID'];\n            suggestionType: SuggestionType;\n          }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when specified with avoidOptionals config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1112,
                "column": 77
            },
            "line": 1112,
            "code": "    it('Should build type correctly when specified with avoidOptionals config', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n          bar: String!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build input type correctly when specified with avoidInputOptionals config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1136,
                "column": 88
            },
            "line": 1136,
            "code": "    it('Should build input type correctly when specified with avoidInputOptionals config', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          foo: String\n          bar: String!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: { inputValue: true } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          foo: InputMaybe<Scalars['String']>;\n          bar: Scalars['String'];\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when specified with immutableTypes config",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1160,
                "column": 77
            },
            "line": 1160,
            "code": "    it('Should build type correctly when specified with immutableTypes config', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: [String!]!\n        }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { immutableTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          readonly  __typename?: 'MyType';\n          readonly foo: ReadonlyArray<Scalars['String']>;\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use const enums when constEnums is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1181,
                "column": 53
            },
            "line": 1181,
            "code": "    it('Should use const enums when constEnums is set', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n      }`);\n      const result = await plugin(schema, [], { constEnums: true }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const enum MyEnum {\n        A = 'A'\n      };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use enum as type when enumsAsTypes is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1196,
                "column": 56
            },
            "line": 1196,
            "code": "    it('Should use enum as type when enumsAsTypes is set', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyEnum =\n          | 'A'\n          | 'B';\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use enum as type when enumsAsTypes is set and also enumValues",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1217,
                "column": 76
            },
            "line": 1217,
            "code": "    it('Should use enum as type when enumsAsTypes is set and also enumValues', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: { A: 'BOOP' } }, enumsAsTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyEnum =\n          | 'BOOP'\n          | 'B';\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum when futureProofEnums is set and also enumAsTypes",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1238,
                "column": 98
            },
            "line": 1238,
            "code": "    it('Should add `%future added value` to enum when futureProofEnums is set and also enumAsTypes', async () => {\n      const schema = buildSchema(`\n      enum MyEnum {\n        A\n        B\n      }\n\n      type MyType {\n        required: MyEnum!\n        optional: MyEnum\n      }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumsAsTypes: true, futureProofEnums: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyEnum =\n        | 'A'\n        | 'B'\n        | '%future added value'\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum;\n          optional?: Maybe<MyEnum>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum usage when futureProofEnums is set, but not enumAsTypes",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1273,
                "column": 104
            },
            "line": 1273,
            "code": "    it('Should add `%future added value` to enum usage when futureProofEnums is set, but not enumAsTypes', async () => {\n      const schema = buildSchema(`\n        enum MyEnum {\n          A\n          B\n        }\n\n        type MyType {\n          required: MyEnum!\n          optional: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { futureProofEnums: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum | '%future added value';\n          optional?: Maybe<MyEnum | '%future added value'>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%future added value` to enum usage when futureProofEnums is set and allowEnumStringTypes is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1309,
                "column": 115
            },
            "line": 1309,
            "code": "    it('Should add `%future added value` to enum usage when futureProofEnums is set and allowEnumStringTypes is set', async () => {\n      const schema = buildSchema(`\n        enum MyEnum {\n          A\n          B\n        }\n\n        type MyType {\n          required: MyEnum!\n          optional: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { futureProofEnums: true, allowEnumStringTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          required: MyEnum | '%future added value' | \\`\\${MyEnum}\\`;\n          optional?: Maybe<MyEnum | '%future added value' | \\`\\${MyEnum}\\`>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums (keep)",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1345,
                "column": 59
            },
            "line": 1345,
            "code": "    it('Should use custom namingConvention for enums (keep)', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            typeNames: 'change-case-all#lowerCase',\n            enumValues: 'keep',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum foo {\n          YES = 'YES',\n          NO = 'NO'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<foo>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums values as string, without specifying other type converters",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1392,
                "column": 111
            },
            "line": 1392,
            "code": "    it('Should use custom namingConvention for enums values as string, without specifying other type converters', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            enumValues: 'change-case-all#lowerCase',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum Foo {\n        yes = 'YES',\n        no = 'NO'\n      }`);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for enums",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1420,
                "column": 52
            },
            "line": 1420,
            "code": "    it('Should use custom namingConvention for enums', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum Foo {\n          YES\n          NO\n        }\n        type MyType {\n          foo(a: String!, b: String, c: [String], d: [Int!]!): Foo\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          namingConvention: {\n            typeNames: 'keep',\n            enumValues: 'change-case-all#lowerCase',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum Foo {\n          yes = 'YES',\n          no = 'NO'\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypefooArgs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo?: Maybe<Foo>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should handle introspection types (like __TypeKind)",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1468,
                "column": 59
            },
            "line": 1468,
            "code": "    it('should handle introspection types (like __TypeKind)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        type Post {\n          title: String\n        }\n        type Query {\n          post: Post!\n        }\n      `);\n      const query = parse(/* GraphQL */ `\n        query Info {\n          __type(name: \"Post\") {\n            name\n            fields {\n              name\n              type {\n                name\n                kind\n              }\n            }\n          }\n        }\n      `);\n\n      const result = (await plugin(\n        testSchema,\n        [{ location: '', document: query }],\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      /** An enum describing what kind of type a given \\`__Type\\` is. */\n      export enum __TypeKind {\n        /** Indicates this type is a scalar. */\n        Scalar = 'SCALAR',\n        /** Indicates this type is an object. \\`fields\\` and \\`interfaces\\` are valid fields. */\n        Object = 'OBJECT',\n        /** Indicates this type is an interface. \\`fields\\`, \\`interfaces\\`, and \\`possibleTypes\\` are valid fields. */\n        Interface = 'INTERFACE',\n        /** Indicates this type is a union. \\`possibleTypes\\` is a valid field. */\n        Union = 'UNION',\n        /** Indicates this type is an enum. \\`enumValues\\` is a valid field. */\n        Enum = 'ENUM',\n        /** Indicates this type is an input object. \\`inputFields\\` is a valid field. */\n        InputObject = 'INPUT_OBJECT',\n        /** Indicates this type is a list. \\`ofType\\` is a valid field. */\n        List = 'LIST',\n        /** Indicates this type is a non-null. \\`ofType\\` is a valid field. */\n        NonNull = 'NON_NULL'\n      }\n      `);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use class correctly when declarationKind: class is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1524,
                "column": 69
            },
            "line": 1524,
            "code": "    it('Should use class correctly when declarationKind: class is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'class',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export class MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export class MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for type when declarationKind for types is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1563,
                "column": 75
            },
            "line": 1563,
            "code": "    it('Should use interface for type when declarationKind for types is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            type: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for input when declarationKind for inputs is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1603,
                "column": 77
            },
            "line": 1603,
            "code": "    it('Should use interface for input when declarationKind for inputs is set', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            input: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for arguments when declarationKind for arguments is set",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1643,
                "column": 84
            },
            "line": 1643,
            "code": "    it('Should use interface for arguments when declarationKind for arguments is set', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          id: ID!\n          displayName: String\n          child(id: ID!): MyType\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: {\n            arguments: 'interface',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          child?: Maybe<MyType>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyTypeChildArgs {\n          id: Scalars['ID'];\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use interface for all objects when declarationKind is interface",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1679,
                "column": 78
            },
            "line": 1679,
            "code": "    it('Should use interface for all objects when declarationKind is interface', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType {\n          id: ID!\n          displayName: String\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {\n          id: Scalars['ID'];\n          displayName?: InputMaybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should correctly render empty interfaces",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1717,
                "column": 48
            },
            "line": 1717,
            "code": "    it('Should correctly render empty interfaces', async () => {\n      const schema = buildSchema(`\n        input MyInput\n\n        type MyType\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInput {}\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType {\n          __typename?: 'MyType';\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should extend one interface from another",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1744,
                "column": 48
            },
            "line": 1744,
            "code": "    it('Should extend one interface from another', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          id: ID!\n          displayName: String\n        }\n\n        type MyType implements MyInterface {\n          id: ID!\n          displayName: String\n          value: Int\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface {\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType extends MyInterface {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should extend mutiple interfaces",
            "suites": [
                "TypeScript",
                "Config"
            ],
            "updatePoint": {
                "line": 1784,
                "column": 40
            },
            "line": 1784,
            "code": "    it('Should extend mutiple interfaces', async () => {\n      const schema = buildSchema(`\n        interface MyInterface1 {\n          id: ID!\n          displayName: String\n        }\n\n        interface MyInterface2 {\n          value: Int\n        }\n\n        type MyType implements MyInterface1 & MyInterface2 {\n          id: ID!\n          displayName: String\n          value: Int\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          declarationKind: 'interface',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface1 {\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyInterface2 {\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export interface MyType extends MyInterface1, MyInterface2 {\n          __typename?: 'MyType';\n          id: Scalars['ID'];\n          displayName?: Maybe<Scalars['String']>;\n          value?: Maybe<Scalars['Int']>;\n        }\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for built-in scalars",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1836,
                "column": 72
            },
            "line": 1836,
            "code": "    it('Should generate a scalars mapping correctly for built-in scalars', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String\n        bar: String!\n      }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['String'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly when using scalars as path",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1862,
                "column": 78
            },
            "line": 1862,
            "code": "    it('Should generate a scalars mapping correctly when using scalars as path', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          scalars: '../../scalars',\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.prepend).toContain(`import { MyScalar } from '../../scalars';`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: String;\n        Boolean: Boolean;\n        Int: number;\n        Float: number;\n        MyScalar: MyScalar;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should import a type of a mapped scalar",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1899,
                "column": 47
            },
            "line": 1899,
            "code": "    it('Should import a type of a mapped scalar', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n      scalar MyOtherScalar\n      scalar MyAliasedScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n        baz: MyOtherScalar!\n        qux: MyAliasedScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        {\n          scalars: {\n            MyScalar: '../../scalars#default',\n            MyOtherScalar: '../../scalars#MyOtherScalar',\n            MyAliasedScalar: '../../scalars#MyAliasedScalar as AliasedScalar',\n          },\n        },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      // It seems like we don't group imports...\n      expect(result.prepend).toContain(`import MyScalar from '../../scalars';`);\n      expect(result.prepend).toContain(`import { MyOtherScalar } from '../../scalars';`);\n      expect(result.prepend).toContain(`import { MyAliasedScalar as AliasedScalar } from '../../scalars';`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: MyScalar;\n        MyOtherScalar: MyOtherScalar;\n        MyAliasedScalar: AliasedScalar;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n        baz: Scalars['MyOtherScalar'];\n        qux: Scalars['MyAliasedScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for custom scalars",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1951,
                "column": 70
            },
            "line": 1951,
            "code": "    it('Should generate a scalars mapping correctly for custom scalars', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: any;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate a scalars mapping correctly for custom scalars with mapping",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 1980,
                "column": 83
            },
            "line": 1980,
            "code": "    it('Should generate a scalars mapping correctly for custom scalars with mapping', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { scalars: { MyScalar: 'Date' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: Date;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should correctly throw an error when an unknown scalar is detected while using `strictScalars`",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2014,
                "column": 102
            },
            "line": 2014,
            "code": "    it('Should correctly throw an error when an unknown scalar is detected while using `strictScalars`', () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n\n      expect(() => {\n        plugin(schema, [], { strictScalars: true }, { outputFile: '' });\n      }).toThrow('Unknown scalar type MyScalar');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow overriding default scalar type",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2028,
                "column": 51
            },
            "line": 2028,
            "code": "    it('Should allow overriding default scalar type', async () => {\n      const schema = buildSchema(`\n      scalar MyScalar\n\n      type MyType {\n        foo: String\n        bar: MyScalar!\n      }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { defaultScalarType: 'unknown' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n        MyScalar: unknown;\n      };`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        foo?: Maybe<Scalars['String']>;\n        bar: Scalars['MyScalar'];\n      };`);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add FieldWrapper when field definition wrapping is enabled",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2062,
                "column": 73
            },
            "line": 2062,
            "code": "    it('Should add FieldWrapper when field definition wrapping is enabled', async () => {\n      const schema = buildSchema(`\n      scalar A\n      `);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toBeSimilarStringTo('export type FieldWrapper<T> =');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow the FieldWrapper type to be modified",
            "suites": [
                "TypeScript",
                "Scalars"
            ],
            "updatePoint": {
                "line": 2077,
                "column": 57
            },
            "line": 2077,
            "code": "    it('Should allow the FieldWrapper type to be modified', async () => {\n      const schema = buildSchema(`\n      scalar A\n      `);\n\n      const result = (await plugin(\n        schema,\n        [],\n        { fieldWrapperValue: 'T | Promise<T>', wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n      expect(result.prepend).toBeSimilarStringTo('export type FieldWrapper<T> = T | Promise<T>');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2094,
                "column": 35
            },
            "line": 2094,
            "code": "    it('Should build type correctly', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing interface",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2112,
                "column": 63
            },
            "line": 2112,
            "code": "    it('Should build type correctly when implementing interface', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface {\n          foo: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n          foo: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing multiple interfaces",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2138,
                "column": 73
            },
            "line": 2138,
            "code": "    it('Should build type correctly when implementing multiple interfaces', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        interface MyOtherInterface {\n          bar: String!\n        }\n\n        type MyType implements MyInterface & MyOtherInterface {\n          foo: String!\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherInterface = {\n          bar: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & MyOtherInterface & {\n          __typename?: 'MyType';\n          foo: Scalars['String'];\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when implementing interface without adding fields",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2175,
                "column": 85
            },
            "line": 2175,
            "code": "    it('Should build type correctly when implementing interface without adding fields', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: Scalars['String'];\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly with links between types",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2198,
                "column": 60
            },
            "line": 2198,
            "code": "    it('Should build type correctly with links between types', async () => {\n      const schema = buildSchema(`\n        type MyType {\n          foo: MyOtherType!\n        }\n\n        type MyOtherType {\n          bar: String!\n        }\n        `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = {\n          __typename?: 'MyType';\n          foo: MyOtherType;\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyOtherType = {\n          __typename?: 'MyOtherType';\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build type correctly when wrapping field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2225,
                "column": 67
            },
            "line": 2225,
            "code": "    it('Should build type correctly when wrapping field definitions', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String!\n        }\n\n        type MyType implements MyInterface {\n          foo: String!\n        }\n        `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo: FieldWrapper<Scalars['String']>;\n        };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyType = MyInterface & {\n          __typename?: 'MyType';\n          foo: FieldWrapper<Scalars['String']>;\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2256,
                "column": 72
            },
            "line": 2256,
            "code": "    it('Should build list type correctly when wrapping field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: Array<FieldWrapper<Scalars['String']>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: Array<Maybe<FieldWrapper<Scalars['String']>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping entire field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2290,
                "column": 79
            },
            "line": 2290,
            "code": "    it('Should build list type correctly when wrapping entire field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapEntireFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: EntireFieldWrapper<Array<Scalars['String']>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: EntireFieldWrapper<Array<Maybe<Scalars['String']>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build list type correctly when wrapping both field definitions and entire field definitions",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2324,
                "column": 106
            },
            "line": 2324,
            "code": "    it('Should build list type correctly when wrapping both field definitions and entire field definitions', async () => {\n      const schema = buildSchema(`\n        type ListOfStrings {\n          foo: [String!]!\n        }\n\n        type ListOfMaybeStrings {\n          foo: [String]!\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapEntireFieldDefinitions: true, wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfStrings = {\n          __typename?: 'ListOfStrings';\n          foo: EntireFieldWrapper<Array<FieldWrapper<Scalars['String']>>>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type ListOfMaybeStrings = {\n          __typename?: 'ListOfMaybeStrings';\n          foo: EntireFieldWrapper<Array<Maybe<FieldWrapper<Scalars['String']>>>>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should not wrap input type fields",
            "suites": [
                "TypeScript",
                "Object (type)"
            ],
            "updatePoint": {
                "line": 2358,
                "column": 41
            },
            "line": 2358,
            "code": "    it('Should not wrap input type fields', async () => {\n      const schema = buildSchema(`\n        input MyInput {\n          foo: String!\n        }\n        `);\n      const result = (await plugin(\n        schema,\n        [],\n        { wrapFieldDefinitions: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          foo: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build union as type correctly",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2381,
                "column": 44
            },
            "line": 2381,
            "code": "    it('Should build union as type correctly', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType;\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%other` object typename to union when futureProofUnions is set",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2399,
                "column": 82
            },
            "line": 2399,
            "code": "    it('Should add `%other` object typename to union when futureProofUnions is set', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], { futureProofUnions: true }, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType | { __typename?: \"%other\" };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add `%other` object typename to union when futureProofUnions and immutableTypes is set",
            "suites": [
                "TypeScript",
                "Union"
            ],
            "updatePoint": {
                "line": 2417,
                "column": 101
            },
            "line": 2417,
            "code": "    it('Should add `%other` object typename to union when futureProofUnions and immutableTypes is set', async () => {\n      const schema = buildSchema(`\n      type MyType {\n        foo: String!\n      }\n\n      type MyOtherType {\n        bar: String!\n      }\n\n      union MyUnion = MyType | MyOtherType\n      `);\n      const result = await plugin(schema, [], { futureProofUnions: true, immutableTypes: true }, { outputFile: '' });\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = MyType | MyOtherType | { readonly __typename?: \"%other\" };\n    `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build interface correctly",
            "suites": [
                "TypeScript",
                "Interface"
            ],
            "updatePoint": {
                "line": 2438,
                "column": 40
            },
            "line": 2438,
            "code": "    it('Should build interface correctly', async () => {\n      const schema = buildSchema(`\n        interface MyInterface {\n          foo: String\n          bar: String!\n        }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInterface = {\n          foo?: Maybe<Scalars['String']>;\n          bar: Scalars['String'];\n        };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should handle directive declarations correctly",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2457,
                "column": 54
            },
            "line": 2457,
            "code": "    it('Should handle directive declarations correctly', async () => {\n      const schema = buildSchema(`\n        directive @simple on FIELD_DEFINITION\n        directive @withArgument(arg: Int!) on FIELD_DEFINITION\n        directive @objSimple on OBJECT\n        directive @universal on OBJECT | FIELD_DEFINITION | ENUM_VALUE\n      `);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).not.toContain('simple');\n      expect(result.content).not.toContain('withArguments');\n      expect(result.content).not.toContain('objSimple');\n      expect(result.content).not.toContain('universal');\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should handle type override",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2474,
                "column": 35
            },
            "line": 2474,
            "code": "    it('Should handle type override', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n\n        type Query {\n          myField(id: ID! @AsNumber): Boolean\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type DirectiveArgumentAndInputFieldMappings = {\n        AsNumber: number;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        myField?: Maybe<Scalars['Boolean']>;\n      };\n\n      export type QueryMyFieldArgs = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow imported types",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2515,
                "column": 35
            },
            "line": 2515,
            "code": "    it('Should allow imported types', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        {\n          directiveArgumentAndInputFieldMappings: { AsNumber: './someModule#MyType' },\n          directiveArgumentAndInputFieldMappingTypeSuffix: 'Model',\n        },\n        { outputFile: '' }\n      );\n\n      expect(result.prepend).toContain(\"import { MyType as MyTypeModel } from './someModule';\");\n      expect(result.content).toBeSimilarStringTo(`\n      export type DirectiveArgumentAndInputFieldMappings = {\n        AsNumber: MyTypeModel;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsNumber'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use last directive override",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2547,
                "column": 42
            },
            "line": 2547,
            "code": "    it('Should use last directive override', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n        directive @AsString on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber @AsString\n        }\n      `);\n      const result = await plugin(\n        schema,\n        [],\n        { directiveArgumentAndInputFieldMappings: { AsNumber: 'number', AsString: 'AsString' } },\n        { outputFile: '' }\n      );\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: DirectiveArgumentAndInputFieldMappings['AsString'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should ignore unmapped directives",
            "suites": [
                "TypeScript",
                "Directives"
            ],
            "updatePoint": {
                "line": 2571,
                "column": 41
            },
            "line": 2571,
            "code": "    it('Should ignore unmapped directives', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        directive @AsNumber on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION\n\n        input MyInput {\n          id: ID! @AsNumber\n        }\n      `);\n      const result = await plugin(schema, [], { directiveArgumentAndInputFieldMappings: {} }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyInput = {\n        id: Scalars['ID'];\n      };\n      `);\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "correct output for type with single field",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2594,
                "column": 51
            },
            "line": 2594,
            "code": "      it('correct output for type with single field', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "correct output for type with multiple fields",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2615,
                "column": 54
            },
            "line": 2615,
            "code": "      it('correct output for type with multiple fields', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "raises exception for type with non-optional fields",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2638,
                "column": 60
            },
            "line": 2638,
            "code": "      it('raises exception for type with non-optional fields', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int!\n            boolean: Boolean!\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        try {\n          await plugin(schema, [], {}, { outputFile: '' });\n          throw new Error('Plugin should have raised an exception.');\n        } catch (err) {\n          expect(err.message).toEqual(\n            'Fields on an input object type can not be non-nullable. It seems like the schema was not validated.'\n          );\n        }\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "handles extensions properly",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2662,
                "column": 37
            },
            "line": 2662,
            "code": "      it('handles extensions properly', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input @oneOf {\n            int: Int\n          }\n\n          extend input Input {\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "handles .isOneOf property on input object types properly",
            "suites": [
                "TypeScript",
                "Directives",
                "@oneOf on input types"
            ],
            "updatePoint": {
                "line": 2687,
                "column": 66
            },
            "line": 2687,
            "code": "      it('handles .isOneOf property on input object types properly', async () => {\n        const schema = buildSchema(\n          /* GraphQL */ `\n          input Input {\n            int: Int\n            boolean: Boolean\n          }\n\n          type Query {\n            foo(input: Input!): Boolean!\n          }\n        `.concat(oneOfDirectiveDefinition)\n        );\n\n        const inputType: Record<'isOneOf', boolean> = schema.getType('Input') as any;\n        inputType.isOneOf = true;\n\n        const result = await plugin(schema, [], {}, { outputFile: '' });\n        expect(result.content).toBeSimilarStringTo(`\n          export type Input =\n            { int: Scalars['Int']; boolean?: never; }\n            | { int?: never; boolean: Scalars['Boolean']; };\n        `);\n      });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention for type name and args typename",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2715,
                "column": 74
            },
            "line": 2715,
            "code": "    it('Should use custom namingConvention for type name and args typename', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should use custom namingConvention and add custom prefix",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2742,
                "column": 64
            },
            "line": 2742,
            "code": "    it('Should use custom namingConvention and add custom prefix', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase', typesPrefix: 'I' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytypefooargs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type Imytype = {\n          __typename?: 'MyType';\n          foo?: Maybe<Scalars['String']>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should allow to disable typesPrefix for enums",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2770,
                "column": 53
            },
            "line": 2770,
            "code": "    it('Should allow to disable typesPrefix for enums', async () => {\n      const schema = buildSchema(`type T { f: String, e: E } enum E { A }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { typesPrefix: 'I', enumPrefix: false },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain(`export enum E {`);\n      expect(result.content).toContain(`e?: Maybe<E>;`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should enable typesPrefix for enums by default",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2785,
                "column": 54
            },
            "line": 2785,
            "code": "    it('Should enable typesPrefix for enums by default', async () => {\n      const schema = buildSchema(`type T { f: String, e: E } enum E { A }`);\n      const result = await plugin(schema, [], { typesPrefix: 'I' }, { outputFile: '' });\n\n      expect(result.content).toContain(`export enum IE {`);\n      expect(result.content).toContain(`e?: Maybe<IE>;`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - lowerCase",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2837,
                "column": 81
            },
            "line": 2837,
            "code": "    it('Should generate correct values when using links between types - lowerCase', async () => {\n      const result = (await plugin(\n        schema,\n        [],\n        { namingConvention: 'change-case-all#lowerCase' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum myenum {\n          a = 'A',\n          b = 'B',\n          c = 'C'\n        }\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type mytype = {\n          __typename?: 'MyType';\n          f?: Maybe<Scalars['String']>;\n          bar?: Maybe<myenum>;\n          b_a_r?: Maybe<Scalars['String']>;\n          myOtherField?: Maybe<Scalars['String']>;\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type my_type = {\n          __typename?: 'My_Type';\n          linkTest?: Maybe<mytype>;\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type myunion = my_type | mytype;\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type some_interface = {\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl1 = some_interface & {\n          __typename?: 'Impl1';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl_2 = some_interface & {\n          __typename?: 'Impl_2';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type impl_3 = some_interface & {\n          __typename?: 'impl_3';\n          id: Scalars['ID'];\n        };\n        `);\n      expect(result.content).toBeSimilarStringTo(`\n        export type query = {\n          __typename?: 'Query';\n          something?: Maybe<myunion>;\n          use_interface?: Maybe<some_interface>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default)",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2904,
                "column": 92
            },
            "line": 2904,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default)', async () => {\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum MyEnum {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      }\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyType = {\n        __typename?: 'MyType';\n        f?: Maybe<Scalars['String']>;\n        bar?: Maybe<MyEnum>;\n        b_a_r?: Maybe<Scalars['String']>;\n        myOtherField?: Maybe<Scalars['String']>;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type My_Type = {\n        __typename?: 'My_Type';\n        linkTest?: Maybe<MyType>;\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type MyUnion = My_Type | MyType;\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Some_Interface = {\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl1 = Some_Interface & {\n        __typename?: 'Impl1';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl_2 = Some_Interface & {\n        __typename?: 'Impl_2';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Impl_3 = Some_Interface & {\n        __typename?: 'impl_3';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type Query = {\n        __typename?: 'Query';\n        something?: Maybe<MyUnion>;\n        use_interface?: Maybe<Some_Interface>;\n      };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correct values when using links between types - pascalCase (default) with custom prefix",
            "suites": [
                "TypeScript",
                "Naming Convention & Types Prefix"
            ],
            "updatePoint": {
                "line": 2966,
                "column": 111
            },
            "line": 2966,
            "code": "    it('Should generate correct values when using links between types - pascalCase (default) with custom prefix', async () => {\n      const result = await plugin(schema, [], { typesPrefix: 'I' }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export enum IMyEnum {\n        A = 'A',\n        B = 'B',\n        C = 'C'\n      }`);\n\n      expect(result.content).toBeSimilarStringTo(`\n      export type IMyType = {\n        __typename?: 'MyType';\n        f?: Maybe<Scalars['String']>;\n        bar?: Maybe<IMyEnum>;\n        b_a_r?: Maybe<Scalars['String']>;\n        myOtherField?: Maybe<Scalars['String']>;\n      };`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IMy_Type = {\n        __typename?: 'My_Type';\n        linkTest?: Maybe<IMyType>;\n      };\n  `);\n      expect(result.content).toBeSimilarStringTo(`export type IMyUnion = IMy_Type | IMyType;`);\n      expect(result.content).toBeSimilarStringTo(`\n      export type ISome_Interface = {\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl1 = ISome_Interface & {\n        __typename?: 'Impl1';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl_2 = ISome_Interface & {\n        __typename?: 'Impl_2';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IImpl_3 = ISome_Interface & {\n        __typename?: 'impl_3';\n        id: Scalars['ID'];\n      };\n      `);\n      expect(result.content).toBeSimilarStringTo(`\n      export type IQuery = {\n        __typename?: 'Query';\n        something?: Maybe<IMyUnion>;\n        use_interface?: Maybe<ISome_Interface>;\n      };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with basic fields",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3027,
                "column": 79
            },
            "line": 3027,
            "code": "    it('Should generate correctly types for field arguments - with basic fields', async () => {\n      const schema = buildSchema(`type MyType { foo(a: String!, b: String, c: [String], d: [Int!]!): String }`);\n\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a: Scalars['String'];\n          b?: InputMaybe<Scalars['String']>;\n          c?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n          d: Array<Scalars['Int']>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with default value",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3044,
                "column": 80
            },
            "line": 3044,
            "code": "    it('Should generate correctly types for field arguments - with default value', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with default value and avoidOptionals option set to true",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3062,
                "column": 118
            },
            "line": 3062,
            "code": "    it('Should generate correctly types for field arguments - with default value and avoidOptionals option set to true', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n      };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments - with input type",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3085,
                "column": 77
            },
            "line": 3085,
            "code": "    it('Should generate correctly types for field arguments - with input type', async () => {\n      const schema = buildSchema(\n        `input MyInput { f: String } type MyType { foo(a: MyInput, b: MyInput!, c: [MyInput], d: [MyInput]!, e: [MyInput!]!): String }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<MyInput>;\n          b: MyInput;\n          c?: InputMaybe<Array<InputMaybe<MyInput>>>;\n          d: Array<InputMaybe<MyInput>>;\n          e: Array<MyInput>;\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should add custom prefix for mutation arguments",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3104,
                "column": 55
            },
            "line": 3104,
            "code": "    it('Should add custom prefix for mutation arguments', async () => {\n      const schema = buildSchema(`input Input { name: String } type Mutation { foo(id: ID, input: Input): String }`);\n      const result = await plugin(schema, [], { typesPrefix: 'T' }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type TInput = {\n          name?: InputMaybe<Scalars['String']>;\n        };\n      `);\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type TMutation = {\n          __typename?: 'Mutation';\n          foo?: Maybe<Scalars['String']>;\n        };\n\n        export type TMutationFooArgs = {\n          id?: InputMaybe<Scalars['ID']>;\n          input?: InputMaybe<TInput>;\n        };\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate the correct type for a method with arguments (interface object)",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3129,
                "column": 87
            },
            "line": 3129,
            "code": "    it('Should generate the correct type for a method with arguments (interface object)', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        interface Node {\n          text(arg1: String!, arg2: String): String\n        }\n\n        type Book implements Node {\n          id: ID!\n          text(arg: String, arg2: String!): String\n        }\n\n        type Query {\n          books: [Book!]!\n        }\n      `);\n      const result = await plugin(testSchema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type NodeTextArgs = {\n          arg1: Scalars['String'];\n          arg2?: InputMaybe<Scalars['String']>;\n        };\n      `);\n      await validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for inputs with default value - #4273",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3155,
                "column": 77
            },
            "line": 3155,
            "code": "    it('Should generate correctly types for inputs with default value - #4273', async () => {\n      const schema = buildSchema(\n        `input MyInput { a: String = \"default\", b: String! = \"default\", c: String, d: String! }`\n      );\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          a?: InputMaybe<Scalars['String']>;\n          b?: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for inputs with default value and avoidOptionals.defaultValue set to true - #5112",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3173,
                "column": 121
            },
            "line": 3173,
            "code": "    it('Should generate correctly types for inputs with default value and avoidOptionals.defaultValue set to true - #5112', async () => {\n      const schema = buildSchema(\n        `input MyInput { a: String = \"default\", b: String! = \"default\", c: String, d: String! }`\n      );\n      const result = await plugin(schema, [], { avoidOptionals: { defaultValue: true } }, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyInput = {\n          a?: InputMaybe<Scalars['String']>;\n          b: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should generate correctly types for field arguments with default value and avoidOptionals.defaultValue option set to true - #5112",
            "suites": [
                "TypeScript",
                "Arguments"
            ],
            "updatePoint": {
                "line": 3191,
                "column": 137
            },
            "line": 3191,
            "code": "    it('Should generate correctly types for field arguments with default value and avoidOptionals.defaultValue option set to true - #5112', async () => {\n      const schema = buildSchema(\n        `type MyType { foo(a: String = \"default\", b: String! = \"default\", c: String, d: String!): String }`\n      );\n      const result = (await plugin(\n        schema,\n        [],\n        { avoidOptionals: { defaultValue: true } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export type MyTypeFooArgs = {\n          a?: InputMaybe<Scalars['String']>;\n          b: Scalars['String'];\n          c?: InputMaybe<Scalars['String']>;\n          d: Scalars['String'];\n        };\n    `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build basic enum correctly",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3216,
                "column": 41
            },
            "line": 3216,
            "code": "    it('Should build basic enum correctly', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = await plugin(schema, [], {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'A',\n          B = 'B',\n          C = 'C'\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom values",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3231,
                "column": 54
            },
            "line": 3231,
            "code": "    it('Should build enum correctly with custom values', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: { A: 'SomeValue', B: 'TEST' } } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toBeSimilarStringTo(`\n        export enum MyEnum {\n          A = 'SomeValue',\n          B = 'TEST',\n          C = 'C'\n        }\n      `);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3251,
                "column": 61
            },
            "line": 3251,
            "code": "    it('Should build enum correctly with custom imported enum', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.prepend).toContain(`import { MyEnum } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum from namspace with different name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3266,
                "column": 95
            },
            "line": 3266,
            "code": "    it('Should build enum correctly with custom imported enum from namspace with different name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#NS.ETest' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).toContain(`export { MyEnum }`);\n      expect(result.prepend).toContain(`import MyEnum = NS.ETest;`);\n      expect(result.prepend).toContain(`import { NS } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum from namspace with same name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3283,
                "column": 90
            },
            "line": 3283,
            "code": "    it('Should build enum correctly with custom imported enum from namspace with same name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#NS.MyEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.prepend).toContain(`import MyEnum = NS.MyEnum;`);\n      expect(result.prepend).toContain(`import { NS } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should build enum correctly with custom imported enum with different name",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3300,
                "column": 81
            },
            "line": 3300,
            "code": "    it('Should build enum correctly with custom imported enum with different name', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } type Query { t: MyEnum }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyCustomEnum' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.prepend).toContain(`import { MyCustomEnum } from './my-file';`);\n      expect(result.prepend).toContain(`import MyEnum = MyCustomEnum;`);\n      expect(result.content).toContain(`export { MyEnum };`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should import all enums from a single file when specified as string",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3317,
                "column": 75
            },
            "line": 3317,
            "code": "    it('Should import all enums from a single file when specified as string', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: './my-file' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).not.toContain(`export enum MyEnum`);\n      expect(result.content).not.toContain(`export enum MyEnum2`);\n      expect(result.prepend).toContain(`import { MyEnum } from './my-file';`);\n      expect(result.prepend).toContain(`import { MyEnum2 } from './my-file';`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should re-export external enums",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3334,
                "column": 39
            },
            "line": 3334,
            "code": "    it('Should re-export external enums', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: { MyEnum: './my-file#MyEnum', MyEnum2: './my-file#MyEnum2X' } },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.content).toContain(`export { MyEnum2 };`);\n      expect(result.prepend).toContain(`import MyEnum2 = MyEnum2X;`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should re-export external enums when single file option used",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3350,
                "column": 68
            },
            "line": 3350,
            "code": "    it('Should re-export external enums when single file option used', async () => {\n      const schema = buildSchema(`enum MyEnum { A, B, C } enum MyEnum2 { X, Y, Z }`);\n      const result = (await plugin(\n        schema,\n        [],\n        { enumValues: './my-file' },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(result.content).toContain(`export { MyEnum };`);\n      expect(result.content).toContain(`export { MyEnum2 };`);\n\n      validateTs(result);\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "allowEnumStringTypes",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3365,
                "column": 28
            },
            "line": 3365,
            "code": "    it('allowEnumStringTypes', async () => {\n      const schema = buildSchema(/* GraphQL */ `\n        enum MyEnum {\n          A\n          B\n          C\n        }\n        type Query {\n          a: MyEnum\n        }\n      `);\n      const result = (await plugin(\n        schema,\n        [],\n        { allowEnumStringTypes: true },\n        { outputFile: '' }\n      )) as Types.ComplexPluginOutput;\n\n      validateTs(result);\n\n      expect(result.content).toBeSimilarStringTo('a?: Maybe<MyEnum | `${MyEnum}`>;');\n    });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not have [object Object]",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3389,
                "column": 37
            },
            "line": 3389,
            "code": "  it('should not have [object Object]', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n\n      type SubscriptionRoot {\n        newUser: User\n      }\n\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const content = await plugin(schema, [], {}, { outputFile: '' });\n\n    expect(content).not.toContainEqual('[object Object]');\n\n    validateTs(content);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should contain __typename",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3422,
                "column": 31
            },
            "line": 3422,
            "code": "  it('should contain __typename', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], {}, { outputFile: '' });\n    expect(result.content).toContain('__typename');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not contain __typename",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3450,
                "column": 35
            },
            "line": 3450,
            "code": "  it('should not contain __typename', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], { skipTypename: true }, { outputFile: '' });\n    expect(result.content).not.toContain('__typename');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should not contain \"export\" when noExport is set to true",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3478,
                "column": 62
            },
            "line": 3478,
            "code": "  it('should not contain \"export\" when noExport is set to true', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type User {\n        id: Int!\n        name: String!\n        email: String!\n      }\n      type QueryRoot {\n        allUsers: [User]!\n        userById(id: Int!): User\n        # Generates a new answer for the guessing game\n        answer: [Int!]!\n      }\n      type SubscriptionRoot {\n        newUser: User\n      }\n      schema {\n        query: QueryRoot\n        subscription: SubscriptionRoot\n      }\n    `);\n\n    const result = await plugin(schema, [], { noExport: true }, { outputFile: '' });\n    expect(result.content).not.toContain('export');\n\n    validateTs(result);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should keep non-optional arguments non-optional - issue #2323",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3506,
                "column": 67
            },
            "line": 3506,
            "code": "  it('should keep non-optional arguments non-optional - issue #2323', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      enum OrderBy {\n        name\n        id\n      }\n\n      input Filter {\n        contain: String\n      }\n\n      type Node {\n        id: ID!\n        name: String!\n      }\n\n      type Connection {\n        nodes: [Node]\n      }\n\n      type Query {\n        list(after: String, orderBy: OrderBy = name, filter: Filter!): Connection!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        avoidOptionals: false,\n        maybeValue: 'T | undefined',\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    // Filter.contain should be optional\n    expect(output.content).toBeSimilarStringTo(`\n      export type Filter = {\n        contain?: InputMaybe<Scalars['String']>;\n      };\n    `);\n    // filter should be non-optional\n    expect(output.content).toBeSimilarStringTo(`\n      export type QueryListArgs = {\n        after?: InputMaybe<Scalars['String']>;\n        orderBy?: InputMaybe<OrderBy>;\n        filter: Filter;\n      };\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should respect defined enum values",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3557,
                "column": 40
            },
            "line": 3557,
            "code": "  it('should respect defined enum values', async () => {\n    const testSchema = new GraphQLSchema({\n      query: new GraphQLObjectType({\n        name: 'Query',\n        fields: {\n          foo: {\n            type: new GraphQLEnumType({\n              name: 'Foo',\n              values: {\n                Bar: {\n                  value: 'Qux',\n                },\n              },\n            }),\n          },\n        },\n      }),\n    });\n    const output = await plugin(testSchema, [], {}, { outputFile: 'graphql.ts' });\n\n    expect(output.content).toBeSimilarStringTo(`\n      export enum Foo {\n        Bar = 'Qux'\n      }\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "should use implementing types as node type - issue #5126",
            "suites": [
                "TypeScript",
                "Enum"
            ],
            "updatePoint": {
                "line": 3584,
                "column": 62
            },
            "line": 3584,
            "code": "  it('should use implementing types as node type - issue #5126', async () => {\n    const testSchema = buildSchema(/* GraphQL */ `\n      type Matrix {\n        pills: [Pill!]!\n      }\n\n      interface Pill {\n        id: ID!\n      }\n\n      type RedPill implements Pill {\n        red: String!\n      }\n\n      type GreenPill implements Pill {\n        green: String!\n      }\n\n      interface Foo {\n        id: ID!\n      }\n\n      type Bar implements Foo {\n        lol: String!\n      }\n\n      type Hello {\n        foo: Foo!\n      }\n\n      type NoInterface {\n        hello: Hello!\n      }\n\n      interface NestedInterface implements Foo {\n        field: String!\n      }\n\n      type NestedType1 implements NestedInterface {\n        hi: String!\n      }\n\n      type NestedType2 implements NestedInterface {\n        ho: String!\n      }\n\n      type NestedField {\n        nested: NestedInterface!\n      }\n    `);\n\n    const output = (await plugin(\n      testSchema,\n      [],\n      {\n        useImplementingTypes: true,\n      } as any,\n      { outputFile: 'graphql.ts' }\n    )) as Types.ComplexPluginOutput;\n\n    expect(output.content).toMatchSnapshot();\n\n    // Type should be Array<RedPill|GreenPill> and not Pill\n    expect(output.content).toBeSimilarStringTo(`\n      export type Matrix = {\n        __typename?: 'Matrix';\n        pills: Array<RedPill | GreenPill>;\n      };\n    `);\n    // Type should be Bar and not Foo\n    expect(output.content).toBeSimilarStringTo(`\n      export type Hello = {\n        __typename?: 'Hello';\n        foo: Bar;\n      };\n    `);\n    // Type should be Hello and not empty\n    expect(output.content).toBeSimilarStringTo(`\n      export type NoInterface = {\n        __typename?: 'NoInterface';\n        hello: Hello;\n      };\n    `);\n    // Type should be NestedType1|NestedType2\n    expect(output.content).toBeSimilarStringTo(`\n      export type NestedField = {\n        __typename?: 'NestedField';\n        nested: NestedType1 | NestedType2;\n      };\n    `);\n  });",
            "file": "typescript.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/typescript/tests"
        },
        {
            "name": "Should output the cache-generic correctly",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 7,
                "column": 47
            },
            "line": 7,
            "code": "  it('Should output the cache-generic correctly', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        todos: [Todo]\n      }\n\n      type Mutation {\n        toggleTodo(id: ID!): Todo!\n        toggleTodos(id: [ID!]!): [Todo!]!\n        toggleTodosOptionalArray(id: [ID!]!): [Todo!]\n        toggleTodosOptionalEntity(id: [ID!]!): [Todo]!\n        toggleTodosOptional(id: [ID!]!): [Todo]\n      }\n\n      type Author {\n        id: ID\n        name: String\n        friends: [Author]\n        friendsPaginated(from: Int!, limit: Int!): [Author]\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n        author: Author\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should output the cache-generic correctly (with unions)",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 39,
                "column": 61
            },
            "line": 39,
            "code": "  it('Should output the cache-generic correctly (with unions)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        media: [Media]\n      }\n\n      type Mutation {\n        updateMedia(id: ID!): Media\n      }\n\n      union Media = Book | Movie\n\n      type Book {\n        id: ID\n        title: String\n        pages: Int\n      }\n\n      type Movie {\n        id: ID\n        title: String\n        duration: Int\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should output the cache-generic correctly (with interfaces)",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 67,
                "column": 65
            },
            "line": 67,
            "code": "  it('Should output the cache-generic correctly (with interfaces)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        schoolBooks: [CoolBook]\n      }\n\n      type Author {\n        id: ID\n        name: String\n        friends: [Author]\n        friendsPaginated(from: Int!, limit: Int!): [Author]\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n        author: Author\n      }\n\n      interface CoolBook {\n        id: ID\n        title: String\n        author: Author\n      }\n\n      type Textbook implements CoolBook {\n        id: ID\n        title: String\n        author: Author\n        todo: Todo\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should output the cache-generic correctly (with typesPrefix and typesSuffix)",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 104,
                "column": 82
            },
            "line": 104,
            "code": "  it('Should output the cache-generic correctly (with typesPrefix and typesSuffix)', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        todos: [Todo]\n      }\n\n      type Mutation {\n        toggleTodo(id: ID!): Todo!\n        toggleTodos(id: [ID!]!): [Todo!]!\n        toggleTodosOptionalArray(id: [ID!]!): [Todo!]\n        toggleTodosOptionalEntity(id: [ID!]!): [Todo]!\n        toggleTodosOptional(id: [ID!]!): [Todo]\n      }\n\n      type Author {\n        id: ID\n        name: String\n        friends: [Author]\n        friendsPaginated(from: Int!, limit: Int!): [Author]\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n        author: Author\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], { typesPrefix: 'Prefix', typesSuffix: 'Suffix' })]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "should emit type imports if useTypeImports config value is used",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 136,
                "column": 69
            },
            "line": 136,
            "code": "  it('should emit type imports if useTypeImports config value is used', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      type Query {\n        todos: [Todo]\n      }\n\n      type Mutation {\n        toggleTodo(id: ID!): Todo!\n        toggleTodos(id: [ID!]!): [Todo!]!\n        toggleTodosOptionalArray(id: [ID!]!): [Todo!]\n        toggleTodosOptionalEntity(id: [ID!]!): [Todo]!\n        toggleTodosOptional(id: [ID!]!): [Todo]\n      }\n\n      type Author {\n        id: ID\n        name: String\n        friends: [Author]\n        friendsPaginated(from: Int!, limit: Int!): [Author]\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n        author: Author\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], { useTypeImports: true })]);\n\n    expect(result).toBeSimilarStringTo(\n      `import type { Resolver as GraphCacheResolver, UpdateResolver as GraphCacheUpdateResolver, OptimisticMutationResolver as GraphCacheOptimisticMutationResolver, StorageAdapter as GraphCacheStorageAdapter } from '@urql/exchange-graphcache';\nimport type { IntrospectionData } from '@urql/exchange-graphcache/dist/types/ast';`\n    );\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should correctly name GraphCacheResolvers & GraphCacheOptimisticUpdaters with nonstandard mutationType names",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 172,
                "column": 114
            },
            "line": 172,
            "code": "  it('Should correctly name GraphCacheResolvers & GraphCacheOptimisticUpdaters with nonstandard mutationType names', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      schema {\n        query: Query_Root\n        mutation: Mutation_Root\n      }\n\n      type Query_Root {\n        todos: [Todo]\n      }\n\n      type Mutation_Root {\n        toggleTodo(id: ID!): Todo!\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should correctly output GraphCacheOptimisticUpdaters when there are no mutations",
            "suites": [
                "urql graphcache"
            ],
            "updatePoint": {
                "line": 197,
                "column": 86
            },
            "line": 197,
            "code": "  it('Should correctly output GraphCacheOptimisticUpdaters when there are no mutations', async () => {\n    const schema = buildSchema(/* GraphQL */ `\n      schema {\n        query: Query_Root\n      }\n\n      type Query_Root {\n        todos: [Todo]\n      }\n\n      type Todo {\n        id: ID\n        text: String\n        complete: Boolean\n      }\n    `);\n    const result = mergeOutputs([await plugin(schema, [], {})]);\n    expect(result).toMatchSnapshot();\n  });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-graphcache/tests"
        },
        {
            "name": "Should ouput correct results based on operations only",
            "suites": [
                "svelte urql operations store types"
            ],
            "updatePoint": {
                "line": 6,
                "column": 59
            },
            "line": 6,
            "code": "  it('Should ouput correct results based on operations only', async () => {\n    const result = (await plugin(\n      null as any,\n      [\n        {\n          document: parse(`query me { id }`),\n        },\n        {\n          document: parse(`mutation doSomething { id }`),\n        },\n        {\n          document: parse(`query { id }`),\n        },\n        {\n          document: parse(`fragment Test on Test { t }`),\n        },\n      ],\n      {}\n    )) as Types.ComplexPluginOutput;\n    expect(result.content).toContain('export type MeQueryStore = OperationStore<MeQuery, MeQueryVariables>;');\n    expect(result.content).toContain(\n      'export type DoSomethingMutationStore = OperationStore<DoSomethingMutation, DoSomethingMutationVariables>;'\n    );\n    expect(result.prepend).toContain(`import type { OperationStore } from '@urql/svelte';`);\n  });",
            "file": "plugins.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql-svelte-operations-store/test"
        },
        {
            "name": "should import Urql and React dependencies when components are used",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 51,
                "column": 74
            },
            "line": 51,
            "code": "    it('should import Urql and React dependencies when components are used', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withComponent: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Urql from 'urql';`);\n      expect(content.prepend).toContain(`import * as React from 'react';`);\n      expect(content.prepend).toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 70,
                "column": 58
            },
            "line": 70,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 88,
                "column": 58
            },
            "line": 88,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should import Urql from urqlImportFrom config option",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 103,
                "column": 60
            },
            "line": 103,
            "code": "    it('should import Urql from urqlImportFrom config option', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, urqlImportFrom: 'custom-urql' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Urql from 'custom-urql';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate basic fragments documents correctly",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 120,
                "column": 59
            },
            "line": 120,
            "code": "    it('Should generate basic fragments documents correctly', async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment MyFragment on Repository {\n              full_name\n            }\n\n            query test {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const result = await plugin(schema, docs, {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyFragmentFragmentDoc = gql\\`\n      fragment MyFragment on Repository {\n        full_name\n      }\n      \\`;`);\n      await validateTypeScript(result, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should generate Document variables for inline fragments",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 148,
                "column": 63
            },
            "line": 148,
            "code": "    it('should generate Document variables for inline fragments', async () => {\n      const repositoryWithOwner = gql`\n        fragment RepositoryWithOwner on Repository {\n          full_name\n          html_url\n          owner {\n            avatar_url\n          }\n        }\n      `;\n      const feedWithRepository = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          commentCount\n          repository(search: \"phrase\") {\n            ...RepositoryWithOwner\n          }\n        }\n\n        ${repositoryWithOwner}\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n\n        ${feedWithRepository}\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const FeedWithRepositoryFragmentDoc = gql\\`\nfragment FeedWithRepository on Entry {\n  id\n  commentCount\n  repository(search: \"phrase\") {\n    ...RepositoryWithOwner\n  }\n}\n\\${RepositoryWithOwnerFragmentDoc}\\`;`);\n      expect(content.content).toBeSimilarStringTo(`export const RepositoryWithOwnerFragmentDoc = gql\\`\nfragment RepositoryWithOwner on Repository {\n  full_name\n  html_url\n  owner {\n    avatar_url\n  }\n}\n\\`;`);\n\n      expect(content.content).toBeSimilarStringTo(`export const MyFeedDocument = gql\\`\nquery MyFeed {\n  feed {\n    ...FeedWithRepository\n  }\n}\n\\${FeedWithRepositoryFragmentDoc}\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should avoid generating duplicate fragments",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 219,
                "column": 51
            },
            "line": 219,
            "code": "    it('should avoid generating duplicate fragments', async () => {\n      const simpleFeed = gql`\n        fragment Item on Entry {\n          id\n        }\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...Item\n          }\n          allFeeds: feed {\n            ...Item\n          }\n        }\n      `;\n      const documents = [simpleFeed, myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        export const MyFeedDocument = gql\\`\n        query MyFeed {\n            feed {\n              ...Item\n            }\n            allFeeds: feed {\n              ...Item\n            }\n          }\n          \\${ItemFragmentDoc}\\``);\n      expect(content.content).toBeSimilarStringTo(`\n        export const ItemFragmentDoc = gql\\`\n        fragment Item on Entry {\n          id\n        }\n\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate fragments in proper order (when one depends on other)",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 266,
                "column": 77
            },
            "line": 266,
            "code": "    it('Should generate fragments in proper order (when one depends on other)', async () => {\n      const myFeed = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          repository {\n            ...RepositoryWithOwner\n          }\n        }\n\n        fragment RepositoryWithOwner on Repository {\n          full_name\n        }\n\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n      `;\n      const documents = [myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const feedWithRepositoryPos = content.content.indexOf('fragment FeedWithRepository');\n      const repositoryWithOwnerPos = content.content.indexOf('fragment RepositoryWithOwner');\n      expect(repositoryWithOwnerPos).toBeLessThan(feedWithRepositoryPos);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should generate Document variable",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 304,
                "column": 41
            },
            "line": 304,
            "code": "    it('should generate Document variable', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          export const TestDocument =  gql\\`\n          query test {\n            feed {\n              id\n              commentCount\n              repository {\n                full_name\n                html_url\n                owner {\n                  avatar_url\n                }\n              }\n            }\n          }\n          \\`;\n        `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should generate Document variable with noGraphQlTag",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 335,
                "column": 59
            },
            "line": 335,
            "code": "    it('should generate Document variable with noGraphQlTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"avatar_url\"}}]}}]}}]}}]}}]} as unknown as DocumentNode;`\n      );\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should not generate Component by default",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 359,
                "column": 48
            },
            "line": 359,
            "code": "    it('should not generate Component by default', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`\n      export const TestComponent = (props: Omit<Urql.QueryProps<TestQuery, TestQueryVariables>,  'query'> & { variables?: TestQueryVariables }) =>\n      (\n          <Urql.Query {...props} query={TestDocument} />\n      );\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should not generate Component",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 379,
                "column": 37
            },
            "line": 379,
            "code": "    it('should not generate Component', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComponent: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export class TestComponent`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should make variables property required if any of variable definitions is non-null",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 394,
                "column": 90
            },
            "line": 394,
            "code": "    it('should make variables property required if any of variable definitions is non-null', async () => {\n      const docs = [\n        {\n          location: '',\n          document: gql`\n            query Test($foo: String!) {\n              test(foo: $foo)\n            }\n          `,\n        },\n      ];\n      const schema = buildASTSchema(gql`\n        type Query {\n          test(foo: String!): Boolean\n        }\n      `);\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withComponent: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: Omit<Urql.QueryProps<TestQuery, TestQueryVariables>, 'query'> & { variables: TestQueryVariables }) => (\n        <Urql.Query {...props} query={TestDocument} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should make variables property optional if operationType is mutation",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 428,
                "column": 76
            },
            "line": 428,
            "code": "    it('should make variables property optional if operationType is mutation', async () => {\n      const docs = [\n        {\n          location: '',\n          document: gql`\n            mutation Test($foo: String!) {\n              test(foo: $foo)\n            }\n          `,\n        },\n      ];\n      const schema = buildASTSchema(gql`\n        type Mutation {\n          test(foo: String!): Boolean\n        }\n      `);\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withComponent: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export const TestComponent = (props: Omit<Urql.MutationProps<TestMutation, TestMutationVariables>, 'query'> & { variables?: TestMutationVariables }) => (\n        <Urql.Mutation {...props} query={TestDocument} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should not add typesPrefix to Component",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 462,
                "column": 47
            },
            "line": 462,
            "code": "    it('should not add typesPrefix to Component', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export class ITestComponent`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should respect omitOperationSuffix for Component",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 476,
                "column": 56
            },
            "line": 476,
            "code": "    it('should respect omitOperationSuffix for Component', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { omitOperationSuffix: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export class TestComponent`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should add three generics if operation type is subscription",
            "suites": [
                "urql",
                "Component"
            ],
            "updatePoint": {
                "line": 490,
                "column": 67
            },
            "line": 490,
            "code": "    it('should add three generics if operation type is subscription', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withComponent: true,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export const ListenToCommentsComponent = (props: Omit<Urql.SubscriptionProps<ListenToCommentsSubscription, ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>, 'query'> & { variables?: ListenToCommentsSubscriptionVariables }) => (\n        <Urql.Subscription {...props} query={ListenToCommentsDocument} />\n      );`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate hooks for query and mutation",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 521,
                "column": 52
            },
            "line": 521,
            "code": "    it('Should generate hooks for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useFeedQuery(options?: Omit<Urql.UseQueryArgs<FeedQueryVariables>, 'query'>) {\n  return Urql.useQuery<FeedQuery>({ query: FeedDocument, ...options });\n};`);\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useSubmitRepositoryMutation() {\n  return Urql.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument);\n};`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate hooks for query with required arguments",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 566,
                "column": 63
            },
            "line": 566,
            "code": "    it('Should generate hooks for query with required arguments', async () => {\n      const documents = parse(/* GraphQL */ `\n        query RequiredArg($feedType: FeedType!, $limit: Int = 10) {\n          feed(type: $feedType, limit: $limit) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false },\n        { outputFile: 'graphql.tsx' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useRequiredArgQuery(options: Omit<Urql.UseQueryArgs<RequiredArgQueryVariables>, 'query'>) {\n  return Urql.useQuery<RequiredArgQuery>({ query: RequiredArgDocument, ...options });\n};`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate hooks for query with default value arguments",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 590,
                "column": 68
            },
            "line": 590,
            "code": "    it('Should generate hooks for query with default value arguments', async () => {\n      const documents = parse(/* GraphQL */ `\n        query DefaultValueArg($feedType: FeedType! = \"HOT\", $limit: Int) {\n          feed(type: $feedType, limit: $limit) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, withComponent: false },\n        { outputFile: 'graphql.tsx' }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useDefaultValueArgQuery(options?: Omit<Urql.UseQueryArgs<DefaultValueArgQueryVariables>, 'query'>) {\n  return Urql.useQuery<DefaultValueArgQuery>({ query: DefaultValueArgDocument, ...options });\n};`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should not generate hooks for query and mutation",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 614,
                "column": 56
            },
            "line": 614,
            "code": "    it('Should not generate hooks for query and mutation', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: false },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should generate subscription hooks",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 629,
                "column": 42
            },
            "line": 629,
            "code": "    it('Should generate subscription hooks', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withHooks: true,\n          withComponent: false,\n        },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useListenToCommentsSubscription<TData = ListenToCommentsSubscription>(options: Omit<Urql.UseSubscriptionArgs<ListenToCommentsSubscriptionVariables>, 'query'> = {}, handler?: Urql.SubscriptionHandler<ListenToCommentsSubscription, TData>) {\n        return Urql.useSubscription<ListenToCommentsSubscription, TData, ListenToCommentsSubscriptionVariables>({ query: ListenToCommentsDocument, ...options }, handler);\n      };`);\n      await validateTypeScript(content, schema, docs, {});\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should not add typesPrefix to hooks",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 660,
                "column": 43
            },
            "line": 660,
            "code": "    it('Should not add typesPrefix to hooks', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTestQuery`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "Should respect omitOperationSuffix for hooks",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 674,
                "column": 52
            },
            "line": 674,
            "code": "    it('Should respect omitOperationSuffix for hooks', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, omitOperationSuffix: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTest(`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should respect dedupeOperationSuffix for hooks",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 688,
                "column": 54
            },
            "line": 688,
            "code": "    it('should respect dedupeOperationSuffix for hooks', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            query testQuery {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withHooks: true, dedupeOperationSuffix: true },\n        {\n          outputFile: 'graphql.tsx',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTestQuery(`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 713,
                "column": 104
            },
            "line": 713,
            "code": "    it('should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importDocumentNodeExternallyFrom must be provided if documentMode=external'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set to something other than \"Operations\"",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 733,
                "column": 94
            },
            "line": 733,
            "code": "    it('output warning if importOperationTypesFrom is set to something other than \"Operations\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Whatever',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importOperationTypesFrom only works correctly when left empty or set to \"Operations\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and documentMode is not \"external\"",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 754,
                "column": 92
            },
            "line": 754,
            "code": "    it('output warning if importOperationTypesFrom is set and documentMode is not \"external\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 774,
                "column": 101
            },
            "line": 774,
            "code": "    it('output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should allow importing operations and documents from another file",
            "suites": [
                "urql",
                "Hooks"
            ],
            "updatePoint": {
                "line": 795,
                "column": 73
            },
            "line": 795,
            "code": "    it('should allow importing operations and documents from another file', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n          importDocumentNodeExternallyFrom: '@myproject/generated',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from '@myproject/generated';`);\n\n      expect(content.content).toContain('Operations.TestDocument');\n      expect(content.content).toContain('Operations.TestQuery');\n      expect(content.content).toContain('Operations.TestQueryVariables');\n\n      expect(content.content).not.toContain('Urql.UseOperations');\n      expect(content.content).toContain('Urql.UseQueryArgs');\n      expect(content.content).toContain('Urql.useQuery');\n\n      await validateTypeScript(content, schema, docs, {});\n\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/urql/tests"
        },
        {
            "name": "should import operation function dependencies",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 69,
                "column": 53
            },
            "line": 69,
            "code": "    it('should import operation function dependencies', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(\n        `import { createMutationFunction, createSmartQueryOptionsFunction, createSmartSubscriptionOptionsFunction } from 'vue-apollo-smart-ops';`\n      );\n      expect(content.prepend).toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import operation function dependencies from configured packages",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 87,
                "column": 78
            },
            "line": 87,
            "code": "    it('should import operation function dependencies from configured packages', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloOperationFunctionsImportFrom: 'custom-operation-functions-package',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(\n        `import { createMutationFunction, createSmartQueryOptionsFunction, createSmartSubscriptionOptionsFunction } from 'custom-operation-functions-package';`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import ApolloError type dependency",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 106,
                "column": 49
            },
            "line": 106,
            "code": "    it('should import ApolloError type dependency', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { ApolloError } from 'apollo-client';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import ApolloError type dependency from configured package",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 121,
                "column": 73
            },
            "line": 121,
            "code": "    it('should import ApolloError type dependency from configured package', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloErrorType: 'CustomApolloError',\n          vueApolloErrorTypeImportFrom: 'custom-error-package',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { CustomApolloError } from 'custom-error-package';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import error handler function dependency from configured package",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 139,
                "column": 79
            },
            "line": 139,
            "code": "    it('should import error handler function dependency from configured package', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloErrorHandlerFunction: 'handleApolloError',\n          vueApolloErrorHandlerFunctionImportFrom: 'custom-error-handler',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { handleApolloError } from 'custom-error-handler';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Vue app type dependency from configured package",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 157,
                "column": 69
            },
            "line": 157,
            "code": "    it('should import Vue app type dependency from configured package', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueAppType: 'CustomApp',\n          vueAppTypeImportFrom: 'my-app',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { CustomApp } from 'my-app';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 175,
                "column": 58
            },
            "line": 175,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "Vue Apollo Operations",
                "Imports"
            ],
            "updatePoint": {
                "line": 193,
                "column": 58
            },
            "line": 193,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate basic fragments documents correctly",
            "suites": [
                "Vue Apollo Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 210,
                "column": 59
            },
            "line": 210,
            "code": "    it('Should generate basic fragments documents correctly', async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment MyFragment on Repository {\n              full_name\n            }\n\n            query {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const result = await plugin(schema, docs, {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyFragmentFragmentDoc = gql\\`\n      fragment MyFragment on Repository {\n        full_name\n      }\n      \\`;`);\n      await validateTypeScript(result, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should generate Document variables for inline fragments",
            "suites": [
                "Vue Apollo Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 238,
                "column": 63
            },
            "line": 238,
            "code": "    it('should generate Document variables for inline fragments', async () => {\n      const repositoryWithOwner = gql`\n        fragment RepositoryWithOwner on Repository {\n          full_name\n          html_url\n          owner {\n            avatar_url\n          }\n        }\n      `;\n      const feedWithRepository = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          commentCount\n          repository(search: \"phrase\") {\n            ...RepositoryWithOwner\n          }\n        }\n\n        ${repositoryWithOwner}\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n\n        ${feedWithRepository}\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const FeedWithRepositoryFragmentDoc = gql\\`\nfragment FeedWithRepository on Entry {\n  id\n  commentCount\n  repository(search: \"phrase\") {\n    ...RepositoryWithOwner\n  }\n}\n\\${RepositoryWithOwnerFragmentDoc}\\`;`);\n      expect(content.content).toBeSimilarStringTo(`export const RepositoryWithOwnerFragmentDoc = gql\\`\nfragment RepositoryWithOwner on Repository {\n  full_name\n  html_url\n  owner {\n    avatar_url\n  }\n}\n\\`;`);\n\n      expect(content.content).toBeSimilarStringTo(`export const MyFeedDocument = gql\\`\nquery MyFeed {\n  feed {\n    ...FeedWithRepository\n  }\n}\n\\${FeedWithRepositoryFragmentDoc}\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should avoid generating duplicate fragments",
            "suites": [
                "Vue Apollo Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 309,
                "column": 51
            },
            "line": 309,
            "code": "    it('should avoid generating duplicate fragments', async () => {\n      const simpleFeed = gql`\n        fragment Item on Entry {\n          id\n        }\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...Item\n          }\n          allFeeds: feed {\n            ...Item\n          }\n        }\n      `;\n      const documents = [simpleFeed, myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        export const MyFeedDocument = gql\\`\n        query MyFeed {\n            feed {\n              ...Item\n            }\n            allFeeds: feed {\n              ...Item\n            }\n          }\n          \\${ItemFragmentDoc}\\``);\n      expect(content.content).toBeSimilarStringTo(`\n        export const ItemFragmentDoc = gql\\`\n        fragment Item on Entry {\n          id\n        }\n\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate fragments in proper order (when one depends on other)",
            "suites": [
                "Vue Apollo Operations",
                "Fragments"
            ],
            "updatePoint": {
                "line": 356,
                "column": 77
            },
            "line": 356,
            "code": "    it('Should generate fragments in proper order (when one depends on other)', async () => {\n      const myFeed = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          repository {\n            ...RepositoryWithOwner\n          }\n        }\n\n        fragment RepositoryWithOwner on Repository {\n          full_name\n        }\n\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n      `;\n      const documents = [myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const feedWithRepositoryPos = content.content.indexOf('fragment FeedWithRepository');\n      const repositoryWithOwnerPos = content.content.indexOf('fragment RepositoryWithOwner');\n      expect(repositoryWithOwnerPos).toBeLessThan(feedWithRepositoryPos);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate operation functions for query and mutation",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 394,
                "column": 66
            },
            "line": 394,
            "code": "    it('Should generate operation functions for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  ApolloError\n>(FeedDocument);`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError\n>(SubmitRepositoryDocument);`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should use custom ApolloError type and handler for operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 444,
                "column": 78
            },
            "line": 444,
            "code": "    it('Should use custom ApolloError type and handler for operation functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloErrorType: 'CustomApolloError',\n          vueApolloErrorTypeImportFrom: 'custom-error-type',\n          vueApolloErrorHandlerFunction: 'handleApolloError',\n          vueApolloErrorHandlerFunctionImportFrom: 'custom-error-handler',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  CustomApolloError\n>(FeedDocument, handleApolloError);`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  CustomApolloError\n>(SubmitRepositoryDocument, handleApolloError);`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should use custom Vue app type for operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 499,
                "column": 62
            },
            "line": 499,
            "code": "    it('Should use custom Vue app type for operation functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueAppType: 'CustomApp',\n          vueAppTypeImportFrom: 'my-app',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  ApolloError,\n  CustomApp\n>(FeedDocument);`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError,\n  CustomApp\n>(SubmitRepositoryDocument);`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate deduped operation functions for query and mutation",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 554,
                "column": 74
            },
            "line": 554,
            "code": "    it('Should generate deduped operation functions for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query FeedQuery {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation SubmitRepositoryMutation($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n      const config = { dedupeOperationSuffix: true };\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  ApolloError\n>(FeedQueryDocument);`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError\n>(SubmitRepositoryMutationDocument);`\n      );\n      await validateTypeScript(content, schema, docs, config);\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should not generate operation functions for query and mutation",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 601,
                "column": 70
            },
            "line": 601,
            "code": "    it('Should not generate operation functions for query and mutation', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withSmartOperationFunctions: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export const useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate subscription operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 616,
                "column": 56
            },
            "line": 616,
            "code": "    it('Should generate subscription operation functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const useListenToCommentsSubscription = createSmartSubscriptionOptionsFunction<\n  ListenToCommentsSubscription,\n  ListenToCommentsSubscriptionVariables,\n  ApolloError\n>(ListenToCommentsDocument);`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should use custom ApolloError type and handler for subscription operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 646,
                "column": 91
            },
            "line": 646,
            "code": "    it('Should use custom ApolloError type and handler for subscription operation functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloErrorType: 'CustomApolloError',\n          vueApolloErrorTypeImportFrom: 'custom-error-type',\n          vueApolloErrorHandlerFunction: 'handleApolloError',\n          vueApolloErrorHandlerFunctionImportFrom: 'custom-error-handler',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const useListenToCommentsSubscription = createSmartSubscriptionOptionsFunction<\n  ListenToCommentsSubscription,\n  ListenToCommentsSubscriptionVariables,\n  CustomApolloError\n>(ListenToCommentsDocument, handleApolloError);`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should not add typesPrefix to operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 681,
                "column": 57
            },
            "line": 681,
            "code": "    it('Should not add typesPrefix to operation functions', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export const useTestQuery`);\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate a mutation operation function with required variables if required in graphql document",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 695,
                "column": 109
            },
            "line": 695,
            "code": "    it('Should generate a mutation operation function with required variables if required in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository($name: String!) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError\n>(SubmitRepositoryDocument);`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate a mutation operation function with no variables if not specified in graphql document",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 725,
                "column": 108
            },
            "line": 725,
            "code": "    it('Should generate a mutation operation function with no variables if not specified in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository {\n          submitRepository {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError\n>(SubmitRepositoryDocument);`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate a mutation operation function with optional variables if optional in graphql document",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 755,
                "column": 109
            },
            "line": 755,
            "code": "    it('Should generate a mutation operation function with optional variables if optional in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export const submitRepositoryMutation = createMutationFunction<\n  SubmitRepositoryMutation,\n  SubmitRepositoryMutationVariables,\n  ApolloError\n>(SubmitRepositoryDocument);`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate required variables if required in graphql document",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 785,
                "column": 74
            },
            "line": 785,
            "code": "    it('Should generate required variables if required in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!, $name: String, $people: [String]!) {\n          feed(id: $id) {\n            id\n          }\n        }\n\n        subscription test($name: String!) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // query with required variables\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  ApolloError\n>(FeedDocument);`\n      );\n\n      // subscription with required variables\n      expect(content.content).toBeSimilarStringTo(\n        `export const useTestSubscription = createSmartSubscriptionOptionsFunction<\n  TestSubscription,\n  TestSubscriptionVariables,\n  ApolloError\n>(TestDocument);`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate optional variables if all optional in graphql document",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 831,
                "column": 78
            },
            "line": 831,
            "code": "    it('Should generate optional variables if all optional in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID) {\n          feed(id: $id) {\n            id\n          }\n        }\n\n        subscription test($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // query with optional variables\n      expect(content.content).toBeSimilarStringTo(\n        `export const useFeedQuery = createSmartQueryOptionsFunction<\n  FeedQuery,\n  FeedQueryVariables,\n  ApolloError\n>(FeedDocument);`\n      );\n\n      // subscription with optional variables\n      expect(content.content).toBeSimilarStringTo(\n        `export const useTestSubscription = createSmartSubscriptionOptionsFunction<\n  TestSubscription,\n  TestSubscriptionVariables,\n  ApolloError\n>(TestDocument);`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should generate JSDoc docblocks for operation functions",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 942,
                "column": 63
            },
            "line": 942,
            "code": "    it('Should generate JSDoc docblocks for operation functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n        subscription commentAdded($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n      expect(queryDocBlock).toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(\n        content.content.substr(content.content.indexOf('/**', content.content.indexOf('/**') + 1))\n      );\n      expect(mutationDocBlock).toEqual(mutationDocBlockSnapshot);\n\n      const subscriptionDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n      expect(subscriptionDocBlock).toEqual(subscriptionDocBlockSnapshot);\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "Should NOT generate JSDoc docblocks for operation functions if addDocBlocks is false",
            "suites": [
                "Vue Apollo Operations",
                "Operation functions"
            ],
            "updatePoint": {
                "line": 984,
                "column": 92
            },
            "line": 984,
            "code": "    it('Should NOT generate JSDoc docblocks for operation functions if addDocBlocks is false', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { addDocBlocks: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n\n      expect(queryDocBlock).not.toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n\n      expect(mutationDocBlock).not.toEqual(mutationDocBlockSnapshot);\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import DocumentNode when documentMode is \"documentNode\"",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1048,
                "column": 70
            },
            "line": 1048,
            "code": "    it('should import DocumentNode when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should generate Document variable when documentMode is \"documentNode\"",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1066,
                "column": 77
            },
            "line": 1066,
            "code": "    it('should generate Document variable when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const TestDocument`);\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation using inline fragment",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1088,
                "column": 109
            },
            "line": 1088,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                ...feedFragment\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1123,
                "column": 113
            },
            "line": 1123,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with just fragment",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1159,
                "column": 91
            },
            "line": 1159,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with just fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n\n      await validateTypeScript(content, schema, docs, { ...config });\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useQuery",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1191,
                "column": 78
            },
            "line": 1191,
            "code": "    it('should import Operations from one external file and use it in useQuery', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents',\n      };\n\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useMutation",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1208,
                "column": 81
            },
            "line": 1208,
            "code": "    it('should import Operations from one external file and use it in useMutation', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.ts',\n      };\n\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export const testMutation`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useSubscription",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1225,
                "column": 85
            },
            "line": 1225,
            "code": "    it('should import Operations from one external file and use it in useSubscription', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestSubscription`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from one external file and use it in multiple operation functions",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1242,
                "column": 98
            },
            "line": 1242,
            "code": "    it('should import Operations from one external file and use it in multiple operation functions', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n\n      const docs = [{ location: '', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestOneQuery`);\n      expect(content.content).toBeSimilarStringTo(`export const testTwoMutation`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestThreeSubscription`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from near operation file for useQuery",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1262,
                "column": 70
            },
            "line": 1262,
            "code": "    it('should import Operations from near operation file for useQuery', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from near operation file for useMutation",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1279,
                "column": 73
            },
            "line": 1279,
            "code": "    it('should import Operations from near operation file for useMutation', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export const testMutation`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from near operation file for useSubscription",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1296,
                "column": 77
            },
            "line": 1296,
            "code": "    it('should import Operations from near operation file for useSubscription', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestSubscription`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import Operations from near operation file and use it in multiple operation functions",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1313,
                "column": 100
            },
            "line": 1313,
            "code": "    it('should import Operations from near operation file and use it in multiple operation functions', async () => {\n      const config: VueApolloSmartOpsRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestOneQuery`);\n      expect(content.content).toBeSimilarStringTo(`export const testTwoMutation`);\n      expect(content.content).toBeSimilarStringTo(`export const useTestThreeSubscription`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and one file",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1333,
                "column": 90
            },
            "line": 1333,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and one file`, async () => {\n      const docs = [\n        {\n          location: 'path/to/document.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'near-operation-file',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and multiple files",
            "suites": [
                "Vue Apollo Operations",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1361,
                "column": 96
            },
            "line": 1361,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and multiple files`, async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment1 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n        {\n          location: 'b.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment2 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo-smart-ops.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo-smart-ops/tests"
        },
        {
            "name": "should import VueApollo and VueCompositionApi dependencies",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 70,
                "column": 66
            },
            "line": 70,
            "code": "    it('should import VueApollo and VueCompositionApi dependencies', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as VueApolloComposable from '@vue/apollo-composable';`);\n      expect(content.prepend).toContain(`import * as VueCompositionApi from '@vue/composition-api';`);\n      expect(content.prepend).toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should support typeImports",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 87,
                "column": 34
            },
            "line": 87,
            "code": "    it('should support typeImports', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          useTypeImports: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as VueApolloComposable from '@vue/apollo-composable';`);\n      expect(content.prepend).toContain(`import type * as VueCompositionApi from '@vue/composition-api';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import VueApollo and VueCompositionApi dependencies from configured packages",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 105,
                "column": 91
            },
            "line": 105,
            "code": "    it('should import VueApollo and VueCompositionApi dependencies from configured packages', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          vueApolloComposableImportFrom: 'custom-apollo-composable-package',\n          vueCompositionApiImportFrom: 'custom-composition-api-package',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as VueApolloComposable from 'custom-apollo-composable-package';`);\n      expect(content.prepend).toContain(`import * as VueCompositionApi from 'custom-composition-api-package';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 124,
                "column": 58
            },
            "line": 124,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 142,
                "column": 58
            },
            "line": 142,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "tests for dedupeOperationSuffix",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 157,
                "column": 39
            },
            "line": 157,
            "code": "    it(`tests for dedupeOperationSuffix`, async () => {\n      const ast = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const ast2 = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        ((await plugin(schema, [{ location: 'test-file.ts', document: ast }], {}, { outputFile: '' })) as any).content\n      ).toContain('VueApolloComposable.UseQueryReturn<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('VueApolloComposable.UseQueryReturn<NotificationsQueryQuery, NotificationsQueryQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('VueApolloComposable.UseQueryReturn<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('VueApolloComposable.UseQueryReturn<NotificationsQuery, NotificationsQueryVariables>');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: ast2 }],\n            { dedupeOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('VueApolloComposable.UseQueryReturn<NotificationsQuery, NotificationsQueryVariables>');\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import VueApolloComposable from VueApolloComposableImportFrom config option",
            "suites": [
                "Vue Apollo",
                "Imports"
            ],
            "updatePoint": {
                "line": 218,
                "column": 90
            },
            "line": 218,
            "code": "    it('should import VueApolloComposable from VueApolloComposableImportFrom config option', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { vueApolloComposableImportFrom: 'vue-apollo-composition-functions' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as VueApolloComposable from 'vue-apollo-composition-functions';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate basic fragments documents correctly",
            "suites": [
                "Vue Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 235,
                "column": 59
            },
            "line": 235,
            "code": "    it('Should generate basic fragments documents correctly', async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment MyFragment on Repository {\n              full_name\n            }\n\n            query {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const result = await plugin(schema, docs, {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyFragmentFragmentDoc = gql\\`\n      fragment MyFragment on Repository {\n        full_name\n      }\n      \\`;`);\n      await validateTypeScript(result, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should generate Document variables for inline fragments",
            "suites": [
                "Vue Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 263,
                "column": 63
            },
            "line": 263,
            "code": "    it('should generate Document variables for inline fragments', async () => {\n      const repositoryWithOwner = gql`\n        fragment RepositoryWithOwner on Repository {\n          full_name\n          html_url\n          owner {\n            avatar_url\n          }\n        }\n      `;\n      const feedWithRepository = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          commentCount\n          repository(search: \"phrase\") {\n            ...RepositoryWithOwner\n          }\n        }\n\n        ${repositoryWithOwner}\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n\n        ${feedWithRepository}\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const FeedWithRepositoryFragmentDoc = gql\\`\nfragment FeedWithRepository on Entry {\n  id\n  commentCount\n  repository(search: \"phrase\") {\n    ...RepositoryWithOwner\n  }\n}\n\\${RepositoryWithOwnerFragmentDoc}\\`;`);\n      expect(content.content).toBeSimilarStringTo(`export const RepositoryWithOwnerFragmentDoc = gql\\`\nfragment RepositoryWithOwner on Repository {\n  full_name\n  html_url\n  owner {\n    avatar_url\n  }\n}\n\\`;`);\n\n      expect(content.content).toBeSimilarStringTo(`export const MyFeedDocument = gql\\`\nquery MyFeed {\n  feed {\n    ...FeedWithRepository\n  }\n}\n\\${FeedWithRepositoryFragmentDoc}\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should avoid generating duplicate fragments",
            "suites": [
                "Vue Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 334,
                "column": 51
            },
            "line": 334,
            "code": "    it('should avoid generating duplicate fragments', async () => {\n      const simpleFeed = gql`\n        fragment Item on Entry {\n          id\n        }\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...Item\n          }\n          allFeeds: feed {\n            ...Item\n          }\n        }\n      `;\n      const documents = [simpleFeed, myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        export const MyFeedDocument = gql\\`\n        query MyFeed {\n            feed {\n              ...Item\n            }\n            allFeeds: feed {\n              ...Item\n            }\n          }\n          \\${ItemFragmentDoc}\\``);\n      expect(content.content).toBeSimilarStringTo(`\n        export const ItemFragmentDoc = gql\\`\n        fragment Item on Entry {\n          id\n        }\n\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate fragments in proper order (when one depends on other)",
            "suites": [
                "Vue Apollo",
                "Fragments"
            ],
            "updatePoint": {
                "line": 381,
                "column": 77
            },
            "line": 381,
            "code": "    it('Should generate fragments in proper order (when one depends on other)', async () => {\n      const myFeed = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          repository {\n            ...RepositoryWithOwner\n          }\n        }\n\n        fragment RepositoryWithOwner on Repository {\n          full_name\n        }\n\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n      `;\n      const documents = [myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const feedWithRepositoryPos = content.content.indexOf('fragment FeedWithRepository');\n      const repositoryWithOwnerPos = content.content.indexOf('fragment RepositoryWithOwner');\n      expect(repositoryWithOwnerPos).toBeLessThan(feedWithRepositoryPos);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate composition functions for query and mutation",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 419,
                "column": 68
            },
            "line": 419,
            "code": "    it('Should generate composition functions for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedQuery(options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n             return VueApolloComposable.useQuery<FeedQuery, FeedQueryVariables>(FeedDocument, {}, options);\n           }`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedLazyQuery(options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n             return VueApolloComposable.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedDocument, {}, options);\n           }`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useSubmitRepositoryMutation(options: VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>> = {}) {\n           return VueApolloComposable.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument, options);\n         }`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should respect omitOperationSuffix and generate type omitted composition functions",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 471,
                "column": 90
            },
            "line": 471,
            "code": "    it(`Should respect omitOperationSuffix and generate type omitted composition functions`, async () => {\n      const documentWithHardcodedQuerySuffix = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      const documentNoQuerySuffix = parse(/* GraphQL */ `\n        query notifications {\n          notifications {\n            id\n          }\n        }\n      `);\n\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentWithHardcodedQuerySuffix }],\n            {},\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsQueryQueryCompositionFunctionResult');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentWithHardcodedQuerySuffix }],\n            { omitOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsQueryQueryCompositionFunctionResult');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentWithHardcodedQuerySuffix }],\n            { omitOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsQueryCompositionFunctionResult');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentNoQuerySuffix }],\n            { omitOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsCompositionFunctionResult');\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentNoQuerySuffix }],\n            { omitOperationSuffix: false },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsQueryCompositionFunctionResult');\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate deduped composition functions for query and mutation",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 539,
                "column": 76
            },
            "line": 539,
            "code": "    it('Should generate deduped composition functions for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query FeedQuery {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation SubmitRepositoryMutation($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n      const config = { dedupeOperationSuffix: true };\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedQuery(options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n          return VueApolloComposable.useQuery<FeedQuery, FeedQueryVariables>(FeedQueryDocument, {}, options);\n        }`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedQueryLazyQuery(options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n          return VueApolloComposable.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedQueryDocument, {}, options);\n        }`\n      );\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useSubmitRepositoryMutation(options: VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>> = {}) {\n           return VueApolloComposable.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryMutationDocument, options);\n        }`\n      );\n      await validateTypeScript(content, schema, docs, config);\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate deduped and type omitted compositions functions",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 588,
                "column": 71
            },
            "line": 588,
            "code": "    it(`Should generate deduped and type omitted compositions functions`, async () => {\n      const documentWithQuerySuffix = parse(/* GraphQL */ `\n        query notificationsQuery {\n          notifications {\n            id\n          }\n        }\n      `);\n      expect(\n        (\n          (await plugin(\n            schema,\n            [{ location: 'test-file.ts', document: documentWithQuerySuffix }],\n            { omitOperationSuffix: true, dedupeOperationSuffix: true },\n            { outputFile: '' }\n          )) as any\n        ).content\n      ).toContain('type NotificationsQueryCompositionFunctionResult');\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should not generate composition functions for query and mutation",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 608,
                "column": 72
            },
            "line": 608,
            "code": "    it('Should not generate composition functions for query and mutation', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withCompositionFunctions: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate subscription composition functions",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 623,
                "column": 58
            },
            "line": 623,
            "code": "    it('Should generate subscription composition functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useListenToCommentsSubscription(variables: ListenToCommentsSubscriptionVariables | VueCompositionApi.Ref<ListenToCommentsSubscriptionVariables> | ReactiveFunction<ListenToCommentsSubscriptionVariables> = {}, options: VueApolloComposable.UseSubscriptionOptions<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables> | VueCompositionApi.Ref<VueApolloComposable.UseSubscriptionOptions<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>> | ReactiveFunction<VueApolloComposable.UseSubscriptionOptions<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>> = {}) {\n          return VueApolloComposable.useSubscription<ListenToCommentsSubscription, ListenToCommentsSubscriptionVariables>(ListenToCommentsDocument, variables, options);\n        }`\n      );\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should not add typesPrefix to composition functions",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 651,
                "column": 59
            },
            "line": 651,
            "code": "    it('Should not add typesPrefix to composition functions', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTestQuery`);\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should generate composition function result",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 665,
                "column": 51
            },
            "line": 665,
            "code": "    it('should generate composition function result', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n\n        subscription test($name: String!) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type FeedQueryCompositionFunctionResult = VueApolloComposable.UseQueryReturn<FeedQuery, FeedQueryVariables>;\n      `);\n\n      expect(content.content).toBeSimilarStringTo(`\n      export type SubmitRepositoryMutationCompositionFunctionResult = VueApolloComposable.UseMutationReturn<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>;\n      `);\n      expect(content.content).toBeSimilarStringTo(`\n      export type TestSubscriptionCompositionFunctionResult = VueApolloComposable.UseSubscriptionReturn<TestSubscription, TestSubscriptionVariables>;\n      `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate a mutation composition function with required variables if required in graphql document",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 717,
                "column": 111
            },
            "line": 717,
            "code": "    it('Should generate a mutation composition function with required variables if required in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository($name: String!) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useSubmitRepositoryMutation(options: VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>>) {\n           return VueApolloComposable.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument, options);\n        }`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate a mutation composition function with no variables if not specified in graphql document",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 745,
                "column": 110
            },
            "line": 745,
            "code": "    it('Should generate a mutation composition function with no variables if not specified in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository {\n          submitRepository {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useSubmitRepositoryMutation(options: VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>> = {}) {\n           return VueApolloComposable.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument, options);\n        }`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate a mutation composition function with optional variables if optional in graphql document",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 773,
                "column": 111
            },
            "line": 773,
            "code": "    it('Should generate a mutation composition function with optional variables if optional in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `export function useSubmitRepositoryMutation(options: VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables> | ReactiveFunction<VueApolloComposable.UseMutationOptions<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>> = {}) {\n           return VueApolloComposable.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument, options);\n        }`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate required variables if required in graphql document",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 801,
                "column": 74
            },
            "line": 801,
            "code": "    it('Should generate required variables if required in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!, $name: String, $people: [String]!) {\n          feed(id: $id) {\n            id\n          }\n        }\n\n        subscription test($name: String!) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // query with required variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedQuery(variables: FeedQueryVariables | VueCompositionApi.Ref<FeedQueryVariables> | ReactiveFunction<FeedQueryVariables>, options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n           return VueApolloComposable.useQuery<FeedQuery, FeedQueryVariables>(FeedDocument, variables, options);\n        }`\n      );\n\n      // lazy query with required variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedLazyQuery(variables: FeedQueryVariables | VueCompositionApi.Ref<FeedQueryVariables> | ReactiveFunction<FeedQueryVariables>, options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n           return VueApolloComposable.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedDocument, variables, options);\n        }`\n      );\n\n      // subscription with required variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useTestSubscription(variables: TestSubscriptionVariables | VueCompositionApi.Ref<TestSubscriptionVariables> | ReactiveFunction<TestSubscriptionVariables>, options: VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables> | VueCompositionApi.Ref<VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables>> | ReactiveFunction<VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables>> = {}) {\n           return VueApolloComposable.useSubscription<TestSubscription, TestSubscriptionVariables>(TestDocument, variables, options);\n        }`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate optional variables if all optional in graphql document",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 850,
                "column": 78
            },
            "line": 850,
            "code": "    it('Should generate optional variables if all optional in graphql document', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID) {\n          feed(id: $id) {\n            id\n          }\n        }\n\n        subscription test($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      // query with optional variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedQuery(variables: FeedQueryVariables | VueCompositionApi.Ref<FeedQueryVariables> | ReactiveFunction<FeedQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n           return VueApolloComposable.useQuery<FeedQuery, FeedQueryVariables>(FeedDocument, variables, options);\n        }`\n      );\n\n      // lazy query with optional variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useFeedLazyQuery(variables: FeedQueryVariables | VueCompositionApi.Ref<FeedQueryVariables> | ReactiveFunction<FeedQueryVariables> = {}, options: VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables> | VueCompositionApi.Ref<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> | ReactiveFunction<VueApolloComposable.UseQueryOptions<FeedQuery, FeedQueryVariables>> = {}) {\n           return VueApolloComposable.useLazyQuery<FeedQuery, FeedQueryVariables>(FeedDocument, variables, options);\n        }`\n      );\n\n      // subscription with optional variables\n      expect(content.content).toBeSimilarStringTo(\n        `export function useTestSubscription(variables: TestSubscriptionVariables | VueCompositionApi.Ref<TestSubscriptionVariables> | ReactiveFunction<TestSubscriptionVariables> = {}, options: VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables> | VueCompositionApi.Ref<VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables>> | ReactiveFunction<VueApolloComposable.UseSubscriptionOptions<TestSubscription, TestSubscriptionVariables>> = {}) {\n           return VueApolloComposable.useSubscription<TestSubscription, TestSubscriptionVariables>(TestDocument, variables, options);\n        }`\n      );\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should generate JSDoc docblocks for composition functions",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 950,
                "column": 65
            },
            "line": 950,
            "code": "    it('Should generate JSDoc docblocks for composition functions', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n        subscription commentAdded($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n      expect(queryDocBlock).toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(\n        content.content.substr(content.content.indexOf('/**', content.content.indexOf('/**') + 1))\n      );\n      expect(mutationDocBlock).toEqual(mutationDocBlockSnapshot);\n\n      const subscriptionDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n      expect(subscriptionDocBlock).toEqual(subscriptionDocBlockSnapshot);\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "Should NOT generate JSDoc docblocks for composition functions if addDocBlocks is false",
            "suites": [
                "Vue Apollo",
                "Composition functions"
            ],
            "updatePoint": {
                "line": 992,
                "column": 94
            },
            "line": 992,
            "code": "    it('Should NOT generate JSDoc docblocks for composition functions if addDocBlocks is false', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed($id: ID!) {\n          feed(id: $id) {\n            id\n          }\n        }\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        { addDocBlocks: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const queryDocBlock = extract(content.content.substr(content.content.indexOf('/**')));\n\n      expect(queryDocBlock).not.toEqual(queryDocBlockSnapshot);\n\n      const mutationDocBlock = extract(content.content.substr(content.content.lastIndexOf('/**')));\n\n      expect(mutationDocBlock).not.toEqual(mutationDocBlockSnapshot);\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import DocumentNode when documentMode is \"documentNode\"",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1056,
                "column": 70
            },
            "line": 1056,
            "code": "    it('should import DocumentNode when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should generate Document variable when documentMode is \"documentNode\"",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1074,
                "column": 77
            },
            "line": 1074,
            "code": "    it('should generate Document variable when documentMode is \"documentNode\"', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.documentNode,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const TestDocument`);\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation using inline fragment",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1096,
                "column": 109
            },
            "line": 1096,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                ...feedFragment\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        { ...config },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1131,
                "column": 113
            },
            "line": 1131,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with operation NOT using inline fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n            query testOne {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should NOT generate inline fragment docs for external mode: file with just fragment",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1167,
                "column": 91
            },
            "line": 1167,
            "code": "    it('should NOT generate inline fragment docs for external mode: file with just fragment', async () => {\n      const docs = [\n        {\n          location: '',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const config = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          ...config,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toBeSimilarStringTo(`export const FeedFragmentFragmentDoc`);\n\n      await validateTypeScript(content, schema, docs, { ...config });\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useQuery",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1199,
                "column": 78
            },
            "line": 1199,
            "code": "    it('should import Operations from one external file and use it in useQuery', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents',\n      };\n\n      const docs = [{ location: '', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useMutation",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1216,
                "column": 81
            },
            "line": 1216,
            "code": "    it('should import Operations from one external file and use it in useMutation', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.ts',\n      };\n\n      const docs = [{ location: '', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestMutation`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in useSubscription",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1233,
                "column": 85
            },
            "line": 1233,
            "code": "    it('should import Operations from one external file and use it in useSubscription', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n\n      const docs = [{ location: '', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestSubscription`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from one external file and use it in multiple composition functions",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1250,
                "column": 100
            },
            "line": 1250,
            "code": "    it('should import Operations from one external file and use it in multiple composition functions', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n      };\n\n      const docs = [{ location: '', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from 'path/to/documents';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestOneQuery`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestTwoMutation`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestThreeSubscription`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useQuery",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1270,
                "column": 70
            },
            "line": 1270,
            "code": "    it('should import Operations from near operation file for useQuery', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: basicDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useMutation",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1287,
                "column": 73
            },
            "line": 1287,
            "code": "    it('should import Operations from near operation file for useMutation', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: mutationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestMutation`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file for useSubscription",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1304,
                "column": 77
            },
            "line": 1304,
            "code": "    it('should import Operations from near operation file for useSubscription', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: subscriptionDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestSubscription`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should import Operations from near operation file and use it in multiple composition functions",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1321,
                "column": 102
            },
            "line": 1321,
            "code": "    it('should import Operations from near operation file and use it in multiple composition functions', async () => {\n      const config: VueApolloRawPluginConfig = {\n        documentMode: DocumentMode.external,\n        importDocumentNodeExternallyFrom: 'near-operation-file',\n      };\n\n      const docs = [{ location: 'path/to/document.graphql', document: multipleOperationDoc }];\n\n      const content = (await plugin(schema, docs, config, {\n        outputFile: 'graphql.ts',\n      })) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from './document.graphql.js';`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestOneQuery`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestTwoMutation`);\n      expect(content.content).toBeSimilarStringTo(`export function useTestThreeSubscription`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and one file",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1341,
                "column": 90
            },
            "line": 1341,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and one file`, async () => {\n      const docs = [\n        {\n          location: 'path/to/document.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'near-operation-file',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should NOT import Operations if no operation collected: external mode and multiple files",
            "suites": [
                "Vue Apollo",
                "documentMode and importDocumentNodeExternallyFrom"
            ],
            "updatePoint": {
                "line": 1369,
                "column": 96
            },
            "line": 1369,
            "code": "    it(`should NOT import Operations if no operation collected: external mode and multiple files`, async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment1 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n        {\n          location: 'b.graphql',\n          document: parse(/* GraphQL */ `\n            fragment feedFragment2 on Entry {\n              id\n              commentCount\n            }\n          `),\n        },\n      ];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importDocumentNodeExternallyFrom: 'path/to/documents.tsx',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).not.toBeSimilarStringTo(`import * as Operations`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "vue-apollo.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-apollo/tests"
        },
        {
            "name": "should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set",
            "suites": [
                "urql",
                "Config"
            ],
            "updatePoint": {
                "line": 51,
                "column": 104
            },
            "line": 51,
            "code": "    it('should output warning if documentMode = external and importDocumentNodeExternallyFrom is not set', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importDocumentNodeExternallyFrom must be provided if documentMode=external'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set to something other than \"Operations\"",
            "suites": [
                "urql",
                "Config"
            ],
            "updatePoint": {
                "line": 71,
                "column": 94
            },
            "line": 71,
            "code": "    it('output warning if importOperationTypesFrom is set to something other than \"Operations\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Whatever',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        'importOperationTypesFrom only works correctly when left empty or set to \"Operations\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and documentMode is not \"external\"",
            "suites": [
                "urql",
                "Config"
            ],
            "updatePoint": {
                "line": 92,
                "column": 92
            },
            "line": 92,
            "code": "    it('output warning if importOperationTypesFrom is set and documentMode is not \"external\"', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not",
            "suites": [
                "urql",
                "Config"
            ],
            "updatePoint": {
                "line": 112,
                "column": 101
            },
            "line": 112,
            "code": "    it('output warning if importOperationTypesFrom is set and importDocumentNodeExternallyFrom is not', async () => {\n      jest.spyOn(console, 'warn');\n      const docs = [{ location: '', document: basicDoc }];\n      await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      );\n\n      // eslint-disable-next-line no-console\n      expect(console.warn).toHaveBeenCalledWith(\n        '\"importOperationTypesFrom\" should be used with \"documentMode=external\" and \"importDocumentNodeExternallyFrom\"'\n      );\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should import Vue Urql when composition is used",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 135,
                "column": 55
            },
            "line": 135,
            "code": "    it('should import Vue Urql when composition is used', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          withComposition: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Urql from '@urql/vue';`);\n      expect(content.prepend).toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should import DocumentNode when using noGraphQLTag",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 153,
                "column": 58
            },
            "line": 153,
            "code": "    it('should import DocumentNode when using noGraphQLTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { DocumentNode } from 'graphql';`);\n      expect(content.prepend).not.toContain(`import gql from 'graphql-tag';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should use gql import from gqlImport config option",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 171,
                "column": 58
            },
            "line": 171,
            "code": "    it(`should use gql import from gqlImport config option`, async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { gqlImport: 'graphql.macro#gql' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import { gql } from 'graphql.macro';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should import Urql from urqlImportFrom config option",
            "suites": [
                "urql",
                "Imports"
            ],
            "updatePoint": {
                "line": 186,
                "column": 60
            },
            "line": 186,
            "code": "    it('should import Urql from urqlImportFrom config option', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { urqlImportFrom: 'custom-urql' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Urql from 'custom-urql';`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should generate basic fragments documents correctly",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 203,
                "column": 59
            },
            "line": 203,
            "code": "    it('Should generate basic fragments documents correctly', async () => {\n      const docs = [\n        {\n          location: 'a.graphql',\n          document: parse(/* GraphQL */ `\n            fragment MyFragment on Repository {\n              full_name\n            }\n\n            query test {\n              feed {\n                id\n              }\n            }\n          `),\n        },\n      ];\n      const result = await plugin(schema, docs, {}, { outputFile: '' });\n\n      expect(result.content).toBeSimilarStringTo(`\n      export const MyFragmentFragmentDoc = gql\\`\n      fragment MyFragment on Repository {\n        full_name\n      }\n      \\`;`);\n      await validateTypeScript(result, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should generate Document variables for inline fragments",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 231,
                "column": 63
            },
            "line": 231,
            "code": "    it('should generate Document variables for inline fragments', async () => {\n      const repositoryWithOwner = gql`\n        fragment RepositoryWithOwner on Repository {\n          full_name\n          html_url\n          owner {\n            avatar_url\n          }\n        }\n      `;\n      const feedWithRepository = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          commentCount\n          repository(search: \"phrase\") {\n            ...RepositoryWithOwner\n          }\n        }\n\n        ${repositoryWithOwner}\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n\n        ${feedWithRepository}\n      `;\n\n      const docs = [{ location: '', document: myFeed }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`export const FeedWithRepositoryFragmentDoc = gql\\`\nfragment FeedWithRepository on Entry {\n  id\n  commentCount\n  repository(search: \"phrase\") {\n    ...RepositoryWithOwner\n  }\n}\n\\${RepositoryWithOwnerFragmentDoc}\\`;`);\n      expect(content.content).toBeSimilarStringTo(`export const RepositoryWithOwnerFragmentDoc = gql\\`\nfragment RepositoryWithOwner on Repository {\n  full_name\n  html_url\n  owner {\n    avatar_url\n  }\n}\n\\`;`);\n\n      expect(content.content).toBeSimilarStringTo(`export const MyFeedDocument = gql\\`\nquery MyFeed {\n  feed {\n    ...FeedWithRepository\n  }\n}\n\\${FeedWithRepositoryFragmentDoc}\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should avoid generating duplicate fragments",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 302,
                "column": 51
            },
            "line": 302,
            "code": "    it('should avoid generating duplicate fragments', async () => {\n      const simpleFeed = gql`\n        fragment Item on Entry {\n          id\n        }\n      `;\n      const myFeed = gql`\n        query MyFeed {\n          feed {\n            ...Item\n          }\n          allFeeds: feed {\n            ...Item\n          }\n        }\n      `;\n      const documents = [simpleFeed, myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n        export const MyFeedDocument = gql\\`\n        query MyFeed {\n            feed {\n              ...Item\n            }\n            allFeeds: feed {\n              ...Item\n            }\n          }\n          \\${ItemFragmentDoc}\\``);\n      expect(content.content).toBeSimilarStringTo(`\n        export const ItemFragmentDoc = gql\\`\n        fragment Item on Entry {\n          id\n        }\n\\`;`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should generate fragments in proper order (when one depends on other)",
            "suites": [
                "urql",
                "Fragments"
            ],
            "updatePoint": {
                "line": 349,
                "column": 77
            },
            "line": 349,
            "code": "    it('Should generate fragments in proper order (when one depends on other)', async () => {\n      const myFeed = gql`\n        fragment FeedWithRepository on Entry {\n          id\n          repository {\n            ...RepositoryWithOwner\n          }\n        }\n\n        fragment RepositoryWithOwner on Repository {\n          full_name\n        }\n\n        query MyFeed {\n          feed {\n            ...FeedWithRepository\n          }\n        }\n      `;\n      const documents = [myFeed];\n      const docs = documents.map(document => ({ document, location: '' }));\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      const feedWithRepositoryPos = content.content.indexOf('fragment FeedWithRepository');\n      const repositoryWithOwnerPos = content.content.indexOf('fragment RepositoryWithOwner');\n      expect(repositoryWithOwnerPos).toBeLessThan(feedWithRepositoryPos);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should generate Document variable",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 387,
                "column": 41
            },
            "line": 387,
            "code": "    it('should generate Document variable', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n          export const TestDocument =  gql\\`\n          query test {\n            feed {\n              id\n              commentCount\n              repository {\n                full_name\n                html_url\n                owner {\n                  avatar_url\n                }\n              }\n            }\n          }\n          \\`;\n        `);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should generate Document variable with noGraphQlTag",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 418,
                "column": 59
            },
            "line": 418,
            "code": "    it('should generate Document variable with noGraphQlTag', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          noGraphQLTag: true,\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(\n        `[{\"kind\":\"Field\",\"name\":{\"kind\":\"Name\",\"value\":\"avatar_url\"}}]}}]}}]}}]}}]} as unknown as DocumentNode;`\n      );\n\n      // For issue #1599 - make sure there are not `loc` properties\n      expect(content.content).not.toContain(`loc\":`);\n      expect(content.content).not.toContain(`loc':`);\n\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should generate composition functions for query and mutation",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 442,
                "column": 68
            },
            "line": 442,
            "code": "    it('Should generate composition functions for query and mutation', async () => {\n      const documents = parse(/* GraphQL */ `\n        query feed {\n          feed {\n            id\n            commentCount\n            repository {\n              full_name\n              html_url\n              owner {\n                avatar_url\n              }\n            }\n          }\n        }\n\n        mutation submitRepository($name: String) {\n          submitRepository(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useFeedQuery(options: Omit<Urql.UseQueryArgs<never, FeedQueryVariables>, 'query'> = {}) {\n  return Urql.useQuery<FeedQuery>({ query: FeedDocument, ...options });\n};`);\n\n      expect(content.content).toBeSimilarStringTo(`\nexport function useSubmitRepositoryMutation() {\n  return Urql.useMutation<SubmitRepositoryMutation, SubmitRepositoryMutationVariables>(SubmitRepositoryDocument);\n};`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should not generate composition functions for query and mutation",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 487,
                "column": 72
            },
            "line": 487,
            "code": "    it('Should not generate composition functions for query and mutation', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { withComposition: false },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).not.toContain(`export function useTestQuery`);\n      await validateTypeScript(content, schema, docs, {});\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should generate subscription hooks",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 502,
                "column": 42
            },
            "line": 502,
            "code": "    it('Should generate subscription hooks', async () => {\n      const documents = parse(/* GraphQL */ `\n        subscription ListenToComments($name: String) {\n          commentAdded(repoFullName: $name) {\n            id\n          }\n        }\n      `);\n\n      const docs = [{ location: '', document: documents }];\n\n      const content = (await plugin(\n        schema,\n        docs,\n        {},\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toBeSimilarStringTo(`\n      export function useListenToCommentsSubscription<R = ListenToCommentsSubscription>(options: Omit<Urql.UseSubscriptionArgs<never, ListenToCommentsSubscriptionVariables>, 'query'> = {}, handler?: Urql.SubscriptionHandlerArg<ListenToCommentsSubscription, R>) {\n        return Urql.useSubscription<ListenToCommentsSubscription, R, ListenToCommentsSubscriptionVariables>({ query: ListenToCommentsDocument, ...options }, handler);\n      };`);\n      await validateTypeScript(content, schema, docs, {});\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should not add typesPrefix to hooks",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 530,
                "column": 43
            },
            "line": 530,
            "code": "    it('Should not add typesPrefix to hooks', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { typesPrefix: 'I' },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTestQuery`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "Should respect omitOperationSuffix for hooks",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 544,
                "column": 52
            },
            "line": 544,
            "code": "    it('Should respect omitOperationSuffix for hooks', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        { omitOperationSuffix: true },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.content).toContain(`export function useTest(`);\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "should allow importing operations and documents from another file",
            "suites": [
                "urql",
                "Composition"
            ],
            "updatePoint": {
                "line": 558,
                "column": 73
            },
            "line": 558,
            "code": "    it('should allow importing operations and documents from another file', async () => {\n      const docs = [{ location: '', document: basicDoc }];\n      const content = (await plugin(\n        schema,\n        docs,\n        {\n          documentMode: DocumentMode.external,\n          importOperationTypesFrom: 'Operations',\n          importDocumentNodeExternallyFrom: '@myproject/generated',\n        },\n        {\n          outputFile: 'graphql.ts',\n        }\n      )) as Types.ComplexPluginOutput;\n\n      expect(content.prepend).toContain(`import * as Operations from '@myproject/generated';`);\n\n      expect(content.content).toContain('Operations.TestDocument');\n      expect(content.content).toContain('Operations.TestQuery');\n      expect(content.content).toContain('Operations.TestQueryVariables');\n\n      expect(content.content).not.toContain('Urql.UseOperations');\n      expect(content.content).toContain('Urql.UseQueryArgs');\n      expect(content.content).toContain('Urql.useQuery');\n\n      await validateTypeScript(content, schema, docs, {});\n\n      expect(mergeOutputs([content])).toMatchSnapshot();\n    });",
            "file": "urql.spec.ts",
            "skipped": false,
            "dir": "packages/plugins/typescript/vue-urql/tests"
        },
        {
            "name": "can imports files in the same directory",
            "suites": [
                "gql-tag-operations-preset > babelPlugin"
            ],
            "updatePoint": {
                "line": 6,
                "column": 47
            },
            "line": 6,
            "code": "  test('can imports files in the same directory', () => {\n    const result = transformFileSync(path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'), {\n      plugins: [[babelPlugin, { artifactDirectory: path.join(__dirname, 'fixtures') }]],\n      babelrc: false,\n      configFile: false,\n    }).code;\n    expect(result).toMatchInlineSnapshot(`\n\"import { CFragmentDoc } from \\\\\"./graphql\\\\\";\nimport { BDocument } from \\\\\"./graphql\\\\\";\nimport { ADocument } from \\\\\"./graphql\\\\\";\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n//@ts-ignore\nimport gql from 'gql-tag'; //@ts-ignore\n\nconst A = ADocument; //@ts-ignore\n\nconst B = BDocument; //@ts-ignore\n\nconst C = CFragmentDoc;\"\n`);\n  });",
            "file": "babel.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can import files in another directory",
            "suites": [
                "gql-tag-operations-preset > babelPlugin"
            ],
            "updatePoint": {
                "line": 28,
                "column": 45
            },
            "line": 28,
            "code": "  test('can import files in another directory', () => {\n    const result = transformFileSync(path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'), {\n      plugins: [[babelPlugin, { artifactDirectory: __dirname }]],\n      babelrc: false,\n      configFile: false,\n    }).code;\n    expect(result).toMatchInlineSnapshot(`\n\"import { CFragmentDoc } from \\\\\"../graphql\\\\\";\nimport { BDocument } from \\\\\"../graphql\\\\\";\nimport { ADocument } from \\\\\"../graphql\\\\\";\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n//@ts-ignore\nimport gql from 'gql-tag'; //@ts-ignore\n\nconst A = ADocument; //@ts-ignore\n\nconst B = BDocument; //@ts-ignore\n\nconst C = CFragmentDoc;\"\n`);\n  });",
            "file": "babel.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can generate simple examples uppercase names",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 10,
                "column": 50
            },
            "line": 10,
            "code": "  it('can generate simple examples uppercase names', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n        },\n      },\n    });\n\n    expect(result).toHaveLength(3);\n    // index.ts (re-exports)\n    const indexFile = result.find(file => file.filename === 'out1/index.ts');\n    expect(indexFile.content).toEqual('export * from \"./gql\"');\n\n    // gql.ts\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n          \"/* eslint-disable */\n          import * as graphql from './graphql';\n          import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n          const documents = {\n              \\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.ADocument,\n              \\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.BDocument,\n              \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.CFragmentDoc,\n          };\n\n          export function gql(source: \\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"];\n          export function gql(source: \\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"];\n          export function gql(source: \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"];\n\n          export function gql(source: string): unknown;\n          export function gql(source: string) {\n            return (documents as any)[source] ?? {};\n          }\n\n          export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n        `);\n\n    // graphql.ts\n    const graphqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(graphqlFile).toBeDefined();\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can generate simple examples lowercase names",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 65,
                "column": 50
            },
            "line": 65,
            "code": "  it('can generate simple examples lowercase names', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-lowercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n        },\n      },\n    });\n\n    expect(result).toHaveLength(3);\n    // index.ts (re-exports)\n    const indexFile = result.find(file => file.filename === 'out1/index.ts');\n    expect(indexFile.content).toEqual('export * from \"./gql\"');\n\n    // gql.ts\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n          \"/* eslint-disable */\n          import * as graphql from './graphql';\n          import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n          const documents = {\n              \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.ADocument,\n              \\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.BDocument,\n              \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.CFragmentDoc,\n          };\n\n          export function gql(source: \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"];\n          export function gql(source: \\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"];\n          export function gql(source: \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"];\n\n          export function gql(source: string): unknown;\n          export function gql(source: string) {\n            return (documents as any)[source] ?? {};\n          }\n\n          export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n        `);\n\n    // graphql.ts\n    const graphqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(graphqlFile).toBeDefined();\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "generates \\n regardless of whether the source contains LF or CRLF",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 120,
                "column": 72
            },
            "line": 120,
            "code": "  it('generates \\\\n regardless of whether the source contains LF or CRLF', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/crlf-operation.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n        },\n      },\n    });\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as graphql from './graphql';\n      import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      const documents = {\n          \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.ADocument,\n          \\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.BDocument,\n          \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.CFragmentDoc,\n      };\n\n      export function gql(source: \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"];\n      export function gql(source: \\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query b {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"];\n      export function gql(source: \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"];\n\n      export function gql(source: string): unknown;\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "follows 'useTypeImports': true",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 164,
                "column": 36
            },
            "line": 164,
            "code": "  it(\"follows 'useTypeImports': true\", async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n        },\n      },\n      config: {\n        useTypeImports: true,\n      },\n    });\n\n    expect(result.length).toBe(3);\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as graphql from './graphql';\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      const documents = {\n          \\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.ADocument,\n          \\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.BDocument,\n          \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.CFragmentDoc,\n      };\n\n      export function gql(source: \\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query A {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"];\n      export function gql(source: \\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query B {\\\\\\\\n    b\\\\\\\\n  }\\\\\\\\n\\\\\"];\n      export function gql(source: \\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  fragment C on Query {\\\\\\\\n    c\\\\\\\\n  }\\\\\\\\n\\\\\"];\n\n      export function gql(source: string): unknown;\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n    const graphqlFile = result.find(file => file.filename === 'out1/graphql.ts');\n    expect(graphqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n      export type Maybe<T> = T | null;\n      export type InputMaybe<T> = Maybe<T>;\n      export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n      export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n      export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        a?: Maybe<Scalars['String']>;\n        b?: Maybe<Scalars['String']>;\n        c?: Maybe<Scalars['String']>;\n      };\n\n      export type AQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type AQuery = { __typename?: 'Query', a?: string | null };\n\n      export type BQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type BQuery = { __typename?: 'Query', b?: string | null };\n\n      export type CFragment = { __typename?: 'Query', c?: string | null };\n\n      export const CFragmentDoc = {\\\\\"kind\\\\\":\\\\\"Document\\\\\",\\\\\"definitions\\\\\":[{\\\\\"kind\\\\\":\\\\\"FragmentDefinition\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"C\\\\\"},\\\\\"typeCondition\\\\\":{\\\\\"kind\\\\\":\\\\\"NamedType\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"Query\\\\\"}},\\\\\"selectionSet\\\\\":{\\\\\"kind\\\\\":\\\\\"SelectionSet\\\\\",\\\\\"selections\\\\\":[{\\\\\"kind\\\\\":\\\\\"Field\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"c\\\\\"}}]}}]} as unknown as DocumentNode<CFragment, unknown>;\n      export const ADocument = {\\\\\"kind\\\\\":\\\\\"Document\\\\\",\\\\\"definitions\\\\\":[{\\\\\"kind\\\\\":\\\\\"OperationDefinition\\\\\",\\\\\"operation\\\\\":\\\\\"query\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"A\\\\\"},\\\\\"selectionSet\\\\\":{\\\\\"kind\\\\\":\\\\\"SelectionSet\\\\\",\\\\\"selections\\\\\":[{\\\\\"kind\\\\\":\\\\\"Field\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"a\\\\\"}}]}}]} as unknown as DocumentNode<AQuery, AQueryVariables>;\n      export const BDocument = {\\\\\"kind\\\\\":\\\\\"Document\\\\\",\\\\\"definitions\\\\\":[{\\\\\"kind\\\\\":\\\\\"OperationDefinition\\\\\",\\\\\"operation\\\\\":\\\\\"query\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"B\\\\\"},\\\\\"selectionSet\\\\\":{\\\\\"kind\\\\\":\\\\\"SelectionSet\\\\\",\\\\\"selections\\\\\":[{\\\\\"kind\\\\\":\\\\\"Field\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"b\\\\\"}}]}}]} as unknown as DocumentNode<BQuery, BQueryVariables>;\"\n    `);\n\n    expect(graphqlFile.content).toContain(\n      \"import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'\"\n    );\n    expect(gqlFile.content).toContain(\n      \"import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core'\"\n    );\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "prevent duplicate operations",
            "suites": [
                "gql-tag-operations-preset"
            ],
            "updatePoint": {
                "line": 261,
                "column": 34
            },
            "line": 261,
            "code": "  it('prevent duplicate operations', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/duplicate-operation.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n        },\n      },\n      config: {\n        useTypeImports: true,\n      },\n    });\n\n    expect(result.length).toBe(3);\n    const gqlFile = result.find(file => file.filename === 'out1/gql.ts');\n    expect(gqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import * as graphql from './graphql';\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      const documents = {\n          \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\": graphql.ADocument,\n      };\n\n      export function gql(source: \\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"): (typeof documents)[\\\\\"\\\\\\\\n  query a {\\\\\\\\n    a\\\\\\\\n  }\\\\\\\\n\\\\\"];\n\n      export function gql(source: string): unknown;\n      export function gql(source: string) {\n        return (documents as any)[source] ?? {};\n      }\n\n      export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<  infer TType,  any>  ? TType  : never;\"\n    `);\n    const graphqlFile = result.find(file => file.filename === 'out1/graphql.ts');\n    expect(graphqlFile.content).toMatchInlineSnapshot(`\n      \"/* eslint-disable */\n      import type { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n      export type Maybe<T> = T | null;\n      export type InputMaybe<T> = Maybe<T>;\n      export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\n      export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\n      export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n      /** All built-in and custom scalars, mapped to their actual values */\n      export type Scalars = {\n        ID: string;\n        String: string;\n        Boolean: boolean;\n        Int: number;\n        Float: number;\n      };\n\n      export type Query = {\n        __typename?: 'Query';\n        a?: Maybe<Scalars['String']>;\n      };\n\n      export type AQueryVariables = Exact<{ [key: string]: never; }>;\n\n\n      export type AQuery = { __typename?: 'Query', a?: string | null };\n\n\n      export const ADocument = {\\\\\"kind\\\\\":\\\\\"Document\\\\\",\\\\\"definitions\\\\\":[{\\\\\"kind\\\\\":\\\\\"OperationDefinition\\\\\",\\\\\"operation\\\\\":\\\\\"query\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"a\\\\\"},\\\\\"selectionSet\\\\\":{\\\\\"kind\\\\\":\\\\\"SelectionSet\\\\\",\\\\\"selections\\\\\":[{\\\\\"kind\\\\\":\\\\\"Field\\\\\",\\\\\"name\\\\\":{\\\\\"kind\\\\\":\\\\\"Name\\\\\",\\\\\"value\\\\\":\\\\\"a\\\\\"}}]}}]} as unknown as DocumentNode<AQuery, AQueryVariables>;\"\n    `);\n\n    expect(gqlFile.content.match(/query a {/g).length).toBe(3);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking: true",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 338,
                "column": 29
            },
            "line": 338,
            "code": "    it('fragmentMasking: true', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            plugins: [],\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n      const fileNames = result.map(res => res.filename);\n      expect(fileNames).toContain('out1/fragment-masking.ts');\n      expect(fileNames).toContain('out1/index.ts');\n      expect(fileNames).toContain('out1/gql.ts');\n      expect(fileNames).toContain('out1/graphql.ts');\n\n      const gqlFile = result.find(file => file.filename === 'out1/index.ts');\n      expect(gqlFile.content).toMatchInlineSnapshot(`\n              \"export * from \\\\\"./gql\\\\\"\n              export * from \\\\\"./fragment-masking\\\\\"\"\n            `);\n      const fragmentMaskingFile = result.find(file => file.filename === 'out1/fragment-masking.ts');\n      expect(fragmentMaskingFile.content).toMatchInlineSnapshot(`\n        \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName': infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs': { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType;\n        // return nullable if \\`fragmentType\\` is nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined;\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>;\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): TType | ReadonlyArray<TType> | null | undefined {\n          return fragmentType as any\n        }\n        \"\n      `);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking: {}",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 419,
                "column": 27
            },
            "line": 419,
            "code": "    it('fragmentMasking: {}', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            plugins: [],\n            presetConfig: {\n              fragmentMasking: {},\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking.unmaskFunctionName",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 445,
                "column": 42
            },
            "line": 445,
            "code": "    it('fragmentMasking.unmaskFunctionName', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n        generates: {\n          out1: {\n            preset,\n            plugins: [],\n            presetConfig: {\n              fragmentMasking: {\n                unmaskFunctionName: 'iLikeTurtles',\n              },\n            },\n          },\n        },\n      });\n\n      expect(result).toHaveLength(4);\n      const gqlFile = result.find(file => file.filename === 'out1/fragment-masking.ts');\n      expect(gqlFile.content).toMatchInlineSnapshot(`\n        \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName': infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs': { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType;\n        // return nullable if \\`fragmentType\\` is nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined;\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>;\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined\n        export function iLikeTurtles<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): TType | ReadonlyArray<TType> | null | undefined {\n          return fragmentType as any\n        }\n        \"\n      `);\n\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>>\n      ): TType;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n      ): TType | null | undefined;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n      ): ReadonlyArray<TType>;\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n      ): ReadonlyArray<TType> | null | undefined\n      `);\n      expect(gqlFile.content).toBeSimilarStringTo(`\n      export function iLikeTurtles<TType>(\n        _documentNode: DocumentNode<TType, any>,\n        fragmentType: FragmentType<DocumentNode<TType, any>> | ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n      ): TType | ReadonlyArray<TType> | null | undefined {\n        return fragmentType as any\n      }\n      `);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can accept null in useFragment",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 550,
                "column": 38
            },
            "line": 550,
            "code": "    it('can accept null in useFragment', async () => {\n      const docPath = path.join(__dirname, 'fixtures/with-fragment.ts');\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              foo: Foo\n              foos: [Foo]\n            }\n\n            type Foo {\n              value: String\n            }\n          `,\n        ],\n        documents: docPath,\n        generates: {\n          out1: {\n            preset,\n            plugins: [],\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      const content = mergeOutputs([\n        ...result,\n        readFileSync(docPath, 'utf8'),\n        `\n        function App(props: { data: FooQuery }) {\n          const fragment: FooFragment | null | undefined = useFragment(Fragment, props.data.foo);\n          return fragment == null ? \"no data\" : fragment.value;\n        }\n        `,\n      ]);\n      validateTs(content, undefined, false, true, [`Duplicate identifier 'DocumentNode'.`], true);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "can accept list in useFragment",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 590,
                "column": 38
            },
            "line": 590,
            "code": "    it('can accept list in useFragment', async () => {\n      const docPath = path.join(__dirname, 'fixtures/with-fragment.ts');\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              foo: Foo\n              foos: [Foo!]\n            }\n\n            type Foo {\n              value: String\n            }\n          `,\n        ],\n        documents: docPath,\n        generates: {\n          out1: {\n            preset,\n            plugins: [],\n            presetConfig: {\n              fragmentMasking: true,\n            },\n          },\n        },\n      });\n\n      const content = mergeOutputs([\n        ...result,\n        readFileSync(docPath, 'utf8'),\n        `\n        function App(props: { data: FoosQuery }) {\n          const fragments: ReadonlyArray<FooFragment> | null | undefined = useFragment(Fragment, props.data.foos);\n          return fragments == null ? \"no data\" : fragments.map(f => f.value);\n        }\n        `,\n      ]);\n      validateTs(content, undefined, false, true, [`Duplicate identifier 'DocumentNode'.`], true);\n    });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "fragmentMasking.augmentedModuleName",
            "suites": [
                "gql-tag-operations-preset",
                "fragment masking"
            ],
            "updatePoint": {
                "line": 631,
                "column": 41
            },
            "line": 631,
            "code": "  it('fragmentMasking.augmentedModuleName', async () => {\n    const result = await executeCodegen({\n      schema: [\n        /* GraphQL */ `\n          type Query {\n            a: String\n            b: String\n            c: String\n          }\n        `,\n      ],\n      documents: path.join(__dirname, 'fixtures/simple-uppercase-operation-name.ts'),\n      generates: {\n        out1: {\n          preset,\n          plugins: [],\n          presetConfig: {\n            fragmentMasking: {\n              augmentedModuleName: '@urql/fragment',\n            },\n          },\n        },\n      },\n    });\n\n    expect(result).toHaveLength(4);\n    const fragmentMaskingFile = result.find(file => file.filename === 'out1/fragment-masking.d.ts');\n    expect(fragmentMaskingFile).toBeDefined();\n    expect(fragmentMaskingFile.content).toMatchInlineSnapshot(`\n      \"import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\n\n      declare module \\\\\"@urql/fragment\\\\\" {\n\n        export type FragmentType<TDocumentType extends DocumentNode<any, any>> = TDocumentType extends DocumentNode<\n          infer TType,\n          any\n        >\n          ? TType extends { ' $fragmentName': infer TKey }\n            ? TKey extends string\n              ? { ' $fragmentRefs': { [key in TKey]: TType } }\n              : never\n            : never\n          : never;\n\n\n        // return non-nullable if \\`fragmentType\\` is non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>>\n        ): TType\n        // return nullable if \\`fragmentType\\` is nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: FragmentType<DocumentNode<TType, any>> | null | undefined\n        ): TType | null | undefined\n        // return array of non-nullable if \\`fragmentType\\` is array of non-nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>>\n        ): ReadonlyArray<TType>\n        // return array of nullable if \\`fragmentType\\` is array of nullable\n        export function useFragment<TType>(\n          _documentNode: DocumentNode<TType, any>,\n          fragmentType: ReadonlyArray<FragmentType<DocumentNode<TType, any>>> | null | undefined\n        ): ReadonlyArray<TType> | null | undefined\n      }\"\n    `);\n  });",
            "file": "gql-tag-operations.spec.ts",
            "skipped": false,
            "dir": "packages/presets/gql-tag-operations/tests"
        },
        {
            "name": "should generate interface field resolvers",
            "suites": [],
            "updatePoint": {
                "line": 51,
                "column": 47
            },
            "line": 51,
            "code": "test('should generate interface field resolvers', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      interface BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type User implements BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: true,\n    }\n  );\n\n  expect(output).toContain(`BaseUser: 'id' | 'email';`);\n  expect(output).toContain(`export type BaseUser = Pick<core.BaseUser, DefinedFields['BaseUser']>;`);\n  expect(output).toContain(`export type BaseUserResolvers = Pick<core.BaseUserResolvers, DefinedFields['BaseUser']>;`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not generate graphql-modules code when useGraphQLModules=false",
            "suites": [],
            "updatePoint": {
                "line": 85,
                "column": 75
            },
            "line": 85,
            "code": "test('should not generate graphql-modules code when useGraphQLModules=false', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      interface BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type User implements BaseUser {\n        id: ID!\n        email: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: false,\n    }\n  );\n\n  expect(output).not.toContain(`graphql-modules`);\n  expect(output).not.toContain(`gm.`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate interface extensions field resolvers ",
            "suites": [],
            "updatePoint": {
                "line": 118,
                "column": 59
            },
            "line": 118,
            "code": "test('should generate interface extensions field resolvers ', () => {\n  const output = buildModule(\n    'test',\n    parse(/* GraphQL */ `\n      extend interface BaseUser {\n        newField: String!\n      }\n\n      type Query {\n        me: BaseUser!\n      }\n    `),\n    {\n      importPath: '../types',\n      importNamespace: 'core',\n      encapsulate: 'none',\n      shouldDeclare: false,\n      rootTypes: ROOT_TYPES,\n      baseVisitor,\n      useGraphQLModules: true,\n    }\n  );\n\n  expect(output).toContain(`BaseUser: 'newField';`);\n  expect(output).toContain(`export type BaseUser = core.BaseUser`);\n  expect(output).toContain(`export type BaseUserResolvers = Pick<core.BaseUserResolvers, DefinedFields['BaseUser']>;`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should include import statement",
            "suites": [],
            "updatePoint": {
                "line": 146,
                "column": 37
            },
            "line": 146,
            "code": "test('should include import statement', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    import * as core from \"../types\";\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should work with naming conventions",
            "suites": [],
            "updatePoint": {
                "line": 162,
                "column": 41
            },
            "line": 162,
            "code": "test('should work with naming conventions', () => {\n  const output = buildModule('test', parse(`type query_root { test: ID! } schema { query: query_root }`), {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toContain(`Pick<core.Query_RootResolvers, `);\n  expect(output).toContain(`Pick<core.Query_Root,`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with namespace",
            "suites": [],
            "updatePoint": {
                "line": 177,
                "column": 55
            },
            "line": 177,
            "code": "test('encapsulate: should wrap correctly with namespace', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'namespace',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`export namespace TestModule {`);\n  expect(output).toMatchSnapshot();\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with a declared namespace",
            "suites": [],
            "updatePoint": {
                "line": 192,
                "column": 66
            },
            "line": 192,
            "code": "test('encapsulate: should wrap correctly with a declared namespace', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'namespace',\n    shouldDeclare: true,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`declare namespace TestModule {`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "encapsulate: should wrap correctly with prefix",
            "suites": [],
            "updatePoint": {
                "line": 206,
                "column": 52
            },
            "line": 206,
            "code": "test('encapsulate: should wrap correctly with prefix', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'prefix',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toMatchSnapshot();\n  expect(output).toContain(`export type Test_Article`);\n  expect(output).toContain(`export type Test_User`);\n  expect(output).toContain(`export type Test_Scalars`);\n  expect(output).toContain(`export type Test_ArticleResolvers`);\n  expect(output).toContain(`export interface Test_Resolvers`);\n  expect(output).toContain(`export interface Test_MiddlewareMap`);\n  expect(output).toContain(`interface DefinedFields {`);\n  expect(output).toContain(`interface DefinedEnumValues {`);\n  expect(output).toContain(`interface DefinedInputFields {`);\n  expect(output).not.toBeSimilarStringTo(`export namespace Test {`);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should pick fields from defined and extended types",
            "suites": [],
            "updatePoint": {
                "line": 230,
                "column": 56
            },
            "line": 230,
            "code": "test('should pick fields from defined and extended types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedFields {\n      Article: 'id' | 'title' | 'text' | 'author' | 'comments' | 'url';\n      Query: 'articles' | 'articleById' | 'articlesByUser';\n      User: 'articles';\n      Node: 'id';\n    };\n  `);\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedEnumValues {\n      UserKind: 'ADMIN' | 'WRITER' | 'REGULAR';\n    };\n  `);\n\n  expect(output).toBeSimilarStringTo(`\n    interface DefinedInputFields {\n      NewArticle: 'title' | 'text';\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should reexport used types but not defined in module",
            "suites": [],
            "updatePoint": {
                "line": 263,
                "column": 58
            },
            "line": 263,
            "code": "test('should reexport used types but not defined in module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type User = core.User;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Comment = core.Comment;\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should export partial types, only those defined in module or root types",
            "suites": [],
            "updatePoint": {
                "line": 282,
                "column": 77
            },
            "line": 282,
            "code": "test('should export partial types, only those defined in module or root types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type Article = Pick<core.Article, DefinedFields['Article']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Query = Pick<core.Query, DefinedFields['Query']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UserKind = DefinedEnumValues['UserKind'];\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type NewArticle = Pick<core.NewArticle, DefinedInputFields['NewArticle']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type Node = Pick<core.Node, DefinedFields['Node']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type ArticleOrUser = core.ArticleOrUser;\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should export partial types of scalars, only those defined in module or root types",
            "suites": [],
            "updatePoint": {
                "line": 313,
                "column": 88
            },
            "line": 313,
            "code": "test('should export partial types of scalars, only those defined in module or root types', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type Scalars = Pick<core.Scalars, 'DateTime' | 'URL'>;\n  `);\n\n  // DateTime type should not be generated\n  expect(output).not.toBeSimilarStringTo(`\n    export type DateTime =\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should use and export resolver signatures of types defined or extended in a module",
            "suites": [],
            "updatePoint": {
                "line": 334,
                "column": 88
            },
            "line": 334,
            "code": "test('should use and export resolver signatures of types defined or extended in a module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export type ArticleResolvers = Pick<core.ArticleResolvers, DefinedFields['Article'] | '__isTypeOf'>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type QueryResolvers = Pick<core.QueryResolvers, DefinedFields['Query']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UserResolvers = Pick<core.UserResolvers, DefinedFields['User']>;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type DateTimeScalarConfig = core.DateTimeScalarConfig;\n  `);\n  expect(output).toBeSimilarStringTo(`\n    export type UrlScalarConfig = core.UrlScalarConfig;\n  `);\n  // Interfaces should not have resolvers\n  // We want Object types to have __isTypeOf\n  expect(output).toBeSimilarStringTo(`\n    export type NodeResolvers\n  `);\n  // Unions should not have resolvers\n  // We want Object types to have __isTypeOf\n  expect(output).not.toBeSimilarStringTo(`\n    export type ArticleOrUserResolvers\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not generate resolver signatures of types that are not defined or extened by a module",
            "suites": [],
            "updatePoint": {
                "line": 372,
                "column": 98
            },
            "line": 372,
            "code": "test('should not generate resolver signatures of types that are not defined or extened by a module', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).not.toContain('CommentResolvers');\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate an aggregation of individual resolver signatures",
            "suites": [],
            "updatePoint": {
                "line": 386,
                "column": 70
            },
            "line": 386,
            "code": "test('should generate an aggregation of individual resolver signatures', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toBeSimilarStringTo(`\n    export interface Resolvers {\n      Article?: ArticleResolvers;\n      Query?: QueryResolvers;\n      User?: UserResolvers;\n      DateTime?: core.Resolvers['DateTime'];\n      URL?: core.Resolvers['URL'];\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate a signature for ResolveMiddleware (with widlcards)",
            "suites": [],
            "updatePoint": {
                "line": 408,
                "column": 72
            },
            "line": 408,
            "code": "test('should generate a signature for ResolveMiddleware (with widlcards)', () => {\n  const output = buildModule('test', testDoc, {\n    importPath: '../types',\n    importNamespace: 'core',\n    encapsulate: 'none',\n    shouldDeclare: false,\n    rootTypes: ROOT_TYPES,\n    baseVisitor,\n    useGraphQLModules: true,\n  });\n\n  expect(output).toContain(`import * as gm from \"graphql-modules\";`);\n\n  expect(output).toBeSimilarStringTo(`\n    export interface MiddlewareMap {\n      '*'?: {\n        '*'?: gm.Middleware[];\n      };\n      Article?: {\n        '*'?: gm.Middleware[];\n        id?: gm.Middleware[];\n        title?: gm.Middleware[];\n        text?: gm.Middleware[];\n        author?: gm.Middleware[];\n        comments?: gm.Middleware[];\n        url?: gm.Middleware[];\n      };\n      User?: {\n        '*'?: gm.Middleware[];\n        articles?: gm.Middleware[];\n      };\n      Query?: {\n        '*'?: gm.Middleware[];\n        articles?: gm.Middleware[];\n        articleById?: gm.Middleware[];\n        articlesByUser?: gm.Middleware[];\n      };\n    };\n  `);\n});",
            "file": "builder.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should generate a base output and 4 for modules",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 33,
                "column": 55
            },
            "line": 33,
            "code": "  test('should generate a base output and 4 for modules', async () => {\n    try {\n      const output = await executeCodegen(options);\n\n      expect(output.length).toBe(5);\n      expect(normalize(output[0].filename)).toMatch(normalize(`/modules/global-types.ts`));\n      expect(normalize(output[1].filename)).toMatch(normalize(`/modules/blog/module-types.ts`));\n      expect(normalize(output[2].filename)).toMatch(normalize(`/modules/common/module-types.ts`));\n      expect(normalize(output[3].filename)).toMatch(normalize(`/modules/dotanions/module-types.ts`));\n      expect(normalize(output[4].filename)).toMatch(normalize(`/modules/users/module-types.ts`));\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n      throw e;\n    }\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should not duplicate type even if type and extend type are in the same module",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 50,
                "column": 85
            },
            "line": 50,
            "code": "  test('should not duplicate type even if type and extend type are in the same module', async () => {\n    try {\n      const output = await executeCodegen(options);\n\n      const userResolversStr = `export type UserResolvers = Pick<Types.UserResolvers, DefinedFields['User'] | '__isTypeOf'>;`;\n      const nbOfTimeUserResolverFound = output[4].content.split(userResolversStr).length - 1;\n\n      expect(nbOfTimeUserResolverFound).toBe(1);\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.error(e);\n      throw e;\n    }\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should allow to override importBaseTypesFrom correctly",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 65,
                "column": 62
            },
            "line": 65,
            "code": "  test('should allow to override importBaseTypesFrom correctly', async () => {\n    const output = await executeCodegen({\n      generates: {\n        './tests/test-files/modules': {\n          schema: './tests/test-files/modules/*/types/*.graphql',\n          plugins: ['typescript', 'typescript-resolvers'],\n          preset: 'graphql-modules',\n          presetConfig: {\n            importBaseTypesFrom: '@types',\n            baseTypesPath: 'global-types.ts',\n            filename: 'module-types.ts',\n            encapsulateModuleTypes: 'none',\n          },\n        },\n      },\n    });\n    const importStatement = `import * as Types from \"@types\";`;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(importStatement);\n    expect(output[2].content).toMatch(importStatement);\n    expect(output[3].content).toMatch(importStatement);\n    expect(output[4].content).toMatch(importStatement);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "should allow to disable graphql-modules",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 90,
                "column": 47
            },
            "line": 90,
            "code": "  test('should allow to disable graphql-modules', async () => {\n    const output = await executeCodegen({\n      generates: {\n        './tests/test-files/modules': {\n          schema: './tests/test-files/modules/*/types/*.graphql',\n          plugins: ['typescript', 'typescript-resolvers'],\n          preset: 'graphql-modules',\n          presetConfig: {\n            importBaseTypesFrom: '@types',\n            baseTypesPath: 'global-types.ts',\n            filename: 'module-types.ts',\n            encapsulateModuleTypes: 'none',\n            useGraphQLModules: false,\n          },\n        },\n      },\n    });\n\n    for (const record of output) {\n      expect(record).not.toContain(`graphql-modules`);\n      expect(record).not.toContain(`gm.`);\n    }\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "each module-types should include a relative import to glob-types module",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 114,
                "column": 79
            },
            "line": 114,
            "code": "  test('each module-types should include a relative import to glob-types module', async () => {\n    const output = await executeCodegen(options);\n    const importStatement = `import * as Types from \"../global-types\";`;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(importStatement);\n    expect(output[2].content).toMatch(importStatement);\n    expect(output[3].content).toMatch(importStatement);\n    expect(output[4].content).toMatch(importStatement);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "each module-types should export Resolvers",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 125,
                "column": 49
            },
            "line": 125,
            "code": "  test('each module-types should export Resolvers', async () => {\n    const output = await executeCodegen(options);\n    const exportStatemment = `export interface Resolvers `;\n\n    expect(output.length).toBe(5);\n    expect(output[1].content).toMatch(exportStatemment);\n    expect(output[2].content).toMatch(exportStatemment);\n    expect(output[3].content).toMatch(exportStatemment);\n    expect(output[4].content).toMatch(exportStatemment);\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "dotanions module should export DefinedFields, Schema Types with Picks and resolvers",
            "suites": [
                "Integration"
            ],
            "updatePoint": {
                "line": 136,
                "column": 91
            },
            "line": 136,
            "code": "  test('dotanions module should export DefinedFields, Schema Types with Picks and resolvers', async () => {\n    const output = await executeCodegen(options);\n\n    expect(output.length).toBe(5);\n    expect(output[3].content).toMatchSnapshot();\n  });",
            "file": "integration.spec.ts",
            "skipped": false,
            "dir": "packages/presets/graphql-modules/tests"
        },
        {
            "name": "Should build the correct operation files paths",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 74,
                "column": 52
            },
            "line": 74,
            "code": "  it('Should build the correct operation files paths', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: testDocuments,\n      plugins: [],\n      pluginMap: {},\n    });\n\n    expect(result.map(a => a.filename)).toEqual(['./src/operation.ts']);\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 90,
                "column": 61
            },
            "line": 90,
            "code": "  it('Should prepend the \"add\" plugin with the correct import', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from './types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import type",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 114,
                "column": 66
            },
            "line": 114,
            "code": "  it('Should prepend the \"add\" plugin with the correct import type', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {\n        useTypeImports: true,\n      },\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import type * as Types from './types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import, when only using fragment spread",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 140,
                "column": 94
            },
            "line": 140,
            "code": "  it('Should prepend the \"add\" plugin with the correct import, when only using fragment spread', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: [\n        { location: '/some/deep/path/src/graphql/me-query.graphql', document: minimalOperationAst },\n        testDocuments[1],\n      ],\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([{ add: { content: `import * as Types from './types';\\n` } }])\n    );\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should NOT prepend the \"add\" plugin with Types import when selection set does not include direct fields",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 161,
                "column": 109
            },
            "line": 161,
            "code": "  it('Should NOT prepend the \"add\" plugin with Types import when selection set does not include direct fields', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: './test.graphql',\n          document: parse(/* GraphQL */ `\n            query {\n              user {\n                ...UserFields\n              }\n            }\n          `),\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).not.toEqual(\n      expect.arrayContaining([{ add: { content: `import * as Types from '../types';\\n` } }])\n    );\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should add \"add\" plugin to plugins map if its not there",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 191,
                "column": 61
            },
            "line": 191,
            "code": "  it('Should add \"add\" plugin to plugins map if its not there', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.pluginMap.add)[0]).toBeDefined();\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "Should add \"namespacedImportName\" to config",
            "suites": [
                "import-types preset"
            ],
            "updatePoint": {
                "line": 207,
                "column": 49
            },
            "line": 207,
            "code": "  it('Should add \"namespacedImportName\" to config', async () => {\n    const result = await preset.buildGeneratesSection({\n      baseOutputDir: './src/operation.ts',\n      config: {},\n      presetConfig: {\n        typesPath: './types',\n      },\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.config.namespacedImportName)[0]).toBe('Types');\n  });",
            "file": "types-import.spec.ts",
            "skipped": false,
            "dir": "packages/presets/import-types/tests"
        },
        {
            "name": "#5002 - error when inline fragment does not specify the name of the type",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 88,
                "column": 80
            },
            "line": 88,
            "code": "    it('#5002 - error when inline fragment does not specify the name of the type', async () => {\n      const testSchema = parse(/* GraphQL */ `\n        scalar Date\n\n        schema {\n          query: Query\n        }\n\n        type Query {\n          me: User!\n          user(id: ID!): User\n          allUsers: [User]\n          search(term: String!): [SearchResult!]!\n          myChats: [Chat!]!\n        }\n\n        enum Role {\n          USER\n          ADMIN\n        }\n\n        interface Node {\n          id: ID!\n        }\n\n        union SearchResult = User | Chat | ChatMessage\n\n        type User implements Node {\n          id: ID!\n          username: String!\n          email: String!\n          role: Role!\n        }\n\n        type Chat implements Node {\n          id: ID!\n          users: [User!]!\n          messages: [ChatMessage!]!\n        }\n\n        type ChatMessage implements Node {\n          id: ID!\n          content: String!\n          time: Date!\n          user: User!\n        }\n      `);\n\n      const operations = [\n        {\n          location: 'test.graphql',\n          document: parse(/* GraphQL */ `\n            query chats {\n              myChats {\n                ...ChatFields\n              }\n            }\n\n            fragment ChatFields on Chat {\n              id\n              ... @include(if: true) {\n                id\n                messages {\n                  id\n                }\n              }\n            }\n          `),\n        },\n      ];\n\n      expect(async () => {\n        await executePreset({\n          baseOutputDir: './src/',\n          config: {},\n          presetConfig: {\n            folder: '__generated__',\n            baseTypesPath: 'types.ts',\n          },\n          schema: testSchema,\n          schemaAst: buildASTSchema(testSchema),\n          documents: operations,\n          plugins: [],\n          pluginMap: {},\n        });\n      }).not.toThrow();\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#3066 - should respect higher level of fragments usage, and ignore fragments per input",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 176,
                "column": 94
            },
            "line": 176,
            "code": "    it('#3066 - should respect higher level of fragments usage, and ignore fragments per input', async () => {\n      const doTest = async (operationsStr: string, expected: string) => {\n        const testSchema = buildSchema(/* GraphQL */ `\n          schema {\n            query: Query\n          }\n\n          type Query {\n            list: [Book]\n            pages: [Page]\n          }\n\n          type Book {\n            id: ID!\n            title: String!\n            pages: [Page!]!\n          }\n\n          type Page {\n            id: ID!\n            number: Int!\n          }\n        `);\n        const result = await executePreset({\n          baseOutputDir: './src/',\n          config: {},\n          presetConfig: {\n            cwd: '/some/deep/path',\n            baseTypesPath: 'types.ts',\n          },\n          schemaAst: testSchema,\n          schema: getCachedDocumentNodeFromSchema(testSchema),\n          documents: [\n            {\n              location: '/some/deep/path/src/graphql/queries.graphql',\n              document: parse(operationsStr),\n            },\n            {\n              location: '/some/deep/path/src/graphql/fragments.graphql',\n              document: parse(/* GraphQL */ `\n                fragment Page on Page {\n                  id\n                  number\n                }\n\n                fragment Book on Book {\n                  id\n                  title\n                  pages {\n                    ...Page\n                  }\n                }\n              `),\n            },\n          ],\n          plugins: [{ 'typescript-react-apollo': {} }],\n          pluginMap: { 'typescript-react-apollo': {} as any },\n        });\n\n        expect(result[0].filename).toContain(`queries.generated.ts`);\n        expect(getFragmentImportsFromResult(result)).toBe(expected);\n      };\n\n      await doTest(\n        /* GraphQL */ `\n          query Pages {\n            pages {\n              ...Page\n            }\n          }\n\n          query List {\n            list {\n              ...Book\n            }\n          }\n        `,\n        `import { PageFragmentDoc, PageFragment, BookFragmentDoc, BookFragment } from './fragments.generated';`\n      );\n\n      // Try to flip the order of operations to see if it's still works\n      await doTest(\n        /* GraphQL */ `\n          query List {\n            list {\n              ...Book\n            }\n          }\n\n          query Pages {\n            pages {\n              ...Page\n            }\n          }\n        `,\n        `import { BookFragmentDoc, BookFragment, PageFragmentDoc, PageFragment } from './fragments.generated';`\n      );\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#2365 - Should not add Fragment suffix to import identifier when dedupeOperationSuffix: true",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 275,
                "column": 100
            },
            "line": 275,
            "code": "    it('#2365 - Should not add Fragment suffix to import identifier when dedupeOperationSuffix: true', async () => {\n      const result = await executePreset({\n        baseOutputDir: './src/',\n        config: {\n          dedupeOperationSuffix: true,\n        },\n        presetConfig: {\n          cwd: '/some/deep/path',\n          baseTypesPath: 'types.ts',\n        },\n        schemaAst: schemaNode,\n        schema: schemaDocumentNode,\n        documents: [\n          {\n            location: '/some/deep/path/src/graphql/me-query.graphql',\n            document: parse(/* GraphQL */ `\n              query {\n                user {\n                  id\n                  ...UserFieldsFragment\n                }\n              }\n            `),\n          },\n          {\n            location: '/some/deep/path/src/graphql/user-fragment.graphql',\n            document: parse(/* GraphQL */ `\n              fragment UserFieldsFragment on User {\n                id\n                username\n              }\n            `),\n          },\n        ],\n        plugins: [{ 'typescript-react-apollo': {} }],\n        pluginMap: { 'typescript-react-apollo': {} as any },\n      });\n\n      expect(result.map(o => o.plugins)[0]).toEqual(\n        expect.arrayContaining([\n          {\n            add: {\n              content: `import * as Types from '../types';\\n`,\n            },\n          },\n          {\n            'typescript-react-apollo': {},\n          },\n        ])\n      );\n\n      expect(getFragmentImportsFromResult(result)).toContain(\n        `import { UserFieldsFragmentDoc, UserFieldsFragment } from './user-fragment.generated';`\n      );\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#2365 - Should add Fragment suffix to import identifier when dedupeOperationSuffix not set",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 331,
                "column": 98
            },
            "line": 331,
            "code": "    it('#2365 - Should add Fragment suffix to import identifier when dedupeOperationSuffix not set', async () => {\n      const result = await executePreset({\n        baseOutputDir: './src/',\n        config: {},\n        presetConfig: {\n          cwd: '/some/deep/path',\n          baseTypesPath: 'types.ts',\n        },\n        schemaAst: schemaNode,\n        schema: schemaDocumentNode,\n        documents: [\n          {\n            location: '/some/deep/path/src/graphql/me-query.graphql',\n            document: parse(/* GraphQL */ `\n              query {\n                user {\n                  id\n                  ...UserFieldsFragment\n                }\n              }\n            `),\n          },\n          {\n            location: '/some/deep/path/src/graphql/user-fragment.graphql',\n            document: parse(/* GraphQL */ `\n              fragment UserFieldsFragment on User {\n                id\n                username\n              }\n            `),\n          },\n        ],\n        plugins: [{ 'typescript-react-apollo': {} }],\n        pluginMap: { 'typescript-react-apollo': {} as any },\n      });\n\n      expect(result.map(o => o.plugins)[0]).toEqual(\n        expect.arrayContaining([\n          {\n            add: {\n              content: `import * as Types from '../types';\\n`,\n            },\n          },\n          {\n            'typescript-react-apollo': {},\n          },\n        ])\n      );\n\n      expect(getFragmentImportsFromResult(result)).toContain(\n        `import { UserFieldsFragmentFragmentDoc, UserFieldsFragmentFragment } from './user-fragment.generated';`\n      );\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#6439 - generating code only for the last query inside a file",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 385,
                "column": 69
            },
            "line": 385,
            "code": "    it('#6439 - generating code only for the last query inside a file', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              a: String\n              b: String\n              c: String\n            }\n          `,\n        ],\n        documents: path.join(__dirname, 'fixtures/issue-6439.ts'),\n        generates: {\n          'out1.ts': {\n            preset,\n            presetConfig: {\n              baseTypesPath: 'types.ts',\n            },\n            plugins: ['typescript-operations'],\n          },\n        },\n      });\n\n      expect(result[0].content).toMatchInlineSnapshot(`\n        \"import * as Types from '../../../../../out1.ts/types';\n\n        export type AQueryVariables = Types.Exact<{ [key: string]: never; }>;\n\n\n        export type AQuery = { __typename?: 'Query', a?: string | null };\n\n        export type BQueryVariables = Types.Exact<{ [key: string]: never; }>;\n\n\n        export type BQuery = { __typename?: 'Query', a?: string | null };\n\n        export type CQueryVariables = Types.Exact<{ [key: string]: never; }>;\n\n\n        export type CQuery = { __typename?: 'Query', a?: string | null };\n        \"\n      `);\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#6520 - self-importing fragment",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 429,
                "column": 39
            },
            "line": 429,
            "code": "    it('#6520 - self-importing fragment', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              user(id: String!): User!\n            }\n\n            type User {\n              id: String!\n              email: String\n              username: String\n            }\n          `,\n        ],\n        documents: [path.join(__dirname, 'fixtures/issue-6520.ts')],\n        generates: {\n          'out1.ts': {\n            preset,\n            presetConfig: {\n              baseTypesPath: 'types.ts',\n            },\n            plugins: ['typescript-operations', 'typescript-react-apollo'],\n          },\n        },\n      });\n\n      expect(result[0].content).not.toMatch(`import { UserFieldsFragmentDoc }`);\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#6546 - duplicate fragment imports",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 459,
                "column": 42
            },
            "line": 459,
            "code": "    it('#6546 - duplicate fragment imports', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type Query {\n              user(id: String!): User!\n            }\n\n            type User {\n              id: String!\n              email: String\n              username: String\n            }\n          `,\n        ],\n        documents: [\n          path.join(__dirname, 'fixtures/issue-6546-queries.ts'),\n          path.join(__dirname, 'fixtures/issue-6546-fragments.ts'),\n        ],\n        generates: {\n          'out1.ts': {\n            preset,\n            presetConfig: {\n              baseTypesPath: 'types.ts',\n            },\n            plugins: ['typescript-operations', 'typescript-react-apollo'],\n          },\n        },\n      });\n\n      const queriesContent = result.find(generatedDoc => generatedDoc.filename.match(/issue-6546-queries/)).content;\n      const imports = queriesContent.match(/import.*UsernameFragmentFragmentDoc/g);\n      expect(imports).toHaveLength(1);\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#7547 - importing root types when a fragment spread a fragment without any fields itself",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 494,
                "column": 96
            },
            "line": 494,
            "code": "    it('#7547 - importing root types when a fragment spread a fragment without any fields itself', async () => {\n      const testSchema = buildSchema(/* GraphQL */ `\n        enum Role {\n          ADMIN\n          USER\n        }\n\n        type User {\n          id: ID!\n          type: Role!\n        }\n      `);\n\n      const result = await executePreset({\n        baseOutputDir: './src/',\n        config: {\n          dedupeOperationSuffix: true,\n        },\n        presetConfig: {\n          cwd: '/some/deep/path',\n          baseTypesPath: 'types.ts',\n        },\n        schemaAst: testSchema,\n        schema: getCachedDocumentNodeFromSchema(testSchema),\n        documents: [\n          {\n            location: '/some/deep/path/src/graphql/a-fragment.gql',\n            document: parse(/* GraphQL */ `\n              fragment AFragment on User {\n                ...BFragment\n              }\n            `),\n          },\n          {\n            location: '/some/deep/path/src/graphql/b-fragment.graphql',\n            document: parse(/* GraphQL */ `\n              fragment BFragment on User {\n                ...CFragment\n              }\n            `),\n          },\n          {\n            location: '/some/deep/path/src/graphql/c-fragment.graphql',\n            document: parse(/* GraphQL */ `\n              fragment CFragment on User {\n                id\n                type\n              }\n            `),\n          },\n        ],\n        plugins: [{ typescript: {} }],\n        pluginMap: { typescript: {} as any },\n      });\n\n      for (const o of result) {\n        expect(o.plugins).toEqual(\n          expect.arrayContaining([{ add: { content: `import * as Types from '../types';\\n` } }])\n        );\n      }\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "#7798 - importing type definitions of dependent fragments when `inlineFragmentType` is `mask`",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 556,
                "column": 101
            },
            "line": 556,
            "code": "    it('#7798 - importing type definitions of dependent fragments when `inlineFragmentType` is `mask`', async () => {\n      const result = await executeCodegen({\n        schema: [\n          /* GraphQL */ `\n            type User {\n              id: ID!\n              name: String!\n            }\n\n            type Query {\n              user(id: ID!): User!\n            }\n          `,\n        ],\n        documents: [\n          path.join(__dirname, 'fixtures/issue-7798-parent.ts'),\n          path.join(__dirname, 'fixtures/issue-7798-child.ts'),\n        ],\n        generates: {\n          'out1.ts': {\n            preset,\n            presetConfig: {\n              baseTypesPath: 'types.ts',\n            },\n            plugins: ['typescript-operations'],\n            config: { inlineFragmentTypes: 'mask' },\n          },\n        },\n      });\n\n      const parentContent = result.find(generatedDoc => generatedDoc.filename.match(/issue-7798-parent/)).content;\n      const imports = parentContent.match(/import.*UserNameFragment/g);\n      expect(imports).toHaveLength(1);\n    });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "should not add imports for fragments in the same location",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 592,
                "column": 63
            },
            "line": 592,
            "code": "  it('should not add imports for fragments in the same location', async () => {\n    const location = '/some/deep/path/src/graphql/me-query.graphql';\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {\n        dedupeOperationSuffix: true,\n      },\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location,\n          document: parse(/* GraphQL */ `\n            query {\n              user {\n                id\n                ...UserFieldsFragment\n              }\n            }\n          `),\n        },\n        {\n          location,\n          document: parse(/* GraphQL */ `\n            fragment UserFieldsFragment on User {\n              id\n              username\n            }\n          `),\n        },\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(getFragmentImportsFromResult(result)).toEqual('');\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should build the correct operation files paths",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 634,
                "column": 52
            },
            "line": 634,
            "code": "  it('Should build the correct operation files paths', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments,\n      plugins: [],\n      pluginMap: {},\n    });\n\n    expect(result.map(a => a.filename)).toEqual([\n      '/some/deep/path/src/graphql/me-query.generated.ts',\n      '/some/deep/path/src/graphql/user-fragment.generated.ts',\n      '/some/deep/path/src/graphql/me.query.generated.ts',\n      '/some/deep/path/src/graphql/something-query.generated.ts',\n      '/some/deep/path/src/graphql/nested/somethingElse.generated.ts',\n      '/some/deep/path/src/graphql/nested/from-js.generated.ts',\n      '/some/deep/path/src/graphql/component.generated.ts',\n    ]);\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should build the correct operation files paths with a subfolder",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 659,
                "column": 69
            },
            "line": 659,
            "code": "  it('Should build the correct operation files paths with a subfolder', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        folder: '__generated__',\n        baseTypesPath: 'types.ts',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: testDocuments,\n      plugins: [],\n      pluginMap: {},\n    });\n    expect(result.map(a => a.filename)).toEqual([\n      '/some/deep/path/src/graphql/__generated__/me-query.generated.ts',\n      '/some/deep/path/src/graphql/__generated__/user-fragment.generated.ts',\n      '/some/deep/path/src/graphql/__generated__/me.query.generated.ts',\n      '/some/deep/path/src/graphql/__generated__/something-query.generated.ts',\n      '/some/deep/path/src/graphql/nested/__generated__/somethingElse.generated.ts',\n      '/some/deep/path/src/graphql/nested/__generated__/from-js.generated.ts',\n      '/some/deep/path/src/graphql/__generated__/component.generated.ts',\n    ]);\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should skip the duplicate documents validation",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 684,
                "column": 52
            },
            "line": 684,
            "code": "  it('Should skip the duplicate documents validation', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        baseTypesPath: 'types.ts',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: testDocuments,\n      plugins: [],\n      pluginMap: {},\n    });\n\n    expect(result[0].skipDocumentsValidation).toBeTruthy();\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should allow to customize output extension",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 701,
                "column": 48
            },
            "line": 701,
            "code": "  it('Should allow to customize output extension', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n        extension: '.flow.js',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: testDocuments,\n      plugins: [],\n      pluginMap: {},\n    });\n\n    expect(result.map(a => a.filename)).toEqual([\n      '/some/deep/path/src/graphql/me-query.flow.js',\n      '/some/deep/path/src/graphql/user-fragment.flow.js',\n      '/some/deep/path/src/graphql/me.query.flow.js',\n      '/some/deep/path/src/graphql/something-query.flow.js',\n      '/some/deep/path/src/graphql/nested/somethingElse.flow.js',\n      '/some/deep/path/src/graphql/nested/from-js.flow.js',\n      '/some/deep/path/src/graphql/component.flow.js',\n    ]);\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 728,
                "column": 61
            },
            "line": 728,
            "code": "  it('Should prepend the \"add\" plugin with the correct import', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '../types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import when used with package name",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 754,
                "column": 89
            },
            "line": 754,
            "code": "  it('Should prepend the \"add\" plugin with the correct import when used with package name', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: '~@custom-package/types',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '@custom-package/types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import, when only using fragment spread",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 780,
                "column": 94
            },
            "line": 780,
            "code": "  it('Should prepend the \"add\" plugin with the correct import, when only using fragment spread', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schema: schemaDocumentNode,\n      schemaAst: schemaNode,\n      documents: [\n        { location: '/some/deep/path/src/graphql/me-query.graphql', document: minimalOperationAst },\n        testDocuments[1],\n      ],\n      plugins: [{ typescript: {} }],\n      pluginMap: { typescript: {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[1]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '../types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "should fail when multiple fragments with the same name but different definition are found",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 809,
                "column": 95
            },
            "line": 809,
            "code": "  it('should fail when multiple fragments with the same name but different definition are found', () => {\n    expect(() =>\n      executePreset({\n        baseOutputDir: './src/',\n        config: {},\n        presetConfig: {\n          cwd: '/some/deep/path',\n          baseTypesPath: 'types.ts',\n        },\n        schema: schemaDocumentNode,\n        schemaAst: schemaNode,\n        documents: [\n          testDocuments[1],\n          {\n            location: `/some/deep/path/src/graphql/user-fragment.graphql`,\n            document: parse(/* GraphQL */ `\n              fragment UserFields on User {\n                id\n              }\n            `),\n          },\n        ],\n        plugins: [{ typescript: {} }],\n        pluginMap: { typescript: {} as any },\n      })\n    ).toThrow('Multiple fragments with the name(s) \"UserFields\" were found.');\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "should NOT fail when multiple fragments with the same name and definition are found",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 837,
                "column": 89
            },
            "line": 837,
            "code": "  it('should NOT fail when multiple fragments with the same name and definition are found', () => {\n    expect(() =>\n      executePreset({\n        baseOutputDir: './src/',\n        config: {},\n        presetConfig: {\n          cwd: '/some/deep/path',\n          baseTypesPath: 'types.ts',\n        },\n        schema: schemaDocumentNode,\n        schemaAst: schemaNode,\n        documents: [testDocuments[1], testDocuments[1]],\n        plugins: [{ typescript: {} }],\n        pluginMap: { typescript: {} as any },\n      })\n    ).not.toThrow('Multiple fragments with the name(s) \"UserFields\" were found.');\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should NOT prepend the \"add\" plugin with Types import when selection set does not include direct fields",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 855,
                "column": 109
            },
            "line": 855,
            "code": "  it('Should NOT prepend the \"add\" plugin with Types import when selection set does not include direct fields', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: './test.graphql',\n          document: parse(/* GraphQL */ `\n            query {\n              user {\n                ...UserFields\n              }\n            }\n          `),\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).not.toEqual(\n      expect.arrayContaining([{ add: { content: `import * as Types from '../types.js';\\n` } }])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with Types import when arguments are used",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 887,
                "column": 79
            },
            "line": 887,
            "code": "  it('Should prepend the \"add\" plugin with Types import when arguments are used', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: './test.graphql',\n          document: parse(/* GraphQL */ `\n            query ($id: String) {\n              user(id: $id) {\n                ...UserFields\n              }\n            }\n          `),\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from './src/types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import (long path)",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 925,
                "column": 73
            },
            "line": 925,
            "code": "  it('Should prepend the \"add\" plugin with the correct import (long path)', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: '/some/deep/path/src/graphql/nested/here/me-query.graphql',\n          document: operationAst,\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '../../../types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should prepend the \"add\" plugin with the correct import (siblings)",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 956,
                "column": 72
            },
            "line": 956,
            "code": "  it('Should prepend the \"add\" plugin with the correct import (siblings)', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: '/some/deep/path/src/me-query.graphql',\n          document: operationAst,\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from './types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should not generate an absolute path if the path starts with \"~\"",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 987,
                "column": 70
            },
            "line": 987,
            "code": "  it('Should not generate an absolute path if the path starts with \"~\"', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: '~@internal/types',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: '/some/deep/path/src/me-query.graphql',\n          document: operationAst,\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '@internal/types';\\n`,\n          },\n        },\n      ])\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should add \"add\" plugin to plugins map if its not there",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1018,
                "column": 61
            },
            "line": 1018,
            "code": "  it('Should add \"add\" plugin to plugins map if its not there', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.pluginMap.add)[0]).toBeDefined();\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should add \"namespacedImportName\" to config",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1036,
                "column": 49
            },
            "line": 1036,
            "code": "  it('Should add \"namespacedImportName\" to config', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.config.namespacedImportName)[0]).toBe('Types');\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should add import to external fragment when its in use",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1054,
                "column": 60
            },
            "line": 1054,
            "code": "  it('Should add import to external fragment when its in use', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '../types';\\n`,\n          },\n        },\n        {\n          'typescript-react-apollo': {},\n        },\n      ])\n    );\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { UserFieldsFragmentDoc, UserFieldsFragment } from './user-fragment.generated';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should allow external fragments to be imported from packages with function",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1087,
                "column": 80
            },
            "line": 1087,
            "code": "  it('Should allow external fragments to be imported from packages with function', async () => {\n    const spy = jest.fn();\n    await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: '~@types',\n        importAllFragmentsFrom: spy.mockReturnValue(false),\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(spy.mock.calls.length).toBe(1);\n    expect(spy.mock.calls[0][1]).toBe('/some/deep/path/src/graphql/me-query.generated.ts');\n    expect(spy.mock.calls[0][0].path).toBe('/some/deep/path/src/graphql/user-fragment.generated.ts');\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should allow external fragments to be imported from packages",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1109,
                "column": 66
            },
            "line": 1109,
            "code": "  it('Should allow external fragments to be imported from packages', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: '~@types',\n        importAllFragmentsFrom: `~@fragments`,\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: testDocuments.slice(0, 2),\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(result.map(o => o.plugins)[0]).toEqual(\n      expect.arrayContaining([\n        {\n          add: {\n            content: `import * as Types from '@types';\\n`,\n          },\n        },\n        {\n          'typescript-react-apollo': {},\n        },\n      ])\n    );\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { UserFieldsFragmentDoc, UserFieldsFragment } from '@fragments';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should add import to external fragment when its in use (long path)",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1143,
                "column": 72
            },
            "line": 1143,
            "code": "  it('Should add import to external fragment when its in use (long path)', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        {\n          location: '/some/deep/path/src/graphql/nested/down/here/me-query.graphql',\n          document: operationAst,\n        },\n        testDocuments[1],\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { UserFieldsFragmentDoc, UserFieldsFragment } from '../../../user-fragment.generated';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should add import to external fragment when its in use (nested fragment)",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1169,
                "column": 78
            },
            "line": 1169,
            "code": "  it('Should add import to external fragment when its in use (nested fragment)', async () => {\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {},\n      presetConfig: {\n        cwd: '/some/deep/path',\n        baseTypesPath: 'types.ts',\n      },\n      schemaAst: schemaNode,\n      schema: schemaDocumentNode,\n      documents: [\n        testDocuments[0],\n        {\n          location: '/some/deep/path/src/graphql/nested/down/here/user-fragment.graphql',\n          document: fragmentAst,\n        },\n      ],\n      plugins: [{ 'typescript-react-apollo': {} }],\n      pluginMap: { 'typescript-react-apollo': {} as any },\n    });\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { UserFieldsFragmentDoc, UserFieldsFragment } from './nested/down/here/user-fragment.generated';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should import relevant fragments on dedupeFragments",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1195,
                "column": 57
            },
            "line": 1195,
            "code": "  it('Should import relevant fragments on dedupeFragments', async () => {\n    const testSchema = parse(/* GraphQL */ `\n      schema {\n        query: Query\n      }\n\n      type Query {\n        animals: [Animal!]!\n      }\n\n      type Group {\n        id: ID!\n        name: String!\n      }\n      type Animal {\n        id: ID!\n        name: String!\n        group: Group\n      }\n    `);\n\n    const operations = [\n      {\n        location: '/operations/document.graphql',\n        document: parse(/* GraphQL */ `\n          #import \"./fragments/MyAnimalFragment.graphql\"\n\n          query Test {\n            animals {\n              ...MyAnimalFragment\n            }\n          }\n        `),\n      },\n      {\n        location: '/operations/fragments/AnotherGroupFragment.graphql',\n        document: parse(/* GraphQL */ `\n          fragment AnotherGroupFragment on Group {\n            id\n          }\n        `),\n      },\n      {\n        location: '/operations/fragments/MyAnimalFragment.graphql',\n        document: parse(/* GraphQL */ `\n          #import \"./MyGroupFragment.graphql\"\n\n          fragment MyAnimalFragment on Animal {\n            name\n            group {\n              ...MyGroupFragment\n            }\n          }\n        `),\n      },\n      {\n        location: '/operations/fragments/MyGroupFragment.graphql',\n        document: parse(/* GraphQL */ `\n          #import \"./AnotherGroupFragment.graphql\"\n\n          fragment MyGroupFragment on Group {\n            ...AnotherGroupFragment\n            name\n          }\n        `),\n      },\n    ];\n\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {\n        skipTypename: true,\n        dedupeFragments: true,\n        exportFragmentSpreadSubTypes: true,\n      },\n      presetConfig: {\n        extension: '.ts',\n        baseTypesPath: '../types',\n      },\n      schema: testSchema,\n      schemaAst: buildASTSchema(testSchema),\n      documents: operations,\n      plugins: [{ typescript: {} }, { 'typescript-operations': {} }, { 'typed-document-node': {} }],\n      pluginMap: { typescript: {} as any, 'typescript-operations': {} as any, 'typed-document-node': {} as any },\n    });\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { MyGroupFragmentFragmentDoc, MyGroupFragmentFragment } from './fragments/MyGroupFragment';`\n    );\n\n    expect(getFragmentImportsFromResult(result)).toContain(\n      `import { AnotherGroupFragmentFragmentDoc, AnotherGroupFragmentFragment } from './fragments/AnotherGroupFragment';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        },
        {
            "name": "Should import relevant nested fragments on dedupeFragments",
            "suites": [
                "near-operation-file preset",
                "Issues"
            ],
            "updatePoint": {
                "line": 1290,
                "column": 64
            },
            "line": 1290,
            "code": "  it('Should import relevant nested fragments on dedupeFragments', async () => {\n    const schema = parse(/* GraphQL */ `\n      type Address {\n        city: String\n      }\n\n      type Author {\n        address: Address\n      }\n\n      type Book {\n        author: Author\n      }\n\n      type Query {\n        book: Book\n      }\n    `);\n\n    const operations = [\n      {\n        location: '/author.graphql',\n        document: parse(/* GraphQL */ `\n          fragment Address on Address {\n            city\n          }\n\n          fragment Author on Author {\n            address {\n              ...Address\n            }\n          }\n        `),\n      },\n      {\n        location: '/book.graphql',\n        document: parse(/* GraphQL */ `\n          fragment Book on Book {\n            author {\n              ...Author\n            }\n          }\n\n          query Book {\n            book {\n              ...Book\n            }\n          }\n        `),\n      },\n    ];\n\n    const result = await executePreset({\n      baseOutputDir: './src/',\n      config: {\n        dedupeFragments: true,\n      },\n      presetConfig: {\n        extension: '.ts',\n        baseTypesPath: './types',\n      },\n      schema,\n      schemaAst: buildASTSchema(schema),\n      documents: operations,\n      plugins: [{ typescript: {} }, { 'typescript-operations': {} }, { 'typed-document-node': {} }],\n      pluginMap: { typescript: {} as any, 'typescript-operations': {} as any, 'typed-document-node': {} as any },\n    });\n\n    expect(getFragmentImportsFromResult(result, 1)).toContain(\n      `import { AuthorFragmentDoc, AuthorFragment, AddressFragmentDoc, AddressFragment } from './author';`\n    );\n  });",
            "file": "near-operation-file.spec.ts",
            "skipped": false,
            "dir": "packages/presets/near-operation-file/tests"
        }
    ],
    "error": "Exclusive tests detected. `.only` call found in resolve-external-module-and-fn.spec.ts:4\nRemove `.only` to restore test checks"
}