{"repo":"angular-ui/ui-router","url":"https://github.com/angular-ui/ui-router","branch":"master","configs":[{"package":"@uirouter/angularjs","lang":"ts","dir":"test","framework":"jest","pattern":"**/*.{js,ts}"}],"tests":[{"name":"should use the state object to build a default view, when no `views` property is found","suites":["Ng1 StateBuilder"],"updatePoint":{"line":20,"column":92},"line":20,"code":"  it('should use the state object to build a default view, when no `views` property is found', function () {\n    const config = { url: '/foo', templateUrl: '/foo.html', controller: 'FooController', parent: parent };\n    const built = builder.builder('views')(config);\n\n    expect(built.$default).not.toEqual(config);\n    expect(built.$default).toEqual(\n      expect.objectContaining({\n        templateUrl: '/foo.html',\n        controller: 'FooController',\n        resolveAs: '$resolve',\n      })\n    );\n  });","file":"ng1StateBuilderSpec.ts","skipped":false,"dir":"test"},{"name":"It should use the views object to build views, when defined","suites":["Ng1 StateBuilder"],"updatePoint":{"line":34,"column":65},"line":34,"code":"  it('It should use the views object to build views, when defined', function () {\n    const config = { a: { foo: 'bar', controller: 'FooController' } };\n    const builtViews = builder.builder('views')({ parent: parent, views: config });\n    expect(builtViews.a.foo).toEqual(config.a.foo);\n    expect(builtViews.a.controller).toEqual(config.a.controller);\n  });","file":"ng1StateBuilderSpec.ts","skipped":false,"dir":"test"},{"name":"should not allow a view config with both component and template keys","suites":["Ng1 StateBuilder"],"updatePoint":{"line":41,"column":74},"line":41,"code":"  it('should not allow a view config with both component and template keys', inject(function ($injector) {\n    const config = {\n      name: 'foo',\n      url: '/foo',\n      template: '<h1>hey</h1>',\n      controller: 'FooController',\n      parent: parent,\n    };\n    expect(() => builder.builder('views')(config)).not.toThrow();\n    expect(() => builder.builder('views')(extend({ component: 'fooComponent' }, config))).toThrow();\n    expect(() => builder.builder('views')(extend({ componentProvider: () => 'fooComponent' }, config))).toThrow();\n    expect(() => builder.builder('views')(extend({ bindings: {} }, config))).toThrow();\n  }));","file":"ng1StateBuilderSpec.ts","skipped":false,"dir":"test"},{"name":"should replace a resolve: string value with a function that injects the service of the same name","suites":["Ng1 StateBuilder"],"updatePoint":{"line":55,"column":102},"line":55,"code":"  it('should replace a resolve: string value with a function that injects the service of the same name', inject(function (\n    $injector\n  ) {\n    const config = { resolve: { foo: 'bar' } };\n    expect(builder.builder('resolvables')).toBeDefined();\n    const built: Resolvable[] = builder.builder('resolvables')(config);\n    expect(built[0].deps).toEqual(['bar']);\n  }));","file":"ng1StateBuilderSpec.ts","skipped":false,"dir":"test"},{"name":"should throw when creating a resolvable with an unannotated fn and strictDi mode on","suites":["Resolvables system:","strictDi support"],"updatePoint":{"line":251,"column":91},"line":251,"code":"    it('should throw when creating a resolvable with an unannotated fn and strictDi mode on', inject(function (\n      $injector\n    ) {\n      if (supportsStrictDi) {\n        expect(() => {\n          makePath(['P']);\n        }).toThrowError(/strictdi/);\n      }\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"should not throw when creating a resolvable with an annotated fn and strictDi mode on","suites":["Resolvables system:","strictDi support"],"updatePoint":{"line":261,"column":93},"line":261,"code":"    it('should not throw when creating a resolvable with an annotated fn and strictDi mode on', inject(function (\n      $injector\n    ) {\n      if (supportsStrictDi) {\n        expect(() => {\n          makePath(['PAnnotated']);\n        }).not.toThrowError(/strictdi/);\n      }\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"calls injectable functions and returns a promise","suites":["$resolve",".resolve()"],"updatePoint":{"line":292,"column":56},"line":292,"code":"    it('calls injectable functions and returns a promise', function () {\n      const fun: Spy = jasmine.createSpy('fun');\n      fun.and.returnValue(42);\n      const r = $r.resolve({ fun: ['$resolve', fun] });\n      expect(isResolved(r)).toBe(false);\n      tick();\n      expect(resolvedValue(r)).toEqual({ fun: 42 });\n      expect(fun).toHaveBeenCalled();\n      expect(fun.calls.count()).toBe(1);\n      expect(fun.calls.mostRecent().args.length).toBe(1);\n      expect(fun.calls.mostRecent().args[0]).toBe($r);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"resolves promises returned from the functions","suites":["$resolve",".resolve()"],"updatePoint":{"line":305,"column":53},"line":305,"code":"    it('resolves promises returned from the functions', inject(function ($q) {\n      const d = $q.defer();\n      const fun = jasmine.createSpy('fun').and.returnValue(d.promise);\n      const r = $r.resolve({ fun: ['$resolve', fun] });\n      tick();\n      expect(isResolved(r)).toBe(false);\n      d.resolve('async');\n      tick();\n      expect(resolvedValue(r)).toEqual({ fun: 'async' });\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"resolves dependencies between functions","suites":["$resolve",".resolve()"],"updatePoint":{"line":316,"column":47},"line":316,"code":"    it('resolves dependencies between functions', function () {\n      const a = jasmine.createSpy('a');\n      const b = jasmine.createSpy('b').and.returnValue('bb');\n      const r = $r.resolve({ a: ['b', a], b: [b] });\n      tick();\n      expect(a).toHaveBeenCalled();\n      expect(a.calls.mostRecent().args).toEqual(['bb']);\n      expect(b).toHaveBeenCalled();\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"resolves dependencies between functions that return promises","suites":["$resolve",".resolve()"],"updatePoint":{"line":326,"column":68},"line":326,"code":"    it('resolves dependencies between functions that return promises', inject(function ($q) {\n      const ad = $q.defer(),\n        a = jasmine.createSpy('a');\n      a.and.returnValue(ad.promise);\n      const bd = $q.defer(),\n        b = jasmine.createSpy('b');\n      b.and.returnValue(bd.promise);\n      const cd = $q.defer(),\n        c = jasmine.createSpy('c');\n      c.and.returnValue(cd.promise);\n\n      const r = $r.resolve({ a: ['b', 'c', a], b: ['c', b], c: [c] });\n      tick();\n      expect(isResolved(r)).toBe(false);\n      expect(a).not.toHaveBeenCalled();\n      expect(b).not.toHaveBeenCalled();\n      expect(c).toHaveBeenCalled();\n      cd.resolve('cc');\n      tick();\n      expect(isResolved(r)).toBe(false);\n      expect(a).not.toHaveBeenCalled();\n      expect(b).toHaveBeenCalled();\n      expect(b.calls.mostRecent().args).toEqual(['cc']);\n      bd.resolve('bb');\n      tick();\n      expect(isResolved(r)).toBe(false);\n      expect(a).toHaveBeenCalled();\n      expect(a.calls.mostRecent().args).toEqual(['bb', 'cc']);\n      ad.resolve('aa');\n      tick();\n      expect(resolvedValue(r)).toEqual({ a: 'aa', b: 'bb', c: 'cc' });\n      expect(a.calls.count()).toBe(1);\n      expect(b.calls.count()).toBe(1);\n      expect(c.calls.count()).toBe(1);\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allows a function to depend on an injector value of the same name","suites":["$resolve",".resolve()"],"updatePoint":{"line":375,"column":73},"line":375,"code":"    it('allows a function to depend on an injector value of the same name', function () {\n      const r = $r.resolve({\n        $resolve: function ($resolve) {\n          return $resolve === $r;\n        },\n      });\n      tick();\n      expect(resolvedValue(r)).toEqual({ $resolve: true });\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allows locals to be passed that override the injector","suites":["$resolve",".resolve()"],"updatePoint":{"line":385,"column":61},"line":385,"code":"    it('allows locals to be passed that override the injector', function () {\n      const fun = jasmine.createSpy('fun');\n      $r.resolve({ fun: ['$resolve', fun] }, { $resolve: 42 });\n      tick();\n      expect(fun).toHaveBeenCalled();\n      expect(fun.calls.mostRecent().args[0]).toBe(42);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"does not call injectables overridden by a local","suites":["$resolve",".resolve()"],"updatePoint":{"line":393,"column":55},"line":393,"code":"    it('does not call injectables overridden by a local', function () {\n      const fun = jasmine.createSpy('fun').and.returnValue('function');\n      const r = $r.resolve({ fun: [fun] }, { fun: 'local' });\n      tick();\n      expect(fun).not.toHaveBeenCalled();\n      expect(resolvedValue(r)).toEqual({ fun: 'local' });\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"includes locals in the returned values","suites":["$resolve",".resolve()"],"updatePoint":{"line":401,"column":46},"line":401,"code":"    it('includes locals in the returned values', function () {\n      const locals = { foo: 'hi', bar: 'mom' };\n      const r = $r.resolve({}, locals);\n      tick();\n      expect(resolvedValue(r)).toEqual(locals);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allows inheritance from a parent resolve()","suites":["$resolve",".resolve()"],"updatePoint":{"line":408,"column":50},"line":408,"code":"    it('allows inheritance from a parent resolve()', function () {\n      const r = $r.resolve({\n        fun: function () {\n          return true;\n        },\n      });\n      const s = $r.resolve(\n        {\n          games: function () {\n            return true;\n          },\n        },\n        {},\n        r\n      );\n      tick();\n      expect(isResolved(r)).toBe(true);\n      expect(resolvedValue(s)).toEqual({ fun: true, games: true });\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"resolves dependencies from a parent resolve()","suites":["$resolve",".resolve()"],"updatePoint":{"line":428,"column":53},"line":428,"code":"    it('resolves dependencies from a parent resolve()', function () {\n      const r = $r.resolve({\n        a: [\n          function () {\n            return 'aa';\n          },\n        ],\n      });\n      const b = jasmine.createSpy('b');\n      const s = $r.resolve({ b: ['a', b] }, {}, r);\n      tick();\n      expect(b).toHaveBeenCalled();\n      expect(b.calls.mostRecent().args).toEqual(['aa']);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allow access to ancestor resolves in descendent resolve blocks","suites":["$resolve",".resolve()"],"updatePoint":{"line":443,"column":70},"line":443,"code":"    it('allow access to ancestor resolves in descendent resolve blocks', inject(function ($q) {\n      const gPromise = $q.defer(),\n        gInjectable = jasmine.createSpy('gInjectable').and.returnValue(gPromise.promise),\n        pPromise = $q.defer(),\n        pInjectable = jasmine.createSpy('pInjectable').and.returnValue(pPromise.promise);\n\n      const g = $r.resolve({ gP: [gInjectable] });\n\n      gPromise.resolve('grandparent');\n      tick();\n\n      const s = jasmine.createSpy('s');\n      const p = $r.resolve({ p: [pInjectable] }, {}, g);\n      const c = $r.resolve({ c: ['p', 'gP', s] }, {}, p);\n\n      pPromise.resolve('parent');\n      tick();\n\n      expect(s).toHaveBeenCalled();\n      expect(s.calls.mostRecent().args).toEqual(['parent', 'grandparent']);\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allow parent resolve to override grandparent resolve","suites":["$resolve",".resolve()"],"updatePoint":{"line":466,"column":60},"line":466,"code":"    it('allow parent resolve to override grandparent resolve', inject(function ($q) {\n      const gPromise = $q.defer(),\n        gInjectable = jasmine.createSpy('gInjectable').and.returnValue(gPromise.promise);\n\n      const g = $r.resolve({\n        item: [\n          function () {\n            return 'grandparent';\n          },\n        ],\n      });\n      gPromise.resolve('grandparent');\n      tick();\n\n      const p = $r.resolve(\n        {\n          item: [\n            function () {\n              return 'parent';\n            },\n          ],\n        },\n        {},\n        g\n      );\n      const s = jasmine.createSpy('s');\n      const c = $r.resolve({ c: [s] }, {}, p);\n      let item;\n      c.then(function (vals) {\n        item = vals.item;\n      });\n      tick();\n\n      expect(s).toHaveBeenCalled();\n      expect(item).toBe('parent');\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allows a function to override a parent value of the same name","suites":["$resolve",".resolve()"],"updatePoint":{"line":503,"column":69},"line":503,"code":"    it('allows a function to override a parent value of the same name', function () {\n      const r = $r.resolve({\n        b: function () {\n          return 'B';\n        },\n      });\n      const s = $r.resolve(\n        {\n          a: function (b) {\n            return 'a:' + b;\n          },\n          b: function (b) {\n            return '(' + b + ')';\n          },\n          c: function (b) {\n            return 'c:' + b;\n          },\n        },\n        {},\n        r\n      );\n      tick();\n      expect(resolvedValue(s)).toEqual({ a: 'a:(B)', b: '(B)', c: 'c:(B)' });\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"allows a function to override a parent value of the same name with a promise","suites":["$resolve",".resolve()"],"updatePoint":{"line":528,"column":84},"line":528,"code":"    it('allows a function to override a parent value of the same name with a promise', inject(function ($q) {\n      const r = $r.resolve({\n        b: function () {\n          return 'B';\n        },\n      });\n      let superb,\n        bd = $q.defer();\n      const s = $r.resolve(\n        {\n          a: function (b) {\n            return 'a:' + b;\n          },\n          b: function (b) {\n            superb = b;\n            return bd.promise;\n          },\n          c: function (b) {\n            return 'c:' + b;\n          },\n        },\n        {},\n        r\n      );\n      tick();\n      bd.resolve('(' + superb + ')');\n      tick();\n      expect(resolvedValue(s)).toEqual({ a: 'a:(B)', b: '(B)', c: 'c:(B)' });\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"it only resolves after the parent resolves","suites":["$resolve",".resolve()"],"updatePoint":{"line":558,"column":50},"line":558,"code":"    it('it only resolves after the parent resolves', inject(function ($q) {\n      const bd = $q.defer(),\n        b = jasmine.createSpy('b').and.returnValue(bd.promise);\n      const cd = $q.defer(),\n        c = jasmine.createSpy('c').and.returnValue(cd.promise);\n      const r = $r.resolve({ c: [c] });\n      const s = $r.resolve({ b: [b] }, {}, r);\n      bd.resolve('bbb');\n      tick();\n      expect(isResolved(r)).toBe(false);\n      expect(isResolved(s)).toBe(false);\n      cd.resolve('ccc');\n      tick();\n      expect(resolvedValue(r)).toEqual({ c: 'ccc' });\n      expect(resolvedValue(s)).toEqual({ b: 'bbb', c: 'ccc' });\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"rejects missing dependencies but does not fail synchronously","suites":["$resolve",".resolve()"],"updatePoint":{"line":575,"column":68},"line":575,"code":"    it('rejects missing dependencies but does not fail synchronously', function () {\n      const r = $r.resolve({ fun: function (invalid) {} });\n      expect(isResolved(r)).toBe(false);\n      tick();\n      expect(resolvedError(r).toString()).toMatch(/unknown provider/i);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"propagates exceptions thrown by the functions as a rejection","suites":["$resolve",".resolve()"],"updatePoint":{"line":582,"column":68},"line":582,"code":"    it('propagates exceptions thrown by the functions as a rejection', function () {\n      const r = $r.resolve({\n        fun: function () {\n          throw 'i want cake';\n        },\n      });\n      expect(isResolved(r)).toBe(false);\n      tick();\n      expect(resolvedError(r)).toBe('i want cake');\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"propagates errors from a parent resolve","suites":["$resolve",".resolve()"],"updatePoint":{"line":593,"column":47},"line":593,"code":"    it('propagates errors from a parent resolve', function () {\n      const error = ['the cake is a lie'];\n      const r = $r.resolve({\n        foo: function () {\n          throw error;\n        },\n      });\n      const s = $r.resolve(\n        {\n          bar: function () {\n            42;\n          },\n        },\n        r\n      );\n      tick();\n      expect(resolvedError(r)).toBe(error);\n      expect(resolvedError(s)).toBe(error);\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"does not invoke any functions if the parent resolve has already failed","suites":["$resolve",".resolve()"],"updatePoint":{"line":613,"column":78},"line":613,"code":"    it('does not invoke any functions if the parent resolve has already failed', function () {\n      const r = $r.resolve({\n        foo: function () {\n          throw 'oops';\n        },\n      });\n      tick();\n      expect(isResolved(r)).toBe(true);\n      const a = jasmine.createSpy('a');\n      const s = $r.resolve({ a: [a] }, {}, r);\n      tick();\n      expect(resolvedError(s)).toBeDefined();\n      expect(a).not.toHaveBeenCalled();\n    });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"does not invoke any more functions after a parent failure","suites":["$resolve",".resolve()"],"updatePoint":{"line":645,"column":65},"line":645,"code":"    it('does not invoke any more functions after a parent failure', inject(function ($q) {\n      const ad = $q.defer(),\n        a = jasmine.createSpy('a').and.returnValue(ad.promise);\n      const cd = $q.defer(),\n        c = jasmine.createSpy('c').and.returnValue(cd.promise);\n      const dd = $q.defer(),\n        d = jasmine.createSpy('d').and.returnValue(dd.promise);\n      const r = $r.resolve({ c: [c], d: [d] });\n      const s = $r.resolve({ a: ['c', a] }, r);\n      dd.reject('dontlikeit');\n      tick();\n      expect(resolvedError(r)).toBeDefined();\n      expect(resolvedError(s)).toBeDefined();\n      cd.resolve('ccc');\n      tick();\n      expect(a).not.toHaveBeenCalled();\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"should not re-resolve data, when redirecting to a child","suites":["Integration: Resolvables system"],"updatePoint":{"line":709,"column":61},"line":709,"code":"  it('should not re-resolve data, when redirecting to a child', () => {\n    $transitions.onStart({ to: 'J' }, ($transition$) => {\n      const ctx = new ResolveContext($transition$.treeChanges().to);\n      return invokeLater(function (_J) {}, ctx).then(function () {\n        expect(counts._J).toEqual(1);\n        return $state.target('K');\n      });\n    });\n    $state.go('J');\n    $rootScope.$digest();\n    expect($state.current.name).toBe('K');\n    expect(counts._J).toEqual(1);\n  });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"should not inject child data into parent","suites":["Integration: Resolvables system"],"updatePoint":{"line":724,"column":46},"line":724,"code":"  it('should not inject child data into parent', () => {\n    let injectedData;\n    router.stateRegistry.register({\n      name: 'foo',\n      resolve: {\n        myresolve: () => 'foodata',\n      },\n      onEnter: (myresolve) => (injectedData = myresolve),\n    });\n\n    router.stateRegistry.register({\n      name: 'foo.bar',\n      resolve: {\n        myresolve: () => 'bardata',\n      },\n    });\n\n    $state.go('foo.bar');\n    $rootScope.$digest();\n\n    expect($state.current.name).toBe('foo.bar');\n    expect(injectedData).toBe('foodata');\n  });","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"should inject a promise for NOWAIT resolve into a controller","suites":["Integration: Resolvables system"],"updatePoint":{"line":748,"column":66},"line":748,"code":"  it('should inject a promise for NOWAIT resolve into a controller', inject(function ($compile, $rootScope) {\n    const scope = $rootScope.$new();\n    const el = $compile('<div><ui-view></ui-view></div>')(scope);\n\n    const deferWait = $q.defer();\n    const deferNowait = $q.defer();\n    let onEnterNowait;\n\n    router.stateProvider.state({\n      name: 'policies',\n      resolve: [\n        { token: 'nowait', resolveFn: () => deferNowait.promise, policy: { async: 'NOWAIT' } },\n        { token: 'wait', resolveFn: () => deferWait.promise },\n      ],\n      onEnter: function (nowait) {\n        onEnterNowait = nowait;\n      },\n      controller: function ($scope, wait, nowait) {\n        $scope.wait = wait;\n        nowait.then((result) => ($scope.nowait = result));\n      },\n      template: '{{ wait }}-{{ nowait }}',\n    });\n\n    $state.go('policies');\n    $q.flush();\n\n    expect($state.current.name).toBe('');\n\n    deferWait.resolve('wait for this');\n    $q.flush();\n\n    expect($state.current.name).toBe('policies');\n    expect(el.text()).toBe('wait for this-');\n    expect(typeof onEnterNowait.then).toBe('function');\n\n    deferNowait.resolve('dont wait for this');\n    $q.flush();\n\n    expect(el.text()).toBe('wait for this-dont wait for this');\n  }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"should bind a promise for NOWAIT resolve onto a component controller","suites":["Integration: Resolvables system"],"updatePoint":{"line":791,"column":76},"line":791,"code":"    it('should bind a promise for NOWAIT resolve onto a component controller', inject(function ($compile, $rootScope) {\n      const scope = $rootScope.$new();\n      const el = $compile('<div><ui-view></ui-view></div>')(scope);\n\n      const deferWait = $q.defer();\n      const deferNowait = $q.defer();\n\n      router.stateProvider.state({\n        name: 'policies',\n        resolve: [\n          { token: 'nowait', resolveFn: () => deferNowait.promise, policy: { async: 'NOWAIT' } },\n          { token: 'wait', resolveFn: () => deferWait.promise },\n        ],\n        component: 'nowait',\n      });\n\n      $state.go('policies');\n      $q.flush();\n\n      expect($state.current.name).toBe('');\n\n      deferWait.resolve('wait for this');\n      $q.flush();\n\n      expect($state.current.name).toBe('policies');\n      expect(el.text()).toBe('wait for this-');\n\n      deferNowait.resolve('dont wait for this');\n      $q.flush();\n\n      expect(el.text()).toBe('wait for this-dont wait for this');\n    }));","file":"resolveSpec.ts","skipped":false,"dir":"test"},{"name":"Should expose ui-router providers from the UIRouter instance","suites":["UI-Router services"],"updatePoint":{"line":68,"column":66},"line":68,"code":"  it('Should expose ui-router providers from the UIRouter instance', () => {\n    expect(providers.$urlMatcherFactoryProvider).toBe($uiRouterProvider.urlMatcherFactory);\n    expect(providers.$urlRouterProvider).toBe($uiRouterProvider.urlRouterProvider);\n    expect(providers.$stateRegistryProvider).toBe($uiRouterProvider.stateRegistry);\n    expect(providers.$uiRouterGlobalsProvider).toBe($uiRouterProvider.globals);\n    expect(providers.$transitionsProvider).toBe($uiRouterProvider.transitionService);\n    expect(providers.$stateProvider).toBe($uiRouterProvider.stateProvider);\n  });","file":"servicesSpec.ts","skipped":false,"dir":"test"},{"name":"Should expose ui-router services from the UIRouter instance","suites":["UI-Router services"],"updatePoint":{"line":77,"column":65},"line":77,"code":"  it('Should expose ui-router services from the UIRouter instance', () => {\n    expect($uiRouter).toBe($uiRouterProvider);\n    expect(services.$urlMatcherFactory).toBe($uiRouter.urlMatcherFactory);\n    expect(services.$urlRouter).toBe($uiRouter.urlRouter);\n    expect(services.$stateRegistry).toBe($uiRouter.stateRegistry);\n    expect(services.$uiRouterGlobals).toBe($uiRouter.globals);\n    expect(services.$transitions).toBe($uiRouter.transitionService);\n    expect(services.$state).toBe($uiRouter.stateService);\n    expect(services.$stateParams).toBe($uiRouter.globals.params);\n    expect(services.$templateFactory.constructor.name).toBe('TemplateFactory');\n    expect(services.$view).toBe($uiRouter.viewService);\n    expect(services.$trace).toBe(trace);\n  });","file":"servicesSpec.ts","skipped":false,"dir":"test"},{"name":"should update the href when promises on parameters change before scope is applied","suites":["uiStateRef","links with promises"],"updatePoint":{"line":104,"column":89},"line":104,"code":"    it('should update the href when promises on parameters change before scope is applied', inject(function (\n      $rootScope,\n      $compile,\n      $q\n    ) {\n      const defer = $q.defer();\n      el = angular.element('<a ui-sref=\"contacts.item.detail({ id: contact.id })\">Details</a>');\n\n      $rootScope.contact = defer.promise;\n      defer.resolve({ id: 6 });\n\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      // HACK: Promises no longer auto-unwrap in 1.2.x+\n      if ($rootScope.contact.$$resolved && $rootScope.contact.$$resolved.value) {\n        $rootScope.contact = $rootScope.contact.$$resolved.value;\n        $rootScope.$digest();\n      }\n\n      expect(el.attr('href')).toBe('#/contacts/6');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should generate the correct href","suites":["uiStateRef","links"],"updatePoint":{"line":143,"column":40},"line":143,"code":"    it('should generate the correct href', function () {\n      expect(el.attr('href')).toBe('#/contacts/5');\n      expect(el2.attr('href')).toBe('#');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update the href when parameters change","suites":["uiStateRef","links"],"updatePoint":{"line":148,"column":53},"line":148,"code":"    it('should update the href when parameters change', function () {\n      expect(el.attr('href')).toBe('#/contacts/5');\n      scope.contact.id = 6;\n      scope.$apply();\n      expect(el.attr('href')).toBe('#/contacts/6');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should allow multi-line attribute values","suites":["uiStateRef","links"],"updatePoint":{"line":155,"column":48},"line":155,"code":"    it('should allow multi-line attribute values', inject(function ($compile, $rootScope) {\n      el = angular.element('<a ui-sref=\"contacts.item.detail({\\n\\tid: $index\\n})\">Details</a>');\n      $rootScope.$index = 3;\n      $rootScope.$apply();\n\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n      expect(el.attr('href')).toBe('#/contacts/3');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should transition states when left-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":165,"column":50},"line":165,"code":"    it('should transition states when left-clicked', inject(function ($state, $stateParams, $q) {\n      expect($state.$current.name).toEqual('top');\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toEqual('contacts.item.detail');\n      expect(obj($stateParams)).toEqual({ id: 5 });\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should transition when given a click that contains no data (fake-click)","suites":["uiStateRef","links"],"updatePoint":{"line":177,"column":81},"line":177,"code":"      it('should transition when given a click that contains no data (fake-click)', inject(function (\n        $state,\n        $stateParams,\n        $q\n      ) {\n        expect($state.current.name).toEqual('top');\n\n        triggerClick(el, {\n          metaKey: undefined,\n          ctrlKey: undefined,\n          shiftKey: undefined,\n          altKey: undefined,\n          button: undefined,\n        });\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('contacts.item.detail');\n        expect(obj($stateParams)).toEqual({ id: 5 });\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when ctrl-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":198,"column":56},"line":198,"code":"      it('should not transition states when ctrl-clicked', inject(function ($state, $stateParams, $q) {\n        expect($state.$current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n\n        triggerClick(el, { ctrlKey: true });\n\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when meta-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":211,"column":56},"line":211,"code":"      it('should not transition states when meta-clicked', inject(function ($state, $stateParams, $q) {\n        expect($state.$current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n\n        triggerClick(el, { metaKey: true });\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when shift-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":223,"column":57},"line":223,"code":"      it('should not transition states when shift-clicked', inject(function ($state, $stateParams, $q) {\n        expect($state.$current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n\n        triggerClick(el, { shiftKey: true });\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when alt-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":235,"column":55},"line":235,"code":"      it('should not transition states when alt-clicked', inject(function ($state, $stateParams, $q) {\n        expect($state.$current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n\n        triggerClick(el, { altKey: true });\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when middle-clicked","suites":["uiStateRef","links"],"updatePoint":{"line":247,"column":58},"line":247,"code":"      it('should not transition states when middle-clicked', inject(function ($state, $stateParams, $q) {\n        expect($state.$current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n\n        triggerClick(el, { button: 1 });\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states when element has target specified","suites":["uiStateRef","links"],"updatePoint":{"line":259,"column":72},"line":259,"code":"      it('should not transition states when element has target specified', inject(function ($state, $stateParams, $q) {\n        el.attr('target', '_blank');\n        expect($state.$current.name).toEqual('top');\n\n        triggerClick(el);\n        timeoutFlush();\n        $q.flush();\n\n        expect($state.current.name).toEqual('top');\n        expect(obj($stateParams)).toEqual({});\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition states if preventDefault() is called in click handler","suites":["uiStateRef","links"],"updatePoint":{"line":272,"column":83},"line":272,"code":"    it('should not transition states if preventDefault() is called in click handler', inject(function (\n      $state,\n      $stateParams,\n      $q\n    ) {\n      expect($state.$current.name).toEqual('top');\n      expect(obj($stateParams)).toEqual({});\n\n      el.bind('click', function (e) {\n        e.preventDefault();\n      });\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toEqual('top');\n      expect(obj($stateParams)).toEqual({});\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should allow passing params to current state","suites":["uiStateRef","links"],"updatePoint":{"line":293,"column":52},"line":293,"code":"    it('should allow passing params to current state', inject(function ($compile, $rootScope, $state, $q) {\n      $state.go('other', { id: 'abc' });\n      $rootScope.$index = 'def';\n      $rootScope.$digest();\n\n      el = angular.element('<a ui-sref=\"{id: $index}\">Details</a>');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toBe('other');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'abc' }));\n      expect(el.attr('href')).toBe('#/other/def');\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toBe('other');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'def' }));\n\n      $rootScope.$index = 'ghi';\n      $state.go('other.detail');\n      $rootScope.$digest();\n\n      expect($state.current.name).toBe('other.detail');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'def' }));\n\n      expect(el.attr('href')).toBe('#/other/ghi/detail');\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toBe('other.detail');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'ghi' }));\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should allow multi-line attribute values when passing params to current state","suites":["uiStateRef","links"],"updatePoint":{"line":330,"column":85},"line":330,"code":"    it('should allow multi-line attribute values when passing params to current state', inject(function (\n      $compile,\n      $rootScope,\n      $state\n    ) {\n      $state.go('contacts.item.detail', { id: '123' });\n      $rootScope.$digest();\n\n      el = angular.element('<a ui-sref=\"{\\n\\tid: $index\\n}\">Details</a>');\n      $rootScope.$index = 3;\n      $rootScope.$apply();\n\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n      expect(el.attr('href')).toBe('#/contacts/3');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should take an object as a parameter and update properly on digest churns","suites":["uiStateRef","links"],"updatePoint":{"line":347,"column":81},"line":347,"code":"    it('should take an object as a parameter and update properly on digest churns', inject(function (\n      $rootScope,\n      $q,\n      $compile,\n      $state\n    ) {\n      el = angular.element('<div><a ui-sref=\"contacts.item.detail(urlParams)\">Contacts</a></div>');\n      template = $compile(el)($rootScope);\n\n      $rootScope.urlParams = { id: 1 };\n      $rootScope.$digest();\n      expect(angular.element(template[0].querySelector('a')).attr('href')).toBe('#/contacts/1');\n\n      $rootScope.urlParams.id = 2;\n      $rootScope.$digest();\n      expect(angular.element(template[0].querySelector('a')).attr('href')).toBe('#/contacts/2');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should generate the correct href","suites":["uiStateRef","links in html5 mode"],"updatePoint":{"line":373,"column":40},"line":373,"code":"    it('should generate the correct href', function () {\n      expect(el.attr('href')).toBe('/contacts/5');\n      expect(el2.attr('href')).toBe('');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update the href when parameters change","suites":["uiStateRef","links in html5 mode"],"updatePoint":{"line":378,"column":53},"line":378,"code":"    it('should update the href when parameters change', function () {\n      expect(el.attr('href')).toBe('/contacts/5');\n      scope.contact.id = 6;\n      scope.$apply();\n      expect(el.attr('href')).toBe('/contacts/6');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should transition states when the url is empty","suites":["uiStateRef","links in html5 mode"],"updatePoint":{"line":385,"column":54},"line":385,"code":"    it('should transition states when the url is empty', inject(function ($state, $stateParams, $q) {\n      // Odd, in html5Mode, the initial state isn't matching on empty url, but does match if top.url is \"/\".\n      //      expect($state.$current.name).toEqual('top');\n\n      triggerClick(el2);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toEqual('top');\n      expect(obj($stateParams)).toEqual({});\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"sets the correct initial href","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":412,"column":37},"line":412,"code":"    it('sets the correct initial href', function () {\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"updates to the new href","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":416,"column":31},"line":416,"code":"    it('updates to the new href', function () {\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts');\n\n      scope.state = 'contacts.item';\n      scope.params = { id: 5 };\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/5');\n\n      scope.params.id = 25;\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/25');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"updates a linked ui-sref-active","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":429,"column":39},"line":429,"code":"    it('updates a linked ui-sref-active', inject(function ($timeout) {\n      function tick() {\n        scope.$digest();\n        try {\n          $timeout.flush();\n        } catch (error) {}\n      }\n      expect(template[0].className).not.toContain('active');\n      expect(template[0].className).not.toContain('activeeq');\n\n      $state.go('contacts');\n      tick();\n      expect(template[0].className).toContain('active activeeq');\n\n      scope.state = 'contacts.item';\n      scope.params = { id: 5 };\n      tick();\n      expect(template[0].className).not.toContain('active');\n      expect(template[0].className).not.toContain('activeeq');\n\n      $state.go('contacts.item', { id: -5 });\n      tick();\n      expect(template[0].className).not.toContain('active');\n      expect(template[0].className).not.toContain('activeeq');\n\n      $state.go('contacts.item', { id: 5 });\n      tick();\n      expect(template[0].className).toContain('active activeeq');\n\n      scope.state = 'contacts';\n      scope.params = {};\n      tick();\n      expect(template[0].className).toContain('active');\n      expect(template[0].className).not.toContain('activeeq');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"updates to a new href when it points to a new state","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":465,"column":59},"line":465,"code":"    it('updates to a new href when it points to a new state', function () {\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts');\n      scope.state = 'other';\n      scope.params = { id: '123' };\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/other/123');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should allow passing params to current state using empty ui-state","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":474,"column":73},"line":474,"code":"    it('should allow passing params to current state using empty ui-state', inject(function (\n      $compile,\n      $rootScope,\n      $state,\n      $q\n    ) {\n      $state.go('other', { id: 'abc' });\n      $rootScope.$index = 'def';\n      $rootScope.$digest();\n\n      el = angular.element('<a ui-state=\"\" ui-state-params=\"{id: $index}\">Details</a>');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toBe('other');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'abc' }));\n      expect(el.attr('href')).toBe('#/other/def');\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toBe('other');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'def' }));\n\n      $rootScope.$index = 'ghi';\n      $state.go('other.detail');\n      $rootScope.$digest();\n\n      expect($state.current.name).toBe('other.detail');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'def' }));\n\n      expect(el.attr('href')).toBe('#/other/ghi/detail');\n\n      triggerClick(el);\n      timeoutFlush();\n      $q.flush();\n\n      expect($state.current.name).toBe('other.detail');\n      expect($state.params).toEqual(expect.objectContaining({ id: 'ghi' }));\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"retains the old href if the new points to a non-state","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":516,"column":61},"line":516,"code":"    it('retains the old href if the new points to a non-state', function () {\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts');\n      scope.state = 'nostate';\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"accepts param overrides","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":523,"column":31},"line":523,"code":"    it('accepts param overrides', inject(function ($compile) {\n      scope.state = 'contacts.item';\n      scope.params = { id: 10 };\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/10');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"accepts param overrides","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":530,"column":31},"line":530,"code":"    it('accepts param overrides', inject(function ($compile) {\n      scope.state = 'contacts.item';\n      scope.params = { id: 10 };\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/10');\n\n      scope.params.id = 22;\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/22');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"watches attributes","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":541,"column":26},"line":541,"code":"    it('watches attributes', inject(function ($compile) {\n      el = angular.element('<a ui-state=\"{{exprvar}}\" ui-state-params=\"params\">state</a>');\n      template = $compile(el)(scope);\n\n      scope.exprvar = 'state1';\n      scope.state1 = 'contacts.item';\n      scope.state2 = 'other';\n      scope.params = { id: 10 };\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/contacts/10');\n\n      scope.exprvar = 'state2';\n      scope.$digest();\n      expect(angular.element(template[0]).attr('href')).toBe('#/other/10');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"allows one-time-binding on ng1.3+","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":558,"column":43},"line":558,"code":"      it('allows one-time-binding on ng1.3+', inject(function ($compile) {\n        el = angular.element('<a ui-state=\"::state\" ui-state-params=\"::params\">state</a>');\n\n        scope.state = 'contacts.item';\n        scope.params = { id: 10 };\n        template = $compile(el)(scope);\n        scope.$digest();\n        expect(angular.element(template[0]).attr('href')).toBe('#/contacts/10');\n\n        scope.state = 'other';\n        scope.params = { id: 22 };\n\n        scope.$digest();\n        expect(angular.element(template[0]).attr('href')).toBe('#/contacts/10');\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"accepts option overrides","suites":["uiStateRef","links with dynamic state definitions"],"updatePoint":{"line":575,"column":32},"line":575,"code":"    it('accepts option overrides', inject(function ($compile, $timeout, $state) {\n      let transitionOptions;\n\n      el = angular.element('<a ui-state=\"state\" ui-state-opts=\"opts\">state</a>');\n      scope.state = 'contacts';\n      scope.opts = { reload: true };\n      template = $compile(el)(scope);\n      scope.$digest();\n\n      spyOn($state, 'go').and.callFake(function (state, params, options) {\n        transitionOptions = options;\n      });\n\n      triggerClick(template);\n      $timeout.flush();\n\n      expect(transitionOptions.reload).toEqual(true);\n      expect(transitionOptions.absolute).toBeUndefined();\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind click event by default","suites":["uiStateRef","links with dynamic state definitions","option event"],"updatePoint":{"line":596,"column":44},"line":596,"code":"      it('should bind click event by default', inject(function ($compile, $state, $timeout) {\n        expect($state.current.name).toBe('top');\n\n        el = angular.element('<a ui-state=\"state\"></a>');\n\n        scope.state = 'contacts';\n        $compile(el)(scope);\n        scope.$digest();\n\n        triggerClick(el);\n        $timeout.flush();\n\n        expect($state.current.name).toBe('contacts');\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind single HTML events","suites":["uiStateRef","links with dynamic state definitions","option event"],"updatePoint":{"line":611,"column":40},"line":611,"code":"      it('should bind single HTML events', inject(function ($compile, $state, $timeout) {\n        expect($state.current.name).toEqual('top');\n\n        el = angular.element('<input type=\"text\" ui-state=\"state\" ui-state-opts=\"{ events: [\\'change\\'] }\">');\n\n        scope.state = 'contacts';\n        $compile(el)(scope);\n        scope.$digest();\n\n        triggerHTMLEvent('change');\n        $timeout.flush();\n\n        expect($state.current.name).toEqual('contacts');\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind multiple HTML events","suites":["uiStateRef","links with dynamic state definitions","option event"],"updatePoint":{"line":626,"column":42},"line":626,"code":"      it('should bind multiple HTML events', inject(function ($compile, $state, $timeout) {\n        expect($state.current.name).toEqual('top');\n\n        el = angular.element('<input type=\"text\" ui-state=\"state\" ui-state-opts=\"{ events: [\\'change\\', \\'blur\\'] }\">');\n\n        scope.state = 'contacts';\n        $compile(el)(scope);\n        scope.$digest();\n\n        triggerHTMLEvent('change');\n        $timeout.flush();\n        expect($state.current.name).toEqual('contacts');\n\n        $state.go('top');\n        scope.$digest();\n\n        expect($state.current.name).toEqual('top');\n\n        triggerHTMLEvent('blur');\n        $timeout.flush();\n        expect($state.current.name).toEqual('contacts');\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind multiple Mouse events","suites":["uiStateRef","links with dynamic state definitions","option event"],"updatePoint":{"line":649,"column":43},"line":649,"code":"      it('should bind multiple Mouse events', inject(function ($compile, $state, $timeout) {\n        expect($state.current.name).toEqual('top');\n\n        el = angular.element('<a ui-state=\"state\" ui-state-opts=\"{ events: [\\'mouseover\\', \\'mousedown\\'] }\">');\n\n        scope.state = 'contacts';\n        $compile(el)(scope);\n        scope.$digest();\n\n        triggerMouseEvent('mouseover');\n        $timeout.flush();\n        expect($state.current.name).toEqual('contacts');\n\n        $state.go('top');\n        scope.$digest();\n\n        expect($state.current.name).toEqual('top');\n\n        triggerMouseEvent('mousedown');\n        $timeout.flush();\n        expect($state.current.name).toEqual('contacts');\n      }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should generate the correct action","suites":["uiStateRef","forms"],"updatePoint":{"line":687,"column":42},"line":687,"code":"    it('should generate the correct action', function () {\n      expect(el.attr('action')).toBe('#/contacts/5');\n    });","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should work","suites":["uiStateRef","relative transitions"],"updatePoint":{"line":704,"column":19},"line":704,"code":"    it('should work', inject(function ($state, $stateParams, $q, $timeout) {\n      triggerClick(el);\n      $timeout.flush();\n      $q.flush();\n\n      expect($state.$current.name).toBe('contacts.item.detail');\n      expect(obj($state.params)).toEqual({ id: 5 });\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should resolve states from parent uiView","suites":["uiStateRef","relative transitions"],"updatePoint":{"line":713,"column":48},"line":713,"code":"    it('should resolve states from parent uiView', inject(function ($state, $stateParams, $q, $timeout) {\n      $state.transitionTo('contacts');\n      $q.flush();\n\n      const parentToChild = angular.element(template[0].querySelector('a.item'));\n      triggerClick(parentToChild);\n      $timeout.flush();\n      $q.flush();\n      expect($state.$current.name).toBe('contacts.item');\n\n      const childToGrandchild = angular.element(template[0].querySelector('a.item-detail'));\n      const childToParent = angular.element(template[0].querySelector('a.item-parent'));\n\n      triggerClick(childToGrandchild);\n      $timeout.flush();\n      $q.flush();\n\n      const grandchildToParent = angular.element(template[0].querySelector('a.item-parent2'));\n      expect($state.$current.name).toBe('contacts.item.detail');\n\n      triggerClick(grandchildToParent);\n      $timeout.flush();\n      $q.flush();\n      expect($state.$current.name).toBe('contacts.item');\n\n      $state.transitionTo('contacts.item.detail', { id: 3 });\n      triggerClick(childToParent);\n      $timeout.flush();\n      $q.flush();\n      expect($state.$current.name).toBe('contacts');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind click event by default","suites":["uiStateRef","option event"],"updatePoint":{"line":747,"column":42},"line":747,"code":"    it('should bind click event by default', inject(function ($rootScope, $compile, $state, $timeout) {\n      el = angular.element('<a ui-sref=\"contacts\"></a>');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerClick(el);\n      $timeout.flush();\n\n      expect($state.current.name).toEqual('contacts');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind single HTML events","suites":["uiStateRef","option event"],"updatePoint":{"line":760,"column":38},"line":760,"code":"    it('should bind single HTML events', inject(function ($rootScope, $compile, $state, $timeout) {\n      el = angular.element('<input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: [\\'change\\'] }\">');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerHTMLEvent('change');\n      $timeout.flush();\n\n      expect($state.current.name).toEqual('contacts');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind multiple HTML events","suites":["uiStateRef","option event"],"updatePoint":{"line":773,"column":40},"line":773,"code":"    it('should bind multiple HTML events', inject(function ($rootScope, $compile, $state, $timeout) {\n      el = angular.element('<input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: [\\'change\\', \\'blur\\'] }\">');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerHTMLEvent('change');\n      $timeout.flush();\n      expect($state.current.name).toEqual('contacts');\n\n      $state.go('top');\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerHTMLEvent('blur');\n      $timeout.flush();\n      expect($state.current.name).toEqual('contacts');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should bind multiple Mouse events","suites":["uiStateRef","option event"],"updatePoint":{"line":794,"column":41},"line":794,"code":"    it('should bind multiple Mouse events', inject(function ($rootScope, $compile, $state, $timeout) {\n      el = angular.element('<a ui-sref=\"contacts\" ui-sref-opts=\"{ events: [\\'mouseover\\', \\'mousedown\\'] }\">');\n      $compile(el)($rootScope);\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerMouseEvent('mouseover');\n      $timeout.flush();\n      expect($state.current.name).toEqual('contacts');\n\n      $state.go('top');\n      $rootScope.$digest();\n\n      expect($state.current.name).toEqual('top');\n\n      triggerMouseEvent('mousedown');\n      $timeout.flush();\n      expect($state.current.name).toEqual('contacts');\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update class for sibling uiSref","suites":["uiSrefActive"],"updatePoint":{"line":873,"column":44},"line":873,"code":"  it('should update class for sibling uiSref', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element(\n      '<div><a ui-sref=\"contacts.item({ id: 1 })\" ui-sref-active=\"active\">Contacts</a><a ui-sref=\"contacts.item({ id: 2 })\" ui-sref-active=\"active\">Contacts</a></div>'\n    );\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('contacts.item', { id: 2 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match state's parameters","suites":["uiSrefActive"],"updatePoint":{"line":892,"column":37},"line":892,"code":"  it(\"should match state's parameters\", inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element(\n      '<div><a ui-sref=\"contacts.item.detail({ foo: \\'bar\\' })\" ui-sref-active=\"active\">Contacts</a></div>'\n    );\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n    $state.transitionTo('contacts.item.detail', { id: 5, foo: 'bar' });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('contacts.item.detail', { id: 5, foo: 'baz' });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should compare using typed parameters","suites":["uiSrefActive"],"updatePoint":{"line":912,"column":43},"line":912,"code":"  it('should compare using typed parameters', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element('<div><a ui-sref=\"arrayparam({ foo: [1,2,3] })\" ui-sref-active=\"active\">foo 123</a></div>');\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n\n    $state.transitionTo('arrayparam', { foo: [1, 2, 3] });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('arrayparam', { foo: [1, 2, 3], bar: 'asdf' });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('arrayparam', { foo: [1, 2] });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should compare ui-sref-active-eq using typed parameters","suites":["uiSrefActive"],"updatePoint":{"line":936,"column":61},"line":936,"code":"  it('should compare ui-sref-active-eq using typed parameters', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element('<div><a ui-sref=\"arrayparam({ foo: [1,2,3] })\" ui-sref-active-eq=\"active\">foo 123</a></div>');\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n\n    $state.transitionTo('arrayparam', { foo: [1, 2, 3] });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('arrayparam', { foo: [1, 2, 3], bar: 'asdf' });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $state.transitionTo('arrayparam', { foo: [1, 2] });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update in response to ui-sref param expression changes","suites":["uiSrefActive"],"updatePoint":{"line":959,"column":67},"line":959,"code":"  it('should update in response to ui-sref param expression changes', inject(function (\n    $rootScope,\n    $q,\n    $compile,\n    $state\n  ) {\n    el = angular.element(\n      '<div><a ui-sref=\"contacts.item.detail({ foo: fooId })\" ui-sref-active=\"active\">Contacts</a></div>'\n    );\n    template = $compile(el)($rootScope);\n    $rootScope.fooId = 'bar';\n    $rootScope.$digest();\n\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n    $state.transitionTo('contacts.item.detail', { id: 5, foo: 'bar' });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n\n    $rootScope.fooId = 'baz';\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on child states","suites":["uiSrefActive"],"updatePoint":{"line":984,"column":34},"line":984,"code":"  it('should match on child states', inject(function ($rootScope, $q, $compile, $state) {\n    template = $compile('<div><a ui-sref=\"contacts.item({ id: 1 })\" ui-sref-active=\"active\">Contacts</a></div>')(\n      $rootScope\n    );\n    $rootScope.$digest();\n    const a = angular.element(template[0].getElementsByTagName('a')[0]);\n\n    $state.transitionTo('contacts.item.edit', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect($state.params.id).toBe('1');\n    expect(a.attr('class')).toMatch(/active/);\n\n    $state.transitionTo('contacts.item.edit', { id: 4 });\n    $q.flush();\n    timeoutFlush();\n    expect($state.params.id).toBe('4');\n    expect(a.attr('class')).not.toMatch(/active/);\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should NOT match on child states when active-equals is used","suites":["uiSrefActive"],"updatePoint":{"line":1004,"column":65},"line":1004,"code":"  it('should NOT match on child states when active-equals is used', inject(function ($rootScope, $q, $compile, $state) {\n    template = $compile('<div><a ui-sref=\"contacts.item({ id: 1 })\" ui-sref-active-eq=\"active\">Contacts</a></div>')(\n      $rootScope\n    );\n    $rootScope.$digest();\n    const a = angular.element(template[0].getElementsByTagName('a')[0]);\n\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(a.attr('class')).toMatch(/active/);\n\n    $state.transitionTo('contacts.item.edit', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(a.attr('class')).not.toMatch(/active/);\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on child states when active-equals and active-equals-eq is used","suites":["uiSrefActive"],"updatePoint":{"line":1022,"column":82},"line":1022,"code":"  it('should match on child states when active-equals and active-equals-eq is used', inject(function (\n    $rootScope,\n    $q,\n    $compile,\n    $state,\n    $timeout\n  ) {\n    template = $compile(\n      '<div><a ui-sref=\"contacts.item({ id: 1 })\" ui-sref-active=\"active\" ui-sref-active-eq=\"active-eq\">Contacts</a></div>'\n    )($rootScope);\n    $rootScope.$digest();\n    const a = angular.element(template[0].getElementsByTagName('a')[0]);\n\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(a.attr('class')).toMatch(/active/);\n    expect(a.attr('class')).toMatch(/active-eq/);\n\n    $state.transitionTo('contacts.item.edit', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(a.attr('class')).toMatch(/active/);\n    expect(a.attr('class')).not.toMatch(/active-eq/);\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should resolve relative state refs","suites":["uiSrefActive"],"updatePoint":{"line":1048,"column":40},"line":1048,"code":"  it('should resolve relative state refs', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element('<section><div ui-view></div></section>');\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    $state.transitionTo('contacts');\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('ng-scope');\n\n    $state.transitionTo('contacts.item', { id: 6 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('ng-scope active');\n\n    $state.transitionTo('contacts.item', { id: 5 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('ng-scope');\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on any child state refs","suites":["uiSrefActive"],"updatePoint":{"line":1069,"column":42},"line":1069,"code":"  it('should match on any child state refs', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element(\n      '<div ui-sref-active=\"active\"><a ui-sref=\"contacts.item({ id: 1 })\">Contacts</a><a ui-sref=\"contacts.item({ id: 2 })\">Contacts</a></div>'\n    );\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    expect(angular.element(template[0]).attr('class')).toBe('ng-scope');\n\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0]).attr('class')).toBe('ng-scope active');\n\n    $state.transitionTo('contacts.item', { id: 2 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0]).attr('class')).toBe('ng-scope active');\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match fuzzy on lazy loaded states","suites":["uiSrefActive"],"updatePoint":{"line":1089,"column":46},"line":1089,"code":"  it('should match fuzzy on lazy loaded states', inject(function ($rootScope, $q, $compile, $state) {\n    el = angular.element('<div><a ui-sref=\"contacts.lazy\" ui-sref-active=\"active\">Lazy Contact</a></div>');\n    template = $compile(el)($rootScope);\n    $q.flush();\n\n    _stateProvider.onInvalid(function ($to$) {\n      if ($to$.name() === 'contacts.lazy') {\n        _stateProvider.state('contacts.lazy', {});\n        return $to$;\n      }\n    });\n\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n\n    $state.transitionTo('contacts.lazy');\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match exactly on lazy loaded states","suites":["uiSrefActive"],"updatePoint":{"line":1112,"column":48},"line":1112,"code":"  it('should match exactly on lazy loaded states', inject(function ($transitions, $rootScope, $q, $compile, $state) {\n    el = angular.element('<div><a ui-sref=\"contacts.lazy\" ui-sref-active-eq=\"active\">Lazy Contact</a></div>');\n    template = $compile(el)($rootScope);\n    $q.flush();\n\n    _stateProvider.onInvalid(function ($to$) {\n      if ($to$.name() === 'contacts.lazy') {\n        _stateProvider.state('contacts.lazy', {});\n        return $to$;\n      }\n    });\n\n    $state.transitionTo('contacts.item', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBeFalsy();\n\n    $state.transitionTo('contacts.lazy');\n    $q.flush();\n    timeoutFlush();\n    expect(angular.element(template[0].querySelector('a')).attr('class')).toBe('active');\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should allow multiple classes to be supplied","suites":["uiSrefActive"],"updatePoint":{"line":1135,"column":50},"line":1135,"code":"  it('should allow multiple classes to be supplied', inject(function ($rootScope, $q, $compile, $state) {\n    template = $compile(\n      '<div><a ui-sref=\"contacts.item({ id: 1 })\" ui-sref-active=\"active also-active\">Contacts</a></div>'\n    )($rootScope);\n    $rootScope.$digest();\n    const a = angular.element(template[0].getElementsByTagName('a')[0]);\n\n    $state.transitionTo('contacts.item.edit', { id: 1 });\n    $q.flush();\n    timeoutFlush();\n    expect(a.attr('class')).toMatch(/active also-active/);\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not match fuzzy on lazy loaded future states","suites":["uiSrefActive"],"updatePoint":{"line":1148,"column":57},"line":1148,"code":"  it('should not match fuzzy on lazy loaded future states', inject(function ($rootScope, $compile, $q, $state) {\n    _stateProvider.state('contacts.lazy.**', {\n      url: '/lazy',\n      lazyLoad: function () {\n        return $q.when().then(function () {\n          _stateProvider\n            .state('contacts.lazy', {\n              abstract: true,\n              url: '/lazy',\n            })\n            .state('contacts.lazy.s1', {\n              url: '/s1',\n            })\n            .state('contacts.lazy.s2', {\n              url: '/s2',\n            });\n        });\n      },\n    });\n    template = $compile(\n      '<div ui-sref-active=\"active\"><a ui-sref=\"contacts.lazy.s1\">Lazy</a></div><div ui-sref-active=\"active\"><a ui-sref=\"contacts.lazy.s2\"></a></div>'\n    )($rootScope);\n    $rootScope.$digest();\n    $state.transitionTo('contacts.lazy.s1');\n    $q.flush();\n    timeoutFlush();\n    expect(template.eq(0).hasClass('active')).toBeTruthy();\n    expect(template.eq(1).hasClass('active')).toBeFalsy();\n  }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on abstract states that are included by the current state","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1179,"column":78},"line":1179,"code":"    it('should match on abstract states that are included by the current state', inject(function (\n      $rootScope,\n      $compile,\n      $state,\n      $q\n    ) {\n      el = $compile(\n        '<div ui-sref-active=\"{active: \\'admin.*\\'}\"><a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a></div>'\n      )($rootScope);\n      $state.transitionTo('admin.roles');\n      $q.flush();\n      timeoutFlush();\n      const abstractParent = el[0];\n      expect(abstractParent.className).toMatch(/active/);\n      const child = el[0].querySelector('a');\n      expect(child.className).toMatch(/active/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on state parameters","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1197,"column":40},"line":1197,"code":"    it('should match on state parameters', inject(function ($compile, $rootScope, $state, $q) {\n      el = $compile('<div ui-sref-active=\"{active: \\'admin.roles({page: 1})\\'}\"></div>')($rootScope);\n      $state.transitionTo('admin.roles', { page: 1 });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/active/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should shadow the state provided by ui-sref","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1205,"column":51},"line":1205,"code":"    it('should shadow the state provided by ui-sref', inject(function ($compile, $rootScope, $state, $q) {\n      el = $compile('<div ui-sref-active=\"{active: \\'admin.roles({page: 1})\\'}\"><a ui-sref=\"admin.roles\"></a></div>')(\n        $rootScope\n      );\n      $state.transitionTo('admin.roles');\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).not.toMatch(/active/);\n      $state.transitionTo('admin.roles', { page: 1 });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/active/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should support multiple <className, stateOrName> pairs","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1219,"column":62},"line":1219,"code":"    it('should support multiple <className, stateOrName> pairs', inject(function ($compile, $rootScope, $state, $q) {\n      el = $compile(\"<div ui-sref-active=\\\"{contacts: 'contacts.**', admin: 'admin.roles({page: 1})'}\\\"></div>\")(\n        $rootScope\n      );\n      $state.transitionTo('contacts');\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/contacts/);\n      expect(el[0].className).not.toMatch(/admin/);\n      $state.transitionTo('admin.roles', { page: 1 });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/admin/);\n      expect(el[0].className).not.toMatch(/contacts/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update the active classes when compiled","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1235,"column":54},"line":1235,"code":"    it('should update the active classes when compiled', inject(function ($compile, $rootScope, $document, $state, $q) {\n      $state.transitionTo('admin.roles');\n      $q.flush();\n      timeoutFlush();\n      el = $compile('<div ui-sref-active=\"{active: \\'admin.roles\\'}\"/>')($rootScope);\n      $rootScope.$digest();\n      timeoutFlush();\n      expect(el.hasClass('active')).toBeTruthy();\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should not match fuzzy on lazy loaded future states","suites":["uiSrefActive","ng-{class,style} interface"],"updatePoint":{"line":1245,"column":59},"line":1245,"code":"    it('should not match fuzzy on lazy loaded future states', inject(function ($rootScope, $compile, $q, $state) {\n      _stateProvider.state('contacts.lazy.**', {\n        url: '/lazy',\n        lazyLoad: function () {\n          return $q.when().then(function () {\n            _stateProvider\n              .state('contacts.lazy', {\n                abstract: true,\n                url: '/lazy',\n              })\n              .state('contacts.lazy.s1', {\n                url: '/s1',\n              })\n              .state('contacts.lazy.s2', {\n                url: '/s2',\n              });\n          });\n        },\n      });\n      template = $compile(\n        '<div ui-sref-active=\"{ active: \\'contacts.lazy.s1\\' }\"><a ui-sref=\"contacts.lazy.s1\">Lazy</a></div><div ui-sref-active=\"{ active: \\'contacts.lazy.s2\\' }\"></div>'\n      )($rootScope);\n      $rootScope.$digest();\n      $state.transitionTo('contacts.lazy.s1');\n      $q.flush();\n      timeoutFlush();\n      expect(template.eq(0).hasClass('active')).toBeTruthy();\n      expect(template.eq(1).hasClass('active')).toBeFalsy();\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on abstract states that are included by the current state","suites":["uiSrefActive","ng-{class,style} interface, and handle values as arrays"],"updatePoint":{"line":1277,"column":78},"line":1277,"code":"    it('should match on abstract states that are included by the current state', inject(function (\n      $rootScope,\n      $compile,\n      $state,\n      $q\n    ) {\n      el = $compile(\n        '<div ui-sref-active=\"{active: [\\'randomState.**\\', \\'admin.roles\\']}\"><a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a></div>'\n      )($rootScope);\n      $state.transitionTo('admin.roles');\n      $q.flush();\n      timeoutFlush();\n      const abstractParent = el[0];\n      expect(abstractParent.className).toMatch(/active/);\n      const child = el[0].querySelector('a');\n      expect(child.className).toMatch(/active/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should match on state parameters","suites":["uiSrefActive","ng-{class,style} interface, and handle values as arrays"],"updatePoint":{"line":1295,"column":40},"line":1295,"code":"    it('should match on state parameters', inject(function ($compile, $rootScope, $state, $q) {\n      el = $compile('<div ui-sref-active=\"{active: [\\'admin.roles({page: 1})\\']}\"></div>')($rootScope);\n      $state.transitionTo('admin.roles', { page: 1 });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/active/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should support multiple <className, stateOrName> pairs","suites":["uiSrefActive","ng-{class,style} interface, and handle values as arrays"],"updatePoint":{"line":1303,"column":62},"line":1303,"code":"    it('should support multiple <className, stateOrName> pairs', inject(function ($compile, $rootScope, $state, $q) {\n      el = $compile(\n        \"<div ui-sref-active=\\\"{contacts: ['contacts.item', 'contacts.item.detail'], admin: 'admin.roles({page: 1})'}\\\"></div>\"\n      )($rootScope);\n      $state.transitionTo('contacts.item.detail', { id: 1, foo: 'bar' });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/contacts/);\n      expect(el[0].className).not.toMatch(/admin/);\n      $state.transitionTo('admin.roles', { page: 1 });\n      $q.flush();\n      timeoutFlush();\n      expect(el[0].className).toMatch(/admin/);\n      expect(el[0].className).not.toMatch(/contacts/);\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"should update the active classes when compiled","suites":["uiSrefActive","ng-{class,style} interface, and handle values as arrays"],"updatePoint":{"line":1319,"column":54},"line":1319,"code":"    it('should update the active classes when compiled', inject(function ($compile, $rootScope, $document, $state, $q) {\n      $state.transitionTo('admin.roles');\n      $q.flush();\n      timeoutFlush();\n      el = $compile(\"<div ui-sref-active=\\\"{active: ['admin.roles', 'admin.someOtherState']}\\\"/>\")($rootScope);\n      $rootScope.$digest();\n      timeoutFlush();\n      expect(el.hasClass('active')).toBeTruthy();\n    }));","file":"stateDirectivesSpec.ts","skipped":false,"dir":"test"},{"name":"triggers $stateChangeStart","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":97,"column":34},"line":97,"code":"    it('triggers $stateChangeStart', inject(function ($state, $q, $rootScope) {\n      initStateTo(E, { i: 'iii' }, { anOption: true });\n      let called;\n      $rootScope.$on('$stateChangeStart', function (ev, to, toParams, from, fromParams, options) {\n        expect(from).toBe(E);\n\n        expect(obj(fromParams)).toEqual({ i: 'iii' });\n\n        expect(to).toBe(D);\n\n        expect(obj(toParams)).toEqual({ x: '1', y: '2' });\n\n        expect(options.custom.anOption).toBe(false);\n\n        expect($state.current).toBe(from); // $state not updated yet\n        expect(obj($state.params)).toEqual(obj(fromParams));\n        called = true;\n      });\n      $state.transitionTo(D, { x: '1', y: '2' }, { custom: { anOption: false } });\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(D);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can be cancelled by preventDefault() in $stateChangeStart","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":121,"column":65},"line":121,"code":"    it('can be cancelled by preventDefault() in $stateChangeStart', inject(function ($state, $q, $rootScope) {\n      $state.defaultErrorHandler(function () {});\n      initStateTo(A);\n      let called;\n      $rootScope.$on('$stateChangeStart', function (ev) {\n        ev.preventDefault();\n        called = true;\n      });\n      const promise = $state.transitionTo(B, {});\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(A);\n      expect(resolvedError(promise)).toBeTruthy();\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"triggers $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":136,"column":31},"line":136,"code":"    it('triggers $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(E, { i: 'iii' });\n      let called;\n      $rootScope.$on('$stateNotFound', function (ev, unfoundState, fromState, fromParams) {\n        expect(fromState).toBe(E);\n        expect(obj(fromParams)).toEqual({ i: 'iii' });\n        expect(unfoundState.to).toEqual('never_defined');\n        expect(unfoundState.toParams).toEqual({ x: '1', y: '2' });\n\n        expect($state.current).toBe(E); // $state not updated yet\n        expect(obj($state.params)).toEqual({ i: 'iii' });\n        called = true;\n      });\n      let message;\n      $state.transitionTo('never_defined', { x: '1', y: '2' }).catch(function (e) {\n        message = e.detail;\n      });\n      $q.flush();\n      expect(message).toEqual(\"No such state 'never_defined'\");\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(E);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"throws Error on failed relative state resolution","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":159,"column":56},"line":159,"code":"    it('throws Error on failed relative state resolution', inject(function ($state, $q) {\n      $state.transitionTo(DD);\n      $q.flush();\n      let error,\n        promise = $state.transitionTo('^.Z', null, { relative: $state.$current });\n      promise.catch(function (e) {\n        error = e.detail;\n      });\n      $q.flush();\n\n      const err = \"Could not resolve '^.Z' from state 'DD'\";\n      expect(error).toBe(err);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"sends $stateChangeError for exceptions in onEnter","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":173,"column":57},"line":173,"code":"    it('sends $stateChangeError for exceptions in onEnter', inject(function (\n      $state,\n      $q,\n      $rootScope,\n      $exceptionHandler\n    ) {\n      $exceptionHandler.disabled = true;\n      $state.defaultErrorHandler(function () {});\n\n      stateProvider.state('onEnterFail', {\n        onEnter: function () {\n          throw new Error('negative onEnter');\n        },\n      });\n\n      let called;\n      $rootScope.$on('$stateChangeError', function (ev, to, toParams, from, fromParams, options) {\n        called = true;\n      });\n\n      initStateTo(A);\n      $state.transitionTo('onEnterFail');\n      $q.flush();\n\n      expect(called).toBeTruthy();\n      expect($state.current.name).toEqual(A.name);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can be cancelled by preventDefault() in $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":201,"column":62},"line":201,"code":"    it('can be cancelled by preventDefault() in $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(A);\n      let called;\n      $rootScope.$on('$stateNotFound', function (ev) {\n        ev.preventDefault();\n        called = true;\n      });\n      const promise = $state.transitionTo('never_defined', {});\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(A);\n      expect(resolvedError(promise)).toBeTruthy();\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can be redirected in $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":215,"column":43},"line":215,"code":"    it('can be redirected in $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(A);\n      let called;\n      $rootScope.$on('$stateNotFound', function (ev, redirect) {\n        redirect.to = D;\n        redirect.toParams = { x: '1', y: '2' };\n        called = true;\n      });\n      const promise = $state.transitionTo('never_defined', { z: 3 });\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(D);\n      expect(obj($state.params)).toEqual({ x: '1', y: '2' });\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can lazy-define a state in $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":230,"column":49},"line":230,"code":"    it('can lazy-define a state in $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(DD, { x: 1, y: 2, z: 3 });\n      let called;\n      $rootScope.$on('$stateNotFound', function (ev, redirect) {\n        stateProvider.state(redirect.to, { parent: DD, params: { w: {} } });\n        ev.retry = called = true;\n      });\n      const promise = $state.go('DDD', { w: 4 });\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current.name).toEqual('DDD');\n      expect(obj($state.params)).toEqual({ x: 1, y: 2, z: 3, w: 4 });\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can defer a state transition in $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":244,"column":54},"line":244,"code":"    it('can defer a state transition in $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(A);\n      let called;\n      const deferred = $q.defer();\n      $rootScope.$on('$stateNotFound', function (ev, redirect) {\n        ev.retry = deferred.promise;\n        called = true;\n      });\n      const promise = $state.go('AA', { a: 1 });\n      stateProvider.state('AA', { parent: A, params: { a: {} } });\n      deferred.resolve();\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current.name).toEqual('AA');\n      expect(obj($state.params)).toEqual({ a: 1 });\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"can defer and supersede a state transition in $stateNotFound","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":261,"column":68},"line":261,"code":"    it('can defer and supersede a state transition in $stateNotFound', inject(function ($state, $q, $rootScope) {\n      initStateTo(A);\n      let called;\n      const deferred = $q.defer();\n      $rootScope.$on('$stateNotFound', function (ev, redirect) {\n        ev.retry = deferred.promise;\n        called = true;\n      });\n      const promise = $state.go('AA', { a: 1 });\n      $state.go(B);\n      stateProvider.state('AA', { parent: A, params: { a: {} } });\n      deferred.resolve();\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toEqual(B);\n      expect(obj($state.params)).toEqual({});\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"triggers $stateChangeSuccess","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":279,"column":36},"line":279,"code":"    it('triggers $stateChangeSuccess', inject(function ($state, $q, $rootScope) {\n      initStateTo(E, { i: 'iii' });\n      let called;\n      $rootScope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {\n        expect(from).toBe(E);\n        expect(obj(fromParams)).toEqual({ i: 'iii' });\n        expect(to).toBe(D);\n        expect(obj(toParams)).toEqual({ x: '1', y: '2' });\n\n        expect($state.current).toBe(to); // $state has been updated\n        expect(obj($state.params)).toEqual(obj(toParams));\n        called = true;\n      });\n      $state.transitionTo(D, { x: '1', y: '2' });\n      $q.flush();\n      expect(called).toBeTruthy();\n      expect($state.current).toBe(D);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"does not trigger $stateChangeSuccess when suppressed, but changes state","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":298,"column":79},"line":298,"code":"    it('does not trigger $stateChangeSuccess when suppressed, but changes state', inject(function (\n      $state,\n      $q,\n      $rootScope\n    ) {\n      initStateTo(E, { i: 'iii' });\n      let called;\n\n      $rootScope.$on('$stateChangeSuccess', function (ev, to, toParams, from, fromParams) {\n        called = true;\n      });\n\n      $state.transitionTo(D, { x: '1', y: '2' }, { notify: false });\n      $q.flush();\n\n      expect(called).toBeFalsy();\n      expect($state.current).toBe(D);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"does not trigger $stateChangeSuccess when suppressed, but updates params","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":317,"column":80},"line":317,"code":"    it('does not trigger $stateChangeSuccess when suppressed, but updates params', inject(function (\n      $state,\n      $q,\n      $rootScope\n    ) {\n      initStateTo(E, { x: 'iii' });\n      let called;\n\n      $rootScope.$on('$stateChangeSuccess', function (ev, transition) {\n        called = true;\n      });\n      $state.transitionTo(E, { i: '1', y: '2' }, { notify: false });\n      $q.flush();\n\n      expect(called).toBeFalsy();\n      expect($state.params.i).toBe('1');\n      expect($state.current).toBe(E);\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"aborts pending transitions even when going back to the current state","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":336,"column":76},"line":336,"code":"    it('aborts pending transitions even when going back to the current state', inject(function ($state, $q, $timeout) {\n      initStateTo(A);\n      logEvents = true;\n      $state.defaultErrorHandler(function () {});\n\n      const superseded = $state.transitionTo(F, {});\n      $q.flush();\n      expect($state.current).toBe(A);\n\n      $state.transitionTo(A, {});\n      $q.flush();\n      $timeout.flush();\n      expect($state.current).toBe(A);\n      expect(resolvedError(superseded)).toBeTruthy();\n      expect(log).toBe('$stateChangeStart(F,A);');\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"aborts pending transitions (last call wins)","suites":["UI-Router v0.2.x $state events",".transitionTo()"],"updatePoint":{"line":353,"column":51},"line":353,"code":"    it('aborts pending transitions (last call wins)', inject(function ($state, $q, $timeout) {\n      initStateTo(A);\n      logEvents = true;\n      $state.defaultErrorHandler(function () {});\n\n      const superseded = $state.transitionTo(F, {});\n      $q.flush();\n\n      $state.transitionTo(C, {});\n      $q.flush();\n      $timeout.flush();\n      expect($state.current).toBe(C);\n      expect(resolvedError(superseded)).toBeTruthy();\n      expect(log).toBe('$stateChangeStart(F,A);' + '$stateChangeStart(C,A);' + '$stateChangeSuccess(C,A);');\n    }));","file":"stateEventsSpec.ts","skipped":false,"dir":"test"},{"name":"should return true if the current state exactly matches the input state","suites":["isState filter"],"updatePoint":{"line":14,"column":77},"line":14,"code":"  it('should return true if the current state exactly matches the input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('a');\n    $q.flush();\n    expect($parse('\"a\" | isState')($rootScope)).toBe(true);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return false if the current state does not exactly match the input state","suites":["isState filter"],"updatePoint":{"line":25,"column":85},"line":25,"code":"  it('should return false if the current state does not exactly match the input state', inject(function (\n    $parse,\n    $q,\n    $state,\n    $rootScope\n  ) {\n    $state.go('a.b');\n    $q.flush();\n    expect($parse('\"a\" | isState')($rootScope)).toBe(false);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return true if the current state and param matches the input state","suites":["isState filter"],"updatePoint":{"line":36,"column":79},"line":36,"code":"  it('should return true if the current state and param matches the input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('with-param', { param: 'a' });\n    $q.flush();\n    expect($parse('\"with-param\" | isState: {param: \"a\"}')($rootScope)).toBe(true);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return false if the current state and param does not match the input state","suites":["isState filter"],"updatePoint":{"line":47,"column":87},"line":47,"code":"  it('should return false if the current state and param does not match the input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('with-param', { param: 'b' });\n    $q.flush();\n    expect($parse('\"with-param\" | isState: {param: \"a\"}')($rootScope)).toBe(false);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return true if the current state exactly matches the input state","suites":["includedByState filter"],"updatePoint":{"line":71,"column":77},"line":71,"code":"  it('should return true if the current state exactly matches the input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('a');\n    $q.flush();\n    expect($parse('\"a\" | includedByState')($rootScope)).toBe(true);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return true if the current state includes the input state","suites":["includedByState filter"],"updatePoint":{"line":82,"column":70},"line":82,"code":"  it('should return true if the current state includes the input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('a.b');\n    $q.flush();\n    expect($parse('\"a\" | includedByState')($rootScope)).toBe(true);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return false if the current state does not include input state","suites":["includedByState filter"],"updatePoint":{"line":93,"column":75},"line":93,"code":"  it('should return false if the current state does not include input state', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('c');\n    $q.flush();\n    expect($parse('\"a\" | includedByState')($rootScope)).toBe(false);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return true if the current state include input state and params","suites":["includedByState filter"],"updatePoint":{"line":104,"column":76},"line":104,"code":"  it('should return true if the current state include input state and params', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('d', { id: 123 });\n    $q.flush();\n    expect($parse('\"d\" | includedByState:{ id: 123 }')($rootScope)).toBe(true);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should return false if the current state does not include input state and params","suites":["includedByState filter"],"updatePoint":{"line":115,"column":86},"line":115,"code":"  it('should return false if the current state does not include input state and params', inject(function (\n    $parse,\n    $state,\n    $q,\n    $rootScope\n  ) {\n    $state.go('d', { id: 2377 });\n    $q.flush();\n    expect($parse('\"d\" | includedByState:{ id: 123 }')($rootScope)).toBe(false);\n  }));","file":"stateFiltersSpec.ts","skipped":false,"dir":"test"},{"name":"should ignore Object properties when registering states","suites":["state","provider"],"updatePoint":{"line":237,"column":63},"line":237,"code":"    it('should ignore Object properties when registering states', function () {\n      expect(function () {\n        $stateProvider.state('toString', { url: '/to-string' });\n      }).not.toThrow();\n      expect(function () {\n        $stateProvider.state('watch', { url: '/watch' });\n      }).not.toThrow();\n    });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"returns a promise for the target state","suites":["state",".transitionTo()"],"updatePoint":{"line":259,"column":46},"line":259,"code":"    it('returns a promise for the target state', inject(function ($state, $q) {\n      const promise = $state.transitionTo(A, {});\n      expect(angular.isFunction(promise.then)).toBeTruthy();\n      expect(promise.transition.to()).toBe(A);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"allows transitions by name","suites":["state",".transitionTo()"],"updatePoint":{"line":268,"column":34},"line":268,"code":"    it('allows transitions by name', inject(function ($state, $q) {\n      $state.transitionTo('A', {});\n      $q.flush();\n      expect($state.current).toBe(A);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is considered fully dynamic when only dynamic params have changed","suites":["state",".transitionTo()","dynamic transitions","[ transition.dynamic() ]:"],"updatePoint":{"line":359,"column":77},"line":359,"code":"        it('is considered fully dynamic when only dynamic params have changed', function () {\n          const promise = $state.go('.', { pathDyn: 'pd2', searchDyn: 'sd2' });\n          expect(promise.transition.dynamic()).toBeTruthy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is not considered fully dynamic if any state is entered","suites":["state",".transitionTo()","dynamic transitions","[ transition.dynamic() ]:"],"updatePoint":{"line":364,"column":67},"line":364,"code":"        it('is not considered fully dynamic if any state is entered', function () {\n          const promise = $state.go(childWithParam);\n          expect(promise.transition.dynamic()).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is not considered fully dynamic if any state is exited","suites":["state",".transitionTo()","dynamic transitions","[ transition.dynamic() ]:"],"updatePoint":{"line":369,"column":66},"line":369,"code":"        it('is not considered fully dynamic if any state is exited', function () {\n          initStateTo(childWithParam, { config: 'p1', path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd1' });\n          const promise = $state.go(dynamicstate);\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is not considered fully dynamic if any state is reloaded","suites":["state",".transitionTo()","dynamic transitions","[ transition.dynamic() ]:"],"updatePoint":{"line":376,"column":68},"line":376,"code":"        it('is not considered fully dynamic if any state is reloaded', function () {\n          const promise = $state.go(dynamicstate, null, { reload: true });\n          expect(promise.transition.dynamic()).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is not considered fully dynamic if any non-dynamic parameter changes","suites":["state",".transitionTo()","dynamic transitions","[ transition.dynamic() ]:"],"updatePoint":{"line":381,"column":80},"line":381,"code":"        it('is not considered fully dynamic if any non-dynamic parameter changes', function () {\n          const promise = $state.go(dynamicstate, { path: 'p2' });\n          expect(promise.transition.dynamic()).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"runs successful transition when fully dynamic","suites":["state",".transitionTo()","dynamic transitions","[ promises ]"],"updatePoint":{"line":388,"column":57},"line":388,"code":"        it('runs successful transition when fully dynamic', function () {\n          let transSuccess,\n            promise = $state.go(dynamicstate, { searchDyn: 'sd2' }),\n            transition = promise.transition;\n          transition.promise.then(function (result) {\n            transSuccess = true;\n          });\n          $q.flush();\n          expect(transition.dynamic()).toBeTruthy();\n          expect(transSuccess).toBeTruthy();\n          expect(dynlog).toBe('success;[searchDyn=sd2];');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"resolves the $state.go() promise with the original/final state, when fully dynamic","suites":["state",".transitionTo()","dynamic transitions","[ promises ]"],"updatePoint":{"line":401,"column":94},"line":401,"code":"        it('resolves the $state.go() promise with the original/final state, when fully dynamic', function () {\n          initStateTo(dynamicstate, { path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd1' });\n          let destState,\n            promise = $state.go(dynamicstate, { pathDyn: 'pd2', searchDyn: 'sd2' });\n          promise.then(function (result) {\n            destState = result;\n          });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeTruthy();\n          expect($state.current).toBe(dynamicstate);\n          expect(destState).toBe(dynamicstate);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not exit nor enter any states when fully dynamic","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":416,"column":65},"line":416,"code":"        it('does not exit nor enter any states when fully dynamic', function () {\n          const promise = $state.go(dynamicstate, { searchDyn: 'sd2' });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeTruthy();\n          expect(promise.transition.treeChanges().entering.length).toBe(0);\n          expect(promise.transition.treeChanges().exiting.length).toBe(0);\n          expect(promise.transition.treeChanges().retained.length).toBe(2);\n          expect(dynlog).toBe('success;[searchDyn=sd2];');\n          expect(obj($stateParams)).toEqual({ path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd2' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not exit nor enter the state when only dynamic search params change","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":427,"column":84},"line":427,"code":"        it('does not exit nor enter the state when only dynamic search params change', function () {\n          const promise = $state.go(dynamicstate, { searchDyn: 'sd2' });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeTruthy();\n          expect(dynlog).toBe('success;[searchDyn=sd2];');\n          expect(obj($stateParams)).toEqual({ path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd2' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not exit nor enter the state when only dynamic path params change","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":435,"column":82},"line":435,"code":"        it('does not exit nor enter the state when only dynamic path params change', function () {\n          const promise = $state.go(dynamicstate, { pathDyn: 'pd2' });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeTruthy();\n          expect(dynlog).toBe('success;[pathDyn=pd2];');\n          expect(obj($stateParams)).toEqual({ path: 'p1', pathDyn: 'pd2', search: 's1', searchDyn: 'sd1' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"exits and enters a state when a non-dynamic search param changes","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":443,"column":76},"line":443,"code":"        it('exits and enters a state when a non-dynamic search param changes', function () {\n          const promise = $state.go(dynamicstate, { search: 's2' });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeFalsy();\n          expect(dynlog).toBe('exit:dyn;enter:dyn;success;');\n          expect(obj($stateParams)).toEqual({ path: 'p1', pathDyn: 'pd1', search: 's2', searchDyn: 'sd1' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"exits and enters a state when a non-dynamic path param changes","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":451,"column":74},"line":451,"code":"        it('exits and enters a state when a non-dynamic path param changes', function () {\n          const promise = $state.go(dynamicstate, { path: 'p2' });\n          $q.flush();\n          expect(promise.transition.dynamic()).toBeFalsy();\n          expect(dynlog).toBe('exit:dyn;enter:dyn;success;');\n          expect(obj($stateParams)).toEqual({ path: 'p2', pathDyn: 'pd1', search: 's1', searchDyn: 'sd1' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not exit nor enter a state when only dynamic params change (triggered via url)","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":459,"column":95},"line":459,"code":"        it('does not exit nor enter a state when only dynamic params change (triggered via url)', function () {\n          $location.search({ search: 's1', searchDyn: 'sd2' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect(dynlog).toBe('success;[searchDyn=sd2];');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"exits and enters a state when any non-dynamic params change (triggered via url)","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":466,"column":91},"line":466,"code":"        it('exits and enters a state when any non-dynamic params change (triggered via url)', function () {\n          $location.search({ search: 's2', searchDyn: 'sd2' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect(dynlog).toBe('exit:dyn;enter:dyn;success;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not exit nor enter a state when only dynamic params change (triggered via $state transition)","suites":["state",".transitionTo()","dynamic transitions","[ enter/exit ]"],"updatePoint":{"line":473,"column":109},"line":473,"code":"        it('does not exit nor enter a state when only dynamic params change (triggered via $state transition)', function () {\n          $state.go('.', { searchDyn: 'sd2' }, { inherit: true });\n          $q.flush();\n          expect(dynlog).toBe('success;[searchDyn=sd2];');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates the global $stateParams object","suites":["state",".transitionTo()","dynamic transitions","[ global $stateParams service ]"],"updatePoint":{"line":481,"column":50},"line":481,"code":"        it('updates the global $stateParams object', function () {\n          $state.go(dynamicstate, { searchDyn: 'sd2' });\n          $q.flush();\n          expect(obj($stateParams)).toEqual({ path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd2' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates $stateParams and $location.search when only dynamic params change (triggered via url)","suites":["state",".transitionTo()","dynamic transitions","[ global $stateParams service ]"],"updatePoint":{"line":487,"column":105},"line":487,"code":"        it('updates $stateParams and $location.search when only dynamic params change (triggered via url)', function () {\n          $location.search({ search: 's1', searchDyn: 'sd2' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect($stateParams.search).toBe('s1');\n          expect($stateParams.searchDyn).toBe('sd2');\n          expect($location.search()).toEqual({ search: 's1', searchDyn: 'sd2' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates $stateParams and $location.search when only dynamic params change (triggered via $state transition)","suites":["state",".transitionTo()","dynamic transitions","[ global $stateParams service ]"],"updatePoint":{"line":496,"column":119},"line":496,"code":"        it('updates $stateParams and $location.search when only dynamic params change (triggered via $state transition)', function () {\n          $state.go('.', { searchDyn: 'sd2' });\n          $q.flush();\n          expect($stateParams.search).toBe('s1');\n          expect($stateParams.searchDyn).toBe('sd2');\n          expect($location.search()).toEqual({ search: 's1', searchDyn: 'sd2' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"dynamic param changes can be observed by watching the global $stateParams","suites":["state",".transitionTo()","dynamic transitions","[ global $stateParams service ]"],"updatePoint":{"line":504,"column":85},"line":504,"code":"        it('dynamic param changes can be observed by watching the global $stateParams', function () {\n          let observedParamValue;\n          function stateParamsTerm() {\n            return $stateParams.searchDyn;\n          }\n          $rootScope.$watch(stateParamsTerm, function (newval, oldval) {\n            if (newval === oldval) return;\n            observedParamValue = newval;\n          });\n          $q.flush();\n\n          $location.search({ search: 's1', searchDyn: 'sd2' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect(observedParamValue).toBe('sd2');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called when dynamic parameter values change","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":523,"column":65},"line":523,"code":"        it('should be called when dynamic parameter values change', function () {\n          $state.go('.', { searchDyn: 'sd2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('searchDyn;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not be called if a non-dynamic parameter changes (causing the controller's state to exit/enter)","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":529,"column":114},"line":529,"code":"        it(\"should not be called if a non-dynamic parameter changes (causing the controller's state to exit/enter)\", function () {\n          $state.go('.', { search: 's2', searchDyn: 'sd2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not be called, when entering a new state, if no parameter values change","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":535,"column":90},"line":535,"code":"        it('should not be called, when entering a new state, if no parameter values change', function () {\n          $state.go(childNoParam);\n          $q.flush();\n          expect(paramsChangedLog).toBe('');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called, when entering a new state, if any dynamic parameter value changed","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":541,"column":95},"line":541,"code":"        it('should be called, when entering a new state, if any dynamic parameter value changed', function () {\n          $state.go(childNoParam, { searchDyn: 'sd2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('searchDyn;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called, when entering a new state, if a new parameter value is added","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":547,"column":90},"line":547,"code":"        it('should be called, when entering a new state, if a new parameter value is added', function () {\n          $state.go(childWithParam, { config: 'c2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('config,configDyn;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called, when reactivating the uiOnParamsChanged state, if a dynamic parameter changed","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":553,"column":107},"line":553,"code":"        it('should be called, when reactivating the uiOnParamsChanged state, if a dynamic parameter changed', function () {\n          initStateTo(childNoParam, { path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd1' });\n          dynlog = paramsChangedLog = '';\n\n          $state.go(dynamicstate, { pathDyn: 'pd2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('pathDyn;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not be called, when reactivating the uiOnParamsChanged state \"dyn\", if any of dyns non-dynamic parameters changed","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":562,"column":132},"line":562,"code":"        it('should not be called, when reactivating the uiOnParamsChanged state \"dyn\", if any of dyns non-dynamic parameters changed', function () {\n          initStateTo(childNoParam, { path: 'p1', pathDyn: 'pd1', search: 's1', searchDyn: 'sd1' });\n          dynlog = paramsChangedLog = '';\n\n          $state.go(dynamicstate, { path: 'p2' });\n          $q.flush();\n          expect(paramsChangedLog).toBe('');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called with an object containing only the changed params","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":571,"column":78},"line":571,"code":"        it('should be called with an object containing only the changed params', function () {\n          $state.go(dynamicstate, { pathDyn: 'pd2' });\n          $q.flush();\n          expect(dynlog).toBe('success;[pathDyn=pd2];');\n\n          $state.go(dynamicstate, { pathDyn: 'pd3', searchDyn: 'sd2' });\n          $q.flush();\n          expect(dynlog).toBe('success;[pathDyn=pd2];success;[pathDyn=pd3,searchDyn=sd2];');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be called on all active controllers that have a uiOnParamsChanged","suites":["state",".transitionTo()","dynamic transitions","[ uiOnParamsChanged ]"],"updatePoint":{"line":581,"column":84},"line":581,"code":"        it('should be called on all active controllers that have a uiOnParamsChanged', function () {\n          initStateTo(childWithParam, {\n            path: 'p1',\n            pathDyn: 'pd1',\n            search: 's1',\n            searchDyn: 'sd1',\n            config: 'p1',\n            configDyn: 'c1',\n          });\n          dynlog = paramsChangedLog = '';\n\n          $state.go(childWithParam, { pathDyn: 'pd2' });\n          $q.flush();\n          expect(dynlog).toBe('success;[pathDyn=pd2];{pathDyn=pd2};');\n\n          dynlog = paramsChangedLog = '';\n          $state.go(childWithParam, { pathDyn: 'pd2', searchDyn: 'sd2', configDyn: 'cd2' });\n          $q.flush();\n          expect(dynlog).toBe('success;[configDyn=cd2,searchDyn=sd2];{configDyn=cd2,searchDyn=sd2};');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"doesn't re-enter state (triggered by url change)","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":614,"column":60},"line":614,"code":"        it(\"doesn't re-enter state (triggered by url change)\", function () {\n          $location.search({ term: 'hello' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect($location.search()).toEqual({ term: 'hello' });\n          expect(entered).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"doesn't re-enter state (triggered by $state transition)","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":622,"column":67},"line":622,"code":"        it(\"doesn't re-enter state (triggered by $state transition)\", function () {\n          initStateTo(RS);\n          const promise = $state.go('.', { term: 'hello' });\n          let success = false,\n            transition = promise.transition;\n          transition.promise.then(function () {\n            success = true;\n          });\n          $q.flush();\n          expect($state.current).toBe(RS);\n          expect(entered).toBeFalsy();\n          expect(success).toBeTruthy();\n          expect($location.search()).toEqual({ term: 'hello' });\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates $stateParams","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":637,"column":32},"line":637,"code":"        it('updates $stateParams', function () {\n          initStateTo(RS);\n          $location.search({ term: 'hello' });\n          $rootScope.$broadcast('$locationChangeSuccess');\n          $q.flush();\n          expect(obj($stateParams)).toEqual({ term: 'hello' });\n          expect(entered).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates URL when (triggered by $state transition)","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":646,"column":61},"line":646,"code":"        it('updates URL when (triggered by $state transition)', function () {\n          initStateTo(RS);\n          $state.go('.', { term: 'goodbye' });\n          $q.flush();\n          expect(obj($stateParams)).toEqual({ term: 'goodbye' });\n          expect($location.url()).toEqual('/search?term=goodbye');\n          expect(entered).toBeFalsy();\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"ignores non-applicable state parameters","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":657,"column":47},"line":657,"code":"    it('ignores non-applicable state parameters', inject(function ($state, $q) {\n      $state.transitionTo('A', { w00t: 'hi mom!' });\n      $q.flush();\n      expect($state.current).toBe(A);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is a no-op when passing the current state and identical parameters","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":663,"column":74},"line":663,"code":"    it('is a no-op when passing the current state and identical parameters', inject(function ($state, $q) {\n      initStateTo(A);\n      const promise = $state.transitionTo(A, {}); // no-op\n      expect(promise).toBeDefined(); // but we still get a valid promise\n      $q.flush();\n      expect(resolvedValue(promise)).toBe(A);\n      expect($state.current).toBe(A);\n      expect(log).toBe('');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"aborts pending transitions (last call wins)","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":673,"column":51},"line":673,"code":"    it('aborts pending transitions (last call wins)', inject(function ($state, $q) {\n      initStateTo(A);\n      logEvents = true;\n\n      const superseded = $state.transitionTo(B, {});\n      $state.transitionTo(C, {});\n      $q.flush();\n      expect($state.current).toBe(C);\n      expect(resolvedError(superseded)).toBeTruthy();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"aborts pending transitions even when going back to the current state","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":684,"column":76},"line":684,"code":"    it('aborts pending transitions even when going back to the current state', inject(function ($state, $q) {\n      initStateTo(A);\n      logEvents = true;\n\n      const superseded = $state.transitionTo(B, {});\n      $state.transitionTo(A, {});\n      $q.flush();\n      expect($state.current).toBe(A);\n      expect(resolvedError(superseded)).toBeTruthy();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"aborts pending transitions when aborted from callbacks","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":695,"column":62},"line":695,"code":"    it('aborts pending transitions when aborted from callbacks', inject(function ($state, $q) {\n      const superseded = $state.transitionTo('home.redirect');\n      $q.flush();\n      expect($state.current.name).toBe('about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"triggers onEnter and onExit callbacks","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":701,"column":45},"line":701,"code":"    it('triggers onEnter and onExit callbacks', inject(function ($state, $q) {\n      initStateTo(A);\n      logEnterExit = true;\n      $state.transitionTo(D, {});\n      $q.flush();\n      log += $state.current.name + ';';\n      $state.transitionTo(DD, {});\n      $q.flush();\n      log += $state.current.name + ';';\n      $state.transitionTo(A, {});\n      $q.flush();\n      expect(log).toBe(\n        'A.onExit;' + 'D.onEnter;' + 'D;' + 'DD.onEnter;' + 'DD;' + 'DD.onExit;' + 'D.onExit;' + 'A.onEnter;'\n      );\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"injects resolve values from the exited state into onExit","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":718,"column":64},"line":718,"code":"    it('injects resolve values from the exited state into onExit', function (done) {\n      const registry = $uiRouter.stateRegistry;\n      registry.register({\n        name: 'design',\n        url: '/design',\n        resolve: {\n          cc: function () {\n            return 'cc resolve';\n          },\n        },\n        onExit: function (cc, $state$, $transition$) {\n          expect($transition$.to().name).toBe('A');\n          expect($transition$.from().name).toBe('design');\n\n          expect($state$).toBe(registry.get('design'));\n\n          expect(cc).toBe('cc resolve');\n\n          done();\n        },\n      });\n\n      $state.go('design');\n      $q.flush();\n\n      $state.go('A');\n      $q.flush();\n    });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"doesn't transition to parent state when child has no URL","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":747,"column":64},"line":747,"code":"    it(\"doesn't transition to parent state when child has no URL\", inject(function ($state, $q) {\n      $state.transitionTo('about.sidebar');\n      $q.flush();\n      expect($state.current.name).toEqual('about.sidebar');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"notifies on failed relative state resolution","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":753,"column":52},"line":753,"code":"    it('notifies on failed relative state resolution', inject(function ($state, $q) {\n      $state.transitionTo(DD);\n      $q.flush();\n\n      let actual,\n        err = \"Could not resolve '^.Z' from state 'DD'\";\n      $state.transitionTo('^.Z', null, { relative: $state.$current }).catch(function (err) {\n        actual = err;\n      });\n      $q.flush();\n      expect(actual.detail).toEqual(err);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"uses the templateProvider to get template dynamically","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":766,"column":61},"line":766,"code":"    it('uses the templateProvider to get template dynamically', inject(function ($state, $q) {\n      $state.transitionTo('dynamicTemplate', { type: 'Acme' });\n      $q.flush();\n      expect(template).toEqual('AcmeFooTemplate');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"uses the controllerProvider to get controller dynamically","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":772,"column":65},"line":772,"code":"    it('uses the controllerProvider to get controller dynamically', inject(function ($state, $q) {\n      $state.transitionTo('dynamicController', { type: 'Acme' });\n      $q.flush();\n      expect(ctrlName).toEqual('AcmeController');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates the location #fragment, if specified","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":778,"column":52},"line":778,"code":"    it('updates the location #fragment, if specified', inject(function ($state, $q, $location) {\n      // html5mode disabled\n      locationProvider.html5Mode(false);\n      expect(html5Compat(locationProvider.html5Mode())).toBe(false);\n      $state.transitionTo('home.item', { id: 'world', '#': 'frag' });\n      $q.flush();\n      expect($location.url()).toBe('/front/world#frag');\n      expect($location.hash()).toBe('frag');\n\n      // html5mode enabled\n      locationProvider.html5Mode(true);\n      expect(html5Compat(locationProvider.html5Mode())).toBe(true);\n      $state.transitionTo('home.item', { id: 'world', '#': 'frag' });\n      $q.flush();\n      expect($location.url()).toBe('/front/world#frag');\n      expect($location.hash()).toBe('frag');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"runs a transition when the location #fragment is updated","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":796,"column":64},"line":796,"code":"    it('runs a transition when the location #fragment is updated', inject(function (\n      $state,\n      $q,\n      $location,\n      $transitions\n    ) {\n      let transitionCount = 0;\n      $transitions.onSuccess({}, function () {\n        transitionCount++;\n      });\n\n      $state.transitionTo('home.item', { id: 'world', '#': 'frag' });\n      $q.flush();\n      expect($location.hash()).toBe('frag');\n      expect(transitionCount).toBe(1);\n\n      $state.transitionTo('home.item', { id: 'world', '#': 'blarg' });\n      $q.flush();\n      expect($location.hash()).toBe('blarg');\n      expect(transitionCount).toBe(2);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"injects $transition$ into resolves","suites":["state",".transitionTo()","(with dynamic params because reloadOnSearch=false)","and only query params changed"],"updatePoint":{"line":818,"column":42},"line":818,"code":"    it('injects $transition$ into resolves', inject(function ($state, $q) {\n      $state.transitionTo('home');\n      $q.flush();\n      $state.transitionTo('about');\n      $q.flush();\n      expect(log).toBe('home => about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"transitions to a relative state","suites":["state",".go()"],"updatePoint":{"line":828,"column":39},"line":828,"code":"    it('transitions to a relative state', inject(function ($state, $q) {\n      $state.transitionTo('about.person.item', { person: 'bob', id: 5 });\n      $q.flush();\n      $state.go('^.^.sidebar');\n      $q.flush();\n      expect($state.$current.name).toBe('about.sidebar');\n\n      // Transitions to absolute state\n      $state.go('home');\n      $q.flush();\n      expect($state.$current.name).toBe('home');\n\n      // Transition to a child state\n      $state.go('.item', { id: 5 });\n      $q.flush();\n      expect($state.$current.name).toBe('home.item');\n\n      // Transition to grandparent's sibling through root\n      // (Equivalent to absolute transition, assuming the root is known).\n      $state.go('^.^.about');\n      $q.flush();\n      expect($state.$current.name).toBe('about');\n\n      // Transition to grandchild\n      $state.go('.person.item', { person: 'bob', id: 13 });\n      $q.flush();\n      expect($state.$current.name).toBe('about.person.item');\n\n      // Transition to immediate parent\n      $state.go('^');\n      $q.flush();\n      expect($state.$current.name).toBe('about.person');\n\n      // Transition to sibling\n      $state.go('^.sidebar');\n      $q.flush();\n      expect($state.$current.name).toBe('about.sidebar');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"keeps parameters from common ancestor states","suites":["state",".go()"],"updatePoint":{"line":867,"column":52},"line":867,"code":"    it('keeps parameters from common ancestor states', inject(function ($state, $stateParams, $q) {\n      $state.transitionTo('about.person', { person: 'bob' });\n      $q.flush();\n\n      $state.go('.item', { id: '5' });\n      $q.flush();\n\n      expect($state.$current.name).toBe('about.person.item');\n      expect(obj($stateParams)).toEqual({ person: 'bob', id: '5' });\n\n      $state.go('^.^.sidebar');\n      $q.flush();\n      expect($state.$current.name).toBe('about.sidebar');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"returns a promise for the state transition","suites":["state",".reload()"],"updatePoint":{"line":884,"column":50},"line":884,"code":"    it('returns a promise for the state transition', inject(function ($state, $q) {\n      let promise = $state.transitionTo(A, {});\n      $q.flush();\n      expect($state.current.name).toBe('A');\n      expect(angular.isFunction(promise.then)).toBeTruthy();\n      expect(promise.transition.to()).toBe(A);\n\n      promise = $state.reload();\n      $q.flush();\n      expect(angular.isFunction(promise.then)).toBeTruthy();\n      expect(promise.transition.to()).toBe(A);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should reload the current state with the current parameters","suites":["state",".reload()"],"updatePoint":{"line":897,"column":67},"line":897,"code":"    it('should reload the current state with the current parameters', inject(function ($state, $q, $timeout) {\n      $state.transitionTo('resolveTimeout', { foo: 'bar' });\n      $q.flush();\n      expect(log).toBe('');\n\n      $timeout.flush();\n      expect(log).toBe('Success!');\n\n      $state.reload();\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('Success!Success!');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should invoke the controller","suites":["state",".reload()"],"updatePoint":{"line":911,"column":36},"line":911,"code":"    it('should invoke the controller', inject(function ($state, $q, $timeout, $rootScope, $compile) {\n      $compile('<div> <div ui-view/> </div>')($rootScope);\n      $state.transitionTo('resolveTimeout', { foo: 'bar' });\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('Success!controller;');\n\n      $state.reload();\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('Success!controller;Success!controller;');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should invoke the controllers by state when given state name","suites":["state",".reload()"],"updatePoint":{"line":924,"column":68},"line":924,"code":"    it('should invoke the controllers by state when given state name', inject(function (\n      $state,\n      $q,\n      $timeout,\n      $rootScope,\n      $compile\n    ) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      log = '';\n      $state.reload('logA');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      log = '';\n      $state.reload('logA.logB');\n      $q.flush();\n      expect(log).toBe('logB;logC;');\n\n      log = '';\n      $state.reload('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logC;');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not reload states when passing false","suites":["state",".reload()"],"updatePoint":{"line":952,"column":51},"line":952,"code":"    it('should not reload states when passing false', inject(function ($state, $q, $timeout, $rootScope, $compile) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      log = '';\n      $state.reload(false);\n      $q.flush();\n      expect(log).toBe('');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should reload all states when passing true","suites":["state",".reload()"],"updatePoint":{"line":964,"column":50},"line":964,"code":"    it('should reload all states when passing true', inject(function ($state, $q, $timeout, $rootScope, $compile) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      log = '';\n      $state.reload(true);\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should invoke the controllers by state when given stateObj","suites":["state",".reload()"],"updatePoint":{"line":976,"column":66},"line":976,"code":"    it('should invoke the controllers by state when given stateObj', inject(function (\n      $state,\n      $q,\n      $timeout,\n      $rootScope,\n      $compile\n    ) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      log = '';\n      $state.reload($state.current);\n      $q.flush();\n      expect(log).toBe('logC;');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should throw an exception for invalid reload state name","suites":["state",".reload()"],"updatePoint":{"line":995,"column":63},"line":995,"code":"    it('should throw an exception for invalid reload state name', inject(function (\n      $state,\n      $q,\n      $timeout,\n      $rootScope,\n      $compile\n    ) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      expect(function () {\n        $state.reload('logInvalid');\n      }).toThrowError(\"No such reload state 'logInvalid'\");\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should throw an exception for invalid reload state object","suites":["state",".reload()"],"updatePoint":{"line":1012,"column":65},"line":1012,"code":"    it('should throw an exception for invalid reload state object', inject(function (\n      $state,\n      $q,\n      $timeout,\n      $rootScope,\n      $compile\n    ) {\n      $compile('<div> <div ui-view/></div>')($rootScope);\n      $state.transitionTo('logA.logB.logC');\n      $q.flush();\n      expect(log).toBe('logA;logB;logC;');\n\n      const invalidObject = { foo: 'bar' };\n      expect(function () {\n        $state.reload(invalidObject);\n      }).toThrowError('Invalid reload state object');\n\n      expect(function () {\n        $state.reload({ name: 'invalidState' });\n      }).toThrowError(\"No such reload state 'invalidState'\");\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed","suites":["state",".is()"],"updatePoint":{"line":1036,"column":59},"line":1036,"code":"    it('should return true when the current state is passed', inject(function ($state, $q) {\n      $state.transitionTo(A);\n      $q.flush();\n      expect($state.is(A)).toBe(true);\n      expect($state.is(A, null)).toBe(true);\n      expect($state.is('A')).toBe(true);\n      expect($state.is(B)).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return undefined when queried state does not exist","suites":["state",".is()"],"updatePoint":{"line":1045,"column":65},"line":1045,"code":"    it('should return undefined when queried state does not exist', inject(function ($state) {\n      expect($state.is('Z')).toBeUndefined();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed with matching parameters","suites":["state",".is()"],"updatePoint":{"line":1049,"column":84},"line":1049,"code":"    it('should return true when the current state is passed with matching parameters', inject(function ($state, $q) {\n      $state.transitionTo(D, { x: 'foo', y: 'bar' });\n      $q.flush();\n      expect($state.is(D)).toBe(true);\n      expect($state.is(D, { x: 'foo', y: 'bar' })).toBe(true);\n      expect($state.is('D', { x: 'foo', y: 'bar' })).toBe(true);\n      expect($state.is(D, { x: 'bar', y: 'foo' })).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should work for relative states","suites":["state",".is()"],"updatePoint":{"line":1058,"column":39},"line":1058,"code":"    it('should work for relative states', inject(function ($state, $q) {\n      const options = { relative: $state.get('about') };\n\n      $state.transitionTo('about.person', { person: 'jane' });\n      $q.flush();\n      expect($state.is('.person', undefined, options)).toBe(true);\n\n      $state.transitionTo('about.person', { person: 'bob' });\n      $q.flush();\n      expect($state.is('.person', { person: 'bob' }, options)).toBe(true);\n      expect($state.is('.person', { person: 'john' }, options)).toBe(false);\n\n      options.relative = $state.get('about.person.item');\n      expect($state.is('^', undefined, options)).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed","suites":["state",".includes()"],"updatePoint":{"line":1076,"column":59},"line":1076,"code":"    it('should return true when the current state is passed', inject(function ($state, $q) {\n      $state.transitionTo(A);\n      $q.flush();\n      expect($state.includes(A)).toBe(true);\n      expect($state.includes('A')).toBe(true);\n      expect($state.includes(B)).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state's parent is passed","suites":["state",".includes()"],"updatePoint":{"line":1084,"column":68},"line":1084,"code":"    it(\"should return true when the current state's parent is passed\", inject(function ($state, $q) {\n      $state.transitionTo('about.person.item', { person: 'bob', id: 5 });\n      $q.flush();\n      expect($state.includes('about')).toBe(true);\n      expect($state.includes('about.person')).toBe(true);\n      expect($state.includes('about.sidebar')).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return undefined when queried state does not exist","suites":["state",".includes()"],"updatePoint":{"line":1092,"column":65},"line":1092,"code":"    it('should return undefined when queried state does not exist', inject(function ($state) {\n      expect($state.includes('Z')).toBeUndefined();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed with partial matching parameters","suites":["state",".includes()"],"updatePoint":{"line":1096,"column":92},"line":1096,"code":"    it('should return true when the current state is passed with partial matching parameters', inject(function (\n      $state,\n      $q\n    ) {\n      $state.transitionTo(D, { x: 'foo', y: 'bar' });\n      $q.flush();\n      expect($state.includes(D, { x: 'foo' })).toBe(true);\n      expect($state.includes(D, { y: 'bar' })).toBe(true);\n      expect($state.includes('D', { x: 'foo' })).toBe(true);\n      expect($state.includes(D, { y: 'foo' })).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed with partial matching parameters from state's parent","suites":["state",".includes()"],"updatePoint":{"line":1108,"column":112},"line":1108,"code":"    it(\"should return true when the current state is passed with partial matching parameters from state's parent\", inject(function (\n      $state,\n      $q\n    ) {\n      $state.transitionTo('about.person.item', { person: 'bob', id: 5 });\n      $q.flush();\n      expect($state.includes('about.person', { person: 'bob' })).toBe(true);\n      expect($state.includes('about.person', { person: 'steve' })).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return true when the current state is passed with partial glob patterns","suites":["state",".includes()"],"updatePoint":{"line":1118,"column":86},"line":1118,"code":"    it('should return true when the current state is passed with partial glob patterns', inject(function ($state, $q) {\n      $state.transitionTo('about.person.item', { person: 'bob', id: 5 });\n      $q.flush();\n      expect($state.includes('*.person.*')).toBe(true);\n      expect($state.includes('*.person.**')).toBe(true);\n      expect($state.includes('**.item.*')).toBe(false);\n      expect($state.includes('**.item')).toBe(true);\n      expect($state.includes('**.stuff.*')).toBe(false);\n      expect($state.includes('*.*.*')).toBe(true);\n      expect($state.includes('about.*.*')).toBe(true);\n      expect($state.includes('about.**')).toBe(true);\n      expect($state.includes('about.*.**')).toBe(true);\n      expect($state.includes('*.about.*')).toBe(false);\n      expect($state.includes('about.*.*', { person: 'bob' })).toBe(true);\n      expect($state.includes('about.*.*', { person: 'shawn' })).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should work for relative states","suites":["state",".includes()"],"updatePoint":{"line":1135,"column":39},"line":1135,"code":"    it('should work for relative states', inject(function ($state, $q) {\n      $state.transitionTo('about.person.item', { person: 'bob', id: 5 });\n      $q.flush();\n\n      expect($state.includes('.person', undefined, { relative: 'about' })).toBe(true);\n      expect($state.includes('.person', null, { relative: 'about' })).toBe(true);\n\n      expect($state.includes('^', undefined, { relative: $state.get('about.person.item') })).toBe(true);\n\n      expect($state.includes('.person', { person: 'bob' }, { relative: $state.get('about') })).toBe(true);\n      expect($state.includes('.person', { person: 'steve' }, { relative: $state.get('about') })).toBe(false);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is always defined","suites":["state",".current"],"updatePoint":{"line":1150,"column":25},"line":1150,"code":"    it('is always defined', inject(function ($state) {\n      expect($state.current).toBeDefined();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"updates asynchronously as the transitionTo() promise is resolved","suites":["state",".current"],"updatePoint":{"line":1154,"column":72},"line":1154,"code":"    it('updates asynchronously as the transitionTo() promise is resolved', inject(function ($state, $q) {\n      const trans = $state.transitionTo(A, {});\n      expect($state.current).not.toBe(A);\n      $q.flush();\n      expect($state.current).toBe(A);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is always defined","suites":["state","$current"],"updatePoint":{"line":1163,"column":25},"line":1163,"code":"    it('is always defined', inject(function ($state) {\n      expect($state.$current).toBeDefined();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"wraps the raw state object","suites":["state","$current"],"updatePoint":{"line":1167,"column":34},"line":1167,"code":"    it('wraps the raw state object', inject(function ($state) {\n      initStateTo(A);\n      expect($state.$current.data).toBe(A.data); // 'data' is reserved for app use\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"is always defined","suites":["state",".params"],"updatePoint":{"line":1174,"column":25},"line":1174,"code":"    it('is always defined', inject(function ($state) {\n      expect(obj($state.params)).toBeDefined();\n      expect(angular.isObject($state.params)).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"contains the parameter values for the current state","suites":["state",".params"],"updatePoint":{"line":1179,"column":59},"line":1179,"code":"    it('contains the parameter values for the current state', inject(function ($state, $q) {\n      initStateTo(D, { x: 'x value', z: 'invalid value' });\n      expect(obj($state.params)).toEqual({ x: 'x value', y: null });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"aborts on un-navigable states","suites":["state",".href()"],"updatePoint":{"line":1186,"column":37},"line":1186,"code":"    it('aborts on un-navigable states', inject(function ($state) {\n      expect($state.href('A')).toBeNull();\n      expect($state.href('about.sidebar', null, { lossy: false })).toBeNull();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"generates a parent state URL when lossy is true","suites":["state",".href()"],"updatePoint":{"line":1191,"column":55},"line":1191,"code":"    it('generates a parent state URL when lossy is true', inject(function ($state) {\n      expect($state.href('about.sidebar', null, { lossy: true })).toEqual('#/about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"generates a URL without parameters","suites":["state",".href()"],"updatePoint":{"line":1195,"column":42},"line":1195,"code":"    it('generates a URL without parameters', inject(function ($state) {\n      expect($state.href('home')).toEqual('#/');\n      expect($state.href('about', {})).toEqual('#/about');\n      expect($state.href('about', { foo: 'bar' })).toEqual('#/about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"generates a URL with parameters","suites":["state",".href()"],"updatePoint":{"line":1201,"column":39},"line":1201,"code":"    it('generates a URL with parameters', inject(function ($state) {\n      expect($state.href('about.person', { person: 'bob' })).toEqual('#/about/bob');\n      expect($state.href('about.person.item', { person: 'bob', id: null })).toEqual('#/about/bob/');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"inherit url parameters from current url","suites":["state",".href()"],"updatePoint":{"line":1206,"column":47},"line":1206,"code":"    it('inherit url parameters from current url', inject(function ($state) {\n      initStateTo($state.get('root'), { param1: 1 });\n      expect($state.href('root', {}, {})).toEqual('#/root?param1=1');\n      expect($state.href('root', {}, { inherit: false })).toEqual('#/root');\n      expect($state.href('root', {}, { inherit: true })).toEqual('#/root?param1=1');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"and absolute is true","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1215,"column":32},"line":1215,"code":"        it('and absolute is true', inject(function ($state, $window) {\n          const pathname = $window.location.pathname;\n          $window.history.replaceState(null, '', '/');\n          expect($window.location.pathname).toBe('/');\n          expect($state.href('about.sidebar', null, { absolute: true })).toEqual('http://server/#/about');\n          $window.history.replaceState(null, '', pathname);\n        }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"and absolute is true and a base tag is present","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1223,"column":58},"line":1223,"code":"        it('and absolute is true and a base tag is present', inject(function ($state, $window, $browser) {\n          spyOn($browser, 'baseHref').and.returnValue('/nested/path');\n          expect($state.href('about.sidebar', null, { absolute: true })).toEqual('http://server/nested/path#/about');\n        }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"and absolute is true and the app is served from a nested document root","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1228,"column":82},"line":1228,"code":"        it('and absolute is true and the app is served from a nested document root', inject(function (\n          $state,\n          $window,\n          $browser\n        ) {\n          const pathname = $window.location.pathname;\n          $window.history.replaceState(null, 'nested path', '/nested/path');\n          expect($window.location.pathname).toBe('/nested/path');\n          spyOn($browser, 'baseHref').and.returnValue(null);\n          expect($state.href('about.sidebar', null, { absolute: true })).toEqual('http://server/nested/path#/about');\n          $window.history.replaceState(null, '', pathname);\n        }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"when html5Mode is true","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1242,"column":32},"line":1242,"code":"      it('when html5Mode is true', inject(function ($state) {\n        locationProvider.html5Mode(true);\n        expect($state.href('about.sidebar', null, { absolute: true })).toEqual('http://server/about');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"respects $locationProvider.hashPrefix()","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1248,"column":47},"line":1248,"code":"    it('respects $locationProvider.hashPrefix()', inject(function ($state) {\n      locationProvider.hashPrefix('!');\n      expect($state.href('home')).toEqual('#!/');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"generates urls with unsquashable default params","suites":["state",".href()","generates an absolute url","when html5mode is false"],"updatePoint":{"line":1253,"column":55},"line":1253,"code":"    it('generates urls with unsquashable default params', inject(function ($state) {\n      expect($state.href('ISS2101')).toEqual('#/2101/qux');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"does not prepend relative urls","suites":["state",".href()","when $browser.baseHref() exists"],"updatePoint":{"line":1264,"column":40},"line":1264,"code":"      it('does not prepend relative urls', inject(function ($state) {\n        expect($state.href('home')).toEqual('#/');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"prepends absolute urls","suites":["state",".href()","when $browser.baseHref() exists"],"updatePoint":{"line":1268,"column":32},"line":1268,"code":"      it('prepends absolute urls', inject(function ($state) {\n        expect($state.href('home', null, { absolute: true })).toEqual('http://server/base/#/');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"prepends relative and absolute urls in html5Mode","suites":["state",".href()","when $browser.baseHref() exists"],"updatePoint":{"line":1272,"column":58},"line":1272,"code":"      it('prepends relative and absolute urls in html5Mode', inject(function ($state) {\n        locationProvider.html5Mode(true);\n        expect($state.href('home')).toEqual('/base/');\n        expect($state.href('home', null, { absolute: true })).toEqual('http://server/base/');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return the state's config","suites":["state",".get()"],"updatePoint":{"line":1281,"column":40},"line":1281,"code":"    it(\"should return the state's config\", inject(function ($state) {\n      expect($state.get('home').url).toBe('/');\n      expect($state.get('home.item').url).toBe('front/:id');\n      expect($state.get('A')).toBe(A);\n      expect($state.get('Z')).toBeNull();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return all of the state's config","suites":["state",".get()"],"updatePoint":{"line":1288,"column":47},"line":1288,"code":"    it(\"should return all of the state's config\", inject(function ($state) {\n      const list = $state.get().sort((a, b) => a.name.localeCompare(b.name));\n      const names = [\n        '',\n        'A',\n        'B',\n        'C',\n        'D',\n        'DD',\n        'DDDD',\n        'E',\n        'F',\n        'H',\n        'HH',\n        'HHH',\n        'ISS2101',\n        'OPT',\n        'OPT.OPT2',\n        'RS',\n        'URLLESS',\n        'about',\n        'about.person',\n        'about.person.item',\n        'about.sidebar',\n        'about.sidebar.item',\n        'badParam',\n        'badParam2',\n        'dynamicController',\n        'dynamicTemplate',\n        'first',\n        'home',\n        'home.item',\n        'home.redirect',\n        'json',\n        'logA',\n        'logA.logB',\n        'logA.logB.logC',\n        'resolveFail',\n        'resolveTimeout',\n        'root',\n        'root.sub1',\n        'root.sub2',\n        'second',\n      ];\n\n      expect(\n        list\n          .map(function (state) {\n            return state.name;\n          })\n          .sort()\n      ).toEqual(names.sort());\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should work for relative states","suites":["state",".get()"],"updatePoint":{"line":1342,"column":39},"line":1342,"code":"    it('should work for relative states', inject(function ($state) {\n      const about = $state.get('about');\n\n      const person = $state.get('.person', about);\n      expect(person.url).toBe('/:person');\n      expect($state.get('^', 'about.person').url).toBe('/about');\n\n      const item = $state.get('.person.item', about);\n      expect(item.url).toBe('/:id');\n      expect($state.get('^.^', item).url).toBe('/about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return undefined on invalid state query","suites":["state",".get()"],"updatePoint":{"line":1354,"column":54},"line":1354,"code":"    it('should return undefined on invalid state query', inject(function ($state) {\n      expect($state.get(null)).toBeNull();\n      expect($state.get(false)).toBeNull();\n      expect($state.get(undefined)).toBeNull();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be populated during transition, if unspecified","suites":["state","optional parameters"],"updatePoint":{"line":1362,"column":61},"line":1362,"code":"    it('should be populated during transition, if unspecified', inject(function ($state, $transitions, $q) {\n      let stateParams;\n      $transitions.onEnter({ entering: 'OPT' }, function (trans) {\n        stateParams = trans.params();\n      });\n      $state.go('OPT');\n      $q.flush();\n      expect($state.current.name).toBe('OPT');\n      expect(obj($state.params)).toEqual({ param: '100' });\n      expect(obj(stateParams)).toEqual({ param: '100' });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow null default value for non-url params","suites":["state","optional parameters"],"updatePoint":{"line":1374,"column":58},"line":1374,"code":"    it('should allow null default value for non-url params', inject(function ($state, $q) {\n      $state.go('D');\n      $q.flush();\n      expect($state.current.name).toBe('D');\n      expect(obj($state.params)).toEqual({ x: null, y: null });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow falsy default values for non-url params","suites":["state","optional parameters"],"updatePoint":{"line":1381,"column":60},"line":1381,"code":"    it('should allow falsy default values for non-url params', inject(function ($state, $q) {\n      $state.go('F');\n      $q.flush();\n      expect($state.current.name).toBe('F');\n      expect(obj($state.params)).toEqual({ a: '', b: false, c: 0, d: undefined, e: -1 });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow arbitrary objects to pass for non-url params","suites":["state","optional parameters"],"updatePoint":{"line":1388,"column":65},"line":1388,"code":"    it('should allow arbitrary objects to pass for non-url params', inject(function ($state, $q) {\n      $state.go('D', { x: 100, y: { foo: 'bar' } });\n      $q.flush();\n      expect($state.current.name).toBe('D');\n      expect(obj($state.params)).toEqual({ x: 100, y: { foo: 'bar' } });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be populated during primary transition, if unspecified","suites":["state","optional parameters"],"updatePoint":{"line":1395,"column":69},"line":1395,"code":"    it('should be populated during primary transition, if unspecified', inject(function ($state, $transitions, $q) {\n      let count = 0;\n      $transitions.onEnter({ entering: 'OPT' }, function () {\n        count++;\n      });\n      $state.go('OPT');\n      $q.flush();\n      expect($state.current.name).toBe('OPT');\n      expect(obj($state.params)).toEqual({ param: '100' });\n      expect(count).toEqual(1);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow mixed URL and config params","suites":["state","optional parameters"],"updatePoint":{"line":1407,"column":48},"line":1407,"code":"    it('should allow mixed URL and config params', inject(function ($state, $transitions, $q) {\n      let count = 0;\n      $transitions.onEnter({ entering: 'OPT' }, function () {\n        count++;\n      });\n      $transitions.onEnter({ entering: 'OPT.OPT2' }, function () {\n        count++;\n      });\n      $state.go('OPT');\n      $q.flush();\n      expect($state.current.name).toBe('OPT');\n      expect(obj($state.params)).toEqual({ param: '100' });\n      expect(count).toEqual(1);\n\n      $state.go('OPT.OPT2', { param2: 200 });\n      $q.flush();\n      expect($state.current.name).toBe('OPT.OPT2');\n      expect(obj($state.params)).toEqual({ param: '100', param2: '200', param3: '300', param4: '400' });\n      expect(count).toEqual(2);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should cause transition failure, when unspecified.","suites":["state","non-optional parameters"],"updatePoint":{"line":1431,"column":58},"line":1431,"code":"    it('should cause transition failure, when unspecified.', inject(function (\n      $state,\n      $transitions,\n      $q,\n      $exceptionHandler\n    ) {\n      $exceptionHandler.disabled = true;\n\n      let count = 0;\n      $transitions.onEnter({ entering: 'OPT' }, function () {\n        count++;\n      });\n      $transitions.onEnter({ entering: 'OPT.OPT2' }, function () {\n        count++;\n      });\n      $state.go('OPT');\n      $q.flush();\n      expect($state.current.name).toBe('OPT');\n      expect(obj($state.params)).toEqual({ param: '100' });\n      expect(count).toEqual(1);\n\n      $state.go('OPT.OPT2'); // no, because missing non-optional param2\n      $q.flush();\n      expect($state.current.name).toBe('OPT');\n      expect(obj($state.params)).toEqual({ param: '100' });\n      expect(count).toEqual(1);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should transition to the same state with different parameters","suites":["state","url handling"],"updatePoint":{"line":1461,"column":69},"line":1461,"code":"    it('should transition to the same state with different parameters', inject(function (\n      $state,\n      $rootScope,\n      $location\n    ) {\n      $location.path('/about/bob');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n      expect(obj($state.params)).toEqual({ person: 'bob' });\n      expect($state.current.name).toBe('about.person');\n\n      $location.path('/about/larry');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n      expect(obj($state.params)).toEqual({ person: 'larry' });\n      expect($state.current.name).toBe('about.person');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"preserve hash","suites":["state","url handling"],"updatePoint":{"line":1479,"column":21},"line":1479,"code":"    it('preserve hash', inject(function ($state, $rootScope, $location) {\n      $location.path('/about/bob');\n      $location.hash('frag');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n      expect(extend({}, $state.params)).toEqual({ '#': 'frag', person: 'bob' });\n      expect($state.current.name).toBe('about.person');\n      expect($location.path()).toBe('/about/bob');\n      expect($location.hash()).toBe('frag');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should correctly handle absolute urls","suites":["state","url handling"],"updatePoint":{"line":1490,"column":45},"line":1490,"code":"    it('should correctly handle absolute urls', inject(function ($state, $rootScope, $location) {\n      $location.path('/first/subpath');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n      expect($state.current.name).toBe('first');\n\n      $state.transitionTo('second');\n      $rootScope.$apply();\n      expect($state.current.name).toBe('second');\n      expect($location.path()).toBe('/second');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should ignore bad urls","suites":["state","url handling"],"updatePoint":{"line":1502,"column":30},"line":1502,"code":"    it('should ignore bad urls', inject(function ($state, $rootScope, $location) {\n      $location.path('/first/second');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n      expect($state.current.name).toBe('');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.go once","suites":["state","url handling","slashes in parameter values","with no \"/\" in the params"],"updatePoint":{"line":1537,"column":38},"line":1537,"code":"        it('should call $state.go once', function () {\n          expect($state.go.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.transitionTo once","suites":["state","url handling","slashes in parameter values","with no \"/\" in the params"],"updatePoint":{"line":1540,"column":48},"line":1540,"code":"        it('should call $state.transitionTo once', function () {\n          expect($state.transitionTo.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call myController once","suites":["state","url handling","slashes in parameter values","with no \"/\" in the params"],"updatePoint":{"line":1543,"column":41},"line":1543,"code":"        it('should call myController once', function () {\n          expect(log).toBe('myController;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.go once","suites":["state","url handling","slashes in parameter values","with a \"/\" in the params"],"updatePoint":{"line":1553,"column":38},"line":1553,"code":"        it('should call $state.go once', function () {\n          expect($state.go.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.transitionTo once","suites":["state","url handling","slashes in parameter values","with a \"/\" in the params"],"updatePoint":{"line":1556,"column":48},"line":1556,"code":"        it('should call $state.transitionTo once', function () {\n          expect($state.transitionTo.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call myController once","suites":["state","url handling","slashes in parameter values","with a \"/\" in the params"],"updatePoint":{"line":1559,"column":41},"line":1559,"code":"        it('should call myController once', function () {\n          expect(log).toBe('myController;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.go once","suites":["state","url handling","slashes in parameter values","with an encoded \"/\" in the params"],"updatePoint":{"line":1569,"column":38},"line":1569,"code":"        it('should call $state.go once', function () {\n          expect($state.go.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call $state.transitionTo once","suites":["state","url handling","slashes in parameter values","with an encoded \"/\" in the params"],"updatePoint":{"line":1572,"column":48},"line":1572,"code":"        it('should call $state.transitionTo once', function () {\n          expect($state.transitionTo.calls.count()).toBe(1);\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should call myController once","suites":["state","url handling","slashes in parameter values","with an encoded \"/\" in the params"],"updatePoint":{"line":1575,"column":41},"line":1575,"code":"        it('should call myController once', function () {\n          expect(log).toBe('myController;');\n        });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should initialize parameters without a hacky empty test","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1642,"column":65},"line":1642,"code":"      it('should initialize parameters without a hacky empty test', inject(function ($urlMatcherFactory, $state) {\n        new UrlMatcher('', null, null, null);\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should ignore bad url parameters","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1646,"column":42},"line":1646,"code":"      it('should ignore bad url parameters', inject(function ($state, $rootScope, $location, $urlMatcherFactory) {\n        $location.path('/bad/5');\n        $rootScope.$broadcast('$locationChangeSuccess');\n        $rootScope.$apply();\n        expect($state.current.name).toBe('badParam');\n\n        $state.transitionTo('about');\n        $rootScope.$apply();\n        expect($state.current.name).toBe('about');\n\n        $location.path('/bad/foo');\n        $rootScope.$broadcast('$locationChangeSuccess');\n        $rootScope.$apply();\n        expect($state.current.name).toBe('about');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should ignore bad state parameters","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1662,"column":44},"line":1662,"code":"      it('should ignore bad state parameters', inject(function (\n        $state,\n        $rootScope,\n        $location,\n        $stateParams,\n        $exceptionHandler\n      ) {\n        $exceptionHandler.disabled = true;\n\n        $state.go('badParam', { param: 5 });\n        $rootScope.$apply();\n        expect($state.current.name).toBe('badParam');\n        expect(obj($stateParams)).toEqual({ param: 5 });\n\n        $state.go('badParam2', { param: '12345' }); // must be 5 digits\n        $rootScope.$apply();\n        expect($state.current.name).toBe('badParam2');\n\n        $state.go('about');\n        $rootScope.$apply();\n        expect($state.current.name).toBe('about');\n\n        $state.go('badParam', { param: 'foo' });\n        $rootScope.$apply();\n        expect($state.current.name).toBe('about');\n\n        $state.go('badParam2', { param: '1234' }); // must be 5 digits\n        $rootScope.$apply();\n        expect($state.current.name).toBe('about');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow param objects containing $scope","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1694,"column":54},"line":1694,"code":"      it('should allow param objects containing $scope', inject(function ($state, $q, $rootScope, $transitions) {\n        const errorhandler = jasmine.createSpy('errorhandler');\n        $state.defaultErrorHandler(errorhandler);\n\n        $state.go('types', { nonurl: { errorscope: $rootScope } });\n        $q.flush();\n\n        expect(errorhandler).not.toHaveBeenCalled();\n        expect($state.params.nonurl && $state.params.nonurl.errorscope).toBe($rootScope);\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map default param values to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1705,"column":86},"line":1705,"code":"      it('should map default param values to/from the $location.url() and $stateParams', function () {\n        checkStateUrl('types', '/types/defaultValue/2014-11-15', {}, defaults);\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should combine and map params and default param values to/from the $location.url() and $stateParams, except for nonurl params","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1709,"column":135},"line":1709,"code":"      it('should combine and map params and default param values to/from the $location.url() and $stateParams, except for nonurl params', function () {\n        const params = { p1: ['foo'] };\n        const nonurl = { nonurl: { foo: 'bar' } };\n        checkStateUrl('types', '/types/foo/2014-11-15', params, defaults, nonurl);\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map json param values to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1715,"column":83},"line":1715,"code":"      it('should map json param values to/from the $location.url() and $stateParams', function () {\n        const params = { p4: { baz: 'qux' } };\n        checkStateUrl(\n          'types.substate',\n          '/types/defaultValue/2014-11-15/sub/a/%7B%22baz%22:%22qux%22%7D',\n          params,\n          substateDefaults\n        );\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should combine and map array default param values and normal param values to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1725,"column":128},"line":1725,"code":"      it('should combine and map array default param values and normal param values to/from the $location.url() and $stateParams', function () {\n        const params = { p1: ['foo'], p2: nov15, p4: { baz: 'qux' } };\n        checkStateUrl(\n          'types.substate',\n          '/types/foo/2014-11-15/sub/a/%7B%22baz%22:%22qux%22%7D',\n          params,\n          substateDefaults\n        );\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map array default param values to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1735,"column":92},"line":1735,"code":"      it('should map array default param values to/from the $location.url() and $stateParams', function () {\n        checkStateUrl('types.substate', '/types/defaultValue/2014-11-15/sub/a/null', {}, substateDefaults);\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map multi-value array default param values to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1739,"column":104},"line":1739,"code":"      it('should map multi-value array default param values to/from the $location.url() and $stateParams', function () {\n        const params = { 'p3[]': ['a', 'b'] };\n        const arrayDefaults = extend({}, substateDefaults, params);\n        checkStateUrl('types.substate', '/types/defaultValue/2014-11-15/sub/a-b/null', params, arrayDefaults);\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map boolean as integers to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1745,"column":85},"line":1745,"code":"      it('should map boolean as integers to/from the $location.url() and $stateParams', function () {\n        const params = { p5: true };\n        checkStateUrl('types.substate', '/types/defaultValue/2014-11-15/sub/a/null?p5=1', params, substateDefaults);\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should map all the things to/from the $location.url() and $stateParams","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1750,"column":80},"line":1750,"code":"      it('should map all the things to/from the $location.url() and $stateParams', function () {\n        const params = { p1: ['foo'], p4: { baz: 'qux' }, p5: true };\n        checkStateUrl(\n          'types.substate',\n          '/types/foo/2014-11-15/sub/a/%7B%22baz%22:%22qux%22%7D?p5=1',\n          params,\n          substateDefaults\n        );\n      });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should support non-url parameters","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1760,"column":43},"line":1760,"code":"      it('should support non-url parameters', inject(function ($state, $q, $stateParams) {\n        $state.transitionTo(A);\n        $q.flush();\n        expect($state.is(A)).toBe(true);\n\n        $state.go('URLLESS', { myparam: '0' });\n        $q.flush(); // string \"0\" decodes to 0\n        expect($state.current.name).toBe('URLLESS');\n        expect($stateParams.myparam).toBe(0);\n\n        $state.go('URLLESS', { myparam: '1' });\n        $q.flush(); // string \"1\" decodes to 1\n        expect($stateParams.myparam).toBe(1);\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition if a required non-url parameter is missing","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1775,"column":74},"line":1775,"code":"      it('should not transition if a required non-url parameter is missing', inject(function (\n        $state,\n        $q,\n        $exceptionHandler\n      ) {\n        $exceptionHandler.disabled = true;\n\n        $state.transitionTo(A);\n        $q.flush();\n        expect($state.current.name).toBe('A');\n\n        $state.go('URLLESS');\n        $q.flush(); // Missing required parameter; transition fails\n        expect($state.current.name).toBe('A');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not transition if a required non-url parameter is invalid","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1791,"column":74},"line":1791,"code":"      it('should not transition if a required non-url parameter is invalid', inject(function (\n        $state,\n        $q,\n        $exceptionHandler\n      ) {\n        $exceptionHandler.disabled = true;\n\n        $state.transitionTo(A);\n        $q.flush();\n        expect($state.current.name).toBe('A');\n\n        $state.go('URLLESS', { myparam: 'somestring' });\n        $q.flush(); // string \"somestring\" is not an int\n        expect($state.current.name).toBe('A');\n      }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should revert to last known working url on state change failure","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1808,"column":71},"line":1808,"code":"    it('should revert to last known working url on state change failure', inject(function (\n      $state,\n      $rootScope,\n      $location,\n      $q\n    ) {\n      $state.transitionTo('about');\n      $q.flush();\n\n      $location.path('/resolve-fail');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n\n      expect($state.current.name).toBe('about');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not revert to last known working url on state change failure","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1824,"column":75},"line":1824,"code":"    it('should not revert to last known working url on state change failure', inject(function (\n      $state,\n      $rootScope,\n      $location,\n      $q\n    ) {\n      $state.transitionTo('about');\n      $q.flush();\n\n      //$rootScope.$on(\"$stateChangeError\", function(event){\n      //    event.defaultPrevented = true;\n      //});\n\n      $location.path('/resolve-fail');\n      $rootScope.$broadcast('$locationChangeSuccess');\n      $rootScope.$apply();\n\n      expect($location.path()).toBe('/resolve-fail');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should replace browser history when \"replace\" enabled","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1844,"column":61},"line":1844,"code":"    it('should replace browser history when \"replace\" enabled', inject(function ($state, $rootScope, $location, $q) {\n      spyOn($uiRouter.locationService, 'url');\n\n      $state.transitionTo('about', {}, { location: 'replace' });\n      $q.flush();\n\n      expect($uiRouter.locationService.url).toHaveBeenCalled();\n      expect($uiRouter.locationService.url.calls.argsFor(0)[1]).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not replace history normally","suites":["state","url handling","typed parameter handling"],"updatePoint":{"line":1854,"column":43},"line":1854,"code":"    it('should not replace history normally', inject(function ($state, $rootScope, $location, $q) {\n      spyOn($location, 'replace');\n\n      $state.transitionTo('about');\n      $q.flush();\n\n      expect($location.replace).not.toHaveBeenCalled();\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should stay immutable for if state doesn't have parent","suites":["state","\"data\" property inheritance/override"],"updatePoint":{"line":1865,"column":62},"line":1865,"code":"    it(\"should stay immutable for if state doesn't have parent\", inject(function ($state) {\n      initStateTo(H);\n      expect($state.current.name).toEqual('H');\n      expect($state.current.data.propA).toEqual(H.data.propA);\n      expect($state.current.data.propB).toEqual(H.data.propB);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be inherited from parent if state doesn't define it","suites":["state","\"data\" property inheritance/override"],"updatePoint":{"line":1872,"column":66},"line":1872,"code":"    it(\"should be inherited from parent if state doesn't define it\", inject(function ($state) {\n      initStateTo(HH);\n      expect($state.current.name).toEqual('HH');\n      expect($state.current.data.propA).toEqual(H.data.propA);\n      expect($state.current.data.propB).toEqual(H.data.propB);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be overridden/extended if state defines it","suites":["state","\"data\" property inheritance/override"],"updatePoint":{"line":1879,"column":57},"line":1879,"code":"    it('should be overridden/extended if state defines it', inject(function ($state) {\n      initStateTo(HHH);\n      expect($state.current.name).toEqual('HHH');\n      expect($state.current.data.propA).toEqual(HHH.data.propA);\n      expect($state.current.data.propB).toEqual(H.data.propB);\n      expect($state.current.data.hasOwnProperty('propB')).toBe(false);\n      expect($state.current.data.propB).toEqual(HH.data.propB);\n      expect($state.current.data.propC).toEqual(HHH.data.propC);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should inherit the parent param","suites":["state","substate and stateParams inheritance"],"updatePoint":{"line":1891,"column":39},"line":1891,"code":"    it('should inherit the parent param', inject(function ($state, $stateParams, $q) {\n      initStateTo($state.get('root'), { param1: 1 });\n      $state.go('root.sub1', { param2: 2 });\n      $q.flush();\n      expect($state.current.name).toEqual('root.sub1');\n      expect(obj($stateParams)).toEqual({ param1: '1', param2: '2' });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not inherit siblings' states","suites":["state","substate and stateParams inheritance"],"updatePoint":{"line":1899,"column":43},"line":1899,"code":"    it(\"should not inherit siblings' states\", inject(function ($state, $stateParams, $q) {\n      initStateTo($state.get('root'), { param1: 1 });\n      $state.go('root.sub1', { param2: 2 });\n      $q.flush();\n      expect($state.current.name).toEqual('root.sub1');\n\n      $state.go('root.sub2');\n      $q.flush();\n      expect($state.current.name).toEqual('root.sub2');\n\n      expect(obj($stateParams)).toEqual({ param1: '1', param2: undefined });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should generate non-hashbang URLs in HTML5 mode","suites":["state","html5Mode compatibility"],"updatePoint":{"line":1914,"column":55},"line":1914,"code":"    it('should generate non-hashbang URLs in HTML5 mode', inject(function ($state) {\n      expect($state.href('about.person', { person: 'bob' })).toEqual('#/about/bob');\n      locationProvider.html5Mode(true);\n      expect($state.href('about.person', { person: 'bob' })).toEqual('/about/bob');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should always have a name","suites":["state","default properties"],"updatePoint":{"line":1922,"column":33},"line":1922,"code":"    it('should always have a name', inject(function ($state, $q) {\n      $state.transitionTo(A);\n      $q.flush();\n      expect($state.$current.name).toBe('A');\n      expect($state.$current.toString()).toBe('A');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should include itself and parent states","suites":["state","default properties"],"updatePoint":{"line":1929,"column":47},"line":1929,"code":"    it('should include itself and parent states', inject(function ($state, $q) {\n      $state.transitionTo(DD);\n      $q.flush();\n      expect($state.$current.includes).toEqual({ '': true, D: true, DD: true });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should inject $stateParams into templateUrl function","suites":["state","template handling"],"updatePoint":{"line":1937,"column":60},"line":1937,"code":"    it('should inject $stateParams into templateUrl function', inject(function ($state, $q, $httpBackend) {\n      $httpBackend.expectGET('/templates/foo.html').respond('200');\n      $state.transitionTo('about.sidebar.item', { item: 'foo' });\n      $q.flush();\n      expect(obj(templateParams)).toEqual({ item: 'foo' });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should return built-in decorators","suites":["state","provider decorators"],"updatePoint":{"line":1946,"column":41},"line":1946,"code":"    it('should return built-in decorators', inject(function ($state) {\n      expect($stateProvider.decorator('parent')({ parent: A }).self.name).toBe('A');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow built-in decorators to be overridden","suites":["state","provider decorators"],"updatePoint":{"line":1950,"column":57},"line":1950,"code":"    it('should allow built-in decorators to be overridden', inject(function ($state, $q) {\n      $stateProvider.decorator('data', function (state) {\n        return angular.extend(state.data || {}, { foo: 'bar' });\n      });\n      $stateProvider.state('AA', { parent: A, data: { baz: 'true' } });\n\n      $state.transitionTo('AA');\n      $q.flush();\n      expect($state.current.data).toEqual({ baz: 'true', foo: 'bar' });\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow new decorators to be added","suites":["state","provider decorators"],"updatePoint":{"line":1961,"column":47},"line":1961,"code":"    it('should allow new decorators to be added', inject(function ($state, $q) {\n      $stateProvider.decorator('custom', function (state) {\n        return function () {\n          return \"Custom functionality for state '\" + state + \"'\";\n        };\n      });\n      $stateProvider.state('decoratorTest', {});\n\n      $state.transitionTo('decoratorTest');\n      $q.flush();\n      expect($state.$current.custom()).toBe(\"Custom functionality for state 'decoratorTest'\");\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow built-in decorators to be extended","suites":["state","provider decorators"],"updatePoint":{"line":1974,"column":55},"line":1974,"code":"    it('should allow built-in decorators to be extended', inject(function ($state, $q, $httpBackend) {\n      $stateProvider.decorator('views', function (state, parent) {\n        const result = {};\n\n        const views = parent(state);\n        forEach(views, function (config, name) {\n          result[name] = angular.extend(config, {\n            templateProvider: function () {\n              return 'Template for ' + name;\n            },\n          });\n          delete result[name].template;\n        });\n        return result;\n      });\n\n      $stateProvider.state('viewTest', {\n        views: {\n          'viewA@': { template: '<div/>' },\n          'viewB@': { template: '<div/>' },\n        },\n      });\n\n      $state.transitionTo('viewTest');\n      $q.flush();\n\n      expect($state.$current.views['viewA@'].templateProvider()).toBe('Template for viewA@');\n      expect($state.$current.views['viewB@'].templateProvider()).toBe('Template for viewB@');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should invoke multiple decorators, if exist","suites":["state","provider decorators"],"updatePoint":{"line":2004,"column":51},"line":2004,"code":"    it('should invoke multiple decorators, if exist', inject(function ($state, $q, $httpBackend) {\n      const d = { d1: false, d2: false };\n      function decorator1(state, parent) {\n        d.d1 = true;\n        return parent(state);\n      }\n      function decorator2(state, parent) {\n        d.d2 = true;\n        return parent(state);\n      }\n\n      $stateProvider.decorator('parent', decorator1);\n      $stateProvider.decorator('parent', decorator2);\n\n      $stateProvider.state({ name: 'test', parent: A });\n      $state.go('test');\n      $q.flush();\n\n      expect($state.$current.name).toBe('test');\n      expect($state.$current.parent.name).toBe('A');\n      expect(d.d1).toBe(true);\n      expect(d.d2).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow any decorator to short circuit the chain","suites":["state","provider decorators"],"updatePoint":{"line":2028,"column":61},"line":2028,"code":"    it('should allow any decorator to short circuit the chain', inject(function ($state, $q, $httpBackend) {\n      const d = { d1: false, d2: false };\n      function decorator1(state, parent) {\n        d.d1 = true;\n        return parent(state);\n      }\n      function decorator2(state, parent) {\n        d.d2 = true;\n        return {};\n      }\n\n      $stateProvider.decorator('data', decorator1);\n      $stateProvider.decorator('data', decorator2);\n\n      $stateProvider.state({ name: 'test', data: { x: 1 } });\n      $state.go('test');\n      $q.flush();\n\n      expect($state.$current.name).toBe('test');\n      expect($state.$current.data.x).toBeUndefined();\n      expect(d.d1).toBe(false);\n      expect(d.d2).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow any decorator to modify the return value of the parent","suites":["state","provider decorators"],"updatePoint":{"line":2052,"column":75},"line":2052,"code":"    it('should allow any decorator to modify the return value of the parent', inject(function (\n      $state,\n      $q,\n      $httpBackend\n    ) {\n      const d = { d1: false, d2: false };\n      function decorator1(state, parent) {\n        d.d1 = true;\n        return angular.extend(parent(state), { y: 2 });\n      }\n      function decorator2(state, parent) {\n        d.d2 = true;\n        return angular.extend(parent(state), { z: 3 });\n      }\n\n      $stateProvider.decorator('data', decorator1);\n      $stateProvider.decorator('data', decorator2);\n\n      $stateProvider.state({ name: 'test', data: { x: 1 } });\n      $state.go('test');\n      $q.flush();\n\n      expect($state.$current.name).toBe('test');\n      expect($state.$current.data).toEqual({ x: 1, y: 2, z: 3 });\n      expect(d.d1).toBe(true);\n      expect(d.d2).toBe(true);\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should work across modules","suites":["state queue"],"updatePoint":{"line":2096,"column":32},"line":2096,"code":"  it('should work across modules', function () {\n    module('ui.router.queue.test', 'ui.router.queue.test.dependency');\n\n    inject(function ($state) {\n      const list = $state.get().sort((a, b) => a.name.localeCompare(b.name));\n      expect(\n        list.map(function (state) {\n          return state.name;\n        })\n      ).toEqual(expectedStates);\n    });\n  });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should work when parent is name string","suites":["state queue"],"updatePoint":{"line":2109,"column":44},"line":2109,"code":"  it('should work when parent is name string', function () {\n    module('ui.router.queue.test', 'ui.router.queue.test.dependency');\n\n    inject(function ($state) {\n      const list = $state.get().sort((a, b) => a.name.localeCompare(b.name));\n      expect(\n        list.map(function (state) {\n          return state.name;\n        })\n      ).toEqual(expectedStates);\n    });\n  });","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target the unnamed ui-view in the parent context, when the view's name is '$default'","suites":["Targeted Views","view targeting"],"updatePoint":{"line":2207,"column":99},"line":2207,"code":"    it(\"should target the unnamed ui-view in the parent context, when the view's name is '$default'\", inject(function () {\n      $state.go('A.a.i');\n      $q.flush();\n      expect(elem[0].querySelector('#Aa_default').textContent).toBe('asdf');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should relatively target a ui-view in the grandparent context, when the viewname starts with '^.'","suites":["Targeted Views","view targeting"],"updatePoint":{"line":2213,"column":105},"line":2213,"code":"    it(\"should relatively target a ui-view in the grandparent context, when the viewname starts with '^.'\", inject(function () {\n      $state.go('A.a.i');\n      $q.flush();\n      expect(elem[0].querySelector('#Aa_named2').textContent).toBe('A.a.i');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should relatively target a ui-view in the great-grandparent context, when the viewname starts with '^.^.'","suites":["Targeted Views","view targeting"],"updatePoint":{"line":2219,"column":113},"line":2219,"code":"    it(\"should relatively target a ui-view in the great-grandparent context, when the viewname starts with '^.^.'\", inject(function () {\n      $state.go('A.a.i.1');\n      $q.flush();\n      expect(elem[0].querySelector('#named_A').textContent).toBe('A.a.i.1');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target the root ui-view, when the view's name is '!$default'","suites":["Targeted Views","view targeting"],"updatePoint":{"line":2225,"column":75},"line":2225,"code":"    it(\"should target the root ui-view, when the view's name is '!$default'\", inject(function () {\n      $state.go('A.a.i.2');\n      $q.flush();\n      expect(elem[0].textContent).toBe('rooted!');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target a ui-view absolutely using the ui-view's FQN when the view name is preceded by the '!' character","suites":["Targeted Views","view targeting"],"updatePoint":{"line":2231,"column":118},"line":2231,"code":"    it(\"should target a ui-view absolutely using the ui-view's FQN when the view name is preceded by the '!' character\", inject(function () {\n      $state.go('A.a.i.3');\n      $q.flush();\n      expect(elem[0].querySelector('#named_A').textContent).toBe('fhqwhgads');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target the unnamed ui-view in the parent context, when the view's name is ''","suites":["Targeted Views","with view@context style view targeting"],"updatePoint":{"line":2239,"column":91},"line":2239,"code":"    it(\"should target the unnamed ui-view in the parent context, when the view's name is ''\", inject(function () {\n      $state.go('A.b.i');\n      $q.flush();\n      expect(elem[0].querySelector('#Ab_default').textContent).toBe('asdf');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target a ui-view named 'named2' at the context named 'A.b' when the view's name is 'named2@A.b'","suites":["Targeted Views","with view@context style view targeting"],"updatePoint":{"line":2245,"column":110},"line":2245,"code":"    it(\"should target a ui-view named 'named2' at the context named 'A.b' when the view's name is 'named2@A.b'\", inject(function () {\n      $state.go('A.b.i');\n      $q.flush();\n      expect(elem[0].querySelector('#Ab_named2').textContent).toBe('A.b.i');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target a ui-view named 'named' at the context named 'A' when the view's name is 'named@A'","suites":["Targeted Views","with view@context style view targeting"],"updatePoint":{"line":2251,"column":104},"line":2251,"code":"    it(\"should target a ui-view named 'named' at the context named 'A' when the view's name is 'named@A'\", inject(function () {\n      $state.go('A.b.i.1');\n      $q.flush();\n      expect(elem[0].querySelector('#named_A').textContent).toBe('A.b.i.1');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target the unnamed ui-view at the root context (named ''), when the view's name is '@'","suites":["Targeted Views","with view@context style view targeting"],"updatePoint":{"line":2257,"column":101},"line":2257,"code":"    it(\"should target the unnamed ui-view at the root context (named ''), when the view's name is '@'\", inject(function () {\n      $state.go('A.b.i.2');\n      $q.flush();\n      expect(elem[0].textContent).toBe('rooted!');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should target ui-views on own state when the state anchor is '.' (view name ends with '@.')","suites":["Targeted Views","with view@context style view targeting"],"updatePoint":{"line":2264,"column":99},"line":2264,"code":"    it(\"should target ui-views on own state when the state anchor is '.' (view name ends with '@.')\", inject(function () {\n      $state.go('B');\n      $q.flush();\n      expect(elem[0].textContent).toBe('Targeted view on own state');\n    }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should fire when the to-state reference is invalid","suites":[".onInvalid()"],"updatePoint":{"line":2281,"column":56},"line":2281,"code":"  it('should fire when the to-state reference is invalid', inject(function ($state, $transitions, $q) {\n    let ref = null;\n    $stateProvider.onInvalid(function ($to$) {\n      ref = $to$;\n      return false;\n    });\n\n    $state.go('invalid');\n    $q.flush();\n    expect(ref).not.toBeNull();\n    expect(ref.valid()).toBeFalsy();\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow redirection if an ITargetState is returned","suites":[".onInvalid()"],"updatePoint":{"line":2294,"column":61},"line":2294,"code":"  it('should allow redirection if an ITargetState is returned', inject(function ($state, $transitions, $q) {\n    $stateProvider.onInvalid(function ($to$) {\n      return $state.target('second', $to$.params(), $to$.options());\n    });\n\n    $state.go('invalid');\n    $q.flush();\n    expect($state.current.name).toBe('second');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"trigger transition.onError","suites":["exceptions in onEnter"],"updatePoint":{"line":2318,"column":32},"line":2318,"code":"  it('trigger transition.onError', inject(function ($state, $q, $transitions) {\n    let called;\n    $state.defaultErrorHandler(function () {});\n    $transitions.onError({}, function () {\n      called = true;\n    });\n\n    $state.go('A');\n    $q.flush();\n    expect($state.current.name).toEqual('A');\n\n    $state.transitionTo('onEnterFail');\n    $q.flush();\n\n    expect(called).toBeTruthy();\n    expect($state.current.name).toEqual('A');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should start empty","suites":["$stateParams"],"updatePoint":{"line":2340,"column":24},"line":2340,"code":"  it('should start empty', inject(function ($stateParams) {\n    expect($stateParams.foo).toBeUndefined();\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should allow setting values on it","suites":["$stateParams"],"updatePoint":{"line":2344,"column":39},"line":2344,"code":"  it('should allow setting values on it', inject(function ($stateParams) {\n    $stateParams.foo = 'bar';\n    expect($stateParams.foo).toBeDefined();\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should be cleared between tests","suites":["$stateParams"],"updatePoint":{"line":2349,"column":37},"line":2349,"code":"  it('should be cleared between tests', inject(function ($stateParams) {\n    expect($stateParams.foo).toBeUndefined();\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"should not go into an infinite loop","suites":["otherwise and state redirects"],"updatePoint":{"line":2380,"column":41},"line":2380,"code":"  it('should not go into an infinite loop', inject(function ($location, $rootScope, $state, $urlRouter, $httpBackend) {\n    $state.defaultErrorHandler(function () {});\n    $httpBackend.expectGET('login.html').respond('login page');\n    $location.url('notmatched');\n    $urlRouter.update(true);\n    expect(function () {\n      $rootScope.$digest();\n    }).not.toThrow();\n    expect(function () {\n      $httpBackend.flush();\n    }).not.toThrow();\n    expect($state.current.name).toBe('loginPage');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"redirects from .otherwise() should go to the redirect-to target state and url","suites":["transition hook"],"updatePoint":{"line":2426,"column":83},"line":2426,"code":"  it('redirects from .otherwise() should go to the redirect-to target state and url', inject(function (\n    $transitions,\n    $q,\n    $state,\n    $location\n  ) {\n    $transitions.onBefore({ to: 'home' }, function () {\n      return $state.target('loginPage', {}, { location: true });\n    });\n    $q.flush();\n    expect($state.current.name).toBe('loginPage');\n    expect($location.path()).toBe('/login');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"redirects should be able to change option.reload","suites":["transition hook"],"updatePoint":{"line":2441,"column":54},"line":2441,"code":"  it('redirects should be able to change option.reload', inject(function ($transitions, $q, $state, $trace) {\n    let count = 0;\n    $q.flush();\n    expect($state.current.name).toBe('home');\n    expect(log).toBe('homeCtrl;');\n\n    $state.go('.');\n    $q.flush();\n    expect(log).toBe('homeCtrl;');\n\n    $transitions.onBefore({ to: 'home' }, function ($transition$) {\n      const options = $transition$.options();\n      if (!options.reload && count++ < 5) {\n        return $state.target($transition$.to(), $transition$.params('to'), extend({}, options, { reload: true }));\n      }\n    });\n\n    $state.go('.');\n    $q.flush();\n\n    expect($state.current.name).toBe('home');\n    expect(log).toBe('homeCtrl;homeCtrl;');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"redirects should re-resolve when reloading during a redirect","suites":["transition hook"],"updatePoint":{"line":2466,"column":66},"line":2466,"code":"  it('redirects should re-resolve when reloading during a redirect', inject(function (\n    $transitions,\n    $q,\n    $state,\n    $trace\n  ) {\n    let count = 0;\n    $q.flush();\n\n    expect($state.current.name).toBe('home');\n    expect(resolvelog).toBe('fooResolve;');\n\n    $state.go('home.foo');\n    $q.flush();\n    expect(resolvelog).toBe('fooResolve;');\n\n    $transitions.onStart({ to: 'home' }, function ($transition$) {\n      if (!$transition$.options().reload && count++ < 5) {\n        const options = $transition$.options();\n        return $state.target($transition$.to(), $transition$.params('to'), extend({}, options, { reload: true }));\n      }\n    });\n\n    $state.go('home');\n    $q.flush();\n    expect($state.current.name).toBe('home');\n    expect(resolvelog).toBe('fooResolve;fooResolve;');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"aborts should reset the URL to the prevous state's","suites":["transition hook"],"updatePoint":{"line":2496,"column":56},"line":2496,"code":"  it(\"aborts should reset the URL to the prevous state's\", inject(function ($transitions, $q, $state, $location) {\n    $state.defaultErrorHandler(function () {});\n    $q.flush();\n    $transitions.onStart({ to: 'home.foo' }, function () {\n      return false;\n    });\n    $location.path('/home/foo');\n    $q.flush();\n    expect($state.current.name).toBe('home');\n    expect($location.path()).toBe('/home');\n  }));","file":"stateSpec.ts","skipped":false,"dir":"test"},{"name":"exists","suites":["templateFactory"],"updatePoint":{"line":11,"column":12},"line":11,"code":"  it('exists', inject(function ($templateFactory) {\n    expect($templateFactory).toBeDefined();\n  }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"accepts relative URLs","suites":["templateFactory","should follow $sce policy and"],"updatePoint":{"line":18,"column":31},"line":18,"code":"      it('accepts relative URLs', inject(function ($templateFactory, $httpBackend, $sce) {\n        $httpBackend.expectGET('views/view.html').respond(200, 'template!');\n        $templateFactory.fromUrl('views/view.html');\n        $httpBackend.flush();\n      }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"rejects untrusted URLs","suites":["templateFactory","should follow $sce policy and"],"updatePoint":{"line":24,"column":32},"line":24,"code":"      it('rejects untrusted URLs', inject(function ($templateFactory, $httpBackend, $sce) {\n        let error = 'No error thrown';\n        try {\n          $templateFactory.fromUrl('http://evil.com/views/view.html');\n        } catch (e) {\n          error = e.message;\n        }\n        expect(error).toMatch(/sce:insecurl/);\n      }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"accepts explicitly trusted URLs","suites":["templateFactory","should follow $sce policy and"],"updatePoint":{"line":34,"column":41},"line":34,"code":"      it('accepts explicitly trusted URLs', inject(function ($templateFactory, $httpBackend, $sce) {\n        $httpBackend.expectGET('http://evil.com/views/view.html').respond(200, 'template!');\n        $templateFactory.fromUrl($sce.trustAsResourceUrl('http://evil.com/views/view.html'));\n        $httpBackend.flush();\n      }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"does not restrict URL loading","suites":["templateFactory","should follow $sce policy and"],"updatePoint":{"line":44,"column":37},"line":44,"code":"    it('does not restrict URL loading', inject(function ($templateFactory, $httpBackend) {\n      $httpBackend.expectGET('http://evil.com/views/view.html').respond(200, 'template!');\n      $templateFactory.fromUrl('http://evil.com/views/view.html');\n      $httpBackend.flush();\n\n      $httpBackend.expectGET('data:text/html,foo').respond(200, 'template!');\n      $templateFactory.fromUrl('data:text/html,foo');\n      $httpBackend.flush();\n    }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should request templates as text/html","suites":["templateFactory","should follow $sce policy and"],"updatePoint":{"line":55,"column":45},"line":55,"code":"    it('should request templates as text/html', inject(function ($templateFactory, $httpBackend) {\n      $httpBackend\n        .expectGET('views/view.html', function (headers) {\n          return headers.Accept === 'text/html';\n        })\n        .respond(200);\n      $templateFactory.fromUrl('views/view.html');\n      $httpBackend.flush();\n    }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"does not restrict URL loading","suites":["templateFactory","templateFactory with forced use of $http service"],"updatePoint":{"line":75,"column":37},"line":75,"code":"    it('does not restrict URL loading', inject(function ($templateFactory, $httpBackend) {\n      $httpBackend.expectGET('http://evil.com/views/view.html').respond(200, 'template!');\n      $templateFactory.fromUrl('http://evil.com/views/view.html');\n      $httpBackend.flush();\n\n      $httpBackend.expectGET('data:text/html,foo').respond(200, 'template!');\n      $templateFactory.fromUrl('data:text/html,foo');\n      $httpBackend.flush();\n    }));","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not prefix the components dom element with anything","suites":["templateFactory","component template builder"],"updatePoint":{"line":105,"column":68},"line":105,"code":"      it('should not prefix the components dom element with anything', () => {\n        router.stateRegistry.register({ name: 'cmp', component: 'myComponent' });\n        router.stateService.go('cmp');\n        rootScope.$digest();\n        expect(el.html()).toMatch(/\\<my-component/);\n      });","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should prefix the components dom element with x- for components named dataFoo","suites":["templateFactory","component template builder"],"updatePoint":{"line":112,"column":87},"line":112,"code":"      it('should prefix the components dom element with x- for components named dataFoo', () => {\n        router.stateRegistry.register({ name: 'cmp', component: 'dataComponent' });\n        router.stateService.go('cmp');\n        rootScope.$digest();\n        expect(el.html()).toMatch(/\\<x-data-component/);\n      });","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should prefix the components dom element with x- for components named xFoo","suites":["templateFactory","component template builder"],"updatePoint":{"line":119,"column":84},"line":119,"code":"      it('should prefix the components dom element with x- for components named xFoo', () => {\n        router.stateRegistry.register({ name: 'cmp', component: 'xComponent' });\n        router.stateService.go('cmp');\n        rootScope.$digest();\n        expect(el.html()).toMatch(/\\<x-x-component/);\n      });","file":"templateFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should factory matchers with correct configuration","suites":["UrlMatcher","provider"],"updatePoint":{"line":20,"column":58},"line":20,"code":"    it('should factory matchers with correct configuration', function () {\n      $umf.caseInsensitive(false);\n      expect($umf.compile('/hello').exec('/HELLO')).toBeNull();\n\n      $umf.caseInsensitive(true);\n      expect($umf.compile('/hello').exec('/HELLO')).toEqual({});\n\n      $umf.strictMode(true);\n      expect($umf.compile('/hello').exec('/hello/')).toBeNull();\n\n      $umf.strictMode(false);\n      expect($umf.compile('/hello').exec('/hello/')).toEqual({});\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should correctly validate UrlMatcher interface","suites":["UrlMatcher","provider"],"updatePoint":{"line":34,"column":54},"line":34,"code":"    it('should correctly validate UrlMatcher interface', function () {\n      let m = $umf.compile('/');\n      expect($umf.isMatcher(m)).toBe(true);\n\n      m = angular.extend({}, m, { validates: null });\n      expect($umf.isMatcher(m)).toBe(false);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match static URLs","suites":["UrlMatcher","provider"],"updatePoint":{"line":43,"column":30},"line":43,"code":"  it('should match static URLs', function () {\n    expect($umf.compile('/hello/world').exec('/hello/world')).toEqual({});\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match static case insensitive URLs","suites":["UrlMatcher","provider"],"updatePoint":{"line":47,"column":47},"line":47,"code":"  it('should match static case insensitive URLs', function () {\n    expect($umf.compile('/hello/world', { caseInsensitive: true }).exec('/heLLo/World')).toEqual({});\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match against the entire path","suites":["UrlMatcher","provider"],"updatePoint":{"line":51,"column":42},"line":51,"code":"  it('should match against the entire path', function () {\n    const matcher = $umf.compile('/hello/world', { strict: true });\n    expect(matcher.exec('/hello/world/')).toBeNull();\n    expect(matcher.exec('/hello/world/suffix')).toBeNull();\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should parse parameter placeholders","suites":["UrlMatcher","provider"],"updatePoint":{"line":57,"column":41},"line":57,"code":"  it('should parse parameter placeholders', function () {\n    const matcher = $umf.compile('/users/:id/details/{type}/{repeat:[0-9]+}?from&to');\n    expect(matcher.parameters().map(prop('id'))).toEqual(['id', 'type', 'repeat', 'from', 'to']);\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode and decode duplicate query string values as array","suites":["UrlMatcher","provider"],"updatePoint":{"line":62,"column":69},"line":62,"code":"  it('should encode and decode duplicate query string values as array', function () {\n    const matcher = $umf.compile('/?foo'),\n      array = { foo: ['bar', 'baz'] };\n    expect(matcher.exec('/', array)).toEqual(array);\n    expect(matcher.format(array)).toBe('/?foo=bar&foo=baz');\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode and decode slashes in parameter values as ~2F","suites":["UrlMatcher","provider"],"updatePoint":{"line":69,"column":65},"line":69,"code":"  it('should encode and decode slashes in parameter values as ~2F', function () {\n    const matcher1 = $umf.compile('/:foo');\n\n    expect(matcher1.format({ foo: '/' })).toBe('/~2F');\n    expect(matcher1.format({ foo: '//' })).toBe('/~2F~2F');\n\n    expect(matcher1.exec('/')).toBeTruthy();\n    expect(matcher1.exec('//')).not.toBeTruthy();\n\n    expect(matcher1.exec('/').foo).toBe('');\n    expect(matcher1.exec('/123').foo).toBe('123');\n    expect(matcher1.exec('/~2F').foo).toBe('/');\n    expect(matcher1.exec('/123~2F').foo).toBe('123/');\n\n    // param :foo should match between two slashes\n    const matcher2 = $umf.compile('/:foo/');\n\n    expect(matcher2.exec('/')).not.toBeTruthy();\n    expect(matcher2.exec('//')).toBeTruthy();\n\n    expect(matcher2.exec('//').foo).toBe('');\n    expect(matcher2.exec('/123/').foo).toBe('123');\n    expect(matcher2.exec('/~2F/').foo).toBe('/');\n    expect(matcher2.exec('/123~2F/').foo).toBe('123/');\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode and decode tildes in parameter values as ~~","suites":["UrlMatcher","provider"],"updatePoint":{"line":95,"column":63},"line":95,"code":"  it('should encode and decode tildes in parameter values as ~~', function () {\n    const matcher1 = $umf.compile('/:foo');\n\n    expect(matcher1.format({ foo: 'abc' })).toBe('/abc');\n    expect(matcher1.format({ foo: '~abc' })).toBe('/~~abc');\n    expect(matcher1.format({ foo: '~2F' })).toBe('/~~2F');\n\n    expect(matcher1.exec('/abc').foo).toBe('abc');\n    expect(matcher1.exec('/~~abc').foo).toBe('~abc');\n    expect(matcher1.exec('/~~2F').foo).toBe('~2F');\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match if properly formatted","suites":["UrlMatcher","snake-case parameters"],"updatePoint":{"line":108,"column":42},"line":108,"code":"    it('should match if properly formatted', function () {\n      const matcher = $umf.compile('/users/?from&to&snake-case&snake-case-triple');\n      expect(matcher.parameters().map(prop('id'))).toEqual(['from', 'to', 'snake-case', 'snake-case-triple']);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not match if invalid","suites":["UrlMatcher","snake-case parameters"],"updatePoint":{"line":113,"column":35},"line":113,"code":"    it('should not match if invalid', function () {\n      let err = \"Invalid parameter name '-snake' in pattern '/users/?from&to&-snake'\";\n      expect(function () {\n        $umf.compile('/users/?from&to&-snake');\n      }).toThrowError(err);\n\n      err = \"Invalid parameter name 'snake-' in pattern '/users/?from&to&snake-'\";\n      expect(function () {\n        $umf.compile('/users/?from&to&snake-');\n      }).toThrowError(err);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match if properly formatted","suites":["UrlMatcher","parameters containing periods"],"updatePoint":{"line":127,"column":42},"line":127,"code":"    it('should match if properly formatted', function () {\n      const matcher = $umf.compile('/users/?from&to&with.periods&with.periods.also');\n      const params = matcher.parameters().map(function (p) {\n        return p.id;\n      });\n\n      expect(params.sort()).toEqual(['from', 'to', 'with.periods', 'with.periods.also']);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not match if invalid","suites":["UrlMatcher","parameters containing periods"],"updatePoint":{"line":136,"column":35},"line":136,"code":"    it('should not match if invalid', function () {\n      let err = new Error(\"Invalid parameter name '.periods' in pattern '/users/?from&to&.periods'\");\n      expect(function () {\n        $umf.compile('/users/?from&to&.periods');\n      }).toThrow(err);\n\n      err = new Error(\"Invalid parameter name 'periods.' in pattern '/users/?from&to&periods.'\");\n      expect(function () {\n        $umf.compile('/users/?from&to&periods.');\n      }).toThrow(err);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should capture parameter values","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":150,"column":39},"line":150,"code":"    it('should capture parameter values', function () {\n      const m = $umf.compile('/users/:id/details/{type}/{repeat:[0-9]+}?from&to', { strict: false });\n      expect(m.exec('/users/123/details//0', {})).toEqual({ id: '123', type: '', repeat: '0' });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should capture catch-all parameters","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":155,"column":43},"line":155,"code":"    it('should capture catch-all parameters', function () {\n      const m = $umf.compile('/document/*path');\n      expect(m.exec('/document/a/b/c', {})).toEqual({ path: 'a/b/c' });\n      expect(m.exec('/document/', {})).toEqual({ path: '' });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should use the optional regexp with curly brace placeholders","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":161,"column":68},"line":161,"code":"    it('should use the optional regexp with curly brace placeholders', function () {\n      const m = $umf.compile('/users/:id/details/{type}/{repeat:[0-9]+}?from&to');\n      expect(m.exec('/users/123/details/what/thisShouldBeDigits', {})).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not use optional regexp for '/'","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":166,"column":46},"line":166,"code":"    it(\"should not use optional regexp for '/'\", function () {\n      const m = $umf.compile('/{language:(?:fr|en|de)}');\n      expect(m.exec('/', {})).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should work with empty default value","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":171,"column":44},"line":171,"code":"    it('should work with empty default value', function () {\n      const m = $umf.compile('/foo/:str', { state: { params: { str: { value: '' } } } });\n      expect(m.exec('/foo/', {})).toEqual({ str: '' });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should work with empty default value for regex","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":176,"column":54},"line":176,"code":"    it('should work with empty default value for regex', function () {\n      const m = $umf.compile('/foo/{param:(?:foo|bar|)}', { state: { params: { param: { value: '' } } } });\n      expect(m.exec('/foo/', {})).toEqual({ param: '' });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should treat the URL as already decoded and does not decode it further","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":181,"column":78},"line":181,"code":"    it('should treat the URL as already decoded and does not decode it further', function () {\n      expect($umf.compile('/users/:id').exec('/users/100%25', {})).toEqual({ id: '100%25' });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should throw on unbalanced capture list","suites":["UrlMatcher",".exec()"],"updatePoint":{"line":199,"column":47},"line":199,"code":"    it('should throw on unbalanced capture list', function () {\n      const shouldThrow = {\n        '/url/{matchedParam:([a-z]+)}/child/{childParam}': '/url/someword/child/childParam',\n        '/url/{matchedParam:([a-z]+)}/child/{childParam}?foo': '/url/someword/child/childParam',\n      };\n\n      angular.forEach(shouldThrow, function (url, route) {\n        expect(function () {\n          $umf.compile(route).exec(url, {});\n        }).toThrowError(\"Unbalanced capture group in route '\" + route + \"'\");\n      });\n\n      const shouldPass = {\n        '/url/{matchedParam:[a-z]+}/child/{childParam}': '/url/someword/child/childParam',\n        '/url/{matchedParam:[a-z]+}/child/{childParam}?foo': '/url/someword/child/childParam',\n      };\n\n      angular.forEach(shouldPass, function (url, route) {\n        expect(function () {\n          $umf.compile(route).exec(url, {});\n        }).not.toThrow();\n      });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should reconstitute the URL","suites":["UrlMatcher",".format()"],"updatePoint":{"line":225,"column":35},"line":225,"code":"    it('should reconstitute the URL', function () {\n      const m = $umf.compile('/users/:id/details/{type}/{repeat:[0-9]+}?from'),\n        params = { id: '123', type: 'default', repeat: 444, ignored: 'value', from: '1970' };\n\n      expect(m.format(params)).toEqual('/users/123/details/default/444?from=1970');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode URL parameters","suites":["UrlMatcher",".format()"],"updatePoint":{"line":232,"column":36},"line":232,"code":"    it('should encode URL parameters', function () {\n      expect($umf.compile('/users/:id').format({ id: '100%' })).toEqual('/users/100%25');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"encodes URL parameters with hashes","suites":["UrlMatcher",".format()"],"updatePoint":{"line":236,"column":42},"line":236,"code":"    it('encodes URL parameters with hashes', function () {\n      const m = $umf.compile('/users/:id#:section');\n      expect(m.format({ id: 'bob', section: 'contact-details' })).toEqual('/users/bob#contact-details');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should trim trailing slashes when the terminal value is optional","suites":["UrlMatcher",".format()"],"updatePoint":{"line":241,"column":72},"line":241,"code":"    it('should trim trailing slashes when the terminal value is optional', function () {\n      const config = { state: { params: { id: { squash: true, value: '123' } } } },\n        m = $umf.compile('/users/:id', config),\n        params = { id: '123' };\n\n      expect(m.format(params)).toEqual('/users');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should format query parameters from parent, child, grandchild matchers","suites":["UrlMatcher",".format()"],"updatePoint":{"line":249,"column":78},"line":249,"code":"    it('should format query parameters from parent, child, grandchild matchers', function () {\n      const m = $umf.compile('/parent?qParent');\n      const m2 = m.append($umf.compile('/child?qChild'));\n      const m3 = m2.append($umf.compile('/grandchild?qGrandchild'));\n\n      const params = { qParent: 'parent', qChild: 'child', qGrandchild: 'grandchild' };\n      const url = '/parent/child/grandchild?qParent=parent&qChild=child&qGrandchild=grandchild';\n\n      const formatted = m3.format(params);\n      expect(formatted).toBe(url);\n      expect(m3.exec(url.split('?')[0], params)).toEqual(params);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should append matchers","suites":["UrlMatcher",".append()"],"updatePoint":{"line":264,"column":30},"line":264,"code":"    it('should append matchers', function () {\n      const matcher = $umf.compile('/users/:id/details/{type}?from').append($umf.compile('/{repeat:[0-9]+}?to'));\n      const params = matcher.parameters();\n      expect(params.map(prop('id'))).toEqual(['id', 'type', 'from', 'repeat', 'to']);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should return a new matcher","suites":["UrlMatcher",".append()"],"updatePoint":{"line":270,"column":35},"line":270,"code":"    it('should return a new matcher', function () {\n      const base = $umf.compile('/users/:id/details/{type}?from');\n      const matcher = base.append($umf.compile('/{repeat:[0-9]+}?to'));\n      expect(matcher).not.toBe(base);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should respect $urlMatcherFactoryProvider.strictMode","suites":["UrlMatcher",".append()"],"updatePoint":{"line":276,"column":60},"line":276,"code":"    it('should respect $urlMatcherFactoryProvider.strictMode', function () {\n      let m = $umf.compile('/');\n      $umf.strictMode(false);\n      m = m.append($umf.compile('foo'));\n      expect(m.exec('/foo')).toEqual({});\n      expect(m.exec('/foo/')).toEqual({});\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should respect $urlMatcherFactoryProvider.caseInsensitive","suites":["UrlMatcher",".append()"],"updatePoint":{"line":284,"column":65},"line":284,"code":"    it('should respect $urlMatcherFactoryProvider.caseInsensitive', function () {\n      let m = $umf.compile('/');\n      $umf.caseInsensitive(true);\n      m = m.append($umf.compile('foo'));\n      expect(m.exec('/foo')).toEqual({});\n      expect(m.exec('/FOO')).toEqual({});\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should respect $urlMatcherFactoryProvider.caseInsensitive when validating regex params","suites":["UrlMatcher",".append()"],"updatePoint":{"line":292,"column":94},"line":292,"code":"    it('should respect $urlMatcherFactoryProvider.caseInsensitive when validating regex params', function () {\n      let m = $umf.compile('/');\n      $umf.caseInsensitive(true);\n      m = m.append($umf.compile('foo/{param:bar}'));\n      expect(m.validates({ param: 'BAR' })).toEqual(true);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should generate/match params in the proper order","suites":["UrlMatcher",".append()"],"updatePoint":{"line":299,"column":56},"line":299,"code":"    it('should generate/match params in the proper order', function () {\n      let m = $umf.compile('/foo?queryparam');\n      m = m.append($umf.compile('/bar/:pathparam'));\n      expect(m.exec('/foo/bar/pathval', { queryparam: 'queryval' })).toEqual({\n        pathparam: 'pathval',\n        queryparam: 'queryval',\n      });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should handle .is() for an array of values","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":310,"column":50},"line":310,"code":"    it('should handle .is() for an array of values', function () {\n      const m = $umf.compile('/foo?{param1:int}'),\n        param = m.parameter('param1');\n      expect(param.type.is([1, 2, 3])).toBe(true);\n      expect(param.type.is([1, '2', 3])).toBe(false);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should handle .equals() for two arrays of values","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":317,"column":56},"line":317,"code":"    it('should handle .equals() for two arrays of values', function () {\n      const m = $umf.compile('/foo?{param1:int}&{param2:date}'),\n        param1 = m.parameter('param1'),\n        param2 = m.parameter('param2');\n\n      expect(param1.type.equals([1, 2, 3], [1, 2, 3])).toBe(true);\n      expect(param1.type.equals([1, 2, 3], [1, 2])).toBe(false);\n      expect(\n        param2.type.equals(\n          [new Date(2014, 11, 15), new Date(2014, 10, 15)],\n          [new Date(2014, 11, 15), new Date(2014, 10, 15)]\n        )\n      ).toBe(true);\n      expect(\n        param2.type.equals(\n          [new Date(2014, 11, 15), new Date(2014, 9, 15)],\n          [new Date(2014, 11, 15), new Date(2014, 10, 15)]\n        )\n      ).toBe(false);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should conditionally be wrapped in an array by default","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":338,"column":62},"line":338,"code":"    it('should conditionally be wrapped in an array by default', function () {\n      const m = $umf.compile('/foo?param1');\n\n      // empty array [] is treated like \"undefined\"\n      expect(m.format({ param1: undefined })).toBe('/foo');\n      expect(m.format({ param1: [] })).toBe('/foo');\n      expect(m.format({ param1: '' })).toBe('/foo');\n      expect(m.format({ param1: '1' })).toBe('/foo?param1=1');\n      expect(m.format({ param1: ['1'] })).toBe('/foo?param1=1');\n      expect(m.format({ param1: ['1', '2'] })).toBe('/foo?param1=1&param1=2');\n\n      expect(m.exec('/foo')).toEqual({ param1: undefined });\n      expect(m.exec('/foo', {})).toEqual({ param1: undefined });\n      expect(m.exec('/foo', { param1: '' })).toEqual({ param1: undefined });\n      expect(m.exec('/foo', { param1: '1' })).toEqual({ param1: '1' }); // auto unwrap single values\n      expect(m.exec('/foo', { param1: ['1', '2'] })).toEqual({ param1: ['1', '2'] });\n\n      $url.url('/foo');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: undefined });\n      $url.url('/foo?param1=bar');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: 'bar' }); // auto unwrap\n      $url.url('/foo?param1=');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: undefined });\n      $url.url('/foo?param1=bar&param1=baz');\n      if (angular.isArray($url.search()))\n        // conditional for angular 1.0.8\n        expect(m.exec($url.path(), $url.search())).toEqual({ param1: ['bar', 'baz'] });\n\n      expect(m.format({})).toBe('/foo');\n      expect(m.format({ param1: undefined })).toBe('/foo');\n      expect(m.format({ param1: '' })).toBe('/foo');\n      expect(m.format({ param1: 'bar' })).toBe('/foo?param1=bar');\n      expect(m.format({ param1: ['bar'] })).toBe('/foo?param1=bar');\n      expect(m.format({ param1: ['bar', 'baz'] })).toBe('/foo?param1=bar&param1=baz');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should be wrapped in an array if array: true","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":374,"column":52},"line":374,"code":"    it('should be wrapped in an array if array: true', function () {\n      const m = $umf.compile('/foo?param1', { state: { params: { param1: { array: true } } } });\n\n      // empty array [] is treated like \"undefined\"\n      expect(m.format({ param1: undefined })).toBe('/foo');\n      expect(m.format({ param1: [] })).toBe('/foo');\n      expect(m.format({ param1: '' })).toBe('/foo');\n      expect(m.format({ param1: '1' })).toBe('/foo?param1=1');\n      expect(m.format({ param1: ['1'] })).toBe('/foo?param1=1');\n      expect(m.format({ param1: ['1', '2'] })).toBe('/foo?param1=1&param1=2');\n\n      expect(m.exec('/foo')).toEqual({ param1: undefined });\n      expect(m.exec('/foo', {})).toEqual({ param1: undefined });\n      expect(m.exec('/foo', { param1: '' })).toEqual({ param1: undefined });\n      expect(m.exec('/foo', { param1: '1' })).toEqual({ param1: ['1'] });\n      expect(m.exec('/foo', { param1: ['1', '2'] })).toEqual({ param1: ['1', '2'] });\n\n      $url.url('/foo');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: undefined });\n      $url.url('/foo?param1=');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: undefined });\n      $url.url('/foo?param1=bar');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: ['bar'] });\n      $url.url('/foo?param1=bar&param1=baz');\n      if (angular.isArray($url.search()))\n        // conditional for angular 1.0.8\n        expect(m.exec($url.path(), $url.search())).toEqual({ param1: ['bar', 'baz'] });\n\n      expect(m.format({})).toBe('/foo');\n      expect(m.format({ param1: undefined })).toBe('/foo');\n      expect(m.format({ param1: '' })).toBe('/foo');\n      expect(m.format({ param1: 'bar' })).toBe('/foo?param1=bar');\n      expect(m.format({ param1: ['bar'] })).toBe('/foo?param1=bar');\n      expect(m.format({ param1: ['bar', 'baz'] })).toBe('/foo?param1=bar&param1=baz');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should be wrapped in an array if paramname looks like param[]","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":410,"column":69},"line":410,"code":"    it('should be wrapped in an array if paramname looks like param[]', function () {\n      const m = $umf.compile('/foo?param1[]');\n\n      expect(m.exec('/foo')).toEqual({});\n\n      $url.url('/foo?param1[]=bar');\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar'] });\n      expect(m.format({ 'param1[]': 'bar' })).toBe('/foo?param1[]=bar');\n      expect(m.format({ 'param1[]': ['bar'] })).toBe('/foo?param1[]=bar');\n\n      $url.url('/foo?param1[]=bar&param1[]=baz');\n      if (angular.isArray($url.search()))\n        // conditional for angular 1.0.8\n        expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar', 'baz'] });\n      expect(m.format({ 'param1[]': ['bar', 'baz'] })).toBe('/foo?param1[]=bar&param1[]=baz');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should return default value, if query param is missing.","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":428,"column":63},"line":428,"code":"    it('should return default value, if query param is missing.', function () {\n      const m = $umf.compile('/state?param1&param2&param3&param5', {\n        state: {\n          params: {\n            param1: 'value1',\n            param2: { array: true, value: ['value2'] },\n            param3: { array: true, value: [] },\n            param5: {\n              array: true,\n              value: function () {\n                return [];\n              },\n            },\n          },\n        },\n      });\n\n      const expected = {\n        param1: 'value1',\n        param2: ['value2'],\n        param3: [],\n        param5: [],\n      };\n\n      // Parse url to get Param.value()\n      const parsed = m.exec('/state');\n      expect(parsed).toEqual(expected);\n\n      // Pass again through Param.value() for normalization (like transitionTo)\n      const paramDefs = m.parameters();\n      const values = map(parsed, function (val, key) {\n        return find(paramDefs, function (def) {\n          return def.id === key;\n        }).value(val);\n      });\n      expect(values).toEqual(expected);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not be wrapped by ui-router into an array if array: false","suites":["UrlMatcher","multivalue-query-parameters"],"updatePoint":{"line":466,"column":72},"line":466,"code":"    it('should not be wrapped by ui-router into an array if array: false', function () {\n      const m = $umf.compile('/foo?param1', { state: { params: { param1: { array: false } } } });\n\n      expect(m.exec('/foo')).toEqual({});\n\n      $url.url('/foo?param1=bar');\n      expect(m.exec($url.path(), $url.search())).toEqual({ param1: 'bar' });\n      expect(m.format({ param1: 'bar' })).toBe('/foo?param1=bar');\n      expect(m.format({ param1: ['bar'] })).toBe('/foo?param1=bar');\n\n      $url.url('/foo?param1=bar&param1=baz');\n      if (angular.isArray($url.search()))\n        // conditional for angular 1.0.8\n        expect(m.exec($url.path(), $url.search())).toEqual({ param1: 'bar,baz' }); // coerced to string\n      expect(m.format({ param1: ['bar', 'baz'] })).toBe('/foo?param1=bar%2Cbaz'); // coerced to string\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should behave as a single-value by default","suites":["UrlMatcher","multivalue-path-parameters"],"updatePoint":{"line":485,"column":50},"line":485,"code":"    it('should behave as a single-value by default', function () {\n      const m = $umf.compile('/foo/:param1');\n\n      expect(m.exec('/foo/')).toEqual({ param1: '' });\n\n      expect(m.exec('/foo/bar')).toEqual({ param1: 'bar' });\n      expect(m.format({ param1: 'bar' })).toBe('/foo/bar');\n      expect(m.format({ param1: ['bar', 'baz'] })).toBe('/foo/bar%2Cbaz'); // coerced to string\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should be split on - in url and wrapped in an array if array: true","suites":["UrlMatcher","multivalue-path-parameters"],"updatePoint":{"line":495,"column":74},"line":495,"code":"    it('should be split on - in url and wrapped in an array if array: true', inject(function ($location) {\n      const m = $umf.compile('/foo/:param1', { state: { params: { param1: { array: true } } } });\n\n      expect(m.exec('/foo/')).toEqual({ param1: undefined });\n      expect(m.exec('/foo/bar')).toEqual({ param1: ['bar'] });\n      $url.url('/foo/bar-baz');\n      expect(m.exec($location.url())).toEqual({ param1: ['bar', 'baz'] });\n\n      expect(m.format({ param1: [] })).toEqual('/foo/');\n      expect(m.format({ param1: ['bar'] })).toEqual('/foo/bar');\n      expect(m.format({ param1: ['bar', 'baz'] })).toEqual('/foo/bar-baz');\n    }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should behave similar to multi-value query params","suites":["UrlMatcher","multivalue-path-parameters"],"updatePoint":{"line":508,"column":57},"line":508,"code":"    it('should behave similar to multi-value query params', function () {\n      const m = $umf.compile('/foo/:param1[]');\n\n      // empty array [] is treated like \"undefined\"\n      expect(m.format({ 'param1[]': undefined })).toBe('/foo/');\n      expect(m.format({ 'param1[]': [] })).toBe('/foo/');\n      expect(m.format({ 'param1[]': '' })).toBe('/foo/');\n      expect(m.format({ 'param1[]': '1' })).toBe('/foo/1');\n      expect(m.format({ 'param1[]': ['1'] })).toBe('/foo/1');\n      expect(m.format({ 'param1[]': ['1', '2'] })).toBe('/foo/1-2');\n\n      expect(m.exec('/foo/')).toEqual({ 'param1[]': undefined });\n      expect(m.exec('/foo/1')).toEqual({ 'param1[]': ['1'] });\n      expect(m.exec('/foo/1-2')).toEqual({ 'param1[]': ['1', '2'] });\n\n      $url.url('/foo/');\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': undefined });\n      $url.url('/foo/bar');\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar'] });\n      $url.url('/foo/bar-baz');\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar', 'baz'] });\n\n      expect(m.format({})).toBe('/foo/');\n      expect(m.format({ 'param1[]': undefined })).toBe('/foo/');\n      expect(m.format({ 'param1[]': '' })).toBe('/foo/');\n      expect(m.format({ 'param1[]': 'bar' })).toBe('/foo/bar');\n      expect(m.format({ 'param1[]': ['bar'] })).toBe('/foo/bar');\n      expect(m.format({ 'param1[]': ['bar', 'baz'] })).toBe('/foo/bar-baz');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should be split on - in url and wrapped in an array if paramname looks like param[]","suites":["UrlMatcher","multivalue-path-parameters"],"updatePoint":{"line":538,"column":91},"line":538,"code":"    it('should be split on - in url and wrapped in an array if paramname looks like param[]', function () {\n      const m = $umf.compile('/foo/:param1[]');\n\n      expect(m.exec('/foo/')).toEqual({ 'param1[]': undefined });\n      expect(m.exec('/foo/bar')).toEqual({ 'param1[]': ['bar'] });\n      expect(m.exec('/foo/bar-baz')).toEqual({ 'param1[]': ['bar', 'baz'] });\n\n      expect(m.format({ 'param1[]': [] })).toEqual('/foo/');\n      expect(m.format({ 'param1[]': ['bar'] })).toEqual('/foo/bar');\n      expect(m.format({ 'param1[]': ['bar', 'baz'] })).toEqual('/foo/bar-baz');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should allow path param arrays with '-' in the values","suites":["UrlMatcher","multivalue-path-parameters"],"updatePoint":{"line":550,"column":61},"line":550,"code":"    it(\"should allow path param arrays with '-' in the values\", function () {\n      const m = $umf.compile('/foo/:param1[]');\n\n      expect(m.exec('/foo/')).toEqual({ 'param1[]': undefined });\n      expect(m.exec('/foo/bar\\\\-')).toEqual({ 'param1[]': ['bar-'] });\n      expect(m.exec('/foo/bar\\\\--\\\\-baz')).toEqual({ 'param1[]': ['bar-', '-baz'] });\n\n      expect(m.format({ 'param1[]': [] })).toEqual('/foo/');\n      expect(m.format({ 'param1[]': ['bar-'] })).toEqual('/foo/bar%5C%2D');\n      expect(m.format({ 'param1[]': ['bar-', '-baz'] })).toEqual('/foo/bar%5C%2D-%5C%2Dbaz');\n      expect(m.format({ 'param1[]': ['bar-bar-bar-', '-baz-baz-baz'] })).toEqual(\n        '/foo/bar%5C%2Dbar%5C%2Dbar%5C%2D-%5C%2Dbaz%5C%2Dbaz%5C%2Dbaz'\n      );\n\n      // check that we handle $location.url decodes correctly\n      $url.url(m.format({ 'param1[]': ['bar-', '-baz'] }));\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar-', '-baz'] });\n\n      // check that we handle $location.url decodes correctly for multiple hyphens\n      $url.url(m.format({ 'param1[]': ['bar-bar-bar-', '-baz-baz-baz'] }));\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['bar-bar-bar-', '-baz-baz-baz'] });\n\n      // check that pre-encoded values are passed correctly\n      $url.url(m.format({ 'param1[]': ['%2C%20%5C%2C', '-baz'] }));\n      expect(m.exec($url.path(), $url.search())).toEqual({ 'param1[]': ['%2C%20%5C%2C', '-baz'] });\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should handle arrays properly with config-time custom type definitions","suites":["urlMatcherFactoryProvider",".type()"],"updatePoint":{"line":596,"column":78},"line":596,"code":"    it('should handle arrays properly with config-time custom type definitions', inject(function ($stateParams) {\n      const m = $umf.compile('/test?{foo:myType}');\n      expect(m.exec('/test', { foo: '1' })).toEqual({ foo: { status: 'decoded' } });\n      expect(m.exec('/test', { foo: ['1', '2'] })).toEqual({ foo: [{ status: 'decoded' }, { status: 'decoded' }] });\n    }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"compiles patterns","suites":["urlMatcherFactory"],"updatePoint":{"line":618,"column":23},"line":618,"code":"  it('compiles patterns', function () {\n    const matcher = $umf.compile('/hello/world');\n    expect(matcher instanceof UrlMatcher).toBe(true);\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"recognizes matchers","suites":["urlMatcherFactory"],"updatePoint":{"line":623,"column":25},"line":623,"code":"  it('recognizes matchers', function () {\n    expect($umf.isMatcher($umf.compile('/'))).toBe(true);\n\n    const custom = {\n      format: angular.noop,\n      exec: angular.noop,\n      append: angular.noop,\n      isRoot: angular.noop,\n      validates: angular.noop,\n      parameters: angular.noop,\n      parameter: angular.noop,\n      _getDecodedParamValue: angular.noop,\n    };\n    expect($umf.isMatcher(custom)).toBe(true);\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should handle case sensitive URL by default","suites":["urlMatcherFactory"],"updatePoint":{"line":639,"column":49},"line":639,"code":"  it('should handle case sensitive URL by default', function () {\n    expect($umf.compile('/hello/world').exec('/heLLo/WORLD')).toBeNull();\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should handle case insensitive URL","suites":["urlMatcherFactory"],"updatePoint":{"line":643,"column":40},"line":643,"code":"  it('should handle case insensitive URL', function () {\n    $umf.caseInsensitive(true);\n    expect($umf.compile('/hello/world').exec('/heLLo/WORLD')).toEqual({});\n  });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should accept object definitions","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":649,"column":40},"line":649,"code":"    it('should accept object definitions', function () {\n      const type = { encode: function () {}, decode: function () {} } as any;\n      $umf.type('myType1', type);\n      expect($umf.type('myType1').encode).toBe(type.encode);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should reject duplicate definitions","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":655,"column":43},"line":655,"code":"    it('should reject duplicate definitions', function () {\n      $umf.type('myType2', { encode: function () {}, decode: function () {} } as any);\n      expect(function () {\n        $umf.type('myType2', {} as any);\n      }).toThrowError(\"A type named 'myType2' has already been defined.\");\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should accept injected function definitions","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":662,"column":51},"line":662,"code":"    it('should accept injected function definitions', inject(function ($stateParams) {\n      $umf.type(\n        'myType3',\n        {} as any,\n        function ($stateParams) {\n          return {\n            decode: function () {\n              return $stateParams;\n            },\n          };\n        } as any\n      );\n      expect($umf.type('myType3').decode()).toBe($stateParams);\n    }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should accept annotated function definitions","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":677,"column":52},"line":677,"code":"    it('should accept annotated function definitions', inject(function ($stateParams) {\n      $umf.type(\n        'myAnnotatedType',\n        {} as any,\n        [\n          '$stateParams',\n          function (s) {\n            return {\n              decode: function () {\n                return s;\n              },\n            };\n          },\n        ] as any\n      );\n      expect($umf.type('myAnnotatedType').decode()).toBe($stateParams);\n    }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match built-in types","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":695,"column":35},"line":695,"code":"    it('should match built-in types', function () {\n      const m = $umf.compile('/{foo:int}/{flag:bool}');\n      expect(m.exec('/1138/1')).toEqual({ foo: 1138, flag: true });\n      expect(m.format({ foo: 5, flag: true })).toBe('/5/1');\n\n      expect(m.exec('/-1138/1')).toEqual({ foo: -1138, flag: true });\n      expect(m.format({ foo: -5, flag: true })).toBe('/-5/1');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match built-in types with spaces","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":704,"column":47},"line":704,"code":"    it('should match built-in types with spaces', function () {\n      const m = $umf.compile('/{foo: int}/{flag:  bool}');\n      expect(m.exec('/1138/1')).toEqual({ foo: 1138, flag: true });\n      expect(m.format({ foo: 5, flag: true })).toBe('/5/1');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match types named only in params","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":710,"column":47},"line":710,"code":"    it('should match types named only in params', function () {\n      const m = $umf.compile('/{foo}/{flag}', {\n        state: {\n          params: {\n            foo: { type: 'int' },\n            flag: { type: 'bool' },\n          },\n        },\n      });\n      expect(m.exec('/1138/1')).toEqual({ foo: 1138, flag: true });\n      expect(m.format({ foo: 5, flag: true })).toBe('/5/1');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should throw an error if a param type is declared twice","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":723,"column":63},"line":723,"code":"    it('should throw an error if a param type is declared twice', function () {\n      expect(function () {\n        $umf.compile('/{foo:int}', {\n          state: {\n            params: {\n              foo: { type: 'int' },\n            },\n          },\n        });\n      }).toThrow(new Error(\"Param 'foo' has two type configurations.\"));\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode/decode dates","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":735,"column":34},"line":735,"code":"    it('should encode/decode dates', function () {\n      const m = $umf.compile('/calendar/{date:date}'),\n        result = m.exec('/calendar/2014-03-26');\n      const date = new Date(2014, 2, 26);\n\n      expect(result.date instanceof Date).toBe(true);\n      expect(result.date.toUTCString()).toEqual(date.toUTCString());\n      expect(m.format({ date: date })).toBe('/calendar/2014-03-26');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should encode/decode arbitrary objects to json","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":745,"column":54},"line":745,"code":"    it('should encode/decode arbitrary objects to json', function () {\n      const m = $umf.compile('/state/{param1:json}/{param2:json}');\n\n      const params = {\n        param1: { foo: 'huh', count: 3 },\n        param2: { foo: 'wha', count: 5 },\n      };\n\n      const json1 = '{\"foo\":\"huh\",\"count\":3}';\n      const json2 = '{\"foo\":\"wha\",\"count\":5}';\n\n      expect(m.format(params)).toBe('/state/' + encodeURIComponent(json1) + '/' + encodeURIComponent(json2));\n      expect(m.exec('/state/' + json1 + '/' + json2)).toEqual(params);\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not match invalid typed parameter values","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":760,"column":55},"line":760,"code":"    it('should not match invalid typed parameter values', function () {\n      const m = $umf.compile('/users/{id:int}');\n\n      expect(m.exec('/users/1138').id).toBe(1138);\n      expect(m.exec('/users/alpha')).toBeNull();\n\n      expect(m.format({ id: 1138 })).toBe('/users/1138');\n      expect(m.format({ id: 'alpha' })).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should automatically handle multiple search param values","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":770,"column":64},"line":770,"code":"    it('should automatically handle multiple search param values', function () {\n      const m = $umf.compile('/foo/{fooid:int}?{bar:int}');\n\n      $url.url('/foo/5?bar=1');\n      expect(m.exec($url.path(), $url.search())).toEqual({ fooid: 5, bar: 1 });\n      expect(m.format({ fooid: 5, bar: 1 })).toEqual('/foo/5?bar=1');\n\n      $url.url('/foo/5?bar=1&bar=2&bar=3');\n      if (angular.isArray($url.search()))\n        // conditional for angular 1.0.8\n        expect(m.exec($url.path(), $url.search())).toEqual({ fooid: 5, bar: [1, 2, 3] });\n      expect(m.format({ fooid: 5, bar: [1, 2, 3] })).toEqual('/foo/5?bar=1&bar=2&bar=3');\n\n      m.format();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should allow custom types to handle multiple search param values manually","suites":["urlMatcherFactory","typed parameters"],"updatePoint":{"line":786,"column":81},"line":786,"code":"    it('should allow custom types to handle multiple search param values manually', function () {\n      $umf.type('custArray', {\n        encode: function (array) {\n          return array.join('-');\n        },\n        decode: function (val) {\n          return angular.isArray(val) ? val : val.split(/-/);\n        },\n        equals: angular.equals,\n        is: angular.isArray,\n      });\n\n      const m = $umf.compile('/foo?{bar:custArray}', { state: { params: { bar: { array: false } } } });\n\n      $url.url('/foo?bar=fox');\n      expect(m.exec($url.path(), $url.search())).toEqual({ bar: ['fox'] });\n      expect(m.format({ bar: ['fox'] })).toEqual('/foo?bar=fox');\n\n      $url.url('/foo?bar=quick-brown-fox');\n      expect(m.exec($url.path(), $url.search())).toEqual({ bar: ['quick', 'brown', 'fox'] });\n      expect(m.format({ bar: ['quick', 'brown', 'fox'] })).toEqual('/foo?bar=quick-brown-fox');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match with or without values","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":811,"column":43},"line":811,"code":"    it('should match with or without values', function () {\n      const m = $umf.compile('/users/{id:int}', {\n        state: {\n          params: { id: { value: null, squash: true } },\n        },\n      });\n      expect(m.exec('/users/1138')).toEqual({ id: 1138 });\n      expect(m.exec('/users1138')).toBeNull();\n      expect(m.exec('/users/').id).toBeNull();\n      expect(m.exec('/users').id).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should correctly match multiple","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":823,"column":39},"line":823,"code":"    it('should correctly match multiple', function () {\n      const m = $umf.compile('/users/{id:int}/{state:[A-Z]+}', {\n        state: {\n          params: { id: { value: null, squash: true }, state: { value: null, squash: true } },\n        },\n      });\n      expect(m.exec('/users/1138')).toEqual({ id: 1138, state: null });\n      expect(m.exec('/users/1138/NY')).toEqual({ id: 1138, state: 'NY' });\n\n      expect(m.exec('/users/').id).toBeNull();\n      expect(m.exec('/users/').state).toBeNull();\n\n      expect(m.exec('/users').id).toBeNull();\n      expect(m.exec('/users').state).toBeNull();\n\n      expect(m.exec('/users/NY').state).toBe('NY');\n      expect(m.exec('/users/NY').id).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should correctly format with or without values","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":842,"column":54},"line":842,"code":"    it('should correctly format with or without values', function () {\n      const m = $umf.compile('/users/{id:int}', {\n        state: {\n          params: { id: { value: null } },\n        },\n      });\n      expect(m.format()).toBe('/users/');\n      expect(m.format({ id: 1138 })).toBe('/users/1138');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should correctly format multiple","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":852,"column":40},"line":852,"code":"    it('should correctly format multiple', function () {\n      const m = $umf.compile('/users/{id:int}/{state:[A-Z]+}', {\n        state: {\n          params: { id: { value: null, squash: true }, state: { value: null, squash: true } },\n        },\n      });\n\n      expect(m.format()).toBe('/users');\n      expect(m.format({ id: 1138 })).toBe('/users/1138');\n      expect(m.format({ state: 'NY' })).toBe('/users/NY');\n      expect(m.format({ id: 1138, state: 'NY' })).toBe('/users/1138/NY');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match in between static segments","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":865,"column":47},"line":865,"code":"    it('should match in between static segments', function () {\n      const m = $umf.compile('/users/{user:int}/photos', {\n        state: {\n          params: { user: { value: 5, squash: true } },\n        },\n      });\n      expect(m.exec('/users/photos').user).toBe(5);\n      expect(m.exec('/users/6/photos').user).toBe(6);\n      expect(m.format()).toBe('/users/photos');\n      expect(m.format({ user: 1138 })).toBe('/users/1138/photos');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should correctly format with an optional followed by a required parameter","suites":["urlMatcherFactory","optional parameters"],"updatePoint":{"line":877,"column":81},"line":877,"code":"    it('should correctly format with an optional followed by a required parameter', function () {\n      const m = $umf.compile('/home/:user/gallery/photos/:photo', {\n        state: {\n          params: {\n            user: { value: null, squash: true },\n            photo: undefined,\n          },\n        },\n      });\n      expect(m.format({ photo: 12 })).toBe('/home/gallery/photos/12');\n      expect(m.format({ user: 1138, photo: 13 })).toBe('/home/1138/gallery/photos/13');\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should populate if not supplied in URL","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":891,"column":48},"line":891,"code":"      it('should populate if not supplied in URL', function () {\n        const m = $umf.compile('/users/{id:int}/{test}', {\n          state: {\n            params: { id: { value: 0, squash: true }, test: { value: 'foo', squash: true } },\n          },\n        });\n        expect(m.exec('/users')).toEqual({ id: 0, test: 'foo' });\n        expect(m.exec('/users/2')).toEqual({ id: 2, test: 'foo' });\n        expect(m.exec('/users/bar')).toEqual({ id: 0, test: 'bar' });\n        expect(m.exec('/users/2/bar')).toEqual({ id: 2, test: 'bar' });\n        expect(m.exec('/users/bar/2')).toBeNull();\n      });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should populate even if the regexp requires 1 or more chars","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":904,"column":69},"line":904,"code":"      it('should populate even if the regexp requires 1 or more chars', function () {\n        const m = $umf.compile('/record/{appId}/{recordId:[0-9a-fA-F]{10,24}}', {\n          state: {\n            params: { appId: null, recordId: null },\n          },\n        });\n        expect(m.exec('/record/546a3e4dd273c60780e35df3/')).toEqual({\n          appId: '546a3e4dd273c60780e35df3',\n          recordId: null,\n        });\n      });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should allow shorthand definitions","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":916,"column":44},"line":916,"code":"      it('should allow shorthand definitions', function () {\n        const m = $umf.compile('/foo/:foo', {\n          state: {\n            params: { foo: 'bar' },\n          },\n        });\n        expect(m.exec('/foo/')).toEqual({ foo: 'bar' });\n      });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should populate query params","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":925,"column":38},"line":925,"code":"      it('should populate query params', function () {\n        const defaults = { order: 'name', limit: 25, page: 1 };\n        const m = $umf.compile('/foo?order&{limit:int}&{page:int}', {\n          state: {\n            params: defaults,\n          },\n        });\n        expect(m.exec('/foo')).toEqual(defaults);\n      });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should allow function-calculated values","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":935,"column":49},"line":935,"code":"      it('should allow function-calculated values', function () {\n        function barFn() {\n          return 'Value from bar()';\n        }\n        let m = $umf.compile('/foo/:bar', {\n          state: {\n            params: { bar: barFn },\n          },\n        });\n        expect(m.exec('/foo/').bar).toBe('Value from bar()');\n\n        m = $umf.compile('/foo/:bar', {\n          state: {\n            params: { bar: { value: barFn, squash: true } },\n          },\n        });\n        expect(m.exec('/foo').bar).toBe('Value from bar()');\n\n        m = $umf.compile('/foo?bar', {\n          state: {\n            params: { bar: barFn },\n          },\n        });\n        expect(m.exec('/foo').bar).toBe('Value from bar()');\n      });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should allow injectable functions","suites":["urlMatcherFactory","optional parameters","default values"],"updatePoint":{"line":961,"column":43},"line":961,"code":"      it('should allow injectable functions', inject(function ($stateParams) {\n        const m = $umf.compile('/users/{user:json}', {\n          state: {\n            params: {\n              user: function ($stateParams) {\n                return $stateParams.user;\n              },\n            },\n          },\n        });\n        const user = { name: 'Bob' };\n\n        $stateParams.user = user;\n        expect(m.exec('/users/').user).toBe(user);\n      }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":": true should squash the default value and one slash","suites":["urlMatcherFactory","optional parameters","default values","squash policy"],"updatePoint":{"line":1005,"column":64},"line":1005,"code":"        it(': true should squash the default value and one slash', inject(function ($stateParams) {\n          const m = getMatcher(true);\n\n          const defaultParams = { userid: 'loggedinuser', galleryid: 'favorites', photoid: '123' };\n          expect(m.exec('/user/gallery/photo/123')).toEqual(defaultParams);\n          expect(m.exec('/user//gallery//photo/123')).toEqual(defaultParams);\n          expect(m.format(defaultParams)).toBe('/user/gallery/photo/123');\n\n          const nonDefaultParams = { userid: 'otheruser', galleryid: 'travel', photoid: '987' };\n          expect(m.exec('/user/otheruser/gallery/travel/photo/987')).toEqual(nonDefaultParams);\n          expect(m.format(nonDefaultParams)).toBe('/user/otheruser/gallery/travel/photo/987');\n        }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":": false should not squash default values","suites":["urlMatcherFactory","optional parameters","default values","squash policy"],"updatePoint":{"line":1018,"column":52},"line":1018,"code":"        it(': false should not squash default values', inject(function ($stateParams) {\n          const m = getMatcher(false);\n\n          const defaultParams = { userid: 'loggedinuser', galleryid: 'favorites', photoid: '123' };\n          expect(m.exec('/user/loggedinuser/gallery/favorites/photo/123')).toEqual(defaultParams);\n          expect(m.format(defaultParams)).toBe('/user/loggedinuser/gallery/favorites/photo/123');\n\n          const nonDefaultParams = { userid: 'otheruser', galleryid: 'travel', photoid: '987' };\n          expect(m.exec('/user/otheruser/gallery/travel/photo/987')).toEqual(nonDefaultParams);\n          expect(m.format(nonDefaultParams)).toBe('/user/otheruser/gallery/travel/photo/987');\n        }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":": '' should squash the default value to an empty string","suites":["urlMatcherFactory","optional parameters","default values","squash policy"],"updatePoint":{"line":1030,"column":67},"line":1030,"code":"        it(\": '' should squash the default value to an empty string\", inject(function ($stateParams) {\n          const m = getMatcher('');\n\n          const defaultParams = { userid: 'loggedinuser', galleryid: 'favorites', photoid: '123' };\n          expect(m.exec('/user//gallery//photo/123')).toEqual(defaultParams);\n          expect(m.format(defaultParams)).toBe('/user//gallery//photo/123');\n\n          const nonDefaultParams = { userid: 'otheruser', galleryid: 'travel', photoid: '987' };\n          expect(m.exec('/user/otheruser/gallery/travel/photo/987')).toEqual(nonDefaultParams);\n          expect(m.format(nonDefaultParams)).toBe('/user/otheruser/gallery/travel/photo/987');\n        }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":": '~' should squash the default value and replace it with '~'","suites":["urlMatcherFactory","optional parameters","default values","squash policy"],"updatePoint":{"line":1042,"column":73},"line":1042,"code":"        it(\": '~' should squash the default value and replace it with '~'\", inject(function ($stateParams) {\n          const m = getMatcher('~');\n\n          const defaultParams = { userid: 'loggedinuser', galleryid: 'favorites', photoid: '123' };\n          expect(m.exec('/user//gallery//photo/123')).toEqual(defaultParams);\n          expect(m.exec('/user/~/gallery/~/photo/123')).toEqual(defaultParams);\n          expect(m.format(defaultParams)).toBe('/user/~/gallery/~/photo/123');\n\n          const nonDefaultParams = { userid: 'otheruser', galleryid: 'travel', photoid: '987' };\n          expect(m.exec('/user/otheruser/gallery/travel/photo/987')).toEqual(nonDefaultParams);\n          expect(m.format(nonDefaultParams)).toBe('/user/otheruser/gallery/travel/photo/987');\n        }));","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match with or without trailing slash","suites":["urlMatcherFactory","strict matching"],"updatePoint":{"line":1059,"column":51},"line":1059,"code":"    it('should match with or without trailing slash', function () {\n      const m = $umf.compile('/users', { strict: false });\n      expect(m.exec('/users')).toEqual({});\n      expect(m.exec('/users/')).toEqual({});\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should not match multiple trailing slashes","suites":["urlMatcherFactory","strict matching"],"updatePoint":{"line":1065,"column":50},"line":1065,"code":"    it('should not match multiple trailing slashes', function () {\n      const m = $umf.compile('/users', { strict: false });\n      expect(m.exec('/users//')).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should match when defined with parameters","suites":["urlMatcherFactory","strict matching"],"updatePoint":{"line":1070,"column":49},"line":1070,"code":"    it('should match when defined with parameters', function () {\n      const m = $umf.compile('/users/{name}', {\n        strict: false,\n        state: {\n          params: {\n            name: { value: null },\n          },\n        },\n      });\n      expect(m.exec('/users/')).toEqual({ name: null });\n      expect(m.exec('/users/bob')).toEqual({ name: 'bob' });\n      expect(m.exec('/users/bob/')).toEqual({ name: 'bob' });\n      expect(m.exec('/users/bob//')).toBeNull();\n    });","file":"urlMatcherFactorySpec.ts","skipped":false,"dir":"test"},{"name":"should throw on non-function rules","suites":["UrlRouter","provider"],"updatePoint":{"line":39,"column":42},"line":39,"code":"    it('should throw on non-function rules', function () {\n      expect(function () {\n        $urp.rule(null);\n      }).toThrowError(\"'rule' must be a function\");\n      expect(function () {\n        $urp.otherwise(null);\n      }).toThrowError(\"'rule' must be a string or function\");\n    });","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should allow location changes to be deferred","suites":["UrlRouter","provider"],"updatePoint":{"line":48,"column":52},"line":48,"code":"    it('should allow location changes to be deferred', inject(function ($urlRouter, $location, $rootScope) {\n      const log = [];\n\n      $urp.rule(function ($injector, $location) {\n        log.push($location.path());\n        return null;\n      });\n\n      $location.path('/foo');\n      $rootScope.$broadcast('$locationChangeSuccess');\n\n      expect(log).toEqual([]);\n\n      $urlRouter.listen();\n      $rootScope.$broadcast('$locationChangeSuccess');\n\n      expect(log).toEqual(['/foo']);\n    }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should execute rewrite rules","suites":["UrlRouter","service"],"updatePoint":{"line":102,"column":36},"line":102,"code":"    it('should execute rewrite rules', function () {\n      location.path('/foo');\n      scope.$emit('$locationChangeSuccess');\n      expect(location.path()).toBe('/foo');\n\n      location.path('/baz');\n      scope.$emit('$locationChangeSuccess');\n      expect(location.path()).toBe('/b4z');\n    });","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should keep otherwise last","suites":["UrlRouter","service"],"updatePoint":{"line":112,"column":34},"line":112,"code":"    it('should keep otherwise last', function () {\n      $urp.otherwise('/otherwise');\n\n      location.path('/lastrule');\n      scope.$emit('$locationChangeSuccess');\n      expect(location.path()).toBe('/otherwise');\n\n      $urp.when('/lastrule', function ($match) {\n        match = ['/lastrule', $match];\n      });\n\n      location.path('/lastrule');\n      scope.$emit('$locationChangeSuccess');\n      expect(location.path()).toBe('/lastrule');\n    });","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can be cancelled by preventDefault() in $locationChangeSuccess","suites":["UrlRouter","service"],"updatePoint":{"line":128,"column":70},"line":128,"code":"    it('can be cancelled by preventDefault() in $locationChangeSuccess', inject(function () {\n      let called;\n      location.path('/baz');\n      scope.$on('$locationChangeSuccess', function (ev) {\n        ev.preventDefault();\n        called = true;\n      });\n      scope.$emit('$locationChangeSuccess');\n      expect(called).toBeTruthy();\n      expect(location.path()).toBe('/baz');\n    }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can be deferred and updated in $locationChangeSuccess","suites":["UrlRouter","service"],"updatePoint":{"line":140,"column":61},"line":140,"code":"    it('can be deferred and updated in $locationChangeSuccess', inject(function ($urlRouter, $timeout) {\n      let called;\n      location.path('/baz');\n      scope.$on('$locationChangeSuccess', function (ev) {\n        ev.preventDefault();\n        called = true;\n        $timeout(() => $urlRouter.sync(), 2000);\n      });\n      scope.$emit('$locationChangeSuccess');\n      $timeout.flush();\n      expect(called).toBeTruthy();\n      expect(location.path()).toBe('/b4z');\n    }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"rule should return a deregistration function","suites":["UrlRouter","service"],"updatePoint":{"line":154,"column":52},"line":154,"code":"    it('rule should return a deregistration function', function () {\n      let count = 0;\n      let rule: UrlRule = {\n        match: () => count++,\n        handler: (match) => match,\n        matchPriority: () => 0,\n        $id: 0,\n        priority: 0,\n        _group: 0,\n        type: 'RAW',\n      };\n      const dereg = $ur.rule(rule as any);\n\n      $ur.sync();\n      expect(count).toBe(1);\n      $ur.sync();\n      expect(count).toBe(2);\n\n      dereg();\n      $ur.sync();\n      expect(count).toBe(2);\n    });","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"removeRule should remove a previously registered rule","suites":["UrlRouter","service"],"updatePoint":{"line":177,"column":61},"line":177,"code":"    it('removeRule should remove a previously registered rule', function () {\n      let count = 0;\n      let rule: UrlRule = {\n        match: () => count++,\n        handler: (match) => match,\n        matchPriority: () => 0,\n        $id: 0,\n        priority: 0,\n        _group: 0,\n        type: 'RAW',\n      };\n      $ur.rule(rule as any);\n\n      $ur.sync();\n      expect(count).toBe(1);\n      $ur.sync();\n      expect(count).toBe(2);\n\n      $ur.removeRule(rule);\n      $ur.sync();\n      expect(count).toBe(2);\n    });","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can push location changes","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":201,"column":35},"line":201,"code":"      it('can push location changes', inject(function ($urlRouter) {\n        const spy = spyOn(router.locationService, 'url');\n        $urlRouter.push($umf.compile('/hello/:name'), { name: 'world' });\n        expect(spy).toHaveBeenCalled();\n        expect(spy.calls.mostRecent().args[0]).toBe('/hello/world');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can push a replacement location","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":208,"column":41},"line":208,"code":"      it('can push a replacement location', inject(function ($urlRouter, $location) {\n        const spy = spyOn(router.locationService, 'url');\n        $urlRouter.push($umf.compile('/hello/:name'), { name: 'world' }, { replace: true });\n        expect(spy).toHaveBeenCalled();\n        expect(spy.calls.mostRecent().args.slice(0, 2)).toEqual(['/hello/world', true]);\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can push location changes with no parameters","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":215,"column":54},"line":215,"code":"      it('can push location changes with no parameters', inject(function ($urlRouter, $location) {\n        const spy = spyOn(router.locationService, 'url');\n        $urlRouter.push($umf.compile('/hello/:name', { state: { params: { name: '' } } }));\n        expect(spy).toHaveBeenCalled();\n        expect(spy.calls.mostRecent().args[0]).toBe('/hello/');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can push an empty url","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":222,"column":31},"line":222,"code":"      it('can push an empty url', inject(function ($urlRouter, $location) {\n        const spy = spyOn(router.locationService, 'url');\n        $urlRouter.push($umf.compile('/{id}', { state: { params: { id: { squash: true, value: null } } } }));\n        expect(spy).toHaveBeenCalled();\n        expect(spy.calls.mostRecent().args[0]).toBe('');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"updates url after an empty url is pushed","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":232,"column":52},"line":232,"code":"        it('updates url after an empty url is pushed', inject(function ($urlRouter, $location) {\n          $lp.html5Mode(false);\n          const spy = spyOn(router.locationService, 'url').and.callThrough();\n          $urlRouter.push($umf.compile('/foobar'));\n          expect(spy.calls.mostRecent().args[0]).toBe('/foobar');\n          $urlRouter.push($umf.compile('/{id}', { state: { params: { id: { squash: true, value: null } } } }));\n          expect(spy.calls.mostRecent().args[0]).toBe('');\n          expect(router.locationService.url()).toBe('/');\n        }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"updates html5mode url after an empty url is pushed","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":243,"column":62},"line":243,"code":"        it('updates html5mode url after an empty url is pushed', inject(function ($urlRouter, $location) {\n          $lp.html5Mode(true);\n          const spy = spyOn(router.locationService, 'url').and.callThrough();\n          $urlRouter.push($umf.compile('/foobar'));\n          expect(spy.calls.mostRecent().args[0]).toBe('/foobar');\n          $urlRouter.push($umf.compile('/{id}', { state: { params: { id: { squash: true, value: null } } } }));\n          expect(spy.calls.mostRecent().args[0]).toBe('');\n          expect(router.locationService.url()).toBe('/');\n        }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can push location changes that include a #fragment","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":254,"column":60},"line":254,"code":"      it('can push location changes that include a #fragment', inject(function ($urlRouter, $location) {\n        // html5mode disabled\n        $lp.html5Mode(false);\n        expect(html5Compat($lp.html5Mode())).toBe(false);\n        $urlRouter.push($umf.compile('/hello/:name'), { name: 'world', '#': 'frag' });\n        expect($location.url()).toBe('/hello/world#frag');\n        expect($location.hash()).toBe('frag');\n\n        // html5mode enabled\n        $lp.html5Mode(true);\n        expect(html5Compat($lp.html5Mode())).toBe(true);\n        $urlRouter.push($umf.compile('/hello/:name'), { name: 'world', '#': 'frag' });\n        expect($location.url()).toBe('/hello/world#frag');\n        expect($location.hash()).toBe('frag');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can read and sync a copy of location URL","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":270,"column":50},"line":270,"code":"      it('can read and sync a copy of location URL', inject(function ($urlRouter, $location) {\n        $location.url('/old');\n\n        spyOn(router.locationService, 'url').and.callThrough();\n        $urlRouter.update(true);\n        expect(router.locationService.url).toHaveBeenCalled();\n\n        $location.url('/new');\n        $urlRouter.update();\n\n        expect($location.url()).toBe('/old');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"can read and sync a copy of location URL including query params","suites":["UrlRouter","service","location updates"],"updatePoint":{"line":283,"column":73},"line":283,"code":"      it('can read and sync a copy of location URL including query params', inject(function ($urlRouter, $location) {\n        $location.url('/old?param=foo');\n\n        spyOn(router.locationService, 'url').and.callThrough();\n        $urlRouter.update(true);\n        expect(router.locationService.url).toHaveBeenCalled();\n\n        $location.url('/new?param=bar');\n        $urlRouter.update();\n\n        expect($location.url()).toBe('/old?param=foo');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should return null when UrlMatcher rejects parameters","suites":["UrlRouter","service","URL generation"],"updatePoint":{"line":298,"column":63},"line":298,"code":"      it('should return null when UrlMatcher rejects parameters', inject(function ($urlRouter: UrlRouter) {\n        $umf.type('custom', <any>{ is: (val) => val === 1138 });\n        const matcher = $umf.compile('/foo/{param:custom}');\n\n        expect($urlRouter.href(matcher, { param: 1138 })).toBe('#/foo/1138');\n        expect($urlRouter.href(matcher, { param: 5 })).toBeNull();\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should handle the new html5Mode object config from Angular 1.3","suites":["UrlRouter","service","URL generation"],"updatePoint":{"line":306,"column":72},"line":306,"code":"      it('should handle the new html5Mode object config from Angular 1.3', inject(function ($urlRouter: UrlRouter) {\n        $lp.html5Mode({\n          enabled: false,\n        });\n\n        expect($urlRouter.href($umf.compile('/hello'))).toBe('#/hello');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should return URLs with #fragments","suites":["UrlRouter","service","URL generation"],"updatePoint":{"line":314,"column":44},"line":314,"code":"      it('should return URLs with #fragments', inject(function ($urlRouter: UrlRouter) {\n        // html5mode disabled\n        $lp.html5Mode(false);\n        expect(html5Compat($lp.html5Mode())).toBe(false);\n        expect($urlRouter.href($umf.compile('/hello/:name'), { name: 'world', '#': 'frag' })).toBe(\n          '#/hello/world#frag'\n        );\n\n        // html5mode enabled\n        $lp.html5Mode(true);\n        expect(html5Compat($lp.html5Mode())).toBe(true);\n        expect($urlRouter.href($umf.compile('/hello/:name'), { name: 'world', '#': 'frag' })).toBe('/hello/world#frag');\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"should return URLs with #fragments when html5Mode is true & browser does not support pushState","suites":["UrlRouter","service","URL generation"],"updatePoint":{"line":328,"column":104},"line":328,"code":"      it('should return URLs with #fragments when html5Mode is true & browser does not support pushState', inject(function (\n        $urlRouter: UrlRouter\n      ) {\n        $lp.html5Mode(true);\n        $s['history'] = false;\n        expect(html5Compat($lp.html5Mode())).toBe(true);\n        expect($urlRouter.href($umf.compile('/hello/:name'), { name: 'world', '#': 'frag' })).toBe(\n          '#/hello/world#frag'\n        );\n      }));","file":"urlRouterSpec.ts","skipped":false,"dir":"test"},{"name":"anonymous ui-view should be replaced with the template of the current $state","suites":["uiView","linking ui-directive"],"updatePoint":{"line":164,"column":84},"line":164,"code":"    it('anonymous ui-view should be replaced with the template of the current $state', inject(function ($state, $q) {\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      expect(elem.find('ui-view').text()).toBe('');\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(aState.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"named ui-view should be replaced with the template of the current $state","suites":["uiView","linking ui-directive"],"updatePoint":{"line":175,"column":80},"line":175,"code":"    it('named ui-view should be replaced with the template of the current $state', inject(function ($state, $q) {\n      elem.append($compile('<div><ui-view name=\"cview\"></ui-view></div>')(scope));\n\n      $state.transitionTo(cState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(cState.views.cview.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"ui-view should be updated after transition to another state","suites":["uiView","linking ui-directive"],"updatePoint":{"line":184,"column":67},"line":184,"code":"    it('ui-view should be updated after transition to another state', inject(function ($state, $q) {\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n      expect(elem.find('ui-view').text()).toBe('');\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(aState.template);\n\n      $state.transitionTo(bState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(bState.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should handle NOT nested ui-views","suites":["uiView","linking ui-directive"],"updatePoint":{"line":199,"column":41},"line":199,"code":"    it('should handle NOT nested ui-views', inject(function ($state, $q) {\n      elem.append(\n        $compile(\n          '<div><ui-view name=\"dview1\" class=\"dview1\"></ui-view><ui-view name=\"dview2\" class=\"dview2\"></ui-view></div>'\n        )(scope)\n      );\n      expect(elem.find('ui-view').eq(0).text()).toBe('');\n      expect(elem.find('ui-view').eq(1).text()).toBe('');\n\n      $state.transitionTo(dState);\n      $q.flush();\n\n      expect(elem.find('ui-view').eq(0).text()).toBe(dState.views.dview1.template);\n      expect(elem.find('ui-view').eq(1).text()).toBe(dState.views.dview2.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should handle nested ui-views (testing two levels deep)","suites":["uiView","linking ui-directive"],"updatePoint":{"line":215,"column":63},"line":215,"code":"    it('should handle nested ui-views (testing two levels deep)', inject(function ($state, $q) {\n      $compile(elem.append('<div><ui-view></ui-view></div>'))(scope);\n      expect(elem.find('ui-view').text()).toBe('');\n\n      $state.transitionTo(fState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(fState.views.eview.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"initial view should be compiled if the view is empty","suites":["uiView","handling initial view"],"updatePoint":{"line":227,"column":60},"line":227,"code":"    it('initial view should be compiled if the view is empty', inject(function ($state, $q) {\n      const content = 'inner content';\n      scope.content = content;\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo(gState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(content);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"initial view should be put back after removal of the view","suites":["uiView","handling initial view"],"updatePoint":{"line":238,"column":65},"line":238,"code":"    it('initial view should be put back after removal of the view', inject(function ($state, $q) {\n      const content = 'inner content';\n      scope.content = content;\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.go(hState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(hState.views.inner.template);\n\n      // going to the parent state which makes the inner view empty\n      $state.go(gState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(content);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"initial view should be transcluded once to prevent breaking other directives","suites":["uiView","handling initial view"],"updatePoint":{"line":256,"column":84},"line":256,"code":"    it('initial view should be transcluded once to prevent breaking other directives', inject(function ($state, $q) {\n      scope.items = ['I', 'am', 'a', 'list', 'of', 'items'];\n\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      // transition to state that has an initial view\n      $state.transitionTo(iState);\n      $q.flush();\n\n      // verify if ng-repeat has been compiled\n      expect(elem.find('li').length).toBe(scope.items.length);\n\n      // transition to another state that replace the initial content\n      $state.transitionTo(jState);\n      $q.flush();\n\n      expect(elem.find('ui-view').text()).toBe(jState.template);\n\n      // transition back to the state with empty subview and the initial view\n      $state.transitionTo(iState);\n      $q.flush();\n\n      // verify if the initial view is correct\n      expect(elem.find('li').length).toBe(scope.items.length);\n\n      // change scope properties\n      scope.$apply(function () {\n        scope.items.push('.', 'Working?');\n      });\n\n      // verify if the initial view has been updated\n      expect(elem.find('li').length).toBe(scope.items.length);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should NOT autoscroll when unspecified","suites":["uiView","autoscroll attribute"],"updatePoint":{"line":292,"column":46},"line":292,"code":"    it('should NOT autoscroll when unspecified', inject(function ($state, $q, $uiViewScroll, $animate) {\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      animateFlush($animate);\n\n      expect($uiViewScroll).not.toHaveBeenCalled();\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should autoscroll when expression is missing","suites":["uiView","autoscroll attribute"],"updatePoint":{"line":303,"column":52},"line":303,"code":"    it('should autoscroll when expression is missing', inject(function ($state, $q, $uiViewScroll, $animate) {\n      elem.append($compile('<div><ui-view autoscroll></ui-view></div>')(scope));\n      $state.transitionTo(aState);\n      $q.flush();\n\n      animateFlush($animate);\n\n      expect($uiViewScroll).toHaveBeenCalledWith(elem.find('ui-view'));\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should autoscroll based on expression","suites":["uiView","autoscroll attribute"],"updatePoint":{"line":313,"column":45},"line":313,"code":"    it('should autoscroll based on expression', inject(function ($state, $q, $uiViewScroll, $animate) {\n      scope.doScroll = false;\n\n      elem.append($compile('<div><ui-view autoscroll=\"doScroll\"></ui-view></div>')(scope));\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      animateFlush($animate);\n\n      expect($uiViewScroll).not.toHaveBeenCalled();\n\n      scope.doScroll = true;\n      $state.transitionTo(bState);\n      $q.flush();\n\n      animateFlush($animate);\n\n      let target,\n        index = -1,\n        uiViews = elem.find('ui-view');\n\n      while (index++ < uiViews.length) {\n        const uiView = angular.element(uiViews[index]);\n        if (uiView.text() === bState.template) target = uiView;\n      }\n\n      expect($uiViewScroll).toHaveBeenCalledWith(target);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should instantiate a controller with controllerAs","suites":["uiView","autoscroll attribute"],"updatePoint":{"line":344,"column":55},"line":344,"code":"  it('should instantiate a controller with controllerAs', inject(function ($state, $q) {\n    elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n    $state.transitionTo(kState);\n    $q.flush();\n\n    expect(elem.text()).toBe('value');\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should instantiate a controller with both $scope and $element injections","suites":["uiView","autoscroll attribute"],"updatePoint":{"line":352,"column":78},"line":352,"code":"  it('should instantiate a controller with both $scope and $element injections', inject(function ($state, $q) {\n    elem.append($compile('<div><ui-view id=\"mState\">{{elementId}}</ui-view></div>')(scope));\n    $state.transitionTo(mState);\n    $q.flush();\n\n    expect(elem.text()).toBe('mState');\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should provide the resolved data on the $scope","suites":["uiView","(resolved data)"],"updatePoint":{"line":377,"column":54},"line":377,"code":"    it('should provide the resolved data on the $scope', inject(function ($state, $q, $timeout) {\n      const state = angular.extend({}, _state, { template: '{{$resolve.user}}', controller: controller });\n      $stateProvider.state(state);\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo('resolve');\n      $q.flush();\n      $timeout.flush();\n      expect(elem.text()).toBe('joeschmoe');\n      expect(_scope.$resolve).toBeDefined();\n      expect(_scope.$resolve.user).toBe('joeschmoe');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should provide the resolved data on the $scope even if there is no controller","suites":["uiView","(resolved data)"],"updatePoint":{"line":391,"column":85},"line":391,"code":"    it('should provide the resolved data on the $scope even if there is no controller', inject(function (\n      $state,\n      $q,\n      $timeout\n    ) {\n      const state = angular.extend({}, _state, { template: '{{$resolve.user}}' });\n      $stateProvider.state(state);\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n      expect(elem.text()).toBe('');\n\n      $state.transitionTo('resolve');\n      $q.flush();\n      $timeout.flush();\n      expect(elem.text()).toBe('joeschmoe');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should put the resolved data on the resolveAs variable","suites":["uiView","(resolved data)"],"updatePoint":{"line":407,"column":62},"line":407,"code":"    it('should put the resolved data on the resolveAs variable', inject(function ($state, $q, $timeout) {\n      const state = angular.extend({}, _state, {\n        template: '{{$$$resolve.user}}',\n        resolveAs: '$$$resolve',\n        controller: controller,\n      });\n      $stateProvider.state(state);\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo('resolve');\n      $q.flush();\n      $timeout.flush();\n      expect(elem.text()).toBe('joeschmoe');\n      expect(_scope.$$$resolve).toBeDefined();\n      expect(_scope.$$$resolve.user).toBe('joeschmoe');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should put the resolved data on the controllerAs","suites":["uiView","(resolved data)"],"updatePoint":{"line":424,"column":56},"line":424,"code":"    it('should put the resolved data on the controllerAs', inject(function ($state, $q, $timeout) {\n      const state = angular.extend({}, _state, {\n        template: '{{$ctrl.$resolve.user}}',\n        controllerAs: '$ctrl',\n        controller: controller,\n      });\n      $stateProvider.state(state);\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo('resolve');\n      $q.flush();\n      $timeout.flush();\n      expect(elem.text()).toBe('joeschmoe');\n      expect(_scope.$resolve).toBeDefined();\n      expect(_scope.$ctrl).toBeDefined();\n      expect(_scope.$ctrl.$resolve).toBeDefined();\n      expect(_scope.$ctrl.$resolve.user).toBe('joeschmoe');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should not allow both view-level resolveAs and state-level resolveAs on the same state","suites":["uiView","(resolved data)"],"updatePoint":{"line":443,"column":94},"line":443,"code":"    it('should not allow both view-level resolveAs and state-level resolveAs on the same state', inject(function (\n      $state,\n      $q,\n      $timeout\n    ) {\n      const views = {\n        $default: {\n          controller: controller,\n          template: '{{$$$resolve.user}}',\n          resolveAs: '$$$resolve',\n        },\n      };\n      const state = angular.extend({}, _state, { resolveAs: 'foo', views: views });\n      expect(() => $stateProvider.state(state)).toThrowError(/resolveAs/);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should call the existing $onInit after instantiating a controller","suites":["uiView","(resolved data)"],"updatePoint":{"line":460,"column":71},"line":460,"code":"  it('should call the existing $onInit after instantiating a controller', inject(function ($state, $q) {\n    const $onInit = jasmine.createSpy();\n    $stateProvider.state('onInit', {\n      controller: function () {\n        this.$onInit = $onInit;\n      },\n      template: 'hi',\n      controllerAs: 'vm',\n    });\n    elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n    $state.transitionTo('onInit');\n    $q.flush();\n\n    expect($onInit).toHaveBeenCalled();\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should default the template to a <ui-view>","suites":["uiView","(resolved data)"],"updatePoint":{"line":476,"column":48},"line":476,"code":"  it('should default the template to a <ui-view>', inject(function ($state, $q) {\n    $stateProvider.state('abstract', { abstract: true });\n    $stateProvider.state('abstract.foo', { template: 'hello' });\n    elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n    $state.transitionTo('abstract.foo');\n    $q.flush();\n\n    expect(elem.text()).toBe('hello');\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with ngIf","suites":["uiView","play nicely with other directives"],"updatePoint":{"line":488,"column":29},"line":488,"code":"    it('should work with ngIf', inject(function ($state, $q, $compile) {\n      // ngIf does not exist in 1.0.8\n      if (angular.version.full === '1.0.8') return;\n\n      scope.someBoolean = false;\n      elem.append($compile('<div ng-if=\"someBoolean\"><ui-view></ui-view></div>')(scope));\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      // Verify there is no ui-view in the DOM\n      expect(elem.find('ui-view').length).toBe(0);\n\n      // Turn on the div that holds the ui-view\n      scope.someBoolean = true;\n      scope.$digest();\n\n      // Verify that the ui-view is there and it has the correct content\n      expect(elem.find('ui-view').text()).toBe(aState.template);\n\n      // Turn off the ui-view\n      scope.someBoolean = false;\n      scope.$digest();\n\n      // Verify there is no ui-view in the DOM\n      expect(elem.find('ui-view').length).toBe(0);\n\n      // Turn on the div that holds the ui-view once again\n      scope.someBoolean = true;\n      scope.$digest();\n\n      // Verify that the ui-view is there and it has the correct content\n      expect(elem.find('ui-view').text()).toBe(aState.template);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with ngClass","suites":["uiView","play nicely with other directives"],"updatePoint":{"line":523,"column":32},"line":523,"code":"    it('should work with ngClass', inject(function ($state, $q, $compile) {\n      const classes = (elem) => Array.prototype.slice.call(elem[0].classList);\n\n      scope.showClass = false;\n      elem.append($compile('<div><ui-view ng-class=\"{\\'someClass\\': showClass}\"></ui-view></div>')(scope));\n\n      expect(classes(elem.find('ui-view'))).not.toContain('someClass');\n\n      scope.showClass = true;\n      scope.$digest();\n\n      expect(classes(elem.find('ui-view'))).toContain('someClass');\n\n      scope.showClass = false;\n      scope.$digest();\n\n      expect(classes(elem.find('ui-view'))).not.toContain('someClass');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should have correct number of uiViews","suites":["uiView","play nicely with other directives","working with ngRepeat"],"updatePoint":{"line":546,"column":47},"line":546,"code":"      it('should have correct number of uiViews', inject(function ($state, $q, $compile) {\n        elem.append($compile('<div><ui-view ng-repeat=\"view in views\" name=\"{{view}}\"></ui-view></div>')(scope));\n\n        // Should be no ui-views in DOM\n        expect(elem.find('ui-view').length).toBe(0);\n\n        // Lets add 3\n        scope.views = ['view1', 'view2', 'view3'];\n        scope.$digest();\n\n        // Should be 3 ui-views in the DOM\n        expect(elem.find('ui-view').length).toBe(scope.views.length);\n\n        // Lets add one more - yay two-way binding\n        scope.views.push('view4');\n        scope.$digest();\n\n        // Should have 4 ui-views\n        expect(elem.find('ui-view').length).toBe(scope.views.length);\n\n        // Lets remove 2 ui-views from the DOM\n        scope.views.pop();\n        scope.views.pop();\n        scope.$digest();\n\n        // Should have 2 ui-views\n        expect(elem.find('ui-view').length).toBe(scope.views.length);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should populate each view with content","suites":["uiView","play nicely with other directives","working with ngRepeat"],"updatePoint":{"line":575,"column":48},"line":575,"code":"      it('should populate each view with content', inject(function ($state, $q, $compile) {\n        elem.append(\n          $compile('<div><ui-view ng-repeat=\"view in views\" name=\"{{view}}\">defaultcontent</ui-view></div>')(scope)\n        );\n\n        $state.transitionTo(lState);\n        $q.flush();\n\n        expect(elem.find('ui-view').length).toBe(0);\n\n        scope.views = ['view1', 'view2'];\n\n        scope.$digest();\n\n        let uiViews = elem.find('ui-view');\n\n        expect(uiViews.eq(0).text()).toBe(lState.views.view1.template);\n        expect(uiViews.eq(1).text()).toBe(lState.views.view2.template);\n        expect(uiViews.eq(2).length).toBe(0);\n\n        scope.views.push('view3');\n        scope.$digest();\n\n        uiViews = elem.find('ui-view');\n\n        expect(uiViews.eq(0).text()).toBe(lState.views.view1.template);\n        expect(uiViews.eq(1).text()).toBe(lState.views.view2.template);\n        expect(uiViews.eq(2).text()).toBe(lState.views.view3.template);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should interpolate ui-view names","suites":["uiView","play nicely with other directives","working with ngRepeat"],"updatePoint":{"line":605,"column":42},"line":605,"code":"      it('should interpolate ui-view names', inject(function ($state, $q, $compile) {\n        elem.append(\n          $compile('<div ng-repeat=\"view in views\">' + '<ui-view name=\"view{{$index + 1}}\">hallo</ui-view>' + '</div>')(\n            scope\n          )\n        );\n\n        $state.transitionTo(lState);\n        $q.flush();\n\n        expect(elem.find('ui-view').length).toBe(0);\n\n        scope.views = ['view1', 'view2'];\n\n        scope.$digest();\n\n        let uiViews = elem.find('ui-view');\n\n        expect(uiViews.eq(0).text()).toBe(lState.views.view1.template);\n        expect(uiViews.eq(1).text()).toBe(lState.views.view2.template);\n        expect(uiViews.eq(2).length).toBe(0);\n\n        scope.views.push('view3');\n        scope.$digest();\n\n        uiViews = elem.find('ui-view');\n\n        expect(uiViews.eq(0).text()).toBe(lState.views.view1.template);\n        expect(uiViews.eq(1).text()).toBe(lState.views.view2.template);\n        expect(uiViews.eq(2).text()).toBe(lState.views.view3.template);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should do transition animations","suites":["uiView","AngularJS Animations"],"updatePoint":{"line":640,"column":39},"line":640,"code":"    it('should do transition animations', inject(function ($state, $q, $compile, $animate) {\n      let content = 'Initial Content',\n        animation;\n      elem.append($compile('<div><ui-view>' + content + '</ui-view></div>')(scope));\n\n      // Enter Animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('enter');\n      expect(animation.element.text() + '-1').toBe(content + '-1');\n\n      $state.transitionTo(aState);\n      $q.flush();\n\n      // Enter Animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('enter');\n      expect(animation.element.text() + '-2').toBe(aState.template + '-2');\n      // Leave Animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('leave');\n      expect(animation.element.text() + '-3').toBe(content + '-3');\n\n      $state.transitionTo(bState);\n      $q.flush();\n\n      // Enter Animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('enter');\n      expect(animation.element.text() + '-4').toBe(bState.template + '-4');\n      // Leave Animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('leave');\n      expect(animation.element.text() + '-5').toBe(aState.template + '-5');\n\n      // No more animations\n      expect($animate.queue.length).toBe(0);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should do ngClass animations","suites":["uiView","AngularJS Animations"],"updatePoint":{"line":678,"column":36},"line":678,"code":"    it('should do ngClass animations', inject(function ($state, $q, $compile, $animate) {\n      scope.classOn = false;\n      let content = 'Initial Content',\n        className = 'yay',\n        animation;\n      elem.append(\n        $compile('<div><ui-view ng-class=\"{\\'' + className + '\\': classOn}\">' + content + '</ui-view></div>')(scope)\n      );\n      // Don't care about enter class\n      $animate.queue.shift();\n\n      scope.classOn = true;\n      scope.$digest();\n\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('addClass');\n      expect(animation.element.text()).toBe(content);\n\n      scope.classOn = false;\n      scope.$digest();\n\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('removeClass');\n      expect(animation.element.text()).toBe(content);\n\n      // No more animations\n      expect($animate.queue.length).toBe(0);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should do ngIf animations","suites":["uiView","AngularJS Animations"],"updatePoint":{"line":707,"column":33},"line":707,"code":"    it('should do ngIf animations', inject(function ($state, $q, $compile, $animate) {\n      scope.shouldShow = false;\n      let content = 'Initial Content',\n        animation;\n      elem.append($compile('<div><ui-view ng-if=\"shouldShow\">' + content + '</ui-view></div>')(scope));\n\n      // No animations yet\n      expect($animate.queue.length).toBe(0);\n\n      scope.shouldShow = true;\n      scope.$digest();\n\n      // $ViewDirective enter animation - Basically it's just the <!-- uiView --> comment\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('enter');\n      expect(animation.element.text()).toBe('');\n\n      // $ViewDirectiveFill enter animation - The second uiView directive that files in the content\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('enter');\n      expect(animation.element.text()).toBe(content);\n\n      scope.shouldShow = false;\n      scope.$digest();\n\n      // uiView leave animation\n      animation = $animate.queue.shift();\n      expect(animation.event).toBe('leave');\n      expect(animation.element.text()).toBe(content);\n\n      // No more animations\n      expect($animate.queue.length).toBe(0);\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should expose animation promises to controllers","suites":["uiView","AngularJS Animations"],"updatePoint":{"line":741,"column":55},"line":741,"code":"    it('should expose animation promises to controllers', inject(function (\n      $state,\n      $q,\n      $compile,\n      $animate,\n      $transitions\n    ) {\n      $transitions.onStart({}, function ($transition$) {\n        log += 'start:' + $transition$.to().name + ';';\n      });\n      $transitions.onFinish({}, function ($transition$) {\n        log += 'finish:' + $transition$.to().name + ';';\n      });\n      $transitions.onSuccess({}, function ($transition$) {\n        log += 'success:' + $transition$.to().name + ';';\n      });\n\n      const content = 'Initial Content';\n      elem.append($compile('<div><ui-view>' + content + '</ui-view></div>')(scope));\n      $state.transitionTo('n');\n      $q.flush();\n\n      expect($state.current.name).toBe('n');\n      expect(log).toBe('start:n;finish:n;success:n;');\n\n      animateFlush($animate);\n      $q.flush();\n      expect(log).toBe('start:n;finish:n;success:n;animEnter;');\n\n      $state.transitionTo('a');\n      $q.flush();\n      expect($state.current.name).toBe('a');\n      expect(log).toBe('start:n;finish:n;success:n;animEnter;start:a;finish:a;destroy;success:a;');\n\n      animateFlush($animate);\n      $q.flush();\n      expect(log).toBe('start:n;finish:n;success:n;animEnter;start:a;finish:a;destroy;success:a;animLeave;');\n    }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"shouldn't puke on weird nested view setups","suites":["UiView"],"updatePoint":{"line":793,"column":48},"line":793,"code":"  it(\"shouldn't puke on weird nested view setups\", inject(function ($compile, $rootScope, $q, $state) {\n    $compile('<div ui-view=\"main\"><div ui-view=\"content\"></div></div>')($rootScope);\n\n    $state.go('main.home');\n    $q.flush();\n\n    expect($state.current.name).toBe('main.home');\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should target weird nested view setups using the view's simple name","suites":["UiView"],"updatePoint":{"line":803,"column":73},"line":803,"code":"  it(\"should target weird nested view setups using the view's simple name\", inject(function (\n    $compile,\n    $rootScope,\n    $q,\n    $state\n  ) {\n    const tpl = `\n      <div>\n        <div ui-view=\"main\">\n          MAIN-DEFAULT-\n          <div ui-view=\"content\">\n            <div ui-view=\"nest\"></div>\n          </div>\n        </div>\n      </div>\n    `;\n    const el = $compile(tpl)($rootScope);\n\n    $state.go('test');\n    $q.flush();\n\n    expect($state.current.name).toBe('test');\n    expect(el.text().replace(/\\s*/g, '')).toBe('MAIN-DEFAULT-TEST');\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should not link the initial view and leave its scope undestroyed when a subview is activated","suites":["uiView transclusion"],"updatePoint":{"line":864,"column":98},"line":864,"code":"  it('should not link the initial view and leave its scope undestroyed when a subview is activated', inject(function (\n    $state,\n    $q\n  ) {\n    let aliveCount = 0;\n    scope.$on('directiveCreated', function () {\n      aliveCount++;\n    });\n    scope.$on('directiveDestroyed', function () {\n      aliveCount--;\n    });\n    elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n    $state.transitionTo('a.b');\n    $q.flush();\n    expect(aliveCount).toBe(0);\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should not go into an infinite loop when controller uses $state.go","suites":["uiView controllers or onEnter handlers"],"updatePoint":{"line":912,"column":72},"line":912,"code":"  it('should not go into an infinite loop when controller uses $state.go', inject(function (\n    $rootScope,\n    $q,\n    $compile,\n    $state\n  ) {\n    el = angular.element('<div><ui-view></ui-view></div>');\n    template = $compile(el)($rootScope);\n    $rootScope.$digest();\n\n    $state.transitionTo('aside');\n    $q.flush();\n    expect(template[0].querySelector('.aside')).toBeDefined();\n    expect(template[0].querySelector('.fwd')).toBeNull();\n\n    $state.transitionTo('A');\n    $q.flush();\n    expect(template[0].querySelector('.A')).not.toBeNull();\n    expect(template[0].querySelector('.fwd')).toBeNull();\n\n    $state.transitionTo('A.fwd');\n    $q.flush();\n    expect(template[0].querySelector('.A')).not.toBeNull();\n    expect(template[0].querySelector('.fwd')).not.toBeNull();\n    expect(template[0].querySelector('.nest')).not.toBeNull();\n    expect(count).toBe(1);\n  }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with directives which themselves have templateUrls","suites":["angular 1.5+ style .component()","routing using component templates"],"updatePoint":{"line":1084,"column":70},"line":1084,"code":"    it('should work with directives which themselves have templateUrls', function () {\n      const $state = svcs.$state,\n        $httpBackend = svcs.$httpBackend,\n        $q = svcs.$q;\n\n      $httpBackend.expectGET('/state_tpl.html').respond('x<ng12-directive data=\"$resolve.data\"></ng12-directive>x');\n      $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n\n      $state.transitionTo('cmp_tpl');\n      $q.flush();\n\n      // Template has not yet been fetched\n      let directiveEl = el[0].querySelector('div ui-view ng12-directive');\n      expect(directiveEl).toBeNull();\n      expect($state.current.name).toBe('');\n\n      // Fetch templates\n      $httpBackend.flush();\n      directiveEl = el[0].querySelector('div ui-view ng12-directive');\n      expect(directiveEl).toBeDefined();\n      expect($state.current.name).toBe('cmp_tpl');\n\n      expect(angular.element(directiveEl).data('$ng12DirectiveController')).toBeDefined();\n      expect(el.text()).toBe('x-DATA!-x');\n    });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with ng 1.3+ bindToController directives","suites":["angular 1.5+ style .component()","routing using component templates"],"updatePoint":{"line":1111,"column":62},"line":1111,"code":"      it('should work with ng 1.3+ bindToController directives', function () {\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/state_tpl.html').respond('x<ng13-directive data=\"$resolve.data\"></ng13-directive>x');\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n\n        $state.transitionTo('cmp_tpl');\n        $q.flush();\n        $httpBackend.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view ng13-directive');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('cmp_tpl');\n\n        expect(angular.element(directiveEl).data('$ng13DirectiveController')).toBeDefined();\n        expect(el.text()).toBe('x-DATA!-x');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with ng 1.5+ .component()s","suites":["angular 1.5+ style .component()","routing using component templates"],"updatePoint":{"line":1133,"column":48},"line":1133,"code":"      it('should work with ng 1.5+ .component()s', function () {\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/state_tpl.html').respond('x<ng-component data=\"$resolve.data\"></ng-component>x');\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n\n        $state.transitionTo('cmp_tpl');\n        $q.flush();\n        $httpBackend.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view ng-component');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('cmp_tpl');\n\n        expect(angular.element(directiveEl).data('$ngComponentController')).toBeDefined();\n        expect(el.text()).toBe('x-DATA!-x');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should disallow controller/template configuration","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1156,"column":57},"line":1156,"code":"    it('should disallow controller/template configuration', function () {\n      const stateDef = {\n        url: '/route2cmp',\n        component: 'ng12Directive',\n        resolve: {\n          data: function () {\n            return 'DATA!';\n          },\n        },\n      };\n\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ template: 'fail' }, stateDef));\n      }).toThrow();\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ templateUrl: 'fail.html' }, stateDef));\n      }).toThrow();\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ templateProvider: function () {} }, stateDef));\n      }).toThrow();\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ controllerAs: 'fail' }, stateDef));\n      }).toThrow();\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ controller: 'FailCtrl' }, stateDef));\n      }).toThrow();\n      expect(function () {\n        $stateProvider.state('route2cmp', extend({ controllerProvider: function () {} }, stateDef));\n      }).toThrow();\n\n      expect(function () {\n        $stateProvider.state('route2cmp', stateDef);\n      }).not.toThrow();\n    });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with angular 1.2+ directives","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1191,"column":48},"line":1191,"code":"    it('should work with angular 1.2+ directives', function () {\n      $stateProvider.state('route2cmp', {\n        url: '/route2cmp',\n        component: 'ng12Directive',\n        resolve: {\n          data: function () {\n            return 'DATA!';\n          },\n        },\n      });\n\n      const $state = svcs.$state,\n        $httpBackend = svcs.$httpBackend,\n        $q = svcs.$q;\n\n      $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n      $state.transitionTo('route2cmp');\n      $q.flush();\n      $httpBackend.flush();\n\n      const directiveEl = el[0].querySelector('div ui-view ng12-directive');\n      expect(directiveEl).toBeDefined();\n      expect($state.current.name).toBe('route2cmp');\n      expect(el.text()).toBe('-DATA!-');\n    });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with angular 1.3+ bindToComponent directives","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1218,"column":66},"line":1218,"code":"      it('should work with angular 1.3+ bindToComponent directives', function () {\n        $stateProvider.state('route2cmp', {\n          url: '/route2cmp',\n          component: 'ng13Directive',\n          resolve: {\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view ng13-directive');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('route2cmp');\n        expect(el.text()).toBe('-DATA!-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should call $onInit() once","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1244,"column":36},"line":1244,"code":"      it('should call $onInit() once', function () {\n        $stateProvider.state('route2cmp', {\n          url: '/route2cmp',\n          component: 'ng13Directive',\n          resolve: {\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        expect(log).toBe('onInit;');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with angular 1.5+ .component()s","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1269,"column":53},"line":1269,"code":"      it('should work with angular 1.5+ .component()s', function () {\n        $stateProvider.state('route2cmp', {\n          url: '/route2cmp',\n          component: 'ngComponent',\n          resolve: {\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view ng-component');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('route2cmp');\n        expect(el.text()).toBe('-DATA!-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should only call $onInit() once","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1295,"column":41},"line":1295,"code":"      it('should only call $onInit() once', function () {\n        $stateProvider.state('route2cmp', {\n          component: 'ngComponent',\n          resolve: {\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        expect(log).toBe('onInit;');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should only call $onInit() once with componentProvider","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1317,"column":64},"line":1317,"code":"      it('should only call $onInit() once with componentProvider', function () {\n        $stateProvider.state('route2cmp', {\n          componentProvider: () => 'ngComponent',\n          resolve: {\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        expect(log).toBe('onInit;');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should supply resolve data to \"<\", \"=\", \"@\" bindings","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1339,"column":62},"line":1339,"code":"      it('should supply resolve data to \"<\", \"=\", \"@\" bindings', function () {\n        $stateProvider.state('bindingtypes', {\n          component: 'bindingTypes',\n          resolve: {\n            oneway: function () {\n              return 'ONEWAY';\n            },\n            twoway: function () {\n              return 'TWOWAY';\n            },\n            attribute: function () {\n              return 'ATTRIBUTE';\n            },\n          },\n          bindings: { attr: 'attribute' },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $state.transitionTo('bindingtypes');\n        $q.flush();\n\n        expect(el.text()).toBe('-ONEWAY,TWOWAY,ATTRIBUTE-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should supply resolve data to optional \"<?\", \"=?\", \"@?\" bindings","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1366,"column":74},"line":1366,"code":"      it('should supply resolve data to optional \"<?\", \"=?\", \"@?\" bindings', function () {\n        $stateProvider.state('optionalbindingtypes', {\n          component: 'optionalBindingTypes',\n          resolve: {\n            oneway: function () {\n              return 'ONEWAY';\n            },\n            twoway: function () {\n              return 'TWOWAY';\n            },\n            attribute: function () {\n              return 'ATTRIBUTE';\n            },\n          },\n          bindings: { attr: 'attribute' },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $state.transitionTo('optionalbindingtypes');\n        $q.flush();\n\n        expect(el.text()).toBe('-ONEWAY,TWOWAY,ATTRIBUTE-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should not throw when routing to a component with output \"&\" binding","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1394,"column":78},"line":1394,"code":"      it('should not throw when routing to a component with output \"&\" binding', function () {\n        $stateProvider.state('nothrow', {\n          component: 'eventComponent',\n        });\n\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.transitionTo('nothrow');\n        $q.flush();\n\n        expect(el.text()).toBe('eventCmp');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should route to a component that is prefixed with \"data\"","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1408,"column":66},"line":1408,"code":"      it('should route to a component that is prefixed with \"data\"', function () {\n        $stateProvider.state('data', {\n          component: 'dataComponent',\n        });\n\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.transitionTo('data');\n        $q.flush();\n\n        expect(el.text()).toBe('DataComponent');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should bind a resolve that is prefixed with \"data\"","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1422,"column":60},"line":1422,"code":"      it('should bind a resolve that is prefixed with \"data\"', function () {\n        $stateProvider.state('data', {\n          component: 'mydataComponent',\n          resolve: { dataUser: () => 'user' },\n        });\n\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.transitionTo('data');\n        $q.flush();\n\n        expect(el.text()).toBe('-user-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should pass any bindings (wired from a parent component template via the ui-view) through to the child","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1437,"column":112},"line":1437,"code":"      it('should pass any bindings (wired from a parent component template via the ui-view) through to the child', inject(function (\n        $rootScope\n      ) {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n\n        $stateProvider.state('parent', {\n          template: '<ui-view oneway=\"data1w\" twoway=\"data2w\" attr=\"attrval\"></ui-view>',\n          controller: function ($scope) {\n            $scope.data1w = '1w';\n            $scope.data2w = '2w';\n          },\n        });\n\n        $stateProvider.state('parent.child', {\n          component: 'bindingTypes',\n        });\n\n        $state.transitionTo('parent.child');\n        $q.flush();\n        expect(el.text()).toEqual('-1w,2w,attrval-');\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should prefer ui-view bindings over resolve data","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1461,"column":58},"line":1461,"code":"      it('should prefer ui-view bindings over resolve data', inject(function ($rootScope) {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n\n        $stateProvider.state('parent', {\n          template: '<ui-view oneway=\"data1w\" twoway=\"data2w\" attr=\"attrval\"></ui-view>',\n          resolve: {\n            oneway: () => 'asfasfd',\n            twoway: () => 'asfasfd',\n            attr: () => 'asfasfd',\n          },\n          controller: function ($scope) {\n            $scope.data1w = '1w';\n            $scope.data2w = '2w';\n          },\n        });\n\n        $stateProvider.state('parent.child', {\n          component: 'bindingTypes',\n        });\n\n        $state.transitionTo('parent.child');\n        $q.flush();\n        expect(el.text()).toEqual('-1w,2w,attrval-');\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should prefer ui-view bindings over resolve data unless a bindings exists","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1488,"column":83},"line":1488,"code":"      it('should prefer ui-view bindings over resolve data unless a bindings exists', inject(function ($rootScope) {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n\n        $stateProvider.state('parent', {\n          template: '<ui-view oneway=\"data1w\" twoway=\"data2w\" attr=\"attrval\"></ui-view>',\n          resolve: {\n            oneway: () => 'asfasfd',\n            twoway: () => 'asfasfd',\n            attr: () => 'asfasfd',\n          },\n          controller: function ($scope) {\n            $scope.data1w = '1w';\n            $scope.data2w = '2w';\n          },\n        });\n\n        $stateProvider.state('parent.child', {\n          component: 'bindingTypes',\n          bindings: { oneway: 'oneway' },\n        });\n\n        $state.transitionTo('parent.child');\n        $q.flush();\n        expect(el.text()).toEqual('-asfasfd,2w,attrval-');\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should pass & bindings (wired from a parent component via the ui-view) through to the child","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1516,"column":101},"line":1516,"code":"      it('should pass & bindings (wired from a parent component via the ui-view) through to the child', inject(function (\n        $rootScope\n      ) {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $rootScope.log = [];\n\n        $stateProvider.state('parent', {\n          component: 'parentCallbackComponent',\n        });\n\n        $stateProvider.state('parent.child', {\n          component: 'childEventComponent',\n        });\n\n        $state.transitionTo('parent.child');\n        $q.flush();\n        expect($rootScope.log).toEqual([]);\n        expect(\n          el\n            .text()\n            .split(/\\s+/)\n            .filter((x) => x)\n        ).toEqual(['parentCmp', 'childCmp', 'Button']);\n\n        // - Click button\n        // - ng-click handler calls $ctrl.onEvent({ foo: 123, bar: 456 })\n        // - on-event is bound to $ctrl.handleEvent(foo, bar) on parentCallbackComponent\n        // - handleEvent pushes param values to the log\n        el.find('button')[0].click();\n        expect($rootScope.log).toEqual([123, 456]);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should bind & bindings to a resolve that returns a function","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1550,"column":69},"line":1550,"code":"      it('should bind & bindings to a resolve that returns a function', inject(function ($rootScope) {\n        const $state = svcs.$state,\n          $q = svcs.$q,\n          log = [];\n\n        $stateProvider.state('resolve', {\n          component: 'childEventComponent',\n          resolve: {\n            onEvent: () => (foo, bar) => {\n              log.push(foo);\n              log.push(bar);\n            },\n          },\n        });\n\n        $state.transitionTo('resolve');\n        $q.flush();\n        expect(log).toEqual([]);\n        el.find('button')[0].click();\n        expect(log).toEqual([123, 456]);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should bind & bindings to a resolve that returns an array-style function","suites":["angular 1.5+ style .component()","+ component: declaration"],"updatePoint":{"line":1573,"column":82},"line":1573,"code":"      it('should bind & bindings to a resolve that returns an array-style function', inject(function ($rootScope) {\n        const $state = svcs.$state,\n          $q = svcs.$q,\n          log = [];\n\n        $stateProvider.state('resolve', {\n          component: 'childEventComponent',\n          resolve: {\n            onEvent: () => [\n              'foo',\n              'bar',\n              (foo, bar) => {\n                log.push(foo);\n                log.push(bar);\n              },\n            ],\n          },\n        });\n\n        $state.transitionTo('resolve');\n        $q.flush();\n        expect(log).toEqual([]);\n        el.find('button')[0].click();\n        expect(log).toEqual([123, 456]);\n      }));","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should disallow controller/template configuration in the view","suites":["angular 1.5+ style .component()","+ named views with component: declaration"],"updatePoint":{"line":1625,"column":71},"line":1625,"code":"      it('should disallow controller/template configuration in the view', function () {\n        expect(function () {\n          $stateProvider.state('route2cmp', stateDef);\n        }).not.toThrow();\n        expect(function () {\n          const state = extend({}, stateDef);\n          state.views.header.template = 'fails';\n          $stateProvider.state('route2cmp', state);\n        }).toThrow();\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should render components as views","suites":["angular 1.5+ style .component()","+ named views with component: declaration"],"updatePoint":{"line":1636,"column":43},"line":1636,"code":"      it('should render components as views', function () {\n        $stateProvider.state('route2cmp', stateDef);\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        const header = el[0].querySelector('[ui-view=header]');\n        const content = el[0].querySelector('[ui-view=content]');\n\n        expect(header.textContent).toBe('#awesome#');\n        expect(content.textContent).toBe('-DATA!-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should allow a component view declaration to use a string as a shorthand","suites":["angular 1.5+ style .component()","+ named views with component: declaration"],"updatePoint":{"line":1654,"column":82},"line":1654,"code":"      it('should allow a component view declaration to use a string as a shorthand', function () {\n        stateDef = {\n          url: '/route2cmp',\n          views: { header: 'header', content: 'ngComponent' },\n          resolve: {\n            status: function () {\n              return 'awesome';\n            },\n            data: function () {\n              return 'DATA!';\n            },\n          },\n        };\n        $stateProvider.state('route2cmp', stateDef);\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        const header = el[0].querySelector('[ui-view=header]');\n        const content = el[0].querySelector('[ui-view=content]');\n\n        expect(header.textContent).toBe('#awesome#');\n        expect(content.textContent).toBe('-DATA!-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should allow different states to reuse view declaration","suites":["angular 1.5+ style .component()","+ named views with component: declaration"],"updatePoint":{"line":1685,"column":65},"line":1685,"code":"      it('should allow different states to reuse view declaration', function () {\n        const views = {\n          header: { component: 'header' },\n          content: { component: 'ngComponent' },\n        };\n\n        const stateDef1 = { name: 'def1', url: '/def1', views: views };\n        const stateDef2 = { name: 'def2', url: '/def2', views: views };\n\n        $stateProvider.state(stateDef1);\n        $stateProvider.state(stateDef2);\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should provide the named component binding with data from the named resolve","suites":["angular 1.5+ style .component()","+ bindings: declaration"],"updatePoint":{"line":1701,"column":83},"line":1701,"code":"    it('should provide the named component binding with data from the named resolve', function () {\n      $stateProvider.state('route2cmp', {\n        url: '/route2cmp',\n        component: 'ng12Directive',\n        bindings: { data: 'foo' },\n        resolve: {\n          foo: function () {\n            return 'DATA!';\n          },\n        },\n      });\n\n      const $state = svcs.$state,\n        $httpBackend = svcs.$httpBackend,\n        $q = svcs.$q;\n\n      $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}-');\n      $state.transitionTo('route2cmp');\n      $q.flush();\n      $httpBackend.flush();\n\n      const directiveEl = el[0].querySelector('div ui-view ng12-directive');\n      expect(directiveEl).toBeDefined();\n      expect($state.current.name).toBe('route2cmp');\n      expect(el.text()).toBe('-DATA!-');\n    });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should provide default bindings for any component bindings omitted in the state.bindings map","suites":["angular 1.5+ style .component()","+ bindings: declaration"],"updatePoint":{"line":1729,"column":102},"line":1729,"code":"      it('should provide default bindings for any component bindings omitted in the state.bindings map', function () {\n        $stateProvider.state('route2cmp', {\n          url: '/route2cmp',\n          component: 'ngComponent',\n          bindings: { data: 'foo' },\n          resolve: {\n            foo: function () {\n              return 'DATA!';\n            },\n            data2: function () {\n              return 'DATA2!';\n            },\n          },\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $httpBackend.expectGET('/comp_tpl.html').respond('-{{ $ctrl.data }}.{{ $ctrl.data2 }}-');\n        $state.transitionTo('route2cmp');\n        $q.flush();\n        $httpBackend.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view ng-component');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('route2cmp');\n        expect(el.text()).toBe('-DATA!.DATA2!-');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with angular 1.2+ directives","suites":["angular 1.5+ style .component()","componentProvider"],"updatePoint":{"line":1762,"column":48},"line":1762,"code":"    it('should work with angular 1.2+ directives', function () {\n      $stateProvider.state('ng12-dynamic-directive', {\n        url: '/ng12dynamicDirective/:type',\n        componentProvider: [\n          '$stateParams',\n          function ($stateParams) {\n            return $stateParams.type;\n          },\n        ],\n      });\n\n      const $state = svcs.$state,\n        $q = svcs.$q;\n\n      $state.transitionTo('ng12-dynamic-directive', { type: 'ng12DynamicDirective' });\n      $q.flush();\n\n      const directiveEl = el[0].querySelector('div ui-view ng12-dynamic-directive');\n      expect(directiveEl).toBeDefined();\n      expect($state.current.name).toBe('ng12-dynamic-directive');\n      expect(el.text()).toBe('dynamic directive');\n    });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should load correct component when using componentProvider","suites":["angular 1.5+ style .component()","componentProvider"],"updatePoint":{"line":1786,"column":68},"line":1786,"code":"      it('should load correct component when using componentProvider', function () {\n        $stateProvider.state('dynamicComponent', {\n          url: '/dynamicComponent/:type',\n          componentProvider: [\n            '$stateParams',\n            function ($stateParams) {\n              return $stateParams.type;\n            },\n          ],\n        });\n\n        const $state = svcs.$state,\n          $httpBackend = svcs.$httpBackend,\n          $q = svcs.$q;\n\n        $state.transitionTo('dynamicComponent', { type: 'dynamicComponent' });\n        $q.flush();\n\n        const directiveEl = el[0].querySelector('div ui-view dynamic-component');\n        expect(directiveEl).toBeDefined();\n        expect($state.current.name).toBe('dynamicComponent');\n        expect(el.text().trim()).toBe('dynamicComponent');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should not be called on the initial transition","suites":["angular 1.5+ style .component()","uiOnParamsChanged()"],"updatePoint":{"line":1832,"column":56},"line":1832,"code":"      it('should not be called on the initial transition', () => {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.go('dynamic', { param: 'abc' });\n        $q.flush();\n        expect(el.text().trim()).toBe('dynamicComponent');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should be called when dynamic parameters change","suites":["angular 1.5+ style .component()","uiOnParamsChanged()"],"updatePoint":{"line":1840,"column":57},"line":1840,"code":"      it('should be called when dynamic parameters change', () => {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.go('dynamic', { param: 'abc' });\n        $q.flush();\n        $state.go('dynamic', { param: 'def' });\n        $q.flush();\n\n        expect(el.text().trim()).toBe('dynamicComponent def');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"should work with componentProvider","suites":["angular 1.5+ style .component()","uiOnParamsChanged()"],"updatePoint":{"line":1851,"column":44},"line":1851,"code":"      it('should work with componentProvider', () => {\n        const $state = svcs.$state,\n          $q = svcs.$q;\n        $state.go('dynamic2', { param: 'abc' });\n        $q.flush();\n        $state.go('dynamic2', { param: 'def' });\n        $q.flush();\n\n        expect(el.text().trim()).toBe('dynamicComponent def');\n      });","file":"viewDirectiveSpec.ts","skipped":false,"dir":"test"},{"name":"can cancel a transition that would exit the view's state by returning false","suites":["view hooks","uiCanExit"],"updatePoint":{"line":76,"column":83},"line":76,"code":"    it(\"can cancel a transition that would exit the view's state by returning false\", () => {\n      $state.defaultErrorHandler(function () {});\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return false;\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('foo');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can allow the transition by returning true","suites":["view hooks","uiCanExit"],"updatePoint":{"line":91,"column":50},"line":91,"code":"    it('can allow the transition by returning true', () => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return true;\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('bar');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can allow the transition by returning nothing","suites":["view hooks","uiCanExit"],"updatePoint":{"line":105,"column":53},"line":105,"code":"    it('can allow the transition by returning nothing', () => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('bar');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can redirect the transition","suites":["view hooks","uiCanExit"],"updatePoint":{"line":118,"column":35},"line":118,"code":"    it('can redirect the transition', () => {\n      ctrl.prototype.uiCanExit = function (trans) {\n        log += 'canexit;';\n        return trans.router.stateService.target('baz');\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('baz');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can cancel the transition by returning a rejected promise","suites":["view hooks","uiCanExit"],"updatePoint":{"line":132,"column":65},"line":132,"code":"    it('can cancel the transition by returning a rejected promise', inject(($q, $state) => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return $q.reject('nope');\n      };\n      initial();\n\n      $state.defaultErrorHandler(function () {});\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('foo');\n    }));","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can wait for a promise and then reject the transition","suites":["view hooks","uiCanExit"],"updatePoint":{"line":147,"column":61},"line":147,"code":"    it('can wait for a promise and then reject the transition', inject(($timeout) => {\n      $state.defaultErrorHandler(function () {});\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return $timeout(() => {\n          log += 'delay;';\n          return false;\n        }, 1000);\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;delay;');\n      expect($state.current.name).toBe('foo');\n    }));","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"can wait for a promise and then allow the transition","suites":["view hooks","uiCanExit"],"updatePoint":{"line":165,"column":60},"line":165,"code":"    it('can wait for a promise and then allow the transition', inject(($timeout) => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return $timeout(() => {\n          log += 'delay;';\n        }, 1000);\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;delay;');\n      expect($state.current.name).toBe('bar');\n    }));","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"has 'this' bound to the controller","suites":["view hooks","uiCanExit"],"updatePoint":{"line":181,"column":42},"line":181,"code":"    it(\"has 'this' bound to the controller\", () => {\n      ctrl.prototype.uiCanExit = function () {\n        log += this.data;\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('DATA');\n      expect($state.current.name).toBe('bar');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"receives the new Transition as the first argument","suites":["view hooks","uiCanExit"],"updatePoint":{"line":194,"column":57},"line":194,"code":"    it('receives the new Transition as the first argument', () => {\n      const _state = $state;\n      ctrl.prototype.uiCanExit = function (trans) {\n        log += 'canexit;';\n        expect(typeof trans.treeChanges).toBe('function');\n        expect(trans.injector().get('$state')).toBe(_state);\n      };\n      initial();\n\n      $state.go('bar');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('bar');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"should trigger once when answered truthy even if redirected","suites":["view hooks","uiCanExit"],"updatePoint":{"line":211,"column":67},"line":211,"code":"    it('should trigger once when answered truthy even if redirected', () => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return true;\n      };\n      initial();\n\n      $state.go('redirect');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('baz');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"should trigger only once if returns a redirect","suites":["view hooks","uiCanExit"],"updatePoint":{"line":226,"column":54},"line":226,"code":"    it('should trigger only once if returns a redirect', () => {\n      ctrl.prototype.uiCanExit = function () {\n        log += 'canexit;';\n        return $state.target('bar');\n      };\n      initial();\n\n      $state.go('redirect');\n      $q.flush();\n      $timeout.flush();\n      expect(log).toBe('canexit;');\n      expect($state.current.name).toBe('bar');\n    });","file":"viewHookSpec.ts","skipped":false,"dir":"test"},{"name":"should scroll element into view after timeout","suites":["uiView","scrollIntoView"],"updatePoint":{"line":18,"column":53},"line":18,"code":"    it('should scroll element into view after timeout', inject(function ($uiViewScroll, $timeout) {\n      $uiViewScroll(elem);\n      expect(elem[0].scrollIntoView).not.toHaveBeenCalled();\n\n      $timeout.flush();\n      expect(elem[0].scrollIntoView).toHaveBeenCalled();\n    }));","file":"viewScrollSpec.ts","skipped":false,"dir":"test"},{"name":"should return the promise from the timeout","suites":["uiView","scrollIntoView"],"updatePoint":{"line":26,"column":50},"line":26,"code":"    it('should return the promise from the timeout', inject(function ($uiViewScroll, $timeout) {\n      const promise = $uiViewScroll(elem);\n\n      $timeout.flush();\n      expect(elem[0].scrollIntoView).toHaveBeenCalled();\n      expect(promise).toBeDefined();\n    }));","file":"viewScrollSpec.ts","skipped":false,"dir":"test"},{"name":"should call $anchorScroll","suites":["uiView","useAnchorScroll"],"updatePoint":{"line":45,"column":33},"line":45,"code":"    it('should call $anchorScroll', inject(function ($uiViewScroll, $anchorScroll) {\n      $uiViewScroll();\n      expect($anchorScroll).toHaveBeenCalled();\n    }));","file":"viewScrollSpec.ts","skipped":false,"dir":"test"},{"name":"uses the controllerProvider to get controller dynamically","suites":["view","controller handling"],"updatePoint":{"line":68,"column":65},"line":68,"code":"    it('uses the controllerProvider to get controller dynamically', inject(function ($view, $q) {\n      $controllerProvider.register('AcmeFooController', function ($scope, foo) {});\n      elem.append($compile('<div><ui-view></ui-view></div>')(scope));\n\n      const view = tail(path).views[0];\n      view.load();\n      $q.flush();\n      expect(ctrlExpression).toEqual('FooController as foo');\n    }));","file":"viewSpec.ts","skipped":false,"dir":"test"}]}